
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference dulwich - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-dulwich" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference dulwich
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_clone_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_clone_then_push_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_init_bare" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_annotated_tag" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_commit" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_data_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_multiple_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_swift_smokepyswiftreposmoketesttest_push_remove_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_walkpywalkertesttest_merge_of_old_branch" class="md-nav__link">
    <span class="md-ellipsis">
      test_walk.py::WalkerTest::test_merge_of_old_branch
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-dulwich"><strong>Reference (Gold)</strong>: dulwich</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1522</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">55</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">9</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1587</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1587</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_swift_smokepyswiftreposmoketesttest_clone_bare">test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...ON': '8.3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_bare (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_clone_then_push_data">test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_clone_then_push_data (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_init_bare">test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...ION': '8.3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_init_bare (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_annotated_tag">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_annotated_tag (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...N': '8.3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_branch (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_commit">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...N': '8.3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_commit (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_data_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...8.3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_data_branch (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_multiple_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_multiple_branch (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_swift_smokepyswiftreposmoketesttest_push_remove_branch">test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch</h3>
<details><summary> <pre>test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch</pre></summary><pre>
path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
>               confpath = os.environ["DULWICH_SWIFT_CFG"]

dulwich/contrib/swift.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = environ({'MODAL_IMAGE_ID': 'im-IZz1uDYqoSR6GHA3U0a9t5', 'MODAL_FUNCTION_RUNTIME': 'gvisor', 'PYTHONHASHSEED': '0', 'MO...3.3', 'PYTEST_CURRENT_TEST': 'tests/contrib/test_swift_smoke.py::SwiftRepoSmokeTest::test_push_remove_branch (setup)'})
key = 'DULWICH_SWIFT_CFG'

    def __getitem__(self, key):
        try:
            value = self._data[self.encodekey(key)]
        except KeyError:
            # raise KeyError with the original key value
>           raise KeyError(key) from None
E           KeyError: 'DULWICH_SWIFT_CFG'

/usr/lib/python3.10/os.py:680: KeyError

The above exception was the direct cause of the following exception:

cls = <class 'tests.contrib.test_swift_smoke.SwiftRepoSmokeTest'>

    @classmethod
    def setUpClass(cls):
        cls.backend = SwiftSystemBackend()
        cls.port = 9148
        cls.server_address = "localhost"
        cls.fakerepo = "fakerepo"
        cls.th_server = DulwichServer(cls.backend, cls.port)
        cls.th_server.run()
>       cls.conf = swift.load_conf()

tests/contrib/test_swift_smoke.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = None, file = None

    def load_conf(path=None, file=None):
        """Load configuration in global var CONF.

        Args:
          path: The path to the configuration file
          file: If provided read instead the file like object
        """
        conf = ConfigParser()
        if file:
            try:
                conf.read_file(file, path)
            except AttributeError:
                # read_file only exists in Python3
                conf.readfp(file)
            return conf
        confpath = None
        if not path:
            try:
                confpath = os.environ["DULWICH_SWIFT_CFG"]
            except KeyError as exc:
>               raise Exception("You need to specify a configuration file") from exc
E               Exception: You need to specify a configuration file

dulwich/contrib/swift.py:137: Exception
</pre>
</details>
<h3 id="test_walkpywalkertesttest_merge_of_old_branch">test_walk.py::WalkerTest::test_merge_of_old_branch</h3>
<details><summary> <pre>test_walk.py::WalkerTest::test_merge_of_old_branch</pre></summary><pre>
self = <TestCaseFunction test_merge_of_old_branch>
testcase = <tests.test_walk.WalkerTest testMethod=test_merge_of_old_branch>
rawexcinfo = (<class 'AssertionError'>, AssertionError("Lists differ: [<TestWalkEntry commit=b'e1170a95d4472d9035[362 chars]one>] !...?                                                                         ^^\n"), <traceback object at 0x7f38bbd00500>)
reason = ''

    def addExpectedFailure(
        self,
        testcase: unittest.TestCase,
        rawexcinfo: _SysExcInfoType,
        reason: str = "",
    ) -> None:
        try:
>           xfail(str(reason))
E           _pytest.outcomes.XFailed

.venv/lib/python3.10/site-packages/_pytest/unittest.py:295: XFailed
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/dulwich/archive.py b/dulwich/archive.py</span>
<span class="gh">index db584c66..03dcad2f 100644</span>
<span class="gd">--- a/dulwich/archive.py</span>
<span class="gi">+++ b/dulwich/archive.py</span>
<span class="gu">@@ -1,4 +1,26 @@</span>
<span class="gi">+# archive.py -- Creating an archive from a tarball</span>
<span class="gi">+# Copyright (C) 2015 Jonas Haag &lt;jonas@lophus.org&gt;</span>
<span class="gi">+# Copyright (C) 2015 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Generates tarballs for Git trees.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import posixpath
<span class="w"> </span>import stat
<span class="w"> </span>import struct
<span class="gu">@@ -19,12 +41,33 @@ class ChunkedBytesIO:</span>
<span class="w"> </span>            list_of_bytestrings)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, contents) -&gt;None:</span>
<span class="gi">+    def __init__(self, contents) -&gt; None:</span>
<span class="w"> </span>        self.contents = contents
<span class="gd">-        self.pos = 0, 0</span>
<span class="gi">+        self.pos = (0, 0)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, maxbytes=None):</span>
<span class="gi">+        if maxbytes &lt; 0:</span>
<span class="gi">+            maxbytes = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        buf = []</span>
<span class="gi">+        chunk, cursor = self.pos</span>

<span class="gi">+        while chunk &lt; len(self.contents):</span>
<span class="gi">+            if maxbytes &lt; len(self.contents[chunk]) - cursor:</span>
<span class="gi">+                buf.append(self.contents[chunk][cursor : cursor + maxbytes])</span>
<span class="gi">+                cursor += maxbytes</span>
<span class="gi">+                self.pos = (chunk, cursor)</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                buf.append(self.contents[chunk][cursor:])</span>
<span class="gi">+                maxbytes -= len(self.contents[chunk]) - cursor</span>
<span class="gi">+                chunk += 1</span>
<span class="gi">+                cursor = 0</span>
<span class="gi">+                self.pos = (chunk, cursor)</span>
<span class="gi">+        return b&quot;&quot;.join(buf)</span>

<span class="gd">-def tar_stream(store, tree, mtime, prefix=b&#39;&#39;, format=&#39;&#39;):</span>
<span class="gi">+</span>
<span class="gi">+def tar_stream(store, tree, mtime, prefix=b&quot;&quot;, format=&quot;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a tar stream for the contents of a Git tree.

<span class="w"> </span>    Returns a generator that lazily assembles a .tar.gz archive, yielding it in
<span class="gu">@@ -40,11 +83,50 @@ def tar_stream(store, tree, mtime, prefix=b&#39;&#39;, format=&#39;&#39;):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Bytestrings
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buf = BytesIO()</span>
<span class="gi">+    with closing(tarfile.open(None, f&quot;w:{format}&quot;, buf)) as tar:</span>
<span class="gi">+        if format == &quot;gz&quot;:</span>
<span class="gi">+            # Manually correct the gzip header file modification time so that</span>
<span class="gi">+            # archives created from the same Git tree are always identical.</span>
<span class="gi">+            # The gzip header file modification time is not currently</span>
<span class="gi">+            # accessible from the tarfile API, see:</span>
<span class="gi">+            # https://bugs.python.org/issue31526</span>
<span class="gi">+            buf.seek(0)</span>
<span class="gi">+            assert buf.read(2) == b&quot;\x1f\x8b&quot;, &quot;Invalid gzip header&quot;</span>
<span class="gi">+            buf.seek(4)</span>
<span class="gi">+            buf.write(struct.pack(&quot;&lt;L&quot;, mtime))</span>
<span class="gi">+            buf.seek(0, SEEK_END)</span>
<span class="gi">+</span>
<span class="gi">+        for entry_abspath, entry in _walk_tree(store, tree, prefix):</span>
<span class="gi">+            try:</span>
<span class="gi">+                blob = store[entry.sha]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # Entry probably refers to a submodule, which we don&#39;t yet</span>
<span class="gi">+                # support.</span>
<span class="gi">+                continue</span>
<span class="gi">+            data = ChunkedBytesIO(blob.chunked)</span>
<span class="gi">+</span>
<span class="gi">+            info = tarfile.TarInfo()</span>
<span class="gi">+            # tarfile only works with ascii.</span>
<span class="gi">+            info.name = entry_abspath.decode(&quot;utf-8&quot;, &quot;surrogateescape&quot;)</span>
<span class="gi">+            info.size = blob.raw_length()</span>
<span class="gi">+            info.mode = entry.mode</span>
<span class="gi">+            info.mtime = mtime</span>
<span class="gi">+</span>
<span class="gi">+            tar.addfile(info, data)</span>
<span class="gi">+            yield buf.getvalue()</span>
<span class="gi">+            buf.truncate(0)</span>
<span class="gi">+            buf.seek(0)</span>
<span class="gi">+    yield buf.getvalue()</span>


<span class="gd">-def _walk_tree(store, tree, root=b&#39;&#39;):</span>
<span class="gi">+def _walk_tree(store, tree, root=b&quot;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively walk a dulwich Tree, yielding tuples of
<span class="w"> </span>    (absolute path, TreeEntry) along the way.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for entry in tree.iteritems():</span>
<span class="gi">+        entry_abspath = posixpath.join(root, entry.path)</span>
<span class="gi">+        if stat.S_ISDIR(entry.mode):</span>
<span class="gi">+            yield from _walk_tree(store, store[entry.sha], entry_abspath)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield (entry_abspath, entry)</span>
<span class="gh">diff --git a/dulwich/bundle.py b/dulwich/bundle.py</span>
<span class="gh">index 1e9c8d04..3b08f337 100644</span>
<span class="gd">--- a/dulwich/bundle.py</span>
<span class="gi">+++ b/dulwich/bundle.py</span>
<span class="gu">@@ -1,19 +1,45 @@</span>
<span class="gi">+# bundle.py -- Bundle format support</span>
<span class="gi">+# Copyright (C) 2020 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Bundle format support.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict, List, Optional, Sequence, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>from .pack import PackData, write_pack_data


<span class="w"> </span>class Bundle:
<span class="w"> </span>    version: Optional[int]
<span class="gi">+</span>
<span class="w"> </span>    capabilities: Dict[str, str]
<span class="w"> </span>    prerequisites: List[Tuple[bytes, str]]
<span class="w"> </span>    references: Dict[str, bytes]
<span class="w"> </span>    pack_data: Union[PackData, Sequence[bytes]]

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;{type(self).__name__}(version={self.version}, capabilities={self.capabilities}, prerequisites={self.prerequisites}, references={self.references})&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;{type(self).__name__}(version={self.version}, &quot;</span>
<span class="gi">+            f&quot;capabilities={self.capabilities}, &quot;</span>
<span class="gi">+            f&quot;prerequisites={self.prerequisites}, &quot;</span>
<span class="gi">+            f&quot;references={self.references})&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, type(self)):
<span class="gu">@@ -31,6 +57,77 @@ class Bundle:</span>
<span class="w"> </span>        return True


<span class="gi">+def _read_bundle(f, version):</span>
<span class="gi">+    capabilities = {}</span>
<span class="gi">+    prerequisites = []</span>
<span class="gi">+    references = {}</span>
<span class="gi">+    line = f.readline()</span>
<span class="gi">+    if version &gt;= 3:</span>
<span class="gi">+        while line.startswith(b&quot;@&quot;):</span>
<span class="gi">+            line = line[1:].rstrip(b&quot;\n&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                key, value = line.split(b&quot;=&quot;, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                key = line</span>
<span class="gi">+                value = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = value.decode(&quot;utf-8&quot;)</span>
<span class="gi">+            capabilities[key.decode(&quot;utf-8&quot;)] = value</span>
<span class="gi">+            line = f.readline()</span>
<span class="gi">+    while line.startswith(b&quot;-&quot;):</span>
<span class="gi">+        (obj_id, comment) = line[1:].rstrip(b&quot;\n&quot;).split(b&quot; &quot;, 1)</span>
<span class="gi">+        prerequisites.append((obj_id, comment.decode(&quot;utf-8&quot;)))</span>
<span class="gi">+        line = f.readline()</span>
<span class="gi">+    while line != b&quot;\n&quot;:</span>
<span class="gi">+        (obj_id, ref) = line.rstrip(b&quot;\n&quot;).split(b&quot; &quot;, 1)</span>
<span class="gi">+        references[ref] = obj_id</span>
<span class="gi">+        line = f.readline()</span>
<span class="gi">+    pack_data = PackData.from_file(f)</span>
<span class="gi">+    ret = Bundle()</span>
<span class="gi">+    ret.references = references</span>
<span class="gi">+    ret.capabilities = capabilities</span>
<span class="gi">+    ret.prerequisites = prerequisites</span>
<span class="gi">+    ret.pack_data = pack_data</span>
<span class="gi">+    ret.version = version</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def read_bundle(f):
<span class="w"> </span>    &quot;&quot;&quot;Read a bundle file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    firstline = f.readline()</span>
<span class="gi">+    if firstline == b&quot;# v2 git bundle\n&quot;:</span>
<span class="gi">+        return _read_bundle(f, 2)</span>
<span class="gi">+    if firstline == b&quot;# v3 git bundle\n&quot;:</span>
<span class="gi">+        return _read_bundle(f, 3)</span>
<span class="gi">+    raise AssertionError(f&quot;unsupported bundle format header: {firstline!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_bundle(f, bundle):</span>
<span class="gi">+    version = bundle.version</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        if bundle.capabilities:</span>
<span class="gi">+            version = 3</span>
<span class="gi">+        else:</span>
<span class="gi">+            version = 2</span>
<span class="gi">+    if version == 2:</span>
<span class="gi">+        f.write(b&quot;# v2 git bundle\n&quot;)</span>
<span class="gi">+    elif version == 3:</span>
<span class="gi">+        f.write(b&quot;# v3 git bundle\n&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise AssertionError(&quot;unknown version %d&quot; % version)</span>
<span class="gi">+    if version == 3:</span>
<span class="gi">+        for key, value in bundle.capabilities.items():</span>
<span class="gi">+            f.write(b&quot;@&quot; + key.encode(&quot;utf-8&quot;))</span>
<span class="gi">+            if value is not None:</span>
<span class="gi">+                f.write(b&quot;=&quot; + value.encode(&quot;utf-8&quot;))</span>
<span class="gi">+            f.write(b&quot;\n&quot;)</span>
<span class="gi">+    for obj_id, comment in bundle.prerequisites:</span>
<span class="gi">+        f.write(b&quot;-%s %s\n&quot; % (obj_id, comment.encode(&quot;utf-8&quot;)))</span>
<span class="gi">+    for ref, obj_id in bundle.references.items():</span>
<span class="gi">+        f.write(b&quot;%s %s\n&quot; % (obj_id, ref))</span>
<span class="gi">+    f.write(b&quot;\n&quot;)</span>
<span class="gi">+    write_pack_data(</span>
<span class="gi">+        f.write,</span>
<span class="gi">+        num_records=len(bundle.pack_data),</span>
<span class="gi">+        records=bundle.pack_data.iter_unpacked(),</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/dulwich/cli.py b/dulwich/cli.py</span>
<span class="gh">index 0c09585d..2c619994 100755</span>
<span class="gd">--- a/dulwich/cli.py</span>
<span class="gi">+++ b/dulwich/cli.py</span>
<span class="gu">@@ -1,9 +1,32 @@</span>
<span class="gi">+#</span>
<span class="gi">+# dulwich - Simple command-line interface to Dulwich</span>
<span class="gi">+# Copyright (C) 2008-2011 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+# vim: expandtab</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Simple command-line interface to Dulwich&gt;.

<span class="w"> </span>This is a very simple command-line wrapper for Dulwich. It is by
<span class="w"> </span>no means intended to be a full-blown Git command-line interface but just
<span class="w"> </span>a way to test Dulwich.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import optparse
<span class="w"> </span>import os
<span class="gu">@@ -11,7 +34,9 @@ import signal</span>
<span class="w"> </span>import sys
<span class="w"> </span>from getopt import getopt
<span class="w"> </span>from typing import ClassVar, Dict, Optional, Type
<span class="gi">+</span>
<span class="w"> </span>from dulwich import porcelain
<span class="gi">+</span>
<span class="w"> </span>from .client import GitProtocolError, get_transport_and_path
<span class="w"> </span>from .errors import ApplyDeltaError
<span class="w"> </span>from .index import Index
<span class="gu">@@ -20,234 +45,818 @@ from .pack import Pack, sha_to_hex</span>
<span class="w"> </span>from .repo import Repo


<span class="gi">+def signal_int(signal, frame):</span>
<span class="gi">+    sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def signal_quit(signal, frame):</span>
<span class="gi">+    import pdb</span>
<span class="gi">+</span>
<span class="gi">+    pdb.set_trace()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Command:
<span class="w"> </span>    &quot;&quot;&quot;A Dulwich subcommand.&quot;&quot;&quot;

<span class="w"> </span>    def run(self, args):
<span class="w"> </span>        &quot;&quot;&quot;Run the command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.run)</span>


<span class="w"> </span>class cmd_archive(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(</span>
<span class="gi">+            &quot;--remote&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            help=&quot;Retrieve archive from specified remote repo&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_argument(&quot;committish&quot;, type=str, nargs=&quot;?&quot;)</span>
<span class="gi">+        args = parser.parse_args(args)</span>
<span class="gi">+        if args.remote:</span>
<span class="gi">+            client, path = get_transport_and_path(args.remote)</span>
<span class="gi">+            client.archive(</span>
<span class="gi">+                path,</span>
<span class="gi">+                args.committish,</span>
<span class="gi">+                sys.stdout.write,</span>
<span class="gi">+                write_error=sys.stderr.write,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            porcelain.archive(</span>
<span class="gi">+                &quot;.&quot;, args.committish, outstream=sys.stdout.buffer, errstream=sys.stderr</span>
<span class="gi">+            )</span>


<span class="w"> </span>class cmd_add(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.add(&quot;.&quot;, paths=args)</span>


<span class="w"> </span>class cmd_rm(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.rm(&quot;.&quot;, paths=args)</span>


<span class="w"> </span>class cmd_fetch_pack(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;--all&quot;, action=&quot;store_true&quot;)</span>
<span class="gi">+        parser.add_argument(&quot;location&quot;, nargs=&quot;?&quot;, type=str)</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+        client, path = get_transport_and_path(args.location)</span>
<span class="gi">+        r = Repo(&quot;.&quot;)</span>
<span class="gi">+        if args.all:</span>
<span class="gi">+            determine_wants = r.object_store.determine_wants_all</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def determine_wants(x, **kwargs):</span>
<span class="gi">+                return [y for y in args if y not in r.object_store]</span>
<span class="gi">+</span>
<span class="gi">+        client.fetch(path, r, determine_wants)</span>


<span class="w"> </span>class cmd_fetch(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        client, path = get_transport_and_path(args.pop(0))</span>
<span class="gi">+        r = Repo(&quot;.&quot;)</span>
<span class="gi">+        refs = client.fetch(path, r, progress=sys.stdout.write)</span>
<span class="gi">+        print(&quot;Remote refs:&quot;)</span>
<span class="gi">+        for item in refs.items():</span>
<span class="gi">+            print(&quot;{} -&gt; {}&quot;.format(*item))</span>


<span class="w"> </span>class cmd_for_each_ref(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;pattern&quot;, type=str, nargs=&quot;?&quot;)</span>
<span class="gi">+        args = parser.parse_args(args)</span>
<span class="gi">+        for sha, object_type, ref in porcelain.for_each_ref(&quot;.&quot;, args.pattern):</span>
<span class="gi">+            print(f&quot;{sha.decode()} {object_type.decode()}\t{ref.decode()}&quot;)</span>


<span class="w"> </span>class cmd_fsck(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        for obj, msg in porcelain.fsck(&quot;.&quot;):</span>
<span class="gi">+            print(f&quot;{obj}: {msg}&quot;)</span>


<span class="w"> </span>class cmd_log(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--reverse&quot;,</span>
<span class="gi">+            dest=&quot;reverse&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;Reverse order in which entries are printed&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--name-status&quot;,</span>
<span class="gi">+            dest=&quot;name_status&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;Print name/status for each changed file&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.log(</span>
<span class="gi">+            &quot;.&quot;,</span>
<span class="gi">+            paths=args,</span>
<span class="gi">+            reverse=options.reverse,</span>
<span class="gi">+            name_status=options.name_status,</span>
<span class="gi">+            outstream=sys.stdout,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class cmd_diff(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+</span>
<span class="gi">+        r = Repo(&quot;.&quot;)</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            commit_id = b&quot;HEAD&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            commit_id = args[0]</span>
<span class="gi">+        commit = parse_commit(r, commit_id)</span>
<span class="gi">+        parent_commit = r[commit.parents[0]]</span>
<span class="gi">+        porcelain.diff_tree(</span>
<span class="gi">+            r, parent_commit.tree, commit.tree, outstream=sys.stdout.buffer</span>
<span class="gi">+        )</span>


<span class="w"> </span>class cmd_dump_pack(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            print(&quot;Usage: dulwich dump-pack FILENAME&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+        basename, _ = os.path.splitext(args[0])</span>
<span class="gi">+        x = Pack(basename)</span>
<span class="gi">+        print(f&quot;Object names checksum: {x.name()}&quot;)</span>
<span class="gi">+        print(f&quot;Checksum: {sha_to_hex(x.get_stored_checksum())}&quot;)</span>
<span class="gi">+        if not x.check():</span>
<span class="gi">+            print(&quot;CHECKSUM DOES NOT MATCH&quot;)</span>
<span class="gi">+        print(&quot;Length: %d&quot; % len(x))</span>
<span class="gi">+        for name in x:</span>
<span class="gi">+            try:</span>
<span class="gi">+                print(f&quot;\t{x[name]}&quot;)</span>
<span class="gi">+            except KeyError as k:</span>
<span class="gi">+                print(f&quot;\t{name}: Unable to resolve base {k}&quot;)</span>
<span class="gi">+            except ApplyDeltaError as e:</span>
<span class="gi">+                print(f&quot;\t{name}: Unable to apply delta: {e!r}&quot;)</span>


<span class="w"> </span>class cmd_dump_index(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            print(&quot;Usage: dulwich dump-index FILENAME&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+        filename = args[0]</span>
<span class="gi">+        idx = Index(filename)</span>
<span class="gi">+</span>
<span class="gi">+        for o in idx:</span>
<span class="gi">+            print(o, idx[o])</span>


<span class="w"> </span>class cmd_init(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;bare&quot;])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            path = os.getcwd()</span>
<span class="gi">+        else:</span>
<span class="gi">+            path = args[0]</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.init(path, bare=(&quot;--bare&quot; in opts))</span>


<span class="w"> </span>class cmd_clone(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--bare&quot;,</span>
<span class="gi">+            dest=&quot;bare&quot;,</span>
<span class="gi">+            help=&quot;Whether to create a bare repository.&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--depth&quot;, dest=&quot;depth&quot;, type=int, help=&quot;Depth at which to fetch&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-b&quot;,</span>
<span class="gi">+            &quot;--branch&quot;,</span>
<span class="gi">+            dest=&quot;branch&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            help=(&quot;Check out branch instead of branch pointed to by remote &quot; &quot;HEAD&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--refspec&quot;,</span>
<span class="gi">+            dest=&quot;refspec&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            help=&quot;References to fetch&quot;,</span>
<span class="gi">+            action=&quot;append&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--filter&quot;,</span>
<span class="gi">+            dest=&quot;filter_spec&quot;,</span>
<span class="gi">+            type=str,</span>
<span class="gi">+            help=&quot;git-rev-list-style object filter&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;--protocol&quot;, dest=&quot;protocol&quot;, type=int, help=&quot;Git protocol version to use&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            print(&quot;usage: dulwich clone host:path [PATH]&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+        source = args.pop(0)</span>
<span class="gi">+        if len(args) &gt; 0:</span>
<span class="gi">+            target = args.pop(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            target = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            porcelain.clone(</span>
<span class="gi">+                source,</span>
<span class="gi">+                target,</span>
<span class="gi">+                bare=options.bare,</span>
<span class="gi">+                depth=options.depth,</span>
<span class="gi">+                branch=options.branch,</span>
<span class="gi">+                refspec=options.refspec,</span>
<span class="gi">+                filter_spec=options.filter_spec,</span>
<span class="gi">+                protocol_version=options.protocol,</span>
<span class="gi">+            )</span>
<span class="gi">+        except GitProtocolError as e:</span>
<span class="gi">+            print(f&quot;{e}&quot;)</span>


<span class="w"> </span>class cmd_commit(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;message&quot;])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        porcelain.commit(&quot;.&quot;, message=opts[&quot;--message&quot;])</span>


<span class="w"> </span>class cmd_commit_tree(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;message&quot;])</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            print(&quot;usage: dulwich commit-tree tree&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        porcelain.commit_tree(&quot;.&quot;, tree=args[0], message=opts[&quot;--message&quot;])</span>


<span class="w"> </span>class cmd_update_server_info(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        porcelain.update_server_info(&quot;.&quot;)</span>


<span class="w"> </span>class cmd_symbolic_ref(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;ref-name&quot;, &quot;force&quot;])</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            print(&quot;Usage: dulwich symbolic-ref REF_NAME [--force]&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+        ref_name = args.pop(0)</span>
<span class="gi">+        porcelain.symbolic_ref(&quot;.&quot;, ref_name=ref_name, force=&quot;--force&quot; in args)</span>


<span class="w"> </span>class cmd_pack_refs(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;--all&quot;, action=&quot;store_true&quot;)</span>
<span class="gi">+        # ignored, we never prune</span>
<span class="gi">+        parser.add_argument(&quot;--no-prune&quot;, action=&quot;store_true&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.pack_refs(&quot;.&quot;, all=args.all)</span>


<span class="w"> </span>class cmd_show(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;objectish&quot;, type=str, nargs=&quot;*&quot;)</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+        porcelain.show(&quot;.&quot;, args.objectish or None)</span>


<span class="w"> </span>class cmd_diff_tree(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        if len(args) &lt; 2:</span>
<span class="gi">+            print(&quot;Usage: dulwich diff-tree OLD-TREE NEW-TREE&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        porcelain.diff_tree(&quot;.&quot;, args[0], args[1])</span>


<span class="w"> </span>class cmd_rev_list(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        if len(args) &lt; 1:</span>
<span class="gi">+            print(&quot;Usage: dulwich rev-list COMMITID...&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        porcelain.rev_list(&quot;.&quot;, args)</span>


<span class="w"> </span>class cmd_tag(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-a&quot;,</span>
<span class="gi">+            &quot;--annotated&quot;,</span>
<span class="gi">+            help=&quot;Create an annotated tag.&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-s&quot;, &quot;--sign&quot;, help=&quot;Sign the annotated tag.&quot;, action=&quot;store_true&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        porcelain.tag_create(</span>
<span class="gi">+            &quot;.&quot;, args[0], annotated=options.annotated, sign=options.sign</span>
<span class="gi">+        )</span>


<span class="w"> </span>class cmd_repack(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        porcelain.repack(&quot;.&quot;)</span>


<span class="w"> </span>class cmd_reset(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;hard&quot;, &quot;soft&quot;, &quot;mixed&quot;])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        mode = &quot;&quot;</span>
<span class="gi">+        if &quot;--hard&quot; in opts:</span>
<span class="gi">+            mode = &quot;hard&quot;</span>
<span class="gi">+        elif &quot;--soft&quot; in opts:</span>
<span class="gi">+            mode = &quot;soft&quot;</span>
<span class="gi">+        elif &quot;--mixed&quot; in opts:</span>
<span class="gi">+            mode = &quot;mixed&quot;</span>
<span class="gi">+        porcelain.reset(&quot;.&quot;, mode=mode, *args)</span>


<span class="w"> </span>class cmd_daemon(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        from dulwich import log_utils</span>
<span class="gi">+</span>
<span class="gi">+        from .protocol import TCP_GIT_PORT</span>
<span class="gi">+</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-l&quot;,</span>
<span class="gi">+            &quot;--listen_address&quot;,</span>
<span class="gi">+            dest=&quot;listen_address&quot;,</span>
<span class="gi">+            default=&quot;localhost&quot;,</span>
<span class="gi">+            help=&quot;Binding IP address.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-p&quot;,</span>
<span class="gi">+            &quot;--port&quot;,</span>
<span class="gi">+            dest=&quot;port&quot;,</span>
<span class="gi">+            type=int,</span>
<span class="gi">+            default=TCP_GIT_PORT,</span>
<span class="gi">+            help=&quot;Binding TCP port.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+        log_utils.default_logging_config()</span>
<span class="gi">+        if len(args) &gt;= 1:</span>
<span class="gi">+            gitdir = args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            gitdir = &quot;.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.daemon(gitdir, address=options.listen_address, port=options.port)</span>


<span class="w"> </span>class cmd_web_daemon(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        from dulwich import log_utils</span>
<span class="gi">+</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-l&quot;,</span>
<span class="gi">+            &quot;--listen_address&quot;,</span>
<span class="gi">+            dest=&quot;listen_address&quot;,</span>
<span class="gi">+            default=&quot;&quot;,</span>
<span class="gi">+            help=&quot;Binding IP address.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-p&quot;,</span>
<span class="gi">+            &quot;--port&quot;,</span>
<span class="gi">+            dest=&quot;port&quot;,</span>
<span class="gi">+            type=int,</span>
<span class="gi">+            default=8000,</span>
<span class="gi">+            help=&quot;Binding TCP port.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+        log_utils.default_logging_config()</span>
<span class="gi">+        if len(args) &gt;= 1:</span>
<span class="gi">+            gitdir = args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            gitdir = &quot;.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        porcelain.web_daemon(gitdir, address=options.listen_address, port=options.port)</span>


<span class="w"> </span>class cmd_write_tree(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        sys.stdout.write(&quot;{}\n&quot;.format(porcelain.write_tree(&quot;.&quot;)))</span>


<span class="w"> </span>class cmd_receive_pack(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        if len(args) &gt;= 1:</span>
<span class="gi">+            gitdir = args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            gitdir = &quot;.&quot;</span>
<span class="gi">+        porcelain.receive_pack(gitdir)</span>


<span class="w"> </span>class cmd_upload_pack(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        if len(args) &gt;= 1:</span>
<span class="gi">+            gitdir = args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            gitdir = &quot;.&quot;</span>
<span class="gi">+        porcelain.upload_pack(gitdir)</span>


<span class="w"> </span>class cmd_status(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        if len(args) &gt;= 1:</span>
<span class="gi">+            gitdir = args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            gitdir = &quot;.&quot;</span>
<span class="gi">+        status = porcelain.status(gitdir)</span>
<span class="gi">+        if any(names for (kind, names) in status.staged.items()):</span>
<span class="gi">+            sys.stdout.write(&quot;Changes to be committed:\n\n&quot;)</span>
<span class="gi">+            for kind, names in status.staged.items():</span>
<span class="gi">+                for name in names:</span>
<span class="gi">+                    sys.stdout.write(</span>
<span class="gi">+                        f&quot;\t{kind}: {name.decode(sys.getfilesystemencoding())}\n&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            sys.stdout.write(&quot;\n&quot;)</span>
<span class="gi">+        if status.unstaged:</span>
<span class="gi">+            sys.stdout.write(&quot;Changes not staged for commit:\n\n&quot;)</span>
<span class="gi">+            for name in status.unstaged:</span>
<span class="gi">+                sys.stdout.write(f&quot;\t{name.decode(sys.getfilesystemencoding())}\n&quot;)</span>
<span class="gi">+            sys.stdout.write(&quot;\n&quot;)</span>
<span class="gi">+        if status.untracked:</span>
<span class="gi">+            sys.stdout.write(&quot;Untracked files:\n\n&quot;)</span>
<span class="gi">+            for name in status.untracked:</span>
<span class="gi">+                sys.stdout.write(f&quot;\t{name}\n&quot;)</span>
<span class="gi">+            sys.stdout.write(&quot;\n&quot;)</span>


<span class="w"> </span>class cmd_ls_remote(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [])</span>
<span class="gi">+        if len(args) &lt; 1:</span>
<span class="gi">+            print(&quot;Usage: dulwich ls-remote URL&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        refs = porcelain.ls_remote(args[0])</span>
<span class="gi">+        for ref in sorted(refs):</span>
<span class="gi">+            sys.stdout.write(f&quot;{ref}\t{refs[ref]}\n&quot;)</span>


<span class="w"> </span>class cmd_ls_tree(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-r&quot;,</span>
<span class="gi">+            &quot;--recursive&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;Recursively list tree contents.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        parser.add_option(&quot;--name-only&quot;, action=&quot;store_true&quot;, help=&quot;Only display name.&quot;)</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        try:</span>
<span class="gi">+            treeish = args.pop(0)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            treeish = None</span>
<span class="gi">+        porcelain.ls_tree(</span>
<span class="gi">+            &quot;.&quot;,</span>
<span class="gi">+            treeish,</span>
<span class="gi">+            outstream=sys.stdout,</span>
<span class="gi">+            recursive=options.recursive,</span>
<span class="gi">+            name_only=options.name_only,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class cmd_pack_objects(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        deltify = False</span>
<span class="gi">+        reuse_deltas = True</span>
<span class="gi">+        opts, args = getopt(args, &quot;&quot;, [&quot;stdout&quot;, &quot;deltify&quot;, &quot;no-reuse-deltas&quot;])</span>
<span class="gi">+        opts = dict(opts)</span>
<span class="gi">+        if len(args) &lt; 1 and &quot;--stdout&quot; not in opts.keys():</span>
<span class="gi">+            print(&quot;Usage: dulwich pack-objects basename&quot;)</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+        object_ids = [line.strip() for line in sys.stdin.readlines()]</span>
<span class="gi">+        if &quot;--deltify&quot; in opts.keys():</span>
<span class="gi">+            deltify = True</span>
<span class="gi">+        if &quot;--no-reuse-deltas&quot; in opts.keys():</span>
<span class="gi">+            reuse_deltas = False</span>
<span class="gi">+        if &quot;--stdout&quot; in opts.keys():</span>
<span class="gi">+            packf = getattr(sys.stdout, &quot;buffer&quot;, sys.stdout)</span>
<span class="gi">+            idxf = None</span>
<span class="gi">+            close = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            basename = args[0]</span>
<span class="gi">+            packf = open(basename + &quot;.pack&quot;, &quot;wb&quot;)</span>
<span class="gi">+            idxf = open(basename + &quot;.idx&quot;, &quot;wb&quot;)</span>
<span class="gi">+            close = [packf, idxf]</span>
<span class="gi">+        porcelain.pack_objects(</span>
<span class="gi">+            &quot;.&quot;, object_ids, packf, idxf, deltify=deltify, reuse_deltas=reuse_deltas</span>
<span class="gi">+        )</span>
<span class="gi">+        for f in close:</span>
<span class="gi">+            f.close()</span>


<span class="w"> </span>class cmd_pull(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;from_location&quot;, type=str)</span>
<span class="gi">+        parser.add_argument(&quot;refspec&quot;, type=str, nargs=&quot;*&quot;)</span>
<span class="gi">+        parser.add_argument(&quot;--filter&quot;, type=str, nargs=1)</span>
<span class="gi">+        parser.add_argument(&quot;--protocol&quot;, type=int, nargs=1)</span>
<span class="gi">+        args = parser.parse_args(args)</span>
<span class="gi">+        porcelain.pull(</span>
<span class="gi">+            &quot;.&quot;,</span>
<span class="gi">+            args.from_location or None,</span>
<span class="gi">+            args.refspec or None,</span>
<span class="gi">+            filter_spec=args.filter,</span>
<span class="gi">+            protocol_version=args.protocol_version or None,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class cmd_push(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.add_argument(&quot;-f&quot;, &quot;--force&quot;, action=&quot;store_true&quot;, help=&quot;Force&quot;)</span>
<span class="gi">+        parser.add_argument(&quot;to_location&quot;, type=str)</span>
<span class="gi">+        parser.add_argument(&quot;refspec&quot;, type=str, nargs=&quot;*&quot;)</span>
<span class="gi">+        args = parser.parse_args(argv)</span>
<span class="gi">+        try:</span>
<span class="gi">+            porcelain.push(</span>
<span class="gi">+                &quot;.&quot;, args.to_location, args.refspec or None, force=args.force</span>
<span class="gi">+            )</span>
<span class="gi">+        except porcelain.DivergedBranches:</span>
<span class="gi">+            sys.stderr.write(&quot;Diverged branches; specify --force to override&quot;)</span>
<span class="gi">+            return 1</span>


<span class="w"> </span>class cmd_remote_add(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        porcelain.remote_add(&quot;.&quot;, args[0], args[1])</span>


<span class="w"> </span>class SuperCommand(Command):
<span class="w"> </span>    subcommands: ClassVar[Dict[str, Type[Command]]] = {}
<span class="w"> </span>    default_command: ClassVar[Optional[Type[Command]]] = None

<span class="gi">+    def run(self, args):</span>
<span class="gi">+        if not args and not self.default_command:</span>
<span class="gi">+            print(</span>
<span class="gi">+                &quot;Supported subcommands: {}&quot;.format(&quot;, &quot;.join(self.subcommands.keys()))</span>
<span class="gi">+            )</span>
<span class="gi">+            return False</span>
<span class="gi">+        cmd = args[0]</span>
<span class="gi">+        try:</span>
<span class="gi">+            cmd_kls = self.subcommands[cmd]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            print(f&quot;No such subcommand: {args[0]}&quot;)</span>
<span class="gi">+            return False</span>
<span class="gi">+        return cmd_kls().run(args[1:])</span>
<span class="gi">+</span>

<span class="w"> </span>class cmd_remote(SuperCommand):
<span class="gd">-    subcommands: ClassVar[Dict[str, Type[Command]]] = {&#39;add&#39;: cmd_remote_add}</span>
<span class="gi">+    subcommands: ClassVar[Dict[str, Type[Command]]] = {</span>
<span class="gi">+        &quot;add&quot;: cmd_remote_add,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class cmd_submodule_list(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.parse_args(argv)</span>
<span class="gi">+        for path, sha in porcelain.submodule_list(&quot;.&quot;):</span>
<span class="gi">+            sys.stdout.write(f&quot; {sha} {path}\n&quot;)</span>


<span class="w"> </span>class cmd_submodule_init(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, argv):</span>
<span class="gi">+        parser = argparse.ArgumentParser()</span>
<span class="gi">+        parser.parse_args(argv)</span>
<span class="gi">+        porcelain.submodule_init(&quot;.&quot;)</span>


<span class="w"> </span>class cmd_submodule(SuperCommand):
<span class="gd">-    subcommands: ClassVar[Dict[str, Type[Command]]] = {&#39;init&#39;:</span>
<span class="gd">-        cmd_submodule_init}</span>
<span class="gi">+    subcommands: ClassVar[Dict[str, Type[Command]]] = {</span>
<span class="gi">+        &quot;init&quot;: cmd_submodule_init,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    default_command = cmd_submodule_init


<span class="w"> </span>class cmd_check_ignore(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        ret = 1</span>
<span class="gi">+        for path in porcelain.check_ignore(&quot;.&quot;, args):</span>
<span class="gi">+            print(path)</span>
<span class="gi">+            ret = 0</span>
<span class="gi">+        return ret</span>


<span class="w"> </span>class cmd_check_mailmap(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            canonical_identity = porcelain.check_mailmap(&quot;.&quot;, arg)</span>
<span class="gi">+            print(canonical_identity)</span>


<span class="w"> </span>class cmd_stash_list(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        for i, entry in porcelain.stash_list(&quot;.&quot;):</span>
<span class="gi">+            print(&quot;stash@{%d}: %s&quot; % (i, entry.message.rstrip(&quot;\n&quot;)))</span>


<span class="w"> </span>class cmd_stash_push(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        porcelain.stash_push(&quot;.&quot;)</span>
<span class="gi">+        print(&quot;Saved working directory and index state&quot;)</span>


<span class="w"> </span>class cmd_stash_pop(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        porcelain.stash_pop(&quot;.&quot;)</span>
<span class="gi">+        print(&quot;Restrored working directory and index state&quot;)</span>


<span class="w"> </span>class cmd_stash(SuperCommand):
<span class="gd">-    subcommands: ClassVar[Dict[str, Type[Command]]] = {&#39;list&#39;:</span>
<span class="gd">-        cmd_stash_list, &#39;pop&#39;: cmd_stash_pop, &#39;push&#39;: cmd_stash_push}</span>
<span class="gi">+    subcommands: ClassVar[Dict[str, Type[Command]]] = {</span>
<span class="gi">+        &quot;list&quot;: cmd_stash_list,</span>
<span class="gi">+        &quot;pop&quot;: cmd_stash_pop,</span>
<span class="gi">+        &quot;push&quot;: cmd_stash_push,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class cmd_ls_files(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        for name in porcelain.ls_files(&quot;.&quot;):</span>
<span class="gi">+            print(name)</span>


<span class="w"> </span>class cmd_describe(Command):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+        print(porcelain.describe(&quot;.&quot;))</span>


<span class="w"> </span>class cmd_help(Command):
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-commands = {&#39;add&#39;: cmd_add, &#39;archive&#39;: cmd_archive, &#39;check-ignore&#39;:</span>
<span class="gd">-    cmd_check_ignore, &#39;check-mailmap&#39;: cmd_check_mailmap, &#39;clone&#39;:</span>
<span class="gd">-    cmd_clone, &#39;commit&#39;: cmd_commit, &#39;commit-tree&#39;: cmd_commit_tree,</span>
<span class="gd">-    &#39;describe&#39;: cmd_describe, &#39;daemon&#39;: cmd_daemon, &#39;diff&#39;: cmd_diff,</span>
<span class="gd">-    &#39;diff-tree&#39;: cmd_diff_tree, &#39;dump-pack&#39;: cmd_dump_pack, &#39;dump-index&#39;:</span>
<span class="gd">-    cmd_dump_index, &#39;fetch-pack&#39;: cmd_fetch_pack, &#39;fetch&#39;: cmd_fetch,</span>
<span class="gd">-    &#39;for-each-ref&#39;: cmd_for_each_ref, &#39;fsck&#39;: cmd_fsck, &#39;help&#39;: cmd_help,</span>
<span class="gd">-    &#39;init&#39;: cmd_init, &#39;log&#39;: cmd_log, &#39;ls-files&#39;: cmd_ls_files, &#39;ls-remote&#39;:</span>
<span class="gd">-    cmd_ls_remote, &#39;ls-tree&#39;: cmd_ls_tree, &#39;pack-objects&#39;: cmd_pack_objects,</span>
<span class="gd">-    &#39;pack-refs&#39;: cmd_pack_refs, &#39;pull&#39;: cmd_pull, &#39;push&#39;: cmd_push,</span>
<span class="gd">-    &#39;receive-pack&#39;: cmd_receive_pack, &#39;remote&#39;: cmd_remote, &#39;repack&#39;:</span>
<span class="gd">-    cmd_repack, &#39;reset&#39;: cmd_reset, &#39;rev-list&#39;: cmd_rev_list, &#39;rm&#39;: cmd_rm,</span>
<span class="gd">-    &#39;show&#39;: cmd_show, &#39;stash&#39;: cmd_stash, &#39;status&#39;: cmd_status,</span>
<span class="gd">-    &#39;symbolic-ref&#39;: cmd_symbolic_ref, &#39;submodule&#39;: cmd_submodule, &#39;tag&#39;:</span>
<span class="gd">-    cmd_tag, &#39;update-server-info&#39;: cmd_update_server_info, &#39;upload-pack&#39;:</span>
<span class="gd">-    cmd_upload_pack, &#39;web-daemon&#39;: cmd_web_daemon, &#39;write-tree&#39;: cmd_write_tree</span>
<span class="gd">-    }</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    def run(self, args):</span>
<span class="gi">+        parser = optparse.OptionParser()</span>
<span class="gi">+        parser.add_option(</span>
<span class="gi">+            &quot;-a&quot;,</span>
<span class="gi">+            &quot;--all&quot;,</span>
<span class="gi">+            dest=&quot;all&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            help=&quot;List all commands.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+        if options.all:</span>
<span class="gi">+            print(&quot;Available commands:&quot;)</span>
<span class="gi">+            for cmd in sorted(commands):</span>
<span class="gi">+                print(f&quot;  {cmd}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            print(</span>
<span class="gi">+                &quot;&quot;&quot;\</span>
<span class="gi">+The dulwich command line tool is currently a very basic frontend for the</span>
<span class="gi">+Dulwich python module. For full functionality, please see the API reference.</span>
<span class="gi">+</span>
<span class="gi">+For a list of supported commands, see &#39;dulwich help -a&#39;.</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+commands = {</span>
<span class="gi">+    &quot;add&quot;: cmd_add,</span>
<span class="gi">+    &quot;archive&quot;: cmd_archive,</span>
<span class="gi">+    &quot;check-ignore&quot;: cmd_check_ignore,</span>
<span class="gi">+    &quot;check-mailmap&quot;: cmd_check_mailmap,</span>
<span class="gi">+    &quot;clone&quot;: cmd_clone,</span>
<span class="gi">+    &quot;commit&quot;: cmd_commit,</span>
<span class="gi">+    &quot;commit-tree&quot;: cmd_commit_tree,</span>
<span class="gi">+    &quot;describe&quot;: cmd_describe,</span>
<span class="gi">+    &quot;daemon&quot;: cmd_daemon,</span>
<span class="gi">+    &quot;diff&quot;: cmd_diff,</span>
<span class="gi">+    &quot;diff-tree&quot;: cmd_diff_tree,</span>
<span class="gi">+    &quot;dump-pack&quot;: cmd_dump_pack,</span>
<span class="gi">+    &quot;dump-index&quot;: cmd_dump_index,</span>
<span class="gi">+    &quot;fetch-pack&quot;: cmd_fetch_pack,</span>
<span class="gi">+    &quot;fetch&quot;: cmd_fetch,</span>
<span class="gi">+    &quot;for-each-ref&quot;: cmd_for_each_ref,</span>
<span class="gi">+    &quot;fsck&quot;: cmd_fsck,</span>
<span class="gi">+    &quot;help&quot;: cmd_help,</span>
<span class="gi">+    &quot;init&quot;: cmd_init,</span>
<span class="gi">+    &quot;log&quot;: cmd_log,</span>
<span class="gi">+    &quot;ls-files&quot;: cmd_ls_files,</span>
<span class="gi">+    &quot;ls-remote&quot;: cmd_ls_remote,</span>
<span class="gi">+    &quot;ls-tree&quot;: cmd_ls_tree,</span>
<span class="gi">+    &quot;pack-objects&quot;: cmd_pack_objects,</span>
<span class="gi">+    &quot;pack-refs&quot;: cmd_pack_refs,</span>
<span class="gi">+    &quot;pull&quot;: cmd_pull,</span>
<span class="gi">+    &quot;push&quot;: cmd_push,</span>
<span class="gi">+    &quot;receive-pack&quot;: cmd_receive_pack,</span>
<span class="gi">+    &quot;remote&quot;: cmd_remote,</span>
<span class="gi">+    &quot;repack&quot;: cmd_repack,</span>
<span class="gi">+    &quot;reset&quot;: cmd_reset,</span>
<span class="gi">+    &quot;rev-list&quot;: cmd_rev_list,</span>
<span class="gi">+    &quot;rm&quot;: cmd_rm,</span>
<span class="gi">+    &quot;show&quot;: cmd_show,</span>
<span class="gi">+    &quot;stash&quot;: cmd_stash,</span>
<span class="gi">+    &quot;status&quot;: cmd_status,</span>
<span class="gi">+    &quot;symbolic-ref&quot;: cmd_symbolic_ref,</span>
<span class="gi">+    &quot;submodule&quot;: cmd_submodule,</span>
<span class="gi">+    &quot;tag&quot;: cmd_tag,</span>
<span class="gi">+    &quot;update-server-info&quot;: cmd_update_server_info,</span>
<span class="gi">+    &quot;upload-pack&quot;: cmd_upload_pack,</span>
<span class="gi">+    &quot;web-daemon&quot;: cmd_web_daemon,</span>
<span class="gi">+    &quot;write-tree&quot;: cmd_write_tree,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main(argv=None):</span>
<span class="gi">+    if argv is None:</span>
<span class="gi">+        argv = sys.argv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if len(argv) &lt; 1:</span>
<span class="gi">+        print(&quot;Usage: dulwich &lt;{}&gt; [OPTIONS...]&quot;.format(&quot;|&quot;.join(commands.keys())))</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    cmd = argv[0]</span>
<span class="gi">+    try:</span>
<span class="gi">+        cmd_kls = commands[cmd]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        print(f&quot;No such subcommand: {cmd}&quot;)</span>
<span class="gi">+        return 1</span>
<span class="gi">+    # TODO(jelmer): Return non-0 on errors</span>
<span class="gi">+    return cmd_kls().run(argv[1:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _main():</span>
<span class="gi">+    if &quot;DULWICH_PDB&quot; in os.environ and getattr(signal, &quot;SIGQUIT&quot;, None):</span>
<span class="gi">+        signal.signal(signal.SIGQUIT, signal_quit)  # type: ignore</span>
<span class="gi">+    signal.signal(signal.SIGINT, signal_int)</span>
<span class="gi">+</span>
<span class="gi">+    sys.exit(main())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    _main()
<span class="gh">diff --git a/dulwich/client.py b/dulwich/client.py</span>
<span class="gh">index e21ee5ae..58b3cade 100644</span>
<span class="gd">--- a/dulwich/client.py</span>
<span class="gi">+++ b/dulwich/client.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# client.py -- Implementation of the client side git protocols</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Client side support for the Git protocol.

<span class="w"> </span>The Dulwich client supports the following capabilities:
<span class="gu">@@ -17,6 +37,7 @@ Known capabilities that are not supported:</span>
<span class="w"> </span> * no-progress
<span class="w"> </span> * include-tag
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>import logging
<span class="w"> </span>import os
<span class="gu">@@ -26,36 +47,104 @@ import subprocess</span>
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import closing
<span class="w"> </span>from io import BufferedReader, BytesIO
<span class="gd">-from typing import IO, TYPE_CHECKING, Callable, ClassVar, Dict, Iterable, Iterator, List, Optional, Set, Tuple, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    IO,</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="w"> </span>from urllib.parse import quote as urlquote
<span class="w"> </span>from urllib.parse import unquote as urlunquote
<span class="w"> </span>from urllib.parse import urljoin, urlparse, urlunparse, urlunsplit
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import urllib3
<span class="gi">+</span>
<span class="w"> </span>import dulwich
<span class="gi">+</span>
<span class="w"> </span>from .config import Config, apply_instead_of, get_xdg_config_home_path
<span class="w"> </span>from .errors import GitProtocolError, NotGitRepository, SendPackError
<span class="gd">-from .pack import PACK_SPOOL_FILE_MAX_SIZE, PackChunkGenerator, UnpackedObject, write_pack_from_container</span>
<span class="gd">-from .protocol import _RBUFSIZE, CAPABILITIES_REF, CAPABILITY_AGENT, CAPABILITY_DELETE_REFS, CAPABILITY_FETCH, CAPABILITY_FILTER, CAPABILITY_INCLUDE_TAG, CAPABILITY_MULTI_ACK, CAPABILITY_MULTI_ACK_DETAILED, CAPABILITY_OFS_DELTA, CAPABILITY_QUIET, CAPABILITY_REPORT_STATUS, CAPABILITY_SHALLOW, CAPABILITY_SIDE_BAND_64K, CAPABILITY_SYMREF, CAPABILITY_THIN_PACK, COMMAND_DEEPEN, COMMAND_DONE, COMMAND_HAVE, COMMAND_SHALLOW, COMMAND_UNSHALLOW, COMMAND_WANT, DEFAULT_GIT_PROTOCOL_VERSION_FETCH, DEFAULT_GIT_PROTOCOL_VERSION_SEND, GIT_PROTOCOL_VERSIONS, KNOWN_RECEIVE_CAPABILITIES, KNOWN_UPLOAD_CAPABILITIES, SIDE_BAND_CHANNEL_DATA, SIDE_BAND_CHANNEL_FATAL, SIDE_BAND_CHANNEL_PROGRESS, TCP_GIT_PORT, ZERO_SHA, HangupException, PktLineParser, Protocol, agent_string, capability_agent, extract_capabilities, extract_capability_names, parse_capability, pkt_line</span>
<span class="gi">+from .pack import (</span>
<span class="gi">+    PACK_SPOOL_FILE_MAX_SIZE,</span>
<span class="gi">+    PackChunkGenerator,</span>
<span class="gi">+    UnpackedObject,</span>
<span class="gi">+    write_pack_from_container,</span>
<span class="gi">+)</span>
<span class="gi">+from .protocol import (</span>
<span class="gi">+    _RBUFSIZE,</span>
<span class="gi">+    CAPABILITIES_REF,</span>
<span class="gi">+    CAPABILITY_AGENT,</span>
<span class="gi">+    CAPABILITY_DELETE_REFS,</span>
<span class="gi">+    CAPABILITY_FETCH,</span>
<span class="gi">+    CAPABILITY_FILTER,</span>
<span class="gi">+    CAPABILITY_INCLUDE_TAG,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gi">+    CAPABILITY_OFS_DELTA,</span>
<span class="gi">+    CAPABILITY_QUIET,</span>
<span class="gi">+    CAPABILITY_REPORT_STATUS,</span>
<span class="gi">+    CAPABILITY_SHALLOW,</span>
<span class="gi">+    CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+    CAPABILITY_SYMREF,</span>
<span class="gi">+    CAPABILITY_THIN_PACK,</span>
<span class="gi">+    COMMAND_DEEPEN,</span>
<span class="gi">+    COMMAND_DONE,</span>
<span class="gi">+    COMMAND_HAVE,</span>
<span class="gi">+    COMMAND_SHALLOW,</span>
<span class="gi">+    COMMAND_UNSHALLOW,</span>
<span class="gi">+    COMMAND_WANT,</span>
<span class="gi">+    DEFAULT_GIT_PROTOCOL_VERSION_FETCH,</span>
<span class="gi">+    DEFAULT_GIT_PROTOCOL_VERSION_SEND,</span>
<span class="gi">+    GIT_PROTOCOL_VERSIONS,</span>
<span class="gi">+    KNOWN_RECEIVE_CAPABILITIES,</span>
<span class="gi">+    KNOWN_UPLOAD_CAPABILITIES,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_DATA,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_FATAL,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_PROGRESS,</span>
<span class="gi">+    TCP_GIT_PORT,</span>
<span class="gi">+    ZERO_SHA,</span>
<span class="gi">+    HangupException,</span>
<span class="gi">+    PktLineParser,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    agent_string,</span>
<span class="gi">+    capability_agent,</span>
<span class="gi">+    extract_capabilities,</span>
<span class="gi">+    extract_capability_names,</span>
<span class="gi">+    parse_capability,</span>
<span class="gi">+    pkt_line,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .refs import PEELED_TAG_SUFFIX, _import_remote_refs, read_info_refs
<span class="w"> </span>from .repo import Repo
<span class="gi">+</span>
<span class="gi">+# url2pathname is lazily imported</span>
<span class="w"> </span>url2pathname = None
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class InvalidWants(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Invalid wants.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, wants) -&gt;None:</span>
<span class="gd">-        Exception.__init__(self,</span>
<span class="gd">-            f&#39;requested wants not in server provided refs: {wants!r}&#39;)</span>
<span class="gi">+    def __init__(self, wants) -&gt; None:</span>
<span class="gi">+        Exception.__init__(</span>
<span class="gi">+            self, f&quot;requested wants not in server provided refs: {wants!r}&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>class HTTPUnauthorized(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised when authentication fails.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, www_authenticate, url) -&gt;None:</span>
<span class="gd">-        Exception.__init__(self, &#39;No valid credentials provided&#39;)</span>
<span class="gi">+    def __init__(self, www_authenticate, url) -&gt; None:</span>
<span class="gi">+        Exception.__init__(self, &quot;No valid credentials provided&quot;)</span>
<span class="w"> </span>        self.www_authenticate = www_authenticate
<span class="w"> </span>        self.url = url

<span class="gu">@@ -63,33 +152,50 @@ class HTTPUnauthorized(Exception):</span>
<span class="w"> </span>class HTTPProxyUnauthorized(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised when proxy authentication fails.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, proxy_authenticate, url) -&gt;None:</span>
<span class="gd">-        Exception.__init__(self, &#39;No valid proxy credentials provided&#39;)</span>
<span class="gi">+    def __init__(self, proxy_authenticate, url) -&gt; None:</span>
<span class="gi">+        Exception.__init__(self, &quot;No valid proxy credentials provided&quot;)</span>
<span class="w"> </span>        self.proxy_authenticate = proxy_authenticate
<span class="w"> </span>        self.url = url


<span class="w"> </span>def _fileno_can_read(fileno):
<span class="w"> </span>    &quot;&quot;&quot;Check if a file descriptor is readable.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(select.select([fileno], [], [], 0)[0]) &gt; 0</span>


<span class="w"> </span>def _win32_peek_avail(handle):
<span class="w"> </span>    &quot;&quot;&quot;Wrapper around PeekNamedPipe to check how many bytes are available.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ctypes import byref, windll, wintypes</span>
<span class="gi">+</span>
<span class="gi">+    c_avail = wintypes.DWORD()</span>
<span class="gi">+    c_message = wintypes.DWORD()</span>
<span class="gi">+    success = windll.kernel32.PeekNamedPipe(</span>
<span class="gi">+        handle, None, 0, None, byref(c_avail), byref(c_message)</span>
<span class="gi">+    )</span>
<span class="gi">+    if not success:</span>
<span class="gi">+        raise OSError(wintypes.GetLastError())</span>
<span class="gi">+    return c_avail.value</span>


<span class="w"> </span>COMMON_CAPABILITIES = [CAPABILITY_OFS_DELTA, CAPABILITY_SIDE_BAND_64K]
<span class="gd">-UPLOAD_CAPABILITIES = [CAPABILITY_THIN_PACK, CAPABILITY_MULTI_ACK,</span>
<span class="gd">-    CAPABILITY_MULTI_ACK_DETAILED, CAPABILITY_SHALLOW, *COMMON_CAPABILITIES]</span>
<span class="gd">-RECEIVE_CAPABILITIES = [CAPABILITY_REPORT_STATUS, CAPABILITY_DELETE_REFS, *</span>
<span class="gd">-    COMMON_CAPABILITIES]</span>
<span class="gi">+UPLOAD_CAPABILITIES = [</span>
<span class="gi">+    CAPABILITY_THIN_PACK,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gi">+    CAPABILITY_SHALLOW,</span>
<span class="gi">+    *COMMON_CAPABILITIES,</span>
<span class="gi">+]</span>
<span class="gi">+RECEIVE_CAPABILITIES = [</span>
<span class="gi">+    CAPABILITY_REPORT_STATUS,</span>
<span class="gi">+    CAPABILITY_DELETE_REFS,</span>
<span class="gi">+    *COMMON_CAPABILITIES,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ReportStatusParser:
<span class="w"> </span>    &quot;&quot;&quot;Handle status as reported by servers with &#39;report-status&#39; capability.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._done = False
<span class="w"> </span>        self._pack_status = None
<span class="w"> </span>        self._ref_statuses: List[bytes] = []
<span class="gu">@@ -102,7 +208,21 @@ class ReportStatusParser:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          iterator over refs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._pack_status not in (b&quot;unpack ok&quot;, None):</span>
<span class="gi">+            raise SendPackError(self._pack_status)</span>
<span class="gi">+        for status in self._ref_statuses:</span>
<span class="gi">+            try:</span>
<span class="gi">+                status, rest = status.split(b&quot; &quot;, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # malformed response, move on to the next one</span>
<span class="gi">+                continue</span>
<span class="gi">+            if status == b&quot;ng&quot;:</span>
<span class="gi">+                ref, error = rest.split(b&quot; &quot;, 1)</span>
<span class="gi">+                yield ref, error.decode(&quot;utf-8&quot;)</span>
<span class="gi">+            elif status == b&quot;ok&quot;:</span>
<span class="gi">+                yield rest, None</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise GitProtocolError(f&quot;invalid ref status {status!r}&quot;)</span>

<span class="w"> </span>    def handle_packet(self, pkt):
<span class="w"> </span>        &quot;&quot;&quot;Handle a packet.
<span class="gu">@@ -111,7 +231,61 @@ class ReportStatusParser:</span>
<span class="w"> </span>          GitProtocolError: Raised when packets are received after a flush
<span class="w"> </span>          packet.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._done:</span>
<span class="gi">+            raise GitProtocolError(&quot;received more data after status report&quot;)</span>
<span class="gi">+        if pkt is None:</span>
<span class="gi">+            self._done = True</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._pack_status is None:</span>
<span class="gi">+            self._pack_status = pkt.strip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref_status = pkt.strip()</span>
<span class="gi">+            self._ref_statuses.append(ref_status)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def negotiate_protocol_version(proto):</span>
<span class="gi">+    pkt = proto.read_pkt_line()</span>
<span class="gi">+    if pkt == b&quot;version 2\n&quot;:</span>
<span class="gi">+        return 2</span>
<span class="gi">+    proto.unread_pkt_line(pkt)</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_server_capabilities(pkt_seq):</span>
<span class="gi">+    server_capabilities = []</span>
<span class="gi">+    for pkt in pkt_seq:</span>
<span class="gi">+        server_capabilities.append(pkt)</span>
<span class="gi">+    return set(server_capabilities)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_pkt_refs(pkt_seq, server_capabilities=None):</span>
<span class="gi">+    refs = {}</span>
<span class="gi">+    # Receive refs from server</span>
<span class="gi">+    for pkt in pkt_seq:</span>
<span class="gi">+        (sha, ref) = pkt.rstrip(b&quot;\n&quot;).split(None, 1)</span>
<span class="gi">+        if sha == b&quot;ERR&quot;:</span>
<span class="gi">+            raise GitProtocolError(ref.decode(&quot;utf-8&quot;, &quot;replace&quot;))</span>
<span class="gi">+        if server_capabilities is None:</span>
<span class="gi">+            (ref, server_capabilities) = extract_capabilities(ref)</span>
<span class="gi">+        else:  # Git protocol-v2:</span>
<span class="gi">+            try:</span>
<span class="gi">+                symref, target = ref.split(b&quot; &quot;, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                if symref and target and target[:14] == b&quot;symref-target:&quot;:</span>
<span class="gi">+                    server_capabilities.add(</span>
<span class="gi">+                        b&quot;%s=%s:%s&quot;</span>
<span class="gi">+                        % (CAPABILITY_SYMREF, symref, target.split(b&quot;:&quot;, 1)[1])</span>
<span class="gi">+                    )</span>
<span class="gi">+                    ref = symref</span>
<span class="gi">+        refs[ref] = sha</span>
<span class="gi">+</span>
<span class="gi">+    if len(refs) == 0:</span>
<span class="gi">+        return {}, set()</span>
<span class="gi">+    if refs == {CAPABILITIES_REF: ZERO_SHA}:</span>
<span class="gi">+        refs = {}</span>
<span class="gi">+    return refs, set(server_capabilities)</span>


<span class="w"> </span>class FetchPackResult:
<span class="gu">@@ -122,26 +296,53 @@ class FetchPackResult:</span>
<span class="w"> </span>      symrefs: Dictionary with remote symrefs
<span class="w"> </span>      agent: User agent string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _FORWARDED_ATTRS: ClassVar[Set[str]] = {&#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;,</span>
<span class="gd">-        &#39;get&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;,</span>
<span class="gd">-        &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;}</span>

<span class="gd">-    def __init__(self, refs, symrefs, agent, new_shallow=None,</span>
<span class="gd">-        new_unshallow=None) -&gt;None:</span>
<span class="gi">+    _FORWARDED_ATTRS: ClassVar[Set[str]] = {</span>
<span class="gi">+        &quot;clear&quot;,</span>
<span class="gi">+        &quot;copy&quot;,</span>
<span class="gi">+        &quot;fromkeys&quot;,</span>
<span class="gi">+        &quot;get&quot;,</span>
<span class="gi">+        &quot;items&quot;,</span>
<span class="gi">+        &quot;keys&quot;,</span>
<span class="gi">+        &quot;pop&quot;,</span>
<span class="gi">+        &quot;popitem&quot;,</span>
<span class="gi">+        &quot;setdefault&quot;,</span>
<span class="gi">+        &quot;update&quot;,</span>
<span class="gi">+        &quot;values&quot;,</span>
<span class="gi">+        &quot;viewitems&quot;,</span>
<span class="gi">+        &quot;viewkeys&quot;,</span>
<span class="gi">+        &quot;viewvalues&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, refs, symrefs, agent, new_shallow=None, new_unshallow=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.refs = refs
<span class="w"> </span>        self.symrefs = symrefs
<span class="w"> </span>        self.agent = agent
<span class="w"> </span>        self.new_shallow = new_shallow
<span class="w"> </span>        self.new_unshallow = new_unshallow

<span class="gi">+    def _warn_deprecated(self):</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Use FetchPackResult.refs instead.&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, dict):
<span class="w"> </span>            self._warn_deprecated()
<span class="w"> </span>            return self.refs == other
<span class="gd">-        return (self.refs == other.refs and self.symrefs == other.symrefs and</span>
<span class="gd">-            self.agent == other.agent)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.refs == other.refs</span>
<span class="gi">+            and self.symrefs == other.symrefs</span>
<span class="gi">+            and self.agent == other.agent</span>
<span class="gi">+        )</span>

<span class="gd">-    def __contains__(self, name) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name) -&gt; bool:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return name in self.refs

<span class="gu">@@ -149,7 +350,7 @@ class FetchPackResult:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return self.refs[name]

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return len(self.refs)

<span class="gu">@@ -163,10 +364,8 @@ class FetchPackResult:</span>
<span class="w"> </span>            return getattr(self.refs, name)
<span class="w"> </span>        return super().__getattribute__(name)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.refs!r}, {self.symrefs!r}, {self.agent!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.refs!r}, {self.symrefs!r}, {self.agent!r})&quot;</span>


<span class="w"> </span>class SendPackResult:
<span class="gu">@@ -178,22 +377,45 @@ class SendPackResult:</span>
<span class="w"> </span>      ref_status: Optional dictionary mapping ref name to error message (if it
<span class="w"> </span>        failed to update), or None if it was updated successfully
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _FORWARDED_ATTRS: ClassVar[Set[str]] = {&#39;clear&#39;, &#39;copy&#39;, &#39;fromkeys&#39;,</span>
<span class="gd">-        &#39;get&#39;, &#39;items&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;,</span>
<span class="gd">-        &#39;values&#39;, &#39;viewitems&#39;, &#39;viewkeys&#39;, &#39;viewvalues&#39;}</span>

<span class="gd">-    def __init__(self, refs, agent=None, ref_status=None) -&gt;None:</span>
<span class="gi">+    _FORWARDED_ATTRS: ClassVar[Set[str]] = {</span>
<span class="gi">+        &quot;clear&quot;,</span>
<span class="gi">+        &quot;copy&quot;,</span>
<span class="gi">+        &quot;fromkeys&quot;,</span>
<span class="gi">+        &quot;get&quot;,</span>
<span class="gi">+        &quot;items&quot;,</span>
<span class="gi">+        &quot;keys&quot;,</span>
<span class="gi">+        &quot;pop&quot;,</span>
<span class="gi">+        &quot;popitem&quot;,</span>
<span class="gi">+        &quot;setdefault&quot;,</span>
<span class="gi">+        &quot;update&quot;,</span>
<span class="gi">+        &quot;values&quot;,</span>
<span class="gi">+        &quot;viewitems&quot;,</span>
<span class="gi">+        &quot;viewkeys&quot;,</span>
<span class="gi">+        &quot;viewvalues&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, refs, agent=None, ref_status=None) -&gt; None:</span>
<span class="w"> </span>        self.refs = refs
<span class="w"> </span>        self.agent = agent
<span class="w"> </span>        self.ref_status = ref_status

<span class="gi">+    def _warn_deprecated(self):</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Use SendPackResult.refs instead.&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, dict):
<span class="w"> </span>            self._warn_deprecated()
<span class="w"> </span>            return self.refs == other
<span class="w"> </span>        return self.refs == other.refs and self.agent == other.agent

<span class="gd">-    def __contains__(self, name) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name) -&gt; bool:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return name in self.refs

<span class="gu">@@ -201,7 +423,7 @@ class SendPackResult:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return self.refs[name]

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        self._warn_deprecated()
<span class="w"> </span>        return len(self.refs)

<span class="gu">@@ -215,17 +437,34 @@ class SendPackResult:</span>
<span class="w"> </span>            return getattr(self.refs, name)
<span class="w"> </span>        return super().__getattribute__(name)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.refs!r}, {self.agent!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.refs!r}, {self.agent!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _read_shallow_updates(pkt_seq):</span>
<span class="gi">+    new_shallow = set()</span>
<span class="gi">+    new_unshallow = set()</span>
<span class="gi">+    for pkt in pkt_seq:</span>
<span class="gi">+        if pkt == b&quot;shallow-info\n&quot;:  # Git-protocol v2</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            cmd, sha = pkt.split(b&quot; &quot;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise GitProtocolError(f&quot;unknown command {pkt}&quot;)</span>
<span class="gi">+        if cmd == COMMAND_SHALLOW:</span>
<span class="gi">+            new_shallow.add(sha.strip())</span>
<span class="gi">+        elif cmd == COMMAND_UNSHALLOW:</span>
<span class="gi">+            new_unshallow.add(sha.strip())</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise GitProtocolError(f&quot;unknown command {pkt}&quot;)</span>
<span class="gi">+    return (new_shallow, new_unshallow)</span>


<span class="w"> </span>class _v1ReceivePackHeader:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, capabilities, old_refs, new_refs) -&gt;None:</span>
<span class="gi">+    def __init__(self, capabilities, old_refs, new_refs) -&gt; None:</span>
<span class="w"> </span>        self.want: List[bytes] = []
<span class="w"> </span>        self.have: List[bytes] = []
<span class="gd">-        self._it = self._handle_receive_pack_head(capabilities, old_refs,</span>
<span class="gd">-            new_refs)</span>
<span class="gi">+        self._it = self._handle_receive_pack_head(capabilities, old_refs, new_refs)</span>
<span class="w"> </span>        self.sent_capabilities = False

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -242,11 +481,45 @@ class _v1ReceivePackHeader:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          (have, want) tuple
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _read_side_band64k_data(pkt_seq: Iterable[bytes]) -&gt;Iterator[Tuple[int,</span>
<span class="gd">-    bytes]]:</span>
<span class="gi">+        self.have = [x for x in old_refs.values() if not x == ZERO_SHA]</span>
<span class="gi">+</span>
<span class="gi">+        for refname in new_refs:</span>
<span class="gi">+            if not isinstance(refname, bytes):</span>
<span class="gi">+                raise TypeError(f&quot;refname is not a bytestring: {refname!r}&quot;)</span>
<span class="gi">+            old_sha1 = old_refs.get(refname, ZERO_SHA)</span>
<span class="gi">+            if not isinstance(old_sha1, bytes):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;old sha1 for {refname!r} is not a bytestring: {old_sha1!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            new_sha1 = new_refs.get(refname, ZERO_SHA)</span>
<span class="gi">+            if not isinstance(new_sha1, bytes):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;old sha1 for {refname!r} is not a bytestring {new_sha1!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if old_sha1 != new_sha1:</span>
<span class="gi">+                logger.debug(</span>
<span class="gi">+                    &quot;Sending updated ref %r: %r -&gt; %r&quot;, refname, old_sha1, new_sha1</span>
<span class="gi">+                )</span>
<span class="gi">+                if self.sent_capabilities:</span>
<span class="gi">+                    yield old_sha1 + b&quot; &quot; + new_sha1 + b&quot; &quot; + refname</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield (</span>
<span class="gi">+                        old_sha1</span>
<span class="gi">+                        + b&quot; &quot;</span>
<span class="gi">+                        + new_sha1</span>
<span class="gi">+                        + b&quot; &quot;</span>
<span class="gi">+                        + refname</span>
<span class="gi">+                        + b&quot;\0&quot;</span>
<span class="gi">+                        + b&quot; &quot;.join(sorted(capabilities))</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.sent_capabilities = True</span>
<span class="gi">+            if new_sha1 not in self.have and new_sha1 != ZERO_SHA:</span>
<span class="gi">+                self.want.append(new_sha1)</span>
<span class="gi">+        yield None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _read_side_band64k_data(pkt_seq: Iterable[bytes]) -&gt; Iterator[Tuple[int, bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read per-channel data.

<span class="w"> </span>    This requires the side-band-64k capability.
<span class="gu">@@ -254,11 +527,30 @@ def _read_side_band64k_data(pkt_seq: Iterable[bytes]) -&gt;Iterator[Tuple[int,</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      pkt_seq: Sequence of packets to read
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _handle_upload_pack_head(proto, capabilities, graph_walker, wants,</span>
<span class="gd">-    can_read, depth, protocol_version):</span>
<span class="gi">+    for pkt in pkt_seq:</span>
<span class="gi">+        channel = ord(pkt[:1])</span>
<span class="gi">+        yield channel, pkt[1:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_capability(capabilities, key, value):</span>
<span class="gi">+    for capability in capabilities:</span>
<span class="gi">+        k, v = parse_capability(capability)</span>
<span class="gi">+        if k != key:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if value and value not in v.split(b&quot; &quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        return capability</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _handle_upload_pack_head(</span>
<span class="gi">+    proto,</span>
<span class="gi">+    capabilities,</span>
<span class="gi">+    graph_walker,</span>
<span class="gi">+    wants,</span>
<span class="gi">+    can_read,</span>
<span class="gi">+    depth,</span>
<span class="gi">+    protocol_version,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle the head of a &#39;git-upload-pack&#39; request.

<span class="w"> </span>    Args:
<span class="gu">@@ -271,12 +563,77 @@ def _handle_upload_pack_head(proto, capabilities, graph_walker, wants,</span>
<span class="w"> </span>      depth: Depth for request
<span class="w"> </span>      protocol_version: Neogiated Git protocol version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _handle_upload_pack_tail(proto, capabilities: Set[bytes], graph_walker,</span>
<span class="gd">-    pack_data: Callable[[bytes], None], progress: Optional[Callable[[bytes],</span>
<span class="gd">-    None]]=None, rbufsize=_RBUFSIZE, protocol_version=0):</span>
<span class="gi">+    assert isinstance(wants, list) and isinstance(wants[0], bytes)</span>
<span class="gi">+    wantcmd = COMMAND_WANT + b&quot; &quot; + wants[0]</span>
<span class="gi">+    if protocol_version is None:</span>
<span class="gi">+        protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_SEND</span>
<span class="gi">+    if protocol_version != 2:</span>
<span class="gi">+        wantcmd += b&quot; &quot; + b&quot; &quot;.join(sorted(capabilities))</span>
<span class="gi">+    wantcmd += b&quot;\n&quot;</span>
<span class="gi">+    proto.write_pkt_line(wantcmd)</span>
<span class="gi">+    for want in wants[1:]:</span>
<span class="gi">+        proto.write_pkt_line(COMMAND_WANT + b&quot; &quot; + want + b&quot;\n&quot;)</span>
<span class="gi">+    if depth not in (0, None) or getattr(graph_walker, &quot;shallow&quot;, None):</span>
<span class="gi">+        if protocol_version == 2:</span>
<span class="gi">+            if not find_capability(capabilities, CAPABILITY_FETCH, CAPABILITY_SHALLOW):</span>
<span class="gi">+                raise GitProtocolError(</span>
<span class="gi">+                    &quot;server does not support shallow capability required for &quot; &quot;depth&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        elif CAPABILITY_SHALLOW not in capabilities:</span>
<span class="gi">+            raise GitProtocolError(</span>
<span class="gi">+                &quot;server does not support shallow capability required for &quot; &quot;depth&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        for sha in graph_walker.shallow:</span>
<span class="gi">+            proto.write_pkt_line(COMMAND_SHALLOW + b&quot; &quot; + sha + b&quot;\n&quot;)</span>
<span class="gi">+        if depth is not None:</span>
<span class="gi">+            proto.write_pkt_line(</span>
<span class="gi">+                COMMAND_DEEPEN + b&quot; &quot; + str(depth).encode(&quot;ascii&quot;) + b&quot;\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        if protocol_version == 2:</span>
<span class="gi">+            proto.write_pkt_line(None)</span>
<span class="gi">+    if protocol_version != 2:</span>
<span class="gi">+        proto.write_pkt_line(None)</span>
<span class="gi">+</span>
<span class="gi">+    if depth not in (0, None):</span>
<span class="gi">+        if can_read is not None:</span>
<span class="gi">+            (new_shallow, new_unshallow) = _read_shallow_updates(proto.read_pkt_seq())</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_shallow = new_unshallow = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        new_shallow = new_unshallow = set()</span>
<span class="gi">+</span>
<span class="gi">+    have = next(graph_walker)</span>
<span class="gi">+    while have:</span>
<span class="gi">+        proto.write_pkt_line(COMMAND_HAVE + b&quot; &quot; + have + b&quot;\n&quot;)</span>
<span class="gi">+        if can_read is not None and can_read():</span>
<span class="gi">+            pkt = proto.read_pkt_line()</span>
<span class="gi">+            parts = pkt.rstrip(b&quot;\n&quot;).split(b&quot; &quot;)</span>
<span class="gi">+            if parts[0] == b&quot;ACK&quot;:</span>
<span class="gi">+                graph_walker.ack(parts[1])</span>
<span class="gi">+                if parts[2] in (b&quot;continue&quot;, b&quot;common&quot;):</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif parts[2] == b&quot;ready&quot;:</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError(</span>
<span class="gi">+                        f&quot;{parts[2]} not in (&#39;continue&#39;, &#39;ready&#39;, &#39;common)&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+        have = next(graph_walker)</span>
<span class="gi">+    proto.write_pkt_line(COMMAND_DONE + b&quot;\n&quot;)</span>
<span class="gi">+    if protocol_version == 2:</span>
<span class="gi">+        proto.write_pkt_line(None)</span>
<span class="gi">+    return (new_shallow, new_unshallow)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _handle_upload_pack_tail(</span>
<span class="gi">+    proto,</span>
<span class="gi">+    capabilities: Set[bytes],</span>
<span class="gi">+    graph_walker,</span>
<span class="gi">+    pack_data: Callable[[bytes], None],</span>
<span class="gi">+    progress: Optional[Callable[[bytes], None]] = None,</span>
<span class="gi">+    rbufsize=_RBUFSIZE,</span>
<span class="gi">+    protocol_version=0,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle the tail of a &#39;git-upload-pack&#39; request.

<span class="w"> </span>    Args:
<span class="gu">@@ -288,14 +645,59 @@ def _handle_upload_pack_tail(proto, capabilities: Set[bytes], graph_walker,</span>
<span class="w"> </span>      rbufsize: Read buffer size
<span class="w"> </span>      protocol_version: Neogiated Git protocol version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    pkt = proto.read_pkt_line()</span>
<span class="gi">+    while pkt:</span>
<span class="gi">+        parts = pkt.rstrip(b&quot;\n&quot;).split(b&quot; &quot;)</span>
<span class="gi">+        if protocol_version == 2 and parts[0] != &quot;packfile&quot;:</span>
<span class="gi">+            break</span>
<span class="gi">+        else:</span>
<span class="gi">+            if parts[0] == b&quot;ACK&quot;:</span>
<span class="gi">+                graph_walker.ack(parts[1])</span>
<span class="gi">+            if parts[0] == b&quot;NAK&quot;:</span>
<span class="gi">+                graph_walker.nak()</span>
<span class="gi">+            if len(parts) &lt; 3 or parts[2] not in (</span>
<span class="gi">+                b&quot;ready&quot;,</span>
<span class="gi">+                b&quot;continue&quot;,</span>
<span class="gi">+                b&quot;common&quot;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>
<span class="gi">+        pkt = proto.read_pkt_line()</span>
<span class="gi">+    if CAPABILITY_SIDE_BAND_64K in capabilities or protocol_version == 2:</span>
<span class="gi">+        if progress is None:</span>
<span class="gi">+            # Just ignore progress data</span>
<span class="gi">+</span>
<span class="gi">+            def progress(x):</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        for chan, data in _read_side_band64k_data(proto.read_pkt_seq()):</span>
<span class="gi">+            if chan == SIDE_BAND_CHANNEL_DATA:</span>
<span class="gi">+                pack_data(data)</span>
<span class="gi">+            elif chan == SIDE_BAND_CHANNEL_PROGRESS:</span>
<span class="gi">+                progress(data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError(&quot;Invalid sideband channel %d&quot; % chan)</span>
<span class="gi">+    else:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            data = proto.read(rbufsize)</span>
<span class="gi">+            if data == b&quot;&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            pack_data(data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO(durin42): this doesn&#39;t correctly degrade if the server doesn&#39;t</span>
<span class="gi">+# support some capabilities. This should work properly with servers</span>
<span class="gi">+# that don&#39;t support multi_ack.</span>
<span class="w"> </span>class GitClient:
<span class="w"> </span>    &quot;&quot;&quot;Git smart server client.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, thin_packs=True, report_activity=None, quiet=False,</span>
<span class="gd">-        include_tags=False, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        thin_packs=True,</span>
<span class="gi">+        report_activity=None,</span>
<span class="gi">+        quiet=False,</span>
<span class="gi">+        include_tags=False,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new GitClient instance.

<span class="w"> </span>        Args:
<span class="gu">@@ -317,7 +719,7 @@ class GitClient:</span>
<span class="w"> </span>            self._fetch_capabilities.remove(CAPABILITY_THIN_PACK)
<span class="w"> </span>        if include_tags:
<span class="w"> </span>            self._fetch_capabilities.add(CAPABILITY_INCLUDE_TAG)
<span class="gd">-        self.protocol_version = 0</span>
<span class="gi">+        self.protocol_version = 0  # will be overridden later</span>

<span class="w"> </span>    def get_url(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Retrieves full url to given path.
<span class="gu">@@ -329,7 +731,7 @@ class GitClient:</span>
<span class="w"> </span>          Url to path (as string)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_url)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_parsedurl(cls, parsedurl, **kwargs):
<span class="gu">@@ -341,11 +743,17 @@ class GitClient:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          A `GitClient` object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def send_pack(self, path, update_refs, generate_pack_data: Callable[[</span>
<span class="gd">-        Set[bytes], Set[bytes], bool], Tuple[int, Iterator[UnpackedObject]]</span>
<span class="gd">-        ], progress=None):</span>
<span class="gi">+        raise NotImplementedError(cls.from_parsedurl)</span>
<span class="gi">+</span>
<span class="gi">+    def send_pack(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        update_refs,</span>
<span class="gi">+        generate_pack_data: Callable[</span>
<span class="gi">+            [Set[bytes], Set[bytes], bool], Tuple[int, Iterator[UnpackedObject]]</span>
<span class="gi">+        ],</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Upload a pack to a remote repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -364,21 +772,121 @@ class GitClient:</span>
<span class="w"> </span>          SendPackError: if server rejects the pack data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def clone(self, path, target_path, mkdir: bool=True, bare: bool=False,</span>
<span class="gd">-        origin: Optional[str]=&#39;origin&#39;, checkout=None, branch=None,</span>
<span class="gd">-        progress=None, depth=None, ref_prefix=[], filter_spec=None,</span>
<span class="gd">-        protocol_version: Optional[int]=None) -&gt;Repo:</span>
<span class="gi">+        raise NotImplementedError(self.send_pack)</span>
<span class="gi">+</span>
<span class="gi">+    def clone(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        target_path,</span>
<span class="gi">+        mkdir: bool = True,</span>
<span class="gi">+        bare: bool = False,</span>
<span class="gi">+        origin: Optional[str] = &quot;origin&quot;,</span>
<span class="gi">+        checkout=None,</span>
<span class="gi">+        branch=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        ref_prefix=[],</span>
<span class="gi">+        filter_spec=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; Repo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clone a repository.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch(self, path: str, target: Repo, determine_wants: Optional[</span>
<span class="gd">-        Callable[[Dict[bytes, bytes], Optional[int]], List[bytes]]]=None,</span>
<span class="gd">-        progress: Optional[Callable[[bytes], None]]=None, depth: Optional[</span>
<span class="gd">-        int]=None, ref_prefix: Optional[List[bytes]]=[], filter_spec:</span>
<span class="gd">-        Optional[bytes]=None, protocol_version: Optional[int]=None</span>
<span class="gd">-        ) -&gt;FetchPackResult:</span>
<span class="gi">+        from .refs import _set_default_branch, _set_head, _set_origin_head</span>
<span class="gi">+</span>
<span class="gi">+        if mkdir:</span>
<span class="gi">+            os.mkdir(target_path)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            target = None</span>
<span class="gi">+            if not bare:</span>
<span class="gi">+                target = Repo.init(target_path)</span>
<span class="gi">+                if checkout is None:</span>
<span class="gi">+                    checkout = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                if checkout:</span>
<span class="gi">+                    raise ValueError(&quot;checkout and bare are incompatible&quot;)</span>
<span class="gi">+                target = Repo.init_bare(target_path)</span>
<span class="gi">+</span>
<span class="gi">+            # TODO(jelmer): abstract method for get_location?</span>
<span class="gi">+            if isinstance(self, (LocalGitClient, SubprocessGitClient)):</span>
<span class="gi">+                encoded_path = path.encode(&quot;utf-8&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                encoded_path = self.get_url(path).encode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            assert target is not None</span>
<span class="gi">+            if origin is not None:</span>
<span class="gi">+                target_config = target.get_config()</span>
<span class="gi">+                target_config.set(</span>
<span class="gi">+                    (b&quot;remote&quot;, origin.encode(&quot;utf-8&quot;)), b&quot;url&quot;, encoded_path</span>
<span class="gi">+                )</span>
<span class="gi">+                target_config.set(</span>
<span class="gi">+                    (b&quot;remote&quot;, origin.encode(&quot;utf-8&quot;)),</span>
<span class="gi">+                    b&quot;fetch&quot;,</span>
<span class="gi">+                    b&quot;+refs/heads/*:refs/remotes/&quot; + origin.encode(&quot;utf-8&quot;) + b&quot;/*&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                target_config.write_to_path()</span>
<span class="gi">+</span>
<span class="gi">+            ref_message = b&quot;clone: from &quot; + encoded_path</span>
<span class="gi">+            result = self.fetch(</span>
<span class="gi">+                path,</span>
<span class="gi">+                target,</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+                depth=depth,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                filter_spec=filter_spec,</span>
<span class="gi">+                protocol_version=protocol_version,</span>
<span class="gi">+            )</span>
<span class="gi">+            if origin is not None:</span>
<span class="gi">+                _import_remote_refs(</span>
<span class="gi">+                    target.refs, origin, result.refs, message=ref_message</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            origin_head = result.symrefs.get(b&quot;HEAD&quot;)</span>
<span class="gi">+            origin_sha = result.refs.get(b&quot;HEAD&quot;)</span>
<span class="gi">+            if origin is None or (origin_sha and not origin_head):</span>
<span class="gi">+                # set detached HEAD</span>
<span class="gi">+                target.refs[b&quot;HEAD&quot;] = origin_sha</span>
<span class="gi">+                head = origin_sha</span>
<span class="gi">+            else:</span>
<span class="gi">+                _set_origin_head(target.refs, origin.encode(&quot;utf-8&quot;), origin_head)</span>
<span class="gi">+                head_ref = _set_default_branch(</span>
<span class="gi">+                    target.refs,</span>
<span class="gi">+                    origin.encode(&quot;utf-8&quot;),</span>
<span class="gi">+                    origin_head,</span>
<span class="gi">+                    branch,</span>
<span class="gi">+                    ref_message,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # Update target head</span>
<span class="gi">+                if head_ref:</span>
<span class="gi">+                    head = _set_head(target.refs, head_ref, ref_message)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    head = None</span>
<span class="gi">+</span>
<span class="gi">+            if checkout and head is not None:</span>
<span class="gi">+                target.reset_index()</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            if target is not None:</span>
<span class="gi">+                target.close()</span>
<span class="gi">+            if mkdir:</span>
<span class="gi">+                import shutil</span>
<span class="gi">+</span>
<span class="gi">+                shutil.rmtree(target_path)</span>
<span class="gi">+            raise</span>
<span class="gi">+        return target</span>
<span class="gi">+</span>
<span class="gi">+    def fetch(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path: str,</span>
<span class="gi">+        target: Repo,</span>
<span class="gi">+        determine_wants: Optional[</span>
<span class="gi">+            Callable[[Dict[bytes, bytes], Optional[int]], List[bytes]]</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+        progress: Optional[Callable[[bytes], None]] = None,</span>
<span class="gi">+        depth: Optional[int] = None,</span>
<span class="gi">+        ref_prefix: Optional[List[bytes]] = [],</span>
<span class="gi">+        filter_spec: Optional[bytes] = None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; FetchPackResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch into a target repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -405,12 +913,61 @@ class GitClient:</span>
<span class="w"> </span>          Dictionary with all remote refs (not just those fetched)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if determine_wants is None:</span>
<span class="gi">+            determine_wants = target.object_store.determine_wants_all</span>
<span class="gi">+        if CAPABILITY_THIN_PACK in self._fetch_capabilities:</span>
<span class="gi">+            from tempfile import SpooledTemporaryFile</span>
<span class="gi">+</span>
<span class="gi">+            f: IO[bytes] = SpooledTemporaryFile(</span>
<span class="gi">+                max_size=PACK_SPOOL_FILE_MAX_SIZE,</span>
<span class="gi">+                prefix=&quot;incoming-&quot;,</span>
<span class="gi">+                dir=getattr(target.object_store, &quot;path&quot;, None),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            def commit():</span>
<span class="gi">+                if f.tell():</span>
<span class="gi">+                    f.seek(0)</span>
<span class="gi">+                    target.object_store.add_thin_pack(f.read, None, progress=progress)</span>
<span class="gi">+                f.close()</span>

<span class="gd">-    def fetch_pack(self, path: str, determine_wants, graph_walker,</span>
<span class="gd">-        pack_data, *, progress: Optional[Callable[[bytes], None]]=None,</span>
<span class="gd">-        depth: Optional[int]=None, ref_prefix=[], filter_spec=None,</span>
<span class="gd">-        protocol_version: Optional[int]=None):</span>
<span class="gi">+            def abort():</span>
<span class="gi">+                f.close()</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            f, commit, abort = target.object_store.add_pack()</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = self.fetch_pack(</span>
<span class="gi">+                path,</span>
<span class="gi">+                determine_wants,</span>
<span class="gi">+                target.get_graph_walker(),</span>
<span class="gi">+                f.write,</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+                depth=depth,</span>
<span class="gi">+                ref_prefix=ref_prefix,</span>
<span class="gi">+                filter_spec=filter_spec,</span>
<span class="gi">+                protocol_version=protocol_version,</span>
<span class="gi">+            )</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            abort()</span>
<span class="gi">+            raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            commit()</span>
<span class="gi">+        target.update_shallow(result.new_shallow, result.new_unshallow)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_pack(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path: str,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        pack_data,</span>
<span class="gi">+        *,</span>
<span class="gi">+        progress: Optional[Callable[[bytes], None]] = None,</span>
<span class="gi">+        depth: Optional[int] = None,</span>
<span class="gi">+        ref_prefix=[],</span>
<span class="gi">+        filter_spec=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a pack from a git smart server.

<span class="w"> </span>        Args:
<span class="gu">@@ -438,7 +995,7 @@ class GitClient:</span>
<span class="w"> </span>          FetchPackResult object

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.fetch_pack)</span>

<span class="w"> </span>    def get_refs(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the current refs from a git smart server.
<span class="gu">@@ -446,11 +1003,30 @@ class GitClient:</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          path: Path to the repo to fetch from. (as bytestring)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _handle_receive_pack_tail(self, proto: Protocol, capabilities: Set[</span>
<span class="gd">-        bytes], progress: Optional[Callable[[bytes], None]]=None) -&gt;Optional[</span>
<span class="gd">-        Dict[bytes, Optional[str]]]:</span>
<span class="gi">+        raise NotImplementedError(self.get_refs)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _should_send_pack(new_refs):</span>
<span class="gi">+        # The packfile MUST NOT be sent if the only command used is delete.</span>
<span class="gi">+        return any(sha != ZERO_SHA for sha in new_refs.values())</span>
<span class="gi">+</span>
<span class="gi">+    def _negotiate_receive_pack_capabilities(self, server_capabilities):</span>
<span class="gi">+        negotiated_capabilities = self._send_capabilities &amp; server_capabilities</span>
<span class="gi">+        agent = None</span>
<span class="gi">+        for capability in server_capabilities:</span>
<span class="gi">+            k, v = parse_capability(capability)</span>
<span class="gi">+            if k == CAPABILITY_AGENT:</span>
<span class="gi">+                agent = v</span>
<span class="gi">+        (extract_capability_names(server_capabilities) - KNOWN_RECEIVE_CAPABILITIES)</span>
<span class="gi">+        # TODO(jelmer): warn about unknown capabilities</span>
<span class="gi">+        return negotiated_capabilities, agent</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_receive_pack_tail(</span>
<span class="gi">+        self,</span>
<span class="gi">+        proto: Protocol,</span>
<span class="gi">+        capabilities: Set[bytes],</span>
<span class="gi">+        progress: Optional[Callable[[bytes], None]] = None,</span>
<span class="gi">+    ) -&gt; Optional[Dict[bytes, Optional[str]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle the tail of a &#39;git-receive-pack&#39; request.

<span class="w"> </span>        Args:
<span class="gu">@@ -463,12 +1039,88 @@ class GitClient:</span>
<span class="w"> </span>            error message if the ref failed to update
<span class="w"> </span>            None if it was updated successfully
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def archive(self, path, committish, write_data, progress=None,</span>
<span class="gd">-        write_error=None, format=None, subdirs=None, prefix=None):</span>
<span class="gi">+        if CAPABILITY_SIDE_BAND_64K in capabilities or self.protocol_version == 2:</span>
<span class="gi">+            if progress is None:</span>
<span class="gi">+</span>
<span class="gi">+                def progress(x):</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+            if CAPABILITY_REPORT_STATUS in capabilities:</span>
<span class="gi">+                assert self._report_status_parser is not None</span>
<span class="gi">+                pktline_parser = PktLineParser(self._report_status_parser.handle_packet)</span>
<span class="gi">+            for chan, data in _read_side_band64k_data(proto.read_pkt_seq()):</span>
<span class="gi">+                if chan == SIDE_BAND_CHANNEL_DATA:</span>
<span class="gi">+                    if CAPABILITY_REPORT_STATUS in capabilities:</span>
<span class="gi">+                        pktline_parser.parse(data)</span>
<span class="gi">+                elif chan == SIDE_BAND_CHANNEL_PROGRESS:</span>
<span class="gi">+                    progress(data)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError(&quot;Invalid sideband channel %d&quot; % chan)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if CAPABILITY_REPORT_STATUS in capabilities:</span>
<span class="gi">+                assert self._report_status_parser</span>
<span class="gi">+                for pkt in proto.read_pkt_seq():</span>
<span class="gi">+                    self._report_status_parser.handle_packet(pkt)</span>
<span class="gi">+        if self._report_status_parser is not None:</span>
<span class="gi">+            return dict(self._report_status_parser.check())</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _negotiate_upload_pack_capabilities(self, server_capabilities):</span>
<span class="gi">+        (extract_capability_names(server_capabilities) - KNOWN_UPLOAD_CAPABILITIES)</span>
<span class="gi">+        # TODO(jelmer): warn about unknown capabilities</span>
<span class="gi">+        symrefs = {}</span>
<span class="gi">+        agent = None</span>
<span class="gi">+        fetch_capa = None</span>
<span class="gi">+        for capability in server_capabilities:</span>
<span class="gi">+            k, v = parse_capability(capability)</span>
<span class="gi">+            if k == CAPABILITY_SYMREF:</span>
<span class="gi">+                (src, dst) = v.split(b&quot;:&quot;, 1)</span>
<span class="gi">+                symrefs[src] = dst</span>
<span class="gi">+            if k == CAPABILITY_AGENT:</span>
<span class="gi">+                agent = v</span>
<span class="gi">+            if self.protocol_version == 2 and k == CAPABILITY_FETCH:</span>
<span class="gi">+                fetch_capa = CAPABILITY_FETCH</span>
<span class="gi">+                fetch_features = []</span>
<span class="gi">+                v = v.strip()</span>
<span class="gi">+                if b&quot;shallow&quot; in v.split(b&quot; &quot;):</span>
<span class="gi">+                    fetch_features.append(CAPABILITY_SHALLOW)</span>
<span class="gi">+                if b&quot;filter&quot; in v.split(b&quot; &quot;):</span>
<span class="gi">+                    fetch_features.append(CAPABILITY_FILTER)</span>
<span class="gi">+                for i in range(len(fetch_features)):</span>
<span class="gi">+                    if i == 0:</span>
<span class="gi">+                        fetch_capa += b&quot;=&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        fetch_capa += b&quot; &quot;</span>
<span class="gi">+                    fetch_capa += fetch_features[i]</span>
<span class="gi">+</span>
<span class="gi">+        negotiated_capabilities = self._fetch_capabilities &amp; server_capabilities</span>
<span class="gi">+        if fetch_capa:</span>
<span class="gi">+            negotiated_capabilities.add(fetch_capa)</span>
<span class="gi">+        return (negotiated_capabilities, symrefs, agent)</span>
<span class="gi">+</span>
<span class="gi">+    def archive(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        committish,</span>
<span class="gi">+        write_data,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        write_error=None,</span>
<span class="gi">+        format=None,</span>
<span class="gi">+        subdirs=None,</span>
<span class="gi">+        prefix=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve an archive of the specified tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.archive)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _warn_filter_objects():</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;object filtering not recognized by server, ignoring&quot;,</span>
<span class="gi">+            UserWarning,</span>
<span class="gi">+        )</span>


<span class="w"> </span>def check_wants(wants, refs):
<span class="gu">@@ -478,14 +1130,29 @@ def check_wants(wants, refs):</span>
<span class="w"> </span>      wants: Set of object SHAs to fetch
<span class="w"> </span>      refs: Refs dictionary to check against
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    missing = set(wants) - {</span>
<span class="gi">+        v for (k, v) in refs.items() if not k.endswith(PEELED_TAG_SUFFIX)</span>
<span class="gi">+    }</span>
<span class="gi">+    if missing:</span>
<span class="gi">+        raise InvalidWants(missing)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remote_error_from_stderr(stderr):</span>
<span class="gi">+    if stderr is None:</span>
<span class="gi">+        return HangupException()</span>
<span class="gi">+    lines = [line.rstrip(b&quot;\n&quot;) for line in stderr.readlines()]</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if line.startswith(b&quot;ERROR: &quot;):</span>
<span class="gi">+            return GitProtocolError(line[len(b&quot;ERROR: &quot;) :].decode(&quot;utf-8&quot;, &quot;replace&quot;))</span>
<span class="gi">+    return HangupException(lines)</span>


<span class="w"> </span>class TraditionalGitClient(GitClient):
<span class="w"> </span>    &quot;&quot;&quot;Traditional Git client.&quot;&quot;&quot;
<span class="gd">-    DEFAULT_ENCODING = &#39;utf-8&#39;</span>

<span class="gd">-    def __init__(self, path_encoding=DEFAULT_ENCODING, **kwargs) -&gt;None:</span>
<span class="gi">+    DEFAULT_ENCODING = &quot;utf-8&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, path_encoding=DEFAULT_ENCODING, **kwargs) -&gt; None:</span>
<span class="w"> </span>        self._remote_path_encoding = path_encoding
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gu">@@ -504,7 +1171,7 @@ class TraditionalGitClient(GitClient):</span>
<span class="w"> </span>          protocol_version: Desired Git protocol version. By default the highest
<span class="w"> </span>            mutually supported protocol version will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def send_pack(self, path, update_refs, generate_pack_data, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Upload a pack to a remote repository.
<span class="gu">@@ -525,11 +1192,93 @@ class TraditionalGitClient(GitClient):</span>
<span class="w"> </span>          SendPackError: if server rejects the pack data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_SEND</span>
<span class="gi">+        proto, unused_can_read, stderr = self._connect(b&quot;receive-pack&quot;, path)</span>
<span class="gi">+        with proto:</span>
<span class="gi">+            try:</span>
<span class="gi">+                old_refs, server_capabilities = read_pkt_refs(proto.read_pkt_seq())</span>
<span class="gi">+            except HangupException as exc:</span>
<span class="gi">+                raise _remote_error_from_stderr(stderr) from exc</span>
<span class="gi">+            (</span>
<span class="gi">+                negotiated_capabilities,</span>
<span class="gi">+                agent,</span>
<span class="gi">+            ) = self._negotiate_receive_pack_capabilities(server_capabilities)</span>
<span class="gi">+            if CAPABILITY_REPORT_STATUS in negotiated_capabilities:</span>
<span class="gi">+                self._report_status_parser = ReportStatusParser()</span>
<span class="gi">+            report_status_parser = self._report_status_parser</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_refs = orig_new_refs = update_refs(dict(old_refs))</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            if set(new_refs.items()).issubset(set(old_refs.items())):</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                return SendPackResult(new_refs, agent=agent, ref_status={})</span>
<span class="gi">+</span>
<span class="gi">+            if CAPABILITY_DELETE_REFS not in server_capabilities:</span>
<span class="gi">+                # Server does not support deletions. Fail later.</span>
<span class="gi">+                new_refs = dict(orig_new_refs)</span>
<span class="gi">+                for ref, sha in orig_new_refs.items():</span>
<span class="gi">+                    if sha == ZERO_SHA:</span>
<span class="gi">+                        if CAPABILITY_REPORT_STATUS in negotiated_capabilities:</span>
<span class="gi">+                            report_status_parser._ref_statuses.append(</span>
<span class="gi">+                                b&quot;ng &quot; + ref + b&quot; remote does not support deleting refs&quot;</span>
<span class="gi">+                            )</span>
<span class="gi">+                            report_status_parser._ref_status_ok = False</span>
<span class="gi">+                        del new_refs[ref]</span>
<span class="gi">+</span>
<span class="gi">+            if new_refs is None:</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                return SendPackResult(old_refs, agent=agent, ref_status={})</span>
<span class="gi">+</span>
<span class="gi">+            if len(new_refs) == 0 and orig_new_refs:</span>
<span class="gi">+                # NOOP - Original new refs filtered out by policy</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                if report_status_parser is not None:</span>
<span class="gi">+                    ref_status = dict(report_status_parser.check())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ref_status = None</span>
<span class="gi">+                return SendPackResult(old_refs, agent=agent, ref_status=ref_status)</span>
<span class="gi">+</span>
<span class="gi">+            header_handler = _v1ReceivePackHeader(</span>
<span class="gi">+                negotiated_capabilities, old_refs, new_refs</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            for pkt in header_handler:</span>
<span class="gi">+                proto.write_pkt_line(pkt)</span>

<span class="gd">-    def fetch_pack(self, path, determine_wants, graph_walker, pack_data,</span>
<span class="gd">-        progress=None, depth=None, ref_prefix=[], filter_spec=None,</span>
<span class="gd">-        protocol_version: Optional[int]=None):</span>
<span class="gi">+            pack_data_count, pack_data = generate_pack_data(</span>
<span class="gi">+                header_handler.have,</span>
<span class="gi">+                header_handler.want,</span>
<span class="gi">+                ofs_delta=(CAPABILITY_OFS_DELTA in negotiated_capabilities),</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if self._should_send_pack(new_refs):</span>
<span class="gi">+                for chunk in PackChunkGenerator(</span>
<span class="gi">+                    pack_data_count, pack_data, progress=progress</span>
<span class="gi">+                ):</span>
<span class="gi">+                    proto.write(chunk)</span>
<span class="gi">+</span>
<span class="gi">+            ref_status = self._handle_receive_pack_tail(</span>
<span class="gi">+                proto, negotiated_capabilities, progress</span>
<span class="gi">+            )</span>
<span class="gi">+            return SendPackResult(new_refs, agent=agent, ref_status=ref_status)</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_pack(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        pack_data,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        ref_prefix=[],</span>
<span class="gi">+        filter_spec=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a pack from a git smart server.

<span class="w"> </span>        Args:
<span class="gu">@@ -557,48 +1306,362 @@ class TraditionalGitClient(GitClient):</span>
<span class="w"> </span>          FetchPackResult object

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            protocol_version is not None</span>
<span class="gi">+            and protocol_version not in GIT_PROTOCOL_VERSIONS</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(&quot;unknown Git protocol version %d&quot; % protocol_version)</span>
<span class="gi">+        proto, can_read, stderr = self._connect(b&quot;upload-pack&quot;, path, protocol_version)</span>
<span class="gi">+        server_protocol_version = negotiate_protocol_version(proto)</span>
<span class="gi">+        if server_protocol_version not in GIT_PROTOCOL_VERSIONS:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;unknown Git protocol version %d used by server&quot;</span>
<span class="gi">+                % server_protocol_version</span>
<span class="gi">+            )</span>
<span class="gi">+        if protocol_version and server_protocol_version &gt; protocol_version:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;bad Git protocol version %d used by server&quot; % server_protocol_version</span>
<span class="gi">+            )</span>
<span class="gi">+        self.protocol_version = server_protocol_version</span>
<span class="gi">+        with proto:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if self.protocol_version == 2:</span>
<span class="gi">+                    server_capabilities = read_server_capabilities(proto.read_pkt_seq())</span>
<span class="gi">+                    refs = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    refs, server_capabilities = read_pkt_refs(proto.read_pkt_seq())</span>
<span class="gi">+            except HangupException as exc:</span>
<span class="gi">+                raise _remote_error_from_stderr(stderr) from exc</span>
<span class="gi">+            (</span>
<span class="gi">+                negotiated_capabilities,</span>
<span class="gi">+                symrefs,</span>
<span class="gi">+                agent,</span>
<span class="gi">+            ) = self._negotiate_upload_pack_capabilities(server_capabilities)</span>
<span class="gi">+</span>
<span class="gi">+            if self.protocol_version == 2:</span>
<span class="gi">+                proto.write_pkt_line(b&quot;command=ls-refs\n&quot;)</span>
<span class="gi">+                proto.write(b&quot;0001&quot;)  # delim-pkt</span>
<span class="gi">+                proto.write_pkt_line(b&quot;symrefs&quot;)</span>
<span class="gi">+                for prefix in ref_prefix:</span>
<span class="gi">+                    proto.write_pkt_line(b&quot;ref-prefix &quot; + prefix)</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                refs, server_capabilities = read_pkt_refs(</span>
<span class="gi">+                    proto.read_pkt_seq(), server_capabilities</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if refs is None:</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                return FetchPackResult(refs, symrefs, agent)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                if depth is not None:</span>
<span class="gi">+                    wants = determine_wants(refs, depth=depth)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    wants = determine_wants(refs)</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                raise</span>
<span class="gi">+            if wants is not None:</span>
<span class="gi">+                wants = [cid for cid in wants if cid != ZERO_SHA]</span>
<span class="gi">+            if not wants:</span>
<span class="gi">+                proto.write_pkt_line(None)</span>
<span class="gi">+                return FetchPackResult(refs, symrefs, agent)</span>
<span class="gi">+            if self.protocol_version == 2:</span>
<span class="gi">+                proto.write_pkt_line(b&quot;command=fetch\n&quot;)</span>
<span class="gi">+                proto.write(b&quot;0001&quot;)  # delim-pkt</span>
<span class="gi">+                if (</span>
<span class="gi">+                    find_capability(</span>
<span class="gi">+                        negotiated_capabilities, CAPABILITY_FETCH, CAPABILITY_FILTER</span>
<span class="gi">+                    )</span>
<span class="gi">+                    and filter_spec</span>
<span class="gi">+                ):</span>
<span class="gi">+                    proto.write(pkt_line(b&quot;filter %s\n&quot; % filter_spec))</span>
<span class="gi">+                elif filter_spec:</span>
<span class="gi">+                    self._warn_filter_objects()</span>
<span class="gi">+            elif filter_spec:</span>
<span class="gi">+                self._warn_filter_objects()</span>
<span class="gi">+            (new_shallow, new_unshallow) = _handle_upload_pack_head(</span>
<span class="gi">+                proto,</span>
<span class="gi">+                negotiated_capabilities,</span>
<span class="gi">+                graph_walker,</span>
<span class="gi">+                wants,</span>
<span class="gi">+                can_read,</span>
<span class="gi">+                depth=depth,</span>
<span class="gi">+                protocol_version=self.protocol_version,</span>
<span class="gi">+            )</span>
<span class="gi">+            _handle_upload_pack_tail(</span>
<span class="gi">+                proto,</span>
<span class="gi">+                negotiated_capabilities,</span>
<span class="gi">+                graph_walker,</span>
<span class="gi">+                pack_data,</span>
<span class="gi">+                progress,</span>
<span class="gi">+                protocol_version=self.protocol_version,</span>
<span class="gi">+            )</span>
<span class="gi">+            return FetchPackResult(refs, symrefs, agent, new_shallow, new_unshallow)</span>

<span class="w"> </span>    def get_refs(self, path, protocol_version=None):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the current refs from a git smart server.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # stock `git ls-remote` uses upload-pack</span>
<span class="gi">+        if (</span>
<span class="gi">+            protocol_version is not None</span>
<span class="gi">+            and protocol_version not in GIT_PROTOCOL_VERSIONS</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(&quot;unknown Git protocol version %d&quot; % protocol_version)</span>
<span class="gi">+        proto, _, stderr = self._connect(b&quot;upload-pack&quot;, path, protocol_version)</span>
<span class="gi">+        server_protocol_version = negotiate_protocol_version(proto)</span>
<span class="gi">+        if server_protocol_version not in GIT_PROTOCOL_VERSIONS:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;unknown Git protocol version %d used by server&quot;</span>
<span class="gi">+                % server_protocol_version</span>
<span class="gi">+            )</span>
<span class="gi">+        if protocol_version and server_protocol_version &gt; protocol_version:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;bad Git protocol version %d used by server&quot; % server_protocol_version</span>
<span class="gi">+            )</span>
<span class="gi">+        self.protocol_version = server_protocol_version</span>
<span class="gi">+        if self.protocol_version == 2:</span>
<span class="gi">+            server_capabilities = read_server_capabilities(proto.read_pkt_seq())</span>
<span class="gi">+            proto.write_pkt_line(b&quot;command=ls-refs\n&quot;)</span>
<span class="gi">+            proto.write(b&quot;0001&quot;)  # delim-pkt</span>
<span class="gi">+            proto.write_pkt_line(b&quot;symrefs&quot;)</span>
<span class="gi">+            proto.write_pkt_line(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            server_capabilities = None  # read_pkt_refs will find them</span>
<span class="gi">+        with proto:</span>
<span class="gi">+            try:</span>
<span class="gi">+                refs, server_capabilities = read_pkt_refs(</span>
<span class="gi">+                    proto.read_pkt_seq(), server_capabilities</span>
<span class="gi">+                )</span>
<span class="gi">+            except HangupException as exc:</span>
<span class="gi">+                raise _remote_error_from_stderr(stderr) from exc</span>
<span class="gi">+            proto.write_pkt_line(None)</span>
<span class="gi">+            return refs</span>
<span class="gi">+</span>
<span class="gi">+    def archive(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        committish,</span>
<span class="gi">+        write_data,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        write_error=None,</span>
<span class="gi">+        format=None,</span>
<span class="gi">+        subdirs=None,</span>
<span class="gi">+        prefix=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        proto, can_read, stderr = self._connect(b&quot;upload-archive&quot;, path)</span>
<span class="gi">+        with proto:</span>
<span class="gi">+            if format is not None:</span>
<span class="gi">+                proto.write_pkt_line(b&quot;argument --format=&quot; + format)</span>
<span class="gi">+            proto.write_pkt_line(b&quot;argument &quot; + committish)</span>
<span class="gi">+            if subdirs is not None:</span>
<span class="gi">+                for subdir in subdirs:</span>
<span class="gi">+                    proto.write_pkt_line(b&quot;argument &quot; + subdir)</span>
<span class="gi">+            if prefix is not None:</span>
<span class="gi">+                proto.write_pkt_line(b&quot;argument --prefix=&quot; + prefix)</span>
<span class="gi">+            proto.write_pkt_line(None)</span>
<span class="gi">+            try:</span>
<span class="gi">+                pkt = proto.read_pkt_line()</span>
<span class="gi">+            except HangupException as exc:</span>
<span class="gi">+                raise _remote_error_from_stderr(stderr) from exc</span>
<span class="gi">+            if pkt == b&quot;NACK\n&quot; or pkt == b&quot;NACK&quot;:</span>
<span class="gi">+                return</span>
<span class="gi">+            elif pkt == b&quot;ACK\n&quot; or pkt == b&quot;ACK&quot;:</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif pkt.startswith(b&quot;ERR &quot;):</span>
<span class="gi">+                raise GitProtocolError(pkt[4:].rstrip(b&quot;\n&quot;).decode(&quot;utf-8&quot;, &quot;replace&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError(f&quot;invalid response {pkt!r}&quot;)</span>
<span class="gi">+            ret = proto.read_pkt_line()</span>
<span class="gi">+            if ret is not None:</span>
<span class="gi">+                raise AssertionError(&quot;expected pkt tail&quot;)</span>
<span class="gi">+            for chan, data in _read_side_band64k_data(proto.read_pkt_seq()):</span>
<span class="gi">+                if chan == SIDE_BAND_CHANNEL_DATA:</span>
<span class="gi">+                    write_data(data)</span>
<span class="gi">+                elif chan == SIDE_BAND_CHANNEL_PROGRESS:</span>
<span class="gi">+                    progress(data)</span>
<span class="gi">+                elif chan == SIDE_BAND_CHANNEL_FATAL:</span>
<span class="gi">+                    write_error(data)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError(&quot;Invalid sideband channel %d&quot; % chan)</span>


<span class="w"> </span>class TCPGitClient(TraditionalGitClient):
<span class="w"> </span>    &quot;&quot;&quot;A Git Client that works over TCP directly (i.e. git://).&quot;&quot;&quot;

<span class="gd">-    def __init__(self, host, port=None, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, host, port=None, **kwargs) -&gt; None:</span>
<span class="w"> </span>        if port is None:
<span class="w"> </span>            port = TCP_GIT_PORT
<span class="w"> </span>        self._host = host
<span class="w"> </span>        self._port = port
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_parsedurl(cls, parsedurl, **kwargs):</span>
<span class="gi">+        return cls(parsedurl.hostname, port=parsedurl.port, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def get_url(self, path):</span>
<span class="gi">+        netloc = self._host</span>
<span class="gi">+        if self._port is not None and self._port != TCP_GIT_PORT:</span>
<span class="gi">+            netloc += &quot;:%d&quot; % self._port</span>
<span class="gi">+        return urlunsplit((&quot;git&quot;, netloc, path, &quot;&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def _connect(self, cmd, path, protocol_version=None):</span>
<span class="gi">+        if not isinstance(cmd, bytes):</span>
<span class="gi">+            raise TypeError(cmd)</span>
<span class="gi">+        if not isinstance(path, bytes):</span>
<span class="gi">+            path = path.encode(self._remote_path_encoding)</span>
<span class="gi">+        sockaddrs = socket.getaddrinfo(</span>
<span class="gi">+            self._host, self._port, socket.AF_UNSPEC, socket.SOCK_STREAM</span>
<span class="gi">+        )</span>
<span class="gi">+        s = None</span>
<span class="gi">+        err = OSError(f&quot;no address found for {self._host}&quot;)</span>
<span class="gi">+        for family, socktype, proto, canonname, sockaddr in sockaddrs:</span>
<span class="gi">+            s = socket.socket(family, socktype, proto)</span>
<span class="gi">+            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span>
<span class="gi">+            try:</span>
<span class="gi">+                s.connect(sockaddr)</span>
<span class="gi">+                break</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                err = e</span>
<span class="gi">+                if s is not None:</span>
<span class="gi">+                    s.close()</span>
<span class="gi">+                s = None</span>
<span class="gi">+        if s is None:</span>
<span class="gi">+            raise err</span>
<span class="gi">+        # -1 means system default buffering</span>
<span class="gi">+        rfile = s.makefile(&quot;rb&quot;, -1)</span>
<span class="gi">+        # 0 means unbuffered</span>
<span class="gi">+        wfile = s.makefile(&quot;wb&quot;, 0)</span>
<span class="gi">+</span>
<span class="gi">+        def close():</span>
<span class="gi">+            rfile.close()</span>
<span class="gi">+            wfile.close()</span>
<span class="gi">+            s.close()</span>
<span class="gi">+</span>
<span class="gi">+        proto = Protocol(</span>
<span class="gi">+            rfile.read,</span>
<span class="gi">+            wfile.write,</span>
<span class="gi">+            close,</span>
<span class="gi">+            report_activity=self._report_activity,</span>
<span class="gi">+        )</span>
<span class="gi">+        if path.startswith(b&quot;/~&quot;):</span>
<span class="gi">+            path = path[1:]</span>
<span class="gi">+        if cmd == b&quot;upload-pack&quot;:</span>
<span class="gi">+            if protocol_version is None:</span>
<span class="gi">+                self.protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_FETCH</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.protocol_version = protocol_version</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_SEND</span>
<span class="gi">+</span>
<span class="gi">+        if cmd == b&quot;upload-pack&quot; and self.protocol_version == 2:</span>
<span class="gi">+            # Git protocol version advertisement is hidden behind two NUL bytes</span>
<span class="gi">+            # for compatibility with older Git server implementations, which</span>
<span class="gi">+            # would crash if something other than a &quot;host=&quot; header was found</span>
<span class="gi">+            # after the first NUL byte.</span>
<span class="gi">+            version_str = b&quot;\0\0version=%d\0&quot; % self.protocol_version</span>
<span class="gi">+        else:</span>
<span class="gi">+            version_str = b&quot;&quot;</span>
<span class="gi">+        # TODO(jelmer): Alternative to ascii?</span>
<span class="gi">+        proto.send_cmd(</span>
<span class="gi">+            b&quot;git-&quot; + cmd, path, b&quot;host=&quot; + self._host.encode(&quot;ascii&quot;) + version_str</span>
<span class="gi">+        )</span>
<span class="gi">+        return proto, lambda: _fileno_can_read(s), None</span>
<span class="gi">+</span>

<span class="w"> </span>class SubprocessWrapper:
<span class="w"> </span>    &quot;&quot;&quot;A socket-like object that talks to a subprocess via pipes.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, proc) -&gt;None:</span>
<span class="gi">+    def __init__(self, proc) -&gt; None:</span>
<span class="w"> </span>        self.proc = proc
<span class="w"> </span>        self.read = BufferedReader(proc.stdout).read
<span class="w"> </span>        self.write = proc.stdin.write

<span class="gi">+    @property</span>
<span class="gi">+    def stderr(self):</span>
<span class="gi">+        return self.proc.stderr</span>
<span class="gi">+</span>
<span class="gi">+    def can_read(self):</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            from msvcrt import get_osfhandle</span>
<span class="gi">+</span>
<span class="gi">+            handle = get_osfhandle(self.proc.stdout.fileno())</span>
<span class="gi">+            return _win32_peek_avail(handle) != 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _fileno_can_read(self.proc.stdout.fileno())</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self.proc.stdin.close()</span>
<span class="gi">+        self.proc.stdout.close()</span>
<span class="gi">+        if self.proc.stderr:</span>
<span class="gi">+            self.proc.stderr.close()</span>
<span class="gi">+        self.proc.wait()</span>

<span class="gd">-def find_git_command() -&gt;List[str]:</span>
<span class="gi">+</span>
<span class="gi">+def find_git_command() -&gt; List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find command to run for system Git (usually C Git).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:  # support .exe, .bat and .cmd</span>
<span class="gi">+        try:  # to avoid overhead</span>
<span class="gi">+            import pywintypes</span>
<span class="gi">+            import win32api</span>
<span class="gi">+        except ImportError:  # run through cmd.exe with some overhead</span>
<span class="gi">+            return [&quot;cmd&quot;, &quot;/c&quot;, &quot;git&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                status, git = win32api.FindExecutable(&quot;git&quot;)</span>
<span class="gi">+                return [git]</span>
<span class="gi">+            except pywintypes.error:</span>
<span class="gi">+                return [&quot;cmd&quot;, &quot;/c&quot;, &quot;git&quot;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [&quot;git&quot;]</span>


<span class="w"> </span>class SubprocessGitClient(TraditionalGitClient):
<span class="w"> </span>    &quot;&quot;&quot;Git client that talks to a server using a subprocess.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_parsedurl(cls, parsedurl, **kwargs):</span>
<span class="gi">+        return cls(**kwargs)</span>
<span class="gi">+</span>
<span class="w"> </span>    git_command = None

<span class="gi">+    def _connect(self, service, path, protocol_version=None):</span>
<span class="gi">+        if not isinstance(service, bytes):</span>
<span class="gi">+            raise TypeError(service)</span>
<span class="gi">+        if isinstance(path, bytes):</span>
<span class="gi">+            path = path.decode(self._remote_path_encoding)</span>
<span class="gi">+        if self.git_command is None:</span>
<span class="gi">+            git_command = find_git_command()</span>
<span class="gi">+        argv = [*git_command, service.decode(&quot;ascii&quot;), path]</span>
<span class="gi">+        p = subprocess.Popen(</span>
<span class="gi">+            argv,</span>
<span class="gi">+            bufsize=0,</span>
<span class="gi">+            stdin=subprocess.PIPE,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.PIPE,</span>
<span class="gi">+        )</span>
<span class="gi">+        pw = SubprocessWrapper(p)</span>
<span class="gi">+        return (</span>
<span class="gi">+            Protocol(</span>
<span class="gi">+                pw.read,</span>
<span class="gi">+                pw.write,</span>
<span class="gi">+                pw.close,</span>
<span class="gi">+                report_activity=self._report_activity,</span>
<span class="gi">+            ),</span>
<span class="gi">+            pw.can_read,</span>
<span class="gi">+            p.stderr,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class LocalGitClient(GitClient):
<span class="w"> </span>    &quot;&quot;&quot;Git Client that just uses a local on-disk repository.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, thin_packs: bool=True, report_activity=None, config:</span>
<span class="gd">-        Optional[Config]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        thin_packs: bool = True,</span>
<span class="gi">+        report_activity=None,</span>
<span class="gi">+        config: Optional[Config] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new LocalGitClient instance.

<span class="w"> </span>        Args:
<span class="gu">@@ -607,6 +1670,20 @@ class LocalGitClient(GitClient):</span>
<span class="w"> </span>            activity.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._report_activity = report_activity
<span class="gi">+        # Ignore the thin_packs argument</span>
<span class="gi">+</span>
<span class="gi">+    def get_url(self, path):</span>
<span class="gi">+        return urlunsplit((&quot;file&quot;, &quot;&quot;, path, &quot;&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_parsedurl(cls, parsedurl, **kwargs):</span>
<span class="gi">+        return cls(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _open_repo(cls, path):</span>
<span class="gi">+        if not isinstance(path, str):</span>
<span class="gi">+            path = os.fsdecode(path)</span>
<span class="gi">+        return closing(Repo(path))</span>

<span class="w"> </span>    def send_pack(self, path, update_refs, generate_pack_data, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Upload a pack to a local on-disk repository.
<span class="gu">@@ -626,10 +1703,59 @@ class LocalGitClient(GitClient):</span>
<span class="w"> </span>          SendPackError: if server rejects the pack data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not progress:</span>
<span class="gi">+</span>
<span class="gi">+            def progress(x):</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        with self._open_repo(path) as target:</span>
<span class="gi">+            old_refs = target.get_refs()</span>
<span class="gi">+            new_refs = update_refs(dict(old_refs))</span>
<span class="gi">+</span>
<span class="gi">+            have = [sha1 for sha1 in old_refs.values() if sha1 != ZERO_SHA]</span>
<span class="gi">+            want = []</span>
<span class="gi">+            for refname, new_sha1 in new_refs.items():</span>
<span class="gi">+                if (</span>
<span class="gi">+                    new_sha1 not in have</span>
<span class="gi">+                    and new_sha1 not in want</span>
<span class="gi">+                    and new_sha1 != ZERO_SHA</span>
<span class="gi">+                ):</span>
<span class="gi">+                    want.append(new_sha1)</span>
<span class="gi">+</span>
<span class="gi">+            if not want and set(new_refs.items()).issubset(set(old_refs.items())):</span>
<span class="gi">+                return SendPackResult(new_refs, ref_status={})</span>
<span class="gi">+</span>
<span class="gi">+            target.object_store.add_pack_data(</span>
<span class="gi">+                *generate_pack_data(have, want, ofs_delta=True)</span>
<span class="gi">+            )</span>

<span class="gd">-    def fetch(self, path, target, determine_wants=None, progress=None,</span>
<span class="gd">-        depth=None, ref_prefix=[], filter_spec=None, **kwargs):</span>
<span class="gi">+            ref_status = {}</span>
<span class="gi">+</span>
<span class="gi">+            for refname, new_sha1 in new_refs.items():</span>
<span class="gi">+                old_sha1 = old_refs.get(refname, ZERO_SHA)</span>
<span class="gi">+                if new_sha1 != ZERO_SHA:</span>
<span class="gi">+                    if not target.refs.set_if_equals(refname, old_sha1, new_sha1):</span>
<span class="gi">+                        msg = f&quot;unable to set {refname} to {new_sha1}&quot;</span>
<span class="gi">+                        progress(msg)</span>
<span class="gi">+                        ref_status[refname] = msg</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not target.refs.remove_if_equals(refname, old_sha1):</span>
<span class="gi">+                        progress(f&quot;unable to remove {refname}&quot;)</span>
<span class="gi">+                        ref_status[refname] = &quot;unable to remove&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return SendPackResult(new_refs, ref_status=ref_status)</span>
<span class="gi">+</span>
<span class="gi">+    def fetch(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        target,</span>
<span class="gi">+        determine_wants=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        ref_prefix=[],</span>
<span class="gi">+        filter_spec=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch into a target repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -654,12 +1780,27 @@ class LocalGitClient(GitClient):</span>
<span class="w"> </span>          FetchPackResult object

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch_pack(self, path, determine_wants, graph_walker, pack_data,</span>
<span class="gd">-        progress=None, depth=None, ref_prefix: Optional[List[bytes]]=[],</span>
<span class="gd">-        filter_spec: Optional[bytes]=None, protocol_version: Optional[int]=None</span>
<span class="gd">-        ) -&gt;FetchPackResult:</span>
<span class="gi">+        with self._open_repo(path) as r:</span>
<span class="gi">+            refs = r.fetch(</span>
<span class="gi">+                target,</span>
<span class="gi">+                determine_wants=determine_wants,</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+                depth=depth,</span>
<span class="gi">+            )</span>
<span class="gi">+            return FetchPackResult(refs, r.refs.get_symrefs(), agent_string())</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_pack(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        pack_data,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        ref_prefix: Optional[List[bytes]] = [],</span>
<span class="gi">+        filter_spec: Optional[bytes] = None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ) -&gt; FetchPackResult:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a pack from a local on-disk repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -685,22 +1826,48 @@ class LocalGitClient(GitClient):</span>
<span class="w"> </span>          FetchPackResult object

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._open_repo(path) as r:</span>
<span class="gi">+            missing_objects = r.find_missing_objects(</span>
<span class="gi">+                determine_wants, graph_walker, progress=progress, depth=depth</span>
<span class="gi">+            )</span>
<span class="gi">+            other_haves = missing_objects.get_remote_has()</span>
<span class="gi">+            object_ids = list(missing_objects)</span>
<span class="gi">+            symrefs = r.refs.get_symrefs()</span>
<span class="gi">+            agent = agent_string()</span>
<span class="gi">+</span>
<span class="gi">+            # Did the process short-circuit (e.g. in a stateless RPC call)?</span>
<span class="gi">+            # Note that the client still expects a 0-object pack in most cases.</span>
<span class="gi">+            if object_ids is None:</span>
<span class="gi">+                return FetchPackResult(None, symrefs, agent)</span>
<span class="gi">+            write_pack_from_container(</span>
<span class="gi">+                pack_data, r.object_store, object_ids, other_haves=other_haves</span>
<span class="gi">+            )</span>
<span class="gi">+            return FetchPackResult(r.get_refs(), symrefs, agent)</span>

<span class="w"> </span>    def get_refs(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the current refs from a local on-disk repository.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._open_repo(path) as target:</span>
<span class="gi">+            return target.get_refs()</span>


<span class="gi">+# What Git client to use for local access</span>
<span class="w"> </span>default_local_git_client_cls = LocalGitClient


<span class="w"> </span>class SSHVendor:
<span class="w"> </span>    &quot;&quot;&quot;A client side SSH implementation.&quot;&quot;&quot;

<span class="gd">-    def run_command(self, host, command, username=None, port=None, password</span>
<span class="gd">-        =None, key_filename=None, ssh_command=None, protocol_version:</span>
<span class="gd">-        Optional[int]=None):</span>
<span class="gi">+    def run_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        command,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        ssh_command=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Connect to an SSH server.

<span class="w"> </span>        Run a command remotely and return a file-like object for interaction
<span class="gu">@@ -717,39 +1884,172 @@ class SSHVendor:</span>
<span class="w"> </span>          protocol_version: Desired Git protocol version. By default the highest
<span class="w"> </span>            mutually supported protocol version will be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.run_command)</span>


<span class="w"> </span>class StrangeHostname(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Refusing to connect to strange SSH hostname.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, hostname) -&gt;None:</span>
<span class="gi">+    def __init__(self, hostname) -&gt; None:</span>
<span class="w"> </span>        super().__init__(hostname)


<span class="w"> </span>class SubprocessSSHVendor(SSHVendor):
<span class="w"> </span>    &quot;&quot;&quot;SSH vendor that shells out to the local &#39;ssh&#39; command.&quot;&quot;&quot;

<span class="gi">+    def run_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        command,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        ssh_command=None,</span>
<span class="gi">+        protocol_version=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if password is not None:</span>
<span class="gi">+            raise NotImplementedError(</span>
<span class="gi">+                &quot;Setting password not supported by SubprocessSSHVendor.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if ssh_command:</span>
<span class="gi">+            import shlex</span>
<span class="gi">+</span>
<span class="gi">+            args = [*shlex.split(ssh_command, posix=sys.platform != &quot;win32&quot;), &quot;-x&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = [&quot;ssh&quot;, &quot;-x&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if port:</span>
<span class="gi">+            args.extend([&quot;-p&quot;, str(port)])</span>
<span class="gi">+</span>
<span class="gi">+        if key_filename:</span>
<span class="gi">+            args.extend([&quot;-i&quot;, str(key_filename)])</span>
<span class="gi">+</span>
<span class="gi">+        if protocol_version is None:</span>
<span class="gi">+            protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_FETCH</span>
<span class="gi">+        if protocol_version &gt; 0:</span>
<span class="gi">+            args.extend([&quot;-o&quot;, f&quot;SetEnv GIT_PROTOCOL=version={protocol_version}&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        if username:</span>
<span class="gi">+            host = f&quot;{username}@{host}&quot;</span>
<span class="gi">+        if host.startswith(&quot;-&quot;):</span>
<span class="gi">+            raise StrangeHostname(hostname=host)</span>
<span class="gi">+        args.append(host)</span>
<span class="gi">+</span>
<span class="gi">+        proc = subprocess.Popen(</span>
<span class="gi">+            [*args, command],</span>
<span class="gi">+            bufsize=0,</span>
<span class="gi">+            stdin=subprocess.PIPE,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.PIPE,</span>
<span class="gi">+        )</span>
<span class="gi">+        return SubprocessWrapper(proc)</span>
<span class="gi">+</span>

<span class="w"> </span>class PLinkSSHVendor(SSHVendor):
<span class="w"> </span>    &quot;&quot;&quot;SSH vendor that shells out to the local &#39;plink&#39; command.&quot;&quot;&quot;

<span class="gi">+    def run_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        command,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        ssh_command=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if ssh_command:</span>
<span class="gi">+            import shlex</span>
<span class="gi">+</span>
<span class="gi">+            args = [*shlex.split(ssh_command, posix=sys.platform != &quot;win32&quot;), &quot;-ssh&quot;]</span>
<span class="gi">+        elif sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            args = [&quot;plink.exe&quot;, &quot;-ssh&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = [&quot;plink&quot;, &quot;-ssh&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if password is not None:</span>
<span class="gi">+            import warnings</span>

<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &quot;Invoking PLink with a password exposes the password in the &quot;</span>
<span class="gi">+                &quot;process list.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            args.extend([&quot;-pw&quot;, str(password)])</span>
<span class="gi">+</span>
<span class="gi">+        if port:</span>
<span class="gi">+            args.extend([&quot;-P&quot;, str(port)])</span>
<span class="gi">+</span>
<span class="gi">+        if key_filename:</span>
<span class="gi">+            args.extend([&quot;-i&quot;, str(key_filename)])</span>
<span class="gi">+</span>
<span class="gi">+        if username:</span>
<span class="gi">+            host = f&quot;{username}@{host}&quot;</span>
<span class="gi">+        if host.startswith(&quot;-&quot;):</span>
<span class="gi">+            raise StrangeHostname(hostname=host)</span>
<span class="gi">+        args.append(host)</span>
<span class="gi">+</span>
<span class="gi">+        # plink.exe does not provide a way to pass environment variables</span>
<span class="gi">+        # via the command line. The best we can do is set an environment</span>
<span class="gi">+        # variable and hope that plink will pass it to the server. If this</span>
<span class="gi">+        # does not work then the server should behave as if we had requested</span>
<span class="gi">+        # protocol version 0.</span>
<span class="gi">+        env = copy.deepcopy(os.environ)</span>
<span class="gi">+        if protocol_version is None:</span>
<span class="gi">+            protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_FETCH</span>
<span class="gi">+        if protocol_version &gt; 0:</span>
<span class="gi">+            env[&quot;GIT_PROTOCOL&quot;] = f&quot;version={protocol_version}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        proc = subprocess.Popen(</span>
<span class="gi">+            [*args, command],</span>
<span class="gi">+            bufsize=0,</span>
<span class="gi">+            stdin=subprocess.PIPE,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.PIPE,</span>
<span class="gi">+            env=env,</span>
<span class="gi">+        )</span>
<span class="gi">+        return SubprocessWrapper(proc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ParamikoSSHVendor(**kwargs):</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;ParamikoSSHVendor has been moved to dulwich.contrib.paramiko_vendor.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+    )</span>
<span class="gi">+    from .contrib.paramiko_vendor import ParamikoSSHVendor</span>
<span class="gi">+</span>
<span class="gi">+    return ParamikoSSHVendor(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Can be overridden by users</span>
<span class="w"> </span>get_ssh_vendor = SubprocessSSHVendor


<span class="w"> </span>class SSHGitClient(TraditionalGitClient):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, host, port=None, username=None, vendor=None, config=</span>
<span class="gd">-        None, password=None, key_filename=None, ssh_command=None, **kwargs</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        vendor=None,</span>
<span class="gi">+        config=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        ssh_command=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.host = host
<span class="w"> </span>        self.port = port
<span class="w"> </span>        self.username = username
<span class="w"> </span>        self.password = password
<span class="w"> </span>        self.key_filename = key_filename
<span class="gd">-        self.ssh_command = ssh_command or os.environ.get(&#39;GIT_SSH_COMMAND&#39;,</span>
<span class="gd">-            os.environ.get(&#39;GIT_SSH&#39;))</span>
<span class="gi">+        self.ssh_command = ssh_command or os.environ.get(</span>
<span class="gi">+            &quot;GIT_SSH_COMMAND&quot;, os.environ.get(&quot;GIT_SSH&quot;)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.alternative_paths: Dict[bytes, bytes] = {}
<span class="w"> </span>        if vendor is not None:
<span class="gu">@@ -757,10 +2057,84 @@ class SSHGitClient(TraditionalGitClient):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.ssh_vendor = get_ssh_vendor()

<span class="gi">+    def get_url(self, path):</span>
<span class="gi">+        netloc = self.host</span>
<span class="gi">+        if self.port is not None:</span>
<span class="gi">+            netloc += &quot;:%d&quot; % self.port</span>
<span class="gi">+</span>
<span class="gi">+        if self.username is not None:</span>
<span class="gi">+            netloc = urlquote(self.username, &quot;@/:&quot;) + &quot;@&quot; + netloc</span>

<span class="gd">-def default_urllib3_manager(config, pool_manager_cls=None,</span>
<span class="gd">-    proxy_manager_cls=None, base_url=None, **override_kwargs) -&gt;Union[</span>
<span class="gd">-    &#39;urllib3.ProxyManager&#39;, &#39;urllib3.PoolManager&#39;]:</span>
<span class="gi">+        return urlunsplit((&quot;ssh&quot;, netloc, path, &quot;&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_parsedurl(cls, parsedurl, **kwargs):</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            host=parsedurl.hostname,</span>
<span class="gi">+            port=parsedurl.port,</span>
<span class="gi">+            username=parsedurl.username,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cmd_path(self, cmd):</span>
<span class="gi">+        cmd = self.alternative_paths.get(cmd, b&quot;git-&quot; + cmd)</span>
<span class="gi">+        assert isinstance(cmd, bytes)</span>
<span class="gi">+        return cmd</span>
<span class="gi">+</span>
<span class="gi">+    def _connect(self, cmd, path, protocol_version=None):</span>
<span class="gi">+        if not isinstance(cmd, bytes):</span>
<span class="gi">+            raise TypeError(cmd)</span>
<span class="gi">+        if isinstance(path, bytes):</span>
<span class="gi">+            path = path.decode(self._remote_path_encoding)</span>
<span class="gi">+        if path.startswith(&quot;/~&quot;):</span>
<span class="gi">+            path = path[1:]</span>
<span class="gi">+        argv = (</span>
<span class="gi">+            self._get_cmd_path(cmd).decode(self._remote_path_encoding)</span>
<span class="gi">+            + &quot; &#39;&quot;</span>
<span class="gi">+            + path</span>
<span class="gi">+            + &quot;&#39;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+        if self.password is not None:</span>
<span class="gi">+            kwargs[&quot;password&quot;] = self.password</span>
<span class="gi">+        if self.key_filename is not None:</span>
<span class="gi">+            kwargs[&quot;key_filename&quot;] = self.key_filename</span>
<span class="gi">+        # GIT_SSH_COMMAND takes precedence over GIT_SSH</span>
<span class="gi">+        if self.ssh_command is not None:</span>
<span class="gi">+            kwargs[&quot;ssh_command&quot;] = self.ssh_command</span>
<span class="gi">+        con = self.ssh_vendor.run_command(</span>
<span class="gi">+            self.host,</span>
<span class="gi">+            argv,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            username=self.username,</span>
<span class="gi">+            protocol_version=protocol_version,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (</span>
<span class="gi">+            Protocol(</span>
<span class="gi">+                con.read,</span>
<span class="gi">+                con.write,</span>
<span class="gi">+                con.close,</span>
<span class="gi">+                report_activity=self._report_activity,</span>
<span class="gi">+            ),</span>
<span class="gi">+            con.can_read,</span>
<span class="gi">+            getattr(con, &quot;stderr&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_user_agent_string():</span>
<span class="gi">+    # Start user agent with &quot;git/&quot;, because GitHub requires this. :-( See</span>
<span class="gi">+    # https://github.com/jelmer/dulwich/issues/562 for details.</span>
<span class="gi">+    return &quot;git/dulwich/{}&quot;.format(&quot;.&quot;.join([str(x) for x in dulwich.__version__]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_urllib3_manager(</span>
<span class="gi">+    config,</span>
<span class="gi">+    pool_manager_cls=None,</span>
<span class="gi">+    proxy_manager_cls=None,</span>
<span class="gi">+    base_url=None,</span>
<span class="gi">+    **override_kwargs,</span>
<span class="gi">+) -&gt; Union[&quot;urllib3.ProxyManager&quot;, &quot;urllib3.PoolManager&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return urllib3 connection pool manager.

<span class="w"> </span>    Honour detected proxy configurations.
<span class="gu">@@ -775,7 +2149,136 @@ def default_urllib3_manager(config, pool_manager_cls=None,</span>
<span class="w"> </span>      (defaults to `urllib3.PoolManager`) instance otherwise

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    proxy_server = user_agent = None</span>
<span class="gi">+    ca_certs = ssl_verify = None</span>
<span class="gi">+</span>
<span class="gi">+    if proxy_server is None:</span>
<span class="gi">+        for proxyname in (&quot;https_proxy&quot;, &quot;http_proxy&quot;, &quot;all_proxy&quot;):</span>
<span class="gi">+            proxy_server = os.environ.get(proxyname)</span>
<span class="gi">+            if proxy_server:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    if proxy_server:</span>
<span class="gi">+        if check_for_proxy_bypass(base_url):</span>
<span class="gi">+            proxy_server = None</span>
<span class="gi">+</span>
<span class="gi">+    if config is not None:</span>
<span class="gi">+        if proxy_server is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                proxy_server = config.get(b&quot;http&quot;, b&quot;proxy&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            user_agent = config.get(b&quot;http&quot;, b&quot;useragent&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # TODO(jelmer): Support per-host settings</span>
<span class="gi">+        try:</span>
<span class="gi">+            ssl_verify = config.get_boolean(b&quot;http&quot;, b&quot;sslVerify&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            ssl_verify = True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            ca_certs = config.get(b&quot;http&quot;, b&quot;sslCAInfo&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            ca_certs = None</span>
<span class="gi">+</span>
<span class="gi">+    if user_agent is None:</span>
<span class="gi">+        user_agent = default_user_agent_string()</span>
<span class="gi">+</span>
<span class="gi">+    headers = {&quot;User-agent&quot;: user_agent}</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {</span>
<span class="gi">+        &quot;ca_certs&quot;: ca_certs,</span>
<span class="gi">+    }</span>
<span class="gi">+    if ssl_verify is True:</span>
<span class="gi">+        kwargs[&quot;cert_reqs&quot;] = &quot;CERT_REQUIRED&quot;</span>
<span class="gi">+    elif ssl_verify is False:</span>
<span class="gi">+        kwargs[&quot;cert_reqs&quot;] = &quot;CERT_NONE&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Default to SSL verification</span>
<span class="gi">+        kwargs[&quot;cert_reqs&quot;] = &quot;CERT_REQUIRED&quot;</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.update(override_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    import urllib3</span>
<span class="gi">+</span>
<span class="gi">+    if proxy_server is not None:</span>
<span class="gi">+        if proxy_manager_cls is None:</span>
<span class="gi">+            proxy_manager_cls = urllib3.ProxyManager</span>
<span class="gi">+        if not isinstance(proxy_server, str):</span>
<span class="gi">+            proxy_server = proxy_server.decode()</span>
<span class="gi">+        proxy_server_url = urlparse(proxy_server)</span>
<span class="gi">+        if proxy_server_url.username is not None:</span>
<span class="gi">+            proxy_headers = urllib3.make_headers(</span>
<span class="gi">+                proxy_basic_auth=f&quot;{proxy_server_url.username}:{proxy_server_url.password or &#39;&#39;}&quot;  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            proxy_headers = {}</span>
<span class="gi">+        manager = proxy_manager_cls(</span>
<span class="gi">+            proxy_server, proxy_headers=proxy_headers, headers=headers, **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        if pool_manager_cls is None:</span>
<span class="gi">+            pool_manager_cls = urllib3.PoolManager</span>
<span class="gi">+        manager = pool_manager_cls(headers=headers, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return manager</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_for_proxy_bypass(base_url):</span>
<span class="gi">+    # Check if a proxy bypass is defined with the no_proxy environment variable</span>
<span class="gi">+    if base_url:  # only check if base_url is provided</span>
<span class="gi">+        no_proxy_str = os.environ.get(&quot;no_proxy&quot;)</span>
<span class="gi">+        if no_proxy_str:</span>
<span class="gi">+            # implementation based on curl behavior: https://curl.se/libcurl/c/CURLOPT_NOPROXY.html</span>
<span class="gi">+            # get hostname of provided parsed url</span>
<span class="gi">+            parsed_url = urlparse(base_url)</span>
<span class="gi">+            hostname = parsed_url.hostname</span>
<span class="gi">+</span>
<span class="gi">+            if hostname:</span>
<span class="gi">+                import ipaddress</span>
<span class="gi">+</span>
<span class="gi">+                # check if hostname is an ip address</span>
<span class="gi">+                try:</span>
<span class="gi">+                    hostname_ip = ipaddress.ip_address(hostname)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    hostname_ip = None</span>
<span class="gi">+</span>
<span class="gi">+                no_proxy_values = no_proxy_str.split(&quot;,&quot;)</span>
<span class="gi">+                for no_proxy_value in no_proxy_values:</span>
<span class="gi">+                    no_proxy_value = no_proxy_value.strip()</span>
<span class="gi">+                    if no_proxy_value:</span>
<span class="gi">+                        no_proxy_value = no_proxy_value.lower()</span>
<span class="gi">+                        no_proxy_value = no_proxy_value.lstrip(</span>
<span class="gi">+                            &quot;.&quot;</span>
<span class="gi">+                        )  # ignore leading dots</span>
<span class="gi">+</span>
<span class="gi">+                        if hostname_ip:</span>
<span class="gi">+                            # check if no_proxy_value is a ip network</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                no_proxy_value_network = ipaddress.ip_network(</span>
<span class="gi">+                                    no_proxy_value, strict=False</span>
<span class="gi">+                                )</span>
<span class="gi">+                            except ValueError:</span>
<span class="gi">+                                no_proxy_value_network = None</span>
<span class="gi">+                            if no_proxy_value_network:</span>
<span class="gi">+                                # if hostname is a ip address and no_proxy_value is a ip network -&gt; check if ip address is part of network</span>
<span class="gi">+                                if hostname_ip in no_proxy_value_network:</span>
<span class="gi">+                                    return True</span>
<span class="gi">+</span>
<span class="gi">+                        if no_proxy_value == &quot;*&quot;:</span>
<span class="gi">+                            # &#39;*&#39; is special case for always bypass proxy</span>
<span class="gi">+                            return True</span>
<span class="gi">+                        if hostname == no_proxy_value:</span>
<span class="gi">+                            return True</span>
<span class="gi">+                        no_proxy_value = (</span>
<span class="gi">+                            &quot;.&quot; + no_proxy_value</span>
<span class="gi">+                        )  # add a dot to only match complete domains</span>
<span class="gi">+                        if hostname.endswith(no_proxy_value):</span>
<span class="gi">+                            return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class AbstractHttpGitClient(GitClient):
<span class="gu">@@ -787,8 +2290,8 @@ class AbstractHttpGitClient(GitClient):</span>
<span class="w"> </span>    _http_request method.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, base_url, dumb=False, **kwargs) -&gt;None:</span>
<span class="gd">-        self._base_url = base_url.rstrip(&#39;/&#39;) + &#39;/&#39;</span>
<span class="gi">+    def __init__(self, base_url, dumb=False, **kwargs) -&gt; None:</span>
<span class="gi">+        self._base_url = base_url.rstrip(&quot;/&quot;) + &quot;/&quot;</span>
<span class="w"> </span>        self.dumb = dumb
<span class="w"> </span>        GitClient.__init__(self, **kwargs)

<span class="gu">@@ -809,7 +2312,118 @@ class AbstractHttpGitClient(GitClient):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          GitProtocolError
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._http_request)</span>
<span class="gi">+</span>
<span class="gi">+    def _discover_references(self, service, base_url, protocol_version=None):</span>
<span class="gi">+        if (</span>
<span class="gi">+            protocol_version is not None</span>
<span class="gi">+            and protocol_version not in GIT_PROTOCOL_VERSIONS</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(&quot;unknown Git protocol version %d&quot; % protocol_version)</span>
<span class="gi">+        assert base_url[-1] == &quot;/&quot;</span>
<span class="gi">+        tail = &quot;info/refs&quot;</span>
<span class="gi">+        headers = {&quot;Accept&quot;: &quot;*/*&quot;}</span>
<span class="gi">+        if self.dumb is not True:</span>
<span class="gi">+            tail += &quot;?service={}&quot;.format(service.decode(&quot;ascii&quot;))</span>
<span class="gi">+            # Enable protocol v2 only when fetching, not when pushing.</span>
<span class="gi">+            # Git does not yet implement push over protocol v2, and as of</span>
<span class="gi">+            # git version 2.37.3 git-http-backend&#39;s behaviour is erratic if</span>
<span class="gi">+            # we try: It responds with a Git-protocol-v1-style ref listing</span>
<span class="gi">+            # which lacks the &quot;001f# service=git-receive-pack&quot; marker.</span>
<span class="gi">+            if service == b&quot;git-upload-pack&quot;:</span>
<span class="gi">+                if protocol_version is None:</span>
<span class="gi">+                    self.protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_FETCH</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.protocol_version = protocol_version</span>
<span class="gi">+                if self.protocol_version == 2:</span>
<span class="gi">+                    headers[&quot;Git-Protocol&quot;] = &quot;version=2&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.protocol_version = DEFAULT_GIT_PROTOCOL_VERSION_SEND</span>
<span class="gi">+        url = urljoin(base_url, tail)</span>
<span class="gi">+        resp, read = self._http_request(url, headers)</span>
<span class="gi">+</span>
<span class="gi">+        if resp.redirect_location:</span>
<span class="gi">+            # Something changed (redirect!), so let&#39;s update the base URL</span>
<span class="gi">+            if not resp.redirect_location.endswith(tail):</span>
<span class="gi">+                raise GitProtocolError(</span>
<span class="gi">+                    f&quot;Redirected from URL {url} to URL {resp.redirect_location} without {tail}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            base_url = urljoin(url, resp.redirect_location[: -len(tail)])</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.dumb = resp.content_type is None or not resp.content_type.startswith(</span>
<span class="gi">+                &quot;application/x-git-&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            if not self.dumb:</span>
<span class="gi">+</span>
<span class="gi">+                def begin_protocol_v2(proto):</span>
<span class="gi">+                    server_capabilities = read_server_capabilities(proto.read_pkt_seq())</span>
<span class="gi">+                    resp, read = self._smart_request(</span>
<span class="gi">+                        service.decode(&quot;ascii&quot;),</span>
<span class="gi">+                        base_url,</span>
<span class="gi">+                        pkt_line(b&quot;command=ls-refs\n&quot;)</span>
<span class="gi">+                        + b&quot;0001&quot;</span>
<span class="gi">+                        + pkt_line(b&quot;symrefs&quot;)</span>
<span class="gi">+                        + b&quot;0000&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    proto = Protocol(read, None)</span>
<span class="gi">+                    return server_capabilities, resp, read, proto</span>
<span class="gi">+</span>
<span class="gi">+                proto = Protocol(read, None)</span>
<span class="gi">+                server_protocol_version = negotiate_protocol_version(proto)</span>
<span class="gi">+                if server_protocol_version not in GIT_PROTOCOL_VERSIONS:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;unknown Git protocol version %d used by server&quot;</span>
<span class="gi">+                        % server_protocol_version</span>
<span class="gi">+                    )</span>
<span class="gi">+                if protocol_version and server_protocol_version &gt; protocol_version:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;bad Git protocol version %d used by server&quot;</span>
<span class="gi">+                        % server_protocol_version</span>
<span class="gi">+                    )</span>
<span class="gi">+                self.protocol_version = server_protocol_version</span>
<span class="gi">+                if self.protocol_version == 2:</span>
<span class="gi">+                    server_capabilities, resp, read, proto = begin_protocol_v2(proto)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    server_capabilities = None  # read_pkt_refs will find them</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        [pkt] = list(proto.read_pkt_seq())</span>
<span class="gi">+                    except ValueError as exc:</span>
<span class="gi">+                        raise GitProtocolError(</span>
<span class="gi">+                            &quot;unexpected number of packets received&quot;</span>
<span class="gi">+                        ) from exc</span>
<span class="gi">+                    if pkt.rstrip(b&quot;\n&quot;) != (b&quot;# service=&quot; + service):</span>
<span class="gi">+                        raise GitProtocolError(</span>
<span class="gi">+                            f&quot;unexpected first line {pkt!r} from smart server&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    # Github sends &quot;version 2&quot; after sending the service name.</span>
<span class="gi">+                    # Try to negotiate protocol version 2 again.</span>
<span class="gi">+                    server_protocol_version = negotiate_protocol_version(proto)</span>
<span class="gi">+                    if server_protocol_version not in GIT_PROTOCOL_VERSIONS:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            &quot;unknown Git protocol version %d used by server&quot;</span>
<span class="gi">+                            % server_protocol_version</span>
<span class="gi">+                        )</span>
<span class="gi">+                    if protocol_version and server_protocol_version &gt; protocol_version:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            &quot;bad Git protocol version %d used by server&quot;</span>
<span class="gi">+                            % server_protocol_version</span>
<span class="gi">+                        )</span>
<span class="gi">+                    self.protocol_version = server_protocol_version</span>
<span class="gi">+                    if self.protocol_version == 2:</span>
<span class="gi">+                        server_capabilities, resp, read, proto = begin_protocol_v2(</span>
<span class="gi">+                            proto</span>
<span class="gi">+                        )</span>
<span class="gi">+                (</span>
<span class="gi">+                    refs,</span>
<span class="gi">+                    server_capabilities,</span>
<span class="gi">+                ) = read_pkt_refs(proto.read_pkt_seq(), server_capabilities)</span>
<span class="gi">+                return refs, server_capabilities, base_url</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.protocol_version = 0  # dumb servers only support protocol v0</span>
<span class="gi">+                return read_info_refs(resp), set(), base_url</span>
<span class="gi">+        finally:</span>
<span class="gi">+            resp.close()</span>

<span class="w"> </span>    def _smart_request(self, service, url, data):
<span class="w"> </span>        &quot;&quot;&quot;Send a &#39;smart&#39; HTTP request.
<span class="gu">@@ -817,7 +2431,23 @@ class AbstractHttpGitClient(GitClient):</span>
<span class="w"> </span>        This is a simple wrapper around _http_request that sets
<span class="w"> </span>        a couple of extra headers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert url[-1] == &quot;/&quot;</span>
<span class="gi">+        url = urljoin(url, service)</span>
<span class="gi">+        result_content_type = f&quot;application/x-{service}-result&quot;</span>
<span class="gi">+        headers = {</span>
<span class="gi">+            &quot;Content-Type&quot;: f&quot;application/x-{service}-request&quot;,</span>
<span class="gi">+            &quot;Accept&quot;: result_content_type,</span>
<span class="gi">+        }</span>
<span class="gi">+        if self.protocol_version == 2:</span>
<span class="gi">+            headers[&quot;Git-Protocol&quot;] = &quot;version=2&quot;</span>
<span class="gi">+        if isinstance(data, bytes):</span>
<span class="gi">+            headers[&quot;Content-Length&quot;] = str(len(data))</span>
<span class="gi">+        resp, read = self._http_request(url, headers, data)</span>
<span class="gi">+        if resp.content_type.split(&quot;;&quot;)[0] != result_content_type:</span>
<span class="gi">+            raise GitProtocolError(</span>
<span class="gi">+                f&quot;Invalid content-type from server: {resp.content_type}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return resp, read</span>

<span class="w"> </span>    def send_pack(self, path, update_refs, generate_pack_data, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Upload a pack to a remote repository.
<span class="gu">@@ -838,11 +2468,64 @@ class AbstractHttpGitClient(GitClient):</span>
<span class="w"> </span>          SendPackError: if server rejects the pack data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch_pack(self, path, determine_wants, graph_walker, pack_data,</span>
<span class="gd">-        progress=None, depth=None, ref_prefix=[], filter_spec=None,</span>
<span class="gd">-        protocol_version: Optional[int]=None):</span>
<span class="gi">+        url = self._get_url(path)</span>
<span class="gi">+        old_refs, server_capabilities, url = self._discover_references(</span>
<span class="gi">+            b&quot;git-receive-pack&quot;, url</span>
<span class="gi">+        )</span>
<span class="gi">+        (</span>
<span class="gi">+            negotiated_capabilities,</span>
<span class="gi">+            agent,</span>
<span class="gi">+        ) = self._negotiate_receive_pack_capabilities(server_capabilities)</span>
<span class="gi">+        negotiated_capabilities.add(capability_agent())</span>
<span class="gi">+</span>
<span class="gi">+        if CAPABILITY_REPORT_STATUS in negotiated_capabilities:</span>
<span class="gi">+            self._report_status_parser = ReportStatusParser()</span>
<span class="gi">+</span>
<span class="gi">+        new_refs = update_refs(dict(old_refs))</span>
<span class="gi">+        if new_refs is None:</span>
<span class="gi">+            # Determine wants function is aborting the push.</span>
<span class="gi">+            return SendPackResult(old_refs, agent=agent, ref_status={})</span>
<span class="gi">+        if set(new_refs.items()).issubset(set(old_refs.items())):</span>
<span class="gi">+            return SendPackResult(new_refs, agent=agent, ref_status={})</span>
<span class="gi">+        if self.dumb:</span>
<span class="gi">+            raise NotImplementedError(self.fetch_pack)</span>
<span class="gi">+</span>
<span class="gi">+        def body_generator():</span>
<span class="gi">+            header_handler = _v1ReceivePackHeader(</span>
<span class="gi">+                negotiated_capabilities, old_refs, new_refs</span>
<span class="gi">+            )</span>
<span class="gi">+            for pkt in header_handler:</span>
<span class="gi">+                yield pkt_line(pkt)</span>
<span class="gi">+            pack_data_count, pack_data = generate_pack_data(</span>
<span class="gi">+                header_handler.have,</span>
<span class="gi">+                header_handler.want,</span>
<span class="gi">+                ofs_delta=(CAPABILITY_OFS_DELTA in negotiated_capabilities),</span>
<span class="gi">+            )</span>
<span class="gi">+            if self._should_send_pack(new_refs):</span>
<span class="gi">+                yield from PackChunkGenerator(pack_data_count, pack_data)</span>
<span class="gi">+</span>
<span class="gi">+        resp, read = self._smart_request(&quot;git-receive-pack&quot;, url, data=body_generator())</span>
<span class="gi">+        try:</span>
<span class="gi">+            resp_proto = Protocol(read, None)</span>
<span class="gi">+            ref_status = self._handle_receive_pack_tail(</span>
<span class="gi">+                resp_proto, negotiated_capabilities, progress</span>
<span class="gi">+            )</span>
<span class="gi">+            return SendPackResult(new_refs, agent=agent, ref_status=ref_status)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            resp.close()</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_pack(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        pack_data,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        ref_prefix=[],</span>
<span class="gi">+        filter_spec=None,</span>
<span class="gi">+        protocol_version: Optional[int] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a pack from a git smart server.

<span class="w"> </span>        Args:
<span class="gu">@@ -868,49 +2551,226 @@ class AbstractHttpGitClient(GitClient):</span>
<span class="w"> </span>          FetchPackResult object

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = self._get_url(path)</span>
<span class="gi">+        refs, server_capabilities, url = self._discover_references(</span>
<span class="gi">+            b&quot;git-upload-pack&quot;, url, protocol_version</span>
<span class="gi">+        )</span>
<span class="gi">+        (</span>
<span class="gi">+            negotiated_capabilities,</span>
<span class="gi">+            symrefs,</span>
<span class="gi">+            agent,</span>
<span class="gi">+        ) = self._negotiate_upload_pack_capabilities(server_capabilities)</span>
<span class="gi">+        if depth is not None:</span>
<span class="gi">+            wants = determine_wants(refs, depth=depth)</span>
<span class="gi">+        else:</span>
<span class="gi">+            wants = determine_wants(refs)</span>
<span class="gi">+        if wants is not None:</span>
<span class="gi">+            wants = [cid for cid in wants if cid != ZERO_SHA]</span>
<span class="gi">+        if not wants:</span>
<span class="gi">+            return FetchPackResult(refs, symrefs, agent)</span>
<span class="gi">+        if self.dumb:</span>
<span class="gi">+            raise NotImplementedError(self.fetch_pack)</span>
<span class="gi">+        req_data = BytesIO()</span>
<span class="gi">+        req_proto = Protocol(None, req_data.write)</span>
<span class="gi">+        (new_shallow, new_unshallow) = _handle_upload_pack_head(</span>
<span class="gi">+            req_proto,</span>
<span class="gi">+            negotiated_capabilities,</span>
<span class="gi">+            graph_walker,</span>
<span class="gi">+            wants,</span>
<span class="gi">+            can_read=None,</span>
<span class="gi">+            depth=depth,</span>
<span class="gi">+            protocol_version=self.protocol_version,</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.protocol_version == 2:</span>
<span class="gi">+            data = pkt_line(b&quot;command=fetch\n&quot;) + b&quot;0001&quot;</span>
<span class="gi">+            if (</span>
<span class="gi">+                find_capability(</span>
<span class="gi">+                    negotiated_capabilities, CAPABILITY_FETCH, CAPABILITY_FILTER</span>
<span class="gi">+                )</span>
<span class="gi">+                and filter_spec</span>
<span class="gi">+            ):</span>
<span class="gi">+                data += pkt_line(b&quot;filter %s\n&quot; % filter_spec)</span>
<span class="gi">+            elif filter_spec:</span>
<span class="gi">+                self._warn_filter_objects()</span>
<span class="gi">+            data += req_data.getvalue()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if filter_spec:</span>
<span class="gi">+                self._warn_filter_objects()</span>
<span class="gi">+            data = req_data.getvalue()</span>
<span class="gi">+        resp, read = self._smart_request(&quot;git-upload-pack&quot;, url, data)</span>
<span class="gi">+        try:</span>
<span class="gi">+            resp_proto = Protocol(read, None)</span>
<span class="gi">+            if new_shallow is None and new_unshallow is None:</span>
<span class="gi">+                (new_shallow, new_unshallow) = _read_shallow_updates(</span>
<span class="gi">+                    resp_proto.read_pkt_seq()</span>
<span class="gi">+                )</span>
<span class="gi">+            _handle_upload_pack_tail(</span>
<span class="gi">+                resp_proto,</span>
<span class="gi">+                negotiated_capabilities,</span>
<span class="gi">+                graph_walker,</span>
<span class="gi">+                pack_data,</span>
<span class="gi">+                progress,</span>
<span class="gi">+                protocol_version=self.protocol_version,</span>
<span class="gi">+            )</span>
<span class="gi">+            return FetchPackResult(refs, symrefs, agent, new_shallow, new_unshallow)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            resp.close()</span>

<span class="w"> </span>    def get_refs(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the current refs from a git smart server.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = self._get_url(path)</span>
<span class="gi">+        refs, _, _ = self._discover_references(b&quot;git-upload-pack&quot;, url)</span>
<span class="gi">+        return refs</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{type(self).__name__}({self._base_url!r}, dumb={self.dumb!r})&#39;</span>
<span class="gi">+    def get_url(self, path):</span>
<span class="gi">+        return self._get_url(path).rstrip(&quot;/&quot;)</span>

<span class="gi">+    def _get_url(self, path):</span>
<span class="gi">+        return urljoin(self._base_url, path).rstrip(&quot;/&quot;) + &quot;/&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_parsedurl(cls, parsedurl, **kwargs):</span>
<span class="gi">+        password = parsedurl.password</span>
<span class="gi">+        if password is not None:</span>
<span class="gi">+            kwargs[&quot;password&quot;] = urlunquote(password)</span>
<span class="gi">+        username = parsedurl.username</span>
<span class="gi">+        if username is not None:</span>
<span class="gi">+            kwargs[&quot;username&quot;] = urlunquote(username)</span>
<span class="gi">+        return cls(urlunparse(parsedurl), **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({self._base_url!r}, dumb={self.dumb!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _wrap_urllib3_exceptions(func):</span>
<span class="gi">+    from urllib3.exceptions import ProtocolError</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        except ProtocolError as error:</span>
<span class="gi">+            raise GitProtocolError(str(error)) from error</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>

<span class="gd">-class Urllib3HttpGitClient(AbstractHttpGitClient):</span>

<span class="gd">-    def __init__(self, base_url, dumb=None, pool_manager=None, config=None,</span>
<span class="gd">-        username=None, password=None, **kwargs) -&gt;None:</span>
<span class="gi">+class Urllib3HttpGitClient(AbstractHttpGitClient):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        base_url,</span>
<span class="gi">+        dumb=None,</span>
<span class="gi">+        pool_manager=None,</span>
<span class="gi">+        config=None,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._username = username
<span class="w"> </span>        self._password = password
<span class="gi">+</span>
<span class="w"> </span>        if pool_manager is None:
<span class="gd">-            self.pool_manager = default_urllib3_manager(config, base_url=</span>
<span class="gd">-                base_url)</span>
<span class="gi">+            self.pool_manager = default_urllib3_manager(config, base_url=base_url)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.pool_manager = pool_manager
<span class="gi">+</span>
<span class="w"> </span>        if username is not None:
<span class="gi">+            # No escaping needed: &quot;:&quot; is not allowed in username:</span>
<span class="gi">+            # https://tools.ietf.org/html/rfc2617#section-2</span>
<span class="w"> </span>            credentials = f&quot;{username}:{password or &#39;&#39;}&quot;
<span class="w"> </span>            import urllib3.util
<span class="gi">+</span>
<span class="w"> </span>            basic_auth = urllib3.util.make_headers(basic_auth=credentials)
<span class="gd">-            self.pool_manager.headers.update(basic_auth)</span>
<span class="gi">+            self.pool_manager.headers.update(basic_auth)  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>        self.config = config
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(base_url=base_url, dumb=dumb, **kwargs)

<span class="gi">+    def _get_url(self, path):</span>
<span class="gi">+        if not isinstance(path, str):</span>
<span class="gi">+            # urllib3.util.url._encode_invalid_chars() converts the path back</span>
<span class="gi">+            # to bytes using the utf-8 codec.</span>
<span class="gi">+            path = path.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        return urljoin(self._base_url, path).rstrip(&quot;/&quot;) + &quot;/&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _http_request(self, url, headers=None, data=None):</span>
<span class="gi">+        import urllib3.exceptions</span>
<span class="gi">+</span>
<span class="gi">+        req_headers = self.pool_manager.headers.copy()</span>
<span class="gi">+        if headers is not None:</span>
<span class="gi">+            req_headers.update(headers)</span>
<span class="gi">+        req_headers[&quot;Pragma&quot;] = &quot;no-cache&quot;</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if data is None:</span>
<span class="gi">+                resp = self.pool_manager.request(</span>
<span class="gi">+                    &quot;GET&quot;, url, headers=req_headers, preload_content=False</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                resp = self.pool_manager.request(</span>
<span class="gi">+                    &quot;POST&quot;, url, headers=req_headers, body=data, preload_content=False</span>
<span class="gi">+                )</span>
<span class="gi">+        except urllib3.exceptions.HTTPError as e:</span>
<span class="gi">+            raise GitProtocolError(str(e)) from e</span>
<span class="gi">+</span>
<span class="gi">+        if resp.status == 404:</span>
<span class="gi">+            raise NotGitRepository</span>
<span class="gi">+        if resp.status == 401:</span>
<span class="gi">+            raise HTTPUnauthorized(resp.headers.get(&quot;WWW-Authenticate&quot;), url)</span>
<span class="gi">+        if resp.status == 407:</span>
<span class="gi">+            raise HTTPProxyUnauthorized(resp.headers.get(&quot;Proxy-Authenticate&quot;), url)</span>
<span class="gi">+        if resp.status != 200:</span>
<span class="gi">+            raise GitProtocolError(</span>
<span class="gi">+                &quot;unexpected http resp %d for %s&quot; % (resp.status, url)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        resp.content_type = resp.headers.get(&quot;Content-Type&quot;)</span>
<span class="gi">+        # Check if geturl() is available (urllib3 version &gt;= 1.23)</span>
<span class="gi">+        try:</span>
<span class="gi">+            resp_url = resp.geturl()</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # get_redirect_location() is available for urllib3 &gt;= 1.1</span>
<span class="gi">+            resp.redirect_location = resp.get_redirect_location()</span>
<span class="gi">+        else:</span>
<span class="gi">+            resp.redirect_location = resp_url if resp_url != url else &quot;&quot;</span>
<span class="gi">+        return resp, _wrap_urllib3_exceptions(resp.read)</span>
<span class="gi">+</span>

<span class="w"> </span>HttpGitClient = Urllib3HttpGitClient


<span class="gd">-def _win32_url_to_path(parsed) -&gt;str:</span>
<span class="gi">+def _win32_url_to_path(parsed) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a file: URL to a path.

<span class="w"> </span>    https://datatracker.ietf.org/doc/html/rfc8089
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_transport_and_path_from_url(url: str, config: Optional[Config]=None,</span>
<span class="gd">-    operation: Optional[str]=None, **kwargs) -&gt;Tuple[GitClient, str]:</span>
<span class="gi">+    assert sys.platform == &quot;win32&quot; or os.name == &quot;nt&quot;</span>
<span class="gi">+    assert parsed.scheme == &quot;file&quot;</span>
<span class="gi">+</span>
<span class="gi">+    _, netloc, path, _, _, _ = parsed</span>
<span class="gi">+</span>
<span class="gi">+    if netloc == &quot;localhost&quot; or not netloc:</span>
<span class="gi">+        netloc = &quot;&quot;</span>
<span class="gi">+    elif (</span>
<span class="gi">+        netloc</span>
<span class="gi">+        and len(netloc) &gt;= 2</span>
<span class="gi">+        and netloc[0].isalpha()</span>
<span class="gi">+        and netloc[1:2] in (&quot;:&quot;, &quot;:/&quot;)</span>
<span class="gi">+    ):</span>
<span class="gi">+        # file://C:/foo.bar/baz or file://C://foo.bar//baz</span>
<span class="gi">+        netloc = netloc[:2]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(&quot;Non-local file URLs are not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    global url2pathname</span>
<span class="gi">+    if url2pathname is None:</span>
<span class="gi">+        from urllib.request import url2pathname  # type: ignore</span>
<span class="gi">+    return url2pathname(netloc + path)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_transport_and_path_from_url(</span>
<span class="gi">+    url: str, config: Optional[Config] = None, operation: Optional[str] = None, **kwargs</span>
<span class="gi">+) -&gt; Tuple[GitClient, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Obtain a git client from a URL.

<span class="w"> </span>    Args:
<span class="gu">@@ -925,16 +2785,61 @@ def get_transport_and_path_from_url(url: str, config: Optional[Config]=None,</span>
<span class="w"> </span>      Tuple with client instance and relative path.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if config is not None:</span>
<span class="gi">+        url = apply_instead_of(config, url, push=(operation == &quot;push&quot;))</span>

<span class="gi">+    return _get_transport_and_path_from_url(</span>
<span class="gi">+        url, config=config, operation=operation, **kwargs</span>
<span class="gi">+    )</span>

<span class="gd">-def parse_rsync_url(location: str) -&gt;Tuple[Optional[str], str, str]:</span>
<span class="gd">-    &quot;&quot;&quot;Parse a rsync-style URL.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>

<span class="gi">+def _get_transport_and_path_from_url(url, config, operation, **kwargs):</span>
<span class="gi">+    parsed = urlparse(url)</span>
<span class="gi">+    if parsed.scheme == &quot;git&quot;:</span>
<span class="gi">+        return (TCPGitClient.from_parsedurl(parsed, **kwargs), parsed.path)</span>
<span class="gi">+    elif parsed.scheme in (&quot;git+ssh&quot;, &quot;ssh&quot;):</span>
<span class="gi">+        return SSHGitClient.from_parsedurl(parsed, **kwargs), parsed.path</span>
<span class="gi">+    elif parsed.scheme in (&quot;http&quot;, &quot;https&quot;):</span>
<span class="gi">+        return (</span>
<span class="gi">+            HttpGitClient.from_parsedurl(parsed, config=config, **kwargs),</span>
<span class="gi">+            parsed.path,</span>
<span class="gi">+        )</span>
<span class="gi">+    elif parsed.scheme == &quot;file&quot;:</span>
<span class="gi">+        if sys.platform == &quot;win32&quot; or os.name == &quot;nt&quot;:</span>
<span class="gi">+            return default_local_git_client_cls(**kwargs), _win32_url_to_path(parsed)</span>
<span class="gi">+        return (</span>
<span class="gi">+            default_local_git_client_cls.from_parsedurl(parsed, **kwargs),</span>
<span class="gi">+            parsed.path,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError(f&quot;unknown scheme &#39;{parsed.scheme}&#39;&quot;)</span>

<span class="gd">-def get_transport_and_path(location: str, config: Optional[Config]=None,</span>
<span class="gd">-    operation: Optional[str]=None, **kwargs) -&gt;Tuple[GitClient, str]:</span>
<span class="gi">+</span>
<span class="gi">+def parse_rsync_url(location: str) -&gt; Tuple[Optional[str], str, str]:</span>
<span class="gi">+    &quot;&quot;&quot;Parse a rsync-style URL.&quot;&quot;&quot;</span>
<span class="gi">+    if &quot;:&quot; in location and &quot;@&quot; not in location:</span>
<span class="gi">+        # SSH with no user@, zero or one leading slash.</span>
<span class="gi">+        (host, path) = location.split(&quot;:&quot;, 1)</span>
<span class="gi">+        user = None</span>
<span class="gi">+    elif &quot;:&quot; in location:</span>
<span class="gi">+        # SSH with user@host:foo.</span>
<span class="gi">+        user_host, path = location.split(&quot;:&quot;, 1)</span>
<span class="gi">+        if &quot;@&quot; in user_host:</span>
<span class="gi">+            user, host = user_host.rsplit(&quot;@&quot;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            user = None</span>
<span class="gi">+            host = user_host</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;not a valid rsync-style URL&quot;)</span>
<span class="gi">+    return (user, host, path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_transport_and_path(</span>
<span class="gi">+    location: str,</span>
<span class="gi">+    config: Optional[Config] = None,</span>
<span class="gi">+    operation: Optional[str] = None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+) -&gt; Tuple[GitClient, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Obtain a git client from a URL.

<span class="w"> </span>    Args:
<span class="gu">@@ -949,8 +2854,50 @@ def get_transport_and_path(location: str, config: Optional[Config]=None,</span>
<span class="w"> </span>      Tuple with client instance and relative path.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if config is not None:</span>
<span class="gi">+        location = apply_instead_of(config, location, push=(operation == &quot;push&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # First, try to parse it as a URL</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _get_transport_and_path_from_url(</span>
<span class="gi">+            location, config=config, operation=operation, **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>

<span class="gd">-DEFAULT_GIT_CREDENTIALS_PATHS = [os.path.expanduser(&#39;~/.git-credentials&#39;),</span>
<span class="gd">-    get_xdg_config_home_path(&#39;git&#39;, &#39;credentials&#39;)]</span>
<span class="gi">+    if sys.platform == &quot;win32&quot; and location[0].isalpha() and location[1:3] == &quot;:\\&quot;:</span>
<span class="gi">+        # Windows local path</span>
<span class="gi">+        return default_local_git_client_cls(**kwargs), location</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        (username, hostname, path) = parse_rsync_url(location)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # Otherwise, assume it&#39;s a local path.</span>
<span class="gi">+        return default_local_git_client_cls(**kwargs), location</span>
<span class="gi">+    else:</span>
<span class="gi">+        return SSHGitClient(hostname, username=username, **kwargs), path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_GIT_CREDENTIALS_PATHS = [</span>
<span class="gi">+    os.path.expanduser(&quot;~/.git-credentials&quot;),</span>
<span class="gi">+    get_xdg_config_home_path(&quot;git&quot;, &quot;credentials&quot;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_credentials_from_store(</span>
<span class="gi">+    scheme, hostname, username=None, fnames=DEFAULT_GIT_CREDENTIALS_PATHS</span>
<span class="gi">+):</span>
<span class="gi">+    for fname in fnames:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(fname, &quot;rb&quot;) as f:</span>
<span class="gi">+                for line in f:</span>
<span class="gi">+                    parsed_line = urlparse(line.strip())</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        parsed_line.scheme == scheme</span>
<span class="gi">+                        and parsed_line.hostname == hostname</span>
<span class="gi">+                        and (username is None or parsed_line.username == username)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return parsed_line.username, parsed_line.password</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            # If the file doesn&#39;t exist, try the next one.</span>
<span class="gi">+            continue</span>
<span class="gh">diff --git a/dulwich/cloud/gcs.py b/dulwich/cloud/gcs.py</span>
<span class="gh">index 329f6ef2..b9dd9b4c 100644</span>
<span class="gd">--- a/dulwich/cloud/gcs.py</span>
<span class="gi">+++ b/dulwich/cloud/gcs.py</span>
<span class="gu">@@ -1,18 +1,79 @@</span>
<span class="gi">+# object_store.py -- Object store for git objects</span>
<span class="gi">+# Copyright (C) 2021 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Storage of repositories on GCS.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import posixpath
<span class="w"> </span>import tempfile
<span class="gi">+</span>
<span class="w"> </span>from ..object_store import BucketBasedObjectStore
<span class="w"> </span>from ..pack import PACK_SPOOL_FILE_MAX_SIZE, Pack, PackData, load_pack_index_file

<span class="gi">+# TODO(jelmer): For performance, read ranges?</span>

<span class="gd">-class GcsObjectStore(BucketBasedObjectStore):</span>

<span class="gd">-    def __init__(self, bucket, subpath=&#39;&#39;) -&gt;None:</span>
<span class="gi">+class GcsObjectStore(BucketBasedObjectStore):</span>
<span class="gi">+    def __init__(self, bucket, subpath=&quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.bucket = bucket
<span class="w"> </span>        self.subpath = subpath

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{type(self).__name__}({self.bucket!r}, subpath={self.subpath!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({self.bucket!r}, subpath={self.subpath!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_pack(self, name):</span>
<span class="gi">+        self.bucket.delete_blobs(</span>
<span class="gi">+            [posixpath.join(self.subpath, name) + &quot;.&quot; + ext for ext in [&quot;pack&quot;, &quot;idx&quot;]]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_pack_names(self):</span>
<span class="gi">+        packs = {}</span>
<span class="gi">+        for blob in self.bucket.list_blobs(prefix=self.subpath):</span>
<span class="gi">+            name, ext = posixpath.splitext(posixpath.basename(blob.name))</span>
<span class="gi">+            packs.setdefault(name, set()).add(ext)</span>
<span class="gi">+        for name, exts in packs.items():</span>
<span class="gi">+            if exts == {&quot;.pack&quot;, &quot;.idx&quot;}:</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+    def _load_pack_data(self, name):</span>
<span class="gi">+        b = self.bucket.blob(posixpath.join(self.subpath, name + &quot;.pack&quot;))</span>
<span class="gi">+        f = tempfile.SpooledTemporaryFile(max_size=PACK_SPOOL_FILE_MAX_SIZE)</span>
<span class="gi">+        b.download_to_file(f)</span>
<span class="gi">+        f.seek(0)</span>
<span class="gi">+        return PackData(name + &quot;.pack&quot;, f)</span>
<span class="gi">+</span>
<span class="gi">+    def _load_pack_index(self, name):</span>
<span class="gi">+        b = self.bucket.blob(posixpath.join(self.subpath, name + &quot;.idx&quot;))</span>
<span class="gi">+        f = tempfile.SpooledTemporaryFile(max_size=PACK_SPOOL_FILE_MAX_SIZE)</span>
<span class="gi">+        b.download_to_file(f)</span>
<span class="gi">+        f.seek(0)</span>
<span class="gi">+        return load_pack_index_file(name + &quot;.idx&quot;, f)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_pack(self, name):</span>
<span class="gi">+        return Pack.from_lazy_objects(</span>
<span class="gi">+            lambda: self._load_pack_data(name), lambda: self._load_pack_index(name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _upload_pack(self, basename, pack_file, index_file):</span>
<span class="gi">+        idxblob = self.bucket.blob(posixpath.join(self.subpath, basename + &quot;.idx&quot;))</span>
<span class="gi">+        datablob = self.bucket.blob(posixpath.join(self.subpath, basename + &quot;.pack&quot;))</span>
<span class="gi">+        idxblob.upload_from_file(index_file)</span>
<span class="gi">+        datablob.upload_from_file(pack_file)</span>
<span class="gh">diff --git a/dulwich/config.py b/dulwich/config.py</span>
<span class="gh">index 663659a6..c0a3de11 100644</span>
<span class="gd">--- a/dulwich/config.py</span>
<span class="gi">+++ b/dulwich/config.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# config.py - Reading and writing Git config files</span>
<span class="gi">+# Copyright (C) 2011-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Reading and writing Git configuration files.

<span class="w"> </span>Todo:
<span class="gu">@@ -5,31 +25,83 @@ Todo:</span>
<span class="w"> </span> * treat subsection names as case-insensitive for [branch.foo] style
<span class="w"> </span>   subsections
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import suppress
<span class="gd">-from typing import Any, BinaryIO, Dict, Iterable, Iterator, KeysView, List, MutableMapping, Optional, Tuple, Union, overload</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    BinaryIO,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    KeysView,</span>
<span class="gi">+    List,</span>
<span class="gi">+    MutableMapping,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+    overload,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .file import GitFile
<span class="gi">+</span>
<span class="w"> </span>SENTINEL = object()


<span class="gd">-class CaseInsensitiveOrderedMultiDict(MutableMapping):</span>
<span class="gi">+def lower_key(key):</span>
<span class="gi">+    if isinstance(key, (bytes, str)):</span>
<span class="gi">+        return key.lower()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(key, Iterable):</span>
<span class="gi">+        return type(key)(map(lower_key, key))  # type: ignore</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    return key</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CaseInsensitiveOrderedMultiDict(MutableMapping):</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._real: List[Any] = []
<span class="w"> </span>        self._keyed: Dict[Any, Any] = {}

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def make(cls, dict_in=None):</span>
<span class="gi">+        if isinstance(dict_in, cls):</span>
<span class="gi">+            return dict_in</span>
<span class="gi">+</span>
<span class="gi">+        out = cls()</span>
<span class="gi">+</span>
<span class="gi">+        if dict_in is None:</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(dict_in, MutableMapping):</span>
<span class="gi">+            raise TypeError</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in dict_in.items():</span>
<span class="gi">+            out[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._keyed)

<span class="gi">+    def keys(self) -&gt; KeysView[Tuple[bytes, ...]]:</span>
<span class="gi">+        return self._keyed.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def items(self):</span>
<span class="gi">+        return iter(self._real)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self._keyed.__iter__()

<span class="gd">-    def __setitem__(self, key, value) -&gt;None:</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._keyed.values()</span>
<span class="gi">+</span>
<span class="gi">+    def __setitem__(self, key, value) -&gt; None:</span>
<span class="w"> </span>        self._real.append((key, value))
<span class="w"> </span>        self._keyed[lower_key(key)] = value

<span class="gd">-    def __delitem__(self, key) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key) -&gt; None:</span>
<span class="w"> </span>        key = lower_key(key)
<span class="w"> </span>        del self._keyed[key]
<span class="w"> </span>        for i, (actual, unused_value) in reversed(list(enumerate(self._real))):
<span class="gu">@@ -39,6 +111,31 @@ class CaseInsensitiveOrderedMultiDict(MutableMapping):</span>
<span class="w"> </span>    def __getitem__(self, item):
<span class="w"> </span>        return self._keyed[lower_key(item)]

<span class="gi">+    def get(self, key, default=SENTINEL):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        if default is SENTINEL:</span>
<span class="gi">+            return type(self)()</span>
<span class="gi">+</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def get_all(self, key):</span>
<span class="gi">+        key = lower_key(key)</span>
<span class="gi">+        for actual, value in self._real:</span>
<span class="gi">+            if lower_key(actual) == key:</span>
<span class="gi">+                yield value</span>
<span class="gi">+</span>
<span class="gi">+    def setdefault(self, key, default=SENTINEL):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            self[key] = self.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+        return self[key]</span>
<span class="gi">+</span>

<span class="w"> </span>Name = bytes
<span class="w"> </span>NameLike = Union[bytes, str]
<span class="gu">@@ -51,7 +148,7 @@ ValueLike = Union[bytes, str]</span>
<span class="w"> </span>class Config:
<span class="w"> </span>    &quot;&quot;&quot;A Git configuration.&quot;&quot;&quot;

<span class="gd">-    def get(self, section: SectionLike, name: NameLike) -&gt;Value:</span>
<span class="gi">+    def get(self, section: SectionLike, name: NameLike) -&gt; Value:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the contents of a configuration setting.

<span class="w"> </span>        Args:
<span class="gu">@@ -62,10 +159,9 @@ class Config:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          KeyError: if the value is not set
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get)</span>

<span class="gd">-    def get_multivar(self, section: SectionLike, name: NameLike) -&gt;Iterator[</span>
<span class="gd">-        Value]:</span>
<span class="gi">+    def get_multivar(self, section: SectionLike, name: NameLike) -&gt; Iterator[Value]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the contents of a multivar configuration setting.

<span class="w"> </span>        Args:
<span class="gu">@@ -76,10 +172,19 @@ class Config:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          KeyError: if the value is not set
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_multivar)</span>

<span class="gd">-    def get_boolean(self, section: SectionLike, name: NameLike, default:</span>
<span class="gd">-        Optional[bool]=None) -&gt;Optional[bool]:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def get_boolean(</span>
<span class="gi">+        self, section: SectionLike, name: NameLike, default: bool</span>
<span class="gi">+    ) -&gt; bool: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def get_boolean(self, section: SectionLike, name: NameLike) -&gt; Optional[bool]: ...</span>
<span class="gi">+</span>
<span class="gi">+    def get_boolean(</span>
<span class="gi">+        self, section: SectionLike, name: NameLike, default: Optional[bool] = None</span>
<span class="gi">+    ) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a configuration setting as boolean.

<span class="w"> </span>        Args:
<span class="gu">@@ -90,10 +195,19 @@ class Config:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          Contents of the setting
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set(self, section: SectionLike, name: NameLike, value: Union[</span>
<span class="gd">-        ValueLike, bool]) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self.get(section, name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>
<span class="gi">+        if value.lower() == b&quot;true&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif value.lower() == b&quot;false&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise ValueError(f&quot;not a valid boolean string: {value!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def set(</span>
<span class="gi">+        self, section: SectionLike, name: NameLike, value: Union[ValueLike, bool]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a configuration value.

<span class="w"> </span>        Args:
<span class="gu">@@ -102,9 +216,9 @@ class Config:</span>
<span class="w"> </span>            and optional subsection
<span class="w"> </span>          value: value of the setting
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.set)</span>

<span class="gd">-    def items(self, section: SectionLike) -&gt;Iterator[Tuple[Name, Value]]:</span>
<span class="gi">+    def items(self, section: SectionLike) -&gt; Iterator[Tuple[Name, Value]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the configuration pairs for a specific section.

<span class="w"> </span>        Args:
<span class="gu">@@ -112,16 +226,16 @@ class Config:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          Iterator over (name, value) pairs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.items)</span>

<span class="gd">-    def sections(self) -&gt;Iterator[Section]:</span>
<span class="gi">+    def sections(self) -&gt; Iterator[Section]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the sections.

<span class="w"> </span>        Returns: Iterator over section tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.sections)</span>

<span class="gd">-    def has_section(self, name: Section) -&gt;bool:</span>
<span class="gi">+    def has_section(self, name: Section) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a specified section exists.

<span class="w"> </span>        Args:
<span class="gu">@@ -129,109 +243,508 @@ class Config:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          boolean indicating whether the section exists
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return name in self.sections()</span>


<span class="w"> </span>class ConfigDict(Config, MutableMapping[Section, MutableMapping[Name, Value]]):
<span class="w"> </span>    &quot;&quot;&quot;Git configuration stored in a dictionary.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, values: Union[MutableMapping[Section, MutableMapping</span>
<span class="gd">-        [Name, Value]], None]=None, encoding: Union[str, None]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        values: Union[</span>
<span class="gi">+            MutableMapping[Section, MutableMapping[Name, Value]], None</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+        encoding: Union[str, None] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new ConfigDict.&quot;&quot;&quot;
<span class="w"> </span>        if encoding is None:
<span class="w"> </span>            encoding = sys.getdefaultencoding()
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self._values = CaseInsensitiveOrderedMultiDict.make(values)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._values!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._values!r})&quot;</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, self.__class__</span>
<span class="gd">-            ) and other._values == self._values</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="gi">+        return isinstance(other, self.__class__) and other._values == self._values</span>

<span class="gd">-    def __getitem__(self, key: Section) -&gt;MutableMapping[Name, Value]:</span>
<span class="gi">+    def __getitem__(self, key: Section) -&gt; MutableMapping[Name, Value]:</span>
<span class="w"> </span>        return self._values.__getitem__(key)

<span class="gd">-    def __setitem__(self, key: Section, value: MutableMapping[Name, Value]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: Section, value: MutableMapping[Name, Value]) -&gt; None:</span>
<span class="w"> </span>        return self._values.__setitem__(key, value)

<span class="gd">-    def __delitem__(self, key: Section) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: Section) -&gt; None:</span>
<span class="w"> </span>        return self._values.__delitem__(key)

<span class="gd">-    def __iter__(self) -&gt;Iterator[Section]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Section]:</span>
<span class="w"> </span>        return self._values.__iter__()

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self._values.__len__()

<span class="gd">-</span>
<span class="gd">-_ESCAPE_TABLE = {ord(b&#39;\\&#39;): ord(b&#39;\\&#39;), ord(b&#39;&quot;&#39;): ord(b&#39;&quot;&#39;), ord(b&#39;n&#39;):</span>
<span class="gd">-    ord(b&#39;\n&#39;), ord(b&#39;t&#39;): ord(b&#39;\t&#39;), ord(b&#39;b&#39;): ord(b&#39;\x08&#39;)}</span>
<span class="gd">-_COMMENT_CHARS = [ord(b&#39;#&#39;), ord(b&#39;;&#39;)]</span>
<span class="gd">-_WHITESPACE_CHARS = [ord(b&#39;\t&#39;), ord(b&#39; &#39;)]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _escape_value(value: bytes) -&gt;bytes:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _parse_setting(cls, name: str):</span>
<span class="gi">+        parts = name.split(&quot;.&quot;)</span>
<span class="gi">+        if len(parts) == 3:</span>
<span class="gi">+            return (parts[0], parts[1], parts[2])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (parts[0], None, parts[1])</span>
<span class="gi">+</span>
<span class="gi">+    def _check_section_and_name(</span>
<span class="gi">+        self, section: SectionLike, name: NameLike</span>
<span class="gi">+    ) -&gt; Tuple[Section, Name]:</span>
<span class="gi">+        if not isinstance(section, tuple):</span>
<span class="gi">+            section = (section,)</span>
<span class="gi">+</span>
<span class="gi">+        checked_section = tuple(</span>
<span class="gi">+            [</span>
<span class="gi">+                subsection.encode(self.encoding)</span>
<span class="gi">+                if not isinstance(subsection, bytes)</span>
<span class="gi">+                else subsection</span>
<span class="gi">+                for subsection in section</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(name, bytes):</span>
<span class="gi">+            name = name.encode(self.encoding)</span>
<span class="gi">+</span>
<span class="gi">+        return checked_section, name</span>
<span class="gi">+</span>
<span class="gi">+    def get_multivar(self, section: SectionLike, name: NameLike) -&gt; Iterator[Value]:</span>
<span class="gi">+        section, name = self._check_section_and_name(section, name)</span>
<span class="gi">+</span>
<span class="gi">+        if len(section) &gt; 1:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._values[section].get_all(name)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return self._values[(section[0],)].get_all(name)</span>
<span class="gi">+</span>
<span class="gi">+    def get(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        section: SectionLike,</span>
<span class="gi">+        name: NameLike,</span>
<span class="gi">+    ) -&gt; Value:</span>
<span class="gi">+        section, name = self._check_section_and_name(section, name)</span>
<span class="gi">+</span>
<span class="gi">+        if len(section) &gt; 1:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._values[section][name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return self._values[(section[0],)][name]</span>
<span class="gi">+</span>
<span class="gi">+    def set(</span>
<span class="gi">+        self,</span>
<span class="gi">+        section: SectionLike,</span>
<span class="gi">+        name: NameLike,</span>
<span class="gi">+        value: Union[ValueLike, bool],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        section, name = self._check_section_and_name(section, name)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, bool):</span>
<span class="gi">+            value = b&quot;true&quot; if value else b&quot;false&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(value, bytes):</span>
<span class="gi">+            value = value.encode(self.encoding)</span>
<span class="gi">+</span>
<span class="gi">+        self._values.setdefault(section)[name] = value</span>
<span class="gi">+</span>
<span class="gi">+    def items(  # type: ignore[override]</span>
<span class="gi">+        self, section: Section</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[Name, Value]]:</span>
<span class="gi">+        return self._values.get(section).items()</span>
<span class="gi">+</span>
<span class="gi">+    def sections(self) -&gt; Iterator[Section]:</span>
<span class="gi">+        return self._values.keys()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_string(value: bytes) -&gt; bytes:</span>
<span class="gi">+    if (</span>
<span class="gi">+        value.startswith((b&quot; &quot;, b&quot;\t&quot;))</span>
<span class="gi">+        or value.endswith((b&quot; &quot;, b&quot;\t&quot;))</span>
<span class="gi">+        or b&quot;#&quot; in value</span>
<span class="gi">+    ):</span>
<span class="gi">+        return b&#39;&quot;&#39; + _escape_value(value) + b&#39;&quot;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _escape_value(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_ESCAPE_TABLE = {</span>
<span class="gi">+    ord(b&quot;\\&quot;): ord(b&quot;\\&quot;),</span>
<span class="gi">+    ord(b&#39;&quot;&#39;): ord(b&#39;&quot;&#39;),</span>
<span class="gi">+    ord(b&quot;n&quot;): ord(b&quot;\n&quot;),</span>
<span class="gi">+    ord(b&quot;t&quot;): ord(b&quot;\t&quot;),</span>
<span class="gi">+    ord(b&quot;b&quot;): ord(b&quot;\b&quot;),</span>
<span class="gi">+}</span>
<span class="gi">+_COMMENT_CHARS = [ord(b&quot;#&quot;), ord(b&quot;;&quot;)]</span>
<span class="gi">+_WHITESPACE_CHARS = [ord(b&quot;\t&quot;), ord(b&quot; &quot;)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_string(value: bytes) -&gt; bytes:</span>
<span class="gi">+    value = bytearray(value.strip())</span>
<span class="gi">+    ret = bytearray()</span>
<span class="gi">+    whitespace = bytearray()</span>
<span class="gi">+    in_quotes = False</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; len(value):</span>
<span class="gi">+        c = value[i]</span>
<span class="gi">+        if c == ord(b&quot;\\&quot;):</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            try:</span>
<span class="gi">+                v = _ESCAPE_TABLE[value[i]]</span>
<span class="gi">+            except IndexError as exc:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;escape character in %r at %d before end of string&quot; % (value, i)</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+            except KeyError as exc:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;escape character followed by unknown character &quot;</span>
<span class="gi">+                    &quot;%s at %d in %r&quot; % (value[i], i, value)</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+            if whitespace:</span>
<span class="gi">+                ret.extend(whitespace)</span>
<span class="gi">+                whitespace = bytearray()</span>
<span class="gi">+            ret.append(v)</span>
<span class="gi">+        elif c == ord(b&#39;&quot;&#39;):</span>
<span class="gi">+            in_quotes = not in_quotes</span>
<span class="gi">+        elif c in _COMMENT_CHARS and not in_quotes:</span>
<span class="gi">+            # the rest of the line is a comment</span>
<span class="gi">+            break</span>
<span class="gi">+        elif c in _WHITESPACE_CHARS:</span>
<span class="gi">+            whitespace.append(c)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if whitespace:</span>
<span class="gi">+                ret.extend(whitespace)</span>
<span class="gi">+                whitespace = bytearray()</span>
<span class="gi">+            ret.append(c)</span>
<span class="gi">+        i += 1</span>
<span class="gi">+</span>
<span class="gi">+    if in_quotes:</span>
<span class="gi">+        raise ValueError(&quot;missing end quote&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return bytes(ret)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _escape_value(value: bytes) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escape a value.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.replace(b&quot;\\&quot;, b&quot;\\\\&quot;)</span>
<span class="gi">+    value = value.replace(b&quot;\r&quot;, b&quot;\\r&quot;)</span>
<span class="gi">+    value = value.replace(b&quot;\n&quot;, b&quot;\\n&quot;)</span>
<span class="gi">+    value = value.replace(b&quot;\t&quot;, b&quot;\\t&quot;)</span>
<span class="gi">+    value = value.replace(b&#39;&quot;&#39;, b&#39;\\&quot;&#39;)</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_variable_name(name: bytes) -&gt; bool:</span>
<span class="gi">+    for i in range(len(name)):</span>
<span class="gi">+        c = name[i : i + 1]</span>
<span class="gi">+        if not c.isalnum() and c != b&quot;-&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_section_name(name: bytes) -&gt; bool:</span>
<span class="gi">+    for i in range(len(name)):</span>
<span class="gi">+        c = name[i : i + 1]</span>
<span class="gi">+        if not c.isalnum() and c not in (b&quot;-&quot;, b&quot;.&quot;):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _strip_comments(line: bytes) -&gt; bytes:</span>
<span class="gi">+    comment_bytes = {ord(b&quot;#&quot;), ord(b&quot;;&quot;)}</span>
<span class="gi">+    quote = ord(b&#39;&quot;&#39;)</span>
<span class="gi">+    string_open = False</span>
<span class="gi">+    # Normalize line to bytearray for simple 2/3 compatibility</span>
<span class="gi">+    for i, character in enumerate(bytearray(line)):</span>
<span class="gi">+        # Comment characters outside balanced quotes denote comment start</span>
<span class="gi">+        if character == quote:</span>
<span class="gi">+            string_open = not string_open</span>
<span class="gi">+        elif not string_open and character in comment_bytes:</span>
<span class="gi">+            return line[:i]</span>
<span class="gi">+    return line</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_section_header_line(line: bytes) -&gt; Tuple[Section, bytes]:</span>
<span class="gi">+    # Parse section header (&quot;[bla]&quot;)</span>
<span class="gi">+    line = _strip_comments(line).rstrip()</span>
<span class="gi">+    in_quotes = False</span>
<span class="gi">+    escaped = False</span>
<span class="gi">+    for i, c in enumerate(line):</span>
<span class="gi">+        if escaped:</span>
<span class="gi">+            escaped = False</span>
<span class="gi">+            continue</span>
<span class="gi">+        if c == ord(b&#39;&quot;&#39;):</span>
<span class="gi">+            in_quotes = not in_quotes</span>
<span class="gi">+        if c == ord(b&quot;\\&quot;):</span>
<span class="gi">+            escaped = True</span>
<span class="gi">+        if c == ord(b&quot;]&quot;) and not in_quotes:</span>
<span class="gi">+            last = i</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;expected trailing ]&quot;)</span>
<span class="gi">+    pts = line[1:last].split(b&quot; &quot;, 1)</span>
<span class="gi">+    line = line[last + 1 :]</span>
<span class="gi">+    section: Section</span>
<span class="gi">+    if len(pts) == 2:</span>
<span class="gi">+        if pts[1][:1] != b&#39;&quot;&#39; or pts[1][-1:] != b&#39;&quot;&#39;:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid subsection {pts[1]!r}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pts[1] = pts[1][1:-1]</span>
<span class="gi">+        if not _check_section_name(pts[0]):</span>
<span class="gi">+            raise ValueError(f&quot;invalid section name {pts[0]!r}&quot;)</span>
<span class="gi">+        section = (pts[0], pts[1])</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not _check_section_name(pts[0]):</span>
<span class="gi">+            raise ValueError(f&quot;invalid section name {pts[0]!r}&quot;)</span>
<span class="gi">+        pts = pts[0].split(b&quot;.&quot;, 1)</span>
<span class="gi">+        if len(pts) == 2:</span>
<span class="gi">+            section = (pts[0], pts[1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            section = (pts[0],)</span>
<span class="gi">+    return section, line</span>


<span class="w"> </span>class ConfigFile(ConfigDict):
<span class="w"> </span>    &quot;&quot;&quot;A Git configuration file, like .git/config or ~/.gitconfig.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, values: Union[MutableMapping[Section, MutableMapping</span>
<span class="gd">-        [Name, Value]], None]=None, encoding: Union[str, None]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        values: Union[</span>
<span class="gi">+            MutableMapping[Section, MutableMapping[Name, Value]], None</span>
<span class="gi">+        ] = None,</span>
<span class="gi">+        encoding: Union[str, None] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(values=values, encoding=encoding)
<span class="w"> </span>        self.path: Optional[str] = None

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_file(cls, f: BinaryIO) -&gt;&#39;ConfigFile&#39;:</span>
<span class="gi">+    def from_file(cls, f: BinaryIO) -&gt; &quot;ConfigFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read configuration from a file-like object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = cls()</span>
<span class="gi">+        section: Optional[Section] = None</span>
<span class="gi">+        setting = None</span>
<span class="gi">+        continuation = None</span>
<span class="gi">+        for lineno, line in enumerate(f.readlines()):</span>
<span class="gi">+            if lineno == 0 and line.startswith(b&quot;\xef\xbb\xbf&quot;):</span>
<span class="gi">+                line = line[3:]</span>
<span class="gi">+            line = line.lstrip()</span>
<span class="gi">+            if setting is None:</span>
<span class="gi">+                if len(line) &gt; 0 and line[:1] == b&quot;[&quot;:</span>
<span class="gi">+                    section, line = _parse_section_header_line(line)</span>
<span class="gi">+                    ret._values.setdefault(section)</span>
<span class="gi">+                if _strip_comments(line).strip() == b&quot;&quot;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if section is None:</span>
<span class="gi">+                    raise ValueError(f&quot;setting {line!r} without section&quot;)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    setting, value = line.split(b&quot;=&quot;, 1)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    setting = line</span>
<span class="gi">+                    value = b&quot;true&quot;</span>
<span class="gi">+                setting = setting.strip()</span>
<span class="gi">+                if not _check_variable_name(setting):</span>
<span class="gi">+                    raise ValueError(f&quot;invalid variable name {setting!r}&quot;)</span>
<span class="gi">+                if value.endswith(b&quot;\\\n&quot;):</span>
<span class="gi">+                    continuation = value[:-2]</span>
<span class="gi">+                elif value.endswith(b&quot;\\\r\n&quot;):</span>
<span class="gi">+                    continuation = value[:-3]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continuation = None</span>
<span class="gi">+                    value = _parse_string(value)</span>
<span class="gi">+                    ret._values[section][setting] = value</span>
<span class="gi">+                    setting = None</span>
<span class="gi">+            else:  # continuation line</span>
<span class="gi">+                if line.endswith(b&quot;\\\n&quot;):</span>
<span class="gi">+                    continuation += line[:-2]</span>
<span class="gi">+                elif line.endswith(b&quot;\\\r\n&quot;):</span>
<span class="gi">+                    continuation += line[:-3]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continuation += line</span>
<span class="gi">+                    value = _parse_string(continuation)</span>
<span class="gi">+                    ret._values[section][setting] = value</span>
<span class="gi">+                    continuation = None</span>
<span class="gi">+                    setting = None</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_path(cls, path: str) -&gt;&#39;ConfigFile&#39;:</span>
<span class="gi">+    def from_path(cls, path: str) -&gt; &quot;ConfigFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read configuration from a file on disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with GitFile(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            ret = cls.from_file(f)</span>
<span class="gi">+            ret.path = path</span>
<span class="gi">+            return ret</span>

<span class="gd">-    def write_to_path(self, path: Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def write_to_path(self, path: Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write configuration to a file on disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if path is None:</span>
<span class="gi">+            path = self.path</span>
<span class="gi">+        with GitFile(path, &quot;wb&quot;) as f:</span>
<span class="gi">+            self.write_to_file(f)</span>

<span class="gd">-    def write_to_file(self, f: BinaryIO) -&gt;None:</span>
<span class="gi">+    def write_to_file(self, f: BinaryIO) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write configuration to a file-like object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for section, values in self._values.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                section_name, subsection_name = section</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                (section_name,) = section</span>
<span class="gi">+                subsection_name = None</span>
<span class="gi">+            if subsection_name is None:</span>
<span class="gi">+                f.write(b&quot;[&quot; + section_name + b&quot;]\n&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.write(b&quot;[&quot; + section_name + b&#39; &quot;&#39; + subsection_name + b&#39;&quot;]\n&#39;)</span>
<span class="gi">+            for key, value in values.items():</span>
<span class="gi">+                value = _format_string(value)</span>
<span class="gi">+                f.write(b&quot;\t&quot; + key + b&quot; = &quot; + value + b&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_xdg_config_home_path(*path_segments):</span>
<span class="gi">+    xdg_config_home = os.environ.get(</span>
<span class="gi">+        &quot;XDG_CONFIG_HOME&quot;,</span>
<span class="gi">+        os.path.expanduser(&quot;~/.config/&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+    return os.path.join(xdg_config_home, *path_segments)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_git_in_win_path():</span>
<span class="gi">+    for exe in (&quot;git.exe&quot;, &quot;git.cmd&quot;):</span>
<span class="gi">+        for path in os.environ.get(&quot;PATH&quot;, &quot;&quot;).split(&quot;;&quot;):</span>
<span class="gi">+            if os.path.exists(os.path.join(path, exe)):</span>
<span class="gi">+                # in windows native shells (powershell/cmd) exe path is</span>
<span class="gi">+                # .../Git/bin/git.exe or .../Git/cmd/git.exe</span>
<span class="gi">+                #</span>
<span class="gi">+                # in git-bash exe path is .../Git/mingw64/bin/git.exe</span>
<span class="gi">+                git_dir, _bin_dir = os.path.split(path)</span>
<span class="gi">+                yield git_dir</span>
<span class="gi">+                parent_dir, basename = os.path.split(git_dir)</span>
<span class="gi">+                if basename == &quot;mingw32&quot; or basename == &quot;mingw64&quot;:</span>
<span class="gi">+                    yield parent_dir</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_git_in_win_reg():</span>
<span class="gi">+    import platform</span>
<span class="gi">+    import winreg</span>
<span class="gi">+</span>
<span class="gi">+    if platform.machine() == &quot;AMD64&quot;:</span>
<span class="gi">+        subkey = (</span>
<span class="gi">+            &quot;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\&quot;</span>
<span class="gi">+            &quot;CurrentVersion\\Uninstall\\Git_is1&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        subkey = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\&quot; &quot;Uninstall\\Git_is1&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for key in (winreg.HKEY_CURRENT_USER, winreg.HKEY_LOCAL_MACHINE):  # type: ignore</span>
<span class="gi">+        with suppress(OSError):</span>
<span class="gi">+            with winreg.OpenKey(key, subkey) as k:  # type: ignore</span>
<span class="gi">+                val, typ = winreg.QueryValueEx(k, &quot;InstallLocation&quot;)  # type: ignore</span>
<span class="gi">+                if typ == winreg.REG_SZ:  # type: ignore</span>
<span class="gi">+                    yield val</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# There is no set standard for system config dirs on windows. We try the</span>
<span class="gi">+# following:</span>
<span class="gi">+#   - %PROGRAMDATA%/Git/config - (deprecated) Windows config dir per CGit docs</span>
<span class="gi">+#   - %PROGRAMFILES%/Git/etc/gitconfig - Git for Windows (msysgit) config dir</span>
<span class="gi">+#     Used if CGit installation (Git/bin/git.exe) is found in PATH in the</span>
<span class="gi">+#     system registry</span>
<span class="gi">+def get_win_system_paths():</span>
<span class="gi">+    if &quot;PROGRAMDATA&quot; in os.environ:</span>
<span class="gi">+        yield os.path.join(os.environ[&quot;PROGRAMDATA&quot;], &quot;Git&quot;, &quot;config&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for git_dir in _find_git_in_win_path():</span>
<span class="gi">+        yield os.path.join(git_dir, &quot;etc&quot;, &quot;gitconfig&quot;)</span>
<span class="gi">+    for git_dir in _find_git_in_win_reg():</span>
<span class="gi">+        yield os.path.join(git_dir, &quot;etc&quot;, &quot;gitconfig&quot;)</span>


<span class="w"> </span>class StackedConfig(Config):
<span class="w"> </span>    &quot;&quot;&quot;Configuration which reads from multiple config files..&quot;&quot;&quot;

<span class="gd">-    def __init__(self, backends: List[ConfigFile], writable: Optional[</span>
<span class="gd">-        ConfigFile]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, backends: List[ConfigFile], writable: Optional[ConfigFile] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.backends = backends
<span class="w"> </span>        self.writable = writable

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__} for {self.backends!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} for {self.backends!r}&gt;&quot;</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def default_backends(cls) -&gt;List[ConfigFile]:</span>
<span class="gi">+    def default(cls) -&gt; &quot;StackedConfig&quot;:</span>
<span class="gi">+        return cls(cls.default_backends())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def default_backends(cls) -&gt; List[ConfigFile]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the default configuration.

<span class="w"> </span>        See git-config(1) for details on the files searched.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def read_submodules(path: str) -&gt;Iterator[Tuple[bytes, bytes, bytes]]:</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        paths.append(os.path.expanduser(&quot;~/.gitconfig&quot;))</span>
<span class="gi">+        paths.append(get_xdg_config_home_path(&quot;git&quot;, &quot;config&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;GIT_CONFIG_NOSYSTEM&quot; not in os.environ:</span>
<span class="gi">+            paths.append(&quot;/etc/gitconfig&quot;)</span>
<span class="gi">+            if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+                paths.extend(get_win_system_paths())</span>
<span class="gi">+</span>
<span class="gi">+        backends = []</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            try:</span>
<span class="gi">+                cf = ConfigFile.from_path(path)</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            backends.append(cf)</span>
<span class="gi">+        return backends</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, section: SectionLike, name: NameLike) -&gt; Value:</span>
<span class="gi">+        if not isinstance(section, tuple):</span>
<span class="gi">+            section = (section,)</span>
<span class="gi">+        for backend in self.backends:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return backend.get(section, name)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise KeyError(name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_multivar(self, section: SectionLike, name: NameLike) -&gt; Iterator[Value]:</span>
<span class="gi">+        if not isinstance(section, tuple):</span>
<span class="gi">+            section = (section,)</span>
<span class="gi">+        for backend in self.backends:</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield from backend.get_multivar(section, name)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    def set(</span>
<span class="gi">+        self, section: SectionLike, name: NameLike, value: Union[ValueLike, bool]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.writable is None:</span>
<span class="gi">+            raise NotImplementedError(self.set)</span>
<span class="gi">+        return self.writable.set(section, name, value)</span>
<span class="gi">+</span>
<span class="gi">+    def sections(self) -&gt; Iterator[Section]:</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        for backend in self.backends:</span>
<span class="gi">+            for section in backend.sections():</span>
<span class="gi">+                if section not in seen:</span>
<span class="gi">+                    seen.add(section)</span>
<span class="gi">+                    yield section</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_submodules(path: str) -&gt; Iterator[Tuple[bytes, bytes, bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a .gitmodules file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cfg = ConfigFile.from_path(path)</span>
<span class="gi">+    return parse_submodules(cfg)</span>


<span class="gd">-def parse_submodules(config: ConfigFile) -&gt;Iterator[Tuple[bytes, bytes, bytes]</span>
<span class="gd">-    ]:</span>
<span class="gi">+def parse_submodules(config: ConfigFile) -&gt; Iterator[Tuple[bytes, bytes, bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a gitmodules GitConfig file, returning submodules.

<span class="w"> </span>    Args:
<span class="gu">@@ -240,15 +753,48 @@ def parse_submodules(config: ConfigFile) -&gt;Iterator[Tuple[bytes, bytes, bytes]</span>
<span class="w"> </span>      list of tuples (submodule path, url, name),
<span class="w"> </span>        where name is quoted part of the section&#39;s name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def iter_instead_of(config: Config, push: bool=False) -&gt;Iterable[Tuple[str,</span>
<span class="gd">-    str]]:</span>
<span class="gi">+    for section in config.keys():</span>
<span class="gi">+        section_kind, section_name = section</span>
<span class="gi">+        if section_kind == b&quot;submodule&quot;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                sm_path = config.get(section, b&quot;path&quot;)</span>
<span class="gi">+                sm_url = config.get(section, b&quot;url&quot;)</span>
<span class="gi">+                yield (sm_path, sm_url, section_name)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # If either path or url is missing, just ignore this</span>
<span class="gi">+                # submodule entry and move on to the next one. This is</span>
<span class="gi">+                # how git itself handles malformed .gitmodule entries.</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_instead_of(config: Config, push: bool = False) -&gt; Iterable[Tuple[str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over insteadOf / pushInsteadOf values.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def apply_instead_of(config: Config, orig_url: str, push: bool=False) -&gt;str:</span>
<span class="gi">+    for section in config.sections():</span>
<span class="gi">+        if section[0] != b&quot;url&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        replacement = section[1]</span>
<span class="gi">+        try:</span>
<span class="gi">+            needles = list(config.get_multivar(section, &quot;insteadOf&quot;))</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            needles = []</span>
<span class="gi">+        if push:</span>
<span class="gi">+            try:</span>
<span class="gi">+                needles += list(config.get_multivar(section, &quot;pushInsteadOf&quot;))</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        for needle in needles:</span>
<span class="gi">+            assert isinstance(needle, bytes)</span>
<span class="gi">+            yield needle.decode(&quot;utf-8&quot;), replacement.decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_instead_of(config: Config, orig_url: str, push: bool = False) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply insteadOf / pushInsteadOf to a URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    longest_needle = &quot;&quot;</span>
<span class="gi">+    updated_url = orig_url</span>
<span class="gi">+    for needle, replacement in iter_instead_of(config, push):</span>
<span class="gi">+        if not orig_url.startswith(needle):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if len(longest_needle) &lt; len(needle):</span>
<span class="gi">+            longest_needle = needle</span>
<span class="gi">+            updated_url = replacement + orig_url[len(needle) :]</span>
<span class="gi">+    return updated_url</span>
<span class="gh">diff --git a/dulwich/contrib/diffstat.py b/dulwich/contrib/diffstat.py</span>
<span class="gh">index 1fbadd25..803c009e 100755</span>
<span class="gd">--- a/dulwich/contrib/diffstat.py</span>
<span class="gi">+++ b/dulwich/contrib/diffstat.py</span>
<span class="gu">@@ -1,28 +1,115 @@</span>
<span class="gi">+#!/usr/bin/env python</span>
<span class="gi">+# vim:ts=4:sw=4:softtabstop=4:smarttab:expandtab</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (c) 2020 Kevin B. Hendricks, Stratford Ontario Canada</span>
<span class="gi">+# All rights reserved.</span>
<span class="gi">+#</span>
<span class="gi">+# This diffstat code was extracted and heavily modified from:</span>
<span class="gi">+#</span>
<span class="gi">+#  https://github.com/techtonik/python-patch</span>
<span class="gi">+#      Under the following license:</span>
<span class="gi">+#</span>
<span class="gi">+#  Patch utility to apply unified diffs</span>
<span class="gi">+#  Brute-force line-by-line non-recursive parsing</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright (c) 2008-2016 anatoly techtonik</span>
<span class="gi">+#</span>
<span class="gi">+# Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="gi">+# of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="gi">+# in the Software without restriction, including without limitation the rights</span>
<span class="gi">+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="gi">+# copies of the Software, and to permit persons to whom the Software is</span>
<span class="gi">+# furnished to do so, subject to the following conditions:</span>
<span class="gi">+#</span>
<span class="gi">+# The above copyright notice and this permission notice shall be included in</span>
<span class="gi">+# all copies or substantial portions of the Software.</span>
<span class="gi">+#</span>
<span class="gi">+# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="gi">+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="gi">+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="gi">+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="gi">+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="gi">+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="gi">+# THE SOFTWARE.</span>
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from typing import List, Optional, Tuple
<span class="gd">-_git_header_name = re.compile(b&#39;diff --git a/(.*) b/(.*)&#39;)</span>
<span class="gd">-_GIT_HEADER_START = b&#39;diff --git a/&#39;</span>
<span class="gd">-_GIT_BINARY_START = b&#39;Binary file&#39;</span>
<span class="gd">-_GIT_RENAMEFROM_START = b&#39;rename from&#39;</span>
<span class="gd">-_GIT_RENAMETO_START = b&#39;rename to&#39;</span>
<span class="gd">-_GIT_CHUNK_START = b&#39;@@&#39;</span>
<span class="gd">-_GIT_ADDED_START = b&#39;+&#39;</span>
<span class="gd">-_GIT_DELETED_START = b&#39;-&#39;</span>
<span class="gd">-_GIT_UNCHANGED_START = b&#39; &#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _parse_patch(lines: List[bytes]) -&gt;Tuple[List[bytes], List[bool], List[</span>
<span class="gd">-    Tuple[int, int]]]:</span>
<span class="gi">+</span>
<span class="gi">+# only needs to detect git style diffs as this is for</span>
<span class="gi">+# use with dulwich</span>
<span class="gi">+</span>
<span class="gi">+_git_header_name = re.compile(rb&quot;diff --git a/(.*) b/(.*)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+_GIT_HEADER_START = b&quot;diff --git a/&quot;</span>
<span class="gi">+_GIT_BINARY_START = b&quot;Binary file&quot;</span>
<span class="gi">+_GIT_RENAMEFROM_START = b&quot;rename from&quot;</span>
<span class="gi">+_GIT_RENAMETO_START = b&quot;rename to&quot;</span>
<span class="gi">+_GIT_CHUNK_START = b&quot;@@&quot;</span>
<span class="gi">+_GIT_ADDED_START = b&quot;+&quot;</span>
<span class="gi">+_GIT_DELETED_START = b&quot;-&quot;</span>
<span class="gi">+_GIT_UNCHANGED_START = b&quot; &quot;</span>
<span class="gi">+</span>
<span class="gi">+# emulate original full Patch class by just extracting</span>
<span class="gi">+# filename and minimal chunk added/deleted information to</span>
<span class="gi">+# properly interface with diffstat routine</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_patch(</span>
<span class="gi">+    lines: List[bytes],</span>
<span class="gi">+) -&gt; Tuple[List[bytes], List[bool], List[Tuple[int, int]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a git style diff or patch to generate diff stats.

<span class="w"> </span>    Args:
<span class="w"> </span>      lines: list of byte string lines from the diff to be parsed
<span class="w"> </span>    Returns: A tuple (names, is_binary, counts) of three lists
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    names = []</span>
<span class="gi">+    nametypes = []</span>
<span class="gi">+    counts = []</span>
<span class="gi">+    in_patch_chunk = in_git_header = binaryfile = False</span>
<span class="gi">+    currentfile: Optional[bytes] = None</span>
<span class="gi">+    added = deleted = 0</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if line.startswith(_GIT_HEADER_START):</span>
<span class="gi">+            if currentfile is not None:</span>
<span class="gi">+                names.append(currentfile)</span>
<span class="gi">+                nametypes.append(binaryfile)</span>
<span class="gi">+                counts.append((added, deleted))</span>
<span class="gi">+            m = _git_header_name.search(line)</span>
<span class="gi">+            assert m</span>
<span class="gi">+            currentfile = m.group(2)</span>
<span class="gi">+            binaryfile = False</span>
<span class="gi">+            added = deleted = 0</span>
<span class="gi">+            in_git_header = True</span>
<span class="gi">+            in_patch_chunk = False</span>
<span class="gi">+        elif line.startswith(_GIT_BINARY_START) and in_git_header:</span>
<span class="gi">+            binaryfile = True</span>
<span class="gi">+            in_git_header = False</span>
<span class="gi">+        elif line.startswith(_GIT_RENAMEFROM_START) and in_git_header:</span>
<span class="gi">+            currentfile = line[12:]</span>
<span class="gi">+        elif line.startswith(_GIT_RENAMETO_START) and in_git_header:</span>
<span class="gi">+            assert currentfile</span>
<span class="gi">+            currentfile += b&quot; =&gt; %s&quot; % line[10:]</span>
<span class="gi">+        elif line.startswith(_GIT_CHUNK_START) and (in_patch_chunk or in_git_header):</span>
<span class="gi">+            in_patch_chunk = True</span>
<span class="gi">+            in_git_header = False</span>
<span class="gi">+        elif line.startswith(_GIT_ADDED_START) and in_patch_chunk:</span>
<span class="gi">+            added += 1</span>
<span class="gi">+        elif line.startswith(_GIT_DELETED_START) and in_patch_chunk:</span>
<span class="gi">+            deleted += 1</span>
<span class="gi">+        elif not line.startswith(_GIT_UNCHANGED_START) and in_patch_chunk:</span>
<span class="gi">+            in_patch_chunk = False</span>
<span class="gi">+    # handle end of input</span>
<span class="gi">+    if currentfile is not None:</span>
<span class="gi">+        names.append(currentfile)</span>
<span class="gi">+        nametypes.append(binaryfile)</span>
<span class="gi">+        counts.append((added, deleted))</span>
<span class="gi">+    return names, nametypes, counts</span>


<span class="gi">+# note must all done using bytes not string because on linux filenames</span>
<span class="gi">+# may not be encodable even to utf-8</span>
<span class="w"> </span>def diffstat(lines, max_width=80):
<span class="w"> </span>    &quot;&quot;&quot;Generate summary statistics from a git style diff ala
<span class="w"> </span>       (git diff tag1 tag2 --stat).
<span class="gu">@@ -34,8 +121,231 @@ def diffstat(lines, max_width=80):</span>
<span class="w"> </span>    Returns: A byte string that lists the changed files with change
<span class="w"> </span>             counts and histogram.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    names, nametypes, counts = _parse_patch(lines)</span>
<span class="gi">+    insert = []</span>
<span class="gi">+    delete = []</span>
<span class="gi">+    namelen = 0</span>
<span class="gi">+    maxdiff = 0  # max changes for any file used for histogram width calc</span>
<span class="gi">+    for i, filename in enumerate(names):</span>
<span class="gi">+        i, d = counts[i]</span>
<span class="gi">+        insert.append(i)</span>
<span class="gi">+        delete.append(d)</span>
<span class="gi">+        namelen = max(namelen, len(filename))</span>
<span class="gi">+        maxdiff = max(maxdiff, i + d)</span>
<span class="gi">+    output = b&quot;&quot;</span>
<span class="gi">+    statlen = len(str(maxdiff))  # stats column width</span>
<span class="gi">+    for i, n in enumerate(names):</span>
<span class="gi">+        binaryfile = nametypes[i]</span>
<span class="gi">+        # %-19s | %-4d %s</span>
<span class="gi">+        # note b&#39;%d&#39; % namelen is not supported until Python 3.5</span>
<span class="gi">+        # To convert an int to a format width specifier for byte</span>
<span class="gi">+        # strings use str(namelen).encode(&#39;ascii&#39;)</span>
<span class="gi">+        format = (</span>
<span class="gi">+            b&quot; %-&quot;</span>
<span class="gi">+            + str(namelen).encode(&quot;ascii&quot;)</span>
<span class="gi">+            + b&quot;s | %&quot;</span>
<span class="gi">+            + str(statlen).encode(&quot;ascii&quot;)</span>
<span class="gi">+            + b&quot;s %s\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        binformat = b&quot; %-&quot; + str(namelen).encode(&quot;ascii&quot;) + b&quot;s | %s\n&quot;</span>
<span class="gi">+        if not binaryfile:</span>
<span class="gi">+            hist = b&quot;&quot;</span>
<span class="gi">+            # -- calculating histogram --</span>
<span class="gi">+            width = len(format % (b&quot;&quot;, b&quot;&quot;, b&quot;&quot;))</span>
<span class="gi">+            histwidth = max(2, max_width - width)</span>
<span class="gi">+            if maxdiff &lt; histwidth:</span>
<span class="gi">+                hist = b&quot;+&quot; * insert[i] + b&quot;-&quot; * delete[i]</span>
<span class="gi">+            else:</span>
<span class="gi">+                iratio = (float(insert[i]) / maxdiff) * histwidth</span>
<span class="gi">+                dratio = (float(delete[i]) / maxdiff) * histwidth</span>
<span class="gi">+                iwidth = dwidth = 0</span>
<span class="gi">+                # make sure every entry that had actual insertions gets</span>
<span class="gi">+                # at least one +</span>
<span class="gi">+                if insert[i] &gt; 0:</span>
<span class="gi">+                    iwidth = int(iratio)</span>
<span class="gi">+                    if iwidth == 0 and 0 &lt; iratio &lt; 1:</span>
<span class="gi">+                        iwidth = 1</span>
<span class="gi">+                # make sure every entry that had actual deletions gets</span>
<span class="gi">+                # at least one -</span>
<span class="gi">+                if delete[i] &gt; 0:</span>
<span class="gi">+                    dwidth = int(dratio)</span>
<span class="gi">+                    if dwidth == 0 and 0 &lt; dratio &lt; 1:</span>
<span class="gi">+                        dwidth = 1</span>
<span class="gi">+                hist = b&quot;+&quot; * int(iwidth) + b&quot;-&quot; * int(dwidth)</span>
<span class="gi">+            output += format % (</span>
<span class="gi">+                bytes(names[i]),</span>
<span class="gi">+                str(insert[i] + delete[i]).encode(&quot;ascii&quot;),</span>
<span class="gi">+                hist,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            output += binformat % (bytes(names[i]), b&quot;Bin&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    output += b&quot; %d files changed, %d insertions(+), %d deletions(-)&quot; % (</span>
<span class="gi">+        len(names),</span>
<span class="gi">+        sum(insert),</span>
<span class="gi">+        sum(delete),</span>
<span class="gi">+    )</span>
<span class="gi">+    return output</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main():</span>
<span class="gi">+    argv = sys.argv</span>
<span class="gi">+    # allow diffstat.py to also be used from the command line</span>
<span class="gi">+    if len(sys.argv) &gt; 1:</span>
<span class="gi">+        diffpath = argv[1]</span>
<span class="gi">+        data = b&quot;&quot;</span>
<span class="gi">+        with open(diffpath, &quot;rb&quot;) as f:</span>
<span class="gi">+            data = f.read()</span>
<span class="gi">+        lines = data.split(b&quot;\n&quot;)</span>
<span class="gi">+        result = diffstat(lines)</span>
<span class="gi">+        print(result.decode(&quot;utf-8&quot;))</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    # if no path argument to a diff file is passed in, run</span>
<span class="gi">+    # a self test. The test case includes tricky things like</span>
<span class="gi">+    # a diff of diff, binary files, renames with further changes</span>
<span class="gi">+    # added files and removed files.</span>
<span class="gi">+    # All extracted from Sigil-Ebook/Sigil&#39;s github repo with</span>
<span class="gi">+    # full permission to use under this license.</span>
<span class="gi">+    selftest = b&quot;&quot;&quot;</span>
<span class="gi">+diff --git a/docs/qt512.7_remove_bad_workaround.patch b/docs/qt512.7_remove_bad_workaround.patch</span>
<span class="gi">+new file mode 100644</span>
<span class="gi">+index 00000000..64e34192</span>
<span class="gi">+--- /dev/null</span>
<span class="gi">++++ b/docs/qt512.7_remove_bad_workaround.patch</span>
<span class="gi">+@@ -0,0 +1,15 @@</span>
<span class="gi">++--- qtbase/src/gui/kernel/qwindow.cpp.orig     2019-12-12 09:15:59.000000000 -0500</span>
<span class="gi">+++++ qtbase/src/gui/kernel/qwindow.cpp  2020-01-10 10:36:53.000000000 -0500</span>
<span class="gi">++@@ -218,12 +218,6 @@</span>
<span class="gi">++     QGuiApplicationPrivate::window_list.removeAll(this);</span>
<span class="gi">++     if (!QGuiApplicationPrivate::is_app_closing)</span>
<span class="gi">++         QGuiApplicationPrivate::instance()-&gt;modalWindowList.removeOne(this);</span>
<span class="gi">++-</span>
<span class="gi">++-    // focus_window is normally cleared in destroy(), but the window may in</span>
<span class="gi">++-    // some cases end up becoming the focus window again. Clear it again</span>
<span class="gi">++-    // here as a workaround. See QTBUG-75326.</span>
<span class="gi">++-    if (QGuiApplicationPrivate::focus_window == this)</span>
<span class="gi">++-        QGuiApplicationPrivate::focus_window = 0;</span>
<span class="gi">++ }</span>
<span class="gi">++</span>
<span class="gi">++ void QWindowPrivate::init(QScreen *targetScreen)</span>
<span class="gi">+diff --git a/docs/testplugin_v017.zip b/docs/testplugin_v017.zip</span>
<span class="gi">+new file mode 100644</span>
<span class="gi">+index 00000000..a4cf4c4c</span>
<span class="gi">+Binary files /dev/null and b/docs/testplugin_v017.zip differ</span>
<span class="gi">+diff --git a/ci_scripts/macgddeploy.py b/ci_scripts/gddeploy.py</span>
<span class="gi">+similarity index 73%</span>
<span class="gi">+rename from ci_scripts/macgddeploy.py</span>
<span class="gi">+rename to ci_scripts/gddeploy.py</span>
<span class="gi">+index a512d075..f9dacd33 100644</span>
<span class="gi">+--- a/ci_scripts/macgddeploy.py</span>
<span class="gi">++++ b/ci_scripts/gddeploy.py</span>
<span class="gi">+@@ -1,19 +1,32 @@</span>
<span class="gi">+ #!/usr/bin/env python3</span>
<span class="gi">+</span>
<span class="gi">+ import os</span>
<span class="gi">++import sys</span>
<span class="gi">+ import subprocess</span>
<span class="gi">+ import datetime</span>
<span class="gi">+ import shutil</span>
<span class="gi">++import glob</span>
<span class="gi">+</span>
<span class="gi">+ gparent = os.path.expandvars(&#39;$GDRIVE_DIR&#39;)</span>
<span class="gi">+ grefresh_token = os.path.expandvars(&#39;$GDRIVE_REFRESH_TOKEN&#39;)</span>
<span class="gi">+</span>
<span class="gi">+-travis_branch = os.path.expandvars(&#39;$TRAVIS_BRANCH&#39;)</span>
<span class="gi">+-travis_commit = os.path.expandvars(&#39;$TRAVIS_COMMIT&#39;)</span>
<span class="gi">+-travis_build_number = os.path.expandvars(&#39;$TRAVIS_BUILD_NUMBER&#39;)</span>
<span class="gi">++if sys.platform.lower().startswith(&#39;darwin&#39;):</span>
<span class="gi">++    travis_branch = os.path.expandvars(&#39;$TRAVIS_BRANCH&#39;)</span>
<span class="gi">++    travis_commit = os.path.expandvars(&#39;$TRAVIS_COMMIT&#39;)</span>
<span class="gi">++    travis_build_number = os.path.expandvars(&#39;$TRAVIS_BUILD_NUMBER&#39;)</span>
<span class="gi">++</span>
<span class="gi">++    origfilename = &#39;./bin/Sigil.tar.xz&#39;</span>
<span class="gi">++    newfilename = &#39;./bin/Sigil-{}-{}-build_num-{}.tar.xz&#39;.format(travis_branch, travis_commit[:7],travis_build_numbe\</span>
<span class="gi">+r)</span>
<span class="gi">++else:</span>
<span class="gi">++    appveyor_branch = os.path.expandvars(&#39;$APPVEYOR_REPO_BRANCH&#39;)</span>
<span class="gi">++    appveyor_commit = os.path.expandvars(&#39;$APPVEYOR_REPO_COMMIT&#39;)</span>
<span class="gi">++    appveyor_build_number = os.path.expandvars(&#39;$APPVEYOR_BUILD_NUMBER&#39;)</span>
<span class="gi">++    names = glob.glob(&#39;.\\installer\\Sigil-*-Setup.exe&#39;)</span>
<span class="gi">++    if not names:</span>
<span class="gi">++        exit(1)</span>
<span class="gi">++    origfilename = names[0]</span>
<span class="gi">++    newfilename = &#39;.\\installer\\Sigil-{}-{}-build_num-{}-Setup.exe&#39;.format(appveyor_branch, appveyor_commit[:7], ap\</span>
<span class="gi">+pveyor_build_number)</span>
<span class="gi">+</span>
<span class="gi">+-origfilename = &#39;./bin/Sigil.tar.xz&#39;</span>
<span class="gi">+-newfilename = &#39;./bin/Sigil-{}-{}-build_num-{}.tar.xz&#39;.format(travis_branch, travis_commit[:7],travis_build_number)</span>
<span class="gi">+ shutil.copy2(origfilename, newfilename)</span>
<span class="gi">+</span>
<span class="gi">+ folder_name = datetime.date.today()</span>
<span class="gi">+diff --git a/docs/qt512.6_backport_009abcd_fix.patch b/docs/qt512.6_backport_009abcd_fix.patch</span>
<span class="gi">+deleted file mode 100644</span>
<span class="gi">+index f4724347..00000000</span>
<span class="gi">+--- a/docs/qt512.6_backport_009abcd_fix.patch</span>
<span class="gi">++++ /dev/null</span>
<span class="gi">+@@ -1,26 +0,0 @@</span>
<span class="gi">+---- qtbase/src/widgets/kernel/qwidget.cpp.orig 2019-11-08 10:57:07.000000000 -0500</span>
<span class="gi">+-+++ qtbase/src/widgets/kernel/qwidget.cpp      2019-12-11 12:32:24.000000000 -0500</span>
<span class="gi">+-@@ -8934,6 +8934,23 @@</span>
<span class="gi">+-         }</span>
<span class="gi">+-     }</span>
<span class="gi">+-     switch (event-&gt;type()) {</span>
<span class="gi">+-+    case QEvent::PlatformSurface: {</span>
<span class="gi">+-+        // Sync up QWidget&#39;s view of whether or not the widget has been created</span>
<span class="gi">+-+        switch (static_cast&lt;QPlatformSurfaceEvent*&gt;(event)-&gt;surfaceEventType()) {</span>
<span class="gi">+-+        case QPlatformSurfaceEvent::SurfaceCreated:</span>
<span class="gi">+-+            if (!testAttribute(Qt::WA_WState_Created))</span>
<span class="gi">+-+                create();</span>
<span class="gi">+-+            break;</span>
<span class="gi">+-+        case QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed:</span>
<span class="gi">+-+            if (testAttribute(Qt::WA_WState_Created)) {</span>
<span class="gi">+-+                // Child windows have already been destroyed by QWindow,</span>
<span class="gi">+-+                // so we skip them here.</span>
<span class="gi">+-+                destroy(false, false);</span>
<span class="gi">+-+            }</span>
<span class="gi">+-+            break;</span>
<span class="gi">+-+        }</span>
<span class="gi">+-+        break;</span>
<span class="gi">+-+    }</span>
<span class="gi">+-     case QEvent::MouseMove:</span>
<span class="gi">+-         mouseMoveEvent((QMouseEvent*)event);</span>
<span class="gi">+-         break;</span>
<span class="gi">+diff --git a/docs/Building_Sigil_On_MacOSX.txt b/docs/Building_Sigil_On_MacOSX.txt</span>
<span class="gi">+index 3b41fd80..64914c78 100644</span>
<span class="gi">+--- a/docs/Building_Sigil_On_MacOSX.txt</span>
<span class="gi">++++ b/docs/Building_Sigil_On_MacOSX.txt</span>
<span class="gi">+@@ -113,7 +113,7 @@ install_name_tool -add_rpath @loader_path/../../Frameworks ./bin/Sigil.app/Content</span>
<span class="gi">+ </span>
<span class="gi">+ # To test if the newly bundled python 3 version of Sigil is working properly ypou can do the following:</span>
<span class="gi">+ </span>
<span class="gi">+-1. download testplugin_v014.zip from https://github.com/Sigil-Ebook/Sigil/tree/master/docs</span>
<span class="gi">++1. download testplugin_v017.zip from https://github.com/Sigil-Ebook/Sigil/tree/master/docs</span>
<span class="gi">+ 2. open Sigil.app to the normal nearly blank template epub it generates when opened</span>
<span class="gi">+ 3. use Plugins-&gt;Manage Plugins menu and make sure the &quot;Use Bundled Python&quot; checkbox is checked</span>
<span class="gi">+ 4. use the &quot;Add Plugin&quot; button to navigate to and add testplugin.zip and then hit &quot;Okay&quot; to exit the Manage Plugins Dialog</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    testoutput = b&quot;&quot;&quot; docs/qt512.7_remove_bad_workaround.patch            | 15 ++++++++++++</span>
<span class="gi">+ docs/testplugin_v017.zip                            | Bin</span>
<span class="gi">+ ci_scripts/macgddeploy.py =&gt; ci_scripts/gddeploy.py |  0 </span>
<span class="gi">+ docs/qt512.6_backport_009abcd_fix.patch             | 26 ---------------------</span>
<span class="gi">+ docs/Building_Sigil_On_MacOSX.txt                   |  2 +-</span>
<span class="gi">+ 5 files changed, 16 insertions(+), 27 deletions(-)&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # return 0 on success otherwise return -1</span>
<span class="gi">+    result = diffstat(selftest.split(b&quot;\n&quot;))</span>
<span class="gi">+    if result == testoutput:</span>
<span class="gi">+        print(&quot;self test passed&quot;)</span>
<span class="gi">+        return 0</span>
<span class="gi">+    print(&quot;self test failed&quot;)</span>
<span class="gi">+    print(&quot;Received:&quot;)</span>
<span class="gi">+    print(result.decode(&quot;utf-8&quot;))</span>
<span class="gi">+    print(&quot;Expected:&quot;)</span>
<span class="gi">+    print(testoutput.decode(&quot;utf-8&quot;))</span>
<span class="gi">+    return -1</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    sys.exit(main())
<span class="gh">diff --git a/dulwich/contrib/paramiko_vendor.py b/dulwich/contrib/paramiko_vendor.py</span>
<span class="gh">index 435df841..4d6da7f4 100644</span>
<span class="gd">--- a/dulwich/contrib/paramiko_vendor.py</span>
<span class="gi">+++ b/dulwich/contrib/paramiko_vendor.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# paramiko_vendor.py -- paramiko implementation of the SSHVendor interface</span>
<span class="gi">+# Copyright (C) 2013 Aaron O&#39;Mullan &lt;aaron.omullan@friendco.de&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Paramiko SSH support for Dulwich.

<span class="w"> </span>To use this implementation as the SSH implementation in Dulwich, override
<span class="gu">@@ -9,19 +29,92 @@ the dulwich.client.get_ssh_vendor attribute:</span>

<span class="w"> </span>This implementation is experimental and does not have any tests.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import paramiko
<span class="w"> </span>import paramiko.client


<span class="w"> </span>class _ParamikoWrapper:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, client, channel) -&gt;None:</span>
<span class="gi">+    def __init__(self, client, channel) -&gt; None:</span>
<span class="w"> </span>        self.client = client
<span class="w"> </span>        self.channel = channel
<span class="gi">+</span>
<span class="gi">+        # Channel must block</span>
<span class="w"> </span>        self.channel.setblocking(True)

<span class="gi">+    @property</span>
<span class="gi">+    def stderr(self):</span>
<span class="gi">+        return self.channel.makefile_stderr(&quot;rb&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def can_read(self):</span>
<span class="gi">+        return self.channel.recv_ready()</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data):</span>
<span class="gi">+        return self.channel.sendall(data)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, n=None):</span>
<span class="gi">+        data = self.channel.recv(n)</span>
<span class="gi">+        data_len = len(data)</span>
<span class="gi">+</span>
<span class="gi">+        # Closed socket</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Read more if needed</span>
<span class="gi">+        if n and data_len &lt; n:</span>
<span class="gi">+            diff_len = n - data_len</span>
<span class="gi">+            return data + self.read(diff_len)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self.channel.close()</span>
<span class="gi">+</span>

<span class="w"> </span>class ParamikoSSHVendor:
<span class="gi">+    # http://docs.paramiko.org/en/2.4/api/client.html</span>

<span class="gd">-    def __init__(self, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, **kwargs) -&gt; None:</span>
<span class="w"> </span>        self.kwargs = kwargs
<span class="gi">+</span>
<span class="gi">+    def run_command(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        command,</span>
<span class="gi">+        username=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        password=None,</span>
<span class="gi">+        pkey=None,</span>
<span class="gi">+        key_filename=None,</span>
<span class="gi">+        protocol_version=None,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    ):</span>
<span class="gi">+        client = paramiko.SSHClient()</span>
<span class="gi">+</span>
<span class="gi">+        connection_kwargs = {&quot;hostname&quot;: host}</span>
<span class="gi">+        connection_kwargs.update(self.kwargs)</span>
<span class="gi">+        if username:</span>
<span class="gi">+            connection_kwargs[&quot;username&quot;] = username</span>
<span class="gi">+        if port:</span>
<span class="gi">+            connection_kwargs[&quot;port&quot;] = port</span>
<span class="gi">+        if password:</span>
<span class="gi">+            connection_kwargs[&quot;password&quot;] = password</span>
<span class="gi">+        if pkey:</span>
<span class="gi">+            connection_kwargs[&quot;pkey&quot;] = pkey</span>
<span class="gi">+        if key_filename:</span>
<span class="gi">+            connection_kwargs[&quot;key_filename&quot;] = key_filename</span>
<span class="gi">+        connection_kwargs.update(kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        policy = paramiko.client.MissingHostKeyPolicy()</span>
<span class="gi">+        client.set_missing_host_key_policy(policy)</span>
<span class="gi">+        client.connect(**connection_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Open SSH session</span>
<span class="gi">+        channel = client.get_transport().open_session()</span>
<span class="gi">+</span>
<span class="gi">+        if protocol_version is None or protocol_version == 2:</span>
<span class="gi">+            channel.set_environment_variable(name=&quot;GIT_PROTOCOL&quot;, value=&quot;version=2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Run commands</span>
<span class="gi">+        channel.exec_command(command)</span>
<span class="gi">+</span>
<span class="gi">+        return _ParamikoWrapper(client, channel)</span>
<span class="gh">diff --git a/dulwich/contrib/release_robot.py b/dulwich/contrib/release_robot.py</span>
<span class="gh">index 3b1d8a46..fc3eefdc 100644</span>
<span class="gd">--- a/dulwich/contrib/release_robot.py</span>
<span class="gi">+++ b/dulwich/contrib/release_robot.py</span>
<span class="gu">@@ -1,3 +1,22 @@</span>
<span class="gi">+# release_robot.py</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Determine last version string from tags.

<span class="w"> </span>Alternate to `Versioneer &lt;https://pypi.python.org/pypi/versioneer/&gt;`_ using
<span class="gu">@@ -24,13 +43,17 @@ EG::</span>


<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>from ..repo import Repo
<span class="gd">-PROJDIR = &#39;.&#39;</span>
<span class="gd">-PATTERN = &#39;[ a-zA-Z_\\-]*([\\d\\.]+[\\-\\w\\.]*)&#39;</span>
<span class="gi">+</span>
<span class="gi">+# CONSTANTS</span>
<span class="gi">+PROJDIR = &quot;.&quot;</span>
<span class="gi">+PATTERN = r&quot;[ a-zA-Z_\-]*([\d\.]+[\-\w\.]*)&quot;</span>


<span class="w"> </span>def get_recent_tags(projdir=PROJDIR):
<span class="gu">@@ -46,7 +69,45 @@ def get_recent_tags(projdir=PROJDIR):</span>
<span class="w"> </span>    Otherwise the tag meta is a tuple containing the tag time, tag id and tag
<span class="w"> </span>    name. Time is in UTC.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with Repo(projdir) as project:  # dulwich repository object</span>
<span class="gi">+        refs = project.get_refs()  # dictionary of refs and their SHA-1 values</span>
<span class="gi">+        tags = {}  # empty dictionary to hold tags, commits and datetimes</span>
<span class="gi">+        # iterate over refs in repository</span>
<span class="gi">+        for key, value in refs.items():</span>
<span class="gi">+            key = key.decode(&quot;utf-8&quot;)  # compatible with Python-3</span>
<span class="gi">+            obj = project.get_object(value)  # dulwich object from SHA-1</span>
<span class="gi">+            # don&#39;t just check if object is &quot;tag&quot; b/c it could be a &quot;commit&quot;</span>
<span class="gi">+            # instead check if &quot;tags&quot; is in the ref-name</span>
<span class="gi">+            if &quot;tags&quot; not in key:</span>
<span class="gi">+                # skip ref if not a tag</span>
<span class="gi">+                continue</span>
<span class="gi">+            # strip the leading text from refs to get &quot;tag name&quot;</span>
<span class="gi">+            _, tag = key.rsplit(&quot;/&quot;, 1)</span>
<span class="gi">+            # check if tag object is &quot;commit&quot; or &quot;tag&quot; pointing to a &quot;commit&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                commit = obj.object  # a tuple (commit class, commit id)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                commit = obj</span>
<span class="gi">+                tag_meta = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                tag_meta = (</span>
<span class="gi">+                    datetime.datetime(*time.gmtime(obj.tag_time)[:6]),</span>
<span class="gi">+                    obj.id.decode(&quot;utf-8&quot;),</span>
<span class="gi">+                    obj.name.decode(&quot;utf-8&quot;),</span>
<span class="gi">+                )  # compatible with Python-3</span>
<span class="gi">+                commit = project.get_object(commit[1])  # commit object</span>
<span class="gi">+            # get tag commit datetime, but dulwich returns seconds since</span>
<span class="gi">+            # beginning of epoch, so use Python time module to convert it to</span>
<span class="gi">+            # timetuple then convert to datetime</span>
<span class="gi">+            tags[tag] = [</span>
<span class="gi">+                datetime.datetime(*time.gmtime(commit.commit_time)[:6]),</span>
<span class="gi">+                commit.id.decode(&quot;utf-8&quot;),</span>
<span class="gi">+                commit.author.decode(&quot;utf-8&quot;),</span>
<span class="gi">+                tag_meta,</span>
<span class="gi">+            ]  # compatible with Python-3</span>
<span class="gi">+</span>
<span class="gi">+    # return list of tags sorted by their datetimes from newest to oldest</span>
<span class="gi">+    return sorted(tags.items(), key=lambda tag: tag[1][0], reverse=True)</span>


<span class="w"> </span>def get_current_version(projdir=PROJDIR, pattern=PATTERN, logger=None):
<span class="gu">@@ -63,10 +124,22 @@ def get_current_version(projdir=PROJDIR, pattern=PATTERN, logger=None):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      tag matching first group in regular expression pattern
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    tags = get_recent_tags(projdir)</span>
<span class="gi">+    try:</span>
<span class="gi">+        tag = tags[0][0]</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        return</span>
<span class="gi">+    matches = re.match(pattern, tag)</span>
<span class="gi">+    try:</span>
<span class="gi">+        current_version = matches.group(1)</span>
<span class="gi">+    except (IndexError, AttributeError) as err:</span>
<span class="gi">+        if logger:</span>
<span class="gi">+            logger.exception(err)</span>
<span class="gi">+        return tag</span>
<span class="gi">+    return current_version</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    if len(sys.argv) &gt; 1:
<span class="w"> </span>        _PROJDIR = sys.argv[1]
<span class="w"> </span>    else:
<span class="gh">diff --git a/dulwich/contrib/requests_vendor.py b/dulwich/contrib/requests_vendor.py</span>
<span class="gh">index fd2439dc..b556f314 100644</span>
<span class="gd">--- a/dulwich/contrib/requests_vendor.py</span>
<span class="gi">+++ b/dulwich/contrib/requests_vendor.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# requests_vendor.py -- requests implementation of the AbstractHttpGitClient interface</span>
<span class="gi">+# Copyright (C) 2022 Eden Shalit &lt;epopcop@gmail.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Requests HTTP client support for Dulwich.

<span class="w"> </span>To use this implementation as the HTTP implementation in Dulwich, override
<span class="gu">@@ -9,19 +29,113 @@ the dulwich.client.HttpGitClient attribute:</span>

<span class="w"> </span>This implementation is experimental and does not have any tests.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from io import BytesIO
<span class="gi">+</span>
<span class="w"> </span>from requests import Session
<span class="gd">-from ..client import AbstractHttpGitClient, HTTPProxyUnauthorized, HTTPUnauthorized, default_user_agent_string</span>
<span class="gi">+</span>
<span class="gi">+from ..client import (</span>
<span class="gi">+    AbstractHttpGitClient,</span>
<span class="gi">+    HTTPProxyUnauthorized,</span>
<span class="gi">+    HTTPUnauthorized,</span>
<span class="gi">+    default_user_agent_string,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ..errors import GitProtocolError, NotGitRepository


<span class="w"> </span>class RequestsHttpGitClient(AbstractHttpGitClient):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, base_url, dumb=None, config=None, username=None,</span>
<span class="gd">-        password=None, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, base_url, dumb=None, config=None, username=None, password=None, **kwargs</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._username = username
<span class="w"> </span>        self._password = password
<span class="gi">+</span>
<span class="w"> </span>        self.session = get_session(config)
<span class="gi">+</span>
<span class="w"> </span>        if username is not None:
<span class="gd">-            self.session.auth = username, password</span>
<span class="gi">+            self.session.auth = (username, password)</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(base_url=base_url, dumb=dumb, **kwargs)
<span class="gi">+</span>
<span class="gi">+    def _http_request(self, url, headers=None, data=None, allow_compression=False):</span>
<span class="gi">+        req_headers = self.session.headers.copy()</span>
<span class="gi">+        if headers is not None:</span>
<span class="gi">+            req_headers.update(headers)</span>
<span class="gi">+</span>
<span class="gi">+        if allow_compression:</span>
<span class="gi">+            req_headers[&quot;Accept-Encoding&quot;] = &quot;gzip&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            req_headers[&quot;Accept-Encoding&quot;] = &quot;identity&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if data:</span>
<span class="gi">+            resp = self.session.post(url, headers=req_headers, data=data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            resp = self.session.get(url, headers=req_headers)</span>
<span class="gi">+</span>
<span class="gi">+        if resp.status_code == 404:</span>
<span class="gi">+            raise NotGitRepository</span>
<span class="gi">+        if resp.status_code == 401:</span>
<span class="gi">+            raise HTTPUnauthorized(resp.headers.get(&quot;WWW-Authenticate&quot;), url)</span>
<span class="gi">+        if resp.status_code == 407:</span>
<span class="gi">+            raise HTTPProxyUnauthorized(resp.headers.get(&quot;Proxy-Authenticate&quot;), url)</span>
<span class="gi">+        if resp.status_code != 200:</span>
<span class="gi">+            raise GitProtocolError(</span>
<span class="gi">+                &quot;unexpected http resp %d for %s&quot; % (resp.status_code, url)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Add required fields as stated in AbstractHttpGitClient._http_request</span>
<span class="gi">+        resp.content_type = resp.headers.get(&quot;Content-Type&quot;)</span>
<span class="gi">+        resp.redirect_location = &quot;&quot;</span>
<span class="gi">+        if resp.history:</span>
<span class="gi">+            resp.redirect_location = resp.url</span>
<span class="gi">+</span>
<span class="gi">+        read = BytesIO(resp.content).read</span>
<span class="gi">+</span>
<span class="gi">+        return resp, read</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_session(config):</span>
<span class="gi">+    session = Session()</span>
<span class="gi">+    session.headers.update({&quot;Pragma&quot;: &quot;no-cache&quot;})</span>
<span class="gi">+</span>
<span class="gi">+    proxy_server = user_agent = ca_certs = ssl_verify = None</span>
<span class="gi">+</span>
<span class="gi">+    if config is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            proxy_server = config.get(b&quot;http&quot;, b&quot;proxy&quot;)</span>
<span class="gi">+            if isinstance(proxy_server, bytes):</span>
<span class="gi">+                proxy_server = proxy_server.decode()</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            user_agent = config.get(b&quot;http&quot;, b&quot;useragent&quot;)</span>
<span class="gi">+            if isinstance(user_agent, bytes):</span>
<span class="gi">+                user_agent = user_agent.decode()</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            ssl_verify = config.get_boolean(b&quot;http&quot;, b&quot;sslVerify&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            ssl_verify = True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            ca_certs = config.get(b&quot;http&quot;, b&quot;sslCAInfo&quot;)</span>
<span class="gi">+            if isinstance(ca_certs, bytes):</span>
<span class="gi">+                ca_certs = ca_certs.decode()</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            ca_certs = None</span>
<span class="gi">+</span>
<span class="gi">+    if user_agent is None:</span>
<span class="gi">+        user_agent = default_user_agent_string()</span>
<span class="gi">+    session.headers.update({&quot;User-agent&quot;: user_agent})</span>
<span class="gi">+</span>
<span class="gi">+    if ca_certs:</span>
<span class="gi">+        session.verify = ca_certs</span>
<span class="gi">+    elif ssl_verify is False:</span>
<span class="gi">+        session.verify = ssl_verify</span>
<span class="gi">+</span>
<span class="gi">+    if proxy_server:</span>
<span class="gi">+        session.proxies.update({&quot;http&quot;: proxy_server, &quot;https&quot;: proxy_server})</span>
<span class="gi">+    return session</span>
<span class="gh">diff --git a/dulwich/contrib/swift.py b/dulwich/contrib/swift.py</span>
<span class="gh">index cca06a4e..57887ceb 100644</span>
<span class="gd">--- a/dulwich/contrib/swift.py</span>
<span class="gi">+++ b/dulwich/contrib/swift.py</span>
<span class="gu">@@ -1,4 +1,31 @@</span>
<span class="gi">+# swift.py -- Repo implementation atop OpenStack SWIFT</span>
<span class="gi">+# Copyright (C) 2013 eNovance SAS &lt;licensing@enovance.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Author: Fabien Boucher &lt;fabien.boucher@enovance.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Repo implementation atop OpenStack SWIFT.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# TODO: Refactor to share more code with dulwich/repo.py.</span>
<span class="gi">+# TODO(fbo): Second attempt to _send() must be notified via real log</span>
<span class="gi">+# TODO(fbo): More logs for operations</span>
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="gu">@@ -9,16 +36,33 @@ import urllib.parse as urlparse</span>
<span class="w"> </span>import zlib
<span class="w"> </span>from configparser import ConfigParser
<span class="w"> </span>from io import BytesIO
<span class="gi">+</span>
<span class="w"> </span>from geventhttpclient import HTTPClient
<span class="gi">+</span>
<span class="w"> </span>from ..greenthreads import GreenThreadsMissingObjectFinder
<span class="w"> </span>from ..lru_cache import LRUSizeCache
<span class="w"> </span>from ..object_store import INFODIR, PACKDIR, PackBasedObjectStore
<span class="w"> </span>from ..objects import S_ISGITLINK, Blob, Commit, Tag, Tree
<span class="gd">-from ..pack import Pack, PackData, PackIndexer, PackStreamCopier, _compute_object_size, compute_file_sha, iter_sha1, load_pack_index_file, read_pack_header, unpack_object, write_pack_header, write_pack_index_v2, write_pack_object</span>
<span class="gi">+from ..pack import (</span>
<span class="gi">+    Pack,</span>
<span class="gi">+    PackData,</span>
<span class="gi">+    PackIndexer,</span>
<span class="gi">+    PackStreamCopier,</span>
<span class="gi">+    _compute_object_size,</span>
<span class="gi">+    compute_file_sha,</span>
<span class="gi">+    iter_sha1,</span>
<span class="gi">+    load_pack_index_file,</span>
<span class="gi">+    read_pack_header,</span>
<span class="gi">+    unpack_object,</span>
<span class="gi">+    write_pack_header,</span>
<span class="gi">+    write_pack_index_v2,</span>
<span class="gi">+    write_pack_object,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ..protocol import TCP_GIT_PORT
<span class="w"> </span>from ..refs import InfoRefsContainer, read_info_refs, write_info_refs
<span class="w"> </span>from ..repo import OBJECTDIR, BaseRepo
<span class="w"> </span>from ..server import Backend, TCPGitServer
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span># Configuration file sample
<span class="w"> </span>[swift]
<span class="gu">@@ -48,7 +92,26 @@ cache_length = 20</span>


<span class="w"> </span>class PackInfoMissingObjectFinder(GreenThreadsMissingObjectFinder):
<span class="gd">-    pass</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if not self.objects_to_send:</span>
<span class="gi">+                return None</span>
<span class="gi">+            (sha, name, leaf) = self.objects_to_send.pop()</span>
<span class="gi">+            if sha not in self.sha_done:</span>
<span class="gi">+                break</span>
<span class="gi">+        if not leaf:</span>
<span class="gi">+            info = self.object_store.pack_info_get(sha)</span>
<span class="gi">+            if info[0] == Commit.type_num:</span>
<span class="gi">+                self.add_todo([(info[2], &quot;&quot;, False)])</span>
<span class="gi">+            elif info[0] == Tree.type_num:</span>
<span class="gi">+                self.add_todo([tuple(i) for i in info[1]])</span>
<span class="gi">+            elif info[0] == Tag.type_num:</span>
<span class="gi">+                self.add_todo([(info[1], None, False)])</span>
<span class="gi">+            if sha in self._tagged:</span>
<span class="gi">+                self.add_todo([(self._tagged[sha], None, True)])</span>
<span class="gi">+        self.sha_done.add(sha)</span>
<span class="gi">+        self.progress(&quot;counting objects: %d\r&quot; % len(self.sha_done))</span>
<span class="gi">+        return (sha, name)</span>


<span class="w"> </span>def load_conf(path=None, file=None):
<span class="gu">@@ -58,7 +121,26 @@ def load_conf(path=None, file=None):</span>
<span class="w"> </span>      path: The path to the configuration file
<span class="w"> </span>      file: If provided read instead the file like object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    conf = ConfigParser()</span>
<span class="gi">+    if file:</span>
<span class="gi">+        try:</span>
<span class="gi">+            conf.read_file(file, path)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # read_file only exists in Python3</span>
<span class="gi">+            conf.readfp(file)</span>
<span class="gi">+        return conf</span>
<span class="gi">+    confpath = None</span>
<span class="gi">+    if not path:</span>
<span class="gi">+        try:</span>
<span class="gi">+            confpath = os.environ[&quot;DULWICH_SWIFT_CFG&quot;]</span>
<span class="gi">+        except KeyError as exc:</span>
<span class="gi">+            raise Exception(&quot;You need to specify a configuration file&quot;) from exc</span>
<span class="gi">+    else:</span>
<span class="gi">+        confpath = path</span>
<span class="gi">+    if not os.path.isfile(confpath):</span>
<span class="gi">+        raise Exception(f&quot;Unable to read configuration file {confpath}&quot;)</span>
<span class="gi">+    conf.read(confpath)</span>
<span class="gi">+    return conf</span>


<span class="w"> </span>def swift_load_pack_index(scon, filename):
<span class="gu">@@ -69,7 +151,45 @@ def swift_load_pack_index(scon, filename):</span>
<span class="w"> </span>      filename: Path to the index file objectise
<span class="w"> </span>    Returns: a `PackIndexer` instance
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with scon.get_object(filename) as f:</span>
<span class="gi">+        return load_pack_index_file(filename, f)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pack_info_create(pack_data, pack_index):</span>
<span class="gi">+    pack = Pack.from_objects(pack_data, pack_index)</span>
<span class="gi">+    info = {}</span>
<span class="gi">+    for obj in pack.iterobjects():</span>
<span class="gi">+        # Commit</span>
<span class="gi">+        if obj.type_num == Commit.type_num:</span>
<span class="gi">+            info[obj.id] = (obj.type_num, obj.parents, obj.tree)</span>
<span class="gi">+        # Tree</span>
<span class="gi">+        elif obj.type_num == Tree.type_num:</span>
<span class="gi">+            shas = [</span>
<span class="gi">+                (s, n, not stat.S_ISDIR(m))</span>
<span class="gi">+                for n, m, s in obj.items()</span>
<span class="gi">+                if not S_ISGITLINK(m)</span>
<span class="gi">+            ]</span>
<span class="gi">+            info[obj.id] = (obj.type_num, shas)</span>
<span class="gi">+        # Blob</span>
<span class="gi">+        elif obj.type_num == Blob.type_num:</span>
<span class="gi">+            info[obj.id] = None</span>
<span class="gi">+        # Tag</span>
<span class="gi">+        elif obj.type_num == Tag.type_num:</span>
<span class="gi">+            info[obj.id] = (obj.type_num, obj.object[1])</span>
<span class="gi">+    return zlib.compress(json.dumps(info))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_pack_info(filename, scon=None, file=None):</span>
<span class="gi">+    if not file:</span>
<span class="gi">+        f = scon.get_object(filename)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f = file</span>
<span class="gi">+    if not f:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        return json.loads(zlib.decompress(f.read()))</span>
<span class="gi">+    finally:</span>
<span class="gi">+        f.close()</span>


<span class="w"> </span>class SwiftException(Exception):
<span class="gu">@@ -79,7 +199,7 @@ class SwiftException(Exception):</span>
<span class="w"> </span>class SwiftConnector:
<span class="w"> </span>    &quot;&quot;&quot;A Connector to swift that manage authentication and errors catching.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, root, conf) -&gt;None:</span>
<span class="gi">+    def __init__(self, root, conf) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a SwiftConnector.

<span class="w"> </span>        Args:
<span class="gu">@@ -87,42 +207,114 @@ class SwiftConnector:</span>
<span class="w"> </span>          conf: A ConfigParser Object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.conf = conf
<span class="gd">-        self.auth_ver = self.conf.get(&#39;swift&#39;, &#39;auth_ver&#39;)</span>
<span class="gd">-        if self.auth_ver not in [&#39;1&#39;, &#39;2&#39;]:</span>
<span class="gd">-            raise NotImplementedError(</span>
<span class="gd">-                &#39;Wrong authentication version use either 1 or 2&#39;)</span>
<span class="gd">-        self.auth_url = self.conf.get(&#39;swift&#39;, &#39;auth_url&#39;)</span>
<span class="gd">-        self.user = self.conf.get(&#39;swift&#39;, &#39;username&#39;)</span>
<span class="gd">-        self.password = self.conf.get(&#39;swift&#39;, &#39;password&#39;)</span>
<span class="gd">-        self.concurrency = self.conf.getint(&#39;swift&#39;, &#39;concurrency&#39;) or 10</span>
<span class="gd">-        self.http_timeout = self.conf.getint(&#39;swift&#39;, &#39;http_timeout&#39;) or 20</span>
<span class="gd">-        self.http_pool_length = self.conf.getint(&#39;swift&#39;, &#39;http_pool_length&#39;</span>
<span class="gd">-            ) or 10</span>
<span class="gd">-        self.region_name = self.conf.get(&#39;swift&#39;, &#39;region_name&#39;) or &#39;RegionOne&#39;</span>
<span class="gd">-        self.endpoint_type = self.conf.get(&#39;swift&#39;, &#39;endpoint_type&#39;</span>
<span class="gd">-            ) or &#39;internalURL&#39;</span>
<span class="gd">-        self.cache_length = self.conf.getint(&#39;swift&#39;, &#39;cache_length&#39;) or 20</span>
<span class="gd">-        self.chunk_length = self.conf.getint(&#39;swift&#39;, &#39;chunk_length&#39;) or 12228</span>
<span class="gi">+        self.auth_ver = self.conf.get(&quot;swift&quot;, &quot;auth_ver&quot;)</span>
<span class="gi">+        if self.auth_ver not in [&quot;1&quot;, &quot;2&quot;]:</span>
<span class="gi">+            raise NotImplementedError(&quot;Wrong authentication version use either 1 or 2&quot;)</span>
<span class="gi">+        self.auth_url = self.conf.get(&quot;swift&quot;, &quot;auth_url&quot;)</span>
<span class="gi">+        self.user = self.conf.get(&quot;swift&quot;, &quot;username&quot;)</span>
<span class="gi">+        self.password = self.conf.get(&quot;swift&quot;, &quot;password&quot;)</span>
<span class="gi">+        self.concurrency = self.conf.getint(&quot;swift&quot;, &quot;concurrency&quot;) or 10</span>
<span class="gi">+        self.http_timeout = self.conf.getint(&quot;swift&quot;, &quot;http_timeout&quot;) or 20</span>
<span class="gi">+        self.http_pool_length = self.conf.getint(&quot;swift&quot;, &quot;http_pool_length&quot;) or 10</span>
<span class="gi">+        self.region_name = self.conf.get(&quot;swift&quot;, &quot;region_name&quot;) or &quot;RegionOne&quot;</span>
<span class="gi">+        self.endpoint_type = self.conf.get(&quot;swift&quot;, &quot;endpoint_type&quot;) or &quot;internalURL&quot;</span>
<span class="gi">+        self.cache_length = self.conf.getint(&quot;swift&quot;, &quot;cache_length&quot;) or 20</span>
<span class="gi">+        self.chunk_length = self.conf.getint(&quot;swift&quot;, &quot;chunk_length&quot;) or 12228</span>
<span class="w"> </span>        self.root = root
<span class="gd">-        block_size = 1024 * 12</span>
<span class="gd">-        if self.auth_ver == &#39;1&#39;:</span>
<span class="gi">+        block_size = 1024 * 12  # 12KB</span>
<span class="gi">+        if self.auth_ver == &quot;1&quot;:</span>
<span class="w"> </span>            self.storage_url, self.token = self.swift_auth_v1()
<span class="w"> </span>        else:
<span class="w"> </span>            self.storage_url, self.token = self.swift_auth_v2()
<span class="gd">-        token_header = {&#39;X-Auth-Token&#39;: str(self.token)}</span>
<span class="gd">-        self.httpclient = HTTPClient.from_url(str(self.storage_url),</span>
<span class="gd">-            concurrency=self.http_pool_length, block_size=block_size,</span>
<span class="gd">-            connection_timeout=self.http_timeout, network_timeout=self.</span>
<span class="gd">-            http_timeout, headers=token_header)</span>
<span class="gd">-        self.base_path = str(posixpath.join(urlparse.urlparse(self.</span>
<span class="gd">-            storage_url).path, self.root))</span>
<span class="gi">+</span>
<span class="gi">+        token_header = {&quot;X-Auth-Token&quot;: str(self.token)}</span>
<span class="gi">+        self.httpclient = HTTPClient.from_url(</span>
<span class="gi">+            str(self.storage_url),</span>
<span class="gi">+            concurrency=self.http_pool_length,</span>
<span class="gi">+            block_size=block_size,</span>
<span class="gi">+            connection_timeout=self.http_timeout,</span>
<span class="gi">+            network_timeout=self.http_timeout,</span>
<span class="gi">+            headers=token_header,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.base_path = str(</span>
<span class="gi">+            posixpath.join(urlparse.urlparse(self.storage_url).path, self.root)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def swift_auth_v1(self):</span>
<span class="gi">+        self.user = self.user.replace(&quot;;&quot;, &quot;:&quot;)</span>
<span class="gi">+        auth_httpclient = HTTPClient.from_url(</span>
<span class="gi">+            self.auth_url,</span>
<span class="gi">+            connection_timeout=self.http_timeout,</span>
<span class="gi">+            network_timeout=self.http_timeout,</span>
<span class="gi">+        )</span>
<span class="gi">+        headers = {&quot;X-Auth-User&quot;: self.user, &quot;X-Auth-Key&quot;: self.password}</span>
<span class="gi">+        path = urlparse.urlparse(self.auth_url).path</span>
<span class="gi">+</span>
<span class="gi">+        ret = auth_httpclient.request(&quot;GET&quot;, path, headers=headers)</span>
<span class="gi">+</span>
<span class="gi">+        # Should do something with redirections (301 in my case)</span>
<span class="gi">+</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt;= 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                &quot;AUTH v1.0 request failed on &quot;</span>
<span class="gi">+                + f&quot;{self.auth_url} with error code {ret.status_code} ({ret.items()!s})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        storage_url = ret[&quot;X-Storage-Url&quot;]</span>
<span class="gi">+        token = ret[&quot;X-Auth-Token&quot;]</span>
<span class="gi">+        return storage_url, token</span>
<span class="gi">+</span>
<span class="gi">+    def swift_auth_v2(self):</span>
<span class="gi">+        self.tenant, self.user = self.user.split(&quot;;&quot;)</span>
<span class="gi">+        auth_dict = {}</span>
<span class="gi">+        auth_dict[&quot;auth&quot;] = {</span>
<span class="gi">+            &quot;passwordCredentials&quot;: {</span>
<span class="gi">+                &quot;username&quot;: self.user,</span>
<span class="gi">+                &quot;password&quot;: self.password,</span>
<span class="gi">+            },</span>
<span class="gi">+            &quot;tenantName&quot;: self.tenant,</span>
<span class="gi">+        }</span>
<span class="gi">+        auth_json = json.dumps(auth_dict)</span>
<span class="gi">+        headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}</span>
<span class="gi">+        auth_httpclient = HTTPClient.from_url(</span>
<span class="gi">+            self.auth_url,</span>
<span class="gi">+            connection_timeout=self.http_timeout,</span>
<span class="gi">+            network_timeout=self.http_timeout,</span>
<span class="gi">+        )</span>
<span class="gi">+        path = urlparse.urlparse(self.auth_url).path</span>
<span class="gi">+        if not path.endswith(&quot;tokens&quot;):</span>
<span class="gi">+            path = posixpath.join(path, &quot;tokens&quot;)</span>
<span class="gi">+        ret = auth_httpclient.request(&quot;POST&quot;, path, body=auth_json, headers=headers)</span>
<span class="gi">+</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt;= 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                &quot;AUTH v2.0 request failed on &quot;</span>
<span class="gi">+                + f&quot;{str(auth_httpclient.get_base_url()) + path} with error code {ret.status_code} ({ret.items()!s})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        auth_ret_json = json.loads(ret.read())</span>
<span class="gi">+        token = auth_ret_json[&quot;access&quot;][&quot;token&quot;][&quot;id&quot;]</span>
<span class="gi">+        catalogs = auth_ret_json[&quot;access&quot;][&quot;serviceCatalog&quot;]</span>
<span class="gi">+        object_store = next(</span>
<span class="gi">+            o_store for o_store in catalogs if o_store[&quot;type&quot;] == &quot;object-store&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        endpoints = object_store[&quot;endpoints&quot;]</span>
<span class="gi">+        endpoint = next(</span>
<span class="gi">+            endp for endp in endpoints if endp[&quot;region&quot;] == self.region_name</span>
<span class="gi">+        )</span>
<span class="gi">+        return endpoint[self.endpoint_type], token</span>

<span class="w"> </span>    def test_root_exists(self):
<span class="w"> </span>        &quot;&quot;&quot;Check that Swift container exist.

<span class="w"> </span>        Returns: True if exist or None it not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = self.httpclient.request(&quot;HEAD&quot;, self.base_path)</span>
<span class="gi">+        if ret.status_code == 404:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;HEAD request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def create_root(self):
<span class="w"> </span>        &quot;&quot;&quot;Create the Swift container.
<span class="gu">@@ -130,7 +322,12 @@ class SwiftConnector:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          SwiftException: if unable to create
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.test_root_exists():</span>
<span class="gi">+            ret = self.httpclient.request(&quot;PUT&quot;, self.base_path)</span>
<span class="gi">+            if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+                raise SwiftException(</span>
<span class="gi">+                    f&quot;PUT request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def get_container_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve objects list in a container.
<span class="gu">@@ -138,7 +335,17 @@ class SwiftConnector:</span>
<span class="w"> </span>        Returns: A list of dict that describe objects
<span class="w"> </span>                 or None if container does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        qs = &quot;?format=json&quot;</span>
<span class="gi">+        path = self.base_path + qs</span>
<span class="gi">+        ret = self.httpclient.request(&quot;GET&quot;, path)</span>
<span class="gi">+        if ret.status_code == 404:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;GET request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        content = ret.read()</span>
<span class="gi">+        return json.loads(content)</span>

<span class="w"> </span>    def get_object_stat(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve object stat.
<span class="gu">@@ -148,7 +355,18 @@ class SwiftConnector:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          A dict that describe the object or None if object does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self.base_path + &quot;/&quot; + name</span>
<span class="gi">+        ret = self.httpclient.request(&quot;HEAD&quot;, path)</span>
<span class="gi">+        if ret.status_code == 404:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;HEAD request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        resp_headers = {}</span>
<span class="gi">+        for header, value in ret.items():</span>
<span class="gi">+            resp_headers[header.lower()] = value</span>
<span class="gi">+        return resp_headers</span>

<span class="w"> </span>    def put_object(self, name, content):
<span class="w"> </span>        &quot;&quot;&quot;Put an object.
<span class="gu">@@ -159,7 +377,26 @@ class SwiftConnector:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          SwiftException: if unable to create
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        content.seek(0)</span>
<span class="gi">+        data = content.read()</span>
<span class="gi">+        path = self.base_path + &quot;/&quot; + name</span>
<span class="gi">+        headers = {&quot;Content-Length&quot;: str(len(data))}</span>
<span class="gi">+</span>
<span class="gi">+        def _send():</span>
<span class="gi">+            ret = self.httpclient.request(&quot;PUT&quot;, path, body=data, headers=headers)</span>
<span class="gi">+            return ret</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Sometime got Broken Pipe - Dirty workaround</span>
<span class="gi">+            ret = _send()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # Second attempt work</span>
<span class="gi">+            ret = _send()</span>
<span class="gi">+</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;PUT request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def get_object(self, name, range=None):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve an object.
<span class="gu">@@ -171,7 +408,22 @@ class SwiftConnector:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          A file like instance or bytestring if range is specified
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = {}</span>
<span class="gi">+        if range:</span>
<span class="gi">+            headers[&quot;Range&quot;] = f&quot;bytes={range}&quot;</span>
<span class="gi">+        path = self.base_path + &quot;/&quot; + name</span>
<span class="gi">+        ret = self.httpclient.request(&quot;GET&quot;, path, headers=headers)</span>
<span class="gi">+        if ret.status_code == 404:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;GET request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        content = ret.read()</span>
<span class="gi">+</span>
<span class="gi">+        if range:</span>
<span class="gi">+            return content</span>
<span class="gi">+        return BytesIO(content)</span>

<span class="w"> </span>    def del_object(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Delete an object.
<span class="gu">@@ -181,7 +433,12 @@ class SwiftConnector:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          SwiftException: if unable to delete
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self.base_path + &quot;/&quot; + name</span>
<span class="gi">+        ret = self.httpclient.request(&quot;DELETE&quot;, path)</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;DELETE request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def del_root(self):
<span class="w"> </span>        &quot;&quot;&quot;Delete the root container by removing container content.
<span class="gu">@@ -189,7 +446,13 @@ class SwiftConnector:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          SwiftException: if unable to delete
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for obj in self.get_container_objects():</span>
<span class="gi">+            self.del_object(obj[&quot;name&quot;])</span>
<span class="gi">+        ret = self.httpclient.request(&quot;DELETE&quot;, self.base_path)</span>
<span class="gi">+        if ret.status_code &lt; 200 or ret.status_code &gt; 300:</span>
<span class="gi">+            raise SwiftException(</span>
<span class="gi">+                f&quot;DELETE request failed with error code {ret.status_code}&quot;</span>
<span class="gi">+            )</span>


<span class="w"> </span>class SwiftPackReader:
<span class="gu">@@ -202,7 +465,7 @@ class SwiftPackReader:</span>
<span class="w"> </span>    to read from Swift.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, scon, filename, pack_length) -&gt;None:</span>
<span class="gi">+    def __init__(self, scon, filename, pack_length) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a SwiftPackReader.

<span class="w"> </span>        Args:
<span class="gu">@@ -215,9 +478,17 @@ class SwiftPackReader:</span>
<span class="w"> </span>        self.pack_length = pack_length
<span class="w"> </span>        self.offset = 0
<span class="w"> </span>        self.base_offset = 0
<span class="gd">-        self.buff = b&#39;&#39;</span>
<span class="gi">+        self.buff = b&quot;&quot;</span>
<span class="w"> </span>        self.buff_length = self.scon.chunk_length

<span class="gi">+    def _read(self, more=False):</span>
<span class="gi">+        if more:</span>
<span class="gi">+            self.buff_length = self.buff_length * 2</span>
<span class="gi">+        offset = self.base_offset</span>
<span class="gi">+        r = min(self.base_offset + self.buff_length, self.pack_length)</span>
<span class="gi">+        ret = self.scon.get_object(self.filename, range=f&quot;{offset}-{r}&quot;)</span>
<span class="gi">+        self.buff = ret</span>
<span class="gi">+</span>
<span class="w"> </span>    def read(self, length):
<span class="w"> </span>        &quot;&quot;&quot;Read a specified amount of Bytes form the pack object.

<span class="gu">@@ -226,7 +497,18 @@ class SwiftPackReader:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          a bytestring
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        end = self.offset + length</span>
<span class="gi">+        if self.base_offset + end &gt; self.pack_length:</span>
<span class="gi">+            data = self.buff[self.offset :]</span>
<span class="gi">+            self.offset = end</span>
<span class="gi">+            return data</span>
<span class="gi">+        if end &gt; len(self.buff):</span>
<span class="gi">+            # Need to read more from swift</span>
<span class="gi">+            self._read(more=True)</span>
<span class="gi">+            return self.read(length)</span>
<span class="gi">+        data = self.buff[self.offset : end]</span>
<span class="gi">+        self.offset = end</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def seek(self, offset):
<span class="w"> </span>        &quot;&quot;&quot;Seek to a specified offset.
<span class="gu">@@ -234,14 +516,16 @@ class SwiftPackReader:</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          offset: the offset to seek to
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.base_offset = offset</span>
<span class="gi">+        self._read()</span>
<span class="gi">+        self.offset = 0</span>

<span class="w"> </span>    def read_checksum(self):
<span class="w"> </span>        &quot;&quot;&quot;Read the checksum from the pack.

<span class="w"> </span>        Returns: the checksum bytestring
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.scon.get_object(self.filename, range=&quot;-20&quot;)</span>


<span class="w"> </span>class SwiftPackData(PackData):
<span class="gu">@@ -251,7 +535,7 @@ class SwiftPackData(PackData):</span>
<span class="w"> </span>    using the Range header feature of Swift.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, scon, filename) -&gt;None:</span>
<span class="gi">+    def __init__(self, scon, filename) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a SwiftPackReader.

<span class="w"> </span>        Args:
<span class="gu">@@ -262,14 +546,31 @@ class SwiftPackData(PackData):</span>
<span class="w"> </span>        self._filename = filename
<span class="w"> </span>        self._header_size = 12
<span class="w"> </span>        headers = self.scon.get_object_stat(self._filename)
<span class="gd">-        self.pack_length = int(headers[&#39;content-length&#39;])</span>
<span class="gd">-        pack_reader = SwiftPackReader(self.scon, self._filename, self.</span>
<span class="gd">-            pack_length)</span>
<span class="gd">-        version, self._num_objects = read_pack_header(pack_reader.read)</span>
<span class="gd">-        self._offset_cache = LRUSizeCache(1024 * 1024 * self.scon.</span>
<span class="gd">-            cache_length, compute_size=_compute_object_size)</span>
<span class="gi">+        self.pack_length = int(headers[&quot;content-length&quot;])</span>
<span class="gi">+        pack_reader = SwiftPackReader(self.scon, self._filename, self.pack_length)</span>
<span class="gi">+        (version, self._num_objects) = read_pack_header(pack_reader.read)</span>
<span class="gi">+        self._offset_cache = LRUSizeCache(</span>
<span class="gi">+            1024 * 1024 * self.scon.cache_length,</span>
<span class="gi">+            compute_size=_compute_object_size,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.pack = None

<span class="gi">+    def get_object_at(self, offset):</span>
<span class="gi">+        if offset in self._offset_cache:</span>
<span class="gi">+            return self._offset_cache[offset]</span>
<span class="gi">+        assert offset &gt;= self._header_size</span>
<span class="gi">+        pack_reader = SwiftPackReader(self.scon, self._filename, self.pack_length)</span>
<span class="gi">+        pack_reader.seek(offset)</span>
<span class="gi">+        unpacked, _ = unpack_object(pack_reader.read)</span>
<span class="gi">+        return (unpacked.pack_type_num, unpacked._obj())</span>
<span class="gi">+</span>
<span class="gi">+    def get_stored_checksum(self):</span>
<span class="gi">+        pack_reader = SwiftPackReader(self.scon, self._filename, self.pack_length)</span>
<span class="gi">+        return pack_reader.read_checksum()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class SwiftPack(Pack):
<span class="w"> </span>    &quot;&quot;&quot;A Git pack object.
<span class="gu">@@ -279,22 +580,22 @@ class SwiftPack(Pack):</span>
<span class="w"> </span>    PackData.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args, **kwargs) -&gt;None:</span>
<span class="gd">-        self.scon = kwargs[&#39;scon&#39;]</span>
<span class="gd">-        del kwargs[&#39;scon&#39;]</span>
<span class="gi">+    def __init__(self, *args, **kwargs) -&gt; None:</span>
<span class="gi">+        self.scon = kwargs[&quot;scon&quot;]</span>
<span class="gi">+        del kwargs[&quot;scon&quot;]</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gd">-        self._pack_info_path = self._basename + &#39;.info&#39;</span>
<span class="gi">+        self._pack_info_path = self._basename + &quot;.info&quot;</span>
<span class="w"> </span>        self._pack_info = None
<span class="gd">-        self._pack_info_load = lambda : load_pack_info(self._pack_info_path,</span>
<span class="gd">-            self.scon)</span>
<span class="gd">-        self._idx_load = lambda : swift_load_pack_index(self.scon, self.</span>
<span class="gd">-            _idx_path)</span>
<span class="gd">-        self._data_load = lambda : SwiftPackData(self.scon, self._data_path)</span>
<span class="gi">+        self._pack_info_load = lambda: load_pack_info(self._pack_info_path, self.scon)</span>
<span class="gi">+        self._idx_load = lambda: swift_load_pack_index(self.scon, self._idx_path)</span>
<span class="gi">+        self._data_load = lambda: SwiftPackData(self.scon, self._data_path)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def pack_info(self):
<span class="w"> </span>        &quot;&quot;&quot;The pack data object being used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._pack_info is None:</span>
<span class="gi">+            self._pack_info = self._pack_info_load()</span>
<span class="gi">+        return self._pack_info</span>


<span class="w"> </span>class SwiftObjectStore(PackBasedObjectStore):
<span class="gu">@@ -304,7 +605,7 @@ class SwiftObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>    This object store only supports pack files and not loose objects.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, scon) -&gt;None:</span>
<span class="gi">+    def __init__(self, scon) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open a Swift object store.

<span class="w"> </span>        Args:
<span class="gu">@@ -316,9 +617,53 @@ class SwiftObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        self.pack_dir = posixpath.join(OBJECTDIR, PACKDIR)
<span class="w"> </span>        self._alternates = None

<span class="gi">+    def _update_pack_cache(self):</span>
<span class="gi">+        objects = self.scon.get_container_objects()</span>
<span class="gi">+        pack_files = [</span>
<span class="gi">+            o[&quot;name&quot;].replace(&quot;.pack&quot;, &quot;&quot;)</span>
<span class="gi">+            for o in objects</span>
<span class="gi">+            if o[&quot;name&quot;].endswith(&quot;.pack&quot;)</span>
<span class="gi">+        ]</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for basename in pack_files:</span>
<span class="gi">+            pack = SwiftPack(basename, scon=self.scon)</span>
<span class="gi">+            self._pack_cache[basename] = pack</span>
<span class="gi">+            ret.append(pack)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="w"> </span>    def _iter_loose_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Loose objects are not supported by this repository.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def pack_info_get(self, sha):</span>
<span class="gi">+        for pack in self.packs:</span>
<span class="gi">+            if sha in pack:</span>
<span class="gi">+                return pack.pack_info[sha]</span>
<span class="gi">+</span>
<span class="gi">+    def _collect_ancestors(self, heads, common=set()):</span>
<span class="gi">+        def _find_parents(commit):</span>
<span class="gi">+            for pack in self.packs:</span>
<span class="gi">+                if commit in pack:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        parents = pack.pack_info[commit][1]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        # Seems to have no parents</span>
<span class="gi">+                        return []</span>
<span class="gi">+                    return parents</span>
<span class="gi">+</span>
<span class="gi">+        bases = set()</span>
<span class="gi">+        commits = set()</span>
<span class="gi">+        queue = []</span>
<span class="gi">+        queue.extend(heads)</span>
<span class="gi">+        while queue:</span>
<span class="gi">+            e = queue.pop(0)</span>
<span class="gi">+            if e in common:</span>
<span class="gi">+                bases.add(e)</span>
<span class="gi">+            elif e not in commits:</span>
<span class="gi">+                commits.add(e)</span>
<span class="gi">+                parents = _find_parents(e)</span>
<span class="gi">+                queue.extend(parents)</span>
<span class="gi">+        return (commits, bases)</span>

<span class="w"> </span>    def add_pack(self):
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack to this object store.
<span class="gu">@@ -326,7 +671,47 @@ class SwiftObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        Returns: Fileobject to write to and a commit function to
<span class="w"> </span>            call when the pack is finished.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = BytesIO()</span>
<span class="gi">+</span>
<span class="gi">+        def commit():</span>
<span class="gi">+            f.seek(0)</span>
<span class="gi">+            pack = PackData(file=f, filename=&quot;&quot;)</span>
<span class="gi">+            entries = pack.sorted_entries()</span>
<span class="gi">+            if entries:</span>
<span class="gi">+                basename = posixpath.join(</span>
<span class="gi">+                    self.pack_dir,</span>
<span class="gi">+                    f&quot;pack-{iter_sha1(entry[0] for entry in entries)}&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                index = BytesIO()</span>
<span class="gi">+                write_pack_index_v2(index, entries, pack.get_stored_checksum())</span>
<span class="gi">+                self.scon.put_object(basename + &quot;.pack&quot;, f)</span>
<span class="gi">+                f.close()</span>
<span class="gi">+                self.scon.put_object(basename + &quot;.idx&quot;, index)</span>
<span class="gi">+                index.close()</span>
<span class="gi">+                final_pack = SwiftPack(basename, scon=self.scon)</span>
<span class="gi">+                final_pack.check_length_and_checksum()</span>
<span class="gi">+                self._add_cached_pack(basename, final_pack)</span>
<span class="gi">+                return final_pack</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        def abort():</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return f, commit, abort</span>
<span class="gi">+</span>
<span class="gi">+    def add_object(self, obj):</span>
<span class="gi">+        self.add_objects(</span>
<span class="gi">+            [</span>
<span class="gi">+                (obj, None),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _pack_cache_stale(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _get_loose_object(self, sha):</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def add_thin_pack(self, read_all, read_some):
<span class="w"> </span>        &quot;&quot;&quot;Read a thin pack.
<span class="gu">@@ -334,33 +719,140 @@ class SwiftObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        Read it from a stream and complete it in a temporary file.
<span class="w"> </span>        Then the pack and the corresponding index file are uploaded to Swift.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fd, path = tempfile.mkstemp(prefix=&quot;tmp_pack_&quot;)</span>
<span class="gi">+        f = os.fdopen(fd, &quot;w+b&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            indexer = PackIndexer(f, resolve_ext_ref=self.get_raw)</span>
<span class="gi">+            copier = PackStreamCopier(read_all, read_some, f, delta_iter=indexer)</span>
<span class="gi">+            copier.verify()</span>
<span class="gi">+            return self._complete_thin_pack(f, path, copier, indexer)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            f.close()</span>
<span class="gi">+            os.unlink(path)</span>
<span class="gi">+</span>
<span class="gi">+    def _complete_thin_pack(self, f, path, copier, indexer):</span>
<span class="gi">+        entries = list(indexer)</span>
<span class="gi">+</span>
<span class="gi">+        # Update the header with the new number of objects.</span>
<span class="gi">+        f.seek(0)</span>
<span class="gi">+        write_pack_header(f, len(entries) + len(indexer.ext_refs()))</span>
<span class="gi">+</span>
<span class="gi">+        # Must flush before reading (http://bugs.python.org/issue3207)</span>
<span class="gi">+        f.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Rescan the rest of the pack, computing the SHA with the new header.</span>
<span class="gi">+        new_sha = compute_file_sha(f, end_ofs=-20)</span>
<span class="gi">+</span>
<span class="gi">+        # Must reposition before writing (http://bugs.python.org/issue3207)</span>
<span class="gi">+        f.seek(0, os.SEEK_CUR)</span>
<span class="gi">+</span>
<span class="gi">+        # Complete the pack.</span>
<span class="gi">+        for ext_sha in indexer.ext_refs():</span>
<span class="gi">+            assert len(ext_sha) == 20</span>
<span class="gi">+            type_num, data = self.get_raw(ext_sha)</span>
<span class="gi">+            offset = f.tell()</span>
<span class="gi">+            crc32 = write_pack_object(f, type_num, data, sha=new_sha)</span>
<span class="gi">+            entries.append((ext_sha, offset, crc32))</span>
<span class="gi">+        pack_sha = new_sha.digest()</span>
<span class="gi">+        f.write(pack_sha)</span>
<span class="gi">+        f.flush()</span>
<span class="gi">+</span>
<span class="gi">+        # Move the pack in.</span>
<span class="gi">+        entries.sort()</span>
<span class="gi">+        pack_base_name = posixpath.join(</span>
<span class="gi">+            self.pack_dir,</span>
<span class="gi">+            &quot;pack-&quot; + os.fsdecode(iter_sha1(e[0] for e in entries)),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.scon.put_object(pack_base_name + &quot;.pack&quot;, f)</span>
<span class="gi">+</span>
<span class="gi">+        # Write the index.</span>
<span class="gi">+        filename = pack_base_name + &quot;.idx&quot;</span>
<span class="gi">+        index_file = BytesIO()</span>
<span class="gi">+        write_pack_index_v2(index_file, entries, pack_sha)</span>
<span class="gi">+        self.scon.put_object(filename, index_file)</span>
<span class="gi">+</span>
<span class="gi">+        # Write pack info.</span>
<span class="gi">+        f.seek(0)</span>
<span class="gi">+        pack_data = PackData(filename=&quot;&quot;, file=f)</span>
<span class="gi">+        index_file.seek(0)</span>
<span class="gi">+        pack_index = load_pack_index_file(&quot;&quot;, index_file)</span>
<span class="gi">+        serialized_pack_info = pack_info_create(pack_data, pack_index)</span>
<span class="gi">+        f.close()</span>
<span class="gi">+        index_file.close()</span>
<span class="gi">+        pack_info_file = BytesIO(serialized_pack_info)</span>
<span class="gi">+        filename = pack_base_name + &quot;.info&quot;</span>
<span class="gi">+        self.scon.put_object(filename, pack_info_file)</span>
<span class="gi">+        pack_info_file.close()</span>
<span class="gi">+</span>
<span class="gi">+        # Add the pack to the store and return it.</span>
<span class="gi">+        final_pack = SwiftPack(pack_base_name, scon=self.scon)</span>
<span class="gi">+        final_pack.check_length_and_checksum()</span>
<span class="gi">+        self._add_cached_pack(pack_base_name, final_pack)</span>
<span class="gi">+        return final_pack</span>


<span class="w"> </span>class SwiftInfoRefsContainer(InfoRefsContainer):
<span class="w"> </span>    &quot;&quot;&quot;Manage references in info/refs object.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, scon, store) -&gt;None:</span>
<span class="gi">+    def __init__(self, scon, store) -&gt; None:</span>
<span class="w"> </span>        self.scon = scon
<span class="gd">-        self.filename = &#39;info/refs&#39;</span>
<span class="gi">+        self.filename = &quot;info/refs&quot;</span>
<span class="w"> </span>        self.store = store
<span class="w"> </span>        f = self.scon.get_object(self.filename)
<span class="w"> </span>        if not f:
<span class="gd">-            f = BytesIO(b&#39;&#39;)</span>
<span class="gi">+            f = BytesIO(b&quot;&quot;)</span>
<span class="w"> </span>        super().__init__(f)

<span class="gi">+    def _load_check_ref(self, name, old_ref):</span>
<span class="gi">+        self._check_refname(name)</span>
<span class="gi">+        f = self.scon.get_object(self.filename)</span>
<span class="gi">+        if not f:</span>
<span class="gi">+            return {}</span>
<span class="gi">+        refs = read_info_refs(f)</span>
<span class="gi">+        if old_ref is not None:</span>
<span class="gi">+            if refs[name] != old_ref:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return refs</span>
<span class="gi">+</span>
<span class="gi">+    def _write_refs(self, refs):</span>
<span class="gi">+        f = BytesIO()</span>
<span class="gi">+        f.writelines(write_info_refs(refs, self.store))</span>
<span class="gi">+        self.scon.put_object(self.filename, f)</span>
<span class="gi">+</span>
<span class="w"> </span>    def set_if_equals(self, name, old_ref, new_ref):
<span class="w"> </span>        &quot;&quot;&quot;Set a refname to new_ref only if it currently equals old_ref.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name == &quot;HEAD&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        refs = self._load_check_ref(name, old_ref)</span>
<span class="gi">+        if not isinstance(refs, dict):</span>
<span class="gi">+            return False</span>
<span class="gi">+        refs[name] = new_ref</span>
<span class="gi">+        self._write_refs(refs)</span>
<span class="gi">+        self._refs[name] = new_ref</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def remove_if_equals(self, name, old_ref):
<span class="w"> </span>        &quot;&quot;&quot;Remove a refname only if it currently equals old_ref.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name == &quot;HEAD&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        refs = self._load_check_ref(name, old_ref)</span>
<span class="gi">+        if not isinstance(refs, dict):</span>
<span class="gi">+            return False</span>
<span class="gi">+        del refs[name]</span>
<span class="gi">+        self._write_refs(refs)</span>
<span class="gi">+        del self._refs[name]</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def allkeys(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._refs[&quot;HEAD&quot;] = self._refs[&quot;refs/heads/master&quot;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return self._refs.keys()</span>


<span class="w"> </span>class SwiftRepo(BaseRepo):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, root, conf) -&gt;None:</span>
<span class="gi">+    def __init__(self, root, conf) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init a Git bare Repository on top of a Swift container.

<span class="w"> </span>        References are managed in info/refs objects by
<span class="gu">@@ -371,15 +863,15 @@ class SwiftRepo(BaseRepo):</span>
<span class="w"> </span>          root: The container which contains the bare repo
<span class="w"> </span>          conf: A ConfigParser object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.root = root.lstrip(&#39;/&#39;)</span>
<span class="gi">+        self.root = root.lstrip(&quot;/&quot;)</span>
<span class="w"> </span>        self.conf = conf
<span class="w"> </span>        self.scon = SwiftConnector(self.root, self.conf)
<span class="w"> </span>        objects = self.scon.get_container_objects()
<span class="w"> </span>        if not objects:
<span class="gd">-            raise Exception(f&#39;There is not any GIT repo here : {self.root}&#39;)</span>
<span class="gd">-        objects = [o[&#39;name&#39;].split(&#39;/&#39;)[0] for o in objects]</span>
<span class="gi">+            raise Exception(f&quot;There is not any GIT repo here : {self.root}&quot;)</span>
<span class="gi">+        objects = [o[&quot;name&quot;].split(&quot;/&quot;)[0] for o in objects]</span>
<span class="w"> </span>        if OBJECTDIR not in objects:
<span class="gd">-            raise Exception(f&#39;This repository ({self.root}) is not bare.&#39;)</span>
<span class="gi">+            raise Exception(f&quot;This repository ({self.root}) is not bare.&quot;)</span>
<span class="w"> </span>        self.bare = True
<span class="w"> </span>        self._controldir = self.root
<span class="w"> </span>        object_store = SwiftObjectStore(self.scon)
<span class="gu">@@ -391,7 +883,7 @@ class SwiftRepo(BaseRepo):</span>

<span class="w"> </span>        Returns: True if permissions can be trusted, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def _put_named_file(self, filename, contents):
<span class="w"> </span>        &quot;&quot;&quot;Put an object in a Swift container.
<span class="gu">@@ -400,7 +892,9 @@ class SwiftRepo(BaseRepo):</span>
<span class="w"> </span>          filename: the path to the object to put on Swift
<span class="w"> </span>          contents: the content as bytestring
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with BytesIO() as f:</span>
<span class="gi">+            f.write(contents)</span>
<span class="gi">+            self.scon.put_object(filename, f)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def init_bare(cls, scon, conf):
<span class="gu">@@ -412,20 +906,118 @@ class SwiftRepo(BaseRepo):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          a `SwiftRepo` instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        scon.create_root()</span>
<span class="gi">+        for obj in [</span>
<span class="gi">+            posixpath.join(OBJECTDIR, PACKDIR),</span>
<span class="gi">+            posixpath.join(INFODIR, &quot;refs&quot;),</span>
<span class="gi">+        ]:</span>
<span class="gi">+            scon.put_object(obj, BytesIO(b&quot;&quot;))</span>
<span class="gi">+        ret = cls(scon.root, conf)</span>
<span class="gi">+        ret._init_files(True)</span>
<span class="gi">+        return ret</span>


<span class="w"> </span>class SwiftSystemBackend(Backend):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, logger, conf) -&gt;None:</span>
<span class="gi">+    def __init__(self, logger, conf) -&gt; None:</span>
<span class="w"> </span>        self.conf = conf
<span class="w"> </span>        self.logger = logger

<span class="gi">+    def open_repository(self, path):</span>
<span class="gi">+        self.logger.info(&quot;opening repository at %s&quot;, path)</span>
<span class="gi">+        return SwiftRepo(path, self.conf)</span>
<span class="gi">+</span>

<span class="w"> </span>def cmd_daemon(args):
<span class="w"> </span>    &quot;&quot;&quot;Entry point for starting a TCP git server.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    import optparse</span>
<span class="gi">+</span>
<span class="gi">+    parser = optparse.OptionParser()</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-l&quot;,</span>
<span class="gi">+        &quot;--listen_address&quot;,</span>
<span class="gi">+        dest=&quot;listen_address&quot;,</span>
<span class="gi">+        default=&quot;127.0.0.1&quot;,</span>
<span class="gi">+        help=&quot;Binding IP address.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-p&quot;,</span>
<span class="gi">+        &quot;--port&quot;,</span>
<span class="gi">+        dest=&quot;port&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=TCP_GIT_PORT,</span>
<span class="gi">+        help=&quot;Binding TCP port.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-c&quot;,</span>
<span class="gi">+        &quot;--swift_config&quot;,</span>
<span class="gi">+        dest=&quot;swift_config&quot;,</span>
<span class="gi">+        default=&quot;&quot;,</span>
<span class="gi">+        help=&quot;Path to the configuration file for Swift backend.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import gevent</span>
<span class="gi">+        import geventhttpclient  # noqa: F401</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        print(</span>
<span class="gi">+            &quot;gevent and geventhttpclient libraries are mandatory &quot;</span>
<span class="gi">+            &quot; for use the Swift backend.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+    import gevent.monkey</span>
<span class="gi">+</span>
<span class="gi">+    gevent.monkey.patch_socket()</span>
<span class="gi">+    from dulwich import log_utils</span>
<span class="gi">+</span>
<span class="gi">+    logger = log_utils.getLogger(__name__)</span>
<span class="gi">+    conf = load_conf(options.swift_config)</span>
<span class="gi">+    backend = SwiftSystemBackend(logger, conf)</span>
<span class="gi">+</span>
<span class="gi">+    log_utils.default_logging_config()</span>
<span class="gi">+    server = TCPGitServer(backend, options.listen_address, port=options.port)</span>
<span class="gi">+    server.serve_forever()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cmd_init(args):</span>
<span class="gi">+    import optparse</span>
<span class="gi">+</span>
<span class="gi">+    parser = optparse.OptionParser()</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-c&quot;,</span>
<span class="gi">+        &quot;--swift_config&quot;,</span>
<span class="gi">+        dest=&quot;swift_config&quot;,</span>
<span class="gi">+        default=&quot;&quot;,</span>
<span class="gi">+        help=&quot;Path to the configuration file for Swift backend.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options, args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+    conf = load_conf(options.swift_config)</span>
<span class="gi">+    if args == []:</span>
<span class="gi">+        parser.error(&quot;missing repository name&quot;)</span>
<span class="gi">+    repo = args[0]</span>
<span class="gi">+    scon = SwiftConnector(repo, conf)</span>
<span class="gi">+    SwiftRepo.init_bare(scon, conf)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main(argv=sys.argv):</span>
<span class="gi">+    commands = {</span>
<span class="gi">+        &quot;init&quot;: cmd_init,</span>
<span class="gi">+        &quot;daemon&quot;: cmd_daemon,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if len(sys.argv) &lt; 2:</span>
<span class="gi">+        print(</span>
<span class="gi">+            &quot;Usage: {} &lt;{}&gt; [OPTIONS...]&quot;.format(sys.argv[0], &quot;|&quot;.join(commands.keys()))</span>
<span class="gi">+        )</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    cmd = sys.argv[1]</span>
<span class="gi">+    if cmd not in commands:</span>
<span class="gi">+        print(f&quot;No such subcommand: {cmd}&quot;)</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+    commands[cmd](sys.argv[2:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/dulwich/credentials.py b/dulwich/credentials.py</span>
<span class="gh">index e77322bf..05de0452 100644</span>
<span class="gd">--- a/dulwich/credentials.py</span>
<span class="gi">+++ b/dulwich/credentials.py</span>
<span class="gu">@@ -1,20 +1,90 @@</span>
<span class="gi">+# credentials.py -- support for git credential helpers</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (C) 2022 Daniele Trifir &lt;daniele@iterative.ai&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Support for git credential helpers.

<span class="w"> </span>https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Iterator, Optional
<span class="w"> </span>from urllib.parse import ParseResult, urlparse
<span class="gi">+</span>
<span class="w"> </span>from .config import ConfigDict, SectionLike


<span class="gd">-def match_partial_url(valid_url: ParseResult, partial_url: str) -&gt;bool:</span>
<span class="gi">+def match_urls(url: ParseResult, url_prefix: ParseResult) -&gt; bool:</span>
<span class="gi">+    base_match = (</span>
<span class="gi">+        url.scheme == url_prefix.scheme</span>
<span class="gi">+        and url.hostname == url_prefix.hostname</span>
<span class="gi">+        and url.port == url_prefix.port</span>
<span class="gi">+    )</span>
<span class="gi">+    user_match = url.username == url_prefix.username if url_prefix.username else True</span>
<span class="gi">+    path_match = url.path.rstrip(&quot;/&quot;).startswith(url_prefix.path.rstrip())</span>
<span class="gi">+    return base_match and user_match and path_match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def match_partial_url(valid_url: ParseResult, partial_url: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Matches a parsed url with a partial url (no scheme/netloc).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;://&quot; not in partial_url:</span>
<span class="gi">+        parsed = urlparse(&quot;scheme://&quot; + partial_url)</span>
<span class="gi">+    else:</span>
<span class="gi">+        parsed = urlparse(partial_url)</span>
<span class="gi">+        if valid_url.scheme != parsed.scheme:</span>
<span class="gi">+            return False</span>

<span class="gi">+    if any(</span>
<span class="gi">+        (</span>
<span class="gi">+            (parsed.hostname and valid_url.hostname != parsed.hostname),</span>
<span class="gi">+            (parsed.username and valid_url.username != parsed.username),</span>
<span class="gi">+            (parsed.port and valid_url.port != parsed.port),</span>
<span class="gi">+            (parsed.path and parsed.path.rstrip(&quot;/&quot;) != valid_url.path.rstrip(&quot;/&quot;)),</span>
<span class="gi">+        ),</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>

<span class="gd">-def urlmatch_credential_sections(config: ConfigDict, url: Optional[str]</span>
<span class="gd">-    ) -&gt;Iterator[SectionLike]:</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def urlmatch_credential_sections(</span>
<span class="gi">+    config: ConfigDict, url: Optional[str]</span>
<span class="gi">+) -&gt; Iterator[SectionLike]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns credential sections from the config which match the given URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    encoding = config.encoding or sys.getdefaultencoding()</span>
<span class="gi">+    parsed_url = urlparse(url or &quot;&quot;)</span>
<span class="gi">+    for config_section in config.sections():</span>
<span class="gi">+        if config_section[0] != b&quot;credential&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if len(config_section) &lt; 2:</span>
<span class="gi">+            yield config_section</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        config_url = config_section[1].decode(encoding)</span>
<span class="gi">+        parsed_config_url = urlparse(config_url)</span>
<span class="gi">+        if parsed_config_url.scheme and parsed_config_url.netloc:</span>
<span class="gi">+            is_match = match_urls(parsed_url, parsed_config_url)</span>
<span class="gi">+        else:</span>
<span class="gi">+            is_match = match_partial_url(parsed_url, config_url)</span>
<span class="gi">+</span>
<span class="gi">+        if is_match:</span>
<span class="gi">+            yield config_section</span>
<span class="gh">diff --git a/dulwich/diff_tree.py b/dulwich/diff_tree.py</span>
<span class="gh">index 05be69e2..eeec9d48 100644</span>
<span class="gd">--- a/dulwich/diff_tree.py</span>
<span class="gi">+++ b/dulwich/diff_tree.py</span>
<span class="gu">@@ -1,28 +1,72 @@</span>
<span class="gi">+# diff_tree.py -- Utilities for diffing files and trees.</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for diffing files and trees.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import stat
<span class="w"> </span>from collections import defaultdict, namedtuple
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from typing import Dict, List, Optional
<span class="gi">+</span>
<span class="w"> </span>from .object_store import BaseObjectStore
<span class="w"> </span>from .objects import S_ISGITLINK, ObjectID, ShaFile, Tree, TreeEntry
<span class="gd">-CHANGE_ADD = &#39;add&#39;</span>
<span class="gd">-CHANGE_MODIFY = &#39;modify&#39;</span>
<span class="gd">-CHANGE_DELETE = &#39;delete&#39;</span>
<span class="gd">-CHANGE_RENAME = &#39;rename&#39;</span>
<span class="gd">-CHANGE_COPY = &#39;copy&#39;</span>
<span class="gd">-CHANGE_UNCHANGED = &#39;unchanged&#39;</span>
<span class="gd">-RENAME_CHANGE_TYPES = CHANGE_RENAME, CHANGE_COPY</span>
<span class="gi">+</span>
<span class="gi">+# TreeChange type constants.</span>
<span class="gi">+CHANGE_ADD = &quot;add&quot;</span>
<span class="gi">+CHANGE_MODIFY = &quot;modify&quot;</span>
<span class="gi">+CHANGE_DELETE = &quot;delete&quot;</span>
<span class="gi">+CHANGE_RENAME = &quot;rename&quot;</span>
<span class="gi">+CHANGE_COPY = &quot;copy&quot;</span>
<span class="gi">+CHANGE_UNCHANGED = &quot;unchanged&quot;</span>
<span class="gi">+</span>
<span class="gi">+RENAME_CHANGE_TYPES = (CHANGE_RENAME, CHANGE_COPY)</span>
<span class="gi">+</span>
<span class="w"> </span>_NULL_ENTRY = TreeEntry(None, None, None)
<span class="gi">+</span>
<span class="w"> </span>_MAX_SCORE = 100
<span class="w"> </span>RENAME_THRESHOLD = 60
<span class="w"> </span>MAX_FILES = 200
<span class="w"> </span>REWRITE_THRESHOLD = None


<span class="gd">-class TreeChange(namedtuple(&#39;TreeChange&#39;, [&#39;type&#39;, &#39;old&#39;, &#39;new&#39;])):</span>
<span class="gi">+class TreeChange(namedtuple(&quot;TreeChange&quot;, [&quot;type&quot;, &quot;old&quot;, &quot;new&quot;])):</span>
<span class="w"> </span>    &quot;&quot;&quot;Named tuple a single change between two trees.&quot;&quot;&quot;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def add(cls, new):</span>
<span class="gi">+        return cls(CHANGE_ADD, _NULL_ENTRY, new)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def delete(cls, old):</span>
<span class="gi">+        return cls(CHANGE_DELETE, old, _NULL_ENTRY)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tree_entries(path: str, tree: Tree) -&gt; List[TreeEntry]:</span>
<span class="gi">+    result: List[TreeEntry] = []</span>
<span class="gi">+    if not tree:</span>
<span class="gi">+        return result</span>
<span class="gi">+    for entry in tree.iteritems(name_order=True):</span>
<span class="gi">+        result.append(entry.in_path(path))</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>

<span class="w"> </span>def _merge_entries(path, tree1, tree2):
<span class="w"> </span>    &quot;&quot;&quot;Merge the entries of two trees.
<span class="gu">@@ -38,7 +82,38 @@ def _merge_entries(path, tree1, tree2):</span>
<span class="w"> </span>        entry will have all attributes set to None. If neither entry&#39;s path is
<span class="w"> </span>        None, they are guaranteed to match.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    entries1 = _tree_entries(path, tree1)</span>
<span class="gi">+    entries2 = _tree_entries(path, tree2)</span>
<span class="gi">+    i1 = i2 = 0</span>
<span class="gi">+    len1 = len(entries1)</span>
<span class="gi">+    len2 = len(entries2)</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    while i1 &lt; len1 and i2 &lt; len2:</span>
<span class="gi">+        entry1 = entries1[i1]</span>
<span class="gi">+        entry2 = entries2[i2]</span>
<span class="gi">+        if entry1.path &lt; entry2.path:</span>
<span class="gi">+            result.append((entry1, _NULL_ENTRY))</span>
<span class="gi">+            i1 += 1</span>
<span class="gi">+        elif entry1.path &gt; entry2.path:</span>
<span class="gi">+            result.append((_NULL_ENTRY, entry2))</span>
<span class="gi">+            i2 += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.append((entry1, entry2))</span>
<span class="gi">+            i1 += 1</span>
<span class="gi">+            i2 += 1</span>
<span class="gi">+    for i in range(i1, len1):</span>
<span class="gi">+        result.append((entries1[i], _NULL_ENTRY))</span>
<span class="gi">+    for i in range(i2, len2):</span>
<span class="gi">+        result.append((_NULL_ENTRY, entries2[i]))</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_tree(entry):</span>
<span class="gi">+    mode = entry.mode</span>
<span class="gi">+    if mode is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return stat.S_ISDIR(mode)</span>


<span class="w"> </span>def walk_trees(store, tree1_id, tree2_id, prune_identical=False):
<span class="gu">@@ -59,11 +134,40 @@ def walk_trees(store, tree1_id, tree2_id, prune_identical=False):</span>
<span class="w"> </span>        to None. If neither entry&#39;s path is None, they are guaranteed to
<span class="w"> </span>        match.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def tree_changes(store, tree1_id, tree2_id, want_unchanged=False,</span>
<span class="gd">-    rename_detector=None, include_trees=False, change_type_same=False):</span>
<span class="gi">+    # This could be fairly easily generalized to &gt;2 trees if we find a use</span>
<span class="gi">+    # case.</span>
<span class="gi">+    mode1 = tree1_id and stat.S_IFDIR or None</span>
<span class="gi">+    mode2 = tree2_id and stat.S_IFDIR or None</span>
<span class="gi">+    todo = [(TreeEntry(b&quot;&quot;, mode1, tree1_id), TreeEntry(b&quot;&quot;, mode2, tree2_id))]</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        entry1, entry2 = todo.pop()</span>
<span class="gi">+        is_tree1 = _is_tree(entry1)</span>
<span class="gi">+        is_tree2 = _is_tree(entry2)</span>
<span class="gi">+        if prune_identical and is_tree1 and is_tree2 and entry1 == entry2:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        tree1 = is_tree1 and store[entry1.sha] or None</span>
<span class="gi">+        tree2 = is_tree2 and store[entry2.sha] or None</span>
<span class="gi">+        path = entry1.path or entry2.path</span>
<span class="gi">+        todo.extend(reversed(_merge_entries(path, tree1, tree2)))</span>
<span class="gi">+        yield entry1, entry2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _skip_tree(entry, include_trees):</span>
<span class="gi">+    if entry.mode is None or (not include_trees and stat.S_ISDIR(entry.mode)):</span>
<span class="gi">+        return _NULL_ENTRY</span>
<span class="gi">+    return entry</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tree_changes(</span>
<span class="gi">+    store,</span>
<span class="gi">+    tree1_id,</span>
<span class="gi">+    tree2_id,</span>
<span class="gi">+    want_unchanged=False,</span>
<span class="gi">+    rename_detector=None,</span>
<span class="gi">+    include_trees=False,</span>
<span class="gi">+    change_type_same=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the differences between the contents of two trees.

<span class="w"> </span>    Args:
<span class="gu">@@ -81,11 +185,66 @@ def tree_changes(store, tree1_id, tree2_id, want_unchanged=False,</span>
<span class="w"> </span>      Iterator over TreeChange instances for each change between the
<span class="w"> </span>        source and target tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def tree_changes_for_merge(store: BaseObjectStore, parent_tree_ids: List[</span>
<span class="gd">-    ObjectID], tree_id: ObjectID, rename_detector=None):</span>
<span class="gi">+    if rename_detector is not None and tree1_id is not None and tree2_id is not None:</span>
<span class="gi">+        yield from rename_detector.changes_with_renames(</span>
<span class="gi">+            tree1_id,</span>
<span class="gi">+            tree2_id,</span>
<span class="gi">+            want_unchanged=want_unchanged,</span>
<span class="gi">+            include_trees=include_trees,</span>
<span class="gi">+        )</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    entries = walk_trees(</span>
<span class="gi">+        store, tree1_id, tree2_id, prune_identical=(not want_unchanged)</span>
<span class="gi">+    )</span>
<span class="gi">+    for entry1, entry2 in entries:</span>
<span class="gi">+        if entry1 == entry2 and not want_unchanged:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Treat entries for trees as missing.</span>
<span class="gi">+        entry1 = _skip_tree(entry1, include_trees)</span>
<span class="gi">+        entry2 = _skip_tree(entry2, include_trees)</span>
<span class="gi">+</span>
<span class="gi">+        if entry1 != _NULL_ENTRY and entry2 != _NULL_ENTRY:</span>
<span class="gi">+            if (</span>
<span class="gi">+                stat.S_IFMT(entry1.mode) != stat.S_IFMT(entry2.mode)</span>
<span class="gi">+                and not change_type_same</span>
<span class="gi">+            ):</span>
<span class="gi">+                # File type changed: report as delete/add.</span>
<span class="gi">+                yield TreeChange.delete(entry1)</span>
<span class="gi">+                entry1 = _NULL_ENTRY</span>
<span class="gi">+                change_type = CHANGE_ADD</span>
<span class="gi">+            elif entry1 == entry2:</span>
<span class="gi">+                change_type = CHANGE_UNCHANGED</span>
<span class="gi">+            else:</span>
<span class="gi">+                change_type = CHANGE_MODIFY</span>
<span class="gi">+        elif entry1 != _NULL_ENTRY:</span>
<span class="gi">+            change_type = CHANGE_DELETE</span>
<span class="gi">+        elif entry2 != _NULL_ENTRY:</span>
<span class="gi">+            change_type = CHANGE_ADD</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Both were None because at least one was a tree.</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield TreeChange(change_type, entry1, entry2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _all_eq(seq, key, value):</span>
<span class="gi">+    for e in seq:</span>
<span class="gi">+        if key(e) != value:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _all_same(seq, key):</span>
<span class="gi">+    return _all_eq(seq[1:], key, key(seq[0]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tree_changes_for_merge(</span>
<span class="gi">+    store: BaseObjectStore,</span>
<span class="gi">+    parent_tree_ids: List[ObjectID],</span>
<span class="gi">+    tree_id: ObjectID,</span>
<span class="gi">+    rename_detector=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the tree changes for a merge tree relative to all its parents.

<span class="w"> </span>    Args:
<span class="gu">@@ -106,13 +265,50 @@ def tree_changes_for_merge(store: BaseObjectStore, parent_tree_ids: List[</span>
<span class="w"> </span>      in the merge tree is not found in any of the parents, or in the case of
<span class="w"> </span>      deletes, if not all of the old SHAs match.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    all_parent_changes = [</span>
<span class="gi">+        tree_changes(store, t, tree_id, rename_detector=rename_detector)</span>
<span class="gi">+        for t in parent_tree_ids</span>
<span class="gi">+    ]</span>
<span class="gi">+    num_parents = len(parent_tree_ids)</span>
<span class="gi">+    changes_by_path: Dict[str, List[Optional[TreeChange]]] = defaultdict(</span>
<span class="gi">+        lambda: [None] * num_parents</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Organize by path.</span>
<span class="gi">+    for i, parent_changes in enumerate(all_parent_changes):</span>
<span class="gi">+        for change in parent_changes:</span>
<span class="gi">+            if change.type == CHANGE_DELETE:</span>
<span class="gi">+                path = change.old.path</span>
<span class="gi">+            else:</span>
<span class="gi">+                path = change.new.path</span>
<span class="gi">+            changes_by_path[path][i] = change</span>
<span class="gi">+</span>
<span class="gi">+    def old_sha(c):</span>
<span class="gi">+        return c.old.sha</span>
<span class="gi">+</span>
<span class="gi">+    def change_type(c):</span>
<span class="gi">+        return c.type</span>
<span class="gi">+</span>
<span class="gi">+    # Yield only conflicting changes.</span>
<span class="gi">+    for _, changes in sorted(changes_by_path.items()):</span>
<span class="gi">+        assert len(changes) == num_parents</span>
<span class="gi">+        have = [c for c in changes if c is not None]</span>
<span class="gi">+        if _all_eq(have, change_type, CHANGE_DELETE):</span>
<span class="gi">+            if not _all_same(have, old_sha):</span>
<span class="gi">+                yield changes</span>
<span class="gi">+        elif not _all_same(have, change_type):</span>
<span class="gi">+            yield changes</span>
<span class="gi">+        elif None not in changes:</span>
<span class="gi">+            # If no change was found relative to one parent, that means the SHA</span>
<span class="gi">+            # must have matched the SHA in that parent, so it is not a</span>
<span class="gi">+            # conflict.</span>
<span class="gi">+            yield changes</span>


<span class="w"> </span>_BLOCK_SIZE = 64


<span class="gd">-def _count_blocks(obj: ShaFile) -&gt;Dict[int, int]:</span>
<span class="gi">+def _count_blocks(obj: ShaFile) -&gt; Dict[int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Count the blocks in an object.

<span class="w"> </span>    Splits the data into blocks either on lines or &lt;=64-byte chunks of lines.
<span class="gu">@@ -123,7 +319,30 @@ def _count_blocks(obj: ShaFile) -&gt;Dict[int, int]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      A dict of block hashcode -&gt; total bytes occurring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    block_counts: Dict[int, int] = defaultdict(int)</span>
<span class="gi">+    block = BytesIO()</span>
<span class="gi">+    n = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Cache attrs as locals to avoid expensive lookups in the inner loop.</span>
<span class="gi">+    block_write = block.write</span>
<span class="gi">+    block_seek = block.seek</span>
<span class="gi">+    block_truncate = block.truncate</span>
<span class="gi">+    block_getvalue = block.getvalue</span>
<span class="gi">+</span>
<span class="gi">+    for c in chain.from_iterable(obj.as_raw_chunks()):</span>
<span class="gi">+        cb = c.to_bytes(1, &quot;big&quot;)</span>
<span class="gi">+        block_write(cb)</span>
<span class="gi">+        n += 1</span>
<span class="gi">+        if cb == b&quot;\n&quot; or n == _BLOCK_SIZE:</span>
<span class="gi">+            value = block_getvalue()</span>
<span class="gi">+            block_counts[hash(value)] += len(value)</span>
<span class="gi">+            block_seek(0)</span>
<span class="gi">+            block_truncate()</span>
<span class="gi">+            n = 0</span>
<span class="gi">+    if n &gt; 0:</span>
<span class="gi">+        last_block = block_getvalue()</span>
<span class="gi">+        block_counts[hash(last_block)] += len(last_block)</span>
<span class="gi">+    return block_counts</span>


<span class="w"> </span>def _common_bytes(blocks1, blocks2):
<span class="gu">@@ -137,7 +356,15 @@ def _common_bytes(blocks1, blocks2):</span>
<span class="w"> </span>      The number of bytes in common between blocks1 and blocks2. This is
<span class="w"> </span>      only approximate due to possible hash collisions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Iterate over the smaller of the two dicts, since this is symmetrical.</span>
<span class="gi">+    if len(blocks1) &gt; len(blocks2):</span>
<span class="gi">+        blocks1, blocks2 = blocks2, blocks1</span>
<span class="gi">+    score = 0</span>
<span class="gi">+    for block, count1 in blocks1.items():</span>
<span class="gi">+        count2 = blocks2.get(block)</span>
<span class="gi">+        if count2:</span>
<span class="gi">+            score += min(count1, count2)</span>
<span class="gi">+    return score</span>


<span class="w"> </span>def _similarity_score(obj1, obj2, block_cache=None):
<span class="gu">@@ -154,15 +381,42 @@ def _similarity_score(obj1, obj2, block_cache=None):</span>
<span class="w"> </span>        number of bytes in common between the two objects divided by the
<span class="w"> </span>        maximum size, scaled to the range 0-100.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if block_cache is None:</span>
<span class="gi">+        block_cache = {}</span>
<span class="gi">+    if obj1.id not in block_cache:</span>
<span class="gi">+        block_cache[obj1.id] = _count_blocks(obj1)</span>
<span class="gi">+    if obj2.id not in block_cache:</span>
<span class="gi">+        block_cache[obj2.id] = _count_blocks(obj2)</span>
<span class="gi">+</span>
<span class="gi">+    common_bytes = _common_bytes(block_cache[obj1.id], block_cache[obj2.id])</span>
<span class="gi">+    max_size = max(obj1.raw_length(), obj2.raw_length())</span>
<span class="gi">+    if not max_size:</span>
<span class="gi">+        return _MAX_SCORE</span>
<span class="gi">+    return int(float(common_bytes) * _MAX_SCORE / max_size)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tree_change_key(entry):</span>
<span class="gi">+    # Sort by old path then new path. If only one exists, use it for both keys.</span>
<span class="gi">+    path1 = entry.old.path</span>
<span class="gi">+    path2 = entry.new.path</span>
<span class="gi">+    if path1 is None:</span>
<span class="gi">+        path1 = path2</span>
<span class="gi">+    if path2 is None:</span>
<span class="gi">+        path2 = path1</span>
<span class="gi">+    return (path1, path2)</span>


<span class="w"> </span>class RenameDetector:
<span class="w"> </span>    &quot;&quot;&quot;Object for handling rename detection between two trees.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, store, rename_threshold=RENAME_THRESHOLD, max_files=</span>
<span class="gd">-        MAX_FILES, rewrite_threshold=REWRITE_THRESHOLD, find_copies_harder=</span>
<span class="gd">-        False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        store,</span>
<span class="gi">+        rename_threshold=RENAME_THRESHOLD,</span>
<span class="gi">+        max_files=MAX_FILES,</span>
<span class="gi">+        rewrite_threshold=REWRITE_THRESHOLD,</span>
<span class="gi">+        find_copies_harder=False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the rename detector.

<span class="w"> </span>        Args:
<span class="gu">@@ -187,16 +441,214 @@ class RenameDetector:</span>
<span class="w"> </span>        self._find_copies_harder = find_copies_harder
<span class="w"> </span>        self._want_unchanged = False

<span class="gd">-    def changes_with_renames(self, tree1_id, tree2_id, want_unchanged=False,</span>
<span class="gd">-        include_trees=False):</span>
<span class="gi">+    def _reset(self):</span>
<span class="gi">+        self._adds = []</span>
<span class="gi">+        self._deletes = []</span>
<span class="gi">+        self._changes = []</span>
<span class="gi">+</span>
<span class="gi">+    def _should_split(self, change):</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._rewrite_threshold is None</span>
<span class="gi">+            or change.type != CHANGE_MODIFY</span>
<span class="gi">+            or change.old.sha == change.new.sha</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        old_obj = self._store[change.old.sha]</span>
<span class="gi">+        new_obj = self._store[change.new.sha]</span>
<span class="gi">+        return _similarity_score(old_obj, new_obj) &lt; self._rewrite_threshold</span>
<span class="gi">+</span>
<span class="gi">+    def _add_change(self, change):</span>
<span class="gi">+        if change.type == CHANGE_ADD:</span>
<span class="gi">+            self._adds.append(change)</span>
<span class="gi">+        elif change.type == CHANGE_DELETE:</span>
<span class="gi">+            self._deletes.append(change)</span>
<span class="gi">+        elif self._should_split(change):</span>
<span class="gi">+            self._deletes.append(TreeChange.delete(change.old))</span>
<span class="gi">+            self._adds.append(TreeChange.add(change.new))</span>
<span class="gi">+        elif (</span>
<span class="gi">+            self._find_copies_harder and change.type == CHANGE_UNCHANGED</span>
<span class="gi">+        ) or change.type == CHANGE_MODIFY:</span>
<span class="gi">+            # Treat all modifies as potential deletes for rename detection,</span>
<span class="gi">+            # but don&#39;t split them (to avoid spurious renames). Setting</span>
<span class="gi">+            # find_copies_harder means we treat unchanged the same as</span>
<span class="gi">+            # modified.</span>
<span class="gi">+            self._deletes.append(change)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._changes.append(change)</span>
<span class="gi">+</span>
<span class="gi">+    def _collect_changes(self, tree1_id, tree2_id):</span>
<span class="gi">+        want_unchanged = self._find_copies_harder or self._want_unchanged</span>
<span class="gi">+        for change in tree_changes(</span>
<span class="gi">+            self._store,</span>
<span class="gi">+            tree1_id,</span>
<span class="gi">+            tree2_id,</span>
<span class="gi">+            want_unchanged=want_unchanged,</span>
<span class="gi">+            include_trees=self._include_trees,</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._add_change(change)</span>
<span class="gi">+</span>
<span class="gi">+    def _prune(self, add_paths, delete_paths):</span>
<span class="gi">+        self._adds = [a for a in self._adds if a.new.path not in add_paths]</span>
<span class="gi">+        self._deletes = [d for d in self._deletes if d.old.path not in delete_paths]</span>
<span class="gi">+</span>
<span class="gi">+    def _find_exact_renames(self):</span>
<span class="gi">+        add_map = defaultdict(list)</span>
<span class="gi">+        for add in self._adds:</span>
<span class="gi">+            add_map[add.new.sha].append(add.new)</span>
<span class="gi">+        delete_map = defaultdict(list)</span>
<span class="gi">+        for delete in self._deletes:</span>
<span class="gi">+            # Keep track of whether the delete was actually marked as a delete.</span>
<span class="gi">+            # If not, it needs to be marked as a copy.</span>
<span class="gi">+            is_delete = delete.type == CHANGE_DELETE</span>
<span class="gi">+            delete_map[delete.old.sha].append((delete.old, is_delete))</span>
<span class="gi">+</span>
<span class="gi">+        add_paths = set()</span>
<span class="gi">+        delete_paths = set()</span>
<span class="gi">+        for sha, sha_deletes in delete_map.items():</span>
<span class="gi">+            sha_adds = add_map[sha]</span>
<span class="gi">+            for (old, is_delete), new in zip(sha_deletes, sha_adds):</span>
<span class="gi">+                if stat.S_IFMT(old.mode) != stat.S_IFMT(new.mode):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if is_delete:</span>
<span class="gi">+                    delete_paths.add(old.path)</span>
<span class="gi">+                add_paths.add(new.path)</span>
<span class="gi">+                new_type = is_delete and CHANGE_RENAME or CHANGE_COPY</span>
<span class="gi">+                self._changes.append(TreeChange(new_type, old, new))</span>
<span class="gi">+</span>
<span class="gi">+            num_extra_adds = len(sha_adds) - len(sha_deletes)</span>
<span class="gi">+            # TODO(dborowitz): Less arbitrary way of dealing with extra copies.</span>
<span class="gi">+            old = sha_deletes[0][0]</span>
<span class="gi">+            if num_extra_adds &gt; 0:</span>
<span class="gi">+                for new in sha_adds[-num_extra_adds:]:</span>
<span class="gi">+                    add_paths.add(new.path)</span>
<span class="gi">+                    self._changes.append(TreeChange(CHANGE_COPY, old, new))</span>
<span class="gi">+        self._prune(add_paths, delete_paths)</span>
<span class="gi">+</span>
<span class="gi">+    def _should_find_content_renames(self):</span>
<span class="gi">+        return len(self._adds) * len(self._deletes) &lt;= self._max_files**2</span>
<span class="gi">+</span>
<span class="gi">+    def _rename_type(self, check_paths, delete, add):</span>
<span class="gi">+        if check_paths and delete.old.path == add.new.path:</span>
<span class="gi">+            # If the paths match, this must be a split modify, so make sure it</span>
<span class="gi">+            # comes out as a modify.</span>
<span class="gi">+            return CHANGE_MODIFY</span>
<span class="gi">+        elif delete.type != CHANGE_DELETE:</span>
<span class="gi">+            # If it&#39;s in deletes but not marked as a delete, it must have been</span>
<span class="gi">+            # added due to find_copies_harder, and needs to be marked as a</span>
<span class="gi">+            # copy.</span>
<span class="gi">+            return CHANGE_COPY</span>
<span class="gi">+        return CHANGE_RENAME</span>
<span class="gi">+</span>
<span class="gi">+    def _find_content_rename_candidates(self):</span>
<span class="gi">+        candidates = self._candidates = []</span>
<span class="gi">+        # TODO: Optimizations:</span>
<span class="gi">+        #  - Compare object sizes before counting blocks.</span>
<span class="gi">+        #  - Skip if delete&#39;s S_IFMT differs from all adds.</span>
<span class="gi">+        #  - Skip if adds or deletes is empty.</span>
<span class="gi">+        # Match C git&#39;s behavior of not attempting to find content renames if</span>
<span class="gi">+        # the matrix size exceeds the threshold.</span>
<span class="gi">+        if not self._should_find_content_renames():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        block_cache = {}</span>
<span class="gi">+        check_paths = self._rename_threshold is not None</span>
<span class="gi">+        for delete in self._deletes:</span>
<span class="gi">+            if S_ISGITLINK(delete.old.mode):</span>
<span class="gi">+                continue  # Git links don&#39;t exist in this repo.</span>
<span class="gi">+            old_sha = delete.old.sha</span>
<span class="gi">+            old_obj = self._store[old_sha]</span>
<span class="gi">+            block_cache[old_sha] = _count_blocks(old_obj)</span>
<span class="gi">+            for add in self._adds:</span>
<span class="gi">+                if stat.S_IFMT(delete.old.mode) != stat.S_IFMT(add.new.mode):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                new_obj = self._store[add.new.sha]</span>
<span class="gi">+                score = _similarity_score(old_obj, new_obj, block_cache=block_cache)</span>
<span class="gi">+                if score &gt; self._rename_threshold:</span>
<span class="gi">+                    new_type = self._rename_type(check_paths, delete, add)</span>
<span class="gi">+                    rename = TreeChange(new_type, delete.old, add.new)</span>
<span class="gi">+                    candidates.append((-score, rename))</span>
<span class="gi">+</span>
<span class="gi">+    def _choose_content_renames(self):</span>
<span class="gi">+        # Sort scores from highest to lowest, but keep names in ascending</span>
<span class="gi">+        # order.</span>
<span class="gi">+        self._candidates.sort()</span>
<span class="gi">+</span>
<span class="gi">+        delete_paths = set()</span>
<span class="gi">+        add_paths = set()</span>
<span class="gi">+        for _, change in self._candidates:</span>
<span class="gi">+            new_path = change.new.path</span>
<span class="gi">+            if new_path in add_paths:</span>
<span class="gi">+                continue</span>
<span class="gi">+            old_path = change.old.path</span>
<span class="gi">+            orig_type = change.type</span>
<span class="gi">+            if old_path in delete_paths:</span>
<span class="gi">+                change = TreeChange(CHANGE_COPY, change.old, change.new)</span>
<span class="gi">+</span>
<span class="gi">+            # If the candidate was originally a copy, that means it came from a</span>
<span class="gi">+            # modified or unchanged path, so we don&#39;t want to prune it.</span>
<span class="gi">+            if orig_type != CHANGE_COPY:</span>
<span class="gi">+                delete_paths.add(old_path)</span>
<span class="gi">+            add_paths.add(new_path)</span>
<span class="gi">+            self._changes.append(change)</span>
<span class="gi">+        self._prune(add_paths, delete_paths)</span>
<span class="gi">+</span>
<span class="gi">+    def _join_modifies(self):</span>
<span class="gi">+        if self._rewrite_threshold is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        modifies = {}</span>
<span class="gi">+        delete_map = {d.old.path: d for d in self._deletes}</span>
<span class="gi">+        for add in self._adds:</span>
<span class="gi">+            path = add.new.path</span>
<span class="gi">+            delete = delete_map.get(path)</span>
<span class="gi">+            if delete is not None and stat.S_IFMT(delete.old.mode) == stat.S_IFMT(</span>
<span class="gi">+                add.new.mode</span>
<span class="gi">+            ):</span>
<span class="gi">+                modifies[path] = TreeChange(CHANGE_MODIFY, delete.old, add.new)</span>
<span class="gi">+</span>
<span class="gi">+        self._adds = [a for a in self._adds if a.new.path not in modifies]</span>
<span class="gi">+        self._deletes = [a for a in self._deletes if a.new.path not in modifies]</span>
<span class="gi">+        self._changes += modifies.values()</span>
<span class="gi">+</span>
<span class="gi">+    def _sorted_changes(self):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        result.extend(self._adds)</span>
<span class="gi">+        result.extend(self._deletes)</span>
<span class="gi">+        result.extend(self._changes)</span>
<span class="gi">+        result.sort(key=_tree_change_key)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _prune_unchanged(self):</span>
<span class="gi">+        if self._want_unchanged:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._deletes = [d for d in self._deletes if d.type != CHANGE_UNCHANGED]</span>
<span class="gi">+</span>
<span class="gi">+    def changes_with_renames(</span>
<span class="gi">+        self, tree1_id, tree2_id, want_unchanged=False, include_trees=False</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate TreeChanges between two tree SHAs, with rename detection.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+        self._reset()</span>
<span class="gi">+        self._want_unchanged = want_unchanged</span>
<span class="gi">+        self._include_trees = include_trees</span>
<span class="gi">+        self._collect_changes(tree1_id, tree2_id)</span>
<span class="gi">+        self._find_exact_renames()</span>
<span class="gi">+        self._find_content_rename_candidates()</span>
<span class="gi">+        self._choose_content_renames()</span>
<span class="gi">+        self._join_modifies()</span>
<span class="gi">+        self._prune_unchanged()</span>
<span class="gi">+        return self._sorted_changes()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Hold on to the pure-python implementations for testing.</span>
<span class="w"> </span>_is_tree_py = _is_tree
<span class="w"> </span>_merge_entries_py = _merge_entries
<span class="w"> </span>_count_blocks_py = _count_blocks
<span class="w"> </span>try:
<span class="gd">-    from dulwich._diff_tree import _count_blocks, _is_tree, _merge_entries</span>
<span class="gi">+    # Try to import Rust versions</span>
<span class="gi">+    from dulwich._diff_tree import (  # type: ignore</span>
<span class="gi">+        _count_blocks,</span>
<span class="gi">+        _is_tree,</span>
<span class="gi">+        _merge_entries,</span>
<span class="gi">+    )</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pass
<span class="gh">diff --git a/dulwich/errors.py b/dulwich/errors.py</span>
<span class="gh">index 7984614e..0e270b7e 100644</span>
<span class="gd">--- a/dulwich/errors.py</span>
<span class="gi">+++ b/dulwich/errors.py</span>
<span class="gu">@@ -1,11 +1,37 @@</span>
<span class="gi">+# errors.py -- errors for dulwich</span>
<span class="gi">+# Copyright (C) 2007 James Westby &lt;jw+debian@jameswestby.net&gt;</span>
<span class="gi">+# Copyright (C) 2009-2012 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Dulwich-related exception classes and utility functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Please do not add more errors here, but instead add them close to the code</span>
<span class="gi">+# that raises the error.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii


<span class="w"> </span>class ChecksumMismatch(Exception):
<span class="w"> </span>    &quot;&quot;&quot;A checksum didn&#39;t match the expected contents.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, expected, got, extra=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, expected, got, extra=None) -&gt; None:</span>
<span class="w"> </span>        if len(expected) == 20:
<span class="w"> </span>            expected = binascii.hexlify(expected)
<span class="w"> </span>        if len(got) == 20:
<span class="gu">@@ -14,11 +40,15 @@ class ChecksumMismatch(Exception):</span>
<span class="w"> </span>        self.got = got
<span class="w"> </span>        self.extra = extra
<span class="w"> </span>        if self.extra is None:
<span class="gd">-            Exception.__init__(self,</span>
<span class="gd">-                f&#39;Checksum mismatch: Expected {expected}, got {got}&#39;)</span>
<span class="gi">+            Exception.__init__(</span>
<span class="gi">+                self,</span>
<span class="gi">+                f&quot;Checksum mismatch: Expected {expected}, got {got}&quot;,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            Exception.__init__(self,</span>
<span class="gd">-                f&#39;Checksum mismatch: Expected {expected}, got {got}; {extra}&#39;)</span>
<span class="gi">+            Exception.__init__(</span>
<span class="gi">+                self,</span>
<span class="gi">+                f&quot;Checksum mismatch: Expected {expected}, got {got}; {extra}&quot;,</span>
<span class="gi">+            )</span>


<span class="w"> </span>class WrongObjectException(Exception):
<span class="gu">@@ -29,65 +59,70 @@ class WrongObjectException(Exception):</span>
<span class="w"> </span>    Subclasses should define a type_name attribute that indicates what
<span class="w"> </span>    was expected if they were raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    type_name: str

<span class="gd">-    def __init__(self, sha, *args, **kwargs) -&gt;None:</span>
<span class="gd">-        Exception.__init__(self, f&#39;{sha} is not a {self.type_name}&#39;)</span>
<span class="gi">+    def __init__(self, sha, *args, **kwargs) -&gt; None:</span>
<span class="gi">+        Exception.__init__(self, f&quot;{sha} is not a {self.type_name}&quot;)</span>


<span class="w"> </span>class NotCommitError(WrongObjectException):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that the sha requested does not point to a commit.&quot;&quot;&quot;
<span class="gd">-    type_name = &#39;commit&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = &quot;commit&quot;</span>


<span class="w"> </span>class NotTreeError(WrongObjectException):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that the sha requested does not point to a tree.&quot;&quot;&quot;
<span class="gd">-    type_name = &#39;tree&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = &quot;tree&quot;</span>


<span class="w"> </span>class NotTagError(WrongObjectException):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that the sha requested does not point to a tag.&quot;&quot;&quot;
<span class="gd">-    type_name = &#39;tag&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = &quot;tag&quot;</span>


<span class="w"> </span>class NotBlobError(WrongObjectException):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that the sha requested does not point to a blob.&quot;&quot;&quot;
<span class="gd">-    type_name = &#39;blob&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = &quot;blob&quot;</span>


<span class="w"> </span>class MissingCommitError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that a commit was not found in the repository.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, sha, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, sha, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        self.sha = sha
<span class="gd">-        Exception.__init__(self, f&#39;{sha} is not in the revision store&#39;)</span>
<span class="gi">+        Exception.__init__(self, f&quot;{sha} is not in the revision store&quot;)</span>


<span class="w"> </span>class ObjectMissing(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that a requested object is missing.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, sha, *args, **kwargs) -&gt;None:</span>
<span class="gd">-        Exception.__init__(self, f&#39;{sha} is not in the pack&#39;)</span>
<span class="gi">+    def __init__(self, sha, *args, **kwargs) -&gt; None:</span>
<span class="gi">+        Exception.__init__(self, f&quot;{sha} is not in the pack&quot;)</span>


<span class="w"> </span>class ApplyDeltaError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that applying a delta failed.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        Exception.__init__(self, *args, **kwargs)


<span class="w"> </span>class NotGitRepository(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Indicates that no Git repository was found.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        Exception.__init__(self, *args, **kwargs)


<span class="w"> </span>class GitProtocolError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Git protocol exception.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        Exception.__init__(self, *args, **kwargs)

<span class="w"> </span>    def __eq__(self, other):
<span class="gu">@@ -101,29 +136,30 @@ class SendPackError(GitProtocolError):</span>
<span class="w"> </span>class HangupException(GitProtocolError):
<span class="w"> </span>    &quot;&quot;&quot;Hangup exception.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, stderr_lines=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, stderr_lines=None) -&gt; None:</span>
<span class="w"> </span>        if stderr_lines:
<span class="gd">-            super().__init__(&#39;\n&#39;.join([line.decode(&#39;utf-8&#39;,</span>
<span class="gd">-                &#39;surrogateescape&#39;) for line in stderr_lines]))</span>
<span class="gd">-        else:</span>
<span class="w"> </span>            super().__init__(
<span class="gd">-                &#39;The remote server unexpectedly closed the connection.&#39;)</span>
<span class="gi">+                &quot;\n&quot;.join(</span>
<span class="gi">+                    [line.decode(&quot;utf-8&quot;, &quot;surrogateescape&quot;) for line in stderr_lines]</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().__init__(&quot;The remote server unexpectedly closed the connection.&quot;)</span>
<span class="w"> </span>        self.stderr_lines = stderr_lines

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return isinstance(self, type(other)</span>
<span class="gd">-            ) and self.stderr_lines == other.stderr_lines</span>
<span class="gi">+        return isinstance(self, type(other)) and self.stderr_lines == other.stderr_lines</span>


<span class="w"> </span>class UnexpectedCommandError(GitProtocolError):
<span class="w"> </span>    &quot;&quot;&quot;Unexpected command received in a proto line.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, command) -&gt;None:</span>
<span class="gi">+    def __init__(self, command) -&gt; None:</span>
<span class="w"> </span>        if command is None:
<span class="gd">-            command = &#39;flush-pkt&#39;</span>
<span class="gi">+            command = &quot;flush-pkt&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            command = f&#39;command {command}&#39;</span>
<span class="gd">-        super().__init__(f&#39;Protocol got unexpected {command}&#39;)</span>
<span class="gi">+            command = f&quot;command {command}&quot;</span>
<span class="gi">+        super().__init__(f&quot;Protocol got unexpected {command}&quot;)</span>


<span class="w"> </span>class FileFormatException(Exception):
<span class="gh">diff --git a/dulwich/fastexport.py b/dulwich/fastexport.py</span>
<span class="gh">index 79b34db3..182517ed 100644</span>
<span class="gd">--- a/dulwich/fastexport.py</span>
<span class="gi">+++ b/dulwich/fastexport.py</span>
<span class="gu">@@ -1,57 +1,248 @@</span>
<span class="gi">+# __init__.py -- Fast export/import functionality</span>
<span class="gi">+# Copyright (C) 2010-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Fast export/import functionality.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import stat
<span class="w"> </span>from typing import Dict, Tuple
<span class="gi">+</span>
<span class="w"> </span>from fastimport import commands, parser, processor
<span class="w"> </span>from fastimport import errors as fastimport_errors
<span class="gi">+</span>
<span class="w"> </span>from .index import commit_tree
<span class="w"> </span>from .object_store import iter_tree_contents
<span class="w"> </span>from .objects import ZERO_SHA, Blob, Commit, Tag


<span class="gi">+def split_email(text):</span>
<span class="gi">+    (name, email) = text.rsplit(b&quot; &lt;&quot;, 1)</span>
<span class="gi">+    return (name, email.rstrip(b&quot;&gt;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class GitFastExporter:
<span class="w"> </span>    &quot;&quot;&quot;Generate a fast-export output stream for Git objects.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, outf, store) -&gt;None:</span>
<span class="gi">+    def __init__(self, outf, store) -&gt; None:</span>
<span class="w"> </span>        self.outf = outf
<span class="w"> </span>        self.store = store
<span class="w"> </span>        self.markers: Dict[bytes, bytes] = {}
<span class="w"> </span>        self._marker_idx = 0

<span class="gi">+    def print_cmd(self, cmd):</span>
<span class="gi">+        self.outf.write(getattr(cmd, &quot;__bytes__&quot;, cmd.__repr__)() + b&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _allocate_marker(self):</span>
<span class="gi">+        self._marker_idx += 1</span>
<span class="gi">+        return (&quot;%d&quot; % (self._marker_idx,)).encode(&quot;ascii&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _export_blob(self, blob):</span>
<span class="gi">+        marker = self._allocate_marker()</span>
<span class="gi">+        self.markers[marker] = blob.id</span>
<span class="gi">+        return (commands.BlobCommand(marker, blob.data), marker)</span>
<span class="gi">+</span>
<span class="gi">+    def emit_blob(self, blob):</span>
<span class="gi">+        (cmd, marker) = self._export_blob(blob)</span>
<span class="gi">+        self.print_cmd(cmd)</span>
<span class="gi">+        return marker</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_files(self, base_tree, new_tree):</span>
<span class="gi">+        for (</span>
<span class="gi">+            (old_path, new_path),</span>
<span class="gi">+            (old_mode, new_mode),</span>
<span class="gi">+            (old_hexsha, new_hexsha),</span>
<span class="gi">+        ) in self.store.tree_changes(base_tree, new_tree):</span>
<span class="gi">+            if new_path is None:</span>
<span class="gi">+                yield commands.FileDeleteCommand(old_path)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not stat.S_ISDIR(new_mode):</span>
<span class="gi">+                blob = self.store[new_hexsha]</span>
<span class="gi">+                marker = self.emit_blob(blob)</span>
<span class="gi">+            if old_path != new_path and old_path is not None:</span>
<span class="gi">+                yield commands.FileRenameCommand(old_path, new_path)</span>
<span class="gi">+            if old_mode != new_mode or old_hexsha != new_hexsha:</span>
<span class="gi">+                prefixed_marker = b&quot;:&quot; + marker</span>
<span class="gi">+                yield commands.FileModifyCommand(</span>
<span class="gi">+                    new_path, new_mode, prefixed_marker, None</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _export_commit(self, commit, ref, base_tree=None):</span>
<span class="gi">+        file_cmds = list(self._iter_files(base_tree, commit.tree))</span>
<span class="gi">+        marker = self._allocate_marker()</span>
<span class="gi">+        if commit.parents:</span>
<span class="gi">+            from_ = commit.parents[0]</span>
<span class="gi">+            merges = commit.parents[1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            from_ = None</span>
<span class="gi">+            merges = []</span>
<span class="gi">+        author, author_email = split_email(commit.author)</span>
<span class="gi">+        committer, committer_email = split_email(commit.committer)</span>
<span class="gi">+        cmd = commands.CommitCommand(</span>
<span class="gi">+            ref,</span>
<span class="gi">+            marker,</span>
<span class="gi">+            (author, author_email, commit.author_time, commit.author_timezone),</span>
<span class="gi">+            (</span>
<span class="gi">+                committer,</span>
<span class="gi">+                committer_email,</span>
<span class="gi">+                commit.commit_time,</span>
<span class="gi">+                commit.commit_timezone,</span>
<span class="gi">+            ),</span>
<span class="gi">+            commit.message,</span>
<span class="gi">+            from_,</span>
<span class="gi">+            merges,</span>
<span class="gi">+            file_cmds,</span>
<span class="gi">+        )</span>
<span class="gi">+        return (cmd, marker)</span>
<span class="gi">+</span>
<span class="gi">+    def emit_commit(self, commit, ref, base_tree=None):</span>
<span class="gi">+        cmd, marker = self._export_commit(commit, ref, base_tree)</span>
<span class="gi">+        self.print_cmd(cmd)</span>
<span class="gi">+        return marker</span>
<span class="gi">+</span>

<span class="w"> </span>class GitImportProcessor(processor.ImportProcessor):
<span class="w"> </span>    &quot;&quot;&quot;An import processor that imports into a Git repository using Dulwich.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, repo, params=None, verbose=False, outf=None) -&gt;None:</span>
<span class="gi">+    # FIXME: Batch creation of objects?</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, repo, params=None, verbose=False, outf=None) -&gt; None:</span>
<span class="w"> </span>        processor.ImportProcessor.__init__(self, params, verbose)
<span class="w"> </span>        self.repo = repo
<span class="w"> </span>        self.last_commit = ZERO_SHA
<span class="w"> </span>        self.markers: Dict[bytes, bytes] = {}
<span class="w"> </span>        self._contents: Dict[bytes, Tuple[int, bytes]] = {}

<span class="gi">+    def lookup_object(self, objectish):</span>
<span class="gi">+        if objectish.startswith(b&quot;:&quot;):</span>
<span class="gi">+            return self.markers[objectish[1:]]</span>
<span class="gi">+        return objectish</span>
<span class="gi">+</span>
<span class="gi">+    def import_stream(self, stream):</span>
<span class="gi">+        p = parser.ImportParser(stream)</span>
<span class="gi">+        self.process(p.iter_commands)</span>
<span class="gi">+        return self.markers</span>
<span class="gi">+</span>
<span class="w"> </span>    def blob_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a BlobCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        blob = Blob.from_string(cmd.data)</span>
<span class="gi">+        self.repo.object_store.add_object(blob)</span>
<span class="gi">+        if cmd.mark:</span>
<span class="gi">+            self.markers[cmd.mark] = blob.id</span>

<span class="w"> </span>    def checkpoint_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a CheckpointCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    def commit_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a CommitCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        commit = Commit()</span>
<span class="gi">+        if cmd.author is not None:</span>
<span class="gi">+            author = cmd.author</span>
<span class="gi">+        else:</span>
<span class="gi">+            author = cmd.committer</span>
<span class="gi">+        (author_name, author_email, author_timestamp, author_timezone) = author</span>
<span class="gi">+        (</span>
<span class="gi">+            committer_name,</span>
<span class="gi">+            committer_email,</span>
<span class="gi">+            commit_timestamp,</span>
<span class="gi">+            commit_timezone,</span>
<span class="gi">+        ) = cmd.committer</span>
<span class="gi">+        commit.author = author_name + b&quot; &lt;&quot; + author_email + b&quot;&gt;&quot;</span>
<span class="gi">+        commit.author_timezone = author_timezone</span>
<span class="gi">+        commit.author_time = int(author_timestamp)</span>
<span class="gi">+        commit.committer = committer_name + b&quot; &lt;&quot; + committer_email + b&quot;&gt;&quot;</span>
<span class="gi">+        commit.commit_timezone = commit_timezone</span>
<span class="gi">+        commit.commit_time = int(commit_timestamp)</span>
<span class="gi">+        commit.message = cmd.message</span>
<span class="gi">+        commit.parents = []</span>
<span class="gi">+        if cmd.from_:</span>
<span class="gi">+            cmd.from_ = self.lookup_object(cmd.from_)</span>
<span class="gi">+            self._reset_base(cmd.from_)</span>
<span class="gi">+        for filecmd in cmd.iter_files():</span>
<span class="gi">+            if filecmd.name == b&quot;filemodify&quot;:</span>
<span class="gi">+                if filecmd.data is not None:</span>
<span class="gi">+                    blob = Blob.from_string(filecmd.data)</span>
<span class="gi">+                    self.repo.object_store.add(blob)</span>
<span class="gi">+                    blob_id = blob.id</span>
<span class="gi">+                else:</span>
<span class="gi">+                    blob_id = self.lookup_object(filecmd.dataref)</span>
<span class="gi">+                self._contents[filecmd.path] = (filecmd.mode, blob_id)</span>
<span class="gi">+            elif filecmd.name == b&quot;filedelete&quot;:</span>
<span class="gi">+                del self._contents[filecmd.path]</span>
<span class="gi">+            elif filecmd.name == b&quot;filecopy&quot;:</span>
<span class="gi">+                self._contents[filecmd.dest_path] = self._contents[filecmd.src_path]</span>
<span class="gi">+            elif filecmd.name == b&quot;filerename&quot;:</span>
<span class="gi">+                self._contents[filecmd.new_path] = self._contents[filecmd.old_path]</span>
<span class="gi">+                del self._contents[filecmd.old_path]</span>
<span class="gi">+            elif filecmd.name == b&quot;filedeleteall&quot;:</span>
<span class="gi">+                self._contents = {}</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise Exception(f&quot;Command {filecmd.name} not supported&quot;)</span>
<span class="gi">+        commit.tree = commit_tree(</span>
<span class="gi">+            self.repo.object_store,</span>
<span class="gi">+            ((path, hexsha, mode) for (path, (mode, hexsha)) in self._contents.items()),</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.last_commit != ZERO_SHA:</span>
<span class="gi">+            commit.parents.append(self.last_commit)</span>
<span class="gi">+        for merge in cmd.merges:</span>
<span class="gi">+            commit.parents.append(self.lookup_object(merge))</span>
<span class="gi">+        self.repo.object_store.add_object(commit)</span>
<span class="gi">+        self.repo[cmd.ref] = commit.id</span>
<span class="gi">+        self.last_commit = commit.id</span>
<span class="gi">+        if cmd.mark:</span>
<span class="gi">+            self.markers[cmd.mark] = commit.id</span>

<span class="w"> </span>    def progress_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a ProgressCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _reset_base(self, commit_id):</span>
<span class="gi">+        if self.last_commit == commit_id:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._contents = {}</span>
<span class="gi">+        self.last_commit = commit_id</span>
<span class="gi">+        if commit_id != ZERO_SHA:</span>
<span class="gi">+            tree_id = self.repo[commit_id].tree</span>
<span class="gi">+            for (</span>
<span class="gi">+                path,</span>
<span class="gi">+                mode,</span>
<span class="gi">+                hexsha,</span>
<span class="gi">+            ) in iter_tree_contents(self.repo.object_store, tree_id):</span>
<span class="gi">+                self._contents[path] = (mode, hexsha)</span>

<span class="w"> </span>    def reset_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a ResetCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cmd.from_ is None:</span>
<span class="gi">+            from_ = ZERO_SHA</span>
<span class="gi">+        else:</span>
<span class="gi">+            from_ = self.lookup_object(cmd.from_)</span>
<span class="gi">+        self._reset_base(from_)</span>
<span class="gi">+        self.repo.refs[cmd.ref] = from_</span>

<span class="w"> </span>    def tag_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a TagCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tag = Tag()</span>
<span class="gi">+        tag.tagger = cmd.tagger</span>
<span class="gi">+        tag.message = cmd.message</span>
<span class="gi">+        tag.name = cmd.tag</span>
<span class="gi">+        self.repo.add_object(tag)</span>
<span class="gi">+        self.repo.refs[&quot;refs/tags/&quot; + tag.name] = tag.id</span>

<span class="w"> </span>    def feature_handler(self, cmd):
<span class="w"> </span>        &quot;&quot;&quot;Process a FeatureCommand.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise fastimport_errors.UnknownFeature(cmd.feature_name)</span>
<span class="gh">diff --git a/dulwich/file.py b/dulwich/file.py</span>
<span class="gh">index f52c127c..d65a81dd 100644</span>
<span class="gd">--- a/dulwich/file.py</span>
<span class="gi">+++ b/dulwich/file.py</span>
<span class="gu">@@ -1,4 +1,25 @@</span>
<span class="gi">+# file.py -- Safe access to git files</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Safe access to git files.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="gu">@@ -7,15 +28,46 @@ from typing import ClassVar, Set</span>

<span class="w"> </span>def ensure_dir_exists(dirname):
<span class="w"> </span>    &quot;&quot;&quot;Ensure a directory exists, creating if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.makedirs(dirname)</span>
<span class="gi">+    except FileExistsError:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>def _fancy_rename(oldname, newname):
<span class="w"> </span>    &quot;&quot;&quot;Rename file with temporary backup file to rollback if rename fails.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def GitFile(filename, mode=&#39;rb&#39;, bufsize=-1, mask=420):</span>
<span class="gi">+    if not os.path.exists(newname):</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.rename(oldname, newname)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            raise</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Defer the tempfile import since it pulls in a lot of other things.</span>
<span class="gi">+    import tempfile</span>
<span class="gi">+</span>
<span class="gi">+    # destination file exists</span>
<span class="gi">+    try:</span>
<span class="gi">+        (fd, tmpfile) = tempfile.mkstemp(&quot;.tmp&quot;, prefix=oldname, dir=&quot;.&quot;)</span>
<span class="gi">+        os.close(fd)</span>
<span class="gi">+        os.remove(tmpfile)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        # either file could not be created (e.g. permission problem)</span>
<span class="gi">+        # or could not be deleted (e.g. rude virus scanner)</span>
<span class="gi">+        raise</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.rename(newname, tmpfile)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        raise  # no rename occurred</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.rename(oldname, newname)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        os.rename(tmpfile, newname)</span>
<span class="gi">+        raise</span>
<span class="gi">+    os.remove(tmpfile)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def GitFile(filename, mode=&quot;rb&quot;, bufsize=-1, mask=0o644):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a file object that obeys the git file locking protocol.

<span class="w"> </span>    Returns: a builtin file object or a _GitFile object
<span class="gu">@@ -31,13 +83,22 @@ def GitFile(filename, mode=&#39;rb&#39;, bufsize=-1, mask=420):</span>
<span class="w"> </span>    world-readable.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;a&quot; in mode:</span>
<span class="gi">+        raise OSError(&quot;append mode not supported for Git files&quot;)</span>
<span class="gi">+    if &quot;+&quot; in mode:</span>
<span class="gi">+        raise OSError(&quot;read/write mode not supported for Git files&quot;)</span>
<span class="gi">+    if &quot;b&quot; not in mode:</span>
<span class="gi">+        raise OSError(&quot;text mode not supported for Git files&quot;)</span>
<span class="gi">+    if &quot;w&quot; in mode:</span>
<span class="gi">+        return _GitFile(filename, mode, bufsize, mask)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return open(filename, mode, bufsize)</span>


<span class="w"> </span>class FileLocked(Exception):
<span class="w"> </span>    &quot;&quot;&quot;File is already locked.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, lockfilename) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename, lockfilename) -&gt; None:</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.lockfilename = lockfilename
<span class="w"> </span>        super().__init__(filename, lockfilename)
<span class="gu">@@ -53,25 +114,48 @@ class _GitFile:</span>
<span class="w"> </span>    Note: You *must* call close() or abort() on a _GitFile for the lock to be
<span class="w"> </span>        released. Typically this will happen in a finally block.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    PROXY_PROPERTIES: ClassVar[Set[str]] = {&#39;closed&#39;, &#39;encoding&#39;, &#39;errors&#39;,</span>
<span class="gd">-        &#39;mode&#39;, &#39;name&#39;, &#39;newlines&#39;, &#39;softspace&#39;}</span>
<span class="gd">-    PROXY_METHODS: ClassVar[Set[str]] = {&#39;__iter__&#39;, &#39;flush&#39;, &#39;fileno&#39;,</span>
<span class="gd">-        &#39;isatty&#39;, &#39;read&#39;, &#39;readline&#39;, &#39;readlines&#39;, &#39;seek&#39;, &#39;tell&#39;,</span>
<span class="gd">-        &#39;truncate&#39;, &#39;write&#39;, &#39;writelines&#39;}</span>

<span class="gd">-    def __init__(self, filename, mode, bufsize, mask) -&gt;None:</span>
<span class="gi">+    PROXY_PROPERTIES: ClassVar[Set[str]] = {</span>
<span class="gi">+        &quot;closed&quot;,</span>
<span class="gi">+        &quot;encoding&quot;,</span>
<span class="gi">+        &quot;errors&quot;,</span>
<span class="gi">+        &quot;mode&quot;,</span>
<span class="gi">+        &quot;name&quot;,</span>
<span class="gi">+        &quot;newlines&quot;,</span>
<span class="gi">+        &quot;softspace&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    PROXY_METHODS: ClassVar[Set[str]] = {</span>
<span class="gi">+        &quot;__iter__&quot;,</span>
<span class="gi">+        &quot;flush&quot;,</span>
<span class="gi">+        &quot;fileno&quot;,</span>
<span class="gi">+        &quot;isatty&quot;,</span>
<span class="gi">+        &quot;read&quot;,</span>
<span class="gi">+        &quot;readline&quot;,</span>
<span class="gi">+        &quot;readlines&quot;,</span>
<span class="gi">+        &quot;seek&quot;,</span>
<span class="gi">+        &quot;tell&quot;,</span>
<span class="gi">+        &quot;truncate&quot;,</span>
<span class="gi">+        &quot;write&quot;,</span>
<span class="gi">+        &quot;writelines&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, filename, mode, bufsize, mask) -&gt; None:</span>
<span class="w"> </span>        self._filename = filename
<span class="w"> </span>        if isinstance(self._filename, bytes):
<span class="gd">-            self._lockfilename = self._filename + b&#39;.lock&#39;</span>
<span class="gi">+            self._lockfilename = self._filename + b&quot;.lock&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            self._lockfilename = self._filename + &#39;.lock&#39;</span>
<span class="gi">+            self._lockfilename = self._filename + &quot;.lock&quot;</span>
<span class="w"> </span>        try:
<span class="gd">-            fd = os.open(self._lockfilename, os.O_RDWR | os.O_CREAT | os.</span>
<span class="gd">-                O_EXCL | getattr(os, &#39;O_BINARY&#39;, 0), mask)</span>
<span class="gi">+            fd = os.open(</span>
<span class="gi">+                self._lockfilename,</span>
<span class="gi">+                os.O_RDWR | os.O_CREAT | os.O_EXCL | getattr(os, &quot;O_BINARY&quot;, 0),</span>
<span class="gi">+                mask,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except FileExistsError as exc:
<span class="w"> </span>            raise FileLocked(filename, self._lockfilename) from exc
<span class="w"> </span>        self._file = os.fdopen(fd, mode, bufsize)
<span class="w"> </span>        self._closed = False
<span class="gi">+</span>
<span class="w"> </span>        for method in self.PROXY_METHODS:
<span class="w"> </span>            setattr(self, method, getattr(self._file, method))

<span class="gu">@@ -80,7 +164,15 @@ class _GitFile:</span>

<span class="w"> </span>        If the file is already closed, this is a no-op.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._file.close()</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.remove(self._lockfilename)</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            # The file may have been removed already, which is ok.</span>
<span class="gi">+            self._closed = True</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close this file, saving the lockfile over the original.
<span class="gu">@@ -95,11 +187,27 @@ class _GitFile:</span>
<span class="w"> </span>            lock file is still closed, so further attempts to write to the same
<span class="w"> </span>            file object will raise ValueError.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._file.flush()</span>
<span class="gi">+        os.fsync(self._file.fileno())</span>
<span class="gi">+        self._file.close()</span>
<span class="gi">+        try:</span>
<span class="gi">+            if getattr(os, &quot;replace&quot;, None) is not None:</span>
<span class="gi">+                os.replace(self._lockfilename, self._filename)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if sys.platform != &quot;win32&quot;:</span>
<span class="gi">+                    os.rename(self._lockfilename, self._filename)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Windows versions prior to Vista don&#39;t support atomic</span>
<span class="gi">+                    # renames</span>
<span class="gi">+                    _fancy_rename(self._lockfilename, self._filename)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.abort()</span>

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gd">-        if not getattr(self, &#39;_closed&#39;, True):</span>
<span class="gd">-            warnings.warn(f&#39;unclosed {self!r}&#39;, ResourceWarning, stacklevel=2)</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="gi">+        if not getattr(self, &quot;_closed&quot;, True):</span>
<span class="gi">+            warnings.warn(f&quot;unclosed {self!r}&quot;, ResourceWarning, stacklevel=2)</span>
<span class="w"> </span>            self.abort()

<span class="w"> </span>    def __enter__(self):
<span class="gh">diff --git a/dulwich/graph.py b/dulwich/graph.py</span>
<span class="gh">index ea7dfbd7..9c18dca6 100644</span>
<span class="gd">--- a/dulwich/graph.py</span>
<span class="gi">+++ b/dulwich/graph.py</span>
<span class="gu">@@ -1,14 +1,120 @@</span>
<span class="gi">+# vim:ts=4:sw=4:softtabstop=4:smarttab:expandtab</span>
<span class="gi">+# Copyright (c) 2020 Kevin B. Hendricks, Stratford Ontario Canada</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Implementation of merge-base following the approach of git.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from heapq import heappop, heappush
<span class="gi">+</span>
<span class="w"> </span>from .lru_cache import LRUCache


<span class="gi">+# priority queue using builtin python minheap tools</span>
<span class="gi">+# why they do not have a builtin maxheap is simply ridiculous but</span>
<span class="gi">+# liveable with integer time stamps using negation</span>
<span class="w"> </span>class WorkList:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.pq = []

<span class="gi">+    def add(self, item):</span>
<span class="gi">+        dt, cmt = item</span>
<span class="gi">+        heappush(self.pq, (-dt, cmt))</span>
<span class="gi">+</span>
<span class="gi">+    def get(self):</span>
<span class="gi">+        item = heappop(self.pq)</span>
<span class="gi">+        if item:</span>
<span class="gi">+            pr, cmt = item</span>
<span class="gi">+            return -pr, cmt</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def iter(self):</span>
<span class="gi">+        for pr, cmt in self.pq:</span>
<span class="gi">+            yield (-pr, cmt)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_lcas(lookup_parents, c1, c2s, lookup_stamp, min_stamp=0):</span>
<span class="gi">+    cands = []</span>
<span class="gi">+    cstates = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Flags to Record State</span>
<span class="gi">+    _ANC_OF_1 = 1  # ancestor of commit 1</span>
<span class="gi">+    _ANC_OF_2 = 2  # ancestor of commit 2</span>
<span class="gi">+    _DNC = 4  # Do Not Consider</span>
<span class="gi">+    _LCA = 8  # potential LCA (Lowest Common Ancestor)</span>
<span class="gi">+</span>
<span class="gi">+    def _has_candidates(wlst, cstates):</span>
<span class="gi">+        for dt, cmt in wlst.iter():</span>
<span class="gi">+            if cmt in cstates:</span>
<span class="gi">+                if not ((cstates[cmt] &amp; _DNC) == _DNC):</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # initialize the working list states with ancestry info</span>
<span class="gi">+    # note possibility of c1 being one of c2s should be handled</span>
<span class="gi">+    wlst = WorkList()</span>
<span class="gi">+    cstates[c1] = _ANC_OF_1</span>
<span class="gi">+    wlst.add((lookup_stamp(c1), c1))</span>
<span class="gi">+    for c2 in c2s:</span>
<span class="gi">+        cflags = cstates.get(c2, 0)</span>
<span class="gi">+        cstates[c2] = cflags | _ANC_OF_2</span>
<span class="gi">+        wlst.add((lookup_stamp(c2), c2))</span>
<span class="gi">+</span>
<span class="gi">+    # loop while at least one working list commit is still viable (not marked as _DNC)</span>
<span class="gi">+    # adding any parents to the list in a breadth first manner</span>
<span class="gi">+    while _has_candidates(wlst, cstates):</span>
<span class="gi">+        dt, cmt = wlst.get()</span>
<span class="gi">+        # Look only at ANCESTRY and _DNC flags so that already</span>
<span class="gi">+        # found _LCAs can still be marked _DNC by lower _LCAS</span>
<span class="gi">+        cflags = cstates[cmt] &amp; (_ANC_OF_1 | _ANC_OF_2 | _DNC)</span>
<span class="gi">+        if cflags == (_ANC_OF_1 | _ANC_OF_2):</span>
<span class="gi">+            # potential common ancestor if not already in candidates add it</span>
<span class="gi">+            if not (cstates[cmt] &amp; _LCA) == _LCA:</span>
<span class="gi">+                cstates[cmt] = cstates[cmt] | _LCA</span>
<span class="gi">+                cands.append((dt, cmt))</span>
<span class="gi">+            # mark any parents of this node _DNC as all parents</span>
<span class="gi">+            # would be one generation further removed common ancestors</span>
<span class="gi">+            cflags = cflags | _DNC</span>
<span class="gi">+        parents = lookup_parents(cmt)</span>
<span class="gi">+        if parents:</span>
<span class="gi">+            for pcmt in parents:</span>
<span class="gi">+                pflags = cstates.get(pcmt, 0)</span>
<span class="gi">+                # if this parent was already visited with no new ancestry/flag information</span>
<span class="gi">+                # do not add it to the working list again</span>
<span class="gi">+                if (pflags &amp; cflags) == cflags:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                pdt = lookup_stamp(pcmt)</span>
<span class="gi">+                if pdt &lt; min_stamp:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                cstates[pcmt] = pflags | cflags</span>
<span class="gi">+                wlst.add((pdt, pcmt))</span>

<span class="gi">+    # walk final candidates removing any superseded by _DNC by later lower _LCAs</span>
<span class="gi">+    # remove any duplicates and sort it so that earliest is first</span>
<span class="gi">+    results = []</span>
<span class="gi">+    for dt, cmt in cands:</span>
<span class="gi">+        if not ((cstates[cmt] &amp; _DNC) == _DNC) and (dt, cmt) not in results:</span>
<span class="gi">+            results.append((dt, cmt))</span>
<span class="gi">+    results.sort(key=lambda x: x[0])</span>
<span class="gi">+    lcas = [cmt for dt, cmt in results]</span>
<span class="gi">+    return lcas</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# actual git sorts these based on commit times</span>
<span class="w"> </span>def find_merge_base(repo, commit_ids):
<span class="w"> </span>    &quot;&quot;&quot;Find lowest common ancestors of commit_ids[0] and *any* of commits_ids[1:].

<span class="gu">@@ -18,7 +124,31 @@ def find_merge_base(repo, commit_ids):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      list of lowest common ancestor commit_ids
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmtcache = LRUCache(max_cache=128)</span>
<span class="gi">+    parents_provider = repo.parents_provider()</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_stamp(cmtid):</span>
<span class="gi">+        if cmtid not in cmtcache:</span>
<span class="gi">+            cmtcache[cmtid] = repo.object_store[cmtid]</span>
<span class="gi">+        return cmtcache[cmtid].commit_time</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_parents(cmtid):</span>
<span class="gi">+        commit = None</span>
<span class="gi">+        if cmtid in cmtcache:</span>
<span class="gi">+            commit = cmtcache[cmtid]</span>
<span class="gi">+        # must use parents provider to handle grafts and shallow</span>
<span class="gi">+        return parents_provider.get_parents(cmtid, commit=commit)</span>
<span class="gi">+</span>
<span class="gi">+    if not commit_ids:</span>
<span class="gi">+        return []</span>
<span class="gi">+    c1 = commit_ids[0]</span>
<span class="gi">+    if not len(commit_ids) &gt; 1:</span>
<span class="gi">+        return [c1]</span>
<span class="gi">+    c2s = commit_ids[1:]</span>
<span class="gi">+    if c1 in c2s:</span>
<span class="gi">+        return [c1]</span>
<span class="gi">+    lcas = _find_lcas(lookup_parents, c1, c2s, lookup_stamp)</span>
<span class="gi">+    return lcas</span>


<span class="w"> </span>def find_octopus_base(repo, commit_ids):
<span class="gu">@@ -30,7 +160,34 @@ def find_octopus_base(repo, commit_ids):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      list of lowest common ancestor commit_ids
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmtcache = LRUCache(max_cache=128)</span>
<span class="gi">+    parents_provider = repo.parents_provider()</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_stamp(cmtid):</span>
<span class="gi">+        if cmtid not in cmtcache:</span>
<span class="gi">+            cmtcache[cmtid] = repo.object_store[cmtid]</span>
<span class="gi">+        return cmtcache[cmtid].commit_time</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_parents(cmtid):</span>
<span class="gi">+        commit = None</span>
<span class="gi">+        if cmtid in cmtcache:</span>
<span class="gi">+            commit = cmtcache[cmtid]</span>
<span class="gi">+        # must use parents provider to handle grafts and shallow</span>
<span class="gi">+        return parents_provider.get_parents(cmtid, commit=commit)</span>
<span class="gi">+</span>
<span class="gi">+    if not commit_ids:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if len(commit_ids) &lt;= 2:</span>
<span class="gi">+        return find_merge_base(repo, commit_ids)</span>
<span class="gi">+    lcas = [commit_ids[0]]</span>
<span class="gi">+    others = commit_ids[1:]</span>
<span class="gi">+    for cmt in others:</span>
<span class="gi">+        next_lcas = []</span>
<span class="gi">+        for ca in lcas:</span>
<span class="gi">+            res = _find_lcas(lookup_parents, cmt, [ca], lookup_stamp)</span>
<span class="gi">+            next_lcas.extend(res)</span>
<span class="gi">+        lcas = next_lcas[:]</span>
<span class="gi">+    return lcas</span>


<span class="w"> </span>def can_fast_forward(repo, c1, c2):
<span class="gu">@@ -41,4 +198,25 @@ def can_fast_forward(repo, c1, c2):</span>
<span class="w"> </span>      c1: Commit id for first commit
<span class="w"> </span>      c2: Commit id for second commit
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmtcache = LRUCache(max_cache=128)</span>
<span class="gi">+    parents_provider = repo.parents_provider()</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_stamp(cmtid):</span>
<span class="gi">+        if cmtid not in cmtcache:</span>
<span class="gi">+            cmtcache[cmtid] = repo.object_store[cmtid]</span>
<span class="gi">+        return cmtcache[cmtid].commit_time</span>
<span class="gi">+</span>
<span class="gi">+    def lookup_parents(cmtid):</span>
<span class="gi">+        commit = None</span>
<span class="gi">+        if cmtid in cmtcache:</span>
<span class="gi">+            commit = cmtcache[cmtid]</span>
<span class="gi">+        # must use parents provider to handle grafts and shallow</span>
<span class="gi">+        return parents_provider.get_parents(cmtid, commit=commit)</span>
<span class="gi">+</span>
<span class="gi">+    if c1 == c2:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Algorithm: Find the common ancestor</span>
<span class="gi">+    min_stamp = lookup_stamp(c1)</span>
<span class="gi">+    lcas = _find_lcas(lookup_parents, c1, [c2], lookup_stamp, min_stamp=min_stamp)</span>
<span class="gi">+    return lcas == [c1]</span>
<span class="gh">diff --git a/dulwich/greenthreads.py b/dulwich/greenthreads.py</span>
<span class="gh">index 72c31520..2255ac09 100644</span>
<span class="gd">--- a/dulwich/greenthreads.py</span>
<span class="gi">+++ b/dulwich/greenthreads.py</span>
<span class="gu">@@ -1,19 +1,67 @@</span>
<span class="gi">+# greenthreads.py -- Utility module for querying an ObjectStore with gevent</span>
<span class="gi">+# Copyright (C) 2013 eNovance SAS &lt;licensing@enovance.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Author: Fabien Boucher &lt;fabien.boucher@enovance.com&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utility module for querying an ObjectStore with gevent.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import FrozenSet, Optional, Set, Tuple
<span class="gi">+</span>
<span class="w"> </span>import gevent
<span class="w"> </span>from gevent import pool
<span class="gd">-from .object_store import MissingObjectFinder, _collect_ancestors, _collect_filetree_revs</span>
<span class="gi">+</span>
<span class="gi">+from .object_store import (</span>
<span class="gi">+    MissingObjectFinder,</span>
<span class="gi">+    _collect_ancestors,</span>
<span class="gi">+    _collect_filetree_revs,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .objects import Commit, ObjectID, Tag


<span class="gd">-def _split_commits_and_tags(obj_store, lst, *, ignore_unknown=False, pool=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def _split_commits_and_tags(obj_store, lst, *, ignore_unknown=False, pool=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Split object id list into two list with commit SHA1s and tag SHA1s.

<span class="w"> </span>    Same implementation as object_store._split_commits_and_tags
<span class="w"> </span>    except we use gevent to parallelize object retrieval.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    commits = set()</span>
<span class="gi">+    tags = set()</span>
<span class="gi">+</span>
<span class="gi">+    def find_commit_type(sha):</span>
<span class="gi">+        try:</span>
<span class="gi">+            o = obj_store[sha]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if not ignore_unknown:</span>
<span class="gi">+                raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(o, Commit):</span>
<span class="gi">+                commits.add(sha)</span>
<span class="gi">+            elif isinstance(o, Tag):</span>
<span class="gi">+                tags.add(sha)</span>
<span class="gi">+                commits.add(o.object[1])</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise KeyError(f&quot;Not a commit or a tag: {sha}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    jobs = [pool.spawn(find_commit_type, s) for s in lst]</span>
<span class="gi">+    gevent.joinall(jobs)</span>
<span class="gi">+    return (commits, tags)</span>


<span class="w"> </span>class GreenThreadsMissingObjectFinder(MissingObjectFinder):
<span class="gu">@@ -23,23 +71,37 @@ class GreenThreadsMissingObjectFinder(MissingObjectFinder):</span>
<span class="w"> </span>    except we use gevent to parallelize object retrieval.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, object_store, haves, wants, progress=None,</span>
<span class="gd">-        get_tagged=None, concurrency=1, get_parents=None) -&gt;None:</span>
<span class="gd">-</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        object_store,</span>
<span class="gi">+        haves,</span>
<span class="gi">+        wants,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        get_tagged=None,</span>
<span class="gi">+        concurrency=1,</span>
<span class="gi">+        get_parents=None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        def collect_tree_sha(sha):
<span class="w"> </span>            self.sha_done.add(sha)
<span class="w"> </span>            cmt = object_store[sha]
<span class="w"> </span>            _collect_filetree_revs(object_store, cmt.tree, self.sha_done)
<span class="gi">+</span>
<span class="w"> </span>        self.object_store = object_store
<span class="w"> </span>        p = pool.Pool(size=concurrency)
<span class="gd">-        have_commits, have_tags = _split_commits_and_tags(object_store,</span>
<span class="gd">-            haves, ignore_unknown=True, pool=p)</span>
<span class="gd">-        want_commits, want_tags = _split_commits_and_tags(object_store,</span>
<span class="gd">-            wants, ignore_unknown=False, pool=p)</span>
<span class="gd">-        all_ancestors: FrozenSet[ObjectID] = frozenset(_collect_ancestors(</span>
<span class="gd">-            object_store, have_commits)[0])</span>
<span class="gd">-        missing_commits, common_commits = _collect_ancestors(object_store,</span>
<span class="gd">-            want_commits, all_ancestors)</span>
<span class="gi">+</span>
<span class="gi">+        have_commits, have_tags = _split_commits_and_tags(</span>
<span class="gi">+            object_store, haves, ignore_unknown=True, pool=p</span>
<span class="gi">+        )</span>
<span class="gi">+        want_commits, want_tags = _split_commits_and_tags(</span>
<span class="gi">+            object_store, wants, ignore_unknown=False, pool=p</span>
<span class="gi">+        )</span>
<span class="gi">+        all_ancestors: FrozenSet[ObjectID] = frozenset(</span>
<span class="gi">+            _collect_ancestors(object_store, have_commits)[0]</span>
<span class="gi">+        )</span>
<span class="gi">+        missing_commits, common_commits = _collect_ancestors(</span>
<span class="gi">+            object_store, want_commits, all_ancestors</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.sha_done = set()
<span class="w"> </span>        jobs = [p.spawn(collect_tree_sha, c) for c in common_commits]
<span class="w"> </span>        gevent.joinall(jobs)
<span class="gu">@@ -47,8 +109,9 @@ class GreenThreadsMissingObjectFinder(MissingObjectFinder):</span>
<span class="w"> </span>            self.sha_done.add(t)
<span class="w"> </span>        missing_tags = want_tags.difference(have_tags)
<span class="w"> </span>        wants = missing_commits.union(missing_tags)
<span class="gd">-        self.objects_to_send: Set[Tuple[ObjectID, Optional[bytes], Optional</span>
<span class="gd">-            [int], bool]] = {(w, None, 0, False) for w in wants}</span>
<span class="gi">+        self.objects_to_send: Set[</span>
<span class="gi">+            Tuple[ObjectID, Optional[bytes], Optional[int], bool]</span>
<span class="gi">+        ] = {(w, None, 0, False) for w in wants}</span>
<span class="w"> </span>        if progress is None:
<span class="w"> </span>            self.progress = lambda x: None
<span class="w"> </span>        else:
<span class="gh">diff --git a/dulwich/hooks.py b/dulwich/hooks.py</span>
<span class="gh">index 88b83bac..b1f56fc5 100644</span>
<span class="gd">--- a/dulwich/hooks.py</span>
<span class="gi">+++ b/dulwich/hooks.py</span>
<span class="gu">@@ -1,6 +1,28 @@</span>
<span class="gi">+# hooks.py -- for dealing with git hooks</span>
<span class="gi">+# Copyright (C) 2012-2013 Jelmer Vernooij and others.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Access to hooks.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess
<span class="gi">+</span>
<span class="w"> </span>from .errors import HookError


<span class="gu">@@ -17,7 +39,7 @@ class Hook:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          a hook may return a useful value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.execute)</span>


<span class="w"> </span>class ShellHook(Hook):
<span class="gu">@@ -28,8 +50,15 @@ class ShellHook(Hook):</span>
<span class="w"> </span>    [0] http://www.kernel.org/pub/software/scm/git/docs/githooks.html
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name, path, numparam, pre_exec_callback=None,</span>
<span class="gd">-        post_exec_callback=None, cwd=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        path,</span>
<span class="gi">+        numparam,</span>
<span class="gi">+        pre_exec_callback=None,</span>
<span class="gi">+        post_exec_callback=None,</span>
<span class="gi">+        cwd=None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Setup shell hook definition.

<span class="w"> </span>        Args:
<span class="gu">@@ -49,59 +78,122 @@ class ShellHook(Hook):</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.filepath = path
<span class="w"> </span>        self.numparam = numparam
<span class="gi">+</span>
<span class="w"> </span>        self.pre_exec_callback = pre_exec_callback
<span class="w"> </span>        self.post_exec_callback = post_exec_callback
<span class="gi">+</span>
<span class="w"> </span>        self.cwd = cwd

<span class="w"> </span>    def execute(self, *args):
<span class="w"> </span>        &quot;&quot;&quot;Execute the hook with given args.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(args) != self.numparam:</span>
<span class="gi">+            raise HookError(</span>
<span class="gi">+                &quot;Hook %s executed with wrong number of args. \</span>
<span class="gi">+                            Expected %d. Saw %d. args: %s&quot;</span>
<span class="gi">+                % (self.name, self.numparam, len(args), args)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self.pre_exec_callback is not None:</span>
<span class="gi">+            args = self.pre_exec_callback(*args)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            ret = subprocess.call(</span>
<span class="gi">+                [os.path.relpath(self.filepath, self.cwd), *list(args)], cwd=self.cwd</span>
<span class="gi">+            )</span>
<span class="gi">+            if ret != 0:</span>
<span class="gi">+                if self.post_exec_callback is not None:</span>
<span class="gi">+                    self.post_exec_callback(0, *args)</span>
<span class="gi">+                raise HookError(</span>
<span class="gi">+                    &quot;Hook %s exited with non-zero status %d&quot; % (self.name, ret)</span>
<span class="gi">+                )</span>
<span class="gi">+            if self.post_exec_callback is not None:</span>
<span class="gi">+                return self.post_exec_callback(1, *args)</span>
<span class="gi">+        except OSError:  # no file. silent failure.</span>
<span class="gi">+            if self.post_exec_callback is not None:</span>
<span class="gi">+                self.post_exec_callback(0, *args)</span>


<span class="w"> </span>class PreCommitShellHook(ShellHook):
<span class="w"> </span>    &quot;&quot;&quot;pre-commit shell hook.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, cwd, controldir) -&gt;None:</span>
<span class="gd">-        filepath = os.path.join(controldir, &#39;hooks&#39;, &#39;pre-commit&#39;)</span>
<span class="gd">-        ShellHook.__init__(self, &#39;pre-commit&#39;, filepath, 0, cwd=cwd)</span>
<span class="gi">+    def __init__(self, cwd, controldir) -&gt; None:</span>
<span class="gi">+        filepath = os.path.join(controldir, &quot;hooks&quot;, &quot;pre-commit&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ShellHook.__init__(self, &quot;pre-commit&quot;, filepath, 0, cwd=cwd)</span>


<span class="w"> </span>class PostCommitShellHook(ShellHook):
<span class="w"> </span>    &quot;&quot;&quot;post-commit shell hook.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, controldir) -&gt;None:</span>
<span class="gd">-        filepath = os.path.join(controldir, &#39;hooks&#39;, &#39;post-commit&#39;)</span>
<span class="gd">-        ShellHook.__init__(self, &#39;post-commit&#39;, filepath, 0, cwd=controldir)</span>
<span class="gi">+    def __init__(self, controldir) -&gt; None:</span>
<span class="gi">+        filepath = os.path.join(controldir, &quot;hooks&quot;, &quot;post-commit&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ShellHook.__init__(self, &quot;post-commit&quot;, filepath, 0, cwd=controldir)</span>


<span class="w"> </span>class CommitMsgShellHook(ShellHook):
<span class="w"> </span>    &quot;&quot;&quot;commit-msg shell hook.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, controldir) -&gt;None:</span>
<span class="gd">-        filepath = os.path.join(controldir, &#39;hooks&#39;, &#39;commit-msg&#39;)</span>
<span class="gi">+    def __init__(self, controldir) -&gt; None:</span>
<span class="gi">+        filepath = os.path.join(controldir, &quot;hooks&quot;, &quot;commit-msg&quot;)</span>

<span class="w"> </span>        def prepare_msg(*args):
<span class="w"> </span>            import tempfile
<span class="gd">-            fd, path = tempfile.mkstemp()</span>
<span class="gd">-            with os.fdopen(fd, &#39;wb&#39;) as f:</span>
<span class="gi">+</span>
<span class="gi">+            (fd, path) = tempfile.mkstemp()</span>
<span class="gi">+</span>
<span class="gi">+            with os.fdopen(fd, &quot;wb&quot;) as f:</span>
<span class="w"> </span>                f.write(args[0])
<span class="gd">-            return path,</span>
<span class="gi">+</span>
<span class="gi">+            return (path,)</span>

<span class="w"> </span>        def clean_msg(success, *args):
<span class="w"> </span>            if success:
<span class="gd">-                with open(args[0], &#39;rb&#39;) as f:</span>
<span class="gi">+                with open(args[0], &quot;rb&quot;) as f:</span>
<span class="w"> </span>                    new_msg = f.read()
<span class="w"> </span>                os.unlink(args[0])
<span class="w"> </span>                return new_msg
<span class="w"> </span>            os.unlink(args[0])
<span class="gd">-        ShellHook.__init__(self, &#39;commit-msg&#39;, filepath, 1, prepare_msg,</span>
<span class="gd">-            clean_msg, controldir)</span>
<span class="gi">+</span>
<span class="gi">+        ShellHook.__init__(</span>
<span class="gi">+            self, &quot;commit-msg&quot;, filepath, 1, prepare_msg, clean_msg, controldir</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PostReceiveShellHook(ShellHook):
<span class="w"> </span>    &quot;&quot;&quot;post-receive shell hook.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, controldir) -&gt;None:</span>
<span class="gi">+    def __init__(self, controldir) -&gt; None:</span>
<span class="w"> </span>        self.controldir = controldir
<span class="gd">-        filepath = os.path.join(controldir, &#39;hooks&#39;, &#39;post-receive&#39;)</span>
<span class="gd">-        ShellHook.__init__(self, &#39;post-receive&#39;, path=filepath, numparam=0)</span>
<span class="gi">+        filepath = os.path.join(controldir, &quot;hooks&quot;, &quot;post-receive&quot;)</span>
<span class="gi">+        ShellHook.__init__(self, &quot;post-receive&quot;, path=filepath, numparam=0)</span>
<span class="gi">+</span>
<span class="gi">+    def execute(self, client_refs):</span>
<span class="gi">+        # do nothing if the script doesn&#39;t exist</span>
<span class="gi">+        if not os.path.exists(self.filepath):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            env = os.environ.copy()</span>
<span class="gi">+            env[&quot;GIT_DIR&quot;] = self.controldir</span>
<span class="gi">+</span>
<span class="gi">+            p = subprocess.Popen(</span>
<span class="gi">+                self.filepath,</span>
<span class="gi">+                stdin=subprocess.PIPE,</span>
<span class="gi">+                stdout=subprocess.PIPE,</span>
<span class="gi">+                stderr=subprocess.PIPE,</span>
<span class="gi">+                env=env,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # client_refs is a list of (oldsha, newsha, ref)</span>
<span class="gi">+            in_data = b&quot;\n&quot;.join([b&quot; &quot;.join(ref) for ref in client_refs])</span>
<span class="gi">+</span>
<span class="gi">+            out_data, err_data = p.communicate(in_data)</span>
<span class="gi">+</span>
<span class="gi">+            if (p.returncode != 0) or err_data:</span>
<span class="gi">+                err_fmt = b&quot;post-receive exit code: %d\n&quot; + b&quot;stdout:\n%s\nstderr:\n%s&quot;</span>
<span class="gi">+                err_msg = err_fmt % (p.returncode, out_data, err_data)</span>
<span class="gi">+                raise HookError(err_msg.decode(&quot;utf-8&quot;, &quot;backslashreplace&quot;))</span>
<span class="gi">+            return out_data</span>
<span class="gi">+        except OSError as err:</span>
<span class="gi">+            raise HookError(repr(err)) from err</span>
<span class="gh">diff --git a/dulwich/ignore.py b/dulwich/ignore.py</span>
<span class="gh">index c824ec53..a2c6d457 100644</span>
<span class="gd">--- a/dulwich/ignore.py</span>
<span class="gi">+++ b/dulwich/ignore.py</span>
<span class="gu">@@ -1,17 +1,77 @@</span>
<span class="gi">+# Copyright (C) 2017 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Parsing of gitignore files.

<span class="w"> </span>For details for the matching rules, see https://git-scm.com/docs/gitignore
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os.path
<span class="w"> </span>import re
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from typing import TYPE_CHECKING, BinaryIO, Dict, Iterable, List, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .repo import Repo
<span class="gi">+</span>
<span class="w"> </span>from .config import Config, get_xdg_config_home_path


<span class="gd">-def translate(pat: bytes) -&gt;bytes:</span>
<span class="gi">+def _translate_segment(segment: bytes) -&gt; bytes:</span>
<span class="gi">+    if segment == b&quot;*&quot;:</span>
<span class="gi">+        return b&quot;[^/]+&quot;</span>
<span class="gi">+    res = b&quot;&quot;</span>
<span class="gi">+    i, n = 0, len(segment)</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        c = segment[i : i + 1]</span>
<span class="gi">+        i = i + 1</span>
<span class="gi">+        if c == b&quot;*&quot;:</span>
<span class="gi">+            res += b&quot;[^/]*&quot;</span>
<span class="gi">+        elif c == b&quot;?&quot;:</span>
<span class="gi">+            res += b&quot;[^/]&quot;</span>
<span class="gi">+        elif c == b&quot;\\&quot;:</span>
<span class="gi">+            res += re.escape(segment[i : i + 1])</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        elif c == b&quot;[&quot;:</span>
<span class="gi">+            j = i</span>
<span class="gi">+            if j &lt; n and segment[j : j + 1] == b&quot;!&quot;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            if j &lt; n and segment[j : j + 1] == b&quot;]&quot;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            while j &lt; n and segment[j : j + 1] != b&quot;]&quot;:</span>
<span class="gi">+                j = j + 1</span>
<span class="gi">+            if j &gt;= n:</span>
<span class="gi">+                res += b&quot;\\[&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                stuff = segment[i:j].replace(b&quot;\\&quot;, b&quot;\\\\&quot;)</span>
<span class="gi">+                i = j + 1</span>
<span class="gi">+                if stuff.startswith(b&quot;!&quot;):</span>
<span class="gi">+                    stuff = b&quot;^&quot; + stuff[1:]</span>
<span class="gi">+                elif stuff.startswith(b&quot;^&quot;):</span>
<span class="gi">+                    stuff = b&quot;\\&quot; + stuff</span>
<span class="gi">+                res += b&quot;[&quot; + stuff + b&quot;]&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            res += re.escape(c)</span>
<span class="gi">+    return res</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def translate(pat: bytes) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Translate a shell PATTERN to a regular expression.

<span class="w"> </span>    There is no way to quote meta-characters.
<span class="gu">@@ -19,20 +79,60 @@ def translate(pat: bytes) -&gt;bytes:</span>
<span class="w"> </span>    Originally copied from fnmatch in Python 2.7, but modified for Dulwich
<span class="w"> </span>    to cope with features in Git ignore patterns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    res = b&quot;(?ms)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if b&quot;/&quot; not in pat[:-1]:</span>
<span class="gi">+        # If there&#39;s no slash, this is a filename-based match</span>
<span class="gi">+        res += b&quot;(.*/)?&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if pat.startswith(b&quot;**/&quot;):</span>
<span class="gi">+        # Leading **/</span>
<span class="gi">+        pat = pat[2:]</span>
<span class="gi">+        res += b&quot;(.*/)?&quot;</span>

<span class="gi">+    if pat.startswith(b&quot;/&quot;):</span>
<span class="gi">+        pat = pat[1:]</span>

<span class="gd">-def read_ignore_patterns(f: BinaryIO) -&gt;Iterable[bytes]:</span>
<span class="gi">+    for i, segment in enumerate(pat.split(b&quot;/&quot;)):</span>
<span class="gi">+        if segment == b&quot;**&quot;:</span>
<span class="gi">+            res += b&quot;(/.*)?&quot;</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            res += (re.escape(b&quot;/&quot;) if i &gt; 0 else b&quot;&quot;) + _translate_segment(segment)</span>
<span class="gi">+</span>
<span class="gi">+    if not pat.endswith(b&quot;/&quot;):</span>
<span class="gi">+        res += b&quot;/?&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return res + b&quot;\\Z&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_ignore_patterns(f: BinaryIO) -&gt; Iterable[bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a git ignore file.

<span class="w"> </span>    Args:
<span class="w"> </span>      f: File-like object to read from
<span class="w"> </span>    Returns: List of patterns
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        line = line.rstrip(b&quot;\r\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore blank lines, they&#39;re used for readability.</span>
<span class="gi">+        if not line.strip():</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if line.startswith(b&quot;#&quot;):</span>
<span class="gi">+            # Comment</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Trailing spaces are ignored unless they are quoted with a backslash.</span>
<span class="gi">+        while line.endswith(b&quot; &quot;) and not line.endswith(b&quot;\\ &quot;):</span>
<span class="gi">+            line = line[:-1]</span>
<span class="gi">+        line = line.replace(b&quot;\\ &quot;, b&quot; &quot;)</span>
<span class="gi">+</span>
<span class="gi">+        yield line</span>


<span class="gd">-def match_pattern(path: bytes, pattern: bytes, ignorecase: bool=False) -&gt;bool:</span>
<span class="gi">+def match_pattern(path: bytes, pattern: bytes, ignorecase: bool = False) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Match a gitignore-style pattern against a path.

<span class="w"> </span>    Args:
<span class="gu">@@ -42,20 +142,20 @@ def match_pattern(path: bytes, pattern: bytes, ignorecase: bool=False) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      bool indicating whether the pattern matched
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Pattern(pattern, ignorecase).match(path)</span>


<span class="w"> </span>class Pattern:
<span class="w"> </span>    &quot;&quot;&quot;A single ignore pattern.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, pattern: bytes, ignorecase: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, pattern: bytes, ignorecase: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.pattern = pattern
<span class="w"> </span>        self.ignorecase = ignorecase
<span class="gd">-        if pattern[0:1] == b&#39;!&#39;:</span>
<span class="gi">+        if pattern[0:1] == b&quot;!&quot;:</span>
<span class="w"> </span>            self.is_exclude = False
<span class="w"> </span>            pattern = pattern[1:]
<span class="w"> </span>        else:
<span class="gd">-            if pattern[0:1] == b&#39;\\&#39;:</span>
<span class="gi">+            if pattern[0:1] == b&quot;\\&quot;:</span>
<span class="w"> </span>                pattern = pattern[1:]
<span class="w"> </span>            self.is_exclude = True
<span class="w"> </span>        flags = 0
<span class="gu">@@ -63,44 +163,47 @@ class Pattern:</span>
<span class="w"> </span>            flags = re.IGNORECASE
<span class="w"> </span>        self._re = re.compile(translate(pattern), flags)

<span class="gd">-    def __bytes__(self) -&gt;bytes:</span>
<span class="gi">+    def __bytes__(self) -&gt; bytes:</span>
<span class="w"> </span>        return self.pattern

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return os.fsdecode(self.pattern)

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gd">-        return (isinstance(other, type(self)) and self.pattern == other.</span>
<span class="gd">-            pattern and self.ignorecase == other.ignorecase)</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(other, type(self))</span>
<span class="gi">+            and self.pattern == other.pattern</span>
<span class="gi">+            and self.ignorecase == other.ignorecase</span>
<span class="gi">+        )</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{type(self).__name__}({self.pattern!r}, {self.ignorecase!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({self.pattern!r}, {self.ignorecase!r})&quot;</span>

<span class="gd">-    def match(self, path: bytes) -&gt;bool:</span>
<span class="gi">+    def match(self, path: bytes) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to match a path against this ignore pattern.

<span class="w"> </span>        Args:
<span class="w"> </span>          path: Path to match (relative to ignore location)
<span class="w"> </span>        Returns: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._re.match(path))</span>


<span class="w"> </span>class IgnoreFilter:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, patterns: Iterable[bytes], ignorecase: bool=False,</span>
<span class="gd">-        path=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, patterns: Iterable[bytes], ignorecase: bool = False, path=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._patterns: List[Pattern] = []
<span class="w"> </span>        self._ignorecase = ignorecase
<span class="w"> </span>        self._path = path
<span class="w"> </span>        for pattern in patterns:
<span class="w"> </span>            self.append_pattern(pattern)

<span class="gd">-    def append_pattern(self, pattern: bytes) -&gt;None:</span>
<span class="gi">+    def append_pattern(self, pattern: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a pattern to the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._patterns.append(Pattern(pattern, self._ignorecase))</span>

<span class="gd">-    def find_matching(self, path: Union[bytes, str]) -&gt;Iterable[Pattern]:</span>
<span class="gi">+    def find_matching(self, path: Union[bytes, str]) -&gt; Iterable[Pattern]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield all matching patterns for path.

<span class="w"> </span>        Args:
<span class="gu">@@ -108,9 +211,13 @@ class IgnoreFilter:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          Iterator over iterators
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(path, bytes):</span>
<span class="gi">+            path = os.fsencode(path)</span>
<span class="gi">+        for pattern in self._patterns:</span>
<span class="gi">+            if pattern.match(path):</span>
<span class="gi">+                yield pattern</span>

<span class="gd">-    def is_ignored(self, path: bytes) -&gt;Optional[bool]:</span>
<span class="gi">+    def is_ignored(self, path: bytes) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a path is ignored.

<span class="w"> </span>        For directories, include a trailing slash.
<span class="gu">@@ -118,23 +225,31 @@ class IgnoreFilter:</span>
<span class="w"> </span>        Returns: status is None if file is not mentioned, True if it is
<span class="w"> </span>            included, False if it is explicitly excluded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        status = None</span>
<span class="gi">+        for pattern in self.find_matching(path):</span>
<span class="gi">+            status = pattern.is_exclude</span>
<span class="gi">+        return status</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path, ignorecase: bool = False) -&gt; &quot;IgnoreFilter&quot;:</span>
<span class="gi">+        with open(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            return cls(read_ignore_patterns(f), ignorecase, path=path)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        path = getattr(self, &#39;_path&#39;, None)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        path = getattr(self, &quot;_path&quot;, None)</span>
<span class="w"> </span>        if path is not None:
<span class="gd">-            return f&#39;{type(self).__name__}.from_path({path!r})&#39;</span>
<span class="gi">+            return f&quot;{type(self).__name__}.from_path({path!r})&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            return f&#39;&lt;{type(self).__name__}&gt;&#39;</span>
<span class="gi">+            return f&quot;&lt;{type(self).__name__}&gt;&quot;</span>


<span class="w"> </span>class IgnoreFilterStack:
<span class="w"> </span>    &quot;&quot;&quot;Check for ignore status in multiple filters.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, filters) -&gt;None:</span>
<span class="gi">+    def __init__(self, filters) -&gt; None:</span>
<span class="w"> </span>        self._filters = filters

<span class="gd">-    def is_ignored(self, path: str) -&gt;Optional[bool]:</span>
<span class="gi">+    def is_ignored(self, path: str) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a path is explicitly included or excluded in ignores.

<span class="w"> </span>        Args:
<span class="gu">@@ -143,10 +258,15 @@ class IgnoreFilterStack:</span>
<span class="w"> </span>          None if the file is not mentioned, True if it is included,
<span class="w"> </span>          False if it is explicitly excluded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        status = None</span>
<span class="gi">+        for filter in self._filters:</span>
<span class="gi">+            status = filter.is_ignored(path)</span>
<span class="gi">+            if status is not None:</span>
<span class="gi">+                return status</span>
<span class="gi">+        return status</span>


<span class="gd">-def default_user_ignore_filter_path(config: Config) -&gt;str:</span>
<span class="gi">+def default_user_ignore_filter_path(config: Config) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return default user ignore filter path.

<span class="w"> </span>    Args:
<span class="gu">@@ -154,25 +274,47 @@ def default_user_ignore_filter_path(config: Config) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Path to a global ignore file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        value = config.get((b&quot;core&quot;,), b&quot;excludesFile&quot;)</span>
<span class="gi">+        assert isinstance(value, bytes)</span>
<span class="gi">+        return value.decode(encoding=&quot;utf-8&quot;)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return get_xdg_config_home_path(&quot;git&quot;, &quot;ignore&quot;)</span>


<span class="w"> </span>class IgnoreFilterManager:
<span class="w"> </span>    &quot;&quot;&quot;Ignore file manager.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, top_path: str, global_filters: List[IgnoreFilter],</span>
<span class="gd">-        ignorecase: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        top_path: str,</span>
<span class="gi">+        global_filters: List[IgnoreFilter],</span>
<span class="gi">+        ignorecase: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._path_filters: Dict[str, Optional[IgnoreFilter]] = {}
<span class="w"> </span>        self._top_path = top_path
<span class="w"> </span>        self._global_filters = global_filters
<span class="w"> </span>        self._ignorecase = ignorecase

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{type(self).__name__}({self._top_path}, {self._global_filters!r}, {self._ignorecase!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{type(self).__name__}({self._top_path}, {self._global_filters!r}, {self._ignorecase!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _load_path(self, path: str) -&gt; Optional[IgnoreFilter]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._path_filters[path]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        p = os.path.join(self._top_path, path, &quot;.gitignore&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._path_filters[path] = IgnoreFilter.from_path(p, self._ignorecase)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            self._path_filters[path] = None</span>
<span class="gi">+        return self._path_filters[path]</span>

<span class="gd">-    def find_matching(self, path: str) -&gt;Iterable[Pattern]:</span>
<span class="gi">+    def find_matching(self, path: str) -&gt; Iterable[Pattern]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find matching patterns for path.

<span class="w"> </span>        Args:
<span class="gu">@@ -180,9 +322,28 @@ class IgnoreFilterManager:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          Iterator over Pattern instances
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def is_ignored(self, path: str) -&gt;Optional[bool]:</span>
<span class="gi">+        if os.path.isabs(path):</span>
<span class="gi">+            raise ValueError(f&quot;{path} is an absolute path&quot;)</span>
<span class="gi">+        filters = [(0, f) for f in self._global_filters]</span>
<span class="gi">+        if os.path.sep != &quot;/&quot;:</span>
<span class="gi">+            path = path.replace(os.path.sep, &quot;/&quot;)</span>
<span class="gi">+        parts = path.split(&quot;/&quot;)</span>
<span class="gi">+        matches = []</span>
<span class="gi">+        for i in range(len(parts) + 1):</span>
<span class="gi">+            dirname = &quot;/&quot;.join(parts[:i])</span>
<span class="gi">+            for s, f in filters:</span>
<span class="gi">+                relpath = &quot;/&quot;.join(parts[s:i])</span>
<span class="gi">+                if i &lt; len(parts):</span>
<span class="gi">+                    # Paths leading up to the final part are all directories,</span>
<span class="gi">+                    # so need a trailing slash.</span>
<span class="gi">+                    relpath += &quot;/&quot;</span>
<span class="gi">+                matches += list(f.find_matching(relpath))</span>
<span class="gi">+            ignore_filter = self._load_path(dirname)</span>
<span class="gi">+            if ignore_filter is not None:</span>
<span class="gi">+                filters.insert(0, (i, ignore_filter))</span>
<span class="gi">+        return iter(matches)</span>
<span class="gi">+</span>
<span class="gi">+    def is_ignored(self, path: str) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a path is explicitly included or excluded in ignores.

<span class="w"> </span>        Args:
<span class="gu">@@ -191,10 +352,13 @@ class IgnoreFilterManager:</span>
<span class="w"> </span>          None if the file is not mentioned, True if it is included,
<span class="w"> </span>          False if it is explicitly excluded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = list(self.find_matching(path))</span>
<span class="gi">+        if matches:</span>
<span class="gi">+            return matches[-1].is_exclude</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_repo(cls, repo: &#39;Repo&#39;) -&gt;&#39;IgnoreFilterManager&#39;:</span>
<span class="gi">+    def from_repo(cls, repo: &quot;Repo&quot;) -&gt; &quot;IgnoreFilterManager&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a IgnoreFilterManager from a repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -202,4 +366,13 @@ class IgnoreFilterManager:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          A `IgnoreFilterManager` object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        global_filters = []</span>
<span class="gi">+        for p in [</span>
<span class="gi">+            os.path.join(repo.controldir(), &quot;info&quot;, &quot;exclude&quot;),</span>
<span class="gi">+            default_user_ignore_filter_path(repo.get_config_stack()),</span>
<span class="gi">+        ]:</span>
<span class="gi">+            with suppress(OSError):</span>
<span class="gi">+                global_filters.append(IgnoreFilter.from_path(os.path.expanduser(p)))</span>
<span class="gi">+        config = repo.get_config_stack()</span>
<span class="gi">+        ignorecase = config.get_boolean((b&quot;core&quot;), (b&quot;ignorecase&quot;), False)</span>
<span class="gi">+        return cls(repo.path, global_filters, ignorecase)</span>
<span class="gh">diff --git a/dulwich/index.py b/dulwich/index.py</span>
<span class="gh">index 092ea76c..f3b3f24f 100644</span>
<span class="gd">--- a/dulwich/index.py</span>
<span class="gi">+++ b/dulwich/index.py</span>
<span class="gu">@@ -1,22 +1,74 @@</span>
<span class="gi">+# index.py -- File parser/writer for the git index file</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Parser for the git index file format.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import stat
<span class="w"> </span>import struct
<span class="w"> </span>import sys
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from enum import Enum
<span class="gd">-from typing import Any, BinaryIO, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Any,</span>
<span class="gi">+    BinaryIO,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .file import GitFile
<span class="w"> </span>from .object_store import iter_tree_contents
<span class="gd">-from .objects import S_IFGITLINK, S_ISGITLINK, Blob, ObjectID, Tree, hex_to_sha, sha_to_hex</span>
<span class="gi">+from .objects import (</span>
<span class="gi">+    S_IFGITLINK,</span>
<span class="gi">+    S_ISGITLINK,</span>
<span class="gi">+    Blob,</span>
<span class="gi">+    ObjectID,</span>
<span class="gi">+    Tree,</span>
<span class="gi">+    hex_to_sha,</span>
<span class="gi">+    sha_to_hex,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .pack import ObjectContainer, SHA1Reader, SHA1Writer
<span class="gd">-FLAG_STAGEMASK = 12288</span>
<span class="gi">+</span>
<span class="gi">+# 2-bit stage (during merge)</span>
<span class="gi">+FLAG_STAGEMASK = 0x3000</span>
<span class="w"> </span>FLAG_STAGESHIFT = 12
<span class="gd">-FLAG_NAMEMASK = 4095</span>
<span class="gd">-FLAG_VALID = 32768</span>
<span class="gd">-FLAG_EXTENDED = 16384</span>
<span class="gd">-EXTENDED_FLAG_SKIP_WORKTREE = 16384</span>
<span class="gd">-EXTENDED_FLAG_INTEND_TO_ADD = 8192</span>
<span class="gi">+FLAG_NAMEMASK = 0x0FFF</span>
<span class="gi">+</span>
<span class="gi">+# assume-valid</span>
<span class="gi">+FLAG_VALID = 0x8000</span>
<span class="gi">+</span>
<span class="gi">+# extended flag (must be zero in version 2)</span>
<span class="gi">+FLAG_EXTENDED = 0x4000</span>
<span class="gi">+</span>
<span class="gi">+# used by sparse checkout</span>
<span class="gi">+EXTENDED_FLAG_SKIP_WORKTREE = 0x4000</span>
<span class="gi">+</span>
<span class="gi">+# used by &quot;git add -N&quot;</span>
<span class="gi">+EXTENDED_FLAG_INTEND_TO_ADD = 0x2000</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_VERSION = 2


<span class="gu">@@ -42,6 +94,9 @@ class SerializedIndexEntry:</span>
<span class="w"> </span>    flags: int
<span class="w"> </span>    extended_flags: int

<span class="gi">+    def stage(self) -&gt; Stage:</span>
<span class="gi">+        return Stage((self.flags &amp; FLAG_STAGEMASK) &gt;&gt; FLAG_STAGESHIFT)</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass
<span class="w"> </span>class IndexEntry:
<span class="gu">@@ -55,15 +110,50 @@ class IndexEntry:</span>
<span class="w"> </span>    size: int
<span class="w"> </span>    sha: bytes

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_serialized(cls, serialized: SerializedIndexEntry) -&gt; &quot;IndexEntry&quot;:</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            ctime=serialized.ctime,</span>
<span class="gi">+            mtime=serialized.mtime,</span>
<span class="gi">+            dev=serialized.dev,</span>
<span class="gi">+            ino=serialized.ino,</span>
<span class="gi">+            mode=serialized.mode,</span>
<span class="gi">+            uid=serialized.uid,</span>
<span class="gi">+            gid=serialized.gid,</span>
<span class="gi">+            size=serialized.size,</span>
<span class="gi">+            sha=serialized.sha,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def serialize(self, name: bytes, stage: Stage) -&gt; SerializedIndexEntry:</span>
<span class="gi">+        return SerializedIndexEntry(</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            ctime=self.ctime,</span>
<span class="gi">+            mtime=self.mtime,</span>
<span class="gi">+            dev=self.dev,</span>
<span class="gi">+            ino=self.ino,</span>
<span class="gi">+            mode=self.mode,</span>
<span class="gi">+            uid=self.uid,</span>
<span class="gi">+            gid=self.gid,</span>
<span class="gi">+            size=self.size,</span>
<span class="gi">+            sha=self.sha,</span>
<span class="gi">+            flags=stage.value &lt;&lt; FLAG_STAGESHIFT,</span>
<span class="gi">+            extended_flags=0,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class ConflictedIndexEntry:
<span class="w"> </span>    &quot;&quot;&quot;Index entry that represents a conflict.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ancestor: Optional[IndexEntry]
<span class="w"> </span>    this: Optional[IndexEntry]
<span class="w"> </span>    other: Optional[IndexEntry]

<span class="gd">-    def __init__(self, ancestor: Optional[IndexEntry]=None, this: Optional[</span>
<span class="gd">-        IndexEntry]=None, other: Optional[IndexEntry]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ancestor: Optional[IndexEntry] = None,</span>
<span class="gi">+        this: Optional[IndexEntry] = None,</span>
<span class="gi">+        other: Optional[IndexEntry] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.ancestor = ancestor
<span class="w"> </span>        self.this = this
<span class="w"> </span>        self.other = other
<span class="gu">@@ -73,7 +163,7 @@ class UnmergedEntries(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;Unmerged entries exist in the index.&quot;&quot;&quot;


<span class="gd">-def pathsplit(path: bytes) -&gt;Tuple[bytes, bytes]:</span>
<span class="gi">+def pathsplit(path: bytes) -&gt; Tuple[bytes, bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split a /-delimited path into a directory part and a basename.

<span class="w"> </span>    Args:
<span class="gu">@@ -82,12 +172,17 @@ def pathsplit(path: bytes) -&gt;Tuple[bytes, bytes]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Tuple with directory name and basename
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        (dirname, basename) = path.rsplit(b&quot;/&quot;, 1)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return (b&quot;&quot;, path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (dirname, basename)</span>


<span class="w"> </span>def pathjoin(*args):
<span class="w"> </span>    &quot;&quot;&quot;Join a /-delimited path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return b&quot;/&quot;.join([p for p in args if p])</span>


<span class="w"> </span>def read_cache_time(f):
<span class="gu">@@ -98,7 +193,7 @@ def read_cache_time(f):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Tuple with seconds and nanoseconds
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return struct.unpack(&quot;&gt;LL&quot;, f.read(8))</span>


<span class="w"> </span>def write_cache_time(f, t):
<span class="gu">@@ -108,52 +203,145 @@ def write_cache_time(f, t):</span>
<span class="w"> </span>      f: File-like object to write to
<span class="w"> </span>      t: Time to write (as int, float or tuple with secs and nsecs)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(t, int):</span>
<span class="gi">+        t = (t, 0)</span>
<span class="gi">+    elif isinstance(t, float):</span>
<span class="gi">+        (secs, nsecs) = divmod(t, 1.0)</span>
<span class="gi">+        t = (int(secs), int(nsecs * 1000000000))</span>
<span class="gi">+    elif not isinstance(t, tuple):</span>
<span class="gi">+        raise TypeError(t)</span>
<span class="gi">+    f.write(struct.pack(&quot;&gt;LL&quot;, *t))</span>


<span class="gd">-def read_cache_entry(f, version: int) -&gt;SerializedIndexEntry:</span>
<span class="gi">+def read_cache_entry(f, version: int) -&gt; SerializedIndexEntry:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read an entry from a cache file.

<span class="w"> </span>    Args:
<span class="w"> </span>      f: File-like object to read from
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_cache_entry(f, entry: SerializedIndexEntry, version: int) -&gt;None:</span>
<span class="gi">+    beginoffset = f.tell()</span>
<span class="gi">+    ctime = read_cache_time(f)</span>
<span class="gi">+    mtime = read_cache_time(f)</span>
<span class="gi">+    (</span>
<span class="gi">+        dev,</span>
<span class="gi">+        ino,</span>
<span class="gi">+        mode,</span>
<span class="gi">+        uid,</span>
<span class="gi">+        gid,</span>
<span class="gi">+        size,</span>
<span class="gi">+        sha,</span>
<span class="gi">+        flags,</span>
<span class="gi">+    ) = struct.unpack(&quot;&gt;LLLLLL20sH&quot;, f.read(20 + 4 * 6 + 2))</span>
<span class="gi">+    if flags &amp; FLAG_EXTENDED:</span>
<span class="gi">+        if version &lt; 3:</span>
<span class="gi">+            raise AssertionError(&quot;extended flag set in index with version &lt; 3&quot;)</span>
<span class="gi">+        (extended_flags,) = struct.unpack(&quot;&gt;H&quot;, f.read(2))</span>
<span class="gi">+    else:</span>
<span class="gi">+        extended_flags = 0</span>
<span class="gi">+    name = f.read(flags &amp; FLAG_NAMEMASK)</span>
<span class="gi">+    # Padding:</span>
<span class="gi">+    if version &lt; 4:</span>
<span class="gi">+        real_size = (f.tell() - beginoffset + 8) &amp; ~7</span>
<span class="gi">+        f.read((beginoffset + real_size) - f.tell())</span>
<span class="gi">+    return SerializedIndexEntry(</span>
<span class="gi">+        name,</span>
<span class="gi">+        ctime,</span>
<span class="gi">+        mtime,</span>
<span class="gi">+        dev,</span>
<span class="gi">+        ino,</span>
<span class="gi">+        mode,</span>
<span class="gi">+        uid,</span>
<span class="gi">+        gid,</span>
<span class="gi">+        size,</span>
<span class="gi">+        sha_to_hex(sha),</span>
<span class="gi">+        flags &amp; ~FLAG_NAMEMASK,</span>
<span class="gi">+        extended_flags,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_cache_entry(f, entry: SerializedIndexEntry, version: int) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write an index entry to a file.

<span class="w"> </span>    Args:
<span class="w"> </span>      f: File object
<span class="w"> </span>      entry: IndexEntry to write, tuple with:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    beginoffset = f.tell()</span>
<span class="gi">+    write_cache_time(f, entry.ctime)</span>
<span class="gi">+    write_cache_time(f, entry.mtime)</span>
<span class="gi">+    flags = len(entry.name) | (entry.flags &amp; ~FLAG_NAMEMASK)</span>
<span class="gi">+    if entry.extended_flags:</span>
<span class="gi">+        flags |= FLAG_EXTENDED</span>
<span class="gi">+    if flags &amp; FLAG_EXTENDED and version is not None and version &lt; 3:</span>
<span class="gi">+        raise AssertionError(&quot;unable to use extended flags in version &lt; 3&quot;)</span>
<span class="gi">+    f.write(</span>
<span class="gi">+        struct.pack(</span>
<span class="gi">+            b&quot;&gt;LLLLLL20sH&quot;,</span>
<span class="gi">+            entry.dev &amp; 0xFFFFFFFF,</span>
<span class="gi">+            entry.ino &amp; 0xFFFFFFFF,</span>
<span class="gi">+            entry.mode,</span>
<span class="gi">+            entry.uid,</span>
<span class="gi">+            entry.gid,</span>
<span class="gi">+            entry.size,</span>
<span class="gi">+            hex_to_sha(entry.sha),</span>
<span class="gi">+            flags,</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    if flags &amp; FLAG_EXTENDED:</span>
<span class="gi">+        f.write(struct.pack(b&quot;&gt;H&quot;, entry.extended_flags))</span>
<span class="gi">+    f.write(entry.name)</span>
<span class="gi">+    if version &lt; 4:</span>
<span class="gi">+        real_size = (f.tell() - beginoffset + 8) &amp; ~7</span>
<span class="gi">+        f.write(b&quot;\0&quot; * ((beginoffset + real_size) - f.tell()))</span>


<span class="w"> </span>class UnsupportedIndexFormat(Exception):
<span class="w"> </span>    &quot;&quot;&quot;An unsupported index format was encountered.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, version) -&gt;None:</span>
<span class="gi">+    def __init__(self, version) -&gt; None:</span>
<span class="w"> </span>        self.index_format_version = version


<span class="gd">-def read_index(f: BinaryIO) -&gt;Iterator[SerializedIndexEntry]:</span>
<span class="gi">+def read_index(f: BinaryIO) -&gt; Iterator[SerializedIndexEntry]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read an index file, yielding the individual entries.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    header = f.read(4)</span>
<span class="gi">+    if header != b&quot;DIRC&quot;:</span>
<span class="gi">+        raise AssertionError(f&quot;Invalid index file header: {header!r}&quot;)</span>
<span class="gi">+    (version, num_entries) = struct.unpack(b&quot;&gt;LL&quot;, f.read(4 * 2))</span>
<span class="gi">+    if version not in (1, 2, 3):</span>
<span class="gi">+        raise UnsupportedIndexFormat(version)</span>
<span class="gi">+    for i in range(num_entries):</span>
<span class="gi">+        yield read_cache_entry(f, version)</span>


<span class="gd">-def read_index_dict(f) -&gt;Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]]:</span>
<span class="gi">+def read_index_dict(f) -&gt; Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read an index file and return it as a dictionary.
<span class="w"> </span>       Dict Key is tuple of path and stage number, as
<span class="w"> </span>            path alone is not unique
<span class="w"> </span>    Args:
<span class="w"> </span>      f: File object to read fromls.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_index(f: BinaryIO, entries: List[SerializedIndexEntry], version:</span>
<span class="gd">-    Optional[int]=None):</span>
<span class="gi">+    ret: Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]] = {}</span>
<span class="gi">+    for entry in read_index(f):</span>
<span class="gi">+        stage = entry.stage()</span>
<span class="gi">+        if stage == Stage.NORMAL:</span>
<span class="gi">+            ret[entry.name] = IndexEntry.from_serialized(entry)</span>
<span class="gi">+        else:</span>
<span class="gi">+            existing = ret.setdefault(entry.name, ConflictedIndexEntry())</span>
<span class="gi">+            if isinstance(existing, IndexEntry):</span>
<span class="gi">+                raise AssertionError(f&quot;Non-conflicted entry for {entry.name!r} exists&quot;)</span>
<span class="gi">+            if stage == Stage.MERGE_CONFLICT_ANCESTOR:</span>
<span class="gi">+                existing.ancestor = IndexEntry.from_serialized(entry)</span>
<span class="gi">+            elif stage == Stage.MERGE_CONFLICT_THIS:</span>
<span class="gi">+                existing.this = IndexEntry.from_serialized(entry)</span>
<span class="gi">+            elif stage == Stage.MERGE_CONFLICT_OTHER:</span>
<span class="gi">+                existing.other = IndexEntry.from_serialized(entry)</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_index(</span>
<span class="gi">+    f: BinaryIO, entries: List[SerializedIndexEntry], version: Optional[int] = None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write an index file.

<span class="w"> </span>    Args:
<span class="gu">@@ -161,18 +349,44 @@ def write_index(f: BinaryIO, entries: List[SerializedIndexEntry], version:</span>
<span class="w"> </span>      version: Version number to write
<span class="w"> </span>      entries: Iterable over the entries to write
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_index_dict(f: BinaryIO, entries: Dict[bytes, Union[IndexEntry,</span>
<span class="gd">-    ConflictedIndexEntry]], version: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        version = DEFAULT_VERSION</span>
<span class="gi">+    f.write(b&quot;DIRC&quot;)</span>
<span class="gi">+    f.write(struct.pack(b&quot;&gt;LL&quot;, version, len(entries)))</span>
<span class="gi">+    for entry in entries:</span>
<span class="gi">+        write_cache_entry(f, entry, version)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_index_dict(</span>
<span class="gi">+    f: BinaryIO,</span>
<span class="gi">+    entries: Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]],</span>
<span class="gi">+    version: Optional[int] = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write an index file based on the contents of a dictionary.
<span class="w"> </span>    being careful to sort by path and then by stage.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    entries_list = []</span>
<span class="gi">+    for key in sorted(entries):</span>
<span class="gi">+        value = entries[key]</span>
<span class="gi">+        if isinstance(value, ConflictedIndexEntry):</span>
<span class="gi">+            if value.ancestor is not None:</span>
<span class="gi">+                entries_list.append(</span>
<span class="gi">+                    value.ancestor.serialize(key, Stage.MERGE_CONFLICT_ANCESTOR)</span>
<span class="gi">+                )</span>
<span class="gi">+            if value.this is not None:</span>
<span class="gi">+                entries_list.append(</span>
<span class="gi">+                    value.this.serialize(key, Stage.MERGE_CONFLICT_THIS)</span>
<span class="gi">+                )</span>
<span class="gi">+            if value.other is not None:</span>
<span class="gi">+                entries_list.append(</span>
<span class="gi">+                    value.other.serialize(key, Stage.MERGE_CONFLICT_OTHER)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            entries_list.append(value.serialize(key, Stage.NORMAL))</span>
<span class="gi">+    write_index(f, entries_list, version=version)</span>


<span class="gd">-def cleanup_mode(mode: int) -&gt;int:</span>
<span class="gi">+def cleanup_mode(mode: int) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Cleanup a mode value.

<span class="w"> </span>    This will return a mode that can be stored in a tree object.
<span class="gu">@@ -183,14 +397,24 @@ def cleanup_mode(mode: int) -&gt;int:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      mode
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stat.S_ISLNK(mode):</span>
<span class="gi">+        return stat.S_IFLNK</span>
<span class="gi">+    elif stat.S_ISDIR(mode):</span>
<span class="gi">+        return stat.S_IFDIR</span>
<span class="gi">+    elif S_ISGITLINK(mode):</span>
<span class="gi">+        return S_IFGITLINK</span>
<span class="gi">+    ret = stat.S_IFREG | 0o644</span>
<span class="gi">+    if mode &amp; 0o100:</span>
<span class="gi">+        ret |= 0o111</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>class Index:
<span class="w"> </span>    &quot;&quot;&quot;A Git Index file.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _byname: Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]]

<span class="gd">-    def __init__(self, filename: Union[bytes, str], read=True) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: Union[bytes, str], read=True) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an index object associated with the given filename.

<span class="w"> </span>        Args:
<span class="gu">@@ -198,28 +422,47 @@ class Index:</span>
<span class="w"> </span>          read: Whether to initialize the index from the given file, should it exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._filename = filename
<span class="gi">+        # TODO(jelmer): Store the version returned by read_index</span>
<span class="w"> </span>        self._version = None
<span class="w"> </span>        self.clear()
<span class="w"> </span>        if read:
<span class="w"> </span>            self.read()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._filename!r})&#39;</span>
<span class="gi">+    @property</span>
<span class="gi">+    def path(self):</span>
<span class="gi">+        return self._filename</span>

<span class="gd">-    def write(self) -&gt;None:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._filename!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def write(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write current contents of index to disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = GitFile(self._filename, &quot;wb&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = SHA1Writer(f)</span>
<span class="gi">+            write_index_dict(f, self._byname, version=self._version)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            f.close()</span>

<span class="w"> </span>    def read(self):
<span class="w"> </span>        &quot;&quot;&quot;Read current contents of index from disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not os.path.exists(self._filename):</span>
<span class="gi">+            return</span>
<span class="gi">+        f = GitFile(self._filename, &quot;rb&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = SHA1Reader(f)</span>
<span class="gi">+            self.update(read_index_dict(f))</span>
<span class="gi">+            # FIXME: Additional data?</span>
<span class="gi">+            f.read(os.path.getsize(self._filename) - f.tell() - 20)</span>
<span class="gi">+            f.check_sha()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            f.close()</span>

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of entries in this index file.&quot;&quot;&quot;
<span class="w"> </span>        return len(self._byname)

<span class="gd">-    def __getitem__(self, key: bytes) -&gt;Union[IndexEntry, ConflictedIndexEntry</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def __getitem__(self, key: bytes) -&gt; Union[IndexEntry, ConflictedIndexEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve entry by relative path and stage.

<span class="w"> </span>        Returns: Either a IndexEntry or a ConflictedIndexEntry
<span class="gu">@@ -227,39 +470,72 @@ class Index:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self._byname[key]

<span class="gd">-    def __iter__(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the paths and stages in this index.&quot;&quot;&quot;
<span class="w"> </span>        return iter(self._byname)

<span class="w"> </span>    def __contains__(self, key):
<span class="w"> </span>        return key in self._byname

<span class="gd">-    def get_sha1(self, path: bytes) -&gt;bytes:</span>
<span class="gi">+    def get_sha1(self, path: bytes) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the (git object) SHA1 for the object at a path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self[path]</span>
<span class="gi">+        if isinstance(value, ConflictedIndexEntry):</span>
<span class="gi">+            raise UnmergedEntries</span>
<span class="gi">+        return value.sha</span>

<span class="gd">-    def get_mode(self, path: bytes) -&gt;int:</span>
<span class="gi">+    def get_mode(self, path: bytes) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the POSIX file mode for the object at a path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self[path]</span>
<span class="gi">+        if isinstance(value, ConflictedIndexEntry):</span>
<span class="gi">+            raise UnmergedEntries</span>
<span class="gi">+        return value.mode</span>

<span class="gd">-    def iterobjects(self) -&gt;Iterable[Tuple[bytes, bytes, int]]:</span>
<span class="gi">+    def iterobjects(self) -&gt; Iterable[Tuple[bytes, bytes, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over path, sha, mode tuples for use with commit_tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for path in self:</span>
<span class="gi">+            entry = self[path]</span>
<span class="gi">+            if isinstance(entry, ConflictedIndexEntry):</span>
<span class="gi">+                raise UnmergedEntries</span>
<span class="gi">+            yield path, entry.sha, cleanup_mode(entry.mode)</span>
<span class="gi">+</span>
<span class="gi">+    def has_conflicts(self) -&gt; bool:</span>
<span class="gi">+        for value in self._byname.values():</span>
<span class="gi">+            if isinstance(value, ConflictedIndexEntry):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all contents from this index.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._byname = {}</span>

<span class="gd">-    def __setitem__(self, name: bytes, value: Union[IndexEntry,</span>
<span class="gd">-        ConflictedIndexEntry]) -&gt;None:</span>
<span class="gi">+    def __setitem__(</span>
<span class="gi">+        self, name: bytes, value: Union[IndexEntry, ConflictedIndexEntry]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(name, bytes)
<span class="w"> </span>        self._byname[name] = value

<span class="gd">-    def __delitem__(self, name: bytes) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name: bytes) -&gt; None:</span>
<span class="w"> </span>        del self._byname[name]

<span class="gd">-    def changes_from_tree(self, object_store, tree: ObjectID,</span>
<span class="gd">-        want_unchanged: bool=False):</span>
<span class="gi">+    def iteritems(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Iterator[Tuple[bytes, Union[IndexEntry, ConflictedIndexEntry]]]:</span>
<span class="gi">+        return iter(self._byname.items())</span>
<span class="gi">+</span>
<span class="gi">+    def items(self) -&gt; Iterator[Tuple[bytes, Union[IndexEntry, ConflictedIndexEntry]]]:</span>
<span class="gi">+        return iter(self._byname.items())</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, entries: Dict[bytes, Union[IndexEntry, ConflictedIndexEntry]]):</span>
<span class="gi">+        for key, value in entries.items():</span>
<span class="gi">+            self[key] = value</span>
<span class="gi">+</span>
<span class="gi">+    def paths(self):</span>
<span class="gi">+        yield from self._byname.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def changes_from_tree(</span>
<span class="gi">+        self, object_store, tree: ObjectID, want_unchanged: bool = False</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the differences between the contents of this index and a tree.

<span class="w"> </span>        Args:
<span class="gu">@@ -269,7 +545,18 @@ class Index:</span>
<span class="w"> </span>        Returns: Iterator over tuples with (oldpath, newpath), (oldmode,
<span class="w"> </span>            newmode), (oldsha, newsha)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def lookup_entry(path):</span>
<span class="gi">+            entry = self[path]</span>
<span class="gi">+            return entry.sha, cleanup_mode(entry.mode)</span>
<span class="gi">+</span>
<span class="gi">+        yield from changes_from_tree(</span>
<span class="gi">+            self.paths(),</span>
<span class="gi">+            lookup_entry,</span>
<span class="gi">+            object_store,</span>
<span class="gi">+            tree,</span>
<span class="gi">+            want_unchanged=want_unchanged,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def commit(self, object_store):
<span class="w"> </span>        &quot;&quot;&quot;Create a new tree from an index.
<span class="gu">@@ -279,11 +566,12 @@ class Index:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          Root tree SHA
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return commit_tree(object_store, self.iterobjects())</span>


<span class="gd">-def commit_tree(object_store: ObjectContainer, blobs: Iterable[Tuple[bytes,</span>
<span class="gd">-    bytes, int]]) -&gt;bytes:</span>
<span class="gi">+def commit_tree(</span>
<span class="gi">+    object_store: ObjectContainer, blobs: Iterable[Tuple[bytes, bytes, int]]</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Commit a new tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -292,10 +580,40 @@ def commit_tree(object_store: ObjectContainer, blobs: Iterable[Tuple[bytes,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      SHA1 of the created tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def commit_index(object_store: ObjectContainer, index: Index) -&gt;bytes:</span>
<span class="gi">+    trees: Dict[bytes, Any] = {b&quot;&quot;: {}}</span>
<span class="gi">+</span>
<span class="gi">+    def add_tree(path):</span>
<span class="gi">+        if path in trees:</span>
<span class="gi">+            return trees[path]</span>
<span class="gi">+        dirname, basename = pathsplit(path)</span>
<span class="gi">+        t = add_tree(dirname)</span>
<span class="gi">+        assert isinstance(basename, bytes)</span>
<span class="gi">+        newtree = {}</span>
<span class="gi">+        t[basename] = newtree</span>
<span class="gi">+        trees[path] = newtree</span>
<span class="gi">+        return newtree</span>
<span class="gi">+</span>
<span class="gi">+    for path, sha, mode in blobs:</span>
<span class="gi">+        tree_path, basename = pathsplit(path)</span>
<span class="gi">+        tree = add_tree(tree_path)</span>
<span class="gi">+        tree[basename] = (mode, sha)</span>
<span class="gi">+</span>
<span class="gi">+    def build_tree(path):</span>
<span class="gi">+        tree = Tree()</span>
<span class="gi">+        for basename, entry in trees[path].items():</span>
<span class="gi">+            if isinstance(entry, dict):</span>
<span class="gi">+                mode = stat.S_IFDIR</span>
<span class="gi">+                sha = build_tree(pathjoin(path, basename))</span>
<span class="gi">+            else:</span>
<span class="gi">+                (mode, sha) = entry</span>
<span class="gi">+            tree.add(basename, mode, sha)</span>
<span class="gi">+        object_store.add_object(tree)</span>
<span class="gi">+        return tree.id</span>
<span class="gi">+</span>
<span class="gi">+    return build_tree(b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def commit_index(object_store: ObjectContainer, index: Index) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a new tree from an index.

<span class="w"> </span>    Args:
<span class="gu">@@ -304,14 +622,22 @@ def commit_index(object_store: ObjectContainer, index: Index) -&gt;bytes:</span>
<span class="w"> </span>    Note: This function is deprecated, use index.commit() instead.
<span class="w"> </span>    Returns: Root tree sha.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def changes_from_tree(names: Iterable[bytes], lookup_entry: Callable[[bytes</span>
<span class="gd">-    ], Tuple[bytes, int]], object_store: ObjectContainer, tree: Optional[</span>
<span class="gd">-    bytes], want_unchanged=False) -&gt;Iterable[Tuple[Tuple[Optional[bytes],</span>
<span class="gd">-    Optional[bytes]], Tuple[Optional[int], Optional[int]], Tuple[Optional[</span>
<span class="gd">-    bytes], Optional[bytes]]]]:</span>
<span class="gi">+    return commit_tree(object_store, index.iterobjects())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def changes_from_tree(</span>
<span class="gi">+    names: Iterable[bytes],</span>
<span class="gi">+    lookup_entry: Callable[[bytes], Tuple[bytes, int]],</span>
<span class="gi">+    object_store: ObjectContainer,</span>
<span class="gi">+    tree: Optional[bytes],</span>
<span class="gi">+    want_unchanged=False,</span>
<span class="gi">+) -&gt; Iterable[</span>
<span class="gi">+    Tuple[</span>
<span class="gi">+        Tuple[Optional[bytes], Optional[bytes]],</span>
<span class="gi">+        Tuple[Optional[int], Optional[int]],</span>
<span class="gi">+        Tuple[Optional[bytes], Optional[bytes]],</span>
<span class="gi">+    ]</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the differences between the contents of a tree and
<span class="w"> </span>    a working copy.

<span class="gu">@@ -324,34 +650,94 @@ def changes_from_tree(names: Iterable[bytes], lookup_entry: Callable[[bytes</span>
<span class="w"> </span>    Returns: Iterator over tuples with (oldpath, newpath), (oldmode, newmode),
<span class="w"> </span>        (oldsha, newsha)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO(jelmer): Support a include_trees option</span>
<span class="gi">+    other_names = set(names)</span>
<span class="gi">+</span>
<span class="gi">+    if tree is not None:</span>
<span class="gi">+        for name, mode, sha in iter_tree_contents(object_store, tree):</span>
<span class="gi">+            try:</span>
<span class="gi">+                (other_sha, other_mode) = lookup_entry(name)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # Was removed</span>
<span class="gi">+                yield ((name, None), (mode, None), (sha, None))</span>
<span class="gi">+            else:</span>
<span class="gi">+                other_names.remove(name)</span>
<span class="gi">+                if want_unchanged or other_sha != sha or other_mode != mode:</span>
<span class="gi">+                    yield ((name, name), (mode, other_mode), (sha, other_sha))</span>
<span class="gi">+</span>
<span class="gi">+    # Mention added files</span>
<span class="gi">+    for name in other_names:</span>
<span class="gi">+        try:</span>
<span class="gi">+            (other_sha, other_mode) = lookup_entry(name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield ((None, name), (None, other_mode), (None, other_sha))</span>


<span class="gd">-def index_entry_from_stat(stat_val, hex_sha: bytes, mode: Optional[int]=None):</span>
<span class="gi">+def index_entry_from_stat(</span>
<span class="gi">+    stat_val,</span>
<span class="gi">+    hex_sha: bytes,</span>
<span class="gi">+    mode: Optional[int] = None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a new index entry from a stat value.

<span class="w"> </span>    Args:
<span class="w"> </span>      stat_val: POSIX stat_result instance
<span class="w"> </span>      hex_sha: Hex sha of the object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mode is None:</span>
<span class="gi">+        mode = cleanup_mode(stat_val.st_mode)</span>

<span class="gi">+    return IndexEntry(</span>
<span class="gi">+        stat_val.st_ctime,</span>
<span class="gi">+        stat_val.st_mtime,</span>
<span class="gi">+        stat_val.st_dev,</span>
<span class="gi">+        stat_val.st_ino,</span>
<span class="gi">+        mode,</span>
<span class="gi">+        stat_val.st_uid,</span>
<span class="gi">+        stat_val.st_gid,</span>
<span class="gi">+        stat_val.st_size,</span>
<span class="gi">+        hex_sha,</span>
<span class="gi">+    )</span>

<span class="gd">-if sys.platform == &#39;win32&#39;:</span>

<span class="gi">+if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+    # On Windows, creating symlinks either requires administrator privileges</span>
<span class="gi">+    # or developer mode. Raise a more helpful error when we&#39;re unable to</span>
<span class="gi">+    # create symlinks</span>

<span class="gd">-    class WindowsSymlinkPermissionError(PermissionError):</span>
<span class="gi">+    # https://github.com/jelmer/dulwich/issues/1005</span>

<span class="gd">-        def __init__(self, errno, msg, filename) -&gt;None:</span>
<span class="gd">-            super(PermissionError, self).__init__(errno,</span>
<span class="gd">-                f&#39;Unable to create symlink; do you have developer mode enabled? {msg}&#39;</span>
<span class="gd">-                , filename)</span>
<span class="gi">+    class WindowsSymlinkPermissionError(PermissionError):</span>
<span class="gi">+        def __init__(self, errno, msg, filename) -&gt; None:</span>
<span class="gi">+            super(PermissionError, self).__init__(</span>
<span class="gi">+                errno,</span>
<span class="gi">+                &quot;Unable to create symlink; &quot;</span>
<span class="gi">+                f&quot;do you have developer mode enabled? {msg}&quot;,</span>
<span class="gi">+                filename,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def symlink(src, dst, target_is_directory=False, *, dir_fd=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return os.symlink(</span>
<span class="gi">+                src, dst, target_is_directory=target_is_directory, dir_fd=dir_fd</span>
<span class="gi">+            )</span>
<span class="gi">+        except PermissionError as e:</span>
<span class="gi">+            raise WindowsSymlinkPermissionError(e.errno, e.strerror, e.filename) from e</span>
<span class="w"> </span>else:
<span class="w"> </span>    symlink = os.symlink


<span class="gd">-def build_file_from_blob(blob: Blob, mode: int, target_path: bytes, *,</span>
<span class="gd">-    honor_filemode=True, tree_encoding=&#39;utf-8&#39;, symlink_fn=None):</span>
<span class="gi">+def build_file_from_blob(</span>
<span class="gi">+    blob: Blob,</span>
<span class="gi">+    mode: int,</span>
<span class="gi">+    target_path: bytes,</span>
<span class="gi">+    *,</span>
<span class="gi">+    honor_filemode=True,</span>
<span class="gi">+    tree_encoding=&quot;utf-8&quot;,</span>
<span class="gi">+    symlink_fn=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Build a file or symlink on disk based on a Git object.

<span class="w"> </span>    Args:
<span class="gu">@@ -363,22 +749,70 @@ def build_file_from_blob(blob: Blob, mode: int, target_path: bytes, *,</span>
<span class="w"> </span>      symlink: Function to use for creating symlinks
<span class="w"> </span>    Returns: stat object for the file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        oldstat = os.lstat(target_path)</span>
<span class="gi">+    except FileNotFoundError:</span>
<span class="gi">+        oldstat = None</span>
<span class="gi">+    contents = blob.as_raw_string()</span>
<span class="gi">+    if stat.S_ISLNK(mode):</span>
<span class="gi">+        if oldstat:</span>
<span class="gi">+            os.unlink(target_path)</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # os.readlink on Python3 on Windows requires a unicode string.</span>
<span class="gi">+            contents = contents.decode(tree_encoding)  # type: ignore</span>
<span class="gi">+            target_path = target_path.decode(tree_encoding)  # type: ignore</span>
<span class="gi">+        (symlink_fn or symlink)(contents, target_path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if oldstat is not None and oldstat.st_size == len(contents):</span>
<span class="gi">+            with open(target_path, &quot;rb&quot;) as f:</span>
<span class="gi">+                if f.read() == contents:</span>
<span class="gi">+                    return oldstat</span>

<span class="gi">+        with open(target_path, &quot;wb&quot;) as f:</span>
<span class="gi">+            # Write out file</span>
<span class="gi">+            f.write(contents)</span>

<span class="gd">-INVALID_DOTNAMES = b&#39;.git&#39;, b&#39;.&#39;, b&#39;..&#39;, b&#39;&#39;</span>
<span class="gi">+        if honor_filemode:</span>
<span class="gi">+            os.chmod(target_path, mode)</span>

<span class="gi">+    return os.lstat(target_path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+INVALID_DOTNAMES = (b&quot;.git&quot;, b&quot;.&quot;, b&quot;..&quot;, b&quot;&quot;)</span>

<span class="gd">-def validate_path(path: bytes, element_validator=validate_path_element_default</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Default path validator that just checks for .git/.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>

<span class="gi">+def validate_path_element_default(element: bytes) -&gt; bool:</span>
<span class="gi">+    return element.lower() not in INVALID_DOTNAMES</span>

<span class="gd">-def build_index_from_tree(root_path: Union[str, bytes], index_path: Union[</span>
<span class="gd">-    str, bytes], object_store: ObjectContainer, tree_id: bytes,</span>
<span class="gd">-    honor_filemode: bool=True, validate_path_element=</span>
<span class="gd">-    validate_path_element_default, symlink_fn=None):</span>
<span class="gi">+</span>
<span class="gi">+def validate_path_element_ntfs(element: bytes) -&gt; bool:</span>
<span class="gi">+    stripped = element.rstrip(b&quot;. &quot;).lower()</span>
<span class="gi">+    if stripped in INVALID_DOTNAMES:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if stripped == b&quot;git~1&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_path(path: bytes, element_validator=validate_path_element_default) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Default path validator that just checks for .git/.&quot;&quot;&quot;</span>
<span class="gi">+    parts = path.split(b&quot;/&quot;)</span>
<span class="gi">+    for p in parts:</span>
<span class="gi">+        if not element_validator(p):</span>
<span class="gi">+            return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def build_index_from_tree(</span>
<span class="gi">+    root_path: Union[str, bytes],</span>
<span class="gi">+    index_path: Union[str, bytes],</span>
<span class="gi">+    object_store: ObjectContainer,</span>
<span class="gi">+    tree_id: bytes,</span>
<span class="gi">+    honor_filemode: bool = True,</span>
<span class="gi">+    validate_path_element=validate_path_element_default,</span>
<span class="gi">+    symlink_fn=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate and materialize index from a tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -394,10 +828,61 @@ def build_index_from_tree(root_path: Union[str, bytes], index_path: Union[</span>
<span class="w"> </span>    Note: existing index is wiped and contents are not merged
<span class="w"> </span>        in a working dir. Suitable only for fresh clones.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def blob_from_path_and_mode(fs_path: bytes, mode: int, tree_encoding=&#39;utf-8&#39;):</span>
<span class="gi">+    index = Index(index_path, read=False)</span>
<span class="gi">+    if not isinstance(root_path, bytes):</span>
<span class="gi">+        root_path = os.fsencode(root_path)</span>
<span class="gi">+</span>
<span class="gi">+    for entry in iter_tree_contents(object_store, tree_id):</span>
<span class="gi">+        if not validate_path(entry.path, validate_path_element):</span>
<span class="gi">+            continue</span>
<span class="gi">+        full_path = _tree_to_fs_path(root_path, entry.path)</span>
<span class="gi">+</span>
<span class="gi">+        if not os.path.exists(os.path.dirname(full_path)):</span>
<span class="gi">+            os.makedirs(os.path.dirname(full_path))</span>
<span class="gi">+</span>
<span class="gi">+        # TODO(jelmer): Merge new index into working tree</span>
<span class="gi">+        if S_ISGITLINK(entry.mode):</span>
<span class="gi">+            if not os.path.isdir(full_path):</span>
<span class="gi">+                os.mkdir(full_path)</span>
<span class="gi">+            st = os.lstat(full_path)</span>
<span class="gi">+            # TODO(jelmer): record and return submodule paths</span>
<span class="gi">+        else:</span>
<span class="gi">+            obj = object_store[entry.sha]</span>
<span class="gi">+            assert isinstance(obj, Blob)</span>
<span class="gi">+            st = build_file_from_blob(</span>
<span class="gi">+                obj,</span>
<span class="gi">+                entry.mode,</span>
<span class="gi">+                full_path,</span>
<span class="gi">+                honor_filemode=honor_filemode,</span>
<span class="gi">+                symlink_fn=symlink_fn,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Add file to index</span>
<span class="gi">+        if not honor_filemode or S_ISGITLINK(entry.mode):</span>
<span class="gi">+            # we can not use tuple slicing to build a new tuple,</span>
<span class="gi">+            # because on windows that will convert the times to</span>
<span class="gi">+            # longs, which causes errors further along</span>
<span class="gi">+            st_tuple = (</span>
<span class="gi">+                entry.mode,</span>
<span class="gi">+                st.st_ino,</span>
<span class="gi">+                st.st_dev,</span>
<span class="gi">+                st.st_nlink,</span>
<span class="gi">+                st.st_uid,</span>
<span class="gi">+                st.st_gid,</span>
<span class="gi">+                st.st_size,</span>
<span class="gi">+                st.st_atime,</span>
<span class="gi">+                st.st_mtime,</span>
<span class="gi">+                st.st_ctime,</span>
<span class="gi">+            )</span>
<span class="gi">+            st = st.__class__(st_tuple)</span>
<span class="gi">+            # default to a stage 0 index entry (normal)</span>
<span class="gi">+            # when reading from the filesystem</span>
<span class="gi">+        index[entry.path] = index_entry_from_stat(st, entry.sha)</span>
<span class="gi">+</span>
<span class="gi">+    index.write()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def blob_from_path_and_mode(fs_path: bytes, mode: int, tree_encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a blob from a path and a stat object.

<span class="w"> </span>    Args:
<span class="gu">@@ -405,10 +890,21 @@ def blob_from_path_and_mode(fs_path: bytes, mode: int, tree_encoding=&#39;utf-8&#39;):</span>
<span class="w"> </span>      mode: File mode
<span class="w"> </span>    Returns: A `Blob` object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert isinstance(fs_path, bytes)</span>
<span class="gi">+    blob = Blob()</span>
<span class="gi">+    if stat.S_ISLNK(mode):</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # os.readlink on Python3 on Windows requires a unicode string.</span>
<span class="gi">+            blob.data = os.readlink(os.fsdecode(fs_path)).encode(tree_encoding)</span>
<span class="gi">+        else:</span>
<span class="gi">+            blob.data = os.readlink(fs_path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        with open(fs_path, &quot;rb&quot;) as f:</span>
<span class="gi">+            blob.data = f.read()</span>
<span class="gi">+    return blob</span>


<span class="gd">-def blob_from_path_and_stat(fs_path: bytes, st, tree_encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def blob_from_path_and_stat(fs_path: bytes, st, tree_encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a blob from a path and a stat object.

<span class="w"> </span>    Args:
<span class="gu">@@ -416,17 +912,31 @@ def blob_from_path_and_stat(fs_path: bytes, st, tree_encoding=&#39;utf-8&#39;):</span>
<span class="w"> </span>      st: A stat object
<span class="w"> </span>    Returns: A `Blob` object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return blob_from_path_and_mode(fs_path, st.st_mode, tree_encoding)</span>


<span class="gd">-def read_submodule_head(path: Union[str, bytes]) -&gt;Optional[bytes]:</span>
<span class="gi">+def read_submodule_head(path: Union[str, bytes]) -&gt; Optional[bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read the head commit of a submodule.

<span class="w"> </span>    Args:
<span class="w"> </span>      path: path to the submodule
<span class="w"> </span>    Returns: HEAD sha, None if not a valid head/repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .errors import NotGitRepository</span>
<span class="gi">+    from .repo import Repo</span>
<span class="gi">+</span>
<span class="gi">+    # Repo currently expects a &quot;str&quot;, so decode if necessary.</span>
<span class="gi">+    # TODO(jelmer): Perhaps move this into Repo() ?</span>
<span class="gi">+    if not isinstance(path, str):</span>
<span class="gi">+        path = os.fsdecode(path)</span>
<span class="gi">+    try:</span>
<span class="gi">+        repo = Repo(path)</span>
<span class="gi">+    except NotGitRepository:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        return repo.head()</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def _has_directory_changed(tree_path: bytes, entry):
<span class="gu">@@ -441,11 +951,22 @@ def _has_directory_changed(tree_path: bytes, entry):</span>
<span class="w"> </span>    Return true if the given path should be considered as changed and False
<span class="w"> </span>    otherwise or if the path is not a directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_unstaged_changes(index: Index, root_path: Union[str, bytes],</span>
<span class="gd">-    filter_blob_callback=None):</span>
<span class="gi">+    # This is actually a directory</span>
<span class="gi">+    if os.path.exists(os.path.join(tree_path, b&quot;.git&quot;)):</span>
<span class="gi">+        # Submodule</span>
<span class="gi">+        head = read_submodule_head(tree_path)</span>
<span class="gi">+        if entry.sha != head:</span>
<span class="gi">+            return True</span>
<span class="gi">+    else:</span>
<span class="gi">+        # The file was changed to a directory, so consider it removed.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_unstaged_changes(</span>
<span class="gi">+    index: Index, root_path: Union[str, bytes], filter_blob_callback=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Walk through an index and check for differences against working tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -453,10 +974,41 @@ def get_unstaged_changes(index: Index, root_path: Union[str, bytes],</span>
<span class="w"> </span>      root_path: path in which to find files
<span class="w"> </span>    Returns: iterator over paths with unstaged changes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # For each entry in the index check the sha1 &amp; ensure not staged</span>
<span class="gi">+    if not isinstance(root_path, bytes):</span>
<span class="gi">+        root_path = os.fsencode(root_path)</span>
<span class="gi">+</span>
<span class="gi">+    for tree_path, entry in index.iteritems():</span>
<span class="gi">+        full_path = _tree_to_fs_path(root_path, tree_path)</span>
<span class="gi">+        if isinstance(entry, ConflictedIndexEntry):</span>
<span class="gi">+            # Conflicted files are always unstaged</span>
<span class="gi">+            yield tree_path</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            st = os.lstat(full_path)</span>
<span class="gi">+            if stat.S_ISDIR(st.st_mode):</span>
<span class="gi">+                if _has_directory_changed(tree_path, entry):</span>
<span class="gi">+                    yield tree_path</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not stat.S_ISREG(st.st_mode) and not stat.S_ISLNK(st.st_mode):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            blob = blob_from_path_and_stat(full_path, st)</span>
<span class="gi">+</span>
<span class="gi">+            if filter_blob_callback is not None:</span>
<span class="gi">+                blob = filter_blob_callback(blob, tree_path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            # The file was removed, so we assume that counts as</span>
<span class="gi">+            # different from whatever file used to exist.</span>
<span class="gi">+            yield tree_path</span>
<span class="gi">+        else:</span>
<span class="gi">+            if blob.id != entry.sha:</span>
<span class="gi">+                yield tree_path</span>


<span class="gd">-os_sep_bytes = os.sep.encode(&#39;ascii&#39;)</span>
<span class="gi">+os_sep_bytes = os.sep.encode(&quot;ascii&quot;)</span>


<span class="w"> </span>def _tree_to_fs_path(root_path: bytes, tree_path: bytes):
<span class="gu">@@ -468,10 +1020,15 @@ def _tree_to_fs_path(root_path: bytes, tree_path: bytes):</span>

<span class="w"> </span>    Returns: File system path.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert isinstance(tree_path, bytes)</span>
<span class="gi">+    if os_sep_bytes != b&quot;/&quot;:</span>
<span class="gi">+        sep_corrected_path = tree_path.replace(b&quot;/&quot;, os_sep_bytes)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sep_corrected_path = tree_path</span>
<span class="gi">+    return os.path.join(root_path, sep_corrected_path)</span>


<span class="gd">-def _fs_to_tree_path(fs_path: Union[str, bytes]) -&gt;bytes:</span>
<span class="gi">+def _fs_to_tree_path(fs_path: Union[str, bytes]) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a file system path to a git tree path.

<span class="w"> </span>    Args:
<span class="gu">@@ -479,11 +1036,29 @@ def _fs_to_tree_path(fs_path: Union[str, bytes]) -&gt;bytes:</span>

<span class="w"> </span>    Returns:  Git tree path as bytes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def index_entry_from_path(path: bytes, object_store: Optional[</span>
<span class="gd">-    ObjectContainer]=None) -&gt;Optional[IndexEntry]:</span>
<span class="gi">+    if not isinstance(fs_path, bytes):</span>
<span class="gi">+        fs_path_bytes = os.fsencode(fs_path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        fs_path_bytes = fs_path</span>
<span class="gi">+    if os_sep_bytes != b&quot;/&quot;:</span>
<span class="gi">+        tree_path = fs_path_bytes.replace(os_sep_bytes, b&quot;/&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        tree_path = fs_path_bytes</span>
<span class="gi">+    return tree_path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def index_entry_from_directory(st, path: bytes) -&gt; Optional[IndexEntry]:</span>
<span class="gi">+    if os.path.exists(os.path.join(path, b&quot;.git&quot;)):</span>
<span class="gi">+        head = read_submodule_head(path)</span>
<span class="gi">+        if head is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return index_entry_from_stat(st, head, mode=S_IFGITLINK)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def index_entry_from_path(</span>
<span class="gi">+    path: bytes, object_store: Optional[ObjectContainer] = None</span>
<span class="gi">+) -&gt; Optional[IndexEntry]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an index from a filesystem path.

<span class="w"> </span>    This returns an index value for files, symlinks
<span class="gu">@@ -496,12 +1071,25 @@ def index_entry_from_path(path: bytes, object_store: Optional[</span>
<span class="w"> </span>        save new blobs in
<span class="w"> </span>    Returns: An index entry; None for directories
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert isinstance(path, bytes)</span>
<span class="gi">+    st = os.lstat(path)</span>
<span class="gi">+    if stat.S_ISDIR(st.st_mode):</span>
<span class="gi">+        return index_entry_from_directory(st, path)</span>

<span class="gi">+    if stat.S_ISREG(st.st_mode) or stat.S_ISLNK(st.st_mode):</span>
<span class="gi">+        blob = blob_from_path_and_stat(path, st)</span>
<span class="gi">+        if object_store is not None:</span>
<span class="gi">+            object_store.add_object(blob)</span>
<span class="gi">+        return index_entry_from_stat(st, blob.id)</span>

<span class="gd">-def iter_fresh_entries(paths: Iterable[bytes], root_path: bytes,</span>
<span class="gd">-    object_store: Optional[ObjectContainer]=None) -&gt;Iterator[Tuple[bytes,</span>
<span class="gd">-    Optional[IndexEntry]]]:</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_fresh_entries(</span>
<span class="gi">+    paths: Iterable[bytes],</span>
<span class="gi">+    root_path: bytes,</span>
<span class="gi">+    object_store: Optional[ObjectContainer] = None,</span>
<span class="gi">+) -&gt; Iterator[Tuple[bytes, Optional[IndexEntry]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over current versions of index entries on disk.

<span class="w"> </span>    Args:
<span class="gu">@@ -510,12 +1098,18 @@ def iter_fresh_entries(paths: Iterable[bytes], root_path: bytes,</span>
<span class="w"> </span>      object_store: Optional store to save new blobs in
<span class="w"> </span>    Returns: Iterator over path, index_entry
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        p = _tree_to_fs_path(root_path, path)</span>
<span class="gi">+        try:</span>
<span class="gi">+            entry = index_entry_from_path(p, object_store=object_store)</span>
<span class="gi">+        except (FileNotFoundError, IsADirectoryError):</span>
<span class="gi">+            entry = None</span>
<span class="gi">+        yield path, entry</span>


<span class="gd">-def iter_fresh_objects(paths: Iterable[bytes], root_path: bytes,</span>
<span class="gd">-    include_deleted=False, object_store=None) -&gt;Iterator[Tuple[bytes,</span>
<span class="gd">-    Optional[bytes], Optional[int]]]:</span>
<span class="gi">+def iter_fresh_objects(</span>
<span class="gi">+    paths: Iterable[bytes], root_path: bytes, include_deleted=False, object_store=None</span>
<span class="gi">+) -&gt; Iterator[Tuple[bytes, Optional[bytes], Optional[int]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over versions of objects on disk referenced by index.

<span class="w"> </span>    Args:
<span class="gu">@@ -525,7 +1119,12 @@ def iter_fresh_objects(paths: Iterable[bytes], root_path: bytes,</span>
<span class="w"> </span>      object_store: Optional object store to report new items to
<span class="w"> </span>    Returns: Iterator over path, sha, mode
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for path, entry in iter_fresh_entries(paths, root_path, object_store=object_store):</span>
<span class="gi">+        if entry is None:</span>
<span class="gi">+            if include_deleted:</span>
<span class="gi">+                yield path, None, None</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield path, entry.sha, cleanup_mode(entry.mode)</span>


<span class="w"> </span>def refresh_index(index: Index, root_path: bytes):
<span class="gu">@@ -537,7 +1136,9 @@ def refresh_index(index: Index, root_path: bytes):</span>
<span class="w"> </span>      index: Index to update
<span class="w"> </span>      root_path: Root filesystem path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for path, entry in iter_fresh_entries(index, root_path):</span>
<span class="gi">+        if entry:</span>
<span class="gi">+            index[path] = entry</span>


<span class="w"> </span>class locked_index:
<span class="gu">@@ -546,11 +1147,11 @@ class locked_index:</span>
<span class="w"> </span>    Works as a context manager.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, path: Union[bytes, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, path: Union[bytes, str]) -&gt; None:</span>
<span class="w"> </span>        self._path = path

<span class="w"> </span>    def __enter__(self):
<span class="gd">-        self._file = GitFile(self._path, &#39;wb&#39;)</span>
<span class="gi">+        self._file = GitFile(self._path, &quot;wb&quot;)</span>
<span class="w"> </span>        self._index = Index(self._path)
<span class="w"> </span>        return self._index

<span class="gh">diff --git a/dulwich/lfs.py b/dulwich/lfs.py</span>
<span class="gh">index b93c99c8..97933647 100644</span>
<span class="gd">--- a/dulwich/lfs.py</span>
<span class="gi">+++ b/dulwich/lfs.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# lfs.py -- Implementation of the LFS</span>
<span class="gi">+# Copyright (C) 2020 Jelmer Vernooij</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import os
<span class="w"> </span>import tempfile
<span class="gu">@@ -6,16 +26,49 @@ import tempfile</span>
<span class="w"> </span>class LFSStore:
<span class="w"> </span>    &quot;&quot;&quot;Stores objects on disk, indexed by SHA256.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path) -&gt;None:</span>
<span class="gi">+    def __init__(self, path) -&gt; None:</span>
<span class="w"> </span>        self.path = path

<span class="gi">+    @classmethod</span>
<span class="gi">+    def create(cls, lfs_dir):</span>
<span class="gi">+        if not os.path.isdir(lfs_dir):</span>
<span class="gi">+            os.mkdir(lfs_dir)</span>
<span class="gi">+        os.mkdir(os.path.join(lfs_dir, &quot;tmp&quot;))</span>
<span class="gi">+        os.mkdir(os.path.join(lfs_dir, &quot;objects&quot;))</span>
<span class="gi">+        return cls(lfs_dir)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_repo(cls, repo, create=False):</span>
<span class="gi">+        lfs_dir = os.path.join(repo.controldir, &quot;lfs&quot;)</span>
<span class="gi">+        if create:</span>
<span class="gi">+            return cls.create(lfs_dir)</span>
<span class="gi">+        return cls(lfs_dir)</span>
<span class="gi">+</span>
<span class="gi">+    def _sha_path(self, sha):</span>
<span class="gi">+        return os.path.join(self.path, &quot;objects&quot;, sha[0:2], sha[2:4], sha)</span>
<span class="gi">+</span>
<span class="w"> </span>    def open_object(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Open an object by sha.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return open(self._sha_path(sha), &quot;rb&quot;)</span>
<span class="gi">+        except FileNotFoundError as exc:</span>
<span class="gi">+            raise KeyError(sha) from exc</span>

<span class="w"> </span>    def write_object(self, chunks):
<span class="w"> </span>        &quot;&quot;&quot;Write an object.

<span class="w"> </span>        Returns: object SHA
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sha = hashlib.sha256()</span>
<span class="gi">+        tmpdir = os.path.join(self.path, &quot;tmp&quot;)</span>
<span class="gi">+        with tempfile.NamedTemporaryFile(dir=tmpdir, mode=&quot;wb&quot;, delete=False) as f:</span>
<span class="gi">+            for chunk in chunks:</span>
<span class="gi">+                sha.update(chunk)</span>
<span class="gi">+                f.write(chunk)</span>
<span class="gi">+            f.flush()</span>
<span class="gi">+            tmppath = f.name</span>
<span class="gi">+        path = self._sha_path(sha.hexdigest())</span>
<span class="gi">+        if not os.path.exists(os.path.dirname(path)):</span>
<span class="gi">+            os.makedirs(os.path.dirname(path))</span>
<span class="gi">+        os.rename(tmppath, path)</span>
<span class="gi">+        return sha.hexdigest()</span>
<span class="gh">diff --git a/dulwich/line_ending.py b/dulwich/line_ending.py</span>
<span class="gh">index 9d4a6618..adfa91bb 100644</span>
<span class="gd">--- a/dulwich/line_ending.py</span>
<span class="gi">+++ b/dulwich/line_ending.py</span>
<span class="gu">@@ -1,4 +1,23 @@</span>
<span class="gd">-&quot;&quot;&quot;All line-ending related functions, from conversions to config processing.</span>
<span class="gi">+# line_ending.py -- Line ending conversion functions</span>
<span class="gi">+# Copyright (C) 2018-2018 Boris Feld &lt;boris.feld@comet.ml&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+r&quot;&quot;&quot;All line-ending related functions, from conversions to config processing.</span>

<span class="w"> </span>Line-ending normalization is a complex beast. Here is some notes and details
<span class="w"> </span>about how it seems to work.
<span class="gu">@@ -42,23 +61,23 @@ There is multiple variables that impact the normalization.</span>
<span class="w"> </span>First, a repository can contains a ``.gitattributes`` file (or more than one...)
<span class="w"> </span>that can further customize the operation on some file patterns, for example:

<span class="gd">-    \\*.txt text</span>
<span class="gi">+    \*.txt text</span>

<span class="w"> </span>Force all ``.txt`` files to be treated as text files and to have their lines
<span class="w"> </span>endings normalized.

<span class="gd">-    \\*.jpg -text</span>
<span class="gi">+    \*.jpg -text</span>

<span class="w"> </span>Force all ``.jpg`` files to be treated as binary files and to not have their
<span class="w"> </span>lines endings converted.

<span class="gd">-    \\*.vcproj text eol=crlf</span>
<span class="gi">+    \*.vcproj text eol=crlf</span>

<span class="w"> </span>Force all ``.vcproj`` files to be treated as text files and to have their lines
<span class="w"> </span>endings converted into ``CRLF`` in working directory no matter the native EOL of
<span class="w"> </span>the platform.

<span class="gd">-    \\*.sh text eol=lf</span>
<span class="gi">+    \*.sh text eol=lf</span>

<span class="w"> </span>Force all ``.sh`` files to be treated as text files and to have their lines
<span class="w"> </span>endings converted into ``LF`` in working directory no matter the native EOL of
<span class="gu">@@ -67,7 +86,7 @@ the platform.</span>
<span class="w"> </span>If the ``eol`` attribute is not defined, Git uses the ``core.eol`` configuration
<span class="w"> </span>value described later.

<span class="gd">-    \\* text=auto</span>
<span class="gi">+    \* text=auto</span>

<span class="w"> </span>Force all files to be scanned by the text file heuristic detection and to have
<span class="w"> </span>their line endings normalized in case they are detected as text files.
<span class="gu">@@ -116,11 +135,13 @@ Sources:</span>
<span class="w"> </span>- https://git-scm.com/docs/gitattributes#_checking_out_and_checking_in
<span class="w"> </span>- https://adaptivepatchwork.com/2012/03/01/mind-the-end-of-your-line/
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .object_store import iter_tree_contents
<span class="w"> </span>from .objects import Blob
<span class="w"> </span>from .patch import is_binary
<span class="gd">-CRLF = b&#39;\r\n&#39;</span>
<span class="gd">-LF = b&#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+CRLF = b&quot;\r\n&quot;</span>
<span class="gi">+LF = b&quot;\n&quot;</span>


<span class="w"> </span>def convert_crlf_to_lf(text_hunk):
<span class="gu">@@ -130,7 +151,7 @@ def convert_crlf_to_lf(text_hunk):</span>
<span class="w"> </span>      text_hunk: A bytes string representing a text hunk
<span class="w"> </span>    Returns: The text hunk with the same type, with CRLF replaced into LF
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return text_hunk.replace(CRLF, LF)</span>


<span class="w"> </span>def convert_lf_to_crlf(text_hunk):
<span class="gu">@@ -140,17 +161,25 @@ def convert_lf_to_crlf(text_hunk):</span>
<span class="w"> </span>      text_hunk: A bytes string representing a text hunk
<span class="w"> </span>    Returns: The text hunk with the same type, with LF replaced into CRLF
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO find a more efficient way of doing it</span>
<span class="gi">+    intermediary = text_hunk.replace(CRLF, LF)</span>
<span class="gi">+    return intermediary.replace(LF, CRLF)</span>


<span class="w"> </span>def get_checkout_filter(core_eol, core_autocrlf, git_attributes):
<span class="w"> </span>    &quot;&quot;&quot;Returns the correct checkout filter based on the passed arguments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO this function should process the git_attributes for the path and if</span>
<span class="gi">+    # the text attribute is not defined, fallback on the</span>
<span class="gi">+    # get_checkout_filter_autocrlf function with the autocrlf value</span>
<span class="gi">+    return get_checkout_filter_autocrlf(core_autocrlf)</span>


<span class="w"> </span>def get_checkin_filter(core_eol, core_autocrlf, git_attributes):
<span class="w"> </span>    &quot;&quot;&quot;Returns the correct checkin filter based on the passed arguments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO this function should process the git_attributes for the path and if</span>
<span class="gi">+    # the text attribute is not defined, fallback on the</span>
<span class="gi">+    # get_checkin_filter_autocrlf function with the autocrlf value</span>
<span class="gi">+    return get_checkin_filter_autocrlf(core_autocrlf)</span>


<span class="w"> </span>def get_checkout_filter_autocrlf(core_autocrlf):
<span class="gu">@@ -162,7 +191,10 @@ def get_checkout_filter_autocrlf(core_autocrlf):</span>
<span class="w"> </span>    Returns: Either None if no filter has to be applied or a function
<span class="w"> </span>        accepting a single argument, a binary text hunk
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if core_autocrlf == b&quot;true&quot;:</span>
<span class="gi">+        return convert_lf_to_crlf</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_checkin_filter_autocrlf(core_autocrlf):
<span class="gu">@@ -174,7 +206,11 @@ def get_checkin_filter_autocrlf(core_autocrlf):</span>
<span class="w"> </span>    Returns: Either None if no filter has to be applied or a function
<span class="w"> </span>        accepting a single argument, a binary text hunk
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if core_autocrlf == b&quot;true&quot; or core_autocrlf == b&quot;input&quot;:</span>
<span class="gi">+        return convert_crlf_to_lf</span>
<span class="gi">+</span>
<span class="gi">+    # Checking filter should never be `convert_lf_to_crlf`</span>
<span class="gi">+    return None</span>


<span class="w"> </span>class BlobNormalizer:
<span class="gu">@@ -182,29 +218,45 @@ class BlobNormalizer:</span>
<span class="w"> </span>    on configuration, gitattributes, path and operation (checkin or checkout).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, config_stack, gitattributes) -&gt;None:</span>
<span class="gi">+    def __init__(self, config_stack, gitattributes) -&gt; None:</span>
<span class="w"> </span>        self.config_stack = config_stack
<span class="w"> </span>        self.gitattributes = gitattributes
<span class="gi">+</span>
<span class="gi">+        # Compute which filters we needs based on parameters</span>
<span class="w"> </span>        try:
<span class="gd">-            core_eol = config_stack.get(&#39;core&#39;, &#39;eol&#39;)</span>
<span class="gi">+            core_eol = config_stack.get(&quot;core&quot;, &quot;eol&quot;)</span>
<span class="w"> </span>        except KeyError:
<span class="gd">-            core_eol = &#39;native&#39;</span>
<span class="gi">+            core_eol = &quot;native&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="gd">-            core_autocrlf = config_stack.get(&#39;core&#39;, &#39;autocrlf&#39;).lower()</span>
<span class="gi">+            core_autocrlf = config_stack.get(&quot;core&quot;, &quot;autocrlf&quot;).lower()</span>
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            core_autocrlf = False
<span class="gd">-        self.fallback_read_filter = get_checkout_filter(core_eol,</span>
<span class="gd">-            core_autocrlf, self.gitattributes)</span>
<span class="gd">-        self.fallback_write_filter = get_checkin_filter(core_eol,</span>
<span class="gd">-            core_autocrlf, self.gitattributes)</span>
<span class="gi">+</span>
<span class="gi">+        self.fallback_read_filter = get_checkout_filter(</span>
<span class="gi">+            core_eol, core_autocrlf, self.gitattributes</span>
<span class="gi">+        )</span>
<span class="gi">+        self.fallback_write_filter = get_checkin_filter(</span>
<span class="gi">+            core_eol, core_autocrlf, self.gitattributes</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def checkin_normalize(self, blob, tree_path):
<span class="w"> </span>        &quot;&quot;&quot;Normalize a blob during a checkin operation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.fallback_write_filter is not None:</span>
<span class="gi">+            return normalize_blob(</span>
<span class="gi">+                blob, self.fallback_write_filter, binary_detection=True</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return blob</span>

<span class="w"> </span>    def checkout_normalize(self, blob, tree_path):
<span class="w"> </span>        &quot;&quot;&quot;Normalize a blob during a checkout operation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.fallback_read_filter is not None:</span>
<span class="gi">+            return normalize_blob(</span>
<span class="gi">+                blob, self.fallback_read_filter, binary_detection=True</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return blob</span>


<span class="w"> </span>def normalize_blob(blob, conversion, binary_detection):
<span class="gu">@@ -212,16 +264,41 @@ def normalize_blob(blob, conversion, binary_detection):</span>
<span class="w"> </span>    binary_detection is True and the blob content looks like binary, else
<span class="w"> </span>    return a new blob with converted data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Read the original blob</span>
<span class="gi">+    data = blob.data</span>

<span class="gi">+    # If we need to detect if a file is binary and the file is detected as</span>
<span class="gi">+    # binary, do not apply the conversion function and return the original</span>
<span class="gi">+    # chunked text</span>
<span class="gi">+    if binary_detection is True:</span>
<span class="gi">+        if is_binary(data):</span>
<span class="gi">+            return blob</span>

<span class="gd">-class TreeBlobNormalizer(BlobNormalizer):</span>
<span class="gi">+    # Now apply the conversion</span>
<span class="gi">+    converted_data = conversion(data)</span>
<span class="gi">+</span>
<span class="gi">+    new_blob = Blob()</span>
<span class="gi">+    new_blob.data = converted_data</span>
<span class="gi">+</span>
<span class="gi">+    return new_blob</span>

<span class="gd">-    def __init__(self, config_stack, git_attributes, object_store, tree=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class TreeBlobNormalizer(BlobNormalizer):</span>
<span class="gi">+    def __init__(self, config_stack, git_attributes, object_store, tree=None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(config_stack, git_attributes)
<span class="w"> </span>        if tree:
<span class="gd">-            self.existing_paths = {name for name, _, _ in</span>
<span class="gd">-                iter_tree_contents(object_store, tree)}</span>
<span class="gi">+            self.existing_paths = {</span>
<span class="gi">+                name for name, _, _ in iter_tree_contents(object_store, tree)</span>
<span class="gi">+            }</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.existing_paths = set()
<span class="gi">+</span>
<span class="gi">+    def checkin_normalize(self, blob, tree_path):</span>
<span class="gi">+        # Existing files should only be normalized on checkin if it was</span>
<span class="gi">+        # previously normalized on checkout</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.fallback_read_filter is not None</span>
<span class="gi">+            or tree_path not in self.existing_paths</span>
<span class="gi">+        ):</span>
<span class="gi">+            return super().checkin_normalize(blob, tree_path)</span>
<span class="gi">+        return blob</span>
<span class="gh">diff --git a/dulwich/log_utils.py b/dulwich/log_utils.py</span>
<span class="gh">index d6736a40..556332df 100644</span>
<span class="gd">--- a/dulwich/log_utils.py</span>
<span class="gi">+++ b/dulwich/log_utils.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# log_utils.py -- Logging utilities for Dulwich</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Logging utilities for Dulwich.

<span class="w"> </span>Any module that uses logging needs to do compile-time initialization to set up
<span class="gu">@@ -14,23 +34,33 @@ getLogger; this module exports that function for convenience. If a calling</span>
<span class="w"> </span>module needs something else, it can import the standard logging module
<span class="w"> </span>directly.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>getLogger = logging.getLogger


<span class="w"> </span>class _NullHandler(logging.Handler):
<span class="w"> </span>    &quot;&quot;&quot;No-op logging handler to avoid unexpected logging warnings.&quot;&quot;&quot;

<span class="gi">+    def emit(self, record):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>_NULL_HANDLER = _NullHandler()
<span class="gd">-_DULWICH_LOGGER = getLogger(&#39;dulwich&#39;)</span>
<span class="gi">+_DULWICH_LOGGER = getLogger(&quot;dulwich&quot;)</span>
<span class="w"> </span>_DULWICH_LOGGER.addHandler(_NULL_HANDLER)


<span class="w"> </span>def default_logging_config():
<span class="w"> </span>    &quot;&quot;&quot;Set up the default Dulwich loggers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    remove_null_handler()</span>
<span class="gi">+    logging.basicConfig(</span>
<span class="gi">+        level=logging.INFO,</span>
<span class="gi">+        stream=sys.stderr,</span>
<span class="gi">+        format=&quot;%(asctime)s %(levelname)s: %(message)s&quot;,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def remove_null_handler():
<span class="gu">@@ -40,4 +70,4 @@ def remove_null_handler():</span>
<span class="w"> </span>    default_logging_config, calling this function first is a minor optimization
<span class="w"> </span>    to avoid the overhead of using the _NullHandler.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _DULWICH_LOGGER.removeHandler(_NULL_HANDLER)</span>
<span class="gh">diff --git a/dulwich/lru_cache.py b/dulwich/lru_cache.py</span>
<span class="gh">index 651ebe4c..5d93f370 100644</span>
<span class="gd">--- a/dulwich/lru_cache.py</span>
<span class="gi">+++ b/dulwich/lru_cache.py</span>
<span class="gu">@@ -1,59 +1,108 @@</span>
<span class="gi">+# lru_cache.py -- Simple LRU cache for dulwich</span>
<span class="gi">+# Copyright (C) 2006, 2008 Canonical Ltd</span>
<span class="gi">+# Copyright (C) 2022 Jelmer Vernoo &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A simple least-recently-used (LRU) cache.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Callable, Dict, Generic, Iterable, Iterator, Optional, TypeVar
<span class="gi">+</span>
<span class="w"> </span>_null_key = object()
<span class="gd">-K = TypeVar(&#39;K&#39;)</span>
<span class="gd">-V = TypeVar(&#39;V&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+K = TypeVar(&quot;K&quot;)</span>
<span class="gi">+V = TypeVar(&quot;V&quot;)</span>


<span class="w"> </span>class _LRUNode(Generic[K, V]):
<span class="w"> </span>    &quot;&quot;&quot;This maintains the linked-list which is the lru internals.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;prev&#39;, &#39;next_key&#39;, &#39;key&#39;, &#39;value&#39;, &#39;cleanup&#39;, &#39;size&#39;</span>
<span class="gd">-    prev: Optional[&#39;_LRUNode[K, V]&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;prev&quot;, &quot;next_key&quot;, &quot;key&quot;, &quot;value&quot;, &quot;cleanup&quot;, &quot;size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    prev: Optional[&quot;_LRUNode[K, V]&quot;]</span>
<span class="w"> </span>    next_key: K
<span class="w"> </span>    size: Optional[int]

<span class="gd">-    def __init__(self, key: K, value: V, cleanup=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, key: K, value: V, cleanup=None) -&gt; None:</span>
<span class="w"> </span>        self.prev = None
<span class="gd">-        self.next_key = _null_key</span>
<span class="gi">+        self.next_key = _null_key  # type: ignore</span>
<span class="w"> </span>        self.key = key
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.cleanup = cleanup
<span class="gi">+        # TODO: We could compute this &#39;on-the-fly&#39; like we used to, and remove</span>
<span class="gi">+        #       one pointer from this object, we just need to decide if it</span>
<span class="gi">+        #       actually costs us much of anything in normal usage</span>
<span class="w"> </span>        self.size = None

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if self.prev is None:
<span class="w"> </span>            prev_key = None
<span class="w"> </span>        else:
<span class="w"> </span>            prev_key = self.prev.key
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.key!r} n:{self.next_key!r} p:{prev_key!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.key!r} n:{self.next_key!r} p:{prev_key!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def run_cleanup(self) -&gt; None:</span>
<span class="gi">+        if self.cleanup is not None:</span>
<span class="gi">+            self.cleanup(self.key, self.value)</span>
<span class="gi">+        self.cleanup = None</span>
<span class="gi">+        # Just make sure to break any refcycles, etc</span>
<span class="gi">+        del self.value</span>


<span class="w"> </span>class LRUCache(Generic[K, V]):
<span class="w"> </span>    &quot;&quot;&quot;A class which manages a cache of entries, removing unused ones.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _least_recently_used: Optional[_LRUNode[K, V]]
<span class="w"> </span>    _most_recently_used: Optional[_LRUNode[K, V]]

<span class="gd">-    def __init__(self, max_cache: int=100, after_cleanup_count: Optional[</span>
<span class="gd">-        int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, max_cache: int = 100, after_cleanup_count: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._cache: Dict[K, _LRUNode[K, V]] = {}
<span class="gi">+        # The &quot;HEAD&quot; of the lru linked list</span>
<span class="w"> </span>        self._most_recently_used = None
<span class="gi">+        # The &quot;TAIL&quot; of the lru linked list</span>
<span class="w"> </span>        self._least_recently_used = None
<span class="w"> </span>        self._update_max_cache(max_cache, after_cleanup_count)

<span class="gd">-    def __contains__(self, key: K) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, key: K) -&gt; bool:</span>
<span class="w"> </span>        return key in self._cache

<span class="gd">-    def __getitem__(self, key: K) -&gt;V:</span>
<span class="gi">+    def __getitem__(self, key: K) -&gt; V:</span>
<span class="w"> </span>        cache = self._cache
<span class="w"> </span>        node = cache[key]
<span class="gi">+        # Inlined from _record_access to decrease the overhead of __getitem__</span>
<span class="gi">+        # We also have more knowledge about structure if __getitem__ is</span>
<span class="gi">+        # succeeding, then we know that self._most_recently_used must not be</span>
<span class="gi">+        # None, etc.</span>
<span class="w"> </span>        mru = self._most_recently_used
<span class="w"> </span>        if node is mru:
<span class="gi">+            # Nothing to do, this node is already at the head of the queue</span>
<span class="w"> </span>            return node.value
<span class="gi">+        # Remove this node from the old location</span>
<span class="w"> </span>        node_prev = node.prev
<span class="w"> </span>        next_key = node.next_key
<span class="gi">+        # benchmarking shows that the lookup of _null_key in globals is faster</span>
<span class="gi">+        # than the attribute lookup for (node is self._least_recently_used)</span>
<span class="w"> </span>        if next_key is _null_key:
<span class="gi">+            # &#39;node&#39; is the _least_recently_used, because it doesn&#39;t have a</span>
<span class="gi">+            # &#39;next&#39; item. So move the current lru to the previous node.</span>
<span class="w"> </span>            self._least_recently_used = node_prev
<span class="w"> </span>        else:
<span class="w"> </span>            node_next = cache[next_key]
<span class="gu">@@ -61,21 +110,56 @@ class LRUCache(Generic[K, V]):</span>
<span class="w"> </span>        assert node_prev
<span class="w"> </span>        assert mru
<span class="w"> </span>        node_prev.next_key = next_key
<span class="gi">+        # Insert this node at the front of the list</span>
<span class="w"> </span>        node.next_key = mru.key
<span class="w"> </span>        mru.prev = node
<span class="w"> </span>        self._most_recently_used = node
<span class="w"> </span>        node.prev = None
<span class="w"> </span>        return node.value

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._cache)

<span class="gd">-    def _walk_lru(self) -&gt;Iterator[_LRUNode[K, V]]:</span>
<span class="gi">+    def _walk_lru(self) -&gt; Iterator[_LRUNode[K, V]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Walk the LRU list, only meant to be used in tests.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add(self, key: K, value: V, cleanup: Optional[Callable[[K, V], None</span>
<span class="gd">-        ]]=None) -&gt;None:</span>
<span class="gi">+        node = self._most_recently_used</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            if node.prev is not None:</span>
<span class="gi">+                raise AssertionError(</span>
<span class="gi">+                    &quot;the _most_recently_used entry is not&quot;</span>
<span class="gi">+                    &quot; supposed to have a previous entry&quot;</span>
<span class="gi">+                    f&quot; {node}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            if node.next_key is _null_key:</span>
<span class="gi">+                if node is not self._least_recently_used:</span>
<span class="gi">+                    raise AssertionError(</span>
<span class="gi">+                        &quot;only the last node should have&quot; f&quot; no next value: {node}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                node_next = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                node_next = self._cache[node.next_key]</span>
<span class="gi">+                if node_next.prev is not node:</span>
<span class="gi">+                    raise AssertionError(</span>
<span class="gi">+                        &quot;inconsistency found, node.next.prev&quot; f&quot; != node: {node}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            if node.prev is None:</span>
<span class="gi">+                if node is not self._most_recently_used:</span>
<span class="gi">+                    raise AssertionError(</span>
<span class="gi">+                        &quot;only the _most_recently_used should&quot;</span>
<span class="gi">+                        f&quot; not have a previous node: {node}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                if node.prev.next_key != node.key:</span>
<span class="gi">+                    raise AssertionError(</span>
<span class="gi">+                        &quot;inconsistency found, node.prev.next&quot; f&quot; != node: {node}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            yield node</span>
<span class="gi">+            node = node_next</span>
<span class="gi">+</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self, key: K, value: V, cleanup: Optional[Callable[[K, V], None]] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new value to the cache.

<span class="w"> </span>        Also, if the entry is ever removed from the cache, call
<span class="gu">@@ -87,13 +171,34 @@ class LRUCache(Generic[K, V]):</span>
<span class="w"> </span>          cleanup: None or a function taking (key, value) to indicate
<span class="w"> </span>                        &#39;value&#39; should be cleaned up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key is _null_key:</span>
<span class="gi">+            raise ValueError(&quot;cannot use _null_key as a key&quot;)</span>
<span class="gi">+        if key in self._cache:</span>
<span class="gi">+            node = self._cache[key]</span>
<span class="gi">+            node.run_cleanup()</span>
<span class="gi">+            node.value = value</span>
<span class="gi">+            node.cleanup = cleanup</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = _LRUNode(key, value, cleanup=cleanup)</span>
<span class="gi">+            self._cache[key] = node</span>
<span class="gi">+        self._record_access(node)</span>
<span class="gi">+</span>
<span class="gi">+        if len(self._cache) &gt; self._max_cache:</span>
<span class="gi">+            # Trigger the cleanup</span>
<span class="gi">+            self.cleanup()</span>

<span class="gd">-    def cache_size(self) -&gt;int:</span>
<span class="gi">+    def cache_size(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the number of entries we will cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._max_cache</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key: K, default: Optional[V] = None) -&gt; Optional[V]:</span>
<span class="gi">+        node = self._cache.get(key, None)</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            return default</span>
<span class="gi">+        self._record_access(node)</span>
<span class="gi">+        return node.value</span>

<span class="gd">-    def keys(self) -&gt;Iterable[K]:</span>
<span class="gi">+    def keys(self) -&gt; Iterable[K]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the list of keys currently cached.

<span class="w"> </span>        Note that values returned here may not be available by the time you
<span class="gu">@@ -102,11 +207,11 @@ class LRUCache(Generic[K, V]):</span>

<span class="w"> </span>        Returns: An unordered list of keys that are currently cached.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._cache.keys()</span>

<span class="gd">-    def items(self) -&gt;Dict[K, V]:</span>
<span class="gi">+    def items(self) -&gt; Dict[K, V]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the key:value pairs as a dict.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {k: n.value for k, n in self._cache.items()}</span>

<span class="w"> </span>    def cleanup(self):
<span class="w"> </span>        &quot;&quot;&quot;Clear the cache until it shrinks to the requested size.
<span class="gu">@@ -114,32 +219,84 @@ class LRUCache(Generic[K, V]):</span>
<span class="w"> </span>        This does not completely wipe the cache, just makes sure it is under
<span class="w"> </span>        the after_cleanup_count.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Make sure the cache is shrunk to the correct size</span>
<span class="gi">+        while len(self._cache) &gt; self._after_cleanup_count:</span>
<span class="gi">+            self._remove_lru()</span>

<span class="gd">-    def __setitem__(self, key: K, value: V) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: K, value: V) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a value to the cache, there will be no cleanup function.&quot;&quot;&quot;
<span class="w"> </span>        self.add(key, value, cleanup=None)

<span class="gd">-    def _record_access(self, node: _LRUNode[K, V]) -&gt;None:</span>
<span class="gi">+    def _record_access(self, node: _LRUNode[K, V]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Record that key was accessed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Move &#39;node&#39; to the front of the queue</span>
<span class="gi">+        if self._most_recently_used is None:</span>
<span class="gi">+            self._most_recently_used = node</span>
<span class="gi">+            self._least_recently_used = node</span>
<span class="gi">+            return</span>
<span class="gi">+        elif node is self._most_recently_used:</span>
<span class="gi">+            # Nothing to do, this node is already at the head of the queue</span>
<span class="gi">+            return</span>
<span class="gi">+        # We&#39;ve taken care of the tail pointer, remove the node, and insert it</span>
<span class="gi">+        # at the front</span>
<span class="gi">+        # REMOVE</span>
<span class="gi">+        if node is self._least_recently_used:</span>
<span class="gi">+            self._least_recently_used = node.prev</span>
<span class="gi">+        if node.prev is not None:</span>
<span class="gi">+            node.prev.next_key = node.next_key</span>
<span class="gi">+        if node.next_key is not _null_key:</span>
<span class="gi">+            node_next = self._cache[node.next_key]</span>
<span class="gi">+            node_next.prev = node.prev</span>
<span class="gi">+        # INSERT</span>
<span class="gi">+        node.next_key = self._most_recently_used.key</span>
<span class="gi">+        self._most_recently_used.prev = node</span>
<span class="gi">+        self._most_recently_used = node</span>
<span class="gi">+        node.prev = None</span>

<span class="gd">-    def _remove_lru(self) -&gt;None:</span>
<span class="gi">+    def _remove_node(self, node: _LRUNode[K, V]) -&gt; None:</span>
<span class="gi">+        if node is self._least_recently_used:</span>
<span class="gi">+            self._least_recently_used = node.prev</span>
<span class="gi">+        self._cache.pop(node.key)</span>
<span class="gi">+        # If we have removed all entries, remove the head pointer as well</span>
<span class="gi">+        if self._least_recently_used is None:</span>
<span class="gi">+            self._most_recently_used = None</span>
<span class="gi">+        node.run_cleanup()</span>
<span class="gi">+        # Now remove this node from the linked list</span>
<span class="gi">+        if node.prev is not None:</span>
<span class="gi">+            node.prev.next_key = node.next_key</span>
<span class="gi">+        if node.next_key is not _null_key:</span>
<span class="gi">+            node_next = self._cache[node.next_key]</span>
<span class="gi">+            node_next.prev = node.prev</span>
<span class="gi">+        # And remove this node&#39;s pointers</span>
<span class="gi">+        node.prev = None</span>
<span class="gi">+        node.next_key = _null_key  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_lru(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove one entry from the lru, and handle consequences.

<span class="w"> </span>        If there are no more references to the lru, then this entry should be
<span class="w"> </span>        removed from the cache.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self._least_recently_used</span>
<span class="gi">+        self._remove_node(self._least_recently_used)</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clear out all of the cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Clean up in LRU order</span>
<span class="gi">+        while self._cache:</span>
<span class="gi">+            self._remove_lru()</span>

<span class="gd">-    def resize(self, max_cache: int, after_cleanup_count: Optional[int]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def resize(self, max_cache: int, after_cleanup_count: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Change the number of entries that will be cached.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._update_max_cache(max_cache, after_cleanup_count=after_cleanup_count)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_max_cache(self, max_cache, after_cleanup_count=None):</span>
<span class="gi">+        self._max_cache = max_cache</span>
<span class="gi">+        if after_cleanup_count is None:</span>
<span class="gi">+            self._after_cleanup_count = self._max_cache * 8 / 10</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._after_cleanup_count = min(after_cleanup_count, self._max_cache)</span>
<span class="gi">+        self.cleanup()</span>


<span class="w"> </span>class LRUSizeCache(LRUCache[K, V]):
<span class="gu">@@ -151,11 +308,15 @@ class LRUSizeCache(LRUCache[K, V]):</span>
<span class="w"> </span>    The size of items added will be computed using compute_size(value), which
<span class="w"> </span>    defaults to len() if not supplied.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _compute_size: Callable[[V], int]

<span class="gd">-    def __init__(self, max_size: int=1024 * 1024, after_cleanup_size:</span>
<span class="gd">-        Optional[int]=None, compute_size: Optional[Callable[[V], int]]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        max_size: int = 1024 * 1024,</span>
<span class="gi">+        after_cleanup_size: Optional[int] = None,</span>
<span class="gi">+        compute_size: Optional[Callable[[V], int]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new LRUSizeCache.

<span class="w"> </span>        Args:
<span class="gu">@@ -172,14 +333,15 @@ class LRUSizeCache(LRUCache[K, V]):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._value_size = 0
<span class="w"> </span>        if compute_size is None:
<span class="gd">-            self._compute_size = len</span>
<span class="gi">+            self._compute_size = len  # type: ignore</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._compute_size = compute_size
<span class="w"> </span>        self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
<span class="w"> </span>        LRUCache.__init__(self, max_cache=max(int(max_size / 512), 1))

<span class="gd">-    def add(self, key: K, value: V, cleanup: Optional[Callable[[K, V], None</span>
<span class="gd">-        ]]=None) -&gt;None:</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self, key: K, value: V, cleanup: Optional[Callable[[K, V], None]] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new value to the cache.

<span class="w"> </span>        Also, if the entry is ever removed from the cache, call
<span class="gu">@@ -191,17 +353,59 @@ class LRUSizeCache(LRUCache[K, V]):</span>
<span class="w"> </span>          cleanup: None or a function taking (key, value) to indicate
<span class="w"> </span>                        &#39;value&#39; should be cleaned up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key is _null_key:</span>
<span class="gi">+            raise ValueError(&quot;cannot use _null_key as a key&quot;)</span>
<span class="gi">+        node = self._cache.get(key, None)</span>
<span class="gi">+        value_len = self._compute_size(value)</span>
<span class="gi">+        if value_len &gt;= self._after_cleanup_size:</span>
<span class="gi">+            # The new value is &#39;too big to fit&#39;, as it would fill up/overflow</span>
<span class="gi">+            # the cache all by itself</span>
<span class="gi">+            if node is not None:</span>
<span class="gi">+                # We won&#39;t be replacing the old node, so just remove it</span>
<span class="gi">+                self._remove_node(node)</span>
<span class="gi">+            if cleanup is not None:</span>
<span class="gi">+                cleanup(key, value)</span>
<span class="gi">+            return</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            node = _LRUNode(key, value, cleanup=cleanup)</span>
<span class="gi">+            self._cache[key] = node</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert node.size is not None</span>
<span class="gi">+            self._value_size -= node.size</span>
<span class="gi">+        node.size = value_len</span>
<span class="gi">+        self._value_size += value_len</span>
<span class="gi">+        self._record_access(node)</span>
<span class="gi">+</span>
<span class="gi">+        if self._value_size &gt; self._max_size:</span>
<span class="gi">+            # Time to cleanup</span>
<span class="gi">+            self.cleanup()</span>

<span class="gd">-    def cleanup(self) -&gt;None:</span>
<span class="gi">+    def cleanup(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clear the cache until it shrinks to the requested size.

<span class="w"> </span>        This does not completely wipe the cache, just makes sure it is under
<span class="w"> </span>        the after_cleanup_size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Make sure the cache is shrunk to the correct size</span>
<span class="gi">+        while self._value_size &gt; self._after_cleanup_size:</span>
<span class="gi">+            self._remove_lru()</span>

<span class="gd">-    def resize(self, max_size: int, after_cleanup_size: Optional[int]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _remove_node(self, node: _LRUNode[K, V]) -&gt; None:</span>
<span class="gi">+        assert node.size is not None</span>
<span class="gi">+        self._value_size -= node.size</span>
<span class="gi">+        LRUCache._remove_node(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    def resize(self, max_size: int, after_cleanup_size: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Change the number of bytes that will be cached.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)</span>
<span class="gi">+        max_cache = max(int(max_size / 512), 1)</span>
<span class="gi">+        self._update_max_cache(max_cache)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_max_size(</span>
<span class="gi">+        self, max_size: int, after_cleanup_size: Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._max_size = max_size</span>
<span class="gi">+        if after_cleanup_size is None:</span>
<span class="gi">+            self._after_cleanup_size = self._max_size * 8 // 10</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._after_cleanup_size = min(after_cleanup_size, self._max_size)</span>
<span class="gh">diff --git a/dulwich/mailmap.py b/dulwich/mailmap.py</span>
<span class="gh">index d866cd63..9ed9a88b 100644</span>
<span class="gd">--- a/dulwich/mailmap.py</span>
<span class="gi">+++ b/dulwich/mailmap.py</span>
<span class="gu">@@ -1,7 +1,41 @@</span>
<span class="gi">+# mailmap.py -- Mailmap reader</span>
<span class="gi">+# Copyright (C) 2018 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Mailmap file reader.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Dict, Optional, Tuple


<span class="gi">+def parse_identity(text):</span>
<span class="gi">+    # TODO(jelmer): Integrate this with dulwich.fastexport.split_email and</span>
<span class="gi">+    # dulwich.repo.check_user_identity</span>
<span class="gi">+    (name, email) = text.rsplit(b&quot;&lt;&quot;, 1)</span>
<span class="gi">+    name = name.strip()</span>
<span class="gi">+    email = email.rstrip(b&quot;&gt;&quot;).strip()</span>
<span class="gi">+    if not name:</span>
<span class="gi">+        name = None</span>
<span class="gi">+    if not email:</span>
<span class="gi">+        email = None</span>
<span class="gi">+    return (name, email)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def read_mailmap(f):
<span class="w"> </span>    &quot;&quot;&quot;Read a mailmap.

<span class="gu">@@ -10,13 +44,26 @@ def read_mailmap(f):</span>
<span class="w"> </span>    Returns: Iterator over
<span class="w"> </span>        ((canonical_name, canonical_email), (from_name, from_email)) tuples
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        # Remove comments</span>
<span class="gi">+        line = line.split(b&quot;#&quot;)[0]</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if not line:</span>
<span class="gi">+            continue</span>
<span class="gi">+        (canonical_identity, from_identity) = line.split(b&quot;&gt;&quot;, 1)</span>
<span class="gi">+        canonical_identity += b&quot;&gt;&quot;</span>
<span class="gi">+        if from_identity.strip():</span>
<span class="gi">+            parsed_from_identity = parse_identity(from_identity)</span>
<span class="gi">+        else:</span>
<span class="gi">+            parsed_from_identity = None</span>
<span class="gi">+        parsed_canonical_identity = parse_identity(canonical_identity)</span>
<span class="gi">+        yield parsed_canonical_identity, parsed_from_identity</span>


<span class="w"> </span>class Mailmap:
<span class="w"> </span>    &quot;&quot;&quot;Class for accessing a mailmap file.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, map=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, map=None) -&gt; None:</span>
<span class="w"> </span>        self._table: Dict[Tuple[Optional[str], str], Tuple[str, str]] = {}
<span class="w"> </span>        if map:
<span class="w"> </span>            for canonical_identity, from_identity in map:
<span class="gu">@@ -32,8 +79,38 @@ class Mailmap:</span>
<span class="w"> </span>          canonical_identity: The canonical identity (tuple)
<span class="w"> </span>          from_identity: The from identity (tuple)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if from_identity is None:</span>
<span class="gi">+            from_name, from_email = None, None</span>
<span class="gi">+        else:</span>
<span class="gi">+            (from_name, from_email) = from_identity</span>
<span class="gi">+        (canonical_name, canonical_email) = canonical_identity</span>
<span class="gi">+        if from_name is None and from_email is None:</span>
<span class="gi">+            self._table[canonical_name, None] = canonical_identity</span>
<span class="gi">+            self._table[None, canonical_email] = canonical_identity</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._table[from_name, from_email] = canonical_identity</span>

<span class="w"> </span>    def lookup(self, identity):
<span class="w"> </span>        &quot;&quot;&quot;Lookup an identity in this mailmail.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(identity, tuple):</span>
<span class="gi">+            was_tuple = False</span>
<span class="gi">+            identity = parse_identity(identity)</span>
<span class="gi">+        else:</span>
<span class="gi">+            was_tuple = True</span>
<span class="gi">+        for query in [identity, (None, identity[1]), (identity[0], None)]:</span>
<span class="gi">+            canonical_identity = self._table.get(query)</span>
<span class="gi">+            if canonical_identity is not None:</span>
<span class="gi">+                identity = (</span>
<span class="gi">+                    canonical_identity[0] or identity[0],</span>
<span class="gi">+                    canonical_identity[1] or identity[1],</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+        if was_tuple:</span>
<span class="gi">+            return identity</span>
<span class="gi">+        else:</span>
<span class="gi">+            return identity[0] + b&quot; &lt;&quot; + identity[1] + b&quot;&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path):</span>
<span class="gi">+        with open(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            return cls(read_mailmap(f))</span>
<span class="gh">diff --git a/dulwich/object_store.py b/dulwich/object_store.py</span>
<span class="gh">index 188df2bb..a28e1417 100644</span>
<span class="gd">--- a/dulwich/object_store.py</span>
<span class="gi">+++ b/dulwich/object_store.py</span>
<span class="gu">@@ -1,38 +1,130 @@</span>
<span class="gi">+# object_store.py -- Object store for git objects</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#                         and others</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Git object store interfaces and implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import stat
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from io import BytesIO
<span class="gd">-from typing import Callable, Dict, FrozenSet, Iterable, Iterator, List, Optional, Protocol, Sequence, Set, Tuple, cast</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    cast,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .errors import NotTreeError
<span class="w"> </span>from .file import GitFile
<span class="gd">-from .objects import S_ISGITLINK, ZERO_SHA, Blob, Commit, ObjectID, ShaFile, Tag, Tree, TreeEntry, hex_to_filename, hex_to_sha, object_class, sha_to_hex, valid_hexsha</span>
<span class="gd">-from .pack import PACK_SPOOL_FILE_MAX_SIZE, ObjectContainer, Pack, PackData, PackedObjectContainer, PackFileDisappeared, PackHint, PackIndexer, PackInflater, PackStreamCopier, UnpackedObject, extend_pack, full_unpacked_object, generate_unpacked_objects, iter_sha1, load_pack_index_file, pack_objects_to_data, write_pack_data, write_pack_index</span>
<span class="gi">+from .objects import (</span>
<span class="gi">+    S_ISGITLINK,</span>
<span class="gi">+    ZERO_SHA,</span>
<span class="gi">+    Blob,</span>
<span class="gi">+    Commit,</span>
<span class="gi">+    ObjectID,</span>
<span class="gi">+    ShaFile,</span>
<span class="gi">+    Tag,</span>
<span class="gi">+    Tree,</span>
<span class="gi">+    TreeEntry,</span>
<span class="gi">+    hex_to_filename,</span>
<span class="gi">+    hex_to_sha,</span>
<span class="gi">+    object_class,</span>
<span class="gi">+    sha_to_hex,</span>
<span class="gi">+    valid_hexsha,</span>
<span class="gi">+)</span>
<span class="gi">+from .pack import (</span>
<span class="gi">+    PACK_SPOOL_FILE_MAX_SIZE,</span>
<span class="gi">+    ObjectContainer,</span>
<span class="gi">+    Pack,</span>
<span class="gi">+    PackData,</span>
<span class="gi">+    PackedObjectContainer,</span>
<span class="gi">+    PackFileDisappeared,</span>
<span class="gi">+    PackHint,</span>
<span class="gi">+    PackIndexer,</span>
<span class="gi">+    PackInflater,</span>
<span class="gi">+    PackStreamCopier,</span>
<span class="gi">+    UnpackedObject,</span>
<span class="gi">+    extend_pack,</span>
<span class="gi">+    full_unpacked_object,</span>
<span class="gi">+    generate_unpacked_objects,</span>
<span class="gi">+    iter_sha1,</span>
<span class="gi">+    load_pack_index_file,</span>
<span class="gi">+    pack_objects_to_data,</span>
<span class="gi">+    write_pack_data,</span>
<span class="gi">+    write_pack_index,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .protocol import DEPTH_INFINITE
<span class="w"> </span>from .refs import PEELED_TAG_SUFFIX, Ref
<span class="gd">-INFODIR = &#39;info&#39;</span>
<span class="gd">-PACKDIR = &#39;pack&#39;</span>
<span class="gd">-PACK_MODE = 292 if sys.platform != &#39;win32&#39; else 420</span>

<span class="gi">+INFODIR = &quot;info&quot;</span>
<span class="gi">+PACKDIR = &quot;pack&quot;</span>
<span class="gi">+</span>
<span class="gi">+# use permissions consistent with Git; just readable by everyone</span>
<span class="gi">+# TODO: should packs also be non-writable on Windows? if so, that</span>
<span class="gi">+# would requite some rather significant adjustments to the test suite</span>
<span class="gi">+PACK_MODE = 0o444 if sys.platform != &quot;win32&quot; else 0o644</span>

<span class="gd">-class PackContainer(Protocol):</span>

<span class="gd">-    def add_pack(self) -&gt;Tuple[BytesIO, Callable[[], None], Callable[[], None]</span>
<span class="gd">-        ]:</span>
<span class="gi">+class PackContainer(Protocol):</span>
<span class="gi">+    def add_pack(self) -&gt; Tuple[BytesIO, Callable[[], None], Callable[[], None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class BaseObjectStore:
<span class="w"> </span>    &quot;&quot;&quot;Object store interface.&quot;&quot;&quot;

<span class="gi">+    def determine_wants_all(</span>
<span class="gi">+        self, refs: Dict[Ref, ObjectID], depth: Optional[int] = None</span>
<span class="gi">+    ) -&gt; List[ObjectID]:</span>
<span class="gi">+        def _want_deepen(sha):</span>
<span class="gi">+            if not depth:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if depth == DEPTH_INFINITE:</span>
<span class="gi">+                return True</span>
<span class="gi">+            return depth &gt; self._get_depth(sha)</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            sha</span>
<span class="gi">+            for (ref, sha) in refs.items()</span>
<span class="gi">+            if (sha not in self or _want_deepen(sha))</span>
<span class="gi">+            and not ref.endswith(PEELED_TAG_SUFFIX)</span>
<span class="gi">+            and not sha == ZERO_SHA</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="w"> </span>    def contains_loose(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1 and is loose.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.contains_loose)</span>

<span class="gd">-    def __contains__(self, sha1: bytes) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, sha1: bytes) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1.

<span class="w"> </span>        This method makes no distinction between loose and packed objects.
<span class="gu">@@ -42,7 +134,7 @@ class BaseObjectStore:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def packs(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterable of pack objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def get_raw(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Obtain the raw text for an object.
<span class="gu">@@ -51,9 +143,9 @@ class BaseObjectStore:</span>
<span class="w"> </span>          name: sha for the object.
<span class="w"> </span>        Returns: tuple with numeric type and object contents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_raw)</span>

<span class="gd">-    def __getitem__(self, sha1: ObjectID) -&gt;ShaFile:</span>
<span class="gi">+    def __getitem__(self, sha1: ObjectID) -&gt; ShaFile:</span>
<span class="w"> </span>        &quot;&quot;&quot;Obtain an object by SHA1.&quot;&quot;&quot;
<span class="w"> </span>        type_num, uncomp = self.get_raw(sha1)
<span class="w"> </span>        return ShaFile.from_raw_string(type_num, uncomp, sha=sha1)
<span class="gu">@@ -64,7 +156,7 @@ class BaseObjectStore:</span>

<span class="w"> </span>    def add_object(self, obj):
<span class="w"> </span>        &quot;&quot;&quot;Add a single object to this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.add_object)</span>

<span class="w"> </span>    def add_objects(self, objects, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a set of objects to this object store.
<span class="gu">@@ -72,10 +164,17 @@ class BaseObjectStore:</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          objects: Iterable over a list of (object, path) tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tree_changes(self, source, target, want_unchanged=False,</span>
<span class="gd">-        include_trees=False, change_type_same=False, rename_detector=None):</span>
<span class="gi">+        raise NotImplementedError(self.add_objects)</span>
<span class="gi">+</span>
<span class="gi">+    def tree_changes(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source,</span>
<span class="gi">+        target,</span>
<span class="gi">+        want_unchanged=False,</span>
<span class="gi">+        include_trees=False,</span>
<span class="gi">+        change_type_same=False,</span>
<span class="gi">+        rename_detector=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the differences between the contents of two trees.

<span class="w"> </span>        Args:
<span class="gu">@@ -88,7 +187,22 @@ class BaseObjectStore:</span>
<span class="w"> </span>        Returns: Iterator over tuples with
<span class="w"> </span>            (oldpath, newpath), (oldmode, newmode), (oldsha, newsha)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .diff_tree import tree_changes</span>
<span class="gi">+</span>
<span class="gi">+        for change in tree_changes(</span>
<span class="gi">+            self,</span>
<span class="gi">+            source,</span>
<span class="gi">+            target,</span>
<span class="gi">+            want_unchanged=want_unchanged,</span>
<span class="gi">+            include_trees=include_trees,</span>
<span class="gi">+            change_type_same=change_type_same,</span>
<span class="gi">+            rename_detector=rename_detector,</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield (</span>
<span class="gi">+                (change.old.path, change.new.path),</span>
<span class="gi">+                (change.old.mode, change.new.mode),</span>
<span class="gi">+                (change.old.sha, change.new.sha),</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def iter_tree_contents(self, tree_id, include_trees=False):
<span class="w"> </span>        &quot;&quot;&quot;Iterate the contents of a tree and all subtrees.
<span class="gu">@@ -101,10 +215,32 @@ class BaseObjectStore:</span>
<span class="w"> </span>        Returns: Iterator over TreeEntry namedtuples for all the objects in a
<span class="w"> </span>            tree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find_missing_objects(self, haves, wants, shallow=None, progress=</span>
<span class="gd">-        None, get_tagged=None, get_parents=lambda commit: commit.parents):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Please use dulwich.object_store.iter_tree_contents&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return iter_tree_contents(self, tree_id, include_trees=include_trees)</span>
<span class="gi">+</span>
<span class="gi">+    def iterobjects_subset(</span>
<span class="gi">+        self, shas: Iterable[bytes], *, allow_missing: bool = False</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        for sha in shas:</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield self[sha]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                if not allow_missing:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+    def find_missing_objects(</span>
<span class="gi">+        self,</span>
<span class="gi">+        haves,</span>
<span class="gi">+        wants,</span>
<span class="gi">+        shallow=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        get_tagged=None,</span>
<span class="gi">+        get_parents=lambda commit: commit.parents,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the missing objects required for a set of revisions.

<span class="w"> </span>        Args:
<span class="gu">@@ -119,7 +255,17 @@ class BaseObjectStore:</span>
<span class="w"> </span>            commit.
<span class="w"> </span>        Returns: Iterator over (sha, path) pairs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(&quot;Please use MissingObjectFinder(store)&quot;, DeprecationWarning)</span>
<span class="gi">+        finder = MissingObjectFinder(</span>
<span class="gi">+            self,</span>
<span class="gi">+            haves=haves,</span>
<span class="gi">+            wants=wants,</span>
<span class="gi">+            shallow=shallow,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            get_tagged=get_tagged,</span>
<span class="gi">+            get_parents=get_parents,</span>
<span class="gi">+        )</span>
<span class="gi">+        return iter(finder)</span>

<span class="w"> </span>    def find_common_revisions(self, graphwalker):
<span class="w"> </span>        &quot;&quot;&quot;Find which revisions this store has in common using graphwalker.
<span class="gu">@@ -128,10 +274,18 @@ class BaseObjectStore:</span>
<span class="w"> </span>          graphwalker: A graphwalker object.
<span class="w"> </span>        Returns: List of SHAs that are in common
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_pack_data(self, have, want, shallow=None, progress=None,</span>
<span class="gd">-        ofs_delta=True) -&gt;Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="gi">+        haves = []</span>
<span class="gi">+        sha = next(graphwalker)</span>
<span class="gi">+        while sha:</span>
<span class="gi">+            if sha in self:</span>
<span class="gi">+                haves.append(sha)</span>
<span class="gi">+                graphwalker.ack(sha)</span>
<span class="gi">+            sha = next(graphwalker)</span>
<span class="gi">+        return haves</span>
<span class="gi">+</span>
<span class="gi">+    def generate_pack_data(</span>
<span class="gi">+        self, have, want, shallow=None, progress=None, ofs_delta=True</span>
<span class="gi">+    ) -&gt; Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate pack data objects for a set of wants/haves.

<span class="w"> </span>        Args:
<span class="gu">@@ -141,7 +295,17 @@ class BaseObjectStore:</span>
<span class="w"> </span>          ofs_delta: Whether OFS deltas can be included
<span class="w"> </span>          progress: Optional progress reporting method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note that the pack-specific implementation below is more efficient,</span>
<span class="gi">+        # as it reuses deltas</span>
<span class="gi">+        missing_objects = MissingObjectFinder(</span>
<span class="gi">+            self, haves=have, wants=want, shallow=shallow, progress=progress</span>
<span class="gi">+        )</span>
<span class="gi">+        object_ids = list(missing_objects)</span>
<span class="gi">+        return pack_objects_to_data(</span>
<span class="gi">+            [(self[oid], path) for oid, path in object_ids],</span>
<span class="gi">+            ofs_delta=ofs_delta,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def peel_sha(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Peel all tags from a SHA.
<span class="gu">@@ -152,10 +316,19 @@ class BaseObjectStore:</span>
<span class="w"> </span>            intermediate tags; if the original ref does not point to a tag,
<span class="w"> </span>            this will equal the original SHA1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_depth(self, head, get_parents=lambda commit: commit.parents,</span>
<span class="gd">-        max_depth=None):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Please use dulwich.object_store.peel_sha()&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return peel_sha(self, sha)[1]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_depth(</span>
<span class="gi">+        self,</span>
<span class="gi">+        head,</span>
<span class="gi">+        get_parents=lambda commit: commit.parents,</span>
<span class="gi">+        max_depth=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current available depth for the given head.
<span class="w"> </span>        For commits with multiple parents, the largest possible depth will be
<span class="w"> </span>        returned.
<span class="gu">@@ -165,42 +338,81 @@ class BaseObjectStore:</span>
<span class="w"> </span>            get_parents: optional function for getting the parents of a commit
<span class="w"> </span>            max_depth: maximum depth to search
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if head not in self:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        current_depth = 1</span>
<span class="gi">+        queue = [(head, current_depth)]</span>
<span class="gi">+        while queue and (max_depth is None or current_depth &lt; max_depth):</span>
<span class="gi">+            e, depth = queue.pop(0)</span>
<span class="gi">+            current_depth = max(current_depth, depth)</span>
<span class="gi">+            cmt = self[e]</span>
<span class="gi">+            if isinstance(cmt, Tag):</span>
<span class="gi">+                _cls, sha = cmt.object</span>
<span class="gi">+                cmt = self[sha]</span>
<span class="gi">+            queue.extend(</span>
<span class="gi">+                (parent, depth + 1) for parent in get_parents(cmt) if parent in self</span>
<span class="gi">+            )</span>
<span class="gi">+        return current_depth</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close any files opened by this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Default implementation is a NO-OP</span>


<span class="w"> </span>class PackBasedObjectStore(BaseObjectStore):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, pack_compression_level=-1) -&gt;None:</span>
<span class="gi">+    def __init__(self, pack_compression_level=-1) -&gt; None:</span>
<span class="w"> </span>        self._pack_cache: Dict[str, Pack] = {}
<span class="w"> </span>        self.pack_compression_level = pack_compression_level

<span class="gd">-    def add_pack(self) -&gt;Tuple[BytesIO, Callable[[], None], Callable[[], None]</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def add_pack(self) -&gt; Tuple[BytesIO, Callable[[], None], Callable[[], None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack to this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.add_pack)</span>

<span class="gd">-    def add_pack_data(self, count: int, unpacked_objects: Iterator[</span>
<span class="gd">-        UnpackedObject], progress=None) -&gt;None:</span>
<span class="gi">+    def add_pack_data(</span>
<span class="gi">+        self, count: int, unpacked_objects: Iterator[UnpackedObject], progress=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add pack data to this object store.

<span class="w"> </span>        Args:
<span class="w"> </span>          count: Number of items to add
<span class="w"> </span>          pack_data: Iterator over pack data tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            # Don&#39;t bother writing an empty pack file</span>
<span class="gi">+            return</span>
<span class="gi">+        f, commit, abort = self.add_pack()</span>
<span class="gi">+        try:</span>
<span class="gi">+            write_pack_data(</span>
<span class="gi">+                f.write,</span>
<span class="gi">+                unpacked_objects,</span>
<span class="gi">+                num_records=count,</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+                compression_level=self.pack_compression_level,</span>
<span class="gi">+            )</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            abort()</span>
<span class="gi">+            raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            return commit()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def alternates(self):</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def contains_packed(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1 and is packed.

<span class="w"> </span>        This does not check alternates.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for pack in self.packs:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if sha in pack:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            except PackFileDisappeared:</span>
<span class="gi">+                pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def __contains__(self, sha) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, sha) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1.

<span class="w"> </span>        This method makes no distinction between loose and packed objects.
<span class="gu">@@ -214,10 +426,15 @@ class PackBasedObjectStore(BaseObjectStore):</span>

<span class="w"> </span>    def _add_cached_pack(self, base_name, pack):
<span class="w"> </span>        &quot;&quot;&quot;Add a newly appeared pack to the cache by path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_pack_data(self, have, want, shallow=None, progress=None,</span>
<span class="gd">-        ofs_delta=True) -&gt;Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="gi">+        prev_pack = self._pack_cache.get(base_name)</span>
<span class="gi">+        if prev_pack is not pack:</span>
<span class="gi">+            self._pack_cache[base_name] = pack</span>
<span class="gi">+            if prev_pack:</span>
<span class="gi">+                prev_pack.close()</span>
<span class="gi">+</span>
<span class="gi">+    def generate_pack_data(</span>
<span class="gi">+        self, have, want, shallow=None, progress=None, ofs_delta=True</span>
<span class="gi">+    ) -&gt; Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate pack data objects for a set of wants/haves.

<span class="w"> </span>        Args:
<span class="gu">@@ -227,27 +444,70 @@ class PackBasedObjectStore(BaseObjectStore):</span>
<span class="w"> </span>          ofs_delta: Whether OFS deltas can be included
<span class="w"> </span>          progress: Optional progress reporting method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing_objects = MissingObjectFinder(</span>
<span class="gi">+            self, haves=have, wants=want, shallow=shallow, progress=progress</span>
<span class="gi">+        )</span>
<span class="gi">+        remote_has = missing_objects.get_remote_has()</span>
<span class="gi">+        object_ids = list(missing_objects)</span>
<span class="gi">+        return len(object_ids), generate_unpacked_objects(</span>
<span class="gi">+            cast(PackedObjectContainer, self),</span>
<span class="gi">+            object_ids,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            ofs_delta=ofs_delta,</span>
<span class="gi">+            other_haves=remote_has,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _clear_cached_packs(self):</span>
<span class="gi">+        pack_cache = self._pack_cache</span>
<span class="gi">+        self._pack_cache = {}</span>
<span class="gi">+        while pack_cache:</span>
<span class="gi">+            (name, pack) = pack_cache.popitem()</span>
<span class="gi">+            pack.close()</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_cached_packs(self):</span>
<span class="gi">+        return self._pack_cache.values()</span>
<span class="gi">+</span>
<span class="gi">+    def _update_pack_cache(self):</span>
<span class="gi">+        raise NotImplementedError(self._update_pack_cache)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self._clear_cached_packs()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def packs(self):
<span class="w"> </span>        &quot;&quot;&quot;List with pack objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self._iter_cached_packs()) + list(self._update_pack_cache())</span>

<span class="w"> </span>    def _iter_alternate_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs of all the objects in alternate stores.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for alternate in self.alternates:</span>
<span class="gi">+            yield from alternate</span>

<span class="w"> </span>    def _iter_loose_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs of all loose objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._iter_loose_objects)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_loose_object(self, sha):</span>
<span class="gi">+        raise NotImplementedError(self._get_loose_object)</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_loose_object(self, sha):</span>
<span class="gi">+        raise NotImplementedError(self._remove_loose_object)</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_pack(self, name):</span>
<span class="gi">+        raise NotImplementedError(self._remove_pack)</span>

<span class="w"> </span>    def pack_loose_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Pack loose objects.

<span class="w"> </span>        Returns: Number of objects packed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        objects = set()</span>
<span class="gi">+        for sha in self._iter_loose_objects():</span>
<span class="gi">+            objects.add((self._get_loose_object(sha), None))</span>
<span class="gi">+        self.add_objects(list(objects))</span>
<span class="gi">+        for obj, path in objects:</span>
<span class="gi">+            self._remove_loose_object(obj.id)</span>
<span class="gi">+        return len(objects)</span>

<span class="w"> </span>    def repack(self):
<span class="w"> </span>        &quot;&quot;&quot;Repack the packs in this repository.
<span class="gu">@@ -255,7 +515,27 @@ class PackBasedObjectStore(BaseObjectStore):</span>
<span class="w"> </span>        Note that this implementation is fairly naive and currently keeps all
<span class="w"> </span>        objects in memory while it repacks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        loose_objects = set()</span>
<span class="gi">+        for sha in self._iter_loose_objects():</span>
<span class="gi">+            loose_objects.add(self._get_loose_object(sha))</span>
<span class="gi">+        objects = {(obj, None) for obj in loose_objects}</span>
<span class="gi">+        old_packs = {p.name(): p for p in self.packs}</span>
<span class="gi">+        for name, pack in old_packs.items():</span>
<span class="gi">+            objects.update((obj, None) for obj in pack.iterobjects())</span>
<span class="gi">+</span>
<span class="gi">+        # The name of the consolidated pack might match the name of a</span>
<span class="gi">+        # pre-existing pack. Take care not to remove the newly created</span>
<span class="gi">+        # consolidated pack.</span>
<span class="gi">+</span>
<span class="gi">+        consolidated = self.add_objects(objects)</span>
<span class="gi">+        old_packs.pop(consolidated.name(), None)</span>
<span class="gi">+</span>
<span class="gi">+        for obj in loose_objects:</span>
<span class="gi">+            self._remove_loose_object(obj.id)</span>
<span class="gi">+        for name, pack in old_packs.items():</span>
<span class="gi">+            self._remove_pack(pack)</span>
<span class="gi">+        self._update_pack_cache()</span>
<span class="gi">+        return len(objects)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs that are present in this store.&quot;&quot;&quot;
<span class="gu">@@ -273,7 +553,7 @@ class PackBasedObjectStore(BaseObjectStore):</span>

<span class="w"> </span>        This does not check alternates.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_loose_object(sha) is not None</span>

<span class="w"> </span>    def get_raw(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Obtain the raw fulltext for an object.
<span class="gu">@@ -282,19 +562,151 @@ class PackBasedObjectStore(BaseObjectStore):</span>
<span class="w"> </span>          name: sha for the object.
<span class="w"> </span>        Returns: tuple with numeric type and object contents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_unpacked_object(self, sha1: bytes, *, include_comp: bool=False</span>
<span class="gd">-        ) -&gt;UnpackedObject:</span>
<span class="gi">+        if name == ZERO_SHA:</span>
<span class="gi">+            raise KeyError(name)</span>
<span class="gi">+        if len(name) == 40:</span>
<span class="gi">+            sha = hex_to_sha(name)</span>
<span class="gi">+            hexsha = name</span>
<span class="gi">+        elif len(name) == 20:</span>
<span class="gi">+            sha = name</span>
<span class="gi">+            hexsha = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError(f&quot;Invalid object name {name!r}&quot;)</span>
<span class="gi">+        for pack in self._iter_cached_packs():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return pack.get_raw(sha)</span>
<span class="gi">+            except (KeyError, PackFileDisappeared):</span>
<span class="gi">+                pass</span>
<span class="gi">+        if hexsha is None:</span>
<span class="gi">+            hexsha = sha_to_hex(name)</span>
<span class="gi">+        ret = self._get_loose_object(hexsha)</span>
<span class="gi">+        if ret is not None:</span>
<span class="gi">+            return ret.type_num, ret.as_raw_string()</span>
<span class="gi">+        # Maybe something else has added a pack with the object</span>
<span class="gi">+        # in the mean time?</span>
<span class="gi">+        for pack in self._update_pack_cache():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return pack.get_raw(sha)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        for alternate in self.alternates:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return alternate.get_raw(hexsha)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise KeyError(hexsha)</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked_subset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        shas,</span>
<span class="gi">+        *,</span>
<span class="gi">+        include_comp=False,</span>
<span class="gi">+        allow_missing: bool = False,</span>
<span class="gi">+        convert_ofs_delta: bool = True,</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        todo: Set[bytes] = set(shas)</span>
<span class="gi">+        for p in self._iter_cached_packs():</span>
<span class="gi">+            for unpacked in p.iter_unpacked_subset(</span>
<span class="gi">+                todo,</span>
<span class="gi">+                include_comp=include_comp,</span>
<span class="gi">+                allow_missing=True,</span>
<span class="gi">+                convert_ofs_delta=convert_ofs_delta,</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield unpacked</span>
<span class="gi">+                hexsha = sha_to_hex(unpacked.sha())</span>
<span class="gi">+                todo.remove(hexsha)</span>
<span class="gi">+        # Maybe something else has added a pack with the object</span>
<span class="gi">+        # in the mean time?</span>
<span class="gi">+        for p in self._update_pack_cache():</span>
<span class="gi">+            for unpacked in p.iter_unpacked_subset(</span>
<span class="gi">+                todo,</span>
<span class="gi">+                include_comp=include_comp,</span>
<span class="gi">+                allow_missing=True,</span>
<span class="gi">+                convert_ofs_delta=convert_ofs_delta,</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield unpacked</span>
<span class="gi">+                hexsha = sha_to_hex(unpacked.sha())</span>
<span class="gi">+                todo.remove(hexsha)</span>
<span class="gi">+        for alternate in self.alternates:</span>
<span class="gi">+            for unpacked in alternate.iter_unpacked_subset(</span>
<span class="gi">+                todo,</span>
<span class="gi">+                include_comp=include_comp,</span>
<span class="gi">+                allow_missing=True,</span>
<span class="gi">+                convert_ofs_delta=convert_ofs_delta,</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield unpacked</span>
<span class="gi">+                hexsha = sha_to_hex(unpacked.sha())</span>
<span class="gi">+                todo.remove(hexsha)</span>
<span class="gi">+</span>
<span class="gi">+    def iterobjects_subset(</span>
<span class="gi">+        self, shas: Iterable[bytes], *, allow_missing: bool = False</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        todo: Set[bytes] = set(shas)</span>
<span class="gi">+        for p in self._iter_cached_packs():</span>
<span class="gi">+            for o in p.iterobjects_subset(todo, allow_missing=True):</span>
<span class="gi">+                yield o</span>
<span class="gi">+                todo.remove(o.id)</span>
<span class="gi">+        # Maybe something else has added a pack with the object</span>
<span class="gi">+        # in the mean time?</span>
<span class="gi">+        for p in self._update_pack_cache():</span>
<span class="gi">+            for o in p.iterobjects_subset(todo, allow_missing=True):</span>
<span class="gi">+                yield o</span>
<span class="gi">+                todo.remove(o.id)</span>
<span class="gi">+        for alternate in self.alternates:</span>
<span class="gi">+            for o in alternate.iterobjects_subset(todo, allow_missing=True):</span>
<span class="gi">+                yield o</span>
<span class="gi">+                todo.remove(o.id)</span>
<span class="gi">+        for oid in todo:</span>
<span class="gi">+            o = self._get_loose_object(oid)</span>
<span class="gi">+            if o is not None:</span>
<span class="gi">+                yield o</span>
<span class="gi">+            elif not allow_missing:</span>
<span class="gi">+                raise KeyError(oid)</span>
<span class="gi">+</span>
<span class="gi">+    def get_unpacked_object(</span>
<span class="gi">+        self, sha1: bytes, *, include_comp: bool = False</span>
<span class="gi">+    ) -&gt; UnpackedObject:</span>
<span class="w"> </span>        &quot;&quot;&quot;Obtain the unpacked object.

<span class="w"> </span>        Args:
<span class="w"> </span>          sha1: sha for the object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sha1 == ZERO_SHA:</span>
<span class="gi">+            raise KeyError(sha1)</span>
<span class="gi">+        if len(sha1) == 40:</span>
<span class="gi">+            sha = hex_to_sha(sha1)</span>
<span class="gi">+            hexsha = sha1</span>
<span class="gi">+        elif len(sha1) == 20:</span>
<span class="gi">+            sha = sha1</span>
<span class="gi">+            hexsha = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError(f&quot;Invalid object sha1 {sha1!r}&quot;)</span>
<span class="gi">+        for pack in self._iter_cached_packs():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return pack.get_unpacked_object(sha, include_comp=include_comp)</span>
<span class="gi">+            except (KeyError, PackFileDisappeared):</span>
<span class="gi">+                pass</span>
<span class="gi">+        if hexsha is None:</span>
<span class="gi">+            hexsha = sha_to_hex(sha1)</span>
<span class="gi">+        # Maybe something else has added a pack with the object</span>
<span class="gi">+        # in the mean time?</span>
<span class="gi">+        for pack in self._update_pack_cache():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return pack.get_unpacked_object(sha, include_comp=include_comp)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        for alternate in self.alternates:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return alternate.get_unpacked_object(hexsha, include_comp=include_comp)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise KeyError(hexsha)</span>

<span class="gd">-    def add_objects(self, objects: Sequence[Tuple[ShaFile, Optional[str]]],</span>
<span class="gd">-        progress: Optional[Callable[[str], None]]=None) -&gt;None:</span>
<span class="gi">+    def add_objects(</span>
<span class="gi">+        self,</span>
<span class="gi">+        objects: Sequence[Tuple[ShaFile, Optional[str]]],</span>
<span class="gi">+        progress: Optional[Callable[[str], None]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a set of objects to this object store.

<span class="w"> </span>        Args:
<span class="gu">@@ -302,14 +714,17 @@ class PackBasedObjectStore(BaseObjectStore):</span>
<span class="w"> </span>            __len__.
<span class="w"> </span>        Returns: Pack object of the objects written.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        count = len(objects)</span>
<span class="gi">+        record_iter = (full_unpacked_object(o) for (o, p) in objects)</span>
<span class="gi">+        return self.add_pack_data(count, record_iter, progress=progress)</span>


<span class="w"> </span>class DiskObjectStore(PackBasedObjectStore):
<span class="w"> </span>    &quot;&quot;&quot;Git-style object store that exists on disk.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path, loose_compression_level=-1,</span>
<span class="gd">-        pack_compression_level=-1) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, path, loose_compression_level=-1, pack_compression_level=-1</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open an object store.

<span class="w"> </span>        Args:
<span class="gu">@@ -324,16 +739,143 @@ class DiskObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        self.loose_compression_level = loose_compression_level
<span class="w"> </span>        self.pack_compression_level = pack_compression_level

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__}({self.path!r})&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__}({self.path!r})&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_config(cls, path, config):</span>
<span class="gi">+        try:</span>
<span class="gi">+            default_compression_level = int(</span>
<span class="gi">+                config.get((b&quot;core&quot;,), b&quot;compression&quot;).decode()</span>
<span class="gi">+            )</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            default_compression_level = -1</span>
<span class="gi">+        try:</span>
<span class="gi">+            loose_compression_level = int(</span>
<span class="gi">+                config.get((b&quot;core&quot;,), b&quot;looseCompression&quot;).decode()</span>
<span class="gi">+            )</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            loose_compression_level = default_compression_level</span>
<span class="gi">+        try:</span>
<span class="gi">+            pack_compression_level = int(</span>
<span class="gi">+                config.get((b&quot;core&quot;,), &quot;packCompression&quot;).decode()</span>
<span class="gi">+            )</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pack_compression_level = default_compression_level</span>
<span class="gi">+        return cls(path, loose_compression_level, pack_compression_level)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def alternates(self):</span>
<span class="gi">+        if self._alternates is not None:</span>
<span class="gi">+            return self._alternates</span>
<span class="gi">+        self._alternates = []</span>
<span class="gi">+        for path in self._read_alternate_paths():</span>
<span class="gi">+            self._alternates.append(DiskObjectStore(path))</span>
<span class="gi">+        return self._alternates</span>
<span class="gi">+</span>
<span class="gi">+    def _read_alternate_paths(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = GitFile(os.path.join(self.path, INFODIR, &quot;alternates&quot;), &quot;rb&quot;)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return</span>
<span class="gi">+        with f:</span>
<span class="gi">+            for line in f.readlines():</span>
<span class="gi">+                line = line.rstrip(b&quot;\n&quot;)</span>
<span class="gi">+                if line.startswith(b&quot;#&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if os.path.isabs(line):</span>
<span class="gi">+                    yield os.fsdecode(line)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield os.fsdecode(os.path.join(os.fsencode(self.path), line))</span>

<span class="w"> </span>    def add_alternate_path(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Add an alternate path to this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(os.path.join(self.path, INFODIR))</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        alternates_path = os.path.join(self.path, INFODIR, &quot;alternates&quot;)</span>
<span class="gi">+        with GitFile(alternates_path, &quot;wb&quot;) as f:</span>
<span class="gi">+            try:</span>
<span class="gi">+                orig_f = open(alternates_path, &quot;rb&quot;)</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                with orig_f:</span>
<span class="gi">+                    f.write(orig_f.read())</span>
<span class="gi">+            f.write(os.fsencode(path) + b&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not os.path.isabs(path):</span>
<span class="gi">+            path = os.path.join(self.path, path)</span>
<span class="gi">+        self.alternates.append(DiskObjectStore(path))</span>

<span class="w"> </span>    def _update_pack_cache(self):
<span class="w"> </span>        &quot;&quot;&quot;Read and iterate over new pack files and cache them.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            pack_dir_contents = os.listdir(self.pack_dir)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            return []</span>
<span class="gi">+        pack_files = set()</span>
<span class="gi">+        for name in pack_dir_contents:</span>
<span class="gi">+            if name.startswith(&quot;pack-&quot;) and name.endswith(&quot;.pack&quot;):</span>
<span class="gi">+                # verify that idx exists first (otherwise the pack was not yet</span>
<span class="gi">+                # fully written)</span>
<span class="gi">+                idx_name = os.path.splitext(name)[0] + &quot;.idx&quot;</span>
<span class="gi">+                if idx_name in pack_dir_contents:</span>
<span class="gi">+                    pack_name = name[: -len(&quot;.pack&quot;)]</span>
<span class="gi">+                    pack_files.add(pack_name)</span>
<span class="gi">+</span>
<span class="gi">+        # Open newly appeared pack files</span>
<span class="gi">+        new_packs = []</span>
<span class="gi">+        for f in pack_files:</span>
<span class="gi">+            if f not in self._pack_cache:</span>
<span class="gi">+                pack = Pack(os.path.join(self.pack_dir, f))</span>
<span class="gi">+                new_packs.append(pack)</span>
<span class="gi">+                self._pack_cache[f] = pack</span>
<span class="gi">+        # Remove disappeared pack files</span>
<span class="gi">+        for f in set(self._pack_cache) - pack_files:</span>
<span class="gi">+            self._pack_cache.pop(f).close()</span>
<span class="gi">+        return new_packs</span>
<span class="gi">+</span>
<span class="gi">+    def _get_shafile_path(self, sha):</span>
<span class="gi">+        # Check from object dir</span>
<span class="gi">+        return hex_to_filename(self.path, sha)</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_loose_objects(self):</span>
<span class="gi">+        for base in os.listdir(self.path):</span>
<span class="gi">+            if len(base) != 2:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for rest in os.listdir(os.path.join(self.path, base)):</span>
<span class="gi">+                sha = os.fsencode(base + rest)</span>
<span class="gi">+                if not valid_hexsha(sha):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                yield sha</span>
<span class="gi">+</span>
<span class="gi">+    def _get_loose_object(self, sha):</span>
<span class="gi">+        path = self._get_shafile_path(sha)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ShaFile.from_path(path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_loose_object(self, sha):</span>
<span class="gi">+        os.remove(self._get_shafile_path(sha))</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_pack(self, pack):</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._pack_cache[os.path.basename(pack._basename)]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        pack.close()</span>
<span class="gi">+        os.remove(pack.data.path)</span>
<span class="gi">+        os.remove(pack.index.path)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_pack_basepath(self, entries):</span>
<span class="gi">+        suffix = iter_sha1(entry[0] for entry in entries)</span>
<span class="gi">+        # TODO: Handle self.pack_dir being bytes</span>
<span class="gi">+        suffix = suffix.decode(&quot;ascii&quot;)</span>
<span class="gi">+        return os.path.join(self.pack_dir, &quot;pack-&quot; + suffix)</span>

<span class="w"> </span>    def _complete_pack(self, f, path, num_objects, indexer, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Move a specific file containing a pack into the pack directory.
<span class="gu">@@ -346,7 +888,58 @@ class DiskObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>          path: Path to the pack file.
<span class="w"> </span>          indexer: A PackIndexer for indexing the pack.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entries = []</span>
<span class="gi">+        for i, entry in enumerate(indexer):</span>
<span class="gi">+            if progress is not None:</span>
<span class="gi">+                progress(</span>
<span class="gi">+                    (&quot;generating index: %d/%d\r&quot; % (i, num_objects)).encode(&quot;ascii&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            entries.append(entry)</span>
<span class="gi">+</span>
<span class="gi">+        pack_sha, extra_entries = extend_pack(</span>
<span class="gi">+            f,</span>
<span class="gi">+            indexer.ext_refs(),</span>
<span class="gi">+            get_raw=self.get_raw,</span>
<span class="gi">+            compression_level=self.pack_compression_level,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+        )</span>
<span class="gi">+        f.flush()</span>
<span class="gi">+        try:</span>
<span class="gi">+            fileno = f.fileno()</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            os.fsync(fileno)</span>
<span class="gi">+        f.close()</span>
<span class="gi">+</span>
<span class="gi">+        entries.extend(extra_entries)</span>
<span class="gi">+</span>
<span class="gi">+        # Move the pack in.</span>
<span class="gi">+        entries.sort()</span>
<span class="gi">+        pack_base_name = self._get_pack_basepath(entries)</span>
<span class="gi">+</span>
<span class="gi">+        for pack in self.packs:</span>
<span class="gi">+            if pack._basename == pack_base_name:</span>
<span class="gi">+                return pack</span>
<span class="gi">+</span>
<span class="gi">+        target_pack_path = pack_base_name + &quot;.pack&quot;</span>
<span class="gi">+        target_index_path = pack_base_name + &quot;.idx&quot;</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            # Windows might have the target pack file lingering. Attempt</span>
<span class="gi">+            # removal, silently passing if the target does not exist.</span>
<span class="gi">+            with suppress(FileNotFoundError):</span>
<span class="gi">+                os.remove(target_pack_path)</span>
<span class="gi">+        os.rename(path, target_pack_path)</span>
<span class="gi">+</span>
<span class="gi">+        # Write the index.</span>
<span class="gi">+        with GitFile(target_index_path, &quot;wb&quot;, mask=PACK_MODE) as index_file:</span>
<span class="gi">+            write_pack_index(index_file, entries, pack_sha)</span>
<span class="gi">+</span>
<span class="gi">+        # Add the pack to the store and return it.</span>
<span class="gi">+        final_pack = Pack(pack_base_name)</span>
<span class="gi">+        final_pack.check_length_and_checksum()</span>
<span class="gi">+        self._add_cached_pack(pack_base_name, final_pack)</span>
<span class="gi">+        return final_pack</span>

<span class="w"> </span>    def add_thin_pack(self, read_all, read_some, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a new thin pack to this object store.
<span class="gu">@@ -363,7 +956,15 @@ class DiskObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        Returns: A Pack object pointing at the now-completed thin pack in the
<span class="w"> </span>            objects/pack directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import tempfile</span>
<span class="gi">+</span>
<span class="gi">+        fd, path = tempfile.mkstemp(dir=self.path, prefix=&quot;tmp_pack_&quot;)</span>
<span class="gi">+        with os.fdopen(fd, &quot;w+b&quot;) as f:</span>
<span class="gi">+            os.chmod(path, PACK_MODE)</span>
<span class="gi">+            indexer = PackIndexer(f, resolve_ext_ref=self.get_raw)</span>
<span class="gi">+            copier = PackStreamCopier(read_all, read_some, f, delta_iter=indexer)</span>
<span class="gi">+            copier.verify(progress=progress)</span>
<span class="gi">+            return self._complete_pack(f, path, len(copier), indexer, progress=progress)</span>

<span class="w"> </span>    def add_pack(self):
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack to this object store.
<span class="gu">@@ -372,7 +973,30 @@ class DiskObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>            call when the pack is finished and an abort
<span class="w"> </span>            function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import tempfile</span>
<span class="gi">+</span>
<span class="gi">+        fd, path = tempfile.mkstemp(dir=self.pack_dir, suffix=&quot;.pack&quot;)</span>
<span class="gi">+        f = os.fdopen(fd, &quot;w+b&quot;)</span>
<span class="gi">+        os.chmod(path, PACK_MODE)</span>
<span class="gi">+</span>
<span class="gi">+        def commit():</span>
<span class="gi">+            if f.tell() &gt; 0:</span>
<span class="gi">+                f.seek(0)</span>
<span class="gi">+                with PackData(path, f) as pd:</span>
<span class="gi">+                    indexer = PackIndexer.for_pack_data(</span>
<span class="gi">+                        pd, resolve_ext_ref=self.get_raw</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return self._complete_pack(f, path, len(pd), indexer)</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.close()</span>
<span class="gi">+                os.remove(path)</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        def abort():</span>
<span class="gi">+            f.close()</span>
<span class="gi">+            os.remove(path)</span>
<span class="gi">+</span>
<span class="gi">+        return f, commit, abort</span>

<span class="w"> </span>    def add_object(self, obj):
<span class="w"> </span>        &quot;&quot;&quot;Add a single object to this object store.
<span class="gu">@@ -380,24 +1004,53 @@ class DiskObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          obj: Object to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._get_shafile_path(obj.id)</span>
<span class="gi">+        dir = os.path.dirname(path)</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(dir)</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        if os.path.exists(path):</span>
<span class="gi">+            return  # Already there, no need to write again</span>
<span class="gi">+        with GitFile(path, &quot;wb&quot;, mask=PACK_MODE) as f:</span>
<span class="gi">+            f.write(</span>
<span class="gi">+                obj.as_legacy_object(compression_level=self.loose_compression_level)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def init(cls, path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(path)</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        os.mkdir(os.path.join(path, &quot;info&quot;))</span>
<span class="gi">+        os.mkdir(os.path.join(path, PACKDIR))</span>
<span class="gi">+        return cls(path)</span>


<span class="w"> </span>class MemoryObjectStore(BaseObjectStore):
<span class="w"> </span>    &quot;&quot;&quot;Object store that keeps all objects in memory.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._data: Dict[str, ShaFile] = {}
<span class="w"> </span>        self.pack_compression_level = -1

<span class="gi">+    def _to_hexsha(self, sha):</span>
<span class="gi">+        if len(sha) == 40:</span>
<span class="gi">+            return sha</span>
<span class="gi">+        elif len(sha) == 20:</span>
<span class="gi">+            return sha_to_hex(sha)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid sha {sha!r}&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    def contains_loose(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1 and is loose.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._to_hexsha(sha) in self._data</span>

<span class="w"> </span>    def contains_packed(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Check if a particular object is present by SHA1 and is packed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs that are present in this store.&quot;&quot;&quot;
<span class="gu">@@ -406,7 +1059,7 @@ class MemoryObjectStore(BaseObjectStore):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def packs(self):
<span class="w"> </span>        &quot;&quot;&quot;List with pack objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def get_raw(self, name: ObjectID):
<span class="w"> </span>        &quot;&quot;&quot;Obtain the raw text for an object.
<span class="gu">@@ -415,18 +1068,19 @@ class MemoryObjectStore(BaseObjectStore):</span>
<span class="w"> </span>          name: sha for the object.
<span class="w"> </span>        Returns: tuple with numeric type and object contents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = self[self._to_hexsha(name)]</span>
<span class="gi">+        return obj.type_num, obj.as_raw_string()</span>

<span class="w"> </span>    def __getitem__(self, name: ObjectID):
<span class="w"> </span>        return self._data[self._to_hexsha(name)].copy()

<span class="gd">-    def __delitem__(self, name: ObjectID) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name: ObjectID) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete an object from this store, for testing only.&quot;&quot;&quot;
<span class="w"> </span>        del self._data[self._to_hexsha(name)]

<span class="w"> </span>    def add_object(self, obj):
<span class="w"> </span>        &quot;&quot;&quot;Add a single object to this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._data[obj.id] = obj.copy()</span>

<span class="w"> </span>    def add_objects(self, objects, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a set of objects to this object store.
<span class="gu">@@ -434,7 +1088,8 @@ class MemoryObjectStore(BaseObjectStore):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          objects: Iterable over a list of (object, path) tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for obj, path in objects:</span>
<span class="gi">+            self.add_object(obj)</span>

<span class="w"> </span>    def add_pack(self):
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack to this object store.
<span class="gu">@@ -445,17 +1100,37 @@ class MemoryObjectStore(BaseObjectStore):</span>
<span class="w"> </span>        Returns: Fileobject to write to and a commit function to
<span class="w"> </span>            call when the pack is finished.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from tempfile import SpooledTemporaryFile</span>

<span class="gd">-    def add_pack_data(self, count: int, unpacked_objects: Iterator[</span>
<span class="gd">-        UnpackedObject], progress=None) -&gt;None:</span>
<span class="gi">+        f = SpooledTemporaryFile(max_size=PACK_SPOOL_FILE_MAX_SIZE, prefix=&quot;incoming-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def commit():</span>
<span class="gi">+            size = f.tell()</span>
<span class="gi">+            if size &gt; 0:</span>
<span class="gi">+                f.seek(0)</span>
<span class="gi">+                p = PackData.from_file(f, size)</span>
<span class="gi">+                for obj in PackInflater.for_pack_data(p, self.get_raw):</span>
<span class="gi">+                    self.add_object(obj)</span>
<span class="gi">+                p.close()</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.close()</span>
<span class="gi">+</span>
<span class="gi">+        def abort():</span>
<span class="gi">+            f.close()</span>
<span class="gi">+</span>
<span class="gi">+        return f, commit, abort</span>
<span class="gi">+</span>
<span class="gi">+    def add_pack_data(</span>
<span class="gi">+        self, count: int, unpacked_objects: Iterator[UnpackedObject], progress=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add pack data to this object store.

<span class="w"> </span>        Args:
<span class="w"> </span>          count: Number of items to add
<span class="w"> </span>          pack_data: Iterator over pack data tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for unpacked_object in unpacked_objects:</span>
<span class="gi">+            self.add_object(unpacked_object.sha_file())</span>

<span class="w"> </span>    def add_thin_pack(self, read_all, read_some, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a new thin pack to this object store.
<span class="gu">@@ -470,12 +1145,23 @@ class MemoryObjectStore(BaseObjectStore):</span>
<span class="w"> </span>          read_some: Read function that returns at least one byte, but may
<span class="w"> </span>            not return the number of bytes requested.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f, commit, abort = self.add_pack()</span>
<span class="gi">+        try:</span>
<span class="gi">+            copier = PackStreamCopier(read_all, read_some, f)</span>
<span class="gi">+            copier.verify()</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            abort()</span>
<span class="gi">+            raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            commit()</span>


<span class="w"> </span>class ObjectIterator(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;Interface for iterating over objects.&quot;&quot;&quot;

<span class="gi">+    def iterobjects(self) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        raise NotImplementedError(self.iterobjects)</span>
<span class="gi">+</span>

<span class="w"> </span>def tree_lookup_path(lookup_obj, root_sha, path):
<span class="w"> </span>    &quot;&quot;&quot;Look up an object in a Git tree.
<span class="gu">@@ -486,11 +1172,15 @@ def tree_lookup_path(lookup_obj, root_sha, path):</span>
<span class="w"> </span>      path: Path to lookup
<span class="w"> </span>    Returns: A tuple of (mode, SHA) of the resulting path.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tree = lookup_obj(root_sha)</span>
<span class="gi">+    if not isinstance(tree, Tree):</span>
<span class="gi">+        raise NotTreeError(root_sha)</span>
<span class="gi">+    return tree.lookup_path(lookup_obj, path)</span>


<span class="gd">-def _collect_filetree_revs(obj_store: ObjectContainer, tree_sha: ObjectID,</span>
<span class="gd">-    kset: Set[ObjectID]) -&gt;None:</span>
<span class="gi">+def _collect_filetree_revs(</span>
<span class="gi">+    obj_store: ObjectContainer, tree_sha: ObjectID, kset: Set[ObjectID]</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect SHA1s of files and directories for specified tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -498,11 +1188,18 @@ def _collect_filetree_revs(obj_store: ObjectContainer, tree_sha: ObjectID,</span>
<span class="w"> </span>      tree_sha: tree reference to walk
<span class="w"> </span>      kset: set to fill with references to files and directories
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _split_commits_and_tags(obj_store: ObjectContainer, lst, *,</span>
<span class="gd">-    ignore_unknown=False) -&gt;Tuple[Set[bytes], Set[bytes], Set[bytes]]:</span>
<span class="gi">+    filetree = obj_store[tree_sha]</span>
<span class="gi">+    assert isinstance(filetree, Tree)</span>
<span class="gi">+    for name, mode, sha in filetree.iteritems():</span>
<span class="gi">+        if not S_ISGITLINK(mode) and sha not in kset:</span>
<span class="gi">+            kset.add(sha)</span>
<span class="gi">+            if stat.S_ISDIR(mode):</span>
<span class="gi">+                _collect_filetree_revs(obj_store, sha, kset)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _split_commits_and_tags(</span>
<span class="gi">+    obj_store: ObjectContainer, lst, *, ignore_unknown=False</span>
<span class="gi">+) -&gt; Tuple[Set[bytes], Set[bytes], Set[bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split object id list into three lists with commit, tag, and other SHAs.

<span class="w"> </span>    Commits referenced by tags are included into commits
<span class="gu">@@ -517,7 +1214,30 @@ def _split_commits_and_tags(obj_store: ObjectContainer, lst, *,</span>
<span class="w"> </span>        silently.
<span class="w"> </span>    Returns: A tuple of (commits, tags, others) SHA1s
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    commits: Set[bytes] = set()</span>
<span class="gi">+    tags: Set[bytes] = set()</span>
<span class="gi">+    others: Set[bytes] = set()</span>
<span class="gi">+    for e in lst:</span>
<span class="gi">+        try:</span>
<span class="gi">+            o = obj_store[e]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if not ignore_unknown:</span>
<span class="gi">+                raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(o, Commit):</span>
<span class="gi">+                commits.add(e)</span>
<span class="gi">+            elif isinstance(o, Tag):</span>
<span class="gi">+                tags.add(e)</span>
<span class="gi">+                tagged = o.object[1]</span>
<span class="gi">+                c, t, os = _split_commits_and_tags(</span>
<span class="gi">+                    obj_store, [tagged], ignore_unknown=ignore_unknown</span>
<span class="gi">+                )</span>
<span class="gi">+                commits |= c</span>
<span class="gi">+                tags |= t</span>
<span class="gi">+                others |= os</span>
<span class="gi">+            else:</span>
<span class="gi">+                others.add(e)</span>
<span class="gi">+    return (commits, tags, others)</span>


<span class="w"> </span>class MissingObjectFinder:
<span class="gu">@@ -535,76 +1255,130 @@ class MissingObjectFinder:</span>
<span class="w"> </span>      tagged: dict of pointed-to sha -&gt; tag sha for including tags
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, object_store, haves, wants, *, shallow=None,</span>
<span class="gd">-        progress=None, get_tagged=None, get_parents=lambda commit: commit.</span>
<span class="gd">-        parents) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        object_store,</span>
<span class="gi">+        haves,</span>
<span class="gi">+        wants,</span>
<span class="gi">+        *,</span>
<span class="gi">+        shallow=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        get_tagged=None,</span>
<span class="gi">+        get_parents=lambda commit: commit.parents,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.object_store = object_store
<span class="w"> </span>        if shallow is None:
<span class="w"> </span>            shallow = set()
<span class="w"> </span>        self._get_parents = get_parents
<span class="gi">+        # process Commits and Tags differently</span>
<span class="gi">+        # Note, while haves may list commits/tags not available locally,</span>
<span class="gi">+        # and such SHAs would get filtered out by _split_commits_and_tags,</span>
<span class="gi">+        # wants shall list only known SHAs, and otherwise</span>
<span class="gi">+        # _split_commits_and_tags fails with KeyError</span>
<span class="w"> </span>        have_commits, have_tags, have_others = _split_commits_and_tags(
<span class="gd">-            object_store, haves, ignore_unknown=True)</span>
<span class="gi">+            object_store, haves, ignore_unknown=True</span>
<span class="gi">+        )</span>
<span class="w"> </span>        want_commits, want_tags, want_others = _split_commits_and_tags(
<span class="gd">-            object_store, wants, ignore_unknown=False)</span>
<span class="gd">-        all_ancestors = _collect_ancestors(object_store, have_commits,</span>
<span class="gd">-            shallow=shallow, get_parents=self._get_parents)[0]</span>
<span class="gd">-        missing_commits, common_commits = _collect_ancestors(object_store,</span>
<span class="gd">-            want_commits, all_ancestors, shallow=shallow, get_parents=self.</span>
<span class="gd">-            _get_parents)</span>
<span class="gi">+            object_store, wants, ignore_unknown=False</span>
<span class="gi">+        )</span>
<span class="gi">+        # all_ancestors is a set of commits that shall not be sent</span>
<span class="gi">+        # (complete repository up to &#39;haves&#39;)</span>
<span class="gi">+        all_ancestors = _collect_ancestors(</span>
<span class="gi">+            object_store, have_commits, shallow=shallow, get_parents=self._get_parents</span>
<span class="gi">+        )[0]</span>
<span class="gi">+        # all_missing - complete set of commits between haves and wants</span>
<span class="gi">+        # common - commits from all_ancestors we hit into while</span>
<span class="gi">+        # traversing parent hierarchy of wants</span>
<span class="gi">+        missing_commits, common_commits = _collect_ancestors(</span>
<span class="gi">+            object_store,</span>
<span class="gi">+            want_commits,</span>
<span class="gi">+            all_ancestors,</span>
<span class="gi">+            shallow=shallow,</span>
<span class="gi">+            get_parents=self._get_parents,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.remote_has: Set[bytes] = set()
<span class="gi">+        # Now, fill sha_done with commits and revisions of</span>
<span class="gi">+        # files and directories known to be both locally</span>
<span class="gi">+        # and on target. Thus these commits and files</span>
<span class="gi">+        # won&#39;t get selected for fetch</span>
<span class="w"> </span>        for h in common_commits:
<span class="w"> </span>            self.remote_has.add(h)
<span class="w"> </span>            cmt = object_store[h]
<span class="w"> </span>            _collect_filetree_revs(object_store, cmt.tree, self.remote_has)
<span class="gi">+        # record tags we have as visited, too</span>
<span class="w"> </span>        for t in have_tags:
<span class="w"> </span>            self.remote_has.add(t)
<span class="w"> </span>        self.sha_done = set(self.remote_has)
<span class="gd">-        self.objects_to_send: Set[Tuple[ObjectID, Optional[bytes], Optional</span>
<span class="gd">-            [int], bool]] = {(w, None, Commit.type_num, False) for w in</span>
<span class="gd">-            missing_commits}</span>
<span class="gi">+</span>
<span class="gi">+        # in fact, what we &#39;want&#39; is commits, tags, and others</span>
<span class="gi">+        # we&#39;ve found missing</span>
<span class="gi">+        self.objects_to_send: Set[</span>
<span class="gi">+            Tuple[ObjectID, Optional[bytes], Optional[int], bool]</span>
<span class="gi">+        ] = {(w, None, Commit.type_num, False) for w in missing_commits}</span>
<span class="w"> </span>        missing_tags = want_tags.difference(have_tags)
<span class="gd">-        self.objects_to_send.update({(w, None, Tag.type_num, False) for w in</span>
<span class="gd">-            missing_tags})</span>
<span class="gi">+        self.objects_to_send.update(</span>
<span class="gi">+            {(w, None, Tag.type_num, False) for w in missing_tags}</span>
<span class="gi">+        )</span>
<span class="w"> </span>        missing_others = want_others.difference(have_others)
<span class="gd">-        self.objects_to_send.update({(w, None, None, False) for w in</span>
<span class="gd">-            missing_others})</span>
<span class="gi">+        self.objects_to_send.update({(w, None, None, False) for w in missing_others})</span>
<span class="gi">+</span>
<span class="w"> </span>        if progress is None:
<span class="w"> </span>            self.progress = lambda x: None
<span class="w"> </span>        else:
<span class="w"> </span>            self.progress = progress
<span class="w"> </span>        self._tagged = get_tagged and get_tagged() or {}

<span class="gd">-    def __next__(self) -&gt;Tuple[bytes, Optional[PackHint]]:</span>
<span class="gi">+    def get_remote_has(self):</span>
<span class="gi">+        return self.remote_has</span>
<span class="gi">+</span>
<span class="gi">+    def add_todo(</span>
<span class="gi">+        self, entries: Iterable[Tuple[ObjectID, Optional[bytes], Optional[int], bool]]</span>
<span class="gi">+    ):</span>
<span class="gi">+        self.objects_to_send.update([e for e in entries if e[0] not in self.sha_done])</span>
<span class="gi">+</span>
<span class="gi">+    def __next__(self) -&gt; Tuple[bytes, Optional[PackHint]]:</span>
<span class="w"> </span>        while True:
<span class="w"> </span>            if not self.objects_to_send:
<span class="gd">-                self.progress((&#39;counting objects: %d, done.\n&#39; % len(self.</span>
<span class="gd">-                    sha_done)).encode(&#39;ascii&#39;))</span>
<span class="gi">+                self.progress(</span>
<span class="gi">+                    (&quot;counting objects: %d, done.\n&quot; % len(self.sha_done)).encode(</span>
<span class="gi">+                        &quot;ascii&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="w"> </span>                raise StopIteration
<span class="gd">-            sha, name, type_num, leaf = self.objects_to_send.pop()</span>
<span class="gi">+            (sha, name, type_num, leaf) = self.objects_to_send.pop()</span>
<span class="w"> </span>            if sha not in self.sha_done:
<span class="w"> </span>                break
<span class="w"> </span>        if not leaf:
<span class="w"> </span>            o = self.object_store[sha]
<span class="w"> </span>            if isinstance(o, Commit):
<span class="gd">-                self.add_todo([(o.tree, b&#39;&#39;, Tree.type_num, False)])</span>
<span class="gi">+                self.add_todo([(o.tree, b&quot;&quot;, Tree.type_num, False)])</span>
<span class="w"> </span>            elif isinstance(o, Tree):
<span class="gd">-                self.add_todo([(s, n, Blob.type_num if stat.S_ISREG(m) else</span>
<span class="gd">-                    Tree.type_num, not stat.S_ISDIR(m)) for n, m, s in o.</span>
<span class="gd">-                    iteritems() if not S_ISGITLINK(m)])</span>
<span class="gi">+                self.add_todo(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        (</span>
<span class="gi">+                            s,</span>
<span class="gi">+                            n,</span>
<span class="gi">+                            (Blob.type_num if stat.S_ISREG(m) else Tree.type_num),</span>
<span class="gi">+                            not stat.S_ISDIR(m),</span>
<span class="gi">+                        )</span>
<span class="gi">+                        for n, m, s in o.iteritems()</span>
<span class="gi">+                        if not S_ISGITLINK(m)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            elif isinstance(o, Tag):
<span class="gd">-                self.add_todo([(o.object[1], None, o.object[0].type_num, </span>
<span class="gd">-                    False)])</span>
<span class="gi">+                self.add_todo([(o.object[1], None, o.object[0].type_num, False)])</span>
<span class="w"> </span>        if sha in self._tagged:
<span class="w"> </span>            self.add_todo([(self._tagged[sha], None, None, True)])
<span class="w"> </span>        self.sha_done.add(sha)
<span class="w"> </span>        if len(self.sha_done) % 1000 == 0:
<span class="gd">-            self.progress((&#39;counting objects: %d\r&#39; % len(self.sha_done)).</span>
<span class="gd">-                encode(&#39;ascii&#39;))</span>
<span class="gi">+            self.progress(</span>
<span class="gi">+                (&quot;counting objects: %d\r&quot; % len(self.sha_done)).encode(&quot;ascii&quot;)</span>
<span class="gi">+            )</span>
<span class="w"> </span>        if type_num is None:
<span class="w"> </span>            pack_hint = None
<span class="w"> </span>        else:
<span class="gd">-            pack_hint = type_num, name</span>
<span class="gd">-        return sha, pack_hint</span>
<span class="gi">+            pack_hint = (type_num, name)</span>
<span class="gi">+        return (sha, pack_hint)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -618,7 +1392,7 @@ class ObjectStoreGraphWalker:</span>
<span class="w"> </span>      get_parents: Function to retrieve parents in the local repo
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, local_heads, get_parents, shallow=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, local_heads, get_parents, shallow=None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new instance.

<span class="w"> </span>        Args:
<span class="gu">@@ -634,15 +1408,46 @@ class ObjectStoreGraphWalker:</span>

<span class="w"> </span>    def nak(self):
<span class="w"> </span>        &quot;&quot;&quot;Nothing in common was found.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    def ack(self, sha):
<span class="w"> </span>        &quot;&quot;&quot;Ack that a revision and its ancestors are present in the source.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(sha) != 40:</span>
<span class="gi">+            raise ValueError(f&quot;unexpected sha {sha!r} received&quot;)</span>
<span class="gi">+        ancestors = {sha}</span>
<span class="gi">+</span>
<span class="gi">+        # stop if we run out of heads to remove</span>
<span class="gi">+        while self.heads:</span>
<span class="gi">+            for a in ancestors:</span>
<span class="gi">+                if a in self.heads:</span>
<span class="gi">+                    self.heads.remove(a)</span>
<span class="gi">+</span>
<span class="gi">+            # collect all ancestors</span>
<span class="gi">+            new_ancestors = set()</span>
<span class="gi">+            for a in ancestors:</span>
<span class="gi">+                ps = self.parents.get(a)</span>
<span class="gi">+                if ps is not None:</span>
<span class="gi">+                    new_ancestors.update(ps)</span>
<span class="gi">+                self.parents[a] = None</span>
<span class="gi">+</span>
<span class="gi">+            # no more ancestors; stop</span>
<span class="gi">+            if not new_ancestors:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            ancestors = new_ancestors</span>

<span class="w"> </span>    def next(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over ancestors of heads in the target.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.heads:</span>
<span class="gi">+            ret = self.heads.pop()</span>
<span class="gi">+            try:</span>
<span class="gi">+                ps = self.get_parents(ret)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                return None</span>
<span class="gi">+            self.parents[ret] = ps</span>
<span class="gi">+            self.heads.update([p for p in ps if p not in self.parents])</span>
<span class="gi">+            return ret</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next


<span class="gu">@@ -667,16 +1472,57 @@ def commit_tree_changes(object_store, tree, changes):</span>
<span class="w"> </span>      changes: changes to apply
<span class="w"> </span>    Returns: New tree root object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO(jelmer): Save up the objects and add them using .add_objects</span>
<span class="gi">+    # rather than with individual calls to .add_object.</span>
<span class="gi">+    nested_changes = {}</span>
<span class="gi">+    for path, new_mode, new_sha in changes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            (dirname, subpath) = path.split(b&quot;/&quot;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            if new_sha is None:</span>
<span class="gi">+                del tree[path]</span>
<span class="gi">+            else:</span>
<span class="gi">+                tree[path] = (new_mode, new_sha)</span>
<span class="gi">+        else:</span>
<span class="gi">+            nested_changes.setdefault(dirname, []).append((subpath, new_mode, new_sha))</span>
<span class="gi">+    for name, subchanges in nested_changes.items():</span>
<span class="gi">+        try:</span>
<span class="gi">+            orig_subtree = object_store[tree[name][1]]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            orig_subtree = Tree()</span>
<span class="gi">+        subtree = commit_tree_changes(object_store, orig_subtree, subchanges)</span>
<span class="gi">+        if len(subtree) == 0:</span>
<span class="gi">+            del tree[name]</span>
<span class="gi">+        else:</span>
<span class="gi">+            tree[name] = (stat.S_IFDIR, subtree.id)</span>
<span class="gi">+    object_store.add_object(tree)</span>
<span class="gi">+    return tree</span>


<span class="w"> </span>class OverlayObjectStore(BaseObjectStore):
<span class="w"> </span>    &quot;&quot;&quot;Object store that can overlay multiple object stores.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, bases, add_store=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, bases, add_store=None) -&gt; None:</span>
<span class="w"> </span>        self.bases = bases
<span class="w"> </span>        self.add_store = add_store

<span class="gi">+    def add_object(self, object):</span>
<span class="gi">+        if self.add_store is None:</span>
<span class="gi">+            raise NotImplementedError(self.add_object)</span>
<span class="gi">+        return self.add_store.add_object(object)</span>
<span class="gi">+</span>
<span class="gi">+    def add_objects(self, objects, progress=None):</span>
<span class="gi">+        if self.add_store is None:</span>
<span class="gi">+            raise NotImplementedError(self.add_object)</span>
<span class="gi">+        return self.add_store.add_objects(objects, progress)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def packs(self):</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            ret.extend(b.packs)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        done = set()
<span class="w"> </span>        for b in self.bases:
<span class="gu">@@ -685,10 +1531,68 @@ class OverlayObjectStore(BaseObjectStore):</span>
<span class="w"> </span>                    yield o_id
<span class="w"> </span>                    done.add(o_id)

<span class="gi">+    def iterobjects_subset(</span>
<span class="gi">+        self, shas: Iterable[bytes], *, allow_missing: bool = False</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        todo = set(shas)</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            for o in b.iterobjects_subset(todo, allow_missing=True):</span>
<span class="gi">+                yield o</span>
<span class="gi">+                todo.remove(o.id)</span>
<span class="gi">+        if todo and not allow_missing:</span>
<span class="gi">+            raise KeyError(o.id)</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked_subset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        shas: Iterable[bytes],</span>
<span class="gi">+        *,</span>
<span class="gi">+        include_comp=False,</span>
<span class="gi">+        allow_missing: bool = False,</span>
<span class="gi">+        convert_ofs_delta=True,</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        todo = set(shas)</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            for o in b.iter_unpacked_subset(</span>
<span class="gi">+                todo,</span>
<span class="gi">+                include_comp=include_comp,</span>
<span class="gi">+                allow_missing=True,</span>
<span class="gi">+                convert_ofs_delta=convert_ofs_delta,</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield o</span>
<span class="gi">+                todo.remove(o.id)</span>
<span class="gi">+        if todo and not allow_missing:</span>
<span class="gi">+            raise KeyError(o.id)</span>
<span class="gi">+</span>
<span class="gi">+    def get_raw(self, sha_id):</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return b.get_raw(sha_id)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise KeyError(sha_id)</span>
<span class="gi">+</span>
<span class="gi">+    def contains_packed(self, sha):</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            if b.contains_packed(sha):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def contains_loose(self, sha):</span>
<span class="gi">+        for b in self.bases:</span>
<span class="gi">+            if b.contains_loose(sha):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>

<span class="w"> </span>def read_packs_file(f):
<span class="w"> </span>    &quot;&quot;&quot;Yield the packs listed in a packs file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in f.read().splitlines():</span>
<span class="gi">+        if not line:</span>
<span class="gi">+            continue</span>
<span class="gi">+        (kind, name) = line.split(b&quot; &quot;, 1)</span>
<span class="gi">+        if kind != b&quot;P&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield os.fsdecode(name)</span>


<span class="w"> </span>class BucketBasedObjectStore(PackBasedObjectStore):
<span class="gu">@@ -696,8 +1600,42 @@ class BucketBasedObjectStore(PackBasedObjectStore):</span>

<span class="w"> </span>    def _iter_loose_objects(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs of all loose objects.&quot;&quot;&quot;
<span class="gi">+        return iter([])</span>
<span class="gi">+</span>
<span class="gi">+    def _get_loose_object(self, sha):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_loose_object(self, sha):</span>
<span class="gi">+        # Doesn&#39;t exist..</span>
<span class="w"> </span>        pass

<span class="gi">+    def _remove_pack(self, name):</span>
<span class="gi">+        raise NotImplementedError(self._remove_pack)</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_pack_names(self):</span>
<span class="gi">+        raise NotImplementedError(self._iter_pack_names)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_pack(self, name):</span>
<span class="gi">+        raise NotImplementedError(self._get_pack)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_pack_cache(self):</span>
<span class="gi">+        pack_files = set(self._iter_pack_names())</span>
<span class="gi">+</span>
<span class="gi">+        # Open newly appeared pack files</span>
<span class="gi">+        new_packs = []</span>
<span class="gi">+        for f in pack_files:</span>
<span class="gi">+            if f not in self._pack_cache:</span>
<span class="gi">+                pack = self._get_pack(f)</span>
<span class="gi">+                new_packs.append(pack)</span>
<span class="gi">+                self._pack_cache[f] = pack</span>
<span class="gi">+        # Remove disappeared pack files</span>
<span class="gi">+        for f in set(self._pack_cache) - pack_files:</span>
<span class="gi">+            self._pack_cache.pop(f).close()</span>
<span class="gi">+        return new_packs</span>
<span class="gi">+</span>
<span class="gi">+    def _upload_pack(self, basename, pack_file, index_file):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>    def add_pack(self):
<span class="w"> </span>        &quot;&quot;&quot;Add a new pack to this object store.

<span class="gu">@@ -705,12 +1643,50 @@ class BucketBasedObjectStore(PackBasedObjectStore):</span>
<span class="w"> </span>            call when the pack is finished and an abort
<span class="w"> </span>            function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _collect_ancestors(store: ObjectContainer, heads, common: FrozenSet[</span>
<span class="gd">-    ObjectID]=frozenset(), shallow: FrozenSet[ObjectID]=frozenset(),</span>
<span class="gd">-    get_parents=lambda commit: commit.parents):</span>
<span class="gi">+        import tempfile</span>
<span class="gi">+</span>
<span class="gi">+        pf = tempfile.SpooledTemporaryFile(</span>
<span class="gi">+            max_size=PACK_SPOOL_FILE_MAX_SIZE, prefix=&quot;incoming-&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def commit():</span>
<span class="gi">+            if pf.tell() == 0:</span>
<span class="gi">+                pf.close()</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            pf.seek(0)</span>
<span class="gi">+            p = PackData(pf.name, pf)</span>
<span class="gi">+            entries = p.sorted_entries()</span>
<span class="gi">+            basename = iter_sha1(entry[0] for entry in entries).decode(&quot;ascii&quot;)</span>
<span class="gi">+            idxf = tempfile.SpooledTemporaryFile(</span>
<span class="gi">+                max_size=PACK_SPOOL_FILE_MAX_SIZE, prefix=&quot;incoming-&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            checksum = p.get_stored_checksum()</span>
<span class="gi">+            write_pack_index(idxf, entries, checksum)</span>
<span class="gi">+            idxf.seek(0)</span>
<span class="gi">+            idx = load_pack_index_file(basename + &quot;.idx&quot;, idxf)</span>
<span class="gi">+            for pack in self.packs:</span>
<span class="gi">+                if pack.get_stored_checksum() == p.get_stored_checksum():</span>
<span class="gi">+                    p.close()</span>
<span class="gi">+                    idx.close()</span>
<span class="gi">+                    return pack</span>
<span class="gi">+            pf.seek(0)</span>
<span class="gi">+            idxf.seek(0)</span>
<span class="gi">+            self._upload_pack(basename, pf, idxf)</span>
<span class="gi">+            final_pack = Pack.from_objects(p, idx)</span>
<span class="gi">+            self._add_cached_pack(basename, final_pack)</span>
<span class="gi">+            return final_pack</span>
<span class="gi">+</span>
<span class="gi">+        return pf, commit, pf.close</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _collect_ancestors(</span>
<span class="gi">+    store: ObjectContainer,</span>
<span class="gi">+    heads,</span>
<span class="gi">+    common: FrozenSet[ObjectID] = frozenset(),</span>
<span class="gi">+    shallow: FrozenSet[ObjectID] = frozenset(),</span>
<span class="gi">+    get_parents=lambda commit: commit.parents,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Collect all ancestors of heads up to (excluding) those in common.

<span class="w"> </span>    Args:
<span class="gu">@@ -723,11 +1699,26 @@ def _collect_ancestors(store: ObjectContainer, heads, common: FrozenSet[</span>
<span class="w"> </span>        from heads but not present in common, B - common (shared) elements
<span class="w"> </span>        that are directly reachable from heads
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def iter_tree_contents(store: ObjectContainer, tree_id: Optional[ObjectID],</span>
<span class="gd">-    *, include_trees: bool=False):</span>
<span class="gi">+    bases = set()</span>
<span class="gi">+    commits = set()</span>
<span class="gi">+    queue = []</span>
<span class="gi">+    queue.extend(heads)</span>
<span class="gi">+    while queue:</span>
<span class="gi">+        e = queue.pop(0)</span>
<span class="gi">+        if e in common:</span>
<span class="gi">+            bases.add(e)</span>
<span class="gi">+        elif e not in commits:</span>
<span class="gi">+            commits.add(e)</span>
<span class="gi">+            if e in shallow:</span>
<span class="gi">+                continue</span>
<span class="gi">+            cmt = store[e]</span>
<span class="gi">+            queue.extend(get_parents(cmt))</span>
<span class="gi">+    return (commits, bases)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def iter_tree_contents(</span>
<span class="gi">+    store: ObjectContainer, tree_id: Optional[ObjectID], *, include_trees: bool = False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate the contents of a tree and all subtrees.

<span class="w"> </span>    Iteration is depth-first pre-order, as in e.g. os.walk.
<span class="gu">@@ -738,10 +1729,25 @@ def iter_tree_contents(store: ObjectContainer, tree_id: Optional[ObjectID],</span>
<span class="w"> </span>    Returns: Iterator over TreeEntry namedtuples for all the objects in a
<span class="w"> </span>        tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def peel_sha(store: ObjectContainer, sha: bytes) -&gt;Tuple[ShaFile, ShaFile]:</span>
<span class="gi">+    if tree_id is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    # This could be fairly easily generalized to &gt;2 trees if we find a use</span>
<span class="gi">+    # case.</span>
<span class="gi">+    todo = [TreeEntry(b&quot;&quot;, stat.S_IFDIR, tree_id)]</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        entry = todo.pop()</span>
<span class="gi">+        if stat.S_ISDIR(entry.mode):</span>
<span class="gi">+            extra = []</span>
<span class="gi">+            tree = store[entry.sha]</span>
<span class="gi">+            assert isinstance(tree, Tree)</span>
<span class="gi">+            for subentry in tree.iteritems(name_order=True):</span>
<span class="gi">+                extra.append(subentry.in_path(entry.path))</span>
<span class="gi">+            todo.extend(reversed(extra))</span>
<span class="gi">+        if not stat.S_ISDIR(entry.mode) or include_trees:</span>
<span class="gi">+            yield entry</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def peel_sha(store: ObjectContainer, sha: bytes) -&gt; Tuple[ShaFile, ShaFile]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Peel all tags from a SHA.

<span class="w"> </span>    Args:
<span class="gu">@@ -750,4 +1756,10 @@ def peel_sha(store: ObjectContainer, sha: bytes) -&gt;Tuple[ShaFile, ShaFile]:</span>
<span class="w"> </span>        intermediate tags; if the original ref does not point to a tag,
<span class="w"> </span>        this will equal the original SHA1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unpeeled = obj = store[sha]</span>
<span class="gi">+    obj_class = object_class(obj.type_name)</span>
<span class="gi">+    while obj_class is Tag:</span>
<span class="gi">+        assert isinstance(obj, Tag)</span>
<span class="gi">+        obj_class, sha = obj.object</span>
<span class="gi">+        obj = store[sha]</span>
<span class="gi">+    return unpeeled, obj</span>
<span class="gh">diff --git a/dulwich/objects.py b/dulwich/objects.py</span>
<span class="gh">index c6f09b4f..04e39250 100644</span>
<span class="gd">--- a/dulwich/objects.py</span>
<span class="gi">+++ b/dulwich/objects.py</span>
<span class="gu">@@ -1,4 +1,26 @@</span>
<span class="gi">+# objects.py -- Access to base git objects</span>
<span class="gi">+# Copyright (C) 2007 James Westby &lt;jw+debian@jameswestby.net&gt;</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Access to base git objects.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="gu">@@ -8,26 +30,59 @@ import zlib</span>
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from io import BytesIO
<span class="gd">-from typing import TYPE_CHECKING, BinaryIO, Dict, Iterable, Iterator, List, Optional, Tuple, Type, Union</span>
<span class="gd">-from .errors import ChecksumMismatch, FileFormatException, NotBlobError, NotCommitError, NotTagError, NotTreeError, ObjectFormatException</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    BinaryIO,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+from .errors import (</span>
<span class="gi">+    ChecksumMismatch,</span>
<span class="gi">+    FileFormatException,</span>
<span class="gi">+    NotBlobError,</span>
<span class="gi">+    NotCommitError,</span>
<span class="gi">+    NotTagError,</span>
<span class="gi">+    NotTreeError,</span>
<span class="gi">+    ObjectFormatException,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .file import GitFile
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from _hashlib import HASH
<span class="gd">-ZERO_SHA = b&#39;0&#39; * 40</span>
<span class="gd">-_TREE_HEADER = b&#39;tree&#39;</span>
<span class="gd">-_PARENT_HEADER = b&#39;parent&#39;</span>
<span class="gd">-_AUTHOR_HEADER = b&#39;author&#39;</span>
<span class="gd">-_COMMITTER_HEADER = b&#39;committer&#39;</span>
<span class="gd">-_ENCODING_HEADER = b&#39;encoding&#39;</span>
<span class="gd">-_MERGETAG_HEADER = b&#39;mergetag&#39;</span>
<span class="gd">-_GPGSIG_HEADER = b&#39;gpgsig&#39;</span>
<span class="gd">-_OBJECT_HEADER = b&#39;object&#39;</span>
<span class="gd">-_TYPE_HEADER = b&#39;type&#39;</span>
<span class="gd">-_TAG_HEADER = b&#39;tag&#39;</span>
<span class="gd">-_TAGGER_HEADER = b&#39;tagger&#39;</span>
<span class="gd">-S_IFGITLINK = 57344</span>
<span class="gd">-MAX_TIME = 9223372036854775807</span>
<span class="gd">-BEGIN_PGP_SIGNATURE = b&#39;-----BEGIN PGP SIGNATURE-----&#39;</span>
<span class="gi">+</span>
<span class="gi">+ZERO_SHA = b&quot;0&quot; * 40</span>
<span class="gi">+</span>
<span class="gi">+# Header fields for commits</span>
<span class="gi">+_TREE_HEADER = b&quot;tree&quot;</span>
<span class="gi">+_PARENT_HEADER = b&quot;parent&quot;</span>
<span class="gi">+_AUTHOR_HEADER = b&quot;author&quot;</span>
<span class="gi">+_COMMITTER_HEADER = b&quot;committer&quot;</span>
<span class="gi">+_ENCODING_HEADER = b&quot;encoding&quot;</span>
<span class="gi">+_MERGETAG_HEADER = b&quot;mergetag&quot;</span>
<span class="gi">+_GPGSIG_HEADER = b&quot;gpgsig&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Header fields for objects</span>
<span class="gi">+_OBJECT_HEADER = b&quot;object&quot;</span>
<span class="gi">+_TYPE_HEADER = b&quot;type&quot;</span>
<span class="gi">+_TAG_HEADER = b&quot;tag&quot;</span>
<span class="gi">+_TAGGER_HEADER = b&quot;tagger&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+S_IFGITLINK = 0o160000</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MAX_TIME = 9223372036854775807  # (2**63) - 1 - signed long int max</span>
<span class="gi">+</span>
<span class="gi">+BEGIN_PGP_SIGNATURE = b&quot;-----BEGIN PGP SIGNATURE-----&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>ObjectID = bytes


<span class="gu">@@ -42,40 +97,93 @@ def S_ISGITLINK(m):</span>
<span class="w"> </span>      m: Mode to check
<span class="w"> </span>    Returns: a ``boolean``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return stat.S_IFMT(m) == S_IFGITLINK</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _decompress(string):</span>
<span class="gi">+    dcomp = zlib.decompressobj()</span>
<span class="gi">+    dcomped = dcomp.decompress(string)</span>
<span class="gi">+    dcomped += dcomp.flush()</span>
<span class="gi">+    return dcomped</span>


<span class="w"> </span>def sha_to_hex(sha):
<span class="w"> </span>    &quot;&quot;&quot;Takes a string and returns the hex of the sha within.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hexsha = binascii.hexlify(sha)</span>
<span class="gi">+    assert len(hexsha) == 40, f&quot;Incorrect length of sha1 string: {hexsha!r}&quot;</span>
<span class="gi">+    return hexsha</span>


<span class="w"> </span>def hex_to_sha(hex):
<span class="w"> </span>    &quot;&quot;&quot;Takes a hex sha and returns a binary sha.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert len(hex) == 40, f&quot;Incorrect length of hexsha: {hex}&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        return binascii.unhexlify(hex)</span>
<span class="gi">+    except TypeError as exc:</span>
<span class="gi">+        if not isinstance(hex, bytes):</span>
<span class="gi">+            raise</span>
<span class="gi">+        raise ValueError(exc.args[0]) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def valid_hexsha(hex):</span>
<span class="gi">+    if len(hex) != 40:</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        binascii.unhexlify(hex)</span>
<span class="gi">+    except (TypeError, binascii.Error):</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True</span>


<span class="w"> </span>def hex_to_filename(path, hex):
<span class="w"> </span>    &quot;&quot;&quot;Takes a hex sha and returns its filename relative to the given path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # os.path.join accepts bytes or unicode, but all args must be of the same</span>
<span class="gi">+    # type. Make sure that hex which is expected to be bytes, is the same type</span>
<span class="gi">+    # as path.</span>
<span class="gi">+    if type(path) is not type(hex) and getattr(path, &quot;encode&quot;, None) is not None:</span>
<span class="gi">+        hex = hex.decode(&quot;ascii&quot;)</span>
<span class="gi">+    dir = hex[:2]</span>
<span class="gi">+    file = hex[2:]</span>
<span class="gi">+    # Check from object dir</span>
<span class="gi">+    return os.path.join(path, dir, file)</span>


<span class="w"> </span>def filename_to_hex(filename):
<span class="w"> </span>    &quot;&quot;&quot;Takes an object filename and returns its corresponding hex sha.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def object_header(num_type: int, length: int) -&gt;bytes:</span>
<span class="gi">+    # grab the last (up to) two path components</span>
<span class="gi">+    names = filename.rsplit(os.path.sep, 2)[-2:]</span>
<span class="gi">+    errmsg = f&quot;Invalid object filename: {filename}&quot;</span>
<span class="gi">+    assert len(names) == 2, errmsg</span>
<span class="gi">+    base, rest = names</span>
<span class="gi">+    assert len(base) == 2 and len(rest) == 38, errmsg</span>
<span class="gi">+    hex = (base + rest).encode(&quot;ascii&quot;)</span>
<span class="gi">+    hex_to_sha(hex)</span>
<span class="gi">+    return hex</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def object_header(num_type: int, length: int) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an object header for the given numeric type and text length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cls = object_class(num_type)</span>
<span class="gi">+    if cls is None:</span>
<span class="gi">+        raise AssertionError(&quot;unsupported class type num: %d&quot; % num_type)</span>
<span class="gi">+    return cls.type_name + b&quot; &quot; + str(length).encode(&quot;ascii&quot;) + b&quot;\0&quot;</span>


<span class="gd">-def serializable_property(name: str, docstring: Optional[str]=None):</span>
<span class="gi">+def serializable_property(name: str, docstring: Optional[str] = None):</span>
<span class="w"> </span>    &quot;&quot;&quot;A property that helps tracking whether serialization is necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def set(obj, value):</span>
<span class="gi">+        setattr(obj, &quot;_&quot; + name, value)</span>
<span class="gi">+        obj._needs_serialization = True</span>
<span class="gi">+</span>
<span class="gi">+    def get(obj):</span>
<span class="gi">+        return getattr(obj, &quot;_&quot; + name)</span>

<span class="gd">-def object_class(type: Union[bytes, int]) -&gt;Optional[Type[&#39;ShaFile&#39;]]:</span>
<span class="gi">+    return property(get, set, doc=docstring)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def object_class(type: Union[bytes, int]) -&gt; Optional[Type[&quot;ShaFile&quot;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the object class corresponding to the given type.

<span class="w"> </span>    Args:
<span class="gu">@@ -83,7 +191,7 @@ def object_class(type: Union[bytes, int]) -&gt;Optional[Type[&#39;ShaFile&#39;]]:</span>
<span class="w"> </span>    Returns: The ShaFile subclass corresponding to the given type, or None if
<span class="w"> </span>        type is not a valid type name/number.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _TYPE_MAP.get(type, None)</span>


<span class="w"> </span>def check_hexsha(hex, error_msg):
<span class="gu">@@ -95,10 +203,11 @@ def check_hexsha(hex, error_msg):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ObjectFormatException: Raised when the string is not valid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not valid_hexsha(hex):</span>
<span class="gi">+        raise ObjectFormatException(f&quot;{error_msg} {hex}&quot;)</span>


<span class="gd">-def check_identity(identity: bytes, error_msg: str) -&gt;None:</span>
<span class="gi">+def check_identity(identity: bytes, error_msg: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the specified identity is valid.

<span class="w"> </span>    This will raise an exception if the identity is not valid.
<span class="gu">@@ -107,7 +216,19 @@ def check_identity(identity: bytes, error_msg: str) -&gt;None:</span>
<span class="w"> </span>      identity: Identity string
<span class="w"> </span>      error_msg: Error message to use in exception
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    email_start = identity.find(b&quot;&lt;&quot;)</span>
<span class="gi">+    email_end = identity.find(b&quot;&gt;&quot;)</span>
<span class="gi">+    if not all(</span>
<span class="gi">+        [</span>
<span class="gi">+            email_start &gt;= 1,</span>
<span class="gi">+            identity[email_start - 1] == b&quot; &quot;[0],</span>
<span class="gi">+            identity.find(b&quot;&lt;&quot;, email_start + 1) == -1,</span>
<span class="gi">+            email_end == len(identity) - 1,</span>
<span class="gi">+            b&quot;\0&quot; not in identity,</span>
<span class="gi">+            b&quot;\n&quot; not in identity,</span>
<span class="gi">+        ]</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise ObjectFormatException(error_msg)</span>


<span class="w"> </span>def check_time(time_seconds):
<span class="gu">@@ -119,80 +240,120 @@ def check_time(time_seconds):</span>
<span class="w"> </span>      time_seconds: time in seconds

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Prevent overflow error</span>
<span class="gi">+    if time_seconds &gt; MAX_TIME:</span>
<span class="gi">+        raise ObjectFormatException(f&quot;Date field should not exceed {MAX_TIME}&quot;)</span>


<span class="w"> </span>def git_line(*items):
<span class="w"> </span>    &quot;&quot;&quot;Formats items into a space separated line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return b&quot; &quot;.join(items) + b&quot;\n&quot;</span>


<span class="w"> </span>class FixedSha:
<span class="w"> </span>    &quot;&quot;&quot;SHA object that behaves like hashlib&#39;s but is given a fixed value.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_hexsha&#39;, &#39;_sha&#39;</span>

<span class="gd">-    def __init__(self, hexsha) -&gt;None:</span>
<span class="gd">-        if getattr(hexsha, &#39;encode&#39;, None) is not None:</span>
<span class="gd">-            hexsha = hexsha.encode(&#39;ascii&#39;)</span>
<span class="gi">+    __slots__ = (&quot;_hexsha&quot;, &quot;_sha&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, hexsha) -&gt; None:</span>
<span class="gi">+        if getattr(hexsha, &quot;encode&quot;, None) is not None:</span>
<span class="gi">+            hexsha = hexsha.encode(&quot;ascii&quot;)</span>
<span class="w"> </span>        if not isinstance(hexsha, bytes):
<span class="gd">-            raise TypeError(f&#39;Expected bytes for hexsha, got {hexsha!r}&#39;)</span>
<span class="gi">+            raise TypeError(f&quot;Expected bytes for hexsha, got {hexsha!r}&quot;)</span>
<span class="w"> </span>        self._hexsha = hexsha
<span class="w"> </span>        self._sha = hex_to_sha(hexsha)

<span class="gd">-    def digest(self) -&gt;bytes:</span>
<span class="gi">+    def digest(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the raw SHA digest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._sha</span>

<span class="gd">-    def hexdigest(self) -&gt;str:</span>
<span class="gi">+    def hexdigest(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the hex SHA digest.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._hexsha.decode(&quot;ascii&quot;)</span>


<span class="w"> </span>class ShaFile:
<span class="w"> </span>    &quot;&quot;&quot;A git SHA file.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_chunked_text&#39;, &#39;_sha&#39;, &#39;_needs_serialization&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_chunked_text&quot;, &quot;_sha&quot;, &quot;_needs_serialization&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    _needs_serialization: bool
<span class="w"> </span>    type_name: bytes
<span class="w"> </span>    type_num: int
<span class="w"> </span>    _chunked_text: Optional[List[bytes]]
<span class="gd">-    _sha: Union[FixedSha, None, &#39;HASH&#39;]</span>
<span class="gi">+    _sha: Union[FixedSha, None, &quot;HASH&quot;]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _parse_legacy_object_header(magic, f: BinaryIO) -&gt;&#39;ShaFile&#39;:</span>
<span class="gi">+    def _parse_legacy_object_header(magic, f: BinaryIO) -&gt; &quot;ShaFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a legacy object, creating it but not reading the file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _parse_legacy_object(self, map) -&gt;None:</span>
<span class="gi">+        bufsize = 1024</span>
<span class="gi">+        decomp = zlib.decompressobj()</span>
<span class="gi">+        header = decomp.decompress(magic)</span>
<span class="gi">+        start = 0</span>
<span class="gi">+        end = -1</span>
<span class="gi">+        while end &lt; 0:</span>
<span class="gi">+            extra = f.read(bufsize)</span>
<span class="gi">+            header += decomp.decompress(extra)</span>
<span class="gi">+            magic += extra</span>
<span class="gi">+            end = header.find(b&quot;\0&quot;, start)</span>
<span class="gi">+            start = len(header)</span>
<span class="gi">+        header = header[:end]</span>
<span class="gi">+        type_name, size = header.split(b&quot; &quot;, 1)</span>
<span class="gi">+        try:</span>
<span class="gi">+            int(size)  # sanity check</span>
<span class="gi">+        except ValueError as exc:</span>
<span class="gi">+            raise ObjectFormatException(f&quot;Object size not an integer: {exc}&quot;) from exc</span>
<span class="gi">+        obj_class = object_class(type_name)</span>
<span class="gi">+        if not obj_class:</span>
<span class="gi">+            raise ObjectFormatException(</span>
<span class="gi">+                &quot;Not a known type: {}&quot;.format(type_name.decode(&quot;ascii&quot;))</span>
<span class="gi">+            )</span>
<span class="gi">+        return obj_class()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_legacy_object(self, map) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a legacy object, setting the raw string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text = _decompress(map)</span>
<span class="gi">+        header_end = text.find(b&quot;\0&quot;)</span>
<span class="gi">+        if header_end &lt; 0:</span>
<span class="gi">+            raise ObjectFormatException(&quot;Invalid object header, no \\0&quot;)</span>
<span class="gi">+        self.set_raw_string(text[header_end + 1 :])</span>

<span class="gd">-    def as_legacy_object_chunks(self, compression_level: int=-1) -&gt;Iterator[</span>
<span class="gd">-        bytes]:</span>
<span class="gi">+    def as_legacy_object_chunks(self, compression_level: int = -1) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return chunks representing the object in the experimental format.

<span class="w"> </span>        Returns: List of strings
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        compobj = zlib.compressobj(compression_level)</span>
<span class="gi">+        yield compobj.compress(self._header())</span>
<span class="gi">+        for chunk in self.as_raw_chunks():</span>
<span class="gi">+            yield compobj.compress(chunk)</span>
<span class="gi">+        yield compobj.flush()</span>

<span class="gd">-    def as_legacy_object(self, compression_level: int=-1) -&gt;bytes:</span>
<span class="gi">+    def as_legacy_object(self, compression_level: int = -1) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return string representing the object in the experimental format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return b&quot;&quot;.join(</span>
<span class="gi">+            self.as_legacy_object_chunks(compression_level=compression_level)</span>
<span class="gi">+        )</span>

<span class="gd">-    def as_raw_chunks(self) -&gt;List[bytes]:</span>
<span class="gi">+    def as_raw_chunks(self) -&gt; List[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return chunks with serialization of the object.

<span class="w"> </span>        Returns: List of strings, not necessarily one per line
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._needs_serialization:</span>
<span class="gi">+            self._sha = None</span>
<span class="gi">+            self._chunked_text = self._serialize()</span>
<span class="gi">+            self._needs_serialization = False</span>
<span class="gi">+        return self._chunked_text  # type: ignore</span>

<span class="gd">-    def as_raw_string(self) -&gt;bytes:</span>
<span class="gi">+    def as_raw_string(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return raw string with serialization of the object.

<span class="w"> </span>        Returns: String object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return b&quot;&quot;.join(self.as_raw_chunks())</span>

<span class="gd">-    def __bytes__(self) -&gt;bytes:</span>
<span class="gi">+    def __bytes__(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return raw string serialization of this object.&quot;&quot;&quot;
<span class="w"> </span>        return self.as_raw_string()

<span class="gu">@@ -200,43 +361,97 @@ class ShaFile:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return unique hash for this object.&quot;&quot;&quot;
<span class="w"> </span>        return hash(self.id)

<span class="gd">-    def as_pretty_string(self) -&gt;str:</span>
<span class="gi">+    def as_pretty_string(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string representing this object, fit for display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.as_raw_string().decode(&quot;utf-8&quot;, &quot;replace&quot;)</span>

<span class="gd">-    def set_raw_string(self, text: bytes, sha: Optional[ObjectID]=None) -&gt;None:</span>
<span class="gi">+    def set_raw_string(self, text: bytes, sha: Optional[ObjectID] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the contents of this object from a serialized string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(text, bytes):</span>
<span class="gi">+            raise TypeError(f&quot;Expected bytes for text, got {text!r}&quot;)</span>
<span class="gi">+        self.set_raw_chunks([text], sha)</span>

<span class="gd">-    def set_raw_chunks(self, chunks: List[bytes], sha: Optional[ObjectID]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def set_raw_chunks(</span>
<span class="gi">+        self, chunks: List[bytes], sha: Optional[ObjectID] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the contents of this object from a list of chunks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._chunked_text = chunks</span>
<span class="gi">+        self._deserialize(chunks)</span>
<span class="gi">+        if sha is None:</span>
<span class="gi">+            self._sha = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._sha = FixedSha(sha)  # type: ignore</span>
<span class="gi">+        self._needs_serialization = False</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parse_object_header(magic, f):
<span class="w"> </span>        &quot;&quot;&quot;Parse a new style object, creating it but not reading the file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        num_type = (ord(magic[0:1]) &gt;&gt; 4) &amp; 7</span>
<span class="gi">+        obj_class = object_class(num_type)</span>
<span class="gi">+        if not obj_class:</span>
<span class="gi">+            raise ObjectFormatException(&quot;Not a known type %d&quot; % num_type)</span>
<span class="gi">+        return obj_class()</span>

<span class="gd">-    def _parse_object(self, map) -&gt;None:</span>
<span class="gi">+    def _parse_object(self, map) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a new style object, setting self._text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # skip type and size; type must have already been determined, and</span>
<span class="gi">+        # we trust zlib to fail if it&#39;s otherwise corrupted</span>
<span class="gi">+        byte = ord(map[0:1])</span>
<span class="gi">+        used = 1</span>
<span class="gi">+        while (byte &amp; 0x80) != 0:</span>
<span class="gi">+            byte = ord(map[used : used + 1])</span>
<span class="gi">+            used += 1</span>
<span class="gi">+        raw = map[used:]</span>
<span class="gi">+        self.set_raw_string(_decompress(raw))</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _is_legacy_object(cls, magic: bytes) -&gt; bool:</span>
<span class="gi">+        b0 = ord(magic[0:1])</span>
<span class="gi">+        b1 = ord(magic[1:2])</span>
<span class="gi">+        word = (b0 &lt;&lt; 8) + b1</span>
<span class="gi">+        return (b0 &amp; 0x8F) == 0x08 and (word % 31) == 0</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _parse_file(cls, f):</span>
<span class="gi">+        map = f.read()</span>
<span class="gi">+        if not map:</span>
<span class="gi">+            raise EmptyFileException(&quot;Corrupted empty file detected&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if cls._is_legacy_object(map):</span>
<span class="gi">+            obj = cls._parse_legacy_object_header(map, f)</span>
<span class="gi">+            obj._parse_legacy_object(map)</span>
<span class="gi">+        else:</span>
<span class="gi">+            obj = cls._parse_object_header(map, f)</span>
<span class="gi">+            obj._parse_object(map)</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t call this directly.&quot;&quot;&quot;
<span class="w"> </span>        self._sha = None
<span class="w"> </span>        self._chunked_text = []
<span class="w"> </span>        self._needs_serialization = True

<span class="gi">+    def _deserialize(self, chunks: List[bytes]) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(self._deserialize)</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self) -&gt; List[bytes]:</span>
<span class="gi">+        raise NotImplementedError(self._serialize)</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_path(cls, path):
<span class="w"> </span>        &quot;&quot;&quot;Open a SHA file from disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with GitFile(path, &quot;rb&quot;) as f:</span>
<span class="gi">+            return cls.from_file(f)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_file(cls, f):
<span class="w"> </span>        &quot;&quot;&quot;Get the contents of a SHA file on disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = cls._parse_file(f)</span>
<span class="gi">+            obj._sha = None</span>
<span class="gi">+            return obj</span>
<span class="gi">+        except (IndexError, ValueError) as exc:</span>
<span class="gi">+            raise ObjectFormatException(&quot;invalid object header&quot;) from exc</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_raw_string(type_num, string, sha=None):
<span class="gu">@@ -247,11 +462,17 @@ class ShaFile:</span>
<span class="w"> </span>          string: The raw uncompressed contents.
<span class="w"> </span>          sha: Optional known sha for the object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = object_class(type_num)</span>
<span class="gi">+        if cls is None:</span>
<span class="gi">+            raise AssertionError(&quot;unsupported class type num: %d&quot; % type_num)</span>
<span class="gi">+        obj = cls()</span>
<span class="gi">+        obj.set_raw_string(string, sha)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def from_raw_chunks(type_num: int, chunks: List[bytes], sha: Optional[</span>
<span class="gd">-        ObjectID]=None):</span>
<span class="gi">+    def from_raw_chunks(</span>
<span class="gi">+        type_num: int, chunks: List[bytes], sha: Optional[ObjectID] = None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates an object of the indicated type from the raw chunks given.

<span class="w"> </span>        Args:
<span class="gu">@@ -259,12 +480,19 @@ class ShaFile:</span>
<span class="w"> </span>          chunks: An iterable of the raw uncompressed contents.
<span class="w"> </span>          sha: Optional known sha for the object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = object_class(type_num)</span>
<span class="gi">+        if cls is None:</span>
<span class="gi">+            raise AssertionError(&quot;unsupported class type num: %d&quot; % type_num)</span>
<span class="gi">+        obj = cls()</span>
<span class="gi">+        obj.set_raw_chunks(chunks, sha)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_string(cls, string):
<span class="w"> </span>        &quot;&quot;&quot;Create a ShaFile from a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj = cls()</span>
<span class="gi">+        obj.set_raw_string(string)</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>    def _check_has_member(self, member, error_msg):
<span class="w"> </span>        &quot;&quot;&quot;Check that the object has a given member variable.
<span class="gu">@@ -276,9 +504,10 @@ class ShaFile:</span>
<span class="w"> </span>          ObjectFormatException: with the given error_msg if member is
<span class="w"> </span>            missing or is None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if getattr(self, member, None) is None:</span>
<span class="gi">+            raise ObjectFormatException(error_msg)</span>

<span class="gd">-    def check(self) -&gt;None:</span>
<span class="gi">+    def check(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check this object for internal consistency.

<span class="w"> </span>        Raises:
<span class="gu">@@ -286,27 +515,52 @@ class ShaFile:</span>
<span class="w"> </span>          ChecksumMismatch: if the object was created with a SHA that does
<span class="w"> </span>            not match its contents
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def raw_length(self) -&gt;int:</span>
<span class="gi">+        # TODO: if we find that error-checking during object parsing is a</span>
<span class="gi">+        # performance bottleneck, those checks should be moved to the class&#39;s</span>
<span class="gi">+        # check() method during optimization so we can still check the object</span>
<span class="gi">+        # when necessary.</span>
<span class="gi">+        old_sha = self.id</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._deserialize(self.as_raw_chunks())</span>
<span class="gi">+            self._sha = None</span>
<span class="gi">+            new_sha = self.id</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            raise ObjectFormatException(exc) from exc</span>
<span class="gi">+        if old_sha != new_sha:</span>
<span class="gi">+            raise ChecksumMismatch(new_sha, old_sha)</span>
<span class="gi">+</span>
<span class="gi">+    def _header(self):</span>
<span class="gi">+        return object_header(self.type_num, self.raw_length())</span>
<span class="gi">+</span>
<span class="gi">+    def raw_length(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the length of the raw string of this object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(map(len, self.as_raw_chunks()))</span>

<span class="w"> </span>    def sha(self):
<span class="w"> </span>        &quot;&quot;&quot;The SHA1 object that is the name of this object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sha is None or self._needs_serialization:</span>
<span class="gi">+            # this is a local because as_raw_chunks() overwrites self._sha</span>
<span class="gi">+            new_sha = sha1()</span>
<span class="gi">+            new_sha.update(self._header())</span>
<span class="gi">+            for chunk in self.as_raw_chunks():</span>
<span class="gi">+                new_sha.update(chunk)</span>
<span class="gi">+            self._sha = new_sha</span>
<span class="gi">+        return self._sha</span>

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;Create a new copy of this SHA1 object from its raw string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        obj_class = object_class(self.type_num)</span>
<span class="gi">+        if obj_class is None:</span>
<span class="gi">+            raise AssertionError(&quot;invalid type num %d&quot; % self.type_num)</span>
<span class="gi">+        return obj_class.from_raw_string(self.type_num, self.as_raw_string(), self.id)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def id(self):
<span class="w"> </span>        &quot;&quot;&quot;The hex SHA of this object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sha().hexdigest().encode(&quot;ascii&quot;)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{self.__class__.__name__} {self.id}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{self.__class__.__name__} {self.id}&gt;&quot;</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Check whether this object does not match the other.&quot;&quot;&quot;
<span class="gu">@@ -331,19 +585,53 @@ class ShaFile:</span>

<span class="w"> </span>class Blob(ShaFile):
<span class="w"> </span>    &quot;&quot;&quot;A Git Blob object.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gd">-    type_name = b&#39;blob&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = b&quot;blob&quot;</span>
<span class="w"> </span>    type_num = 3
<span class="gi">+</span>
<span class="w"> </span>    _chunked_text: List[bytes]

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._chunked_text = []
<span class="w"> </span>        self._needs_serialization = False
<span class="gd">-    data = property(_get_data, _set_data, doc=</span>
<span class="gd">-        &#39;The text contained within the blob object.&#39;)</span>
<span class="gd">-    chunked = property(_get_chunked, _set_chunked, doc=</span>
<span class="gd">-        &#39;The text in the blob object, as chunks (not necessarily lines)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_data(self):</span>
<span class="gi">+        return self.as_raw_string()</span>
<span class="gi">+</span>
<span class="gi">+    def _set_data(self, data):</span>
<span class="gi">+        self.set_raw_string(data)</span>
<span class="gi">+</span>
<span class="gi">+    data = property(</span>
<span class="gi">+        _get_data, _set_data, doc=&quot;The text contained within the blob object.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_chunked(self):</span>
<span class="gi">+        return self._chunked_text</span>
<span class="gi">+</span>
<span class="gi">+    def _set_chunked(self, chunks: List[bytes]):</span>
<span class="gi">+        self._chunked_text = chunks</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self):</span>
<span class="gi">+        return self._chunked_text</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, chunks):</span>
<span class="gi">+        self._chunked_text = chunks</span>
<span class="gi">+</span>
<span class="gi">+    chunked = property(</span>
<span class="gi">+        _get_chunked,</span>
<span class="gi">+        _set_chunked,</span>
<span class="gi">+        doc=&quot;The text in the blob object, as chunks (not necessarily lines)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path):</span>
<span class="gi">+        blob = ShaFile.from_path(path)</span>
<span class="gi">+        if not isinstance(blob, cls):</span>
<span class="gi">+            raise NotBlobError(path)</span>
<span class="gi">+        return blob</span>

<span class="w"> </span>    def check(self):
<span class="w"> </span>        &quot;&quot;&quot;Check this object for internal consistency.
<span class="gu">@@ -351,18 +639,39 @@ class Blob(ShaFile):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          ObjectFormatException: if the object is malformed in some way
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().check()</span>

<span class="gd">-    def splitlines(self) -&gt;List[bytes]:</span>
<span class="gi">+    def splitlines(self) -&gt; List[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return list of lines in this blob.

<span class="w"> </span>        This preserves the original line endings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _parse_message(chunks: Iterable[bytes]) -&gt;Iterator[Union[Tuple[None,</span>
<span class="gd">-    None], Tuple[Optional[bytes], bytes]]]:</span>
<span class="gi">+        chunks = self.chunked</span>
<span class="gi">+        if not chunks:</span>
<span class="gi">+            return []</span>
<span class="gi">+        if len(chunks) == 1:</span>
<span class="gi">+            return chunks[0].splitlines(True)</span>
<span class="gi">+        remaining = None</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for chunk in chunks:</span>
<span class="gi">+            lines = chunk.splitlines(True)</span>
<span class="gi">+            if len(lines) &gt; 1:</span>
<span class="gi">+                ret.append((remaining or b&quot;&quot;) + lines[0])</span>
<span class="gi">+                ret.extend(lines[1:-1])</span>
<span class="gi">+                remaining = lines[-1]</span>
<span class="gi">+            elif len(lines) == 1:</span>
<span class="gi">+                if remaining is None:</span>
<span class="gi">+                    remaining = lines.pop()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    remaining += lines.pop()</span>
<span class="gi">+        if remaining is not None:</span>
<span class="gi">+            ret.append(remaining)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_message(</span>
<span class="gi">+    chunks: Iterable[bytes],</span>
<span class="gi">+) -&gt; Iterator[Union[Tuple[None, None], Tuple[Optional[bytes], bytes]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a message with a list of fields and a body.

<span class="w"> </span>    Args:
<span class="gu">@@ -371,19 +680,83 @@ def _parse_message(chunks: Iterable[bytes]) -&gt;Iterator[Union[Tuple[None,</span>
<span class="w"> </span>        order read from the text, possibly including duplicates. Includes a
<span class="w"> </span>        field named None for the freeform tag/commit text.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f = BytesIO(b&quot;&quot;.join(chunks))</span>
<span class="gi">+    k = None</span>
<span class="gi">+    v = b&quot;&quot;</span>
<span class="gi">+    eof = False</span>
<span class="gi">+</span>
<span class="gi">+    def _strip_last_newline(value):</span>
<span class="gi">+        &quot;&quot;&quot;Strip the last newline from value.&quot;&quot;&quot;</span>
<span class="gi">+        if value and value.endswith(b&quot;\n&quot;):</span>
<span class="gi">+            return value[:-1]</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    # Parse the headers</span>
<span class="gi">+    #</span>
<span class="gi">+    # Headers can contain newlines. The next line is indented with a space.</span>
<span class="gi">+    # We store the latest key as &#39;k&#39;, and the accumulated value as &#39;v&#39;.</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        if line.startswith(b&quot; &quot;):</span>
<span class="gi">+            # Indented continuation of the previous line</span>
<span class="gi">+            v += line[1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            if k is not None:</span>
<span class="gi">+                # We parsed a new header, return its value</span>
<span class="gi">+                yield (k, _strip_last_newline(v))</span>
<span class="gi">+            if line == b&quot;\n&quot;:</span>
<span class="gi">+                # Empty line indicates end of headers</span>
<span class="gi">+                break</span>
<span class="gi">+            (k, v) = line.split(b&quot; &quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # We reached end of file before the headers ended. We still need to</span>
<span class="gi">+        # return the previous header, then we need to return a None field for</span>
<span class="gi">+        # the text.</span>
<span class="gi">+        eof = True</span>
<span class="gi">+        if k is not None:</span>
<span class="gi">+            yield (k, _strip_last_newline(v))</span>
<span class="gi">+        yield (None, None)</span>
<span class="gi">+</span>
<span class="gi">+    if not eof:</span>
<span class="gi">+        # We didn&#39;t reach the end of file while parsing headers. We can return</span>
<span class="gi">+        # the rest of the file as a message.</span>
<span class="gi">+        yield (None, f.read())</span>
<span class="gi">+</span>
<span class="gi">+    f.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_message(headers, body):</span>
<span class="gi">+    for field, value in headers:</span>
<span class="gi">+        lines = value.split(b&quot;\n&quot;)</span>
<span class="gi">+        yield git_line(field, lines[0])</span>
<span class="gi">+        for line in lines[1:]:</span>
<span class="gi">+            yield b&quot; &quot; + line + b&quot;\n&quot;</span>
<span class="gi">+    if body:</span>
<span class="gi">+        yield b&quot;\n&quot;  # There must be a new line after the headers</span>
<span class="gi">+        yield body</span>


<span class="w"> </span>class Tag(ShaFile):
<span class="w"> </span>    &quot;&quot;&quot;A Git Tag object.&quot;&quot;&quot;
<span class="gd">-    type_name = b&#39;tag&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = b&quot;tag&quot;</span>
<span class="w"> </span>    type_num = 4
<span class="gd">-    __slots__ = (&#39;_tag_timezone_neg_utc&#39;, &#39;_name&#39;, &#39;_object_sha&#39;,</span>
<span class="gd">-        &#39;_object_class&#39;, &#39;_tag_time&#39;, &#39;_tag_timezone&#39;, &#39;_tagger&#39;,</span>
<span class="gd">-        &#39;_message&#39;, &#39;_signature&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;_tag_timezone_neg_utc&quot;,</span>
<span class="gi">+        &quot;_name&quot;,</span>
<span class="gi">+        &quot;_object_sha&quot;,</span>
<span class="gi">+        &quot;_object_class&quot;,</span>
<span class="gi">+        &quot;_tag_time&quot;,</span>
<span class="gi">+        &quot;_tag_timezone&quot;,</span>
<span class="gi">+        &quot;_tagger&quot;,</span>
<span class="gi">+        &quot;_message&quot;,</span>
<span class="gi">+        &quot;_signature&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    _tagger: Optional[bytes]

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._tagger = None
<span class="w"> </span>        self._tag_time = None
<span class="gu">@@ -391,39 +764,159 @@ class Tag(ShaFile):</span>
<span class="w"> </span>        self._tag_timezone_neg_utc = False
<span class="w"> </span>        self._signature = None

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, filename):</span>
<span class="gi">+        tag = ShaFile.from_path(filename)</span>
<span class="gi">+        if not isinstance(tag, cls):</span>
<span class="gi">+            raise NotTagError(filename)</span>
<span class="gi">+        return tag</span>
<span class="gi">+</span>
<span class="w"> </span>    def check(self):
<span class="w"> </span>        &quot;&quot;&quot;Check this object for internal consistency.

<span class="w"> </span>        Raises:
<span class="w"> </span>          ObjectFormatException: if the object is malformed in some way
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().check()</span>
<span class="gi">+        assert self._chunked_text is not None</span>
<span class="gi">+        self._check_has_member(&quot;_object_sha&quot;, &quot;missing object sha&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_object_class&quot;, &quot;missing object type&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_name&quot;, &quot;missing tag name&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._name:</span>
<span class="gi">+            raise ObjectFormatException(&quot;empty tag name&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        check_hexsha(self._object_sha, &quot;invalid object sha&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._tagger is not None:</span>
<span class="gi">+            check_identity(self._tagger, &quot;invalid tagger&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._check_has_member(&quot;_tag_time&quot;, &quot;missing tag time&quot;)</span>
<span class="gi">+        check_time(self._tag_time)</span>
<span class="gi">+</span>
<span class="gi">+        last = None</span>
<span class="gi">+        for field, _ in _parse_message(self._chunked_text):</span>
<span class="gi">+            if field == _OBJECT_HEADER and last is not None:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected object&quot;)</span>
<span class="gi">+            elif field == _TYPE_HEADER and last != _OBJECT_HEADER:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected type&quot;)</span>
<span class="gi">+            elif field == _TAG_HEADER and last != _TYPE_HEADER:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected tag name&quot;)</span>
<span class="gi">+            elif field == _TAGGER_HEADER and last != _TAG_HEADER:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected tagger&quot;)</span>
<span class="gi">+            last = field</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self):</span>
<span class="gi">+        headers = []</span>
<span class="gi">+        headers.append((_OBJECT_HEADER, self._object_sha))</span>
<span class="gi">+        headers.append((_TYPE_HEADER, self._object_class.type_name))</span>
<span class="gi">+        headers.append((_TAG_HEADER, self._name))</span>
<span class="gi">+        if self._tagger:</span>
<span class="gi">+            if self._tag_time is None:</span>
<span class="gi">+                headers.append((_TAGGER_HEADER, self._tagger))</span>
<span class="gi">+            else:</span>
<span class="gi">+                headers.append(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        _TAGGER_HEADER,</span>
<span class="gi">+                        format_time_entry(</span>
<span class="gi">+                            self._tagger,</span>
<span class="gi">+                            self._tag_time,</span>
<span class="gi">+                            (self._tag_timezone, self._tag_timezone_neg_utc),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if self.message is None and self._signature is None:</span>
<span class="gi">+            body = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            body = (self.message or b&quot;&quot;) + (self._signature or b&quot;&quot;)</span>
<span class="gi">+        return list(_format_message(headers, body))</span>

<span class="w"> </span>    def _deserialize(self, chunks):
<span class="w"> </span>        &quot;&quot;&quot;Grab the metadata attached to the tag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._tagger = None</span>
<span class="gi">+        self._tag_time = None</span>
<span class="gi">+        self._tag_timezone = None</span>
<span class="gi">+        self._tag_timezone_neg_utc = False</span>
<span class="gi">+        for field, value in _parse_message(chunks):</span>
<span class="gi">+            if field == _OBJECT_HEADER:</span>
<span class="gi">+                self._object_sha = value</span>
<span class="gi">+            elif field == _TYPE_HEADER:</span>
<span class="gi">+                assert isinstance(value, bytes)</span>
<span class="gi">+                obj_class = object_class(value)</span>
<span class="gi">+                if not obj_class:</span>
<span class="gi">+                    raise ObjectFormatException(f&quot;Not a known type: {value!r}&quot;)</span>
<span class="gi">+                self._object_class = obj_class</span>
<span class="gi">+            elif field == _TAG_HEADER:</span>
<span class="gi">+                self._name = value</span>
<span class="gi">+            elif field == _TAGGER_HEADER:</span>
<span class="gi">+                (</span>
<span class="gi">+                    self._tagger,</span>
<span class="gi">+                    self._tag_time,</span>
<span class="gi">+                    (self._tag_timezone, self._tag_timezone_neg_utc),</span>
<span class="gi">+                ) = parse_time_entry(value)</span>
<span class="gi">+            elif field is None:</span>
<span class="gi">+                if value is None:</span>
<span class="gi">+                    self._message = None</span>
<span class="gi">+                    self._signature = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        sig_idx = value.index(BEGIN_PGP_SIGNATURE)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        self._message = value</span>
<span class="gi">+                        self._signature = None</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._message = value[:sig_idx]</span>
<span class="gi">+                        self._signature = value[sig_idx:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ObjectFormatException(f&quot;Unknown field {field}&quot;)</span>

<span class="w"> </span>    def _get_object(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the object pointed to by this tag.

<span class="w"> </span>        Returns: tuple of (object class, sha).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self._object_class, self._object_sha)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_object(self, value):</span>
<span class="gi">+        (self._object_class, self._object_sha) = value</span>
<span class="gi">+        self._needs_serialization = True</span>
<span class="gi">+</span>
<span class="w"> </span>    object = property(_get_object, _set_object)
<span class="gd">-    name = serializable_property(&#39;name&#39;, &#39;The name of this tag&#39;)</span>
<span class="gd">-    tagger = serializable_property(&#39;tagger&#39;,</span>
<span class="gd">-        &#39;Returns the name of the person who created this tag&#39;)</span>
<span class="gd">-    tag_time = serializable_property(&#39;tag_time&#39;,</span>
<span class="gd">-        &#39;The creation timestamp of the tag.  As the number of seconds since the epoch&#39;</span>
<span class="gd">-        )</span>
<span class="gd">-    tag_timezone = serializable_property(&#39;tag_timezone&#39;,</span>
<span class="gd">-        &#39;The timezone that tag_time is in.&#39;)</span>
<span class="gd">-    message = serializable_property(&#39;message&#39;,</span>
<span class="gd">-        &#39;the message attached to this tag&#39;)</span>
<span class="gd">-    signature = serializable_property(&#39;signature&#39;,</span>
<span class="gd">-        &#39;Optional detached GPG signature&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def verify(self, keyids: Optional[Iterable[str]]=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = serializable_property(&quot;name&quot;, &quot;The name of this tag&quot;)</span>
<span class="gi">+    tagger = serializable_property(</span>
<span class="gi">+        &quot;tagger&quot;, &quot;Returns the name of the person who created this tag&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    tag_time = serializable_property(</span>
<span class="gi">+        &quot;tag_time&quot;,</span>
<span class="gi">+        &quot;The creation timestamp of the tag.  As the number of seconds &quot;</span>
<span class="gi">+        &quot;since the epoch&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    tag_timezone = serializable_property(</span>
<span class="gi">+        &quot;tag_timezone&quot;, &quot;The timezone that tag_time is in.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    message = serializable_property(&quot;message&quot;, &quot;the message attached to this tag&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    signature = serializable_property(&quot;signature&quot;, &quot;Optional detached GPG signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self, keyid: Optional[str] = None):</span>
<span class="gi">+        import gpg</span>
<span class="gi">+</span>
<span class="gi">+        with gpg.Context(armor=True) as c:</span>
<span class="gi">+            if keyid is not None:</span>
<span class="gi">+                key = c.get_key(keyid)</span>
<span class="gi">+                with gpg.Context(armor=True, signers=[key]) as ctx:</span>
<span class="gi">+                    self.signature, unused_result = ctx.sign(</span>
<span class="gi">+                        self.as_raw_string(),</span>
<span class="gi">+                        mode=gpg.constants.sig.mode.DETACH,</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.signature, unused_result = c.sign(</span>
<span class="gi">+                    self.as_raw_string(), mode=gpg.constants.sig.mode.DETACH</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def verify(self, keyids: Optional[Iterable[str]] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify GPG signature for this tag (if it is signed).

<span class="w"> </span>        Args:
<span class="gu">@@ -437,15 +930,34 @@ class Tag(ShaFile):</span>
<span class="w"> </span>          gpg.errors.MissingSignatures: if tag was not signed by a key
<span class="w"> </span>            specified in keyids
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-class TreeEntry(namedtuple(&#39;TreeEntry&#39;, [&#39;path&#39;, &#39;mode&#39;, &#39;sha&#39;])):</span>
<span class="gi">+        if self._signature is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        import gpg</span>
<span class="gi">+</span>
<span class="gi">+        with gpg.Context() as ctx:</span>
<span class="gi">+            data, result = ctx.verify(</span>
<span class="gi">+                self.as_raw_string()[: -len(self._signature)],</span>
<span class="gi">+                signature=self._signature,</span>
<span class="gi">+            )</span>
<span class="gi">+            if keyids:</span>
<span class="gi">+                keys = [ctx.get_key(key) for key in keyids]</span>
<span class="gi">+                for key in keys:</span>
<span class="gi">+                    for subkey in keys:</span>
<span class="gi">+                        for sig in result.signatures:</span>
<span class="gi">+                            if subkey.can_sign and subkey.fpr == sig.fpr:</span>
<span class="gi">+                                return</span>
<span class="gi">+                raise gpg.errors.MissingSignatures(result, keys, results=(data, result))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class TreeEntry(namedtuple(&quot;TreeEntry&quot;, [&quot;path&quot;, &quot;mode&quot;, &quot;sha&quot;])):</span>
<span class="w"> </span>    &quot;&quot;&quot;Named tuple encapsulating a single tree entry.&quot;&quot;&quot;

<span class="w"> </span>    def in_path(self, path: bytes):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of this entry with the given path prepended.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(self.path, bytes):</span>
<span class="gi">+            raise TypeError(f&quot;Expected bytes for path, got {path!r}&quot;)</span>
<span class="gi">+        return TreeEntry(posixpath.join(path, self.path), self.mode, self.sha)</span>


<span class="w"> </span>def parse_tree(text, strict=False):
<span class="gu">@@ -458,7 +970,25 @@ def parse_tree(text, strict=False):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ObjectFormatException: if the object was malformed in some way
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    length = len(text)</span>
<span class="gi">+    while count &lt; length:</span>
<span class="gi">+        mode_end = text.index(b&quot; &quot;, count)</span>
<span class="gi">+        mode_text = text[count:mode_end]</span>
<span class="gi">+        if strict and mode_text.startswith(b&quot;0&quot;):</span>
<span class="gi">+            raise ObjectFormatException(f&quot;Invalid mode &#39;{mode_text}&#39;&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            mode = int(mode_text, 8)</span>
<span class="gi">+        except ValueError as exc:</span>
<span class="gi">+            raise ObjectFormatException(f&quot;Invalid mode &#39;{mode_text}&#39;&quot;) from exc</span>
<span class="gi">+        name_end = text.index(b&quot;\0&quot;, mode_end)</span>
<span class="gi">+        name = text[mode_end + 1 : name_end]</span>
<span class="gi">+        count = name_end + 21</span>
<span class="gi">+        sha = text[name_end + 1 : count]</span>
<span class="gi">+        if len(sha) != 20:</span>
<span class="gi">+            raise ObjectFormatException(&quot;Sha has invalid length&quot;)</span>
<span class="gi">+        hexsha = sha_to_hex(sha)</span>
<span class="gi">+        yield (name, mode, hexsha)</span>


<span class="w"> </span>def serialize_tree(items):
<span class="gu">@@ -468,7 +998,10 @@ def serialize_tree(items):</span>
<span class="w"> </span>      items: Sorted iterable over (name, mode, sha) tuples
<span class="w"> </span>    Returns: Serialized tree text as chunks
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name, mode, hexsha in items:</span>
<span class="gi">+        yield (</span>
<span class="gi">+            (f&quot;{mode:04o}&quot;).encode(&quot;ascii&quot;) + b&quot; &quot; + name + b&quot;\0&quot; + hex_to_sha(hexsha)</span>
<span class="gi">+        )</span>


<span class="w"> </span>def sorted_tree_items(entries, name_order: bool):
<span class="gu">@@ -481,24 +1014,37 @@ def sorted_tree_items(entries, name_order: bool):</span>
<span class="w"> </span>      entries: Dictionary mapping names to (mode, sha) tuples
<span class="w"> </span>    Returns: Iterator over (name, mode, hexsha)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name_order:</span>
<span class="gi">+        key_func = key_entry_name_order</span>
<span class="gi">+    else:</span>
<span class="gi">+        key_func = key_entry</span>
<span class="gi">+    for name, entry in sorted(entries.items(), key=key_func):</span>
<span class="gi">+        mode, hexsha = entry</span>
<span class="gi">+        # Stricter type checks than normal to mirror checks in the Rust version.</span>
<span class="gi">+        mode = int(mode)</span>
<span class="gi">+        if not isinstance(hexsha, bytes):</span>
<span class="gi">+            raise TypeError(f&quot;Expected bytes for SHA, got {hexsha!r}&quot;)</span>
<span class="gi">+        yield TreeEntry(name, mode, hexsha)</span>


<span class="gd">-def key_entry(entry) -&gt;bytes:</span>
<span class="gi">+def key_entry(entry) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort key for tree entry.

<span class="w"> </span>    Args:
<span class="w"> </span>      entry: (name, value) tuple
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (name, value) = entry</span>
<span class="gi">+    if stat.S_ISDIR(value[0]):</span>
<span class="gi">+        name += b&quot;/&quot;</span>
<span class="gi">+    return name</span>


<span class="w"> </span>def key_entry_name_order(entry):
<span class="w"> </span>    &quot;&quot;&quot;Sort key for tree entry in name order.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return entry[0]</span>


<span class="gd">-def pretty_format_tree_entry(name, mode, hexsha, encoding=&#39;utf-8&#39;) -&gt;str:</span>
<span class="gi">+def pretty_format_tree_entry(name, mode, hexsha, encoding=&quot;utf-8&quot;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pretty format tree entry.

<span class="w"> </span>    Args:
<span class="gu">@@ -507,34 +1053,52 @@ def pretty_format_tree_entry(name, mode, hexsha, encoding=&#39;utf-8&#39;) -&gt;str:</span>
<span class="w"> </span>      hexsha: Hexsha of the referenced object
<span class="w"> </span>    Returns: string describing the tree entry
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mode &amp; stat.S_IFDIR:</span>
<span class="gi">+        kind = &quot;tree&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        kind = &quot;blob&quot;</span>
<span class="gi">+    return &quot;{:04o} {} {}\t{}\n&quot;.format(</span>
<span class="gi">+        mode,</span>
<span class="gi">+        kind,</span>
<span class="gi">+        hexsha.decode(&quot;ascii&quot;),</span>
<span class="gi">+        name.decode(encoding, &quot;replace&quot;),</span>
<span class="gi">+    )</span>


<span class="w"> </span>class SubmoduleEncountered(Exception):
<span class="w"> </span>    &quot;&quot;&quot;A submodule was encountered while resolving a path.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path, sha) -&gt;None:</span>
<span class="gi">+    def __init__(self, path, sha) -&gt; None:</span>
<span class="w"> </span>        self.path = path
<span class="w"> </span>        self.sha = sha


<span class="w"> </span>class Tree(ShaFile):
<span class="w"> </span>    &quot;&quot;&quot;A Git tree object.&quot;&quot;&quot;
<span class="gd">-    type_name = b&#39;tree&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = b&quot;tree&quot;</span>
<span class="w"> </span>    type_num = 2
<span class="gd">-    __slots__ = &#39;_entries&#39;</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    __slots__ = &quot;_entries&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._entries: Dict[bytes, Tuple[int, bytes]] = {}

<span class="gd">-    def __contains__(self, name) -&gt;bool:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, filename):</span>
<span class="gi">+        tree = ShaFile.from_path(filename)</span>
<span class="gi">+        if not isinstance(tree, cls):</span>
<span class="gi">+            raise NotTreeError(filename)</span>
<span class="gi">+        return tree</span>
<span class="gi">+</span>
<span class="gi">+    def __contains__(self, name) -&gt; bool:</span>
<span class="w"> </span>        return name in self._entries

<span class="w"> </span>    def __getitem__(self, name):
<span class="w"> </span>        return self._entries[name]

<span class="gd">-    def __setitem__(self, name, value) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name, value) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a tree entry by name.

<span class="w"> </span>        Args:
<span class="gu">@@ -544,14 +1108,14 @@ class Tree(ShaFile):</span>
<span class="w"> </span>            a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        mode, hexsha = value
<span class="gd">-        self._entries[name] = mode, hexsha</span>
<span class="gi">+        self._entries[name] = (mode, hexsha)</span>
<span class="w"> </span>        self._needs_serialization = True

<span class="gd">-    def __delitem__(self, name) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name) -&gt; None:</span>
<span class="w"> </span>        del self._entries[name]
<span class="w"> </span>        self._needs_serialization = True

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._entries)

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -566,7 +1130,8 @@ class Tree(ShaFile):</span>
<span class="w"> </span>          name: The name of the entry, as a string.
<span class="w"> </span>          hexsha: The hex SHA of the entry as a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._entries[name] = mode, hexsha</span>
<span class="gi">+        self._needs_serialization = True</span>

<span class="w"> </span>    def iteritems(self, name_order=False):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over entries.
<span class="gu">@@ -576,18 +1141,25 @@ class Tree(ShaFile):</span>
<span class="w"> </span>            order.
<span class="w"> </span>        Returns: Iterator over (name, mode, sha) tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sorted_tree_items(self._entries, name_order)</span>

<span class="w"> </span>    def items(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the sorted entries in this tree.

<span class="w"> </span>        Returns: List with (name, mode, sha) tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.iteritems())</span>

<span class="w"> </span>    def _deserialize(self, chunks):
<span class="w"> </span>        &quot;&quot;&quot;Grab the entries in the tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            parsed_entries = parse_tree(b&quot;&quot;.join(chunks))</span>
<span class="gi">+        except ValueError as exc:</span>
<span class="gi">+            raise ObjectFormatException(exc) from exc</span>
<span class="gi">+        # TODO: list comprehension is for efficiency in the common (small)</span>
<span class="gi">+        # case; if memory efficiency in the large case is a concern, use a</span>
<span class="gi">+        # genexp.</span>
<span class="gi">+        self._entries = {n: (m, s) for n, m, s in parsed_entries}</span>

<span class="w"> </span>    def check(self):
<span class="w"> </span>        &quot;&quot;&quot;Check this object for internal consistency.
<span class="gu">@@ -595,7 +1167,44 @@ class Tree(ShaFile):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          ObjectFormatException: if the object is malformed in some way
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().check()</span>
<span class="gi">+        assert self._chunked_text is not None</span>
<span class="gi">+        last = None</span>
<span class="gi">+        allowed_modes = (</span>
<span class="gi">+            stat.S_IFREG | 0o755,</span>
<span class="gi">+            stat.S_IFREG | 0o644,</span>
<span class="gi">+            stat.S_IFLNK,</span>
<span class="gi">+            stat.S_IFDIR,</span>
<span class="gi">+            S_IFGITLINK,</span>
<span class="gi">+            # TODO: optionally exclude as in git fsck --strict</span>
<span class="gi">+            stat.S_IFREG | 0o664,</span>
<span class="gi">+        )</span>
<span class="gi">+        for name, mode, sha in parse_tree(b&quot;&quot;.join(self._chunked_text), True):</span>
<span class="gi">+            check_hexsha(sha, f&quot;invalid sha {sha}&quot;)</span>
<span class="gi">+            if b&quot;/&quot; in name or name in (b&quot;&quot;, b&quot;.&quot;, b&quot;..&quot;, b&quot;.git&quot;):</span>
<span class="gi">+                raise ObjectFormatException(</span>
<span class="gi">+                    &quot;invalid name {}&quot;.format(name.decode(&quot;utf-8&quot;, &quot;replace&quot;))</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if mode not in allowed_modes:</span>
<span class="gi">+                raise ObjectFormatException(f&quot;invalid mode {mode:06o}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            entry = (name, (mode, sha))</span>
<span class="gi">+            if last:</span>
<span class="gi">+                if key_entry(last) &gt; key_entry(entry):</span>
<span class="gi">+                    raise ObjectFormatException(&quot;entries not sorted&quot;)</span>
<span class="gi">+                if name == last[0]:</span>
<span class="gi">+                    raise ObjectFormatException(f&quot;duplicate entry {name}&quot;)</span>
<span class="gi">+            last = entry</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self):</span>
<span class="gi">+        return list(serialize_tree(self.iteritems()))</span>
<span class="gi">+</span>
<span class="gi">+    def as_pretty_string(self) -&gt; str:</span>
<span class="gi">+        text: List[str] = []</span>
<span class="gi">+        for name, mode, hexsha in self.iteritems():</span>
<span class="gi">+            text.append(pretty_format_tree_entry(name, mode, hexsha))</span>
<span class="gi">+        return &quot;&quot;.join(text)</span>

<span class="w"> </span>    def lookup_path(self, lookup_obj, path):
<span class="w"> </span>        &quot;&quot;&quot;Look up an object in a Git tree.
<span class="gu">@@ -605,7 +1214,19 @@ class Tree(ShaFile):</span>
<span class="w"> </span>          path: Path to lookup
<span class="w"> </span>        Returns: A tuple of (mode, SHA) of the resulting path.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = path.split(b&quot;/&quot;)</span>
<span class="gi">+        sha = self.id</span>
<span class="gi">+        mode = None</span>
<span class="gi">+        for i, p in enumerate(parts):</span>
<span class="gi">+            if not p:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if mode is not None and S_ISGITLINK(mode):</span>
<span class="gi">+                raise SubmoduleEncountered(b&quot;/&quot;.join(parts[:i]), sha)</span>
<span class="gi">+            obj = lookup_obj(sha)</span>
<span class="gi">+            if not isinstance(obj, Tree):</span>
<span class="gi">+                raise NotTreeError(sha)</span>
<span class="gi">+            mode, sha = obj[p]</span>
<span class="gi">+        return mode, sha</span>


<span class="w"> </span>def parse_timezone(text):
<span class="gu">@@ -617,7 +1238,24 @@ def parse_timezone(text):</span>
<span class="w"> </span>        and a boolean indicating whether this was a UTC timezone
<span class="w"> </span>        prefixed with a negative sign (-0000).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # cgit parses the first character as the sign, and the rest</span>
<span class="gi">+    #  as an integer (using strtol), which could also be negative.</span>
<span class="gi">+    #  We do the same for compatibility. See #697828.</span>
<span class="gi">+    if text[0] not in b&quot;+-&quot;:</span>
<span class="gi">+        raise ValueError(&quot;Timezone must start with + or - ({text})&quot;.format(**vars()))</span>
<span class="gi">+    sign = text[:1]</span>
<span class="gi">+    offset = int(text[1:])</span>
<span class="gi">+    if sign == b&quot;-&quot;:</span>
<span class="gi">+        offset = -offset</span>
<span class="gi">+    unnecessary_negative_timezone = offset &gt;= 0 and sign == b&quot;-&quot;</span>
<span class="gi">+    signum = (offset &lt; 0) and -1 or 1</span>
<span class="gi">+    offset = abs(offset)</span>
<span class="gi">+    hours = int(offset / 100)</span>
<span class="gi">+    minutes = offset % 100</span>
<span class="gi">+    return (</span>
<span class="gi">+        signum * (hours * 3600 + minutes * 60),</span>
<span class="gi">+        unnecessary_negative_timezone,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def format_timezone(offset, unnecessary_negative_timezone=False):
<span class="gu">@@ -628,7 +1266,14 @@ def format_timezone(offset, unnecessary_negative_timezone=False):</span>
<span class="w"> </span>      unnecessary_negative_timezone: Whether to use a minus sign for
<span class="w"> </span>        UTC or positive timezones (-0000 and --700 rather than +0000 / +0700).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if offset % 60 != 0:</span>
<span class="gi">+        raise ValueError(&quot;Unable to handle non-minute offset.&quot;)</span>
<span class="gi">+    if offset &lt; 0 or unnecessary_negative_timezone:</span>
<span class="gi">+        sign = &quot;-&quot;</span>
<span class="gi">+        offset = -offset</span>
<span class="gi">+    else:</span>
<span class="gi">+        sign = &quot;+&quot;</span>
<span class="gi">+    return (&quot;%c%02d%02d&quot; % (sign, offset / 3600, (offset / 60) % 60)).encode(&quot;ascii&quot;)</span>


<span class="w"> </span>def parse_time_entry(value):
<span class="gu">@@ -641,12 +1286,27 @@ def parse_time_entry(value):</span>
<span class="w"> </span>      field date)
<span class="w"> </span>    Returns: Tuple of (author, time, (timezone, timezone_neg_utc))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        sep = value.rindex(b&quot;&gt; &quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return (value, None, (None, False))</span>
<span class="gi">+    try:</span>
<span class="gi">+        person = value[0 : sep + 1]</span>
<span class="gi">+        rest = value[sep + 2 :]</span>
<span class="gi">+        timetext, timezonetext = rest.rsplit(b&quot; &quot;, 1)</span>
<span class="gi">+        time = int(timetext)</span>
<span class="gi">+        timezone, timezone_neg_utc = parse_timezone(timezonetext)</span>
<span class="gi">+    except ValueError as exc:</span>
<span class="gi">+        raise ObjectFormatException(exc) from exc</span>
<span class="gi">+    return person, time, (timezone, timezone_neg_utc)</span>


<span class="w"> </span>def format_time_entry(person, time, timezone_info):
<span class="w"> </span>    &quot;&quot;&quot;Format an event.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (timezone, timezone_neg_utc) = timezone_info</span>
<span class="gi">+    return b&quot; &quot;.join(</span>
<span class="gi">+        [person, str(time).encode(&quot;ascii&quot;), format_timezone(timezone, timezone_neg_utc)]</span>
<span class="gi">+    )</span>


<span class="w"> </span>def parse_commit(chunks):
<span class="gu">@@ -657,20 +1317,75 @@ def parse_commit(chunks):</span>
<span class="w"> </span>    Returns: Tuple of (tree, parents, author_info, commit_info,
<span class="w"> </span>        encoding, mergetag, gpgsig, message, extra)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(&quot;parse_commit will be removed in 0.22&quot;, DeprecationWarning)</span>
<span class="gi">+    parents = []</span>
<span class="gi">+    extra = []</span>
<span class="gi">+    tree = None</span>
<span class="gi">+    author_info = (None, None, (None, None))</span>
<span class="gi">+    commit_info = (None, None, (None, None))</span>
<span class="gi">+    encoding = None</span>
<span class="gi">+    mergetag = []</span>
<span class="gi">+    message = None</span>
<span class="gi">+    gpgsig = None</span>
<span class="gi">+</span>
<span class="gi">+    for field, value in _parse_message(chunks):</span>
<span class="gi">+        # TODO(jelmer): Enforce ordering</span>
<span class="gi">+        if field == _TREE_HEADER:</span>
<span class="gi">+            tree = value</span>
<span class="gi">+        elif field == _PARENT_HEADER:</span>
<span class="gi">+            parents.append(value)</span>
<span class="gi">+        elif field == _AUTHOR_HEADER:</span>
<span class="gi">+            author_info = parse_time_entry(value)</span>
<span class="gi">+        elif field == _COMMITTER_HEADER:</span>
<span class="gi">+            commit_info = parse_time_entry(value)</span>
<span class="gi">+        elif field == _ENCODING_HEADER:</span>
<span class="gi">+            encoding = value</span>
<span class="gi">+        elif field == _MERGETAG_HEADER:</span>
<span class="gi">+            mergetag.append(Tag.from_string(value + b&quot;\n&quot;))</span>
<span class="gi">+        elif field == _GPGSIG_HEADER:</span>
<span class="gi">+            gpgsig = value</span>
<span class="gi">+        elif field is None:</span>
<span class="gi">+            message = value</span>
<span class="gi">+        else:</span>
<span class="gi">+            extra.append((field, value))</span>
<span class="gi">+    return (</span>
<span class="gi">+        tree,</span>
<span class="gi">+        parents,</span>
<span class="gi">+        author_info,</span>
<span class="gi">+        commit_info,</span>
<span class="gi">+        encoding,</span>
<span class="gi">+        mergetag,</span>
<span class="gi">+        gpgsig,</span>
<span class="gi">+        message,</span>
<span class="gi">+        extra,</span>
<span class="gi">+    )</span>


<span class="w"> </span>class Commit(ShaFile):
<span class="w"> </span>    &quot;&quot;&quot;A git commit object.&quot;&quot;&quot;
<span class="gd">-    type_name = b&#39;commit&#39;</span>
<span class="gi">+</span>
<span class="gi">+    type_name = b&quot;commit&quot;</span>
<span class="w"> </span>    type_num = 1
<span class="gd">-    __slots__ = (&#39;_parents&#39;, &#39;_encoding&#39;, &#39;_extra&#39;,</span>
<span class="gd">-        &#39;_author_timezone_neg_utc&#39;, &#39;_commit_timezone_neg_utc&#39;,</span>
<span class="gd">-        &#39;_commit_time&#39;, &#39;_author_time&#39;, &#39;_author_timezone&#39;,</span>
<span class="gd">-        &#39;_commit_timezone&#39;, &#39;_author&#39;, &#39;_committer&#39;, &#39;_tree&#39;, &#39;_message&#39;,</span>
<span class="gd">-        &#39;_mergetag&#39;, &#39;_gpgsig&#39;)</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;_parents&quot;,</span>
<span class="gi">+        &quot;_encoding&quot;,</span>
<span class="gi">+        &quot;_extra&quot;,</span>
<span class="gi">+        &quot;_author_timezone_neg_utc&quot;,</span>
<span class="gi">+        &quot;_commit_timezone_neg_utc&quot;,</span>
<span class="gi">+        &quot;_commit_time&quot;,</span>
<span class="gi">+        &quot;_author_time&quot;,</span>
<span class="gi">+        &quot;_author_timezone&quot;,</span>
<span class="gi">+        &quot;_commit_timezone&quot;,</span>
<span class="gi">+        &quot;_author&quot;,</span>
<span class="gi">+        &quot;_committer&quot;,</span>
<span class="gi">+        &quot;_tree&quot;,</span>
<span class="gi">+        &quot;_message&quot;,</span>
<span class="gi">+        &quot;_mergetag&quot;,</span>
<span class="gi">+        &quot;_gpgsig&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._parents: List[bytes] = []
<span class="w"> </span>        self._encoding = None
<span class="gu">@@ -680,15 +1395,121 @@ class Commit(ShaFile):</span>
<span class="w"> </span>        self._author_timezone_neg_utc = False
<span class="w"> </span>        self._commit_timezone_neg_utc = False

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path):</span>
<span class="gi">+        commit = ShaFile.from_path(path)</span>
<span class="gi">+        if not isinstance(commit, cls):</span>
<span class="gi">+            raise NotCommitError(path)</span>
<span class="gi">+        return commit</span>
<span class="gi">+</span>
<span class="gi">+    def _deserialize(self, chunks):</span>
<span class="gi">+        self._parents = []</span>
<span class="gi">+        self._extra = []</span>
<span class="gi">+        self._tree = None</span>
<span class="gi">+        author_info = (None, None, (None, None))</span>
<span class="gi">+        commit_info = (None, None, (None, None))</span>
<span class="gi">+        self._encoding = None</span>
<span class="gi">+        self._mergetag = []</span>
<span class="gi">+        self._message = None</span>
<span class="gi">+        self._gpgsig = None</span>
<span class="gi">+</span>
<span class="gi">+        for field, value in _parse_message(chunks):</span>
<span class="gi">+            # TODO(jelmer): Enforce ordering</span>
<span class="gi">+            if field == _TREE_HEADER:</span>
<span class="gi">+                self._tree = value</span>
<span class="gi">+            elif field == _PARENT_HEADER:</span>
<span class="gi">+                assert value is not None</span>
<span class="gi">+                self._parents.append(value)</span>
<span class="gi">+            elif field == _AUTHOR_HEADER:</span>
<span class="gi">+                author_info = parse_time_entry(value)</span>
<span class="gi">+            elif field == _COMMITTER_HEADER:</span>
<span class="gi">+                commit_info = parse_time_entry(value)</span>
<span class="gi">+            elif field == _ENCODING_HEADER:</span>
<span class="gi">+                self._encoding = value</span>
<span class="gi">+            elif field == _MERGETAG_HEADER:</span>
<span class="gi">+                assert value is not None</span>
<span class="gi">+                self._mergetag.append(Tag.from_string(value + b&quot;\n&quot;))</span>
<span class="gi">+            elif field == _GPGSIG_HEADER:</span>
<span class="gi">+                self._gpgsig = value</span>
<span class="gi">+            elif field is None:</span>
<span class="gi">+                self._message = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._extra.append((field, value))</span>
<span class="gi">+</span>
<span class="gi">+        (</span>
<span class="gi">+            self._author,</span>
<span class="gi">+            self._author_time,</span>
<span class="gi">+            (self._author_timezone, self._author_timezone_neg_utc),</span>
<span class="gi">+        ) = author_info</span>
<span class="gi">+        (</span>
<span class="gi">+            self._committer,</span>
<span class="gi">+            self._commit_time,</span>
<span class="gi">+            (self._commit_timezone, self._commit_timezone_neg_utc),</span>
<span class="gi">+        ) = commit_info</span>
<span class="gi">+</span>
<span class="w"> </span>    def check(self):
<span class="w"> </span>        &quot;&quot;&quot;Check this object for internal consistency.

<span class="w"> </span>        Raises:
<span class="w"> </span>          ObjectFormatException: if the object is malformed in some way
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def verify(self, keyids: Optional[Iterable[str]]=None):</span>
<span class="gi">+        super().check()</span>
<span class="gi">+        assert self._chunked_text is not None</span>
<span class="gi">+        self._check_has_member(&quot;_tree&quot;, &quot;missing tree&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_author&quot;, &quot;missing author&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_committer&quot;, &quot;missing committer&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_author_time&quot;, &quot;missing author time&quot;)</span>
<span class="gi">+        self._check_has_member(&quot;_commit_time&quot;, &quot;missing commit time&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for parent in self._parents:</span>
<span class="gi">+            check_hexsha(parent, &quot;invalid parent sha&quot;)</span>
<span class="gi">+        check_hexsha(self._tree, &quot;invalid tree sha&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        check_identity(self._author, &quot;invalid author&quot;)</span>
<span class="gi">+        check_identity(self._committer, &quot;invalid committer&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        check_time(self._author_time)</span>
<span class="gi">+        check_time(self._commit_time)</span>
<span class="gi">+</span>
<span class="gi">+        last = None</span>
<span class="gi">+        for field, _ in _parse_message(self._chunked_text):</span>
<span class="gi">+            if field == _TREE_HEADER and last is not None:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected tree&quot;)</span>
<span class="gi">+            elif field == _PARENT_HEADER and last not in (</span>
<span class="gi">+                _PARENT_HEADER,</span>
<span class="gi">+                _TREE_HEADER,</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected parent&quot;)</span>
<span class="gi">+            elif field == _AUTHOR_HEADER and last not in (</span>
<span class="gi">+                _TREE_HEADER,</span>
<span class="gi">+                _PARENT_HEADER,</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected author&quot;)</span>
<span class="gi">+            elif field == _COMMITTER_HEADER and last != _AUTHOR_HEADER:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected committer&quot;)</span>
<span class="gi">+            elif field == _ENCODING_HEADER and last != _COMMITTER_HEADER:</span>
<span class="gi">+                raise ObjectFormatException(&quot;unexpected encoding&quot;)</span>
<span class="gi">+            last = field</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: optionally check for duplicate parents</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self, keyid: Optional[str] = None):</span>
<span class="gi">+        import gpg</span>
<span class="gi">+</span>
<span class="gi">+        with gpg.Context(armor=True) as c:</span>
<span class="gi">+            if keyid is not None:</span>
<span class="gi">+                key = c.get_key(keyid)</span>
<span class="gi">+                with gpg.Context(armor=True, signers=[key]) as ctx:</span>
<span class="gi">+                    self.gpgsig, unused_result = ctx.sign(</span>
<span class="gi">+                        self.as_raw_string(),</span>
<span class="gi">+                        mode=gpg.constants.sig.mode.DETACH,</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.gpgsig, unused_result = c.sign(</span>
<span class="gi">+                    self.as_raw_string(), mode=gpg.constants.sig.mode.DETACH</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def verify(self, keyids: Optional[Iterable[str]] = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify GPG signature for this commit (if it is signed).

<span class="w"> </span>        Args:
<span class="gu">@@ -702,55 +1523,150 @@ class Commit(ShaFile):</span>
<span class="w"> </span>          gpg.errors.MissingSignatures: if commit was not signed by a key
<span class="w"> </span>            specified in keyids
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    tree = serializable_property(&#39;tree&#39;,</span>
<span class="gd">-        &#39;Tree that is the state of this commit&#39;)</span>
<span class="gi">+        if self._gpgsig is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        import gpg</span>
<span class="gi">+</span>
<span class="gi">+        with gpg.Context() as ctx:</span>
<span class="gi">+            self_without_gpgsig = self.copy()</span>
<span class="gi">+            self_without_gpgsig._gpgsig = None</span>
<span class="gi">+            self_without_gpgsig.gpgsig = None</span>
<span class="gi">+            data, result = ctx.verify(</span>
<span class="gi">+                self_without_gpgsig.as_raw_string(),</span>
<span class="gi">+                signature=self._gpgsig,</span>
<span class="gi">+            )</span>
<span class="gi">+            if keyids:</span>
<span class="gi">+                keys = [ctx.get_key(key) for key in keyids]</span>
<span class="gi">+                for key in keys:</span>
<span class="gi">+                    for subkey in keys:</span>
<span class="gi">+                        for sig in result.signatures:</span>
<span class="gi">+                            if subkey.can_sign and subkey.fpr == sig.fpr:</span>
<span class="gi">+                                return</span>
<span class="gi">+                raise gpg.errors.MissingSignatures(result, keys, results=(data, result))</span>
<span class="gi">+</span>
<span class="gi">+    def _serialize(self):</span>
<span class="gi">+        headers = []</span>
<span class="gi">+        tree_bytes = self._tree.id if isinstance(self._tree, Tree) else self._tree</span>
<span class="gi">+        headers.append((_TREE_HEADER, tree_bytes))</span>
<span class="gi">+        for p in self._parents:</span>
<span class="gi">+            headers.append((_PARENT_HEADER, p))</span>
<span class="gi">+        headers.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                _AUTHOR_HEADER,</span>
<span class="gi">+                format_time_entry(</span>
<span class="gi">+                    self._author,</span>
<span class="gi">+                    self._author_time,</span>
<span class="gi">+                    (self._author_timezone, self._author_timezone_neg_utc),</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        headers.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                _COMMITTER_HEADER,</span>
<span class="gi">+                format_time_entry(</span>
<span class="gi">+                    self._committer,</span>
<span class="gi">+                    self._commit_time,</span>
<span class="gi">+                    (self._commit_timezone, self._commit_timezone_neg_utc),</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.encoding:</span>
<span class="gi">+            headers.append((_ENCODING_HEADER, self.encoding))</span>
<span class="gi">+        for mergetag in self.mergetag:</span>
<span class="gi">+            headers.append((_MERGETAG_HEADER, mergetag.as_raw_string()[:-1]))</span>
<span class="gi">+        headers.extend(self._extra)</span>
<span class="gi">+        if self.gpgsig:</span>
<span class="gi">+            headers.append((_GPGSIG_HEADER, self.gpgsig))</span>
<span class="gi">+        return list(_format_message(headers, self._message))</span>
<span class="gi">+</span>
<span class="gi">+    tree = serializable_property(&quot;tree&quot;, &quot;Tree that is the state of this commit&quot;)</span>

<span class="w"> </span>    def _get_parents(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of parents of this commit.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parents</span>

<span class="w"> </span>    def _set_parents(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Set a list of parents of this commit.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    parents = property(_get_parents, _set_parents, doc=</span>
<span class="gd">-        &#39;Parents of this commit, by their SHA1.&#39;)</span>
<span class="gi">+        self._needs_serialization = True</span>
<span class="gi">+        self._parents = value</span>
<span class="gi">+</span>
<span class="gi">+    parents = property(</span>
<span class="gi">+        _get_parents,</span>
<span class="gi">+        _set_parents,</span>
<span class="gi">+        doc=&quot;Parents of this commit, by their SHA1.&quot;,</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def _get_extra(self):
<span class="w"> </span>        &quot;&quot;&quot;Return extra settings of this commit.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    extra = property(_get_extra, doc=</span>
<span class="gd">-        &#39;Extra header fields not understood (presumably added in a newer version of git). Kept verbatim so the object can be correctly reserialized. For private commit metadata, use pseudo-headers in Commit.message, rather than this field.&#39;</span>
<span class="gd">-        )</span>
<span class="gd">-    author = serializable_property(&#39;author&#39;,</span>
<span class="gd">-        &#39;The name of the author of the commit&#39;)</span>
<span class="gd">-    committer = serializable_property(&#39;committer&#39;,</span>
<span class="gd">-        &#39;The name of the committer of the commit&#39;)</span>
<span class="gd">-    message = serializable_property(&#39;message&#39;, &#39;The commit message&#39;)</span>
<span class="gd">-    commit_time = serializable_property(&#39;commit_time&#39;,</span>
<span class="gd">-        &#39;The timestamp of the commit. As the number of seconds since the epoch.&#39;</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Commit.extra is deprecated. Use Commit._extra instead.&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="w"> </span>        )
<span class="gd">-    commit_timezone = serializable_property(&#39;commit_timezone&#39;,</span>
<span class="gd">-        &#39;The zone the commit time is in&#39;)</span>
<span class="gd">-    author_time = serializable_property(&#39;author_time&#39;,</span>
<span class="gd">-        &#39;The timestamp the commit was written. As the number of seconds since the epoch.&#39;</span>
<span class="gd">-        )</span>
<span class="gd">-    author_timezone = serializable_property(&#39;author_timezone&#39;,</span>
<span class="gd">-        &#39;Returns the zone the author time is in.&#39;)</span>
<span class="gd">-    encoding = serializable_property(&#39;encoding&#39;,</span>
<span class="gd">-        &#39;Encoding of the commit message.&#39;)</span>
<span class="gd">-    mergetag = serializable_property(&#39;mergetag&#39;, &#39;Associated signed tag.&#39;)</span>
<span class="gd">-    gpgsig = serializable_property(&#39;gpgsig&#39;, &#39;GPG Signature.&#39;)</span>
<span class="gi">+        return self._extra</span>
<span class="gi">+</span>
<span class="gi">+    extra = property(</span>
<span class="gi">+        _get_extra,</span>
<span class="gi">+        doc=&quot;Extra header fields not understood (presumably added in a &quot;</span>
<span class="gi">+        &quot;newer version of git). Kept verbatim so the object can &quot;</span>
<span class="gi">+        &quot;be correctly reserialized. For private commit metadata, use &quot;</span>
<span class="gi">+        &quot;pseudo-headers in Commit.message, rather than this field.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    author = serializable_property(&quot;author&quot;, &quot;The name of the author of the commit&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    committer = serializable_property(</span>
<span class="gi">+        &quot;committer&quot;, &quot;The name of the committer of the commit&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    message = serializable_property(&quot;message&quot;, &quot;The commit message&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    commit_time = serializable_property(</span>
<span class="gi">+        &quot;commit_time&quot;,</span>
<span class="gi">+        &quot;The timestamp of the commit. As the number of seconds since the &quot; &quot;epoch.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    commit_timezone = serializable_property(</span>
<span class="gi">+        &quot;commit_timezone&quot;, &quot;The zone the commit time is in&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    author_time = serializable_property(</span>
<span class="gi">+        &quot;author_time&quot;,</span>
<span class="gi">+        &quot;The timestamp the commit was written. As the number of &quot;</span>
<span class="gi">+        &quot;seconds since the epoch.&quot;,</span>
<span class="gi">+    )</span>

<span class="gi">+    author_timezone = serializable_property(</span>
<span class="gi">+        &quot;author_timezone&quot;, &quot;Returns the zone the author time is in.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    encoding = serializable_property(&quot;encoding&quot;, &quot;Encoding of the commit message.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    mergetag = serializable_property(&quot;mergetag&quot;, &quot;Associated signed tag.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    gpgsig = serializable_property(&quot;gpgsig&quot;, &quot;GPG Signature.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+OBJECT_CLASSES = (</span>
<span class="gi">+    Commit,</span>
<span class="gi">+    Tree,</span>
<span class="gi">+    Blob,</span>
<span class="gi">+    Tag,</span>
<span class="gi">+)</span>

<span class="gd">-OBJECT_CLASSES = Commit, Tree, Blob, Tag</span>
<span class="w"> </span>_TYPE_MAP: Dict[Union[bytes, int], Type[ShaFile]] = {}
<span class="gi">+</span>
<span class="w"> </span>for cls in OBJECT_CLASSES:
<span class="w"> </span>    _TYPE_MAP[cls.type_name] = cls
<span class="w"> </span>    _TYPE_MAP[cls.type_num] = cls
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Hold on to the pure-python implementations for testing</span>
<span class="w"> </span>_parse_tree_py = parse_tree
<span class="w"> </span>_sorted_tree_items_py = sorted_tree_items
<span class="w"> </span>try:
<span class="gd">-    from dulwich._objects import parse_tree, sorted_tree_items</span>
<span class="gi">+    # Try to import Rust versions</span>
<span class="gi">+    from dulwich._objects import parse_tree, sorted_tree_items  # type: ignore</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pass
<span class="gh">diff --git a/dulwich/objectspec.py b/dulwich/objectspec.py</span>
<span class="gh">index ad4be807..edaa5a43 100644</span>
<span class="gd">--- a/dulwich/objectspec.py</span>
<span class="gi">+++ b/dulwich/objectspec.py</span>
<span class="gu">@@ -1,12 +1,40 @@</span>
<span class="gi">+# objectspec.py -- Object specification</span>
<span class="gi">+# Copyright (C) 2014 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Object specification.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Iterator, List, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from .objects import Commit, ShaFile, Tree
<span class="w"> </span>    from .refs import Ref, RefsContainer
<span class="w"> </span>    from .repo import Repo


<span class="gd">-def parse_object(repo: &#39;Repo&#39;, objectish: Union[bytes, str]) -&gt;&#39;ShaFile&#39;:</span>
<span class="gi">+def to_bytes(text: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+    if getattr(text, &quot;encode&quot;, None) is not None:</span>
<span class="gi">+        text = text.encode(&quot;ascii&quot;)  # type: ignore</span>
<span class="gi">+    return text  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_object(repo: &quot;Repo&quot;, objectish: Union[bytes, str]) -&gt; &quot;ShaFile&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string referring to an object.

<span class="w"> </span>    Args:
<span class="gu">@@ -16,10 +44,11 @@ def parse_object(repo: &#39;Repo&#39;, objectish: Union[bytes, str]) -&gt;&#39;ShaFile&#39;:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If the object can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    objectish = to_bytes(objectish)</span>
<span class="gi">+    return repo[objectish]</span>


<span class="gd">-def parse_tree(repo: &#39;Repo&#39;, treeish: Union[bytes, str]) -&gt;&#39;Tree&#39;:</span>
<span class="gi">+def parse_tree(repo: &quot;Repo&quot;, treeish: Union[bytes, str]) -&gt; &quot;Tree&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string referring to a tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -29,11 +58,20 @@ def parse_tree(repo: &#39;Repo&#39;, treeish: Union[bytes, str]) -&gt;&#39;Tree&#39;:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If the object can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    treeish = to_bytes(treeish)</span>
<span class="gi">+    try:</span>
<span class="gi">+        treeish = parse_ref(repo, treeish)</span>
<span class="gi">+    except KeyError:  # treeish is commit sha</span>
<span class="gi">+        pass</span>
<span class="gi">+    o = repo[treeish]</span>
<span class="gi">+    if o.type_name == b&quot;commit&quot;:</span>
<span class="gi">+        return repo[o.tree]</span>
<span class="gi">+    return o</span>


<span class="gd">-def parse_ref(container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;], refspec: Union[str,</span>
<span class="gd">-    bytes]) -&gt;&#39;Ref&#39;:</span>
<span class="gi">+def parse_ref(</span>
<span class="gi">+    container: Union[&quot;Repo&quot;, &quot;RefsContainer&quot;], refspec: Union[str, bytes]</span>
<span class="gi">+) -&gt; &quot;Ref&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string referring to a reference.

<span class="w"> </span>    Args:
<span class="gu">@@ -43,12 +81,27 @@ def parse_ref(container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;], refspec: Union[str,</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If the ref can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refspec = to_bytes(refspec)</span>
<span class="gi">+    possible_refs = [</span>
<span class="gi">+        refspec,</span>
<span class="gi">+        b&quot;refs/&quot; + refspec,</span>
<span class="gi">+        b&quot;refs/tags/&quot; + refspec,</span>
<span class="gi">+        b&quot;refs/heads/&quot; + refspec,</span>
<span class="gi">+        b&quot;refs/remotes/&quot; + refspec,</span>
<span class="gi">+        b&quot;refs/remotes/&quot; + refspec + b&quot;/HEAD&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    for ref in possible_refs:</span>
<span class="gi">+        if ref in container:</span>
<span class="gi">+            return ref</span>
<span class="gi">+    raise KeyError(refspec)</span>


<span class="gd">-def parse_reftuple(lh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;],</span>
<span class="gd">-    rh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;], refspec: Union[str, bytes</span>
<span class="gd">-    ], force: bool=False) -&gt;Tuple[Optional[&#39;Ref&#39;], Optional[&#39;Ref&#39;], bool]:</span>
<span class="gi">+def parse_reftuple(</span>
<span class="gi">+    lh_container: Union[&quot;Repo&quot;, &quot;RefsContainer&quot;],</span>
<span class="gi">+    rh_container: Union[&quot;Repo&quot;, &quot;RefsContainer&quot;],</span>
<span class="gi">+    refspec: Union[str, bytes],</span>
<span class="gi">+    force: bool = False,</span>
<span class="gi">+) -&gt; Tuple[Optional[&quot;Ref&quot;], Optional[&quot;Ref&quot;], bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a reftuple spec.

<span class="w"> </span>    Args:
<span class="gu">@@ -59,12 +112,38 @@ def parse_reftuple(lh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If one of the refs can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refspec = to_bytes(refspec)</span>
<span class="gi">+    if refspec.startswith(b&quot;+&quot;):</span>
<span class="gi">+        force = True</span>
<span class="gi">+        refspec = refspec[1:]</span>
<span class="gi">+    lh: Optional[bytes]</span>
<span class="gi">+    rh: Optional[bytes]</span>
<span class="gi">+    if b&quot;:&quot; in refspec:</span>
<span class="gi">+        (lh, rh) = refspec.split(b&quot;:&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        lh = rh = refspec</span>
<span class="gi">+    if lh == b&quot;&quot;:</span>
<span class="gi">+        lh = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        lh = parse_ref(lh_container, lh)</span>
<span class="gi">+    if rh == b&quot;&quot;:</span>
<span class="gi">+        rh = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rh = parse_ref(rh_container, rh)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # TODO: check force?</span>
<span class="gi">+            if b&quot;/&quot; not in rh:</span>
<span class="gi">+                rh = b&quot;refs/heads/&quot; + rh</span>
<span class="gi">+    return (lh, rh, force)</span>


<span class="gd">-def parse_reftuples(lh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;],</span>
<span class="gd">-    rh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;], refspecs: Union[bytes,</span>
<span class="gd">-    List[bytes]], force: bool=False):</span>
<span class="gi">+def parse_reftuples(</span>
<span class="gi">+    lh_container: Union[&quot;Repo&quot;, &quot;RefsContainer&quot;],</span>
<span class="gi">+    rh_container: Union[&quot;Repo&quot;, &quot;RefsContainer&quot;],</span>
<span class="gi">+    refspecs: Union[bytes, List[bytes]],</span>
<span class="gi">+    force: bool = False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of reftuple specs to a list of reftuples.

<span class="w"> </span>    Args:
<span class="gu">@@ -76,7 +155,13 @@ def parse_reftuples(lh_container: Union[&#39;Repo&#39;, &#39;RefsContainer&#39;],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If one of the refs can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(refspecs, list):</span>
<span class="gi">+        refspecs = [refspecs]</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    # TODO: Support * in refspecs</span>
<span class="gi">+    for refspec in refspecs:</span>
<span class="gi">+        ret.append(parse_reftuple(lh_container, rh_container, refspec, force=force))</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>def parse_refs(container, refspecs):
<span class="gu">@@ -89,11 +174,18 @@ def parse_refs(container, refspecs):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: If one of the refs can not be found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO: Support * in refspecs</span>
<span class="gi">+    if not isinstance(refspecs, list):</span>
<span class="gi">+        refspecs = [refspecs]</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for refspec in refspecs:</span>
<span class="gi">+        ret.append(parse_ref(container, refspec))</span>
<span class="gi">+    return ret</span>


<span class="gd">-def parse_commit_range(repo: &#39;Repo&#39;, committishs: Union[str, bytes]</span>
<span class="gd">-    ) -&gt;Iterator[&#39;Commit&#39;]:</span>
<span class="gi">+def parse_commit_range(</span>
<span class="gi">+    repo: &quot;Repo&quot;, committishs: Union[str, bytes]</span>
<span class="gi">+) -&gt; Iterator[&quot;Commit&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string referring to a range of commits.

<span class="w"> </span>    Args:
<span class="gu">@@ -104,23 +196,35 @@ def parse_commit_range(repo: &#39;Repo&#39;, committishs: Union[str, bytes]</span>
<span class="w"> </span>      KeyError: When the reference commits can not be found
<span class="w"> </span>      ValueError: If the range can not be parsed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    committishs = to_bytes(committishs)</span>
<span class="gi">+    # TODO(jelmer): Support more than a single commit..</span>
<span class="gi">+    return iter([parse_commit(repo, committishs)])</span>


<span class="w"> </span>class AmbiguousShortId(Exception):
<span class="w"> </span>    &quot;&quot;&quot;The short id is ambiguous.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, prefix, options) -&gt;None:</span>
<span class="gi">+    def __init__(self, prefix, options) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.options = options


<span class="w"> </span>def scan_for_short_id(object_store, prefix):
<span class="w"> </span>    &quot;&quot;&quot;Scan an object store for a short id.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO(jelmer): This could short-circuit looking for objects</span>
<span class="gi">+    # starting with a certain prefix.</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for object_id in object_store:</span>
<span class="gi">+        if object_id.startswith(prefix):</span>
<span class="gi">+            ret.append(object_store[object_id])</span>
<span class="gi">+    if not ret:</span>
<span class="gi">+        raise KeyError(prefix)</span>
<span class="gi">+    if len(ret) == 1:</span>
<span class="gi">+        return ret[0]</span>
<span class="gi">+    raise AmbiguousShortId(prefix, ret)</span>


<span class="gd">-def parse_commit(repo: &#39;Repo&#39;, committish: Union[str, bytes]) -&gt;&#39;Commit&#39;:</span>
<span class="gi">+def parse_commit(repo: &quot;Repo&quot;, committish: Union[str, bytes]) -&gt; &quot;Commit&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string referring to a single commit.

<span class="w"> </span>    Args:
<span class="gu">@@ -131,4 +235,26 @@ def parse_commit(repo: &#39;Repo&#39;, committish: Union[str, bytes]) -&gt;&#39;Commit&#39;:</span>
<span class="w"> </span>      KeyError: When the reference commits can not be found
<span class="w"> </span>      ValueError: If the range can not be parsed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    committish = to_bytes(committish)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return repo[committish]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return repo[parse_ref(repo, committish)]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    if len(committish) &gt;= 4 and len(committish) &lt; 40:</span>
<span class="gi">+        try:</span>
<span class="gi">+            int(committish, 16)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return scan_for_short_id(repo.object_store, committish)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    raise KeyError(committish)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO: parse_path_in_tree(), which handles e.g. v1.0:Documentation</span>
<span class="gh">diff --git a/dulwich/pack.py b/dulwich/pack.py</span>
<span class="gh">index 453c10c4..988f7a9d 100644</span>
<span class="gd">--- a/dulwich/pack.py</span>
<span class="gi">+++ b/dulwich/pack.py</span>
<span class="gu">@@ -1,3 +1,24 @@</span>
<span class="gi">+# pack.py -- For dealing with packed git objects.</span>
<span class="gi">+# Copyright (C) 2007 James Westby &lt;jw+debian@jameswestby.net&gt;</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes for dealing with packed git objects.

<span class="w"> </span>A pack is a compact representation of a bunch of objects, stored
<span class="gu">@@ -10,14 +31,17 @@ To find an object you look in all of the index files &#39;til you find a</span>
<span class="w"> </span>match for the object name. You then use the pointer got from this as
<span class="w"> </span>a pointer in to the corresponding packfile.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>from collections import defaultdict, deque
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from io import BytesIO, UnsupportedOperation
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from cdifflib import CSequenceMatcher as SequenceMatcher
<span class="w"> </span>except ModuleNotFoundError:
<span class="w"> </span>    from difflib import SequenceMatcher
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import struct
<span class="w"> </span>import sys
<span class="gu">@@ -27,24 +51,52 @@ from hashlib import sha1</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from os import SEEK_CUR, SEEK_END
<span class="w"> </span>from struct import unpack_from
<span class="gd">-from typing import BinaryIO, Callable, Deque, Dict, Generic, Iterable, Iterator, List, Optional, Protocol, Sequence, Set, Tuple, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    BinaryIO,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Deque,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    Sequence,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import mmap
<span class="w"> </span>except ImportError:
<span class="w"> </span>    has_mmap = False
<span class="w"> </span>else:
<span class="w"> </span>    has_mmap = True
<span class="gd">-if sys.platform == &#39;Plan9&#39;:</span>
<span class="gi">+</span>
<span class="gi">+# For some reason the above try, except fails to set has_mmap = False for plan9</span>
<span class="gi">+if sys.platform == &quot;Plan9&quot;:</span>
<span class="w"> </span>    has_mmap = False
<span class="gi">+</span>
<span class="w"> </span>from .errors import ApplyDeltaError, ChecksumMismatch
<span class="w"> </span>from .file import GitFile
<span class="w"> </span>from .lru_cache import LRUSizeCache
<span class="w"> </span>from .objects import ObjectID, ShaFile, hex_to_sha, object_header, sha_to_hex
<span class="gi">+</span>
<span class="w"> </span>OFS_DELTA = 6
<span class="w"> </span>REF_DELTA = 7
<span class="gd">-DELTA_TYPES = OFS_DELTA, REF_DELTA</span>
<span class="gi">+</span>
<span class="gi">+DELTA_TYPES = (OFS_DELTA, REF_DELTA)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_PACK_DELTA_WINDOW_SIZE = 10
<span class="gi">+</span>
<span class="gi">+# Keep pack files under 16Mb in memory, otherwise write them out to disk</span>
<span class="w"> </span>PACK_SPOOL_FILE_MAX_SIZE = 16 * 1024 * 1024
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>OldUnpackedObject = Union[Tuple[Union[bytes, int], List[bytes]], List[bytes]]
<span class="w"> </span>ResolveExtRefFn = Callable[[bytes], Tuple[int, OldUnpackedObject]]
<span class="w"> </span>ProgressFn = Callable[[int, str], None]
<span class="gu">@@ -59,57 +111,76 @@ class UnresolvedDeltas(Exception):</span>


<span class="w"> </span>class ObjectContainer(Protocol):
<span class="gd">-</span>
<span class="gd">-    def add_object(self, obj: ShaFile) -&gt;None:</span>
<span class="gi">+    def add_object(self, obj: ShaFile) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a single object to this object store.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def add_objects(self, objects: Sequence[Tuple[ShaFile, Optional[str]]],</span>
<span class="gd">-        progress: Optional[Callable[[str], None]]=None) -&gt;None:</span>
<span class="gi">+    def add_objects(</span>
<span class="gi">+        self,</span>
<span class="gi">+        objects: Sequence[Tuple[ShaFile, Optional[str]]],</span>
<span class="gi">+        progress: Optional[Callable[[str], None]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a set of objects to this object store.

<span class="w"> </span>        Args:
<span class="w"> </span>          objects: Iterable over a list of (object, path) tuples
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def __contains__(self, sha1: bytes) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, sha1: bytes) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a hex sha is present.&quot;&quot;&quot;

<span class="gd">-    def __getitem__(self, sha1: bytes) -&gt;ShaFile:</span>
<span class="gi">+    def __getitem__(self, sha1: bytes) -&gt; ShaFile:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve an object.&quot;&quot;&quot;


<span class="w"> </span>class PackedObjectContainer(ObjectContainer):
<span class="gd">-</span>
<span class="gd">-    def get_unpacked_object(self, sha1: bytes, *, include_comp: bool=False</span>
<span class="gd">-        ) -&gt;&#39;UnpackedObject&#39;:</span>
<span class="gi">+    def get_unpacked_object(</span>
<span class="gi">+        self, sha1: bytes, *, include_comp: bool = False</span>
<span class="gi">+    ) -&gt; &quot;UnpackedObject&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a raw unresolved object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_unpacked_object)</span>

<span class="gi">+    def iterobjects_subset(</span>
<span class="gi">+        self, shas: Iterable[bytes], *, allow_missing: bool = False</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        raise NotImplementedError(self.iterobjects_subset)</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked_subset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        shas: Set[bytes],</span>
<span class="gi">+        include_comp: bool = False,</span>
<span class="gi">+        allow_missing: bool = False,</span>
<span class="gi">+        convert_ofs_delta: bool = True,</span>
<span class="gi">+    ) -&gt; Iterator[&quot;UnpackedObject&quot;]:</span>
<span class="gi">+        raise NotImplementedError(self.iter_unpacked_subset)</span>

<span class="gd">-class UnpackedObjectStream:</span>

<span class="gd">-    def __iter__(self) -&gt;Iterator[&#39;UnpackedObject&#39;]:</span>
<span class="gi">+class UnpackedObjectStream:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[&quot;UnpackedObject&quot;]:</span>
<span class="w"> </span>        raise NotImplementedError(self.__iter__)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        raise NotImplementedError(self.__len__)


<span class="gd">-def take_msb_bytes(read: Callable[[int], bytes], crc32: Optional[int]=None</span>
<span class="gd">-    ) -&gt;Tuple[List[int], Optional[int]]:</span>
<span class="gi">+def take_msb_bytes(</span>
<span class="gi">+    read: Callable[[int], bytes], crc32: Optional[int] = None</span>
<span class="gi">+) -&gt; Tuple[List[int], Optional[int]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read bytes marked with most significant bit.

<span class="w"> </span>    Args:
<span class="w"> </span>      read: Read function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ret: List[int] = []</span>
<span class="gi">+    while len(ret) == 0 or ret[-1] &amp; 0x80:</span>
<span class="gi">+        b = read(1)</span>
<span class="gi">+        if crc32 is not None:</span>
<span class="gi">+            crc32 = binascii.crc32(b, crc32)</span>
<span class="gi">+        ret.append(ord(b[:1]))</span>
<span class="gi">+    return ret, crc32</span>


<span class="w"> </span>class PackFileDisappeared(Exception):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, obj) -&gt;None:</span>
<span class="gi">+    def __init__(self, obj) -&gt; None:</span>
<span class="w"> </span>        self.obj = obj


<span class="gu">@@ -123,17 +194,39 @@ class UnpackedObject:</span>
<span class="w"> </span>    End users of this object should take care that the function they&#39;re getting
<span class="w"> </span>    this object from is guaranteed to set the members they need.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;offset&#39;, &#39;_sha&#39;, &#39;obj_type_num&#39;, &#39;obj_chunks&#39;,</span>
<span class="gd">-        &#39;pack_type_num&#39;, &#39;delta_base&#39;, &#39;comp_chunks&#39;, &#39;decomp_chunks&#39;,</span>
<span class="gd">-        &#39;decomp_len&#39;, &#39;crc32&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;offset&quot;,  # Offset in its pack.</span>
<span class="gi">+        &quot;_sha&quot;,  # Cached binary SHA.</span>
<span class="gi">+        &quot;obj_type_num&quot;,  # Type of this object.</span>
<span class="gi">+        &quot;obj_chunks&quot;,  # Decompressed and delta-resolved chunks.</span>
<span class="gi">+        &quot;pack_type_num&quot;,  # Type of this object in the pack (may be a delta).</span>
<span class="gi">+        &quot;delta_base&quot;,  # Delta base offset or SHA.</span>
<span class="gi">+        &quot;comp_chunks&quot;,  # Compressed object chunks.</span>
<span class="gi">+        &quot;decomp_chunks&quot;,  # Decompressed object chunks.</span>
<span class="gi">+        &quot;decomp_len&quot;,  # Decompressed length of this object.</span>
<span class="gi">+        &quot;crc32&quot;,  # CRC32.</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    obj_type_num: Optional[int]
<span class="w"> </span>    obj_chunks: Optional[List[bytes]]
<span class="w"> </span>    delta_base: Union[None, bytes, int]
<span class="w"> </span>    decomp_chunks: List[bytes]
<span class="w"> </span>    comp_chunks: Optional[List[bytes]]

<span class="gd">-    def __init__(self, pack_type_num, *, delta_base=None, decomp_len=None,</span>
<span class="gd">-        crc32=None, sha=None, decomp_chunks=None, offset=None) -&gt;None:</span>
<span class="gi">+    # TODO(dborowitz): read_zlib_chunks and unpack_object could very well be</span>
<span class="gi">+    # methods of this object.</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pack_type_num,</span>
<span class="gi">+        *,</span>
<span class="gi">+        delta_base=None,</span>
<span class="gi">+        decomp_len=None,</span>
<span class="gi">+        crc32=None,</span>
<span class="gi">+        sha=None,</span>
<span class="gi">+        decomp_chunks=None,</span>
<span class="gi">+        offset=None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.offset = offset
<span class="w"> </span>        self._sha = sha
<span class="w"> </span>        self.pack_type_num = pack_type_num
<span class="gu">@@ -145,6 +238,7 @@ class UnpackedObject:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.decomp_len = decomp_len
<span class="w"> </span>        self.crc32 = crc32
<span class="gi">+</span>
<span class="w"> </span>        if pack_type_num in DELTA_TYPES:
<span class="w"> </span>            self.obj_type_num = None
<span class="w"> </span>            self.obj_chunks = None
<span class="gu">@@ -155,15 +249,24 @@ class UnpackedObject:</span>

<span class="w"> </span>    def sha(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the binary SHA of this object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sha is None:</span>
<span class="gi">+            self._sha = obj_sha(self.obj_type_num, self.obj_chunks)</span>
<span class="gi">+        return self._sha</span>

<span class="w"> </span>    def sha_file(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a ShaFile from this object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.obj_type_num is not None and self.obj_chunks is not None</span>
<span class="gi">+        return ShaFile.from_raw_chunks(self.obj_type_num, self.obj_chunks)</span>

<span class="gd">-    def _obj(self) -&gt;OldUnpackedObject:</span>
<span class="gi">+    # Only provided for backwards compatibility with code that expects either</span>
<span class="gi">+    # chunks or a delta tuple.</span>
<span class="gi">+    def _obj(self) -&gt; OldUnpackedObject:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the decompressed chunks, or (delta base, delta chunks).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.pack_type_num in DELTA_TYPES:</span>
<span class="gi">+            assert isinstance(self.delta_base, (bytes, int))</span>
<span class="gi">+            return (self.delta_base, self.decomp_chunks)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.decomp_chunks</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, UnpackedObject):
<span class="gu">@@ -174,19 +277,22 @@ class UnpackedObject:</span>
<span class="w"> </span>        return True

<span class="w"> </span>    def __ne__(self, other):
<span class="gd">-        return not self == other</span>
<span class="gi">+        return not (self == other)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        data = [f&#39;{s}={getattr(self, s)!r}&#39; for s in self.__slots__]</span>
<span class="gd">-        return &#39;{}({})&#39;.format(self.__class__.__name__, &#39;, &#39;.join(data))</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        data = [f&quot;{s}={getattr(self, s)!r}&quot; for s in self.__slots__]</span>
<span class="gi">+        return &quot;{}({})&quot;.format(self.__class__.__name__, &quot;, &quot;.join(data))</span>


<span class="w"> </span>_ZLIB_BUFSIZE = 4096


<span class="gd">-def read_zlib_chunks(read_some: Callable[[int], bytes], unpacked:</span>
<span class="gd">-    UnpackedObject, include_comp: bool=False, buffer_size: int=_ZLIB_BUFSIZE</span>
<span class="gd">-    ) -&gt;bytes:</span>
<span class="gi">+def read_zlib_chunks(</span>
<span class="gi">+    read_some: Callable[[int], bytes],</span>
<span class="gi">+    unpacked: UnpackedObject,</span>
<span class="gi">+    include_comp: bool = False,</span>
<span class="gi">+    buffer_size: int = _ZLIB_BUFSIZE,</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read zlib data from a buffer.

<span class="w"> </span>    This function requires that the buffer have additional data following the
<span class="gu">@@ -210,7 +316,43 @@ def read_zlib_chunks(read_some: Callable[[int], bytes], unpacked:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      zlib.error: if a decompression error occurred.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if unpacked.decomp_len &lt;= -1:</span>
<span class="gi">+        raise ValueError(&quot;non-negative zlib data stream size expected&quot;)</span>
<span class="gi">+    decomp_obj = zlib.decompressobj()</span>
<span class="gi">+</span>
<span class="gi">+    comp_chunks = []</span>
<span class="gi">+    decomp_chunks = unpacked.decomp_chunks</span>
<span class="gi">+    decomp_len = 0</span>
<span class="gi">+    crc32 = unpacked.crc32</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        add = read_some(buffer_size)</span>
<span class="gi">+        if not add:</span>
<span class="gi">+            raise zlib.error(&quot;EOF before end of zlib stream&quot;)</span>
<span class="gi">+        comp_chunks.append(add)</span>
<span class="gi">+        decomp = decomp_obj.decompress(add)</span>
<span class="gi">+        decomp_len += len(decomp)</span>
<span class="gi">+        decomp_chunks.append(decomp)</span>
<span class="gi">+        unused = decomp_obj.unused_data</span>
<span class="gi">+        if unused:</span>
<span class="gi">+            left = len(unused)</span>
<span class="gi">+            if crc32 is not None:</span>
<span class="gi">+                crc32 = binascii.crc32(add[:-left], crc32)</span>
<span class="gi">+            if include_comp:</span>
<span class="gi">+                comp_chunks[-1] = add[:-left]</span>
<span class="gi">+            break</span>
<span class="gi">+        elif crc32 is not None:</span>
<span class="gi">+            crc32 = binascii.crc32(add, crc32)</span>
<span class="gi">+    if crc32 is not None:</span>
<span class="gi">+        crc32 &amp;= 0xFFFFFFFF</span>
<span class="gi">+</span>
<span class="gi">+    if decomp_len != unpacked.decomp_len:</span>
<span class="gi">+        raise zlib.error(&quot;decompressed data does not match expected size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    unpacked.crc32 = crc32</span>
<span class="gi">+    if include_comp:</span>
<span class="gi">+        unpacked.comp_chunks = comp_chunks</span>
<span class="gi">+    return unused</span>


<span class="w"> </span>def iter_sha1(iter):
<span class="gu">@@ -220,7 +362,10 @@ def iter_sha1(iter):</span>
<span class="w"> </span>      iter: Iterator over string objects
<span class="w"> </span>    Returns: 40-byte hex sha1 digest
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sha = sha1()</span>
<span class="gi">+    for name in iter:</span>
<span class="gi">+        sha.update(name)</span>
<span class="gi">+    return sha.hexdigest().encode(&quot;ascii&quot;)</span>


<span class="w"> </span>def load_pack_index(path):
<span class="gu">@@ -230,7 +375,30 @@ def load_pack_index(path):</span>
<span class="w"> </span>      path: Path to the index file
<span class="w"> </span>    Returns: A PackIndex loaded from the given path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with GitFile(path, &quot;rb&quot;) as f:</span>
<span class="gi">+        return load_pack_index_file(path, f)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_file_contents(f, size=None):</span>
<span class="gi">+    try:</span>
<span class="gi">+        fd = f.fileno()</span>
<span class="gi">+    except (UnsupportedOperation, AttributeError):</span>
<span class="gi">+        fd = None</span>
<span class="gi">+    # Attempt to use mmap if possible</span>
<span class="gi">+    if fd is not None:</span>
<span class="gi">+        if size is None:</span>
<span class="gi">+            size = os.fstat(fd).st_size</span>
<span class="gi">+        if has_mmap:</span>
<span class="gi">+            try:</span>
<span class="gi">+                contents = mmap.mmap(fd, size, access=mmap.ACCESS_READ)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # Perhaps a socket?</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                return contents, size</span>
<span class="gi">+    contents = f.read()</span>
<span class="gi">+    size = len(contents)</span>
<span class="gi">+    return contents, size</span>


<span class="w"> </span>def load_pack_index_file(path, f):
<span class="gu">@@ -241,7 +409,15 @@ def load_pack_index_file(path, f):</span>
<span class="w"> </span>      f: File-like object
<span class="w"> </span>    Returns: A PackIndex loaded from the given file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    contents, size = _load_file_contents(f)</span>
<span class="gi">+    if contents[:4] == b&quot;\377tOc&quot;:</span>
<span class="gi">+        version = struct.unpack(b&quot;&gt;L&quot;, contents[4:8])[0]</span>
<span class="gi">+        if version == 2:</span>
<span class="gi">+            return PackIndex2(path, file=f, contents=contents, size=size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise KeyError(&quot;Unknown pack index format %d&quot; % version)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return PackIndex1(path, file=f, contents=contents, size=size)</span>


<span class="w"> </span>def bisect_find_sha(start, end, sha, unpack_name):
<span class="gu">@@ -254,7 +430,17 @@ def bisect_find_sha(start, end, sha, unpack_name):</span>
<span class="w"> </span>      unpack_name: Callback to retrieve SHA by index
<span class="w"> </span>    Returns: Index of the SHA, or None if it wasn&#39;t found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert start &lt;= end</span>
<span class="gi">+    while start &lt;= end:</span>
<span class="gi">+        i = (start + end) // 2</span>
<span class="gi">+        file_sha = unpack_name(i)</span>
<span class="gi">+        if file_sha &lt; sha:</span>
<span class="gi">+            start = i + 1</span>
<span class="gi">+        elif file_sha &gt; sha:</span>
<span class="gi">+            end = i - 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            return i</span>
<span class="gi">+    return None</span>


<span class="w"> </span>PackIndexEntry = Tuple[bytes, int, Optional[int]]
<span class="gu">@@ -270,8 +456,10 @@ class PackIndex:</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, PackIndex):
<span class="w"> </span>            return False
<span class="gd">-        for (name1, _, _), (name2, _, _) in zip(self.iterentries(), other.</span>
<span class="gd">-            iterentries()):</span>
<span class="gi">+</span>
<span class="gi">+        for (name1, _, _), (name2, _, _) in zip(</span>
<span class="gi">+            self.iterentries(), other.iterentries()</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            if name1 != name2:
<span class="w"> </span>                return False
<span class="w"> </span>        return True
<span class="gu">@@ -279,66 +467,82 @@ class PackIndex:</span>
<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self.__eq__(other)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number of entries in this pack index.&quot;&quot;&quot;
<span class="w"> </span>        raise NotImplementedError(self.__len__)

<span class="gd">-    def __iter__(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the SHAs in this pack.&quot;&quot;&quot;
<span class="w"> </span>        return map(sha_to_hex, self._itersha())

<span class="gd">-    def iterentries(self) -&gt;Iterator[PackIndexEntry]:</span>
<span class="gi">+    def iterentries(self) -&gt; Iterator[PackIndexEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the entries in this pack index.

<span class="w"> </span>        Returns: iterator over tuples with object name, offset in packfile and
<span class="w"> </span>            crc32 checksum.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.iterentries)</span>

<span class="gd">-    def get_pack_checksum(self) -&gt;bytes:</span>
<span class="gi">+    def get_pack_checksum(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the SHA1 checksum stored for the corresponding packfile.

<span class="w"> </span>        Returns: 20-byte binary digest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_pack_checksum)</span>
<span class="gi">+</span>
<span class="gi">+    def object_index(self, sha: bytes) -&gt; int:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Please use object_offset instead&quot;, DeprecationWarning, stacklevel=2</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.object_offset(sha)</span>

<span class="gd">-    def object_offset(self, sha: bytes) -&gt;int:</span>
<span class="gi">+    def object_offset(self, sha: bytes) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the offset in to the corresponding packfile for the object.

<span class="w"> </span>        Given the name of an object it will return the offset that object
<span class="w"> </span>        lives at within the corresponding pack file. If the pack file doesn&#39;t
<span class="w"> </span>        have the object then None will be returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.object_offset)</span>

<span class="gd">-    def object_sha1(self, index: int) -&gt;bytes:</span>
<span class="gi">+    def object_sha1(self, index: int) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the SHA1 corresponding to the index in the pack file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, offset, crc32 in self.iterentries():</span>
<span class="gi">+            if offset == index:</span>
<span class="gi">+                return name</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise KeyError(index)</span>

<span class="gd">-    def _object_offset(self, sha: bytes) -&gt;int:</span>
<span class="gi">+    def _object_offset(self, sha: bytes) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;See object_offset.

<span class="w"> </span>        Args:
<span class="w"> </span>          sha: A *binary* SHA string. (20 characters long)_
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._object_offset)</span>

<span class="gd">-    def objects_sha1(self) -&gt;bytes:</span>
<span class="gi">+    def objects_sha1(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the hex SHA1 over all the shas of all objects in this pack.

<span class="w"> </span>        Note: This is used for the filename of the pack.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return iter_sha1(self._itersha())</span>

<span class="gd">-    def _itersha(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+    def _itersha(self) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield all the SHA1&#39;s of the objects in the index, sorted.&quot;&quot;&quot;
<span class="gi">+        raise NotImplementedError(self._itersha)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def check(self) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="w"> </span>class MemoryPackIndex(PackIndex):
<span class="w"> </span>    &quot;&quot;&quot;Pack index that is stored entirely in memory.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, entries, pack_checksum=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, entries, pack_checksum=None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new MemoryPackIndex.

<span class="w"> </span>        Args:
<span class="gu">@@ -353,9 +557,34 @@ class MemoryPackIndex(PackIndex):</span>
<span class="w"> </span>        self._entries = entries
<span class="w"> </span>        self._pack_checksum = pack_checksum

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def get_pack_checksum(self):</span>
<span class="gi">+        return self._pack_checksum</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._entries)

<span class="gi">+    def object_offset(self, sha):</span>
<span class="gi">+        if len(sha) == 40:</span>
<span class="gi">+            sha = hex_to_sha(sha)</span>
<span class="gi">+        return self._by_sha[sha]</span>
<span class="gi">+</span>
<span class="gi">+    def object_sha1(self, offset):</span>
<span class="gi">+        return self._by_offset[offset]</span>
<span class="gi">+</span>
<span class="gi">+    def _itersha(self):</span>
<span class="gi">+        return iter(self._by_sha)</span>
<span class="gi">+</span>
<span class="gi">+    def iterentries(self):</span>
<span class="gi">+        return iter(self._entries)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def for_pack(cls, pack):</span>
<span class="gi">+        return MemoryPackIndex(pack.sorted_entries(), pack.calculate_checksum())</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def clone(cls, other_index):</span>
<span class="gi">+        return cls(other_index.iterentries(), other_index.get_pack_checksum())</span>
<span class="gi">+</span>

<span class="w"> </span>class FilePackIndex(PackIndex):
<span class="w"> </span>    &quot;&quot;&quot;Pack index that is based on a file.
<span class="gu">@@ -368,136 +597,223 @@ class FilePackIndex(PackIndex):</span>
<span class="w"> </span>    the start and end offset and then bisect in to find if the value is
<span class="w"> </span>    present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _fan_out_table: List[int]

<span class="gd">-    def __init__(self, filename, file=None, contents=None, size=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename, file=None, contents=None, size=None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a pack index object.

<span class="w"> </span>        Provide it with the name of the index file to consider, and it will map
<span class="w"> </span>        it whenever required.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._filename = filename
<span class="gi">+        # Take the size now, so it can be checked each time we map the file to</span>
<span class="gi">+        # ensure that it hasn&#39;t changed.</span>
<span class="w"> </span>        if file is None:
<span class="gd">-            self._file = GitFile(filename, &#39;rb&#39;)</span>
<span class="gi">+            self._file = GitFile(filename, &quot;rb&quot;)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._file = file
<span class="w"> </span>        if contents is None:
<span class="w"> </span>            self._contents, self._size = _load_file_contents(self._file, size)
<span class="w"> </span>        else:
<span class="gd">-            self._contents, self._size = contents, size</span>
<span class="gi">+            self._contents, self._size = (contents, size)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def path(self) -&gt; str:</span>
<span class="gi">+        return self._filename</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        if isinstance(other, FilePackIndex</span>
<span class="gd">-            ) and self._fan_out_table != other._fan_out_table:</span>
<span class="gi">+        # Quick optimization:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(other, FilePackIndex)</span>
<span class="gi">+            and self._fan_out_table != other._fan_out_table</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            return False
<span class="gi">+</span>
<span class="w"> </span>        return super().__eq__(other)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        self._file.close()</span>
<span class="gi">+        if getattr(self._contents, &quot;close&quot;, None) is not None:</span>
<span class="gi">+            self._contents.close()</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number of entries in this pack index.&quot;&quot;&quot;
<span class="w"> </span>        return self._fan_out_table[-1]

<span class="gd">-    def _unpack_entry(self, i: int) -&gt;PackIndexEntry:</span>
<span class="gi">+    def _unpack_entry(self, i: int) -&gt; PackIndexEntry:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unpack the i-th entry in the index file.

<span class="w"> </span>        Returns: Tuple with object name (SHA), offset in pack file and CRC32
<span class="w"> </span>            checksum (if known).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._unpack_entry)</span>

<span class="w"> </span>    def _unpack_name(self, i):
<span class="w"> </span>        &quot;&quot;&quot;Unpack the i-th name from the index file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._unpack_name)</span>

<span class="w"> </span>    def _unpack_offset(self, i):
<span class="w"> </span>        &quot;&quot;&quot;Unpack the i-th object offset from the index file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._unpack_offset)</span>

<span class="w"> </span>    def _unpack_crc32_checksum(self, i):
<span class="w"> </span>        &quot;&quot;&quot;Unpack the crc32 checksum for the ith object from the index file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._unpack_crc32_checksum)</span>
<span class="gi">+</span>
<span class="gi">+    def _itersha(self) -&gt; Iterator[bytes]:</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            yield self._unpack_name(i)</span>

<span class="gd">-    def iterentries(self) -&gt;Iterator[PackIndexEntry]:</span>
<span class="gi">+    def iterentries(self) -&gt; Iterator[PackIndexEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the entries in this pack index.

<span class="w"> </span>        Returns: iterator over tuples with object name, offset in packfile and
<span class="w"> </span>            crc32 checksum.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def check(self) -&gt;None:</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            yield self._unpack_entry(i)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_fan_out_table(self, start_offset: int):</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for i in range(0x100):</span>
<span class="gi">+            fanout_entry = self._contents[</span>
<span class="gi">+                start_offset + i * 4 : start_offset + (i + 1) * 4</span>
<span class="gi">+            ]</span>
<span class="gi">+            ret.append(struct.unpack(&quot;&gt;L&quot;, fanout_entry)[0])</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def check(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the stored checksum matches the actual checksum.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        actual = self.calculate_checksum()</span>
<span class="gi">+        stored = self.get_stored_checksum()</span>
<span class="gi">+        if actual != stored:</span>
<span class="gi">+            raise ChecksumMismatch(stored, actual)</span>

<span class="gd">-    def calculate_checksum(self) -&gt;bytes:</span>
<span class="gi">+    def calculate_checksum(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calculate the SHA1 checksum over this pack index.

<span class="w"> </span>        Returns: This is a 20-byte binary digest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sha1(self._contents[:-20]).digest()</span>

<span class="gd">-    def get_pack_checksum(self) -&gt;bytes:</span>
<span class="gi">+    def get_pack_checksum(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the SHA1 checksum stored for the corresponding packfile.

<span class="w"> </span>        Returns: 20-byte binary digest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytes(self._contents[-40:-20])</span>

<span class="gd">-    def get_stored_checksum(self) -&gt;bytes:</span>
<span class="gi">+    def get_stored_checksum(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the SHA1 checksum stored for this index.

<span class="w"> </span>        Returns: 20-byte binary digest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytes(self._contents[-20:])</span>

<span class="gd">-    def object_offset(self, sha: bytes) -&gt;int:</span>
<span class="gi">+    def object_offset(self, sha: bytes) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the offset in to the corresponding packfile for the object.

<span class="w"> </span>        Given the name of an object it will return the offset that object
<span class="w"> </span>        lives at within the corresponding pack file. If the pack file doesn&#39;t
<span class="w"> </span>        have the object then None will be returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _object_offset(self, sha: bytes) -&gt;int:</span>
<span class="gi">+        if len(sha) == 40:</span>
<span class="gi">+            sha = hex_to_sha(sha)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._object_offset(sha)</span>
<span class="gi">+        except ValueError as exc:</span>
<span class="gi">+            closed = getattr(self._contents, &quot;closed&quot;, None)</span>
<span class="gi">+            if closed in (None, True):</span>
<span class="gi">+                raise PackFileDisappeared(self) from exc</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _object_offset(self, sha: bytes) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;See object_offset.

<span class="w"> </span>        Args:
<span class="w"> </span>          sha: A *binary* SHA string. (20 characters long)_
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert len(sha) == 20</span>
<span class="gi">+        idx = ord(sha[:1])</span>
<span class="gi">+        if idx == 0:</span>
<span class="gi">+            start = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = self._fan_out_table[idx - 1]</span>
<span class="gi">+        end = self._fan_out_table[idx]</span>
<span class="gi">+        i = bisect_find_sha(start, end, sha, self._unpack_name)</span>
<span class="gi">+        if i is None:</span>
<span class="gi">+            raise KeyError(sha)</span>
<span class="gi">+        return self._unpack_offset(i)</span>


<span class="w"> </span>class PackIndex1(FilePackIndex):
<span class="w"> </span>    &quot;&quot;&quot;Version 1 Pack Index file.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename: str, file=None, contents=None, size=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: str, file=None, contents=None, size=None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(filename, file, contents, size)
<span class="w"> </span>        self.version = 1
<span class="w"> </span>        self._fan_out_table = self._read_fan_out_table(0)

<span class="gi">+    def _unpack_entry(self, i):</span>
<span class="gi">+        (offset, name) = unpack_from(&quot;&gt;L20s&quot;, self._contents, (0x100 * 4) + (i * 24))</span>
<span class="gi">+        return (name, offset, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_name(self, i):</span>
<span class="gi">+        offset = (0x100 * 4) + (i * 24) + 4</span>
<span class="gi">+        return self._contents[offset : offset + 20]</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_offset(self, i):</span>
<span class="gi">+        offset = (0x100 * 4) + (i * 24)</span>
<span class="gi">+        return unpack_from(&quot;&gt;L&quot;, self._contents, offset)[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_crc32_checksum(self, i):</span>
<span class="gi">+        # Not stored in v1 index files</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class PackIndex2(FilePackIndex):
<span class="w"> </span>    &quot;&quot;&quot;Version 2 Pack Index file.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename: str, file=None, contents=None, size=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: str, file=None, contents=None, size=None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(filename, file, contents, size)
<span class="gd">-        if self._contents[:4] != b&#39;\xfftOc&#39;:</span>
<span class="gd">-            raise AssertionError(&#39;Not a v2 pack index file&#39;)</span>
<span class="gd">-        self.version, = unpack_from(b&#39;&gt;L&#39;, self._contents, 4)</span>
<span class="gi">+        if self._contents[:4] != b&quot;\377tOc&quot;:</span>
<span class="gi">+            raise AssertionError(&quot;Not a v2 pack index file&quot;)</span>
<span class="gi">+        (self.version,) = unpack_from(b&quot;&gt;L&quot;, self._contents, 4)</span>
<span class="w"> </span>        if self.version != 2:
<span class="gd">-            raise AssertionError(&#39;Version was %d&#39; % self.version)</span>
<span class="gi">+            raise AssertionError(&quot;Version was %d&quot; % self.version)</span>
<span class="w"> </span>        self._fan_out_table = self._read_fan_out_table(8)
<span class="gd">-        self._name_table_offset = 8 + 256 * 4</span>
<span class="gi">+        self._name_table_offset = 8 + 0x100 * 4</span>
<span class="w"> </span>        self._crc32_table_offset = self._name_table_offset + 20 * len(self)
<span class="gd">-        self._pack_offset_table_offset = self._crc32_table_offset + 4 * len(</span>
<span class="gd">-            self)</span>
<span class="gd">-        self._pack_offset_largetable_offset = (self.</span>
<span class="gd">-            _pack_offset_table_offset + 4 * len(self))</span>
<span class="gi">+        self._pack_offset_table_offset = self._crc32_table_offset + 4 * len(self)</span>
<span class="gi">+        self._pack_offset_largetable_offset = self._pack_offset_table_offset + 4 * len(</span>
<span class="gi">+            self</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_entry(self, i):</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._unpack_name(i),</span>
<span class="gi">+            self._unpack_offset(i),</span>
<span class="gi">+            self._unpack_crc32_checksum(i),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_name(self, i):</span>
<span class="gi">+        offset = self._name_table_offset + i * 20</span>
<span class="gi">+        return self._contents[offset : offset + 20]</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_offset(self, i):</span>
<span class="gi">+        offset = self._pack_offset_table_offset + i * 4</span>
<span class="gi">+        offset = unpack_from(&quot;&gt;L&quot;, self._contents, offset)[0]</span>
<span class="gi">+        if offset &amp; (2**31):</span>
<span class="gi">+            offset = self._pack_offset_largetable_offset + (offset &amp; (2**31 - 1)) * 8</span>
<span class="gi">+            offset = unpack_from(&quot;&gt;Q&quot;, self._contents, offset)[0]</span>
<span class="gi">+        return offset</span>
<span class="gi">+</span>
<span class="gi">+    def _unpack_crc32_checksum(self, i):</span>
<span class="gi">+        return unpack_from(&quot;&gt;L&quot;, self._contents, self._crc32_table_offset + i * 4)[0]</span>


<span class="gd">-def read_pack_header(read) -&gt;Tuple[int, int]:</span>
<span class="gi">+def read_pack_header(read) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read the header of a pack file.

<span class="w"> </span>    Args:
<span class="gu">@@ -505,12 +821,32 @@ def read_pack_header(read) -&gt;Tuple[int, int]:</span>
<span class="w"> </span>    Returns: Tuple of (pack version, number of objects). If no data is
<span class="w"> </span>        available to read, returns (None, None).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def unpack_object(read_all: Callable[[int], bytes], read_some: Optional[</span>
<span class="gd">-    Callable[[int], bytes]]=None, compute_crc32=False, include_comp=False,</span>
<span class="gd">-    zlib_bufsize=_ZLIB_BUFSIZE) -&gt;Tuple[UnpackedObject, bytes]:</span>
<span class="gi">+    header = read(12)</span>
<span class="gi">+    if not header:</span>
<span class="gi">+        raise AssertionError(&quot;file too short to contain pack&quot;)</span>
<span class="gi">+    if header[:4] != b&quot;PACK&quot;:</span>
<span class="gi">+        raise AssertionError(f&quot;Invalid pack header {header!r}&quot;)</span>
<span class="gi">+    (version,) = unpack_from(b&quot;&gt;L&quot;, header, 4)</span>
<span class="gi">+    if version not in (2, 3):</span>
<span class="gi">+        raise AssertionError(&quot;Version was %d&quot; % version)</span>
<span class="gi">+    (num_objects,) = unpack_from(b&quot;&gt;L&quot;, header, 8)</span>
<span class="gi">+    return (version, num_objects)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def chunks_length(chunks: Union[bytes, Iterable[bytes]]) -&gt; int:</span>
<span class="gi">+    if isinstance(chunks, bytes):</span>
<span class="gi">+        return len(chunks)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return sum(map(len, chunks))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unpack_object(</span>
<span class="gi">+    read_all: Callable[[int], bytes],</span>
<span class="gi">+    read_some: Optional[Callable[[int], bytes]] = None,</span>
<span class="gi">+    compute_crc32=False,</span>
<span class="gi">+    include_comp=False,</span>
<span class="gi">+    zlib_bufsize=_ZLIB_BUFSIZE,</span>
<span class="gi">+) -&gt; Tuple[UnpackedObject, bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unpack a Git object.

<span class="w"> </span>    Args:
<span class="gu">@@ -534,12 +870,59 @@ def unpack_object(read_all: Callable[[int], bytes], read_some: Optional[</span>
<span class="w"> </span>        * decomp_len
<span class="w"> </span>        * crc32          (if compute_crc32 is True)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if read_some is None:</span>
<span class="gi">+        read_some = read_all</span>
<span class="gi">+    if compute_crc32:</span>
<span class="gi">+        crc32 = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        crc32 = None</span>
<span class="gi">+</span>
<span class="gi">+    raw, crc32 = take_msb_bytes(read_all, crc32=crc32)</span>
<span class="gi">+    type_num = (raw[0] &gt;&gt; 4) &amp; 0x07</span>
<span class="gi">+    size = raw[0] &amp; 0x0F</span>
<span class="gi">+    for i, byte in enumerate(raw[1:]):</span>
<span class="gi">+        size += (byte &amp; 0x7F) &lt;&lt; ((i * 7) + 4)</span>
<span class="gi">+</span>
<span class="gi">+    delta_base: Union[int, bytes, None]</span>
<span class="gi">+    raw_base = len(raw)</span>
<span class="gi">+    if type_num == OFS_DELTA:</span>
<span class="gi">+        raw, crc32 = take_msb_bytes(read_all, crc32=crc32)</span>
<span class="gi">+        raw_base += len(raw)</span>
<span class="gi">+        if raw[-1] &amp; 0x80:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        delta_base_offset = raw[0] &amp; 0x7F</span>
<span class="gi">+        for byte in raw[1:]:</span>
<span class="gi">+            delta_base_offset += 1</span>
<span class="gi">+            delta_base_offset &lt;&lt;= 7</span>
<span class="gi">+            delta_base_offset += byte &amp; 0x7F</span>
<span class="gi">+        delta_base = delta_base_offset</span>
<span class="gi">+    elif type_num == REF_DELTA:</span>
<span class="gi">+        delta_base_obj = read_all(20)</span>
<span class="gi">+        if crc32 is not None:</span>
<span class="gi">+            crc32 = binascii.crc32(delta_base_obj, crc32)</span>
<span class="gi">+        delta_base = delta_base_obj</span>
<span class="gi">+        raw_base += 20</span>
<span class="gi">+    else:</span>
<span class="gi">+        delta_base = None</span>
<span class="gi">+</span>
<span class="gi">+    unpacked = UnpackedObject(</span>
<span class="gi">+        type_num, delta_base=delta_base, decomp_len=size, crc32=crc32</span>
<span class="gi">+    )</span>
<span class="gi">+    unused = read_zlib_chunks(</span>
<span class="gi">+        read_some,</span>
<span class="gi">+        unpacked,</span>
<span class="gi">+        buffer_size=zlib_bufsize,</span>
<span class="gi">+        include_comp=include_comp,</span>
<span class="gi">+    )</span>
<span class="gi">+    return unpacked, unused</span>


<span class="w"> </span>def _compute_object_size(value):
<span class="w"> </span>    &quot;&quot;&quot;Compute the size of a unresolved object for use with LRUSizeCache.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (num, obj) = value</span>
<span class="gi">+    if num in DELTA_TYPES:</span>
<span class="gi">+        return chunks_length(obj[1])</span>
<span class="gi">+    return chunks_length(obj)</span>


<span class="w"> </span>class PackStreamReader:
<span class="gu">@@ -549,8 +932,7 @@ class PackStreamReader:</span>
<span class="w"> </span>    appropriate.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, read_all, read_some=None, zlib_bufsize=_ZLIB_BUFSIZE</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, read_all, read_some=None, zlib_bufsize=_ZLIB_BUFSIZE) -&gt; None:</span>
<span class="w"> </span>        self.read_all = read_all
<span class="w"> </span>        if read_some is None:
<span class="w"> </span>            self.read_some = read_all
<span class="gu">@@ -559,6 +941,7 @@ class PackStreamReader:</span>
<span class="w"> </span>        self.sha = sha1()
<span class="w"> </span>        self._offset = 0
<span class="w"> </span>        self._rbuf = BytesIO()
<span class="gi">+        # trailer is a deque to avoid memory allocation on small reads</span>
<span class="w"> </span>        self._trailer: Deque[bytes] = deque()
<span class="w"> </span>        self._zlib_bufsize = zlib_bufsize

<span class="gu">@@ -573,20 +956,62 @@ class PackStreamReader:</span>
<span class="w"> </span>          size: The maximum number of bytes to read; the particular
<span class="w"> </span>            behavior is callback-specific.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = read(size)</span>
<span class="gi">+</span>
<span class="gi">+        # maintain a trailer of the last 20 bytes we&#39;ve read</span>
<span class="gi">+        n = len(data)</span>
<span class="gi">+        self._offset += n</span>
<span class="gi">+        tn = len(self._trailer)</span>
<span class="gi">+        if n &gt;= 20:</span>
<span class="gi">+            to_pop = tn</span>
<span class="gi">+            to_add = 20</span>
<span class="gi">+        else:</span>
<span class="gi">+            to_pop = max(n + tn - 20, 0)</span>
<span class="gi">+            to_add = n</span>
<span class="gi">+        self.sha.update(</span>
<span class="gi">+            bytes(bytearray([self._trailer.popleft() for _ in range(to_pop)]))</span>
<span class="gi">+        )</span>
<span class="gi">+        self._trailer.extend(data[-to_add:])</span>
<span class="gi">+</span>
<span class="gi">+        # hash everything but the trailer</span>
<span class="gi">+        self.sha.update(data[:-to_add])</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _buf_len(self):</span>
<span class="gi">+        buf = self._rbuf</span>
<span class="gi">+        start = buf.tell()</span>
<span class="gi">+        buf.seek(0, SEEK_END)</span>
<span class="gi">+        end = buf.tell()</span>
<span class="gi">+        buf.seek(start)</span>
<span class="gi">+        return end - start</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def offset(self):</span>
<span class="gi">+        return self._offset - self._buf_len()</span>

<span class="w"> </span>    def read(self, size):
<span class="w"> </span>        &quot;&quot;&quot;Read, blocking until size bytes are read.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buf_len = self._buf_len()</span>
<span class="gi">+        if buf_len &gt;= size:</span>
<span class="gi">+            return self._rbuf.read(size)</span>
<span class="gi">+        buf_data = self._rbuf.read()</span>
<span class="gi">+        self._rbuf = BytesIO()</span>
<span class="gi">+        return buf_data + self._read(self.read_all, size - buf_len)</span>

<span class="w"> </span>    def recv(self, size):
<span class="w"> </span>        &quot;&quot;&quot;Read up to size bytes, blocking until one byte is read.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+        buf_len = self._buf_len()</span>
<span class="gi">+        if buf_len:</span>
<span class="gi">+            data = self._rbuf.read(size)</span>
<span class="gi">+            if size &gt;= buf_len:</span>
<span class="gi">+                self._rbuf = BytesIO()</span>
<span class="gi">+            return data</span>
<span class="gi">+        return self._read(self.read_some, size)</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self._num_objects

<span class="gd">-    def read_objects(self, compute_crc32=False) -&gt;Iterator[UnpackedObject]:</span>
<span class="gi">+    def read_objects(self, compute_crc32=False) -&gt; Iterator[UnpackedObject]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read the objects in this pack file.

<span class="w"> </span>        Args:
<span class="gu">@@ -607,7 +1032,37 @@ class PackStreamReader:</span>
<span class="w"> </span>          zlib.error: if an error occurred during zlib decompression.
<span class="w"> </span>          IOError: if an error occurred writing to the output file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pack_version, self._num_objects = read_pack_header(self.read)</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(self._num_objects):</span>
<span class="gi">+            offset = self.offset</span>
<span class="gi">+            unpacked, unused = unpack_object(</span>
<span class="gi">+                self.read,</span>
<span class="gi">+                read_some=self.recv,</span>
<span class="gi">+                compute_crc32=compute_crc32,</span>
<span class="gi">+                zlib_bufsize=self._zlib_bufsize,</span>
<span class="gi">+            )</span>
<span class="gi">+            unpacked.offset = offset</span>
<span class="gi">+</span>
<span class="gi">+            # prepend any unused data to current read buffer</span>
<span class="gi">+            buf = BytesIO()</span>
<span class="gi">+            buf.write(unused)</span>
<span class="gi">+            buf.write(self._rbuf.read())</span>
<span class="gi">+            buf.seek(0)</span>
<span class="gi">+            self._rbuf = buf</span>
<span class="gi">+</span>
<span class="gi">+            yield unpacked</span>
<span class="gi">+</span>
<span class="gi">+        if self._buf_len() &lt; 20:</span>
<span class="gi">+            # If the read buffer is full, then the last read() got the whole</span>
<span class="gi">+            # trailer off the wire. If not, it means there is still some of the</span>
<span class="gi">+            # trailer to read. We need to read() all 20 bytes; N come from the</span>
<span class="gi">+            # read buffer and (20 - N) come from the wire.</span>
<span class="gi">+            self.read(20)</span>
<span class="gi">+</span>
<span class="gi">+        pack_sha = bytearray(self._trailer)  # type: ignore</span>
<span class="gi">+        if pack_sha != self.sha.digest():</span>
<span class="gi">+            raise ChecksumMismatch(sha_to_hex(pack_sha), self.sha.hexdigest())</span>


<span class="w"> </span>class PackStreamCopier(PackStreamReader):
<span class="gu">@@ -617,7 +1072,7 @@ class PackStreamCopier(PackStreamReader):</span>
<span class="w"> </span>    appropriate and written out to the given file-like object.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, read_all, read_some, outfile, delta_iter=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, read_all, read_some, outfile, delta_iter=None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the copier.

<span class="w"> </span>        Args:
<span class="gu">@@ -635,7 +1090,9 @@ class PackStreamCopier(PackStreamReader):</span>

<span class="w"> </span>    def _read(self, read, size):
<span class="w"> </span>        &quot;&quot;&quot;Read data from the read callback and write it to the file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = super()._read(read, size)</span>
<span class="gi">+        self.outfile.write(data)</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def verify(self, progress=None):
<span class="w"> </span>        &quot;&quot;&quot;Verify a pack stream and write it to the output file.
<span class="gu">@@ -643,12 +1100,28 @@ class PackStreamCopier(PackStreamReader):</span>
<span class="w"> </span>        See PackStreamReader.iterobjects for a list of exceptions this may
<span class="w"> </span>        throw.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i = 0  # default count of entries if read_objects() is empty</span>
<span class="gi">+        for i, unpacked in enumerate(self.read_objects()):</span>
<span class="gi">+            if self._delta_iter:</span>
<span class="gi">+                self._delta_iter.record(unpacked)</span>
<span class="gi">+            if progress is not None:</span>
<span class="gi">+                progress(</span>
<span class="gi">+                    (&quot;copying pack entries: %d/%d\r&quot; % (i, len(self))).encode(&quot;ascii&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+        if progress is not None:</span>
<span class="gi">+            progress((&quot;copied %d pack entries\n&quot; % i).encode(&quot;ascii&quot;))</span>


<span class="w"> </span>def obj_sha(type, chunks):
<span class="w"> </span>    &quot;&quot;&quot;Compute the SHA for a numeric type and object chunks.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sha = sha1()</span>
<span class="gi">+    sha.update(object_header(type, chunks_length(chunks)))</span>
<span class="gi">+    if isinstance(chunks, bytes):</span>
<span class="gi">+        sha.update(chunks)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for chunk in chunks:</span>
<span class="gi">+            sha.update(chunk)</span>
<span class="gi">+    return sha.digest()</span>


<span class="w"> </span>def compute_file_sha(f, start_ofs=0, end_ofs=0, buffer_size=1 &lt;&lt; 16):
<span class="gu">@@ -662,7 +1135,21 @@ def compute_file_sha(f, start_ofs=0, end_ofs=0, buffer_size=1 &lt;&lt; 16):</span>
<span class="w"> </span>      buffer_size: A buffer size for reading.
<span class="w"> </span>    Returns: A new SHA object updated with data read from the file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sha = sha1()</span>
<span class="gi">+    f.seek(0, SEEK_END)</span>
<span class="gi">+    length = f.tell()</span>
<span class="gi">+    if (end_ofs &lt; 0 and length + end_ofs &lt; start_ofs) or end_ofs &gt; length:</span>
<span class="gi">+        raise AssertionError(</span>
<span class="gi">+            &quot;Attempt to read beyond file length. &quot;</span>
<span class="gi">+            &quot;start_ofs: %d, end_ofs: %d, file length: %d&quot; % (start_ofs, end_ofs, length)</span>
<span class="gi">+        )</span>
<span class="gi">+    todo = length + end_ofs - start_ofs</span>
<span class="gi">+    f.seek(start_ofs)</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        data = f.read(min(todo, buffer_size))</span>
<span class="gi">+        sha.update(data)</span>
<span class="gi">+        todo -= len(data)</span>
<span class="gi">+    return sha</span>


<span class="w"> </span>class PackData:
<span class="gu">@@ -692,7 +1179,7 @@ class PackData:</span>
<span class="w"> </span>    position.  It will all just throw a zlib or KeyError.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, filename, file=None, size=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename, file=None, size=None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a PackData object representing the pack in the given filename.

<span class="w"> </span>        The file must exist and stay readable until the object is disposed of.
<span class="gu">@@ -705,12 +1192,32 @@ class PackData:</span>
<span class="w"> </span>        self._size = size
<span class="w"> </span>        self._header_size = 12
<span class="w"> </span>        if file is None:
<span class="gd">-            self._file = GitFile(self._filename, &#39;rb&#39;)</span>
<span class="gi">+            self._file = GitFile(self._filename, &quot;rb&quot;)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._file = file
<span class="gd">-        version, self._num_objects = read_pack_header(self._file.read)</span>
<span class="gi">+        (version, self._num_objects) = read_pack_header(self._file.read)</span>
<span class="w"> </span>        self._offset_cache = LRUSizeCache[int, Tuple[int, OldUnpackedObject]](
<span class="gd">-            1024 * 1024 * 20, compute_size=_compute_object_size)</span>
<span class="gi">+            1024 * 1024 * 20, compute_size=_compute_object_size</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def filename(self):</span>
<span class="gi">+        return os.path.basename(self._filename)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def path(self):</span>
<span class="gi">+        return self._filename</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_file(cls, file, size=None):</span>
<span class="gi">+        return cls(str(file), file=file, size=size)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_path(cls, path):</span>
<span class="gi">+        return cls(filename=path)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self._file.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -723,7 +1230,20 @@ class PackData:</span>
<span class="w"> </span>            return self.get_stored_checksum() == other.get_stored_checksum()
<span class="w"> </span>        return False

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def _get_size(self):</span>
<span class="gi">+        if self._size is not None:</span>
<span class="gi">+            return self._size</span>
<span class="gi">+        self._size = os.path.getsize(self._filename)</span>
<span class="gi">+        if self._size &lt; self._header_size:</span>
<span class="gi">+            errmsg = &quot;%s is too small for a packfile (%d &lt; %d)&quot; % (</span>
<span class="gi">+                self._filename,</span>
<span class="gi">+                self._size,</span>
<span class="gi">+                self._header_size,</span>
<span class="gi">+            )</span>
<span class="gi">+            raise AssertionError(errmsg)</span>
<span class="gi">+        return self._size</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of objects in this pack.&quot;&quot;&quot;
<span class="w"> </span>        return self._num_objects

<span class="gu">@@ -732,10 +1252,27 @@ class PackData:</span>

<span class="w"> </span>        Returns: 20-byte binary SHA1 digest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def iterentries(self, progress=None, resolve_ext_ref: Optional[</span>
<span class="gd">-        ResolveExtRefFn]=None):</span>
<span class="gi">+        return compute_file_sha(self._file, end_ofs=-20).digest()</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked(self, *, include_comp: bool = False):</span>
<span class="gi">+        self._file.seek(self._header_size)</span>
<span class="gi">+</span>
<span class="gi">+        if self._num_objects is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for _ in range(self._num_objects):</span>
<span class="gi">+            offset = self._file.tell()</span>
<span class="gi">+            unpacked, unused = unpack_object(</span>
<span class="gi">+                self._file.read, compute_crc32=False, include_comp=include_comp</span>
<span class="gi">+            )</span>
<span class="gi">+            unpacked.offset = offset</span>
<span class="gi">+            yield unpacked</span>
<span class="gi">+            # Back up over unused data.</span>
<span class="gi">+            self._file.seek(-len(unused), SEEK_CUR)</span>
<span class="gi">+</span>
<span class="gi">+    def iterentries(</span>
<span class="gi">+        self, progress=None, resolve_ext_ref: Optional[ResolveExtRefFn] = None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield entries summarizing the contents of this pack.

<span class="w"> </span>        Args:
<span class="gu">@@ -743,10 +1280,18 @@ class PackData:</span>
<span class="w"> </span>            object count.
<span class="w"> </span>        Returns: iterator of tuples with (sha, offset, crc32)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def sorted_entries(self, progress: Optional[ProgressFn]=None,</span>
<span class="gd">-        resolve_ext_ref: Optional[ResolveExtRefFn]=None):</span>
<span class="gi">+        num_objects = self._num_objects</span>
<span class="gi">+        indexer = PackIndexer.for_pack_data(self, resolve_ext_ref=resolve_ext_ref)</span>
<span class="gi">+        for i, result in enumerate(indexer):</span>
<span class="gi">+            if progress is not None:</span>
<span class="gi">+                progress(i, num_objects)</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+    def sorted_entries(</span>
<span class="gi">+        self,</span>
<span class="gi">+        progress: Optional[ProgressFn] = None,</span>
<span class="gi">+        resolve_ext_ref: Optional[ResolveExtRefFn] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return entries in this pack, sorted by SHA.

<span class="w"> </span>        Args:
<span class="gu">@@ -754,7 +1299,9 @@ class PackData:</span>
<span class="w"> </span>            object count
<span class="w"> </span>        Returns: Iterator of tuples with (sha, offset, crc32)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            self.iterentries(progress=progress, resolve_ext_ref=resolve_ext_ref)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def create_index_v1(self, filename, progress=None, resolve_ext_ref=None):
<span class="w"> </span>        &quot;&quot;&quot;Create a version 1 file for this data file.
<span class="gu">@@ -764,7 +1311,11 @@ class PackData:</span>
<span class="w"> </span>          progress: Progress report function
<span class="w"> </span>        Returns: Checksum of index file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entries = self.sorted_entries(</span>
<span class="gi">+            progress=progress, resolve_ext_ref=resolve_ext_ref</span>
<span class="gi">+        )</span>
<span class="gi">+        with GitFile(filename, &quot;wb&quot;) as f:</span>
<span class="gi">+            return write_pack_index_v1(f, entries, self.calculate_checksum())</span>

<span class="w"> </span>    def create_index_v2(self, filename, progress=None, resolve_ext_ref=None):
<span class="w"> </span>        &quot;&quot;&quot;Create a version 2 index file for this data file.
<span class="gu">@@ -774,10 +1325,13 @@ class PackData:</span>
<span class="w"> </span>          progress: Progress report function
<span class="w"> </span>        Returns: Checksum of index file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entries = self.sorted_entries(</span>
<span class="gi">+            progress=progress, resolve_ext_ref=resolve_ext_ref</span>
<span class="gi">+        )</span>
<span class="gi">+        with GitFile(filename, &quot;wb&quot;) as f:</span>
<span class="gi">+            return write_pack_index_v2(f, entries, self.calculate_checksum())</span>

<span class="gd">-    def create_index(self, filename, progress=None, version=2,</span>
<span class="gd">-        resolve_ext_ref=None):</span>
<span class="gi">+    def create_index(self, filename, progress=None, version=2, resolve_ext_ref=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an  index file for this data file.

<span class="w"> </span>        Args:
<span class="gu">@@ -785,32 +1339,55 @@ class PackData:</span>
<span class="w"> </span>          progress: Progress report function
<span class="w"> </span>        Returns: Checksum of index file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return self.create_index_v1(</span>
<span class="gi">+                filename, progress, resolve_ext_ref=resolve_ext_ref</span>
<span class="gi">+            )</span>
<span class="gi">+        elif version == 2:</span>
<span class="gi">+            return self.create_index_v2(</span>
<span class="gi">+                filename, progress, resolve_ext_ref=resolve_ext_ref</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;unknown index format %d&quot; % version)</span>

<span class="w"> </span>    def get_stored_checksum(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the expected checksum stored in this pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._file.seek(-20, SEEK_END)</span>
<span class="gi">+        return self._file.read(20)</span>

<span class="w"> </span>    def check(self):
<span class="w"> </span>        &quot;&quot;&quot;Check the consistency of this pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_unpacked_object_at(self, offset: int, *, include_comp: bool=False</span>
<span class="gd">-        ) -&gt;UnpackedObject:</span>
<span class="gi">+        actual = self.calculate_checksum()</span>
<span class="gi">+        stored = self.get_stored_checksum()</span>
<span class="gi">+        if actual != stored:</span>
<span class="gi">+            raise ChecksumMismatch(stored, actual)</span>
<span class="gi">+</span>
<span class="gi">+    def get_unpacked_object_at(</span>
<span class="gi">+        self, offset: int, *, include_comp: bool = False</span>
<span class="gi">+    ) -&gt; UnpackedObject:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given offset in the packfile return a UnpackedObject.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert offset &gt;= self._header_size</span>
<span class="gi">+        self._file.seek(offset)</span>
<span class="gi">+        unpacked, _ = unpack_object(self._file.read, include_comp=include_comp)</span>
<span class="gi">+        unpacked.offset = offset</span>
<span class="gi">+        return unpacked</span>

<span class="gd">-    def get_object_at(self, offset: int) -&gt;Tuple[int, OldUnpackedObject]:</span>
<span class="gi">+    def get_object_at(self, offset: int) -&gt; Tuple[int, OldUnpackedObject]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given an offset in to the packfile return the object that is there.

<span class="w"> </span>        Using the associated index the location of an object can be looked up,
<span class="w"> </span>        and then the packfile can be asked directly for that object using this
<span class="w"> </span>        function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._offset_cache[offset]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        unpacked = self.get_unpacked_object_at(offset, include_comp=False)</span>
<span class="gi">+        return (unpacked.pack_type_num, unpacked._obj())</span>


<span class="gd">-T = TypeVar(&#39;T&#39;)</span>
<span class="gi">+T = TypeVar(&quot;T&quot;)</span>


<span class="w"> </span>class DeltaChainIterator(Generic[T]):
<span class="gu">@@ -833,10 +1410,11 @@ class DeltaChainIterator(Generic[T]):</span>
<span class="w"> </span>    * decomp_len
<span class="w"> </span>    * crc32          (if _compute_crc32 is True)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _compute_crc32 = False
<span class="w"> </span>    _include_comp = False

<span class="gd">-    def __init__(self, file_obj, *, resolve_ext_ref=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, file_obj, *, resolve_ext_ref=None) -&gt; None:</span>
<span class="w"> </span>        self._file = file_obj
<span class="w"> </span>        self._resolve_ext_ref = resolve_ext_ref
<span class="w"> </span>        self._pending_ofs: Dict[int, List[int]] = defaultdict(list)
<span class="gu">@@ -844,38 +1422,222 @@ class DeltaChainIterator(Generic[T]):</span>
<span class="w"> </span>        self._full_ofs: List[Tuple[int, int]] = []
<span class="w"> </span>        self._ext_refs: List[bytes] = []

<span class="gd">-    def __iter__(self) -&gt;Iterator[T]:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def for_pack_data(cls, pack_data: PackData, resolve_ext_ref=None):</span>
<span class="gi">+        walker = cls(None, resolve_ext_ref=resolve_ext_ref)</span>
<span class="gi">+        walker.set_pack_data(pack_data)</span>
<span class="gi">+        for unpacked in pack_data.iter_unpacked(include_comp=False):</span>
<span class="gi">+            walker.record(unpacked)</span>
<span class="gi">+        return walker</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def for_pack_subset(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        pack: &quot;Pack&quot;,</span>
<span class="gi">+        shas: Iterable[bytes],</span>
<span class="gi">+        *,</span>
<span class="gi">+        allow_missing: bool = False,</span>
<span class="gi">+        resolve_ext_ref=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        walker = cls(None, resolve_ext_ref=resolve_ext_ref)</span>
<span class="gi">+        walker.set_pack_data(pack.data)</span>
<span class="gi">+        todo = set()</span>
<span class="gi">+        for sha in shas:</span>
<span class="gi">+            assert isinstance(sha, bytes)</span>
<span class="gi">+            try:</span>
<span class="gi">+                off = pack.index.object_offset(sha)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                if not allow_missing:</span>
<span class="gi">+                    raise</span>
<span class="gi">+            else:</span>
<span class="gi">+                todo.add(off)</span>
<span class="gi">+        done = set()</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            off = todo.pop()</span>
<span class="gi">+            unpacked = pack.data.get_unpacked_object_at(off)</span>
<span class="gi">+            walker.record(unpacked)</span>
<span class="gi">+            done.add(off)</span>
<span class="gi">+            base_ofs = None</span>
<span class="gi">+            if unpacked.pack_type_num == OFS_DELTA:</span>
<span class="gi">+                base_ofs = unpacked.offset - unpacked.delta_base</span>
<span class="gi">+            elif unpacked.pack_type_num == REF_DELTA:</span>
<span class="gi">+                with suppress(KeyError):</span>
<span class="gi">+                    assert isinstance(unpacked.delta_base, bytes)</span>
<span class="gi">+                    base_ofs = pack.index.object_index(unpacked.delta_base)</span>
<span class="gi">+            if base_ofs is not None and base_ofs not in done:</span>
<span class="gi">+                todo.add(base_ofs)</span>
<span class="gi">+        return walker</span>
<span class="gi">+</span>
<span class="gi">+    def record(self, unpacked: UnpackedObject) -&gt; None:</span>
<span class="gi">+        type_num = unpacked.pack_type_num</span>
<span class="gi">+        offset = unpacked.offset</span>
<span class="gi">+        if type_num == OFS_DELTA:</span>
<span class="gi">+            base_offset = offset - unpacked.delta_base</span>
<span class="gi">+            self._pending_ofs[base_offset].append(offset)</span>
<span class="gi">+        elif type_num == REF_DELTA:</span>
<span class="gi">+            assert isinstance(unpacked.delta_base, bytes)</span>
<span class="gi">+            self._pending_ref[unpacked.delta_base].append(offset)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._full_ofs.append((offset, type_num))</span>
<span class="gi">+</span>
<span class="gi">+    def set_pack_data(self, pack_data: PackData) -&gt; None:</span>
<span class="gi">+        self._file = pack_data._file</span>
<span class="gi">+</span>
<span class="gi">+    def _walk_all_chains(self):</span>
<span class="gi">+        for offset, type_num in self._full_ofs:</span>
<span class="gi">+            yield from self._follow_chain(offset, type_num, None)</span>
<span class="gi">+        yield from self._walk_ref_chains()</span>
<span class="gi">+        assert not self._pending_ofs, repr(self._pending_ofs)</span>
<span class="gi">+</span>
<span class="gi">+    def _ensure_no_pending(self) -&gt; None:</span>
<span class="gi">+        if self._pending_ref:</span>
<span class="gi">+            raise UnresolvedDeltas([sha_to_hex(s) for s in self._pending_ref])</span>
<span class="gi">+</span>
<span class="gi">+    def _walk_ref_chains(self):</span>
<span class="gi">+        if not self._resolve_ext_ref:</span>
<span class="gi">+            self._ensure_no_pending()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for base_sha, pending in sorted(self._pending_ref.items()):</span>
<span class="gi">+            if base_sha not in self._pending_ref:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                type_num, chunks = self._resolve_ext_ref(base_sha)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # Not an external ref, but may depend on one. Either it will</span>
<span class="gi">+                # get popped via a _follow_chain call, or we will raise an</span>
<span class="gi">+                # error below.</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._ext_refs.append(base_sha)</span>
<span class="gi">+            self._pending_ref.pop(base_sha)</span>
<span class="gi">+            for new_offset in pending:</span>
<span class="gi">+                yield from self._follow_chain(new_offset, type_num, chunks)</span>
<span class="gi">+</span>
<span class="gi">+        self._ensure_no_pending()</span>
<span class="gi">+</span>
<span class="gi">+    def _result(self, unpacked: UnpackedObject) -&gt; T:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_object(</span>
<span class="gi">+        self, offset: int, obj_type_num: int, base_chunks: List[bytes]</span>
<span class="gi">+    ) -&gt; UnpackedObject:</span>
<span class="gi">+        self._file.seek(offset)</span>
<span class="gi">+        unpacked, _ = unpack_object(</span>
<span class="gi">+            self._file.read,</span>
<span class="gi">+            include_comp=self._include_comp,</span>
<span class="gi">+            compute_crc32=self._compute_crc32,</span>
<span class="gi">+        )</span>
<span class="gi">+        unpacked.offset = offset</span>
<span class="gi">+        if base_chunks is None:</span>
<span class="gi">+            assert unpacked.pack_type_num == obj_type_num</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert unpacked.pack_type_num in DELTA_TYPES</span>
<span class="gi">+            unpacked.obj_type_num = obj_type_num</span>
<span class="gi">+            unpacked.obj_chunks = apply_delta(base_chunks, unpacked.decomp_chunks)</span>
<span class="gi">+        return unpacked</span>
<span class="gi">+</span>
<span class="gi">+    def _follow_chain(self, offset: int, obj_type_num: int, base_chunks: List[bytes]):</span>
<span class="gi">+        # Unlike PackData.get_object_at, there is no need to cache offsets as</span>
<span class="gi">+        # this approach by design inflates each object exactly once.</span>
<span class="gi">+        todo = [(offset, obj_type_num, base_chunks)]</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            (offset, obj_type_num, base_chunks) = todo.pop()</span>
<span class="gi">+            unpacked = self._resolve_object(offset, obj_type_num, base_chunks)</span>
<span class="gi">+            yield self._result(unpacked)</span>
<span class="gi">+</span>
<span class="gi">+            unblocked = chain(</span>
<span class="gi">+                self._pending_ofs.pop(unpacked.offset, []),</span>
<span class="gi">+                self._pending_ref.pop(unpacked.sha(), []),</span>
<span class="gi">+            )</span>
<span class="gi">+            todo.extend(</span>
<span class="gi">+                (new_offset, unpacked.obj_type_num, unpacked.obj_chunks)  # type: ignore</span>
<span class="gi">+                for new_offset in unblocked</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[T]:</span>
<span class="w"> </span>        return self._walk_all_chains()

<span class="gi">+    def ext_refs(self):</span>
<span class="gi">+        return self._ext_refs</span>
<span class="gi">+</span>

<span class="w"> </span>class UnpackedObjectIterator(DeltaChainIterator[UnpackedObject]):
<span class="w"> </span>    &quot;&quot;&quot;Delta chain iterator that yield unpacked objects.&quot;&quot;&quot;

<span class="gi">+    def _result(self, unpacked):</span>
<span class="gi">+        return unpacked</span>
<span class="gi">+</span>

<span class="w"> </span>class PackIndexer(DeltaChainIterator[PackIndexEntry]):
<span class="w"> </span>    &quot;&quot;&quot;Delta chain iterator that yields index entries.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _compute_crc32 = True

<span class="gi">+    def _result(self, unpacked):</span>
<span class="gi">+        return unpacked.sha(), unpacked.offset, unpacked.crc32</span>
<span class="gi">+</span>

<span class="w"> </span>class PackInflater(DeltaChainIterator[ShaFile]):
<span class="w"> </span>    &quot;&quot;&quot;Delta chain iterator that yields ShaFile objects.&quot;&quot;&quot;

<span class="gi">+    def _result(self, unpacked):</span>
<span class="gi">+        return unpacked.sha_file()</span>
<span class="gi">+</span>

<span class="w"> </span>class SHA1Reader:
<span class="w"> </span>    &quot;&quot;&quot;Wrapper for file-like object that remembers the SHA1 of its data.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, f) -&gt;None:</span>
<span class="gi">+    def __init__(self, f) -&gt; None:</span>
<span class="w"> </span>        self.f = f
<span class="gd">-        self.sha1 = sha1(b&#39;&#39;)</span>
<span class="gi">+        self.sha1 = sha1(b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, num=None):</span>
<span class="gi">+        data = self.f.read(num)</span>
<span class="gi">+        self.sha1.update(data)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def check_sha(self):</span>
<span class="gi">+        stored = self.f.read(20)</span>
<span class="gi">+        if stored != self.sha1.digest():</span>
<span class="gi">+            raise ChecksumMismatch(self.sha1.hexdigest(), sha_to_hex(stored))</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        return self.f.close()</span>
<span class="gi">+</span>
<span class="gi">+    def tell(self):</span>
<span class="gi">+        return self.f.tell()</span>


<span class="w"> </span>class SHA1Writer:
<span class="w"> </span>    &quot;&quot;&quot;Wrapper for file-like object that remembers the SHA1 of its data.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, f) -&gt;None:</span>
<span class="gi">+    def __init__(self, f) -&gt; None:</span>
<span class="w"> </span>        self.f = f
<span class="w"> </span>        self.length = 0
<span class="gd">-        self.sha1 = sha1(b&#39;&#39;)</span>
<span class="gi">+        self.sha1 = sha1(b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data):</span>
<span class="gi">+        self.sha1.update(data)</span>
<span class="gi">+        self.f.write(data)</span>
<span class="gi">+        self.length += len(data)</span>
<span class="gi">+</span>
<span class="gi">+    def write_sha(self):</span>
<span class="gi">+        sha = self.sha1.digest()</span>
<span class="gi">+        assert len(sha) == 20</span>
<span class="gi">+        self.f.write(sha)</span>
<span class="gi">+        self.length += len(sha)</span>
<span class="gi">+        return sha</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        sha = self.write_sha()</span>
<span class="gi">+        self.f.close()</span>
<span class="gi">+        return sha</span>
<span class="gi">+</span>
<span class="gi">+    def offset(self):</span>
<span class="gi">+        return self.length</span>
<span class="gi">+</span>
<span class="gi">+    def tell(self):</span>
<span class="gi">+        return self.f.tell()</span>


<span class="w"> </span>def pack_object_header(type_num, delta_base, size):
<span class="gu">@@ -887,7 +1649,26 @@ def pack_object_header(type_num, delta_base, size):</span>
<span class="w"> </span>      size: Uncompressed object size.
<span class="w"> </span>    Returns: A header for a packed object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    header = []</span>
<span class="gi">+    c = (type_num &lt;&lt; 4) | (size &amp; 15)</span>
<span class="gi">+    size &gt;&gt;= 4</span>
<span class="gi">+    while size:</span>
<span class="gi">+        header.append(c | 0x80)</span>
<span class="gi">+        c = size &amp; 0x7F</span>
<span class="gi">+        size &gt;&gt;= 7</span>
<span class="gi">+    header.append(c)</span>
<span class="gi">+    if type_num == OFS_DELTA:</span>
<span class="gi">+        ret = [delta_base &amp; 0x7F]</span>
<span class="gi">+        delta_base &gt;&gt;= 7</span>
<span class="gi">+        while delta_base:</span>
<span class="gi">+            delta_base -= 1</span>
<span class="gi">+            ret.insert(0, 0x80 | (delta_base &amp; 0x7F))</span>
<span class="gi">+            delta_base &gt;&gt;= 7</span>
<span class="gi">+        header.extend(ret)</span>
<span class="gi">+    elif type_num == REF_DELTA:</span>
<span class="gi">+        assert len(delta_base) == 20</span>
<span class="gi">+        header += delta_base</span>
<span class="gi">+    return bytearray(header)</span>


<span class="w"> </span>def pack_object_chunks(type, object, compression_level=-1):
<span class="gu">@@ -899,7 +1680,17 @@ def pack_object_chunks(type, object, compression_level=-1):</span>
<span class="w"> </span>      compression_level: the zlib compression level
<span class="w"> </span>    Returns: Chunks
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type in DELTA_TYPES:</span>
<span class="gi">+        delta_base, object = object</span>
<span class="gi">+    else:</span>
<span class="gi">+        delta_base = None</span>
<span class="gi">+    if isinstance(object, bytes):</span>
<span class="gi">+        object = [object]</span>
<span class="gi">+    yield bytes(pack_object_header(type, delta_base, sum(map(len, object))))</span>
<span class="gi">+    compressor = zlib.compressobj(level=compression_level)</span>
<span class="gi">+    for data in object:</span>
<span class="gi">+        yield compressor.compress(data)</span>
<span class="gi">+    yield compressor.flush()</span>


<span class="w"> </span>def write_pack_object(write, type, object, sha=None, compression_level=-1):
<span class="gu">@@ -912,12 +1703,23 @@ def write_pack_object(write, type, object, sha=None, compression_level=-1):</span>
<span class="w"> </span>      compression_level: the zlib compression level
<span class="w"> </span>    Returns: Tuple with offset at which the object was written, and crc32
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_pack(filename, objects: Union[Sequence[ShaFile], Sequence[Tuple[</span>
<span class="gd">-    ShaFile, Optional[bytes]]]], *, deltify: Optional[bool]=None,</span>
<span class="gd">-    delta_window_size: Optional[int]=None, compression_level: int=-1):</span>
<span class="gi">+    crc32 = 0</span>
<span class="gi">+    for chunk in pack_object_chunks(type, object, compression_level=compression_level):</span>
<span class="gi">+        write(chunk)</span>
<span class="gi">+        if sha is not None:</span>
<span class="gi">+            sha.update(chunk)</span>
<span class="gi">+        crc32 = binascii.crc32(chunk, crc32)</span>
<span class="gi">+    return crc32 &amp; 0xFFFFFFFF</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_pack(</span>
<span class="gi">+    filename,</span>
<span class="gi">+    objects: Union[Sequence[ShaFile], Sequence[Tuple[ShaFile, Optional[bytes]]]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    deltify: Optional[bool] = None,</span>
<span class="gi">+    delta_window_size: Optional[int] = None,</span>
<span class="gi">+    compression_level: int = -1,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a new pack data file.

<span class="w"> </span>    Args:
<span class="gu">@@ -929,22 +1731,75 @@ def write_pack(filename, objects: Union[Sequence[ShaFile], Sequence[Tuple[</span>
<span class="w"> </span>      compression_level: the zlib compression level
<span class="w"> </span>    Returns: Tuple with checksum of pack file and index file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with GitFile(filename + &quot;.pack&quot;, &quot;wb&quot;) as f:</span>
<span class="gi">+        entries, data_sum = write_pack_objects(</span>
<span class="gi">+            f.write,</span>
<span class="gi">+            objects,</span>
<span class="gi">+            delta_window_size=delta_window_size,</span>
<span class="gi">+            deltify=deltify,</span>
<span class="gi">+            compression_level=compression_level,</span>
<span class="gi">+        )</span>
<span class="gi">+    entries = sorted([(k, v[0], v[1]) for (k, v) in entries.items()])</span>
<span class="gi">+    with GitFile(filename + &quot;.idx&quot;, &quot;wb&quot;) as f:</span>
<span class="gi">+        return data_sum, write_pack_index_v2(f, entries, data_sum)</span>


<span class="w"> </span>def pack_header_chunks(num_objects):
<span class="w"> </span>    &quot;&quot;&quot;Yield chunks for a pack header.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield b&quot;PACK&quot;  # Pack header</span>
<span class="gi">+    yield struct.pack(b&quot;&gt;L&quot;, 2)  # Pack version</span>
<span class="gi">+    yield struct.pack(b&quot;&gt;L&quot;, num_objects)  # Number of objects in pack</span>


<span class="w"> </span>def write_pack_header(write, num_objects):
<span class="w"> </span>    &quot;&quot;&quot;Write a pack header for the given number of objects.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def deltify_pack_objects(objects: Union[Iterator[bytes], Iterator[Tuple[</span>
<span class="gd">-    ShaFile, Optional[bytes]]]], *, window_size: Optional[int]=None,</span>
<span class="gd">-    progress=None) -&gt;Iterator[UnpackedObject]:</span>
<span class="gi">+    if hasattr(write, &quot;write&quot;):</span>
<span class="gi">+        write = write.write</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;write_pack_header() now takes a write rather than file argument&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+    for chunk in pack_header_chunks(num_objects):</span>
<span class="gi">+        write(chunk)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_reusable_deltas(</span>
<span class="gi">+    container: PackedObjectContainer,</span>
<span class="gi">+    object_ids: Set[bytes],</span>
<span class="gi">+    *,</span>
<span class="gi">+    other_haves: Optional[Set[bytes]] = None,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+) -&gt; Iterator[UnpackedObject]:</span>
<span class="gi">+    if other_haves is None:</span>
<span class="gi">+        other_haves = set()</span>
<span class="gi">+    reused = 0</span>
<span class="gi">+    for i, unpacked in enumerate(</span>
<span class="gi">+        container.iter_unpacked_subset(</span>
<span class="gi">+            object_ids, allow_missing=True, convert_ofs_delta=True</span>
<span class="gi">+        )</span>
<span class="gi">+    ):</span>
<span class="gi">+        if progress is not None and i % 1000 == 0:</span>
<span class="gi">+            progress(</span>
<span class="gi">+                (&quot;checking for reusable deltas: %d/%d\r&quot; % (i, len(object_ids))).encode(</span>
<span class="gi">+                    &quot;utf-8&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        if unpacked.pack_type_num == REF_DELTA:</span>
<span class="gi">+            hexsha = sha_to_hex(unpacked.delta_base)</span>
<span class="gi">+            if hexsha in object_ids or hexsha in other_haves:</span>
<span class="gi">+                yield unpacked</span>
<span class="gi">+                reused += 1</span>
<span class="gi">+    if progress is not None:</span>
<span class="gi">+        progress((&quot;found %d deltas to reuse\n&quot; % (reused,)).encode(&quot;utf-8&quot;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deltify_pack_objects(</span>
<span class="gi">+    objects: Union[Iterator[bytes], Iterator[Tuple[ShaFile, Optional[bytes]]]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    window_size: Optional[int] = None,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+) -&gt; Iterator[UnpackedObject]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate deltas for pack objects.

<span class="w"> </span>    Args:
<span class="gu">@@ -953,41 +1808,185 @@ def deltify_pack_objects(objects: Union[Iterator[bytes], Iterator[Tuple[</span>
<span class="w"> </span>    Returns: Iterator over type_num, object id, delta_base, content
<span class="w"> </span>        delta_base is None for full text entries
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-def pack_objects_to_data(objects: Union[Sequence[ShaFile], Sequence[Tuple[</span>
<span class="gd">-    ShaFile, Optional[bytes]]]], *, deltify: Optional[bool]=None,</span>
<span class="gd">-    delta_window_size: Optional[int]=None, ofs_delta: bool=True, progress=None</span>
<span class="gd">-    ) -&gt;Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="gi">+    def objects_with_hints():</span>
<span class="gi">+        for e in objects:</span>
<span class="gi">+            if isinstance(e, ShaFile):</span>
<span class="gi">+                yield (e, (e.type_num, None))</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield (e[0], (e[0].type_num, e[1]))</span>
<span class="gi">+</span>
<span class="gi">+    yield from deltas_from_sorted_objects(</span>
<span class="gi">+        sort_objects_for_delta(objects_with_hints()),</span>
<span class="gi">+        window_size=window_size,</span>
<span class="gi">+        progress=progress,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sort_objects_for_delta(</span>
<span class="gi">+    objects: Union[Iterator[ShaFile], Iterator[Tuple[ShaFile, Optional[PackHint]]]],</span>
<span class="gi">+) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+    magic = []</span>
<span class="gi">+    for entry in objects:</span>
<span class="gi">+        if isinstance(entry, tuple):</span>
<span class="gi">+            obj, hint = entry</span>
<span class="gi">+            if hint is None:</span>
<span class="gi">+                type_num = None</span>
<span class="gi">+                path = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                (type_num, path) = hint</span>
<span class="gi">+        else:</span>
<span class="gi">+            obj = entry</span>
<span class="gi">+        magic.append((type_num, path, -obj.raw_length(), obj))</span>
<span class="gi">+    # Build a list of objects ordered by the magic Linus heuristic</span>
<span class="gi">+    # This helps us find good objects to diff against us</span>
<span class="gi">+    magic.sort()</span>
<span class="gi">+    return (x[3] for x in magic)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deltas_from_sorted_objects(</span>
<span class="gi">+    objects, window_size: Optional[int] = None, progress=None</span>
<span class="gi">+):</span>
<span class="gi">+    # TODO(jelmer): Use threads</span>
<span class="gi">+    if window_size is None:</span>
<span class="gi">+        window_size = DEFAULT_PACK_DELTA_WINDOW_SIZE</span>
<span class="gi">+</span>
<span class="gi">+    possible_bases: Deque[Tuple[bytes, int, List[bytes]]] = deque()</span>
<span class="gi">+    for i, o in enumerate(objects):</span>
<span class="gi">+        if progress is not None and i % 1000 == 0:</span>
<span class="gi">+            progress((&quot;generating deltas: %d\r&quot; % (i,)).encode(&quot;utf-8&quot;))</span>
<span class="gi">+        raw = o.as_raw_chunks()</span>
<span class="gi">+        winner = raw</span>
<span class="gi">+        winner_len = sum(map(len, winner))</span>
<span class="gi">+        winner_base = None</span>
<span class="gi">+        for base_id, base_type_num, base in possible_bases:</span>
<span class="gi">+            if base_type_num != o.type_num:</span>
<span class="gi">+                continue</span>
<span class="gi">+            delta_len = 0</span>
<span class="gi">+            delta = []</span>
<span class="gi">+            for chunk in create_delta(base, raw):</span>
<span class="gi">+                delta_len += len(chunk)</span>
<span class="gi">+                if delta_len &gt;= winner_len:</span>
<span class="gi">+                    break</span>
<span class="gi">+                delta.append(chunk)</span>
<span class="gi">+            else:</span>
<span class="gi">+                winner_base = base_id</span>
<span class="gi">+                winner = delta</span>
<span class="gi">+                winner_len = sum(map(len, winner))</span>
<span class="gi">+        yield UnpackedObject(</span>
<span class="gi">+            o.type_num,</span>
<span class="gi">+            sha=o.sha().digest(),</span>
<span class="gi">+            delta_base=winner_base,</span>
<span class="gi">+            decomp_len=winner_len,</span>
<span class="gi">+            decomp_chunks=winner,</span>
<span class="gi">+        )</span>
<span class="gi">+        possible_bases.appendleft((o.sha().digest(), o.type_num, raw))</span>
<span class="gi">+        while len(possible_bases) &gt; window_size:</span>
<span class="gi">+            possible_bases.pop()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pack_objects_to_data(</span>
<span class="gi">+    objects: Union[Sequence[ShaFile], Sequence[Tuple[ShaFile, Optional[bytes]]]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    deltify: Optional[bool] = None,</span>
<span class="gi">+    delta_window_size: Optional[int] = None,</span>
<span class="gi">+    ofs_delta: bool = True,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+) -&gt; Tuple[int, Iterator[UnpackedObject]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create pack data from objects.

<span class="w"> </span>    Args:
<span class="w"> </span>      objects: Pack objects
<span class="w"> </span>    Returns: Tuples with (type_num, hexdigest, delta base, object chunks)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def generate_unpacked_objects(container: PackedObjectContainer, object_ids:</span>
<span class="gd">-    Sequence[Tuple[ObjectID, Optional[PackHint]]], delta_window_size:</span>
<span class="gd">-    Optional[int]=None, deltify: Optional[bool]=None, reuse_deltas: bool=</span>
<span class="gd">-    True, ofs_delta: bool=True, other_haves: Optional[Set[bytes]]=None,</span>
<span class="gd">-    progress=None) -&gt;Iterator[UnpackedObject]:</span>
<span class="gi">+    # TODO(jelmer): support deltaifying</span>
<span class="gi">+    count = len(objects)</span>
<span class="gi">+    if deltify is None:</span>
<span class="gi">+        # PERFORMANCE/TODO(jelmer): This should be enabled but is *much* too</span>
<span class="gi">+        # slow at the moment.</span>
<span class="gi">+        deltify = False</span>
<span class="gi">+    if deltify:</span>
<span class="gi">+        return (</span>
<span class="gi">+            count,</span>
<span class="gi">+            deltify_pack_objects(</span>
<span class="gi">+                iter(objects),  # type: ignore</span>
<span class="gi">+                window_size=delta_window_size,</span>
<span class="gi">+                progress=progress,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def iter_without_path():</span>
<span class="gi">+            for o in objects:</span>
<span class="gi">+                if isinstance(o, tuple):</span>
<span class="gi">+                    yield full_unpacked_object(o[0])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield full_unpacked_object(o)</span>
<span class="gi">+</span>
<span class="gi">+        return (count, iter_without_path())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_unpacked_objects(</span>
<span class="gi">+    container: PackedObjectContainer,</span>
<span class="gi">+    object_ids: Sequence[Tuple[ObjectID, Optional[PackHint]]],</span>
<span class="gi">+    delta_window_size: Optional[int] = None,</span>
<span class="gi">+    deltify: Optional[bool] = None,</span>
<span class="gi">+    reuse_deltas: bool = True,</span>
<span class="gi">+    ofs_delta: bool = True,</span>
<span class="gi">+    other_haves: Optional[Set[bytes]] = None,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+) -&gt; Iterator[UnpackedObject]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create pack data from objects.

<span class="w"> </span>    Args:
<span class="w"> </span>      objects: Pack objects
<span class="w"> </span>    Returns: Tuples with (type_num, hexdigest, delta base, object chunks)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_pack_from_container(write, container: PackedObjectContainer,</span>
<span class="gi">+    todo = dict(object_ids)</span>
<span class="gi">+    if reuse_deltas:</span>
<span class="gi">+        for unpack in find_reusable_deltas(</span>
<span class="gi">+            container, set(todo), other_haves=other_haves, progress=progress</span>
<span class="gi">+        ):</span>
<span class="gi">+            del todo[sha_to_hex(unpack.sha())]</span>
<span class="gi">+            yield unpack</span>
<span class="gi">+    if deltify is None:</span>
<span class="gi">+        # PERFORMANCE/TODO(jelmer): This should be enabled but is *much* too</span>
<span class="gi">+        # slow at the moment.</span>
<span class="gi">+        deltify = False</span>
<span class="gi">+    if deltify:</span>
<span class="gi">+        objects_to_delta = container.iterobjects_subset(</span>
<span class="gi">+            todo.keys(), allow_missing=False</span>
<span class="gi">+        )</span>
<span class="gi">+        yield from deltas_from_sorted_objects(</span>
<span class="gi">+            sort_objects_for_delta((o, todo[o.id]) for o in objects_to_delta),</span>
<span class="gi">+            window_size=delta_window_size,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        for oid in todo:</span>
<span class="gi">+            yield full_unpacked_object(container[oid])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def full_unpacked_object(o: ShaFile) -&gt; UnpackedObject:</span>
<span class="gi">+    return UnpackedObject(</span>
<span class="gi">+        o.type_num,</span>
<span class="gi">+        delta_base=None,</span>
<span class="gi">+        crc32=None,</span>
<span class="gi">+        decomp_chunks=o.as_raw_chunks(),</span>
<span class="gi">+        sha=o.sha().digest(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_pack_from_container(</span>
<span class="gi">+    write,</span>
<span class="gi">+    container: PackedObjectContainer,</span>
<span class="w"> </span>    object_ids: Sequence[Tuple[ObjectID, Optional[PackHint]]],
<span class="gd">-    delta_window_size: Optional[int]=None, deltify: Optional[bool]=None,</span>
<span class="gd">-    reuse_deltas: bool=True, compression_level: int=-1, other_haves:</span>
<span class="gd">-    Optional[Set[bytes]]=None):</span>
<span class="gi">+    delta_window_size: Optional[int] = None,</span>
<span class="gi">+    deltify: Optional[bool] = None,</span>
<span class="gi">+    reuse_deltas: bool = True,</span>
<span class="gi">+    compression_level: int = -1,</span>
<span class="gi">+    other_haves: Optional[Set[bytes]] = None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a new pack data file.

<span class="w"> </span>    Args:
<span class="gu">@@ -1000,12 +1999,32 @@ def write_pack_from_container(write, container: PackedObjectContainer,</span>
<span class="w"> </span>      compression_level: the zlib compression level to use
<span class="w"> </span>    Returns: Dict mapping id -&gt; (offset, crc32 checksum), pack checksum
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_pack_objects(write, objects: Union[Sequence[ShaFile], Sequence[</span>
<span class="gd">-    Tuple[ShaFile, Optional[bytes]]]], *, delta_window_size: Optional[int]=</span>
<span class="gd">-    None, deltify: Optional[bool]=None, compression_level: int=-1):</span>
<span class="gi">+    pack_contents_count = len(object_ids)</span>
<span class="gi">+    pack_contents = generate_unpacked_objects(</span>
<span class="gi">+        container,</span>
<span class="gi">+        object_ids,</span>
<span class="gi">+        delta_window_size=delta_window_size,</span>
<span class="gi">+        deltify=deltify,</span>
<span class="gi">+        reuse_deltas=reuse_deltas,</span>
<span class="gi">+        other_haves=other_haves,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return write_pack_data(</span>
<span class="gi">+        write,</span>
<span class="gi">+        pack_contents,</span>
<span class="gi">+        num_records=pack_contents_count,</span>
<span class="gi">+        compression_level=compression_level,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_pack_objects(</span>
<span class="gi">+    write,</span>
<span class="gi">+    objects: Union[Sequence[ShaFile], Sequence[Tuple[ShaFile, Optional[bytes]]]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    delta_window_size: Optional[int] = None,</span>
<span class="gi">+    deltify: Optional[bool] = None,</span>
<span class="gi">+    compression_level: int = -1,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a new pack data file.

<span class="w"> </span>    Args:
<span class="gu">@@ -1017,25 +2036,50 @@ def write_pack_objects(write, objects: Union[Sequence[ShaFile], Sequence[</span>
<span class="w"> </span>      compression_level: the zlib compression level to use
<span class="w"> </span>    Returns: Dict mapping id -&gt; (offset, crc32 checksum), pack checksum
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pack_contents_count, pack_contents = pack_objects_to_data(objects, deltify=deltify)</span>

<span class="gi">+    return write_pack_data(</span>
<span class="gi">+        write,</span>
<span class="gi">+        pack_contents,</span>
<span class="gi">+        num_records=pack_contents_count,</span>
<span class="gi">+        compression_level=compression_level,</span>
<span class="gi">+    )</span>

<span class="gd">-class PackChunkGenerator:</span>

<span class="gd">-    def __init__(self, num_records=None, records=None, progress=None,</span>
<span class="gd">-        compression_level=-1, reuse_compressed=True) -&gt;None:</span>
<span class="gd">-        self.cs = sha1(b&#39;&#39;)</span>
<span class="gi">+class PackChunkGenerator:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        num_records=None,</span>
<span class="gi">+        records=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        compression_level=-1,</span>
<span class="gi">+        reuse_compressed=True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.cs = sha1(b&quot;&quot;)</span>
<span class="w"> </span>        self.entries: Dict[Union[int, bytes], Tuple[int, int]] = {}
<span class="gd">-        self._it = self._pack_data_chunks(num_records=num_records, records=</span>
<span class="gd">-            records, progress=progress, compression_level=compression_level,</span>
<span class="gd">-            reuse_compressed=reuse_compressed)</span>
<span class="gi">+        self._it = self._pack_data_chunks(</span>
<span class="gi">+            num_records=num_records,</span>
<span class="gi">+            records=records,</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            compression_level=compression_level,</span>
<span class="gi">+            reuse_compressed=reuse_compressed,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def sha1digest(self):</span>
<span class="gi">+        return self.cs.digest()</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return self._it

<span class="gd">-    def _pack_data_chunks(self, records: Iterator[UnpackedObject], *,</span>
<span class="gd">-        num_records=None, progress=None, compression_level: int=-1,</span>
<span class="gd">-        reuse_compressed: bool=True) -&gt;Iterator[bytes]:</span>
<span class="gi">+    def _pack_data_chunks(</span>
<span class="gi">+        self,</span>
<span class="gi">+        records: Iterator[UnpackedObject],</span>
<span class="gi">+        *,</span>
<span class="gi">+        num_records=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        compression_level: int = -1,</span>
<span class="gi">+        reuse_compressed: bool = True,</span>
<span class="gi">+    ) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate pack data file chunks.

<span class="w"> </span>        Args:
<span class="gu">@@ -1045,11 +2089,67 @@ class PackChunkGenerator:</span>
<span class="w"> </span>          compression_level: the zlib compression level
<span class="w"> </span>        Returns: Dict mapping id -&gt; (offset, crc32 checksum), pack checksum
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_pack_data(write, records: Iterator[UnpackedObject], *,</span>
<span class="gd">-    num_records=None, progress=None, compression_level=-1):</span>
<span class="gi">+        # Write the pack</span>
<span class="gi">+        if num_records is None:</span>
<span class="gi">+            num_records = len(records)  # type: ignore</span>
<span class="gi">+        offset = 0</span>
<span class="gi">+        for chunk in pack_header_chunks(num_records):</span>
<span class="gi">+            yield chunk</span>
<span class="gi">+            self.cs.update(chunk)</span>
<span class="gi">+            offset += len(chunk)</span>
<span class="gi">+        actual_num_records = 0</span>
<span class="gi">+        for i, unpacked in enumerate(records):</span>
<span class="gi">+            type_num = unpacked.pack_type_num</span>
<span class="gi">+            if progress is not None and i % 1000 == 0:</span>
<span class="gi">+                progress(</span>
<span class="gi">+                    (&quot;writing pack data: %d/%d\r&quot; % (i, num_records)).encode(&quot;ascii&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            raw: Union[List[bytes], Tuple[int, List[bytes]], Tuple[bytes, List[bytes]]]</span>
<span class="gi">+            if unpacked.delta_base is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    base_offset, base_crc32 = self.entries[unpacked.delta_base]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    type_num = REF_DELTA</span>
<span class="gi">+                    assert isinstance(unpacked.delta_base, bytes)</span>
<span class="gi">+                    raw = (unpacked.delta_base, unpacked.decomp_chunks)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    type_num = OFS_DELTA</span>
<span class="gi">+                    raw = (offset - base_offset, unpacked.decomp_chunks)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raw = unpacked.decomp_chunks</span>
<span class="gi">+            if unpacked.comp_chunks is not None and reuse_compressed:</span>
<span class="gi">+                chunks = unpacked.comp_chunks</span>
<span class="gi">+            else:</span>
<span class="gi">+                chunks = pack_object_chunks(</span>
<span class="gi">+                    type_num, raw, compression_level=compression_level</span>
<span class="gi">+                )</span>
<span class="gi">+            crc32 = 0</span>
<span class="gi">+            object_size = 0</span>
<span class="gi">+            for chunk in chunks:</span>
<span class="gi">+                yield chunk</span>
<span class="gi">+                crc32 = binascii.crc32(chunk, crc32)</span>
<span class="gi">+                self.cs.update(chunk)</span>
<span class="gi">+                object_size += len(chunk)</span>
<span class="gi">+            actual_num_records += 1</span>
<span class="gi">+            self.entries[unpacked.sha()] = (offset, crc32)</span>
<span class="gi">+            offset += object_size</span>
<span class="gi">+        if actual_num_records != num_records:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                &quot;actual records written differs: %d != %d&quot;</span>
<span class="gi">+                % (actual_num_records, num_records)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        yield self.cs.digest()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_pack_data(</span>
<span class="gi">+    write,</span>
<span class="gi">+    records: Iterator[UnpackedObject],</span>
<span class="gi">+    *,</span>
<span class="gi">+    num_records=None,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+    compression_level=-1,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a new pack data file.

<span class="w"> </span>    Args:
<span class="gu">@@ -1060,7 +2160,15 @@ def write_pack_data(write, records: Iterator[UnpackedObject], *,</span>
<span class="w"> </span>      compression_level: the zlib compression level
<span class="w"> </span>    Returns: Dict mapping id -&gt; (offset, crc32 checksum), pack checksum
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    chunk_generator = PackChunkGenerator(</span>
<span class="gi">+        num_records=num_records,</span>
<span class="gi">+        records=records,</span>
<span class="gi">+        progress=progress,</span>
<span class="gi">+        compression_level=compression_level,</span>
<span class="gi">+    )</span>
<span class="gi">+    for chunk in chunk_generator:</span>
<span class="gi">+        write(chunk)</span>
<span class="gi">+    return chunk_generator.entries, chunk_generator.sha1digest()</span>


<span class="w"> </span>def write_pack_index_v1(f, entries, pack_checksum):
<span class="gu">@@ -1073,10 +2181,52 @@ def write_pack_index_v1(f, entries, pack_checksum):</span>
<span class="w"> </span>      pack_checksum: Checksum of the pack file.
<span class="w"> </span>    Returns: The SHA of the written index file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_MAX_COPY_LEN = 65535</span>
<span class="gi">+    f = SHA1Writer(f)</span>
<span class="gi">+    fan_out_table = defaultdict(lambda: 0)</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        fan_out_table[ord(name[:1])] += 1</span>
<span class="gi">+    # Fan-out table</span>
<span class="gi">+    for i in range(0x100):</span>
<span class="gi">+        f.write(struct.pack(&quot;&gt;L&quot;, fan_out_table[i]))</span>
<span class="gi">+        fan_out_table[i + 1] += fan_out_table[i]</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        if not (offset &lt;= 0xFFFFFFFF):</span>
<span class="gi">+            raise TypeError(&quot;pack format 1 only supports offsets &lt; 2Gb&quot;)</span>
<span class="gi">+        f.write(struct.pack(&quot;&gt;L20s&quot;, offset, name))</span>
<span class="gi">+    assert len(pack_checksum) == 20</span>
<span class="gi">+    f.write(pack_checksum)</span>
<span class="gi">+    return f.write_sha()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _delta_encode_size(size) -&gt; bytes:</span>
<span class="gi">+    ret = bytearray()</span>
<span class="gi">+    c = size &amp; 0x7F</span>
<span class="gi">+    size &gt;&gt;= 7</span>
<span class="gi">+    while size:</span>
<span class="gi">+        ret.append(c | 0x80)</span>
<span class="gi">+        c = size &amp; 0x7F</span>
<span class="gi">+        size &gt;&gt;= 7</span>
<span class="gi">+    ret.append(c)</span>
<span class="gi">+    return bytes(ret)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The length of delta compression copy operations in version 2 packs is limited</span>
<span class="gi">+# to 64K.  To copy more, we use several copy operations.  Version 3 packs allow</span>
<span class="gi">+# 24-bit lengths in copy operations, but we always make version 2 packs.</span>
<span class="gi">+_MAX_COPY_LEN = 0xFFFF</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _encode_copy_operation(start, length):</span>
<span class="gi">+    scratch = bytearray([0x80])</span>
<span class="gi">+    for i in range(4):</span>
<span class="gi">+        if start &amp; 0xFF &lt;&lt; i * 8:</span>
<span class="gi">+            scratch.append((start &gt;&gt; i * 8) &amp; 0xFF)</span>
<span class="gi">+            scratch[0] |= 1 &lt;&lt; i</span>
<span class="gi">+    for i in range(2):</span>
<span class="gi">+        if length &amp; 0xFF &lt;&lt; i * 8:</span>
<span class="gi">+            scratch.append((length &gt;&gt; i * 8) &amp; 0xFF)</span>
<span class="gi">+            scratch[0] |= 1 &lt;&lt; (4 + i)</span>
<span class="gi">+    return bytes(scratch)</span>


<span class="w"> </span>def create_delta(base_buf, target_buf):
<span class="gu">@@ -1086,7 +2236,43 @@ def create_delta(base_buf, target_buf):</span>
<span class="w"> </span>      base_buf: Base buffer
<span class="w"> </span>      target_buf: Target buffer
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(base_buf, list):</span>
<span class="gi">+        base_buf = b&quot;&quot;.join(base_buf)</span>
<span class="gi">+    if isinstance(target_buf, list):</span>
<span class="gi">+        target_buf = b&quot;&quot;.join(target_buf)</span>
<span class="gi">+    assert isinstance(base_buf, bytes)</span>
<span class="gi">+    assert isinstance(target_buf, bytes)</span>
<span class="gi">+    # write delta header</span>
<span class="gi">+    yield _delta_encode_size(len(base_buf))</span>
<span class="gi">+    yield _delta_encode_size(len(target_buf))</span>
<span class="gi">+    # write out delta opcodes</span>
<span class="gi">+    seq = SequenceMatcher(isjunk=None, a=base_buf, b=target_buf)</span>
<span class="gi">+    for opcode, i1, i2, j1, j2 in seq.get_opcodes():</span>
<span class="gi">+        # Git patch opcodes don&#39;t care about deletes!</span>
<span class="gi">+        # if opcode == &#39;replace&#39; or opcode == &#39;delete&#39;:</span>
<span class="gi">+        #    pass</span>
<span class="gi">+        if opcode == &quot;equal&quot;:</span>
<span class="gi">+            # If they are equal, unpacker will use data from base_buf</span>
<span class="gi">+            # Write out an opcode that says what range to use</span>
<span class="gi">+            copy_start = i1</span>
<span class="gi">+            copy_len = i2 - i1</span>
<span class="gi">+            while copy_len &gt; 0:</span>
<span class="gi">+                to_copy = min(copy_len, _MAX_COPY_LEN)</span>
<span class="gi">+                yield _encode_copy_operation(copy_start, to_copy)</span>
<span class="gi">+                copy_start += to_copy</span>
<span class="gi">+                copy_len -= to_copy</span>
<span class="gi">+        if opcode == &quot;replace&quot; or opcode == &quot;insert&quot;:</span>
<span class="gi">+            # If we are replacing a range or adding one, then we just</span>
<span class="gi">+            # output it to the stream (prefixed by its size)</span>
<span class="gi">+            s = j2 - j1</span>
<span class="gi">+            o = j1</span>
<span class="gi">+            while s &gt; 127:</span>
<span class="gi">+                yield bytes([127])</span>
<span class="gi">+                yield memoryview(target_buf)[o : o + 127]</span>
<span class="gi">+                s -= 127</span>
<span class="gi">+                o += 127</span>
<span class="gi">+            yield bytes([s])</span>
<span class="gi">+            yield memoryview(target_buf)[o : o + s]</span>


<span class="w"> </span>def apply_delta(src_buf, delta):
<span class="gu">@@ -1096,11 +2282,73 @@ def apply_delta(src_buf, delta):</span>
<span class="w"> </span>      src_buf: Source buffer
<span class="w"> </span>      delta: Delta instructions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(src_buf, bytes):</span>
<span class="gi">+        src_buf = b&quot;&quot;.join(src_buf)</span>
<span class="gi">+    if not isinstance(delta, bytes):</span>
<span class="gi">+        delta = b&quot;&quot;.join(delta)</span>
<span class="gi">+    out = []</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    delta_length = len(delta)</span>
<span class="gi">+</span>
<span class="gi">+    def get_delta_header_size(delta, index):</span>
<span class="gi">+        size = 0</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while delta:</span>
<span class="gi">+            cmd = ord(delta[index : index + 1])</span>
<span class="gi">+            index += 1</span>
<span class="gi">+            size |= (cmd &amp; ~0x80) &lt;&lt; i</span>
<span class="gi">+            i += 7</span>
<span class="gi">+            if not cmd &amp; 0x80:</span>
<span class="gi">+                break</span>
<span class="gi">+        return size, index</span>
<span class="gi">+</span>
<span class="gi">+    src_size, index = get_delta_header_size(delta, index)</span>
<span class="gi">+    dest_size, index = get_delta_header_size(delta, index)</span>
<span class="gi">+    assert src_size == len(src_buf), &quot;%d vs %d&quot; % (src_size, len(src_buf))</span>
<span class="gi">+    while index &lt; delta_length:</span>
<span class="gi">+        cmd = ord(delta[index : index + 1])</span>
<span class="gi">+        index += 1</span>
<span class="gi">+        if cmd &amp; 0x80:</span>
<span class="gi">+            cp_off = 0</span>
<span class="gi">+            for i in range(4):</span>
<span class="gi">+                if cmd &amp; (1 &lt;&lt; i):</span>
<span class="gi">+                    x = ord(delta[index : index + 1])</span>
<span class="gi">+                    index += 1</span>
<span class="gi">+                    cp_off |= x &lt;&lt; (i * 8)</span>
<span class="gi">+            cp_size = 0</span>
<span class="gi">+            # Version 3 packs can contain copy sizes larger than 64K.</span>
<span class="gi">+            for i in range(3):</span>
<span class="gi">+                if cmd &amp; (1 &lt;&lt; (4 + i)):</span>
<span class="gi">+                    x = ord(delta[index : index + 1])</span>
<span class="gi">+                    index += 1</span>
<span class="gi">+                    cp_size |= x &lt;&lt; (i * 8)</span>
<span class="gi">+            if cp_size == 0:</span>
<span class="gi">+                cp_size = 0x10000</span>
<span class="gi">+            if (</span>
<span class="gi">+                cp_off + cp_size &lt; cp_size</span>
<span class="gi">+                or cp_off + cp_size &gt; src_size</span>
<span class="gi">+                or cp_size &gt; dest_size</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>
<span class="gi">+            out.append(src_buf[cp_off : cp_off + cp_size])</span>
<span class="gi">+        elif cmd != 0:</span>
<span class="gi">+            out.append(delta[index : index + cmd])</span>
<span class="gi">+            index += cmd</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ApplyDeltaError(&quot;Invalid opcode 0&quot;)</span>

<span class="gi">+    if index != delta_length:</span>
<span class="gi">+        raise ApplyDeltaError(f&quot;delta not empty: {delta[index:]!r}&quot;)</span>

<span class="gd">-def write_pack_index_v2(f, entries: Iterable[PackIndexEntry], pack_checksum:</span>
<span class="gd">-    bytes) -&gt;bytes:</span>
<span class="gi">+    if dest_size != chunks_length(out):</span>
<span class="gi">+        raise ApplyDeltaError(&quot;dest size incorrect&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_pack_index_v2(</span>
<span class="gi">+    f, entries: Iterable[PackIndexEntry], pack_checksum: bytes</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a new pack index file.

<span class="w"> </span>    Args:
<span class="gu">@@ -1110,7 +2358,32 @@ def write_pack_index_v2(f, entries: Iterable[PackIndexEntry], pack_checksum:</span>
<span class="w"> </span>      pack_checksum: Checksum of the pack file.
<span class="w"> </span>    Returns: The SHA of the index file written
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f = SHA1Writer(f)</span>
<span class="gi">+    f.write(b&quot;\377tOc&quot;)  # Magic!</span>
<span class="gi">+    f.write(struct.pack(&quot;&gt;L&quot;, 2))</span>
<span class="gi">+    fan_out_table: Dict[int, int] = defaultdict(lambda: 0)</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        fan_out_table[ord(name[:1])] += 1</span>
<span class="gi">+    # Fan-out table</span>
<span class="gi">+    largetable: List[int] = []</span>
<span class="gi">+    for i in range(0x100):</span>
<span class="gi">+        f.write(struct.pack(b&quot;&gt;L&quot;, fan_out_table[i]))</span>
<span class="gi">+        fan_out_table[i + 1] += fan_out_table[i]</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        f.write(name)</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        f.write(struct.pack(b&quot;&gt;L&quot;, entry_checksum))</span>
<span class="gi">+    for name, offset, entry_checksum in entries:</span>
<span class="gi">+        if offset &lt; 2**31:</span>
<span class="gi">+            f.write(struct.pack(b&quot;&gt;L&quot;, offset))</span>
<span class="gi">+        else:</span>
<span class="gi">+            f.write(struct.pack(b&quot;&gt;L&quot;, 2**31 + len(largetable)))</span>
<span class="gi">+            largetable.append(offset)</span>
<span class="gi">+    for offset in largetable:</span>
<span class="gi">+        f.write(struct.pack(b&quot;&gt;Q&quot;, offset))</span>
<span class="gi">+    assert len(pack_checksum) == 20</span>
<span class="gi">+    f.write(pack_checksum)</span>
<span class="gi">+    return f.write_sha()</span>


<span class="w"> </span>write_pack_index = write_pack_index_v2
<span class="gu">@@ -1118,20 +2391,23 @@ write_pack_index = write_pack_index_v2</span>

<span class="w"> </span>class Pack:
<span class="w"> </span>    &quot;&quot;&quot;A Git pack object.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _data_load: Optional[Callable[[], PackData]]
<span class="w"> </span>    _idx_load: Optional[Callable[[], PackIndex]]
<span class="gi">+</span>
<span class="w"> </span>    _data: Optional[PackData]
<span class="w"> </span>    _idx: Optional[PackIndex]

<span class="gd">-    def __init__(self, basename, resolve_ext_ref: Optional[ResolveExtRefFn]</span>
<span class="gd">-        =None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, basename, resolve_ext_ref: Optional[ResolveExtRefFn] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._basename = basename
<span class="w"> </span>        self._data = None
<span class="w"> </span>        self._idx = None
<span class="gd">-        self._idx_path = self._basename + &#39;.idx&#39;</span>
<span class="gd">-        self._data_path = self._basename + &#39;.pack&#39;</span>
<span class="gd">-        self._data_load = lambda : PackData(self._data_path)</span>
<span class="gd">-        self._idx_load = lambda : load_pack_index(self._idx_path)</span>
<span class="gi">+        self._idx_path = self._basename + &quot;.idx&quot;</span>
<span class="gi">+        self._data_path = self._basename + &quot;.pack&quot;</span>
<span class="gi">+        self._data_load = lambda: PackData(self._data_path)</span>
<span class="gi">+        self._idx_load = lambda: load_pack_index(self._idx_path)</span>
<span class="w"> </span>        self.resolve_ext_ref = resolve_ext_ref

<span class="w"> </span>    @classmethod
<span class="gu">@@ -1139,29 +2415,51 @@ class Pack:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new pack object from callables to load pack data and
<span class="w"> </span>        index objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = cls(&quot;&quot;)</span>
<span class="gi">+        ret._data_load = data_fn</span>
<span class="gi">+        ret._idx_load = idx_fn</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_objects(cls, data, idx):
<span class="w"> </span>        &quot;&quot;&quot;Create a new pack object from pack data and index objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = cls(&quot;&quot;)</span>
<span class="gi">+        ret._data = data</span>
<span class="gi">+        ret._data_load = None</span>
<span class="gi">+        ret._idx = idx</span>
<span class="gi">+        ret._idx_load = None</span>
<span class="gi">+        ret.check_length_and_checksum()</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def name(self):
<span class="w"> </span>        &quot;&quot;&quot;The SHA over the SHAs of the objects in this pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.index.objects_sha1()</span>

<span class="w"> </span>    @property
<span class="gd">-    def data(self) -&gt;PackData:</span>
<span class="gi">+    def data(self) -&gt; PackData:</span>
<span class="w"> </span>        &quot;&quot;&quot;The pack data object being used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._data is None:</span>
<span class="gi">+            assert self._data_load</span>
<span class="gi">+            self._data = self._data_load()</span>
<span class="gi">+            self.check_length_and_checksum()</span>
<span class="gi">+        return self._data</span>

<span class="w"> </span>    @property
<span class="gd">-    def index(self) -&gt;PackIndex:</span>
<span class="gi">+    def index(self) -&gt; PackIndex:</span>
<span class="w"> </span>        &quot;&quot;&quot;The index being used.

<span class="w"> </span>        Note: This may be an in-memory index
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._idx is None:</span>
<span class="gi">+            assert self._idx_load</span>
<span class="gi">+            self._idx = self._idx_load()</span>
<span class="gi">+        return self._idx</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if self._data is not None:</span>
<span class="gi">+            self._data.close()</span>
<span class="gi">+        if self._idx is not None:</span>
<span class="gi">+            self._idx.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -1172,30 +2470,49 @@ class Pack:</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        return isinstance(self, type(other)) and self.index == other.index

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of entries in this pack.&quot;&quot;&quot;
<span class="w"> </span>        return len(self.index)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._basename!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._basename!r})&quot;</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over all the sha1s of the objects in this pack.&quot;&quot;&quot;
<span class="w"> </span>        return iter(self.index)

<span class="gd">-    def check_length_and_checksum(self) -&gt;None:</span>
<span class="gi">+    def check_length_and_checksum(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sanity check the length and checksum of the pack index and data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def check(self) -&gt;None:</span>
<span class="gi">+        assert len(self.index) == len(</span>
<span class="gi">+            self.data</span>
<span class="gi">+        ), f&quot;Length mismatch: {len(self.index)} (index) != {len(self.data)} (data)&quot;</span>
<span class="gi">+        idx_stored_checksum = self.index.get_pack_checksum()</span>
<span class="gi">+        data_stored_checksum = self.data.get_stored_checksum()</span>
<span class="gi">+        if idx_stored_checksum != data_stored_checksum:</span>
<span class="gi">+            raise ChecksumMismatch(</span>
<span class="gi">+                sha_to_hex(idx_stored_checksum),</span>
<span class="gi">+                sha_to_hex(data_stored_checksum),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def check(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the integrity of this pack.

<span class="w"> </span>        Raises:
<span class="w"> </span>          ChecksumMismatch: if a checksum for the index or data is wrong
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.index.check()</span>
<span class="gi">+        self.data.check()</span>
<span class="gi">+        for obj in self.iterobjects():</span>
<span class="gi">+            obj.check()</span>
<span class="gi">+        # TODO: object connectivity checks</span>
<span class="gi">+</span>
<span class="gi">+    def get_stored_checksum(self) -&gt; bytes:</span>
<span class="gi">+        return self.data.get_stored_checksum()</span>
<span class="gi">+</span>
<span class="gi">+    def pack_tuples(self):</span>
<span class="gi">+        return [(o, None) for o in self.iterobjects()]</span>

<span class="gd">-    def __contains__(self, sha1: bytes) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, sha1: bytes) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether this pack contains a particular SHA1.&quot;&quot;&quot;
<span class="w"> </span>        try:
<span class="w"> </span>            self.index.object_offset(sha1)
<span class="gu">@@ -1203,16 +2520,84 @@ class Pack:</span>
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            return False

<span class="gd">-    def __getitem__(self, sha1: bytes) -&gt;ShaFile:</span>
<span class="gi">+    def get_raw(self, sha1: bytes) -&gt; Tuple[int, bytes]:</span>
<span class="gi">+        offset = self.index.object_offset(sha1)</span>
<span class="gi">+        obj_type, obj = self.data.get_object_at(offset)</span>
<span class="gi">+        type_num, chunks = self.resolve_object(offset, obj_type, obj)</span>
<span class="gi">+        return type_num, b&quot;&quot;.join(chunks)</span>
<span class="gi">+</span>
<span class="gi">+    def __getitem__(self, sha1: bytes) -&gt; ShaFile:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the specified SHA1.&quot;&quot;&quot;
<span class="w"> </span>        type, uncomp = self.get_raw(sha1)
<span class="w"> </span>        return ShaFile.from_raw_string(type, uncomp, sha=sha1)

<span class="gd">-    def iterobjects(self) -&gt;Iterator[ShaFile]:</span>
<span class="gi">+    def iterobjects(self) -&gt; Iterator[ShaFile]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the objects in this pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def keep(self, msg: Optional[bytes]=None) -&gt;str:</span>
<span class="gi">+        return iter(</span>
<span class="gi">+            PackInflater.for_pack_data(self.data, resolve_ext_ref=self.resolve_ext_ref)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def iterobjects_subset(</span>
<span class="gi">+        self, shas: Iterable[ObjectID], *, allow_missing: bool = False</span>
<span class="gi">+    ) -&gt; Iterator[ShaFile]:</span>
<span class="gi">+        return (</span>
<span class="gi">+            uo</span>
<span class="gi">+            for uo in PackInflater.for_pack_subset(</span>
<span class="gi">+                self,</span>
<span class="gi">+                shas,</span>
<span class="gi">+                allow_missing=allow_missing,</span>
<span class="gi">+                resolve_ext_ref=self.resolve_ext_ref,</span>
<span class="gi">+            )</span>
<span class="gi">+            if uo.id in shas</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked_subset(</span>
<span class="gi">+        self,</span>
<span class="gi">+        shas: Iterable[ObjectID],</span>
<span class="gi">+        *,</span>
<span class="gi">+        include_comp: bool = False,</span>
<span class="gi">+        allow_missing: bool = False,</span>
<span class="gi">+        convert_ofs_delta: bool = False,</span>
<span class="gi">+    ) -&gt; Iterator[UnpackedObject]:</span>
<span class="gi">+        ofs_pending: Dict[int, List[UnpackedObject]] = defaultdict(list)</span>
<span class="gi">+        ofs: Dict[bytes, int] = {}</span>
<span class="gi">+        todo = set(shas)</span>
<span class="gi">+        for unpacked in self.iter_unpacked(include_comp=include_comp):</span>
<span class="gi">+            sha = unpacked.sha()</span>
<span class="gi">+            ofs[unpacked.offset] = sha</span>
<span class="gi">+            hexsha = sha_to_hex(sha)</span>
<span class="gi">+            if hexsha in todo:</span>
<span class="gi">+                if unpacked.pack_type_num == OFS_DELTA:</span>
<span class="gi">+                    assert isinstance(unpacked.delta_base, int)</span>
<span class="gi">+                    base_offset = unpacked.offset - unpacked.delta_base</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        unpacked.delta_base = ofs[base_offset]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        ofs_pending[base_offset].append(unpacked)</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        unpacked.pack_type_num = REF_DELTA</span>
<span class="gi">+                yield unpacked</span>
<span class="gi">+                todo.remove(hexsha)</span>
<span class="gi">+            for child in ofs_pending.pop(unpacked.offset, []):</span>
<span class="gi">+                child.pack_type_num = REF_DELTA</span>
<span class="gi">+                child.delta_base = sha</span>
<span class="gi">+                yield child</span>
<span class="gi">+        assert not ofs_pending</span>
<span class="gi">+        if not allow_missing and todo:</span>
<span class="gi">+            raise UnresolvedDeltas(todo)</span>
<span class="gi">+</span>
<span class="gi">+    def iter_unpacked(self, include_comp=False):</span>
<span class="gi">+        ofs_to_entries = {</span>
<span class="gi">+            ofs: (sha, crc32) for (sha, ofs, crc32) in self.index.iterentries()</span>
<span class="gi">+        }</span>
<span class="gi">+        for unpacked in self.data.iter_unpacked(include_comp=include_comp):</span>
<span class="gi">+            (sha, crc32) = ofs_to_entries[unpacked.offset]</span>
<span class="gi">+            unpacked._sha = sha</span>
<span class="gi">+            unpacked.crc32 = crc32</span>
<span class="gi">+            yield unpacked</span>
<span class="gi">+</span>
<span class="gi">+    def keep(self, msg: Optional[bytes] = None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a .keep file for the pack, preventing git from garbage collecting it.

<span class="w"> </span>        Args:
<span class="gu">@@ -1220,23 +2605,77 @@ class Pack:</span>
<span class="w"> </span>            to determine whether or not a .keep file is obsolete.
<span class="w"> </span>        Returns: The path of the .keep file, as a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_ref(self, sha: bytes) -&gt;Tuple[Optional[int], int, OldUnpackedObject</span>
<span class="gd">-        ]:</span>
<span class="gi">+        keepfile_name = f&quot;{self._basename}.keep&quot;</span>
<span class="gi">+        with GitFile(keepfile_name, &quot;wb&quot;) as keepfile:</span>
<span class="gi">+            if msg:</span>
<span class="gi">+                keepfile.write(msg)</span>
<span class="gi">+                keepfile.write(b&quot;\n&quot;)</span>
<span class="gi">+        return keepfile_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_ref(self, sha: bytes) -&gt; Tuple[Optional[int], int, OldUnpackedObject]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the object for a ref SHA, only looking in this pack.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: cache these results</span>
<span class="gi">+        try:</span>
<span class="gi">+            offset = self.index.object_offset(sha)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            offset = None</span>
<span class="gi">+        if offset:</span>
<span class="gi">+            type, obj = self.data.get_object_at(offset)</span>
<span class="gi">+        elif self.resolve_ext_ref:</span>
<span class="gi">+            type, obj = self.resolve_ext_ref(sha)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise KeyError(sha)</span>
<span class="gi">+        return offset, type, obj</span>

<span class="gd">-    def resolve_object(self, offset: int, type: int, obj, get_ref=None</span>
<span class="gd">-        ) -&gt;Tuple[int, Iterable[bytes]]:</span>
<span class="gi">+    def resolve_object(</span>
<span class="gi">+        self, offset: int, type: int, obj, get_ref=None</span>
<span class="gi">+    ) -&gt; Tuple[int, Iterable[bytes]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolve an object, possibly resolving deltas when necessary.

<span class="w"> </span>        Returns: Tuple with object type and contents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def entries(self, progress: Optional[ProgressFn]=None) -&gt;Iterator[</span>
<span class="gd">-        PackIndexEntry]:</span>
<span class="gi">+        # Walk down the delta chain, building a stack of deltas to reach</span>
<span class="gi">+        # the requested object.</span>
<span class="gi">+        base_offset = offset</span>
<span class="gi">+        base_type = type</span>
<span class="gi">+        base_obj = obj</span>
<span class="gi">+        delta_stack = []</span>
<span class="gi">+        while base_type in DELTA_TYPES:</span>
<span class="gi">+            prev_offset = base_offset</span>
<span class="gi">+            if get_ref is None:</span>
<span class="gi">+                get_ref = self.get_ref</span>
<span class="gi">+            if base_type == OFS_DELTA:</span>
<span class="gi">+                (delta_offset, delta) = base_obj</span>
<span class="gi">+                # TODO: clean up asserts and replace with nicer error messages</span>
<span class="gi">+                base_offset = base_offset - delta_offset</span>
<span class="gi">+                base_type, base_obj = self.data.get_object_at(base_offset)</span>
<span class="gi">+                assert isinstance(base_type, int)</span>
<span class="gi">+            elif base_type == REF_DELTA:</span>
<span class="gi">+                (basename, delta) = base_obj</span>
<span class="gi">+                assert isinstance(basename, bytes) and len(basename) == 20</span>
<span class="gi">+                base_offset, base_type, base_obj = get_ref(basename)</span>
<span class="gi">+                assert isinstance(base_type, int)</span>
<span class="gi">+                if base_offset == prev_offset:  # object is based on itself</span>
<span class="gi">+                    raise UnresolvedDeltas(sha_to_hex(basename))</span>
<span class="gi">+            delta_stack.append((prev_offset, base_type, delta))</span>
<span class="gi">+</span>
<span class="gi">+        # Now grab the base object (mustn&#39;t be a delta) and apply the</span>
<span class="gi">+        # deltas all the way up the stack.</span>
<span class="gi">+        chunks = base_obj</span>
<span class="gi">+        for prev_offset, delta_type, delta in reversed(delta_stack):</span>
<span class="gi">+            chunks = apply_delta(chunks, delta)</span>
<span class="gi">+            # TODO(dborowitz): This can result in poor performance if</span>
<span class="gi">+            # large base objects are separated from deltas in the pack.</span>
<span class="gi">+            # We should reorganize so that we apply deltas to all</span>
<span class="gi">+            # objects in a chain one after the other to optimize cache</span>
<span class="gi">+            # performance.</span>
<span class="gi">+            if prev_offset is not None:</span>
<span class="gi">+                self.data._offset_cache[prev_offset] = base_type, chunks</span>
<span class="gi">+        return base_type, chunks</span>
<span class="gi">+</span>
<span class="gi">+    def entries(</span>
<span class="gi">+        self, progress: Optional[ProgressFn] = None</span>
<span class="gi">+    ) -&gt; Iterator[PackIndexEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield entries summarizing the contents of this pack.

<span class="w"> </span>        Args:
<span class="gu">@@ -1244,10 +2683,13 @@ class Pack:</span>
<span class="w"> </span>            object count.
<span class="w"> </span>        Returns: iterator of tuples with (sha, offset, crc32)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.data.iterentries(</span>
<span class="gi">+            progress=progress, resolve_ext_ref=self.resolve_ext_ref</span>
<span class="gi">+        )</span>

<span class="gd">-    def sorted_entries(self, progress: Optional[ProgressFn]=None) -&gt;Iterator[</span>
<span class="gd">-        PackIndexEntry]:</span>
<span class="gi">+    def sorted_entries(</span>
<span class="gi">+        self, progress: Optional[ProgressFn] = None</span>
<span class="gi">+    ) -&gt; Iterator[PackIndexEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return entries in this pack, sorted by SHA.

<span class="w"> </span>        Args:
<span class="gu">@@ -1255,30 +2697,88 @@ class Pack:</span>
<span class="w"> </span>            object count
<span class="w"> </span>        Returns: Iterator of tuples with (sha, offset, crc32)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.data.sorted_entries(</span>
<span class="gi">+            progress=progress, resolve_ext_ref=self.resolve_ext_ref</span>
<span class="gi">+        )</span>

<span class="gd">-    def get_unpacked_object(self, sha: bytes, *, include_comp: bool=False,</span>
<span class="gd">-        convert_ofs_delta: bool=True) -&gt;UnpackedObject:</span>
<span class="gi">+    def get_unpacked_object(</span>
<span class="gi">+        self, sha: bytes, *, include_comp: bool = False, convert_ofs_delta: bool = True</span>
<span class="gi">+    ) -&gt; UnpackedObject:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the unpacked object for a sha.

<span class="w"> </span>        Args:
<span class="w"> </span>          sha: SHA of object to fetch
<span class="w"> </span>          include_comp: Whether to include compression data in UnpackedObject
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extend_pack(f: BinaryIO, object_ids: Set[ObjectID], get_raw, *,</span>
<span class="gd">-    compression_level=-1, progress=None) -&gt;Tuple[bytes, List]:</span>
<span class="gi">+        offset = self.index.object_offset(sha)</span>
<span class="gi">+        unpacked = self.data.get_unpacked_object_at(offset, include_comp=include_comp)</span>
<span class="gi">+        if unpacked.pack_type_num == OFS_DELTA and convert_ofs_delta:</span>
<span class="gi">+            assert isinstance(unpacked.delta_base, int)</span>
<span class="gi">+            unpacked.delta_base = self.index.object_sha1(offset - unpacked.delta_base)</span>
<span class="gi">+            unpacked.pack_type_num = REF_DELTA</span>
<span class="gi">+        return unpacked</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extend_pack(</span>
<span class="gi">+    f: BinaryIO,</span>
<span class="gi">+    object_ids: Set[ObjectID],</span>
<span class="gi">+    get_raw,</span>
<span class="gi">+    *,</span>
<span class="gi">+    compression_level=-1,</span>
<span class="gi">+    progress=None,</span>
<span class="gi">+) -&gt; Tuple[bytes, List]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extend a pack file with more objects.

<span class="w"> </span>    The caller should make sure that object_ids does not contain any objects
<span class="w"> </span>    that are already in the pack
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Update the header with the new number of objects.</span>
<span class="gi">+    f.seek(0)</span>
<span class="gi">+    _version, num_objects = read_pack_header(f.read)</span>
<span class="gi">+</span>
<span class="gi">+    if object_ids:</span>
<span class="gi">+        f.seek(0)</span>
<span class="gi">+        write_pack_header(f.write, num_objects + len(object_ids))</span>
<span class="gi">+</span>
<span class="gi">+        # Must flush before reading (http://bugs.python.org/issue3207)</span>
<span class="gi">+        f.flush()</span>
<span class="gi">+</span>
<span class="gi">+    # Rescan the rest of the pack, computing the SHA with the new header.</span>
<span class="gi">+    new_sha = compute_file_sha(f, end_ofs=-20)</span>
<span class="gi">+</span>
<span class="gi">+    # Must reposition before writing (http://bugs.python.org/issue3207)</span>
<span class="gi">+    f.seek(0, os.SEEK_CUR)</span>
<span class="gi">+</span>
<span class="gi">+    extra_entries = []</span>
<span class="gi">+</span>
<span class="gi">+    # Complete the pack.</span>
<span class="gi">+    for i, object_id in enumerate(object_ids):</span>
<span class="gi">+        if progress is not None:</span>
<span class="gi">+            progress(</span>
<span class="gi">+                (&quot;writing extra base objects: %d/%d\r&quot; % (i, len(object_ids))).encode(</span>
<span class="gi">+                    &quot;ascii&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        assert len(object_id) == 20</span>
<span class="gi">+        type_num, data = get_raw(object_id)</span>
<span class="gi">+        offset = f.tell()</span>
<span class="gi">+        crc32 = write_pack_object(</span>
<span class="gi">+            f.write,</span>
<span class="gi">+            type_num,</span>
<span class="gi">+            data,</span>
<span class="gi">+            sha=new_sha,</span>
<span class="gi">+            compression_level=compression_level,</span>
<span class="gi">+        )</span>
<span class="gi">+        extra_entries.append((object_id, offset, crc32))</span>
<span class="gi">+    pack_sha = new_sha.digest()</span>
<span class="gi">+    f.write(pack_sha)</span>
<span class="gi">+    return pack_sha, extra_entries</span>


<span class="w"> </span>try:
<span class="gd">-    from dulwich._pack import apply_delta, bisect_find_sha</span>
<span class="gi">+    from dulwich._pack import (  # type: ignore</span>
<span class="gi">+        apply_delta,  # type: ignore</span>
<span class="gi">+        bisect_find_sha,  # type: ignore</span>
<span class="gi">+    )</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pass
<span class="gh">diff --git a/dulwich/patch.py b/dulwich/patch.py</span>
<span class="gh">index dbafc30d..ae74615a 100644</span>
<span class="gd">--- a/dulwich/patch.py</span>
<span class="gi">+++ b/dulwich/patch.py</span>
<span class="gu">@@ -1,19 +1,41 @@</span>
<span class="gi">+# patch.py -- For dealing with packed-style patches.</span>
<span class="gi">+# Copyright (C) 2009-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes for dealing with git am-style patches.

<span class="w"> </span>These patches are basically unified diffs with some extra metadata tacked
<span class="w"> </span>on.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import email.parser
<span class="w"> </span>import time
<span class="w"> </span>from difflib import SequenceMatcher
<span class="w"> </span>from typing import BinaryIO, Optional, TextIO, Union
<span class="gi">+</span>
<span class="w"> </span>from .objects import S_ISGITLINK, Blob, Commit
<span class="w"> </span>from .pack import ObjectContainer
<span class="gi">+</span>
<span class="w"> </span>FIRST_FEW_BYTES = 8000


<span class="gd">-def write_commit_patch(f, commit, contents, progress, version=None,</span>
<span class="gd">-    encoding=None):</span>
<span class="gi">+def write_commit_patch(f, commit, contents, progress, version=None, encoding=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a individual file patch.

<span class="w"> </span>    Args:
<span class="gu">@@ -23,7 +45,48 @@ def write_commit_patch(f, commit, contents, progress, version=None,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      tuple with filename and contents
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    encoding = encoding or getattr(f, &quot;encoding&quot;, &quot;ascii&quot;)</span>
<span class="gi">+    if isinstance(contents, str):</span>
<span class="gi">+        contents = contents.encode(encoding)</span>
<span class="gi">+    (num, total) = progress</span>
<span class="gi">+    f.write(</span>
<span class="gi">+        b&quot;From &quot;</span>
<span class="gi">+        + commit.id</span>
<span class="gi">+        + b&quot; &quot;</span>
<span class="gi">+        + time.ctime(commit.commit_time).encode(encoding)</span>
<span class="gi">+        + b&quot;\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    f.write(b&quot;From: &quot; + commit.author + b&quot;\n&quot;)</span>
<span class="gi">+    f.write(</span>
<span class="gi">+        b&quot;Date: &quot; + time.strftime(&quot;%a, %d %b %Y %H:%M:%S %Z&quot;).encode(encoding) + b&quot;\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    f.write(</span>
<span class="gi">+        (&quot;Subject: [PATCH %d/%d] &quot; % (num, total)).encode(encoding)</span>
<span class="gi">+        + commit.message</span>
<span class="gi">+        + b&quot;\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    f.write(b&quot;\n&quot;)</span>
<span class="gi">+    f.write(b&quot;---\n&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        import subprocess</span>
<span class="gi">+</span>
<span class="gi">+        p = subprocess.Popen(</span>
<span class="gi">+            [&quot;diffstat&quot;], stdout=subprocess.PIPE, stdin=subprocess.PIPE</span>
<span class="gi">+        )</span>
<span class="gi">+    except (ImportError, OSError):</span>
<span class="gi">+        pass  # diffstat not available?</span>
<span class="gi">+    else:</span>
<span class="gi">+        (diffstat, _) = p.communicate(contents)</span>
<span class="gi">+        f.write(diffstat)</span>
<span class="gi">+        f.write(b&quot;\n&quot;)</span>
<span class="gi">+    f.write(contents)</span>
<span class="gi">+    f.write(b&quot;-- \n&quot;)</span>
<span class="gi">+    if version is None:</span>
<span class="gi">+        from dulwich import __version__ as dulwich_version</span>
<span class="gi">+</span>
<span class="gi">+        f.write(b&quot;Dulwich %d.%d.%d\n&quot; % dulwich_version)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f.write(version.encode(encoding) + b&quot;\n&quot;)</span>


<span class="w"> </span>def get_summary(commit):
<span class="gu">@@ -33,22 +96,73 @@ def get_summary(commit):</span>
<span class="w"> </span>      commit: Commit
<span class="w"> </span>    Returns: Summary string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    decoded = commit.message.decode(errors=&quot;replace&quot;)</span>
<span class="gi">+    return decoded.splitlines()[0].replace(&quot; &quot;, &quot;-&quot;)</span>


<span class="gi">+#  Unified Diff</span>
<span class="w"> </span>def _format_range_unified(start, stop):
<span class="w"> </span>    &quot;&quot;&quot;Convert range to the &quot;ed&quot; format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def unified_diff(a, b, fromfile=&#39;&#39;, tofile=&#39;&#39;, fromfiledate=&#39;&#39;, tofiledate=</span>
<span class="gd">-    &#39;&#39;, n=3, lineterm=&#39;\n&#39;, tree_encoding=&#39;utf-8&#39;, output_encoding=&#39;utf-8&#39;):</span>
<span class="gi">+    # Per the diff spec at http://www.unix.org/single_unix_specification/</span>
<span class="gi">+    beginning = start + 1  # lines start numbering with one</span>
<span class="gi">+    length = stop - start</span>
<span class="gi">+    if length == 1:</span>
<span class="gi">+        return f&quot;{beginning}&quot;</span>
<span class="gi">+    if not length:</span>
<span class="gi">+        beginning -= 1  # empty ranges begin at line just before the range</span>
<span class="gi">+    return f&quot;{beginning},{length}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unified_diff(</span>
<span class="gi">+    a,</span>
<span class="gi">+    b,</span>
<span class="gi">+    fromfile=&quot;&quot;,</span>
<span class="gi">+    tofile=&quot;&quot;,</span>
<span class="gi">+    fromfiledate=&quot;&quot;,</span>
<span class="gi">+    tofiledate=&quot;&quot;,</span>
<span class="gi">+    n=3,</span>
<span class="gi">+    lineterm=&quot;\n&quot;,</span>
<span class="gi">+    tree_encoding=&quot;utf-8&quot;,</span>
<span class="gi">+    output_encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;difflib.unified_diff that can detect &quot;No newline at end of file&quot; as
<span class="w"> </span>    original &quot;git diff&quot; does.

<span class="w"> </span>    Based on the same function in Python2.7 difflib.py
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    started = False</span>
<span class="gi">+    for group in SequenceMatcher(None, a, b).get_grouped_opcodes(n):</span>
<span class="gi">+        if not started:</span>
<span class="gi">+            started = True</span>
<span class="gi">+            fromdate = f&quot;\t{fromfiledate}&quot; if fromfiledate else &quot;&quot;</span>
<span class="gi">+            todate = f&quot;\t{tofiledate}&quot; if tofiledate else &quot;&quot;</span>
<span class="gi">+            yield f&quot;--- {fromfile.decode(tree_encoding)}{fromdate}{lineterm}&quot;.encode(</span>
<span class="gi">+                output_encoding</span>
<span class="gi">+            )</span>
<span class="gi">+            yield f&quot;+++ {tofile.decode(tree_encoding)}{todate}{lineterm}&quot;.encode(</span>
<span class="gi">+                output_encoding</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        first, last = group[0], group[-1]</span>
<span class="gi">+        file1_range = _format_range_unified(first[1], last[2])</span>
<span class="gi">+        file2_range = _format_range_unified(first[3], last[4])</span>
<span class="gi">+        yield f&quot;@@ -{file1_range} +{file2_range} @@{lineterm}&quot;.encode(output_encoding)</span>
<span class="gi">+</span>
<span class="gi">+        for tag, i1, i2, j1, j2 in group:</span>
<span class="gi">+            if tag == &quot;equal&quot;:</span>
<span class="gi">+                for line in a[i1:i2]:</span>
<span class="gi">+                    yield b&quot; &quot; + line</span>
<span class="gi">+                continue</span>
<span class="gi">+            if tag in (&quot;replace&quot;, &quot;delete&quot;):</span>
<span class="gi">+                for line in a[i1:i2]:</span>
<span class="gi">+                    if not line[-1:] == b&quot;\n&quot;:</span>
<span class="gi">+                        line += b&quot;\n\\ No newline at end of file\n&quot;</span>
<span class="gi">+                    yield b&quot;-&quot; + line</span>
<span class="gi">+            if tag in (&quot;replace&quot;, &quot;insert&quot;):</span>
<span class="gi">+                for line in b[j1:j2]:</span>
<span class="gi">+                    if not line[-1:] == b&quot;\n&quot;:</span>
<span class="gi">+                        line += b&quot;\n\\ No newline at end of file\n&quot;</span>
<span class="gi">+                    yield b&quot;+&quot; + line</span>


<span class="w"> </span>def is_binary(content):
<span class="gu">@@ -57,11 +171,24 @@ def is_binary(content):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      content: Bytestring to check for binary content
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return b&quot;\0&quot; in content[:FIRST_FEW_BYTES]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def shortid(hexsha):</span>
<span class="gi">+    if hexsha is None:</span>
<span class="gi">+        return b&quot;0&quot; * 7</span>
<span class="gi">+    else:</span>
<span class="gi">+        return hexsha[:7]</span>


<span class="gd">-def write_object_diff(f, store: ObjectContainer, old_file, new_file,</span>
<span class="gd">-    diff_binary=False):</span>
<span class="gi">+def patch_filename(p, root):</span>
<span class="gi">+    if p is None:</span>
<span class="gi">+        return b&quot;/dev/null&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return root + b&quot;/&quot; + p</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_object_diff(f, store: ObjectContainer, old_file, new_file, diff_binary=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write the diff for an object.

<span class="w"> </span>    Args:
<span class="gu">@@ -74,9 +201,51 @@ def write_object_diff(f, store: ObjectContainer, old_file, new_file,</span>

<span class="w"> </span>    Note: the tuple elements should be None for nonexistent files
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    (old_path, old_mode, old_id) = old_file</span>
<span class="gi">+    (new_path, new_mode, new_id) = new_file</span>
<span class="gi">+    patched_old_path = patch_filename(old_path, b&quot;a&quot;)</span>
<span class="gi">+    patched_new_path = patch_filename(new_path, b&quot;b&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def content(mode, hexsha):</span>
<span class="gi">+        if hexsha is None:</span>
<span class="gi">+            return Blob.from_string(b&quot;&quot;)</span>
<span class="gi">+        elif S_ISGITLINK(mode):</span>
<span class="gi">+            return Blob.from_string(b&quot;Subproject commit &quot; + hexsha + b&quot;\n&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return store[hexsha]</span>
<span class="gi">+</span>
<span class="gi">+    def lines(content):</span>
<span class="gi">+        if not content:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return content.splitlines()</span>
<span class="gi">+</span>
<span class="gi">+    f.writelines(</span>
<span class="gi">+        gen_diff_header((old_path, new_path), (old_mode, new_mode), (old_id, new_id))</span>
<span class="gi">+    )</span>
<span class="gi">+    old_content = content(old_mode, old_id)</span>
<span class="gi">+    new_content = content(new_mode, new_id)</span>
<span class="gi">+    if not diff_binary and (is_binary(old_content.data) or is_binary(new_content.data)):</span>
<span class="gi">+        binary_diff = (</span>
<span class="gi">+            b&quot;Binary files &quot;</span>
<span class="gi">+            + patched_old_path</span>
<span class="gi">+            + b&quot; and &quot;</span>
<span class="gi">+            + patched_new_path</span>
<span class="gi">+            + b&quot; differ\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        f.write(binary_diff)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f.writelines(</span>
<span class="gi">+            unified_diff(</span>
<span class="gi">+                lines(old_content),</span>
<span class="gi">+                lines(new_content),</span>
<span class="gi">+                patched_old_path,</span>
<span class="gi">+                patched_new_path,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO(jelmer): Support writing unicode, rather than bytes.</span>
<span class="w"> </span>def gen_diff_header(paths, modes, shas):
<span class="w"> </span>    &quot;&quot;&quot;Write a blob diff header.

<span class="gu">@@ -85,9 +254,31 @@ def gen_diff_header(paths, modes, shas):</span>
<span class="w"> </span>      modes: Tuple with old and new modes
<span class="w"> </span>      shas: Tuple with old and new shas
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    (old_path, new_path) = paths</span>
<span class="gi">+    (old_mode, new_mode) = modes</span>
<span class="gi">+    (old_sha, new_sha) = shas</span>
<span class="gi">+    if old_path is None and new_path is not None:</span>
<span class="gi">+        old_path = new_path</span>
<span class="gi">+    if new_path is None and old_path is not None:</span>
<span class="gi">+        new_path = old_path</span>
<span class="gi">+    old_path = patch_filename(old_path, b&quot;a&quot;)</span>
<span class="gi">+    new_path = patch_filename(new_path, b&quot;b&quot;)</span>
<span class="gi">+    yield b&quot;diff --git &quot; + old_path + b&quot; &quot; + new_path + b&quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if old_mode != new_mode:</span>
<span class="gi">+        if new_mode is not None:</span>
<span class="gi">+            if old_mode is not None:</span>
<span class="gi">+                yield (f&quot;old file mode {old_mode:o}\n&quot;).encode(&quot;ascii&quot;)</span>
<span class="gi">+            yield (f&quot;new file mode {new_mode:o}\n&quot;).encode(&quot;ascii&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield (f&quot;deleted file mode {old_mode:o}\n&quot;).encode(&quot;ascii&quot;)</span>
<span class="gi">+    yield b&quot;index &quot; + shortid(old_sha) + b&quot;..&quot; + shortid(new_sha)</span>
<span class="gi">+    if new_mode is not None and old_mode is not None:</span>
<span class="gi">+        yield (f&quot; {new_mode:o}&quot;).encode(&quot;ascii&quot;)</span>
<span class="gi">+    yield b&quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO(jelmer): Support writing unicode, rather than bytes.</span>
<span class="w"> </span>def write_blob_diff(f, old_file, new_file):
<span class="w"> </span>    &quot;&quot;&quot;Write blob diff.

<span class="gu">@@ -98,7 +289,29 @@ def write_blob_diff(f, old_file, new_file):</span>

<span class="w"> </span>    Note: The use of write_object_diff is recommended over this function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (old_path, old_mode, old_blob) = old_file</span>
<span class="gi">+    (new_path, new_mode, new_blob) = new_file</span>
<span class="gi">+    patched_old_path = patch_filename(old_path, b&quot;a&quot;)</span>
<span class="gi">+    patched_new_path = patch_filename(new_path, b&quot;b&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def lines(blob):</span>
<span class="gi">+        if blob is not None:</span>
<span class="gi">+            return blob.splitlines()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    f.writelines(</span>
<span class="gi">+        gen_diff_header(</span>
<span class="gi">+            (old_path, new_path),</span>
<span class="gi">+            (old_mode, new_mode),</span>
<span class="gi">+            (getattr(old_blob, &quot;id&quot;, None), getattr(new_blob, &quot;id&quot;, None)),</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    old_contents = lines(old_blob)</span>
<span class="gi">+    new_contents = lines(new_blob)</span>
<span class="gi">+    f.writelines(</span>
<span class="gi">+        unified_diff(old_contents, new_contents, patched_old_path, patched_new_path)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def write_tree_diff(f, store, old_tree, new_tree, diff_binary=False):
<span class="gu">@@ -111,11 +324,18 @@ def write_tree_diff(f, store, old_tree, new_tree, diff_binary=False):</span>
<span class="w"> </span>      diff_binary: Whether to diff files even if they
<span class="w"> </span>        are considered binary files by is_binary().
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def git_am_patch_split(f: Union[TextIO, BinaryIO], encoding: Optional[str]=None</span>
<span class="gd">-    ):</span>
<span class="gi">+    changes = store.tree_changes(old_tree, new_tree)</span>
<span class="gi">+    for (oldpath, newpath), (oldmode, newmode), (oldsha, newsha) in changes:</span>
<span class="gi">+        write_object_diff(</span>
<span class="gi">+            f,</span>
<span class="gi">+            store,</span>
<span class="gi">+            (oldpath, oldmode, oldsha),</span>
<span class="gi">+            (newpath, newmode, newsha),</span>
<span class="gi">+            diff_binary=diff_binary,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def git_am_patch_split(f: Union[TextIO, BinaryIO], encoding: Optional[str] = None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a git-am-style patch and split it up into bits.

<span class="w"> </span>    Args:
<span class="gu">@@ -123,7 +343,16 @@ def git_am_patch_split(f: Union[TextIO, BinaryIO], encoding: Optional[str]=None</span>
<span class="w"> </span>      encoding: Encoding to use when creating Git objects
<span class="w"> </span>    Returns: Tuple with commit object, diff contents and git version
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    encoding = encoding or getattr(f, &quot;encoding&quot;, &quot;ascii&quot;)</span>
<span class="gi">+    encoding = encoding or &quot;ascii&quot;</span>
<span class="gi">+    contents = f.read()</span>
<span class="gi">+    if isinstance(contents, bytes):</span>
<span class="gi">+        bparser = email.parser.BytesParser()</span>
<span class="gi">+        msg = bparser.parsebytes(contents)</span>
<span class="gi">+    else:</span>
<span class="gi">+        uparser = email.parser.Parser()</span>
<span class="gi">+        msg = uparser.parsestr(contents)</span>
<span class="gi">+    return parse_patch_message(msg, encoding)</span>


<span class="w"> </span>def parse_patch_message(msg, encoding=None):
<span class="gu">@@ -134,4 +363,41 @@ def parse_patch_message(msg, encoding=None):</span>
<span class="w"> </span>      encoding: Encoding to use to encode Git commits
<span class="w"> </span>    Returns: Tuple with commit object, diff contents and git version
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    c = Commit()</span>
<span class="gi">+    c.author = msg[&quot;from&quot;].encode(encoding)</span>
<span class="gi">+    c.committer = msg[&quot;from&quot;].encode(encoding)</span>
<span class="gi">+    try:</span>
<span class="gi">+        patch_tag_start = msg[&quot;subject&quot;].index(&quot;[PATCH&quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        subject = msg[&quot;subject&quot;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        close = msg[&quot;subject&quot;].index(&quot;] &quot;, patch_tag_start)</span>
<span class="gi">+        subject = msg[&quot;subject&quot;][close + 2 :]</span>
<span class="gi">+    c.message = (subject.replace(&quot;\n&quot;, &quot;&quot;) + &quot;\n&quot;).encode(encoding)</span>
<span class="gi">+    first = True</span>
<span class="gi">+</span>
<span class="gi">+    body = msg.get_payload(decode=True)</span>
<span class="gi">+    lines = body.splitlines(True)</span>
<span class="gi">+    line_iter = iter(lines)</span>
<span class="gi">+</span>
<span class="gi">+    for line in line_iter:</span>
<span class="gi">+        if line == b&quot;---\n&quot;:</span>
<span class="gi">+            break</span>
<span class="gi">+        if first:</span>
<span class="gi">+            if line.startswith(b&quot;From: &quot;):</span>
<span class="gi">+                c.author = line[len(b&quot;From: &quot;) :].rstrip()</span>
<span class="gi">+            else:</span>
<span class="gi">+                c.message += b&quot;\n&quot; + line</span>
<span class="gi">+            first = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            c.message += line</span>
<span class="gi">+    diff = b&quot;&quot;</span>
<span class="gi">+    for line in line_iter:</span>
<span class="gi">+        if line == b&quot;-- \n&quot;:</span>
<span class="gi">+            break</span>
<span class="gi">+        diff += line</span>
<span class="gi">+    try:</span>
<span class="gi">+        version = next(line_iter).rstrip(b&quot;\n&quot;)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        version = None</span>
<span class="gi">+    return c, diff, version</span>
<span class="gh">diff --git a/dulwich/porcelain.py b/dulwich/porcelain.py</span>
<span class="gh">index 25aaa366..5c7ee29e 100644</span>
<span class="gd">--- a/dulwich/porcelain.py</span>
<span class="gi">+++ b/dulwich/porcelain.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="gi">+# porcelain.py -- Porcelain-like layer on top of Dulwich</span>
<span class="gi">+# Copyright (C) 2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Simple wrapper that provides porcelain-like functions on top of Dulwich.

<span class="w"> </span>Currently implemented:
<span class="gu">@@ -43,6 +63,7 @@ to the repository root.</span>

<span class="w"> </span>Functions should generally accept both unicode strings and bytestrings
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import fnmatch
<span class="w"> </span>import os
<span class="gu">@@ -55,41 +76,94 @@ from contextlib import closing, contextmanager</span>
<span class="w"> </span>from io import BytesIO, RawIOBase
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Dict, List, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>from .archive import tar_stream
<span class="w"> </span>from .client import get_transport_and_path
<span class="w"> </span>from .config import Config, ConfigFile, StackedConfig, read_submodules
<span class="gd">-from .diff_tree import CHANGE_ADD, CHANGE_COPY, CHANGE_DELETE, CHANGE_MODIFY, CHANGE_RENAME, RENAME_CHANGE_TYPES</span>
<span class="gi">+from .diff_tree import (</span>
<span class="gi">+    CHANGE_ADD,</span>
<span class="gi">+    CHANGE_COPY,</span>
<span class="gi">+    CHANGE_DELETE,</span>
<span class="gi">+    CHANGE_MODIFY,</span>
<span class="gi">+    CHANGE_RENAME,</span>
<span class="gi">+    RENAME_CHANGE_TYPES,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .errors import SendPackError
<span class="w"> </span>from .file import ensure_dir_exists
<span class="w"> </span>from .graph import can_fast_forward
<span class="w"> </span>from .ignore import IgnoreFilterManager
<span class="gd">-from .index import _fs_to_tree_path, blob_from_path_and_stat, build_file_from_blob, get_unstaged_changes, index_entry_from_stat</span>
<span class="gi">+from .index import (</span>
<span class="gi">+    _fs_to_tree_path,</span>
<span class="gi">+    blob_from_path_and_stat,</span>
<span class="gi">+    build_file_from_blob,</span>
<span class="gi">+    get_unstaged_changes,</span>
<span class="gi">+    index_entry_from_stat,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .object_store import iter_tree_contents, tree_lookup_path
<span class="gd">-from .objects import Commit, Tag, format_timezone, parse_timezone, pretty_format_tree_entry</span>
<span class="gd">-from .objectspec import parse_commit, parse_object, parse_ref, parse_reftuples, parse_tree, to_bytes</span>
<span class="gi">+from .objects import (</span>
<span class="gi">+    Commit,</span>
<span class="gi">+    Tag,</span>
<span class="gi">+    format_timezone,</span>
<span class="gi">+    parse_timezone,</span>
<span class="gi">+    pretty_format_tree_entry,</span>
<span class="gi">+)</span>
<span class="gi">+from .objectspec import (</span>
<span class="gi">+    parse_commit,</span>
<span class="gi">+    parse_object,</span>
<span class="gi">+    parse_ref,</span>
<span class="gi">+    parse_reftuples,</span>
<span class="gi">+    parse_tree,</span>
<span class="gi">+    to_bytes,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .pack import write_pack_from_container, write_pack_index
<span class="w"> </span>from .patch import write_tree_diff
<span class="w"> </span>from .protocol import ZERO_SHA, Protocol
<span class="gd">-from .refs import LOCAL_BRANCH_PREFIX, LOCAL_REMOTE_PREFIX, LOCAL_TAG_PREFIX, _import_remote_refs</span>
<span class="gi">+from .refs import (</span>
<span class="gi">+    LOCAL_BRANCH_PREFIX,</span>
<span class="gi">+    LOCAL_REMOTE_PREFIX,</span>
<span class="gi">+    LOCAL_TAG_PREFIX,</span>
<span class="gi">+    _import_remote_refs,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .repo import BaseRepo, Repo, get_user_identity
<span class="gd">-from .server import FileSystemBackend, ReceivePackHandler, TCPGitServer, UploadPackHandler</span>
<span class="gi">+from .server import (</span>
<span class="gi">+    FileSystemBackend,</span>
<span class="gi">+    ReceivePackHandler,</span>
<span class="gi">+    TCPGitServer,</span>
<span class="gi">+    UploadPackHandler,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .server import update_server_info as server_update_server_info
<span class="gd">-GitStatus = namedtuple(&#39;GitStatus&#39;, &#39;staged unstaged untracked&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# Module level tuple definition for status output</span>
<span class="gi">+GitStatus = namedtuple(&quot;GitStatus&quot;, &quot;staged unstaged untracked&quot;)</span>


<span class="w"> </span>class NoneStream(RawIOBase):
<span class="w"> </span>    &quot;&quot;&quot;Fallback if stdout or stderr are unavailable, does nothing.&quot;&quot;&quot;

<span class="gi">+    def read(self, size=-1):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def readall(self):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def readinto(self, b):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, b):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="gd">-default_bytes_out_stream = getattr(sys.stdout, &#39;buffer&#39;, None) or NoneStream()</span>
<span class="gd">-default_bytes_err_stream = getattr(sys.stderr, &#39;buffer&#39;, None) or NoneStream()</span>
<span class="gd">-DEFAULT_ENCODING = &#39;utf-8&#39;</span>
<span class="gi">+default_bytes_out_stream = getattr(sys.stdout, &quot;buffer&quot;, None) or NoneStream()</span>
<span class="gi">+default_bytes_err_stream = getattr(sys.stderr, &quot;buffer&quot;, None) or NoneStream()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_ENCODING = &quot;utf-8&quot;</span>


<span class="w"> </span>class Error(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Porcelain-based error.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, msg) -&gt;None:</span>
<span class="gi">+    def __init__(self, msg) -&gt; None:</span>
<span class="w"> </span>        super().__init__(msg)


<span class="gu">@@ -120,7 +194,44 @@ def parse_timezone_format(tz_str):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      TimezoneFormatError: if timezone information cannot be extracted
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import re</span>
<span class="gi">+</span>
<span class="gi">+    # Git internal format</span>
<span class="gi">+    internal_format_pattern = re.compile(&quot;^[0-9]+ [+-][0-9]{,4}$&quot;)</span>
<span class="gi">+    if re.match(internal_format_pattern, tz_str):</span>
<span class="gi">+        try:</span>
<span class="gi">+            tz_internal = parse_timezone(tz_str.split(&quot; &quot;)[1].encode(DEFAULT_ENCODING))</span>
<span class="gi">+            return tz_internal[0]</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 2822</span>
<span class="gi">+    import email.utils</span>
<span class="gi">+</span>
<span class="gi">+    rfc_2822 = email.utils.parsedate_tz(tz_str)</span>
<span class="gi">+    if rfc_2822:</span>
<span class="gi">+        return rfc_2822[9]</span>
<span class="gi">+</span>
<span class="gi">+    # ISO 8601</span>
<span class="gi">+</span>
<span class="gi">+    # Supported offsets:</span>
<span class="gi">+    # sHHMM, sHH:MM, sHH</span>
<span class="gi">+    iso_8601_pattern = re.compile(</span>
<span class="gi">+        &quot;[0-9] ?([+-])([0-9]{2})(?::(?=[0-9]{2}))?([0-9]{2})?$&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    match = re.search(iso_8601_pattern, tz_str)</span>
<span class="gi">+    total_secs = 0</span>
<span class="gi">+    if match:</span>
<span class="gi">+        sign, hours, minutes = match.groups()</span>
<span class="gi">+        total_secs += int(hours) * 3600</span>
<span class="gi">+        if minutes:</span>
<span class="gi">+            total_secs += int(minutes) * 60</span>
<span class="gi">+        total_secs = -total_secs if sign == &quot;-&quot; else total_secs</span>
<span class="gi">+        return total_secs</span>
<span class="gi">+</span>
<span class="gi">+    # YYYY.MM.DD, MM/DD/YYYY, DD.MM.YYYY contain no timezone information</span>
<span class="gi">+</span>
<span class="gi">+    raise TimezoneFormatError(tz_str)</span>


<span class="w"> </span>def get_user_timezones():
<span class="gu">@@ -128,18 +239,31 @@ def get_user_timezones():</span>
<span class="w"> </span>    https://raw.githubusercontent.com/git/git/v2.3.0/Documentation/date-formats.txt
<span class="w"> </span>    Returns: A tuple containing author timezone, committer timezone.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    local_timezone = time.localtime().tm_gmtoff</span>
<span class="gi">+</span>
<span class="gi">+    if os.environ.get(&quot;GIT_AUTHOR_DATE&quot;):</span>
<span class="gi">+        author_timezone = parse_timezone_format(os.environ[&quot;GIT_AUTHOR_DATE&quot;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        author_timezone = local_timezone</span>
<span class="gi">+    if os.environ.get(&quot;GIT_COMMITTER_DATE&quot;):</span>
<span class="gi">+        commit_timezone = parse_timezone_format(os.environ[&quot;GIT_COMMITTER_DATE&quot;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        commit_timezone = local_timezone</span>
<span class="gi">+</span>
<span class="gi">+    return author_timezone, commit_timezone</span>


<span class="w"> </span>def open_repo(path_or_repo):
<span class="w"> </span>    &quot;&quot;&quot;Open an argument that can be a repository or a path for a repository.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(path_or_repo, BaseRepo):</span>
<span class="gi">+        return path_or_repo</span>
<span class="gi">+    return Repo(path_or_repo)</span>


<span class="w"> </span>@contextmanager
<span class="w"> </span>def _noop_context_manager(obj):
<span class="w"> </span>    &quot;&quot;&quot;Context manager that has the same api as closing but does nothing.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield obj</span>


<span class="w"> </span>def open_repo_closing(path_or_repo):
<span class="gu">@@ -147,7 +271,9 @@ def open_repo_closing(path_or_repo):</span>
<span class="w"> </span>    returns a context manager that will close the repo on exit if the argument
<span class="w"> </span>    is a path, else does nothing if the argument is a repo.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(path_or_repo, BaseRepo):</span>
<span class="gi">+        return _noop_context_manager(path_or_repo)</span>
<span class="gi">+    return closing(Repo(path_or_repo))</span>


<span class="w"> </span>def path_to_tree_path(repopath, path, tree_encoding=DEFAULT_ENCODING):
<span class="gu">@@ -159,13 +285,42 @@ def path_to_tree_path(repopath, path, tree_encoding=DEFAULT_ENCODING):</span>
<span class="w"> </span>      path: A path, absolute or relative to the cwd
<span class="w"> </span>    Returns: A path formatted for use in e.g. an index
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Resolve might returns a relative path on Windows</span>
<span class="gi">+    # https://bugs.python.org/issue38671</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        path = os.path.abspath(path)</span>
<span class="gi">+</span>
<span class="gi">+    path = Path(path)</span>
<span class="gi">+    resolved_path = path.resolve()</span>
<span class="gi">+</span>
<span class="gi">+    # Resolve and abspath seems to behave differently regarding symlinks,</span>
<span class="gi">+    # as we are doing abspath on the file path, we need to do the same on</span>
<span class="gi">+    # the repo path or they might not match</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        repopath = os.path.abspath(repopath)</span>
<span class="gi">+</span>
<span class="gi">+    repopath = Path(repopath).resolve()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        relpath = resolved_path.relative_to(repopath)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # If path is a symlink that points to a file outside the repo, we</span>
<span class="gi">+        # want the relpath for the link itself, not the resolved target</span>
<span class="gi">+        if path.is_symlink():</span>
<span class="gi">+            parent = path.parent.resolve()</span>
<span class="gi">+            relpath = (parent / path.name).relative_to(repopath)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        return str(relpath).replace(os.path.sep, &quot;/&quot;).encode(tree_encoding)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return bytes(relpath)</span>


<span class="w"> </span>class DivergedBranches(Error):
<span class="w"> </span>    &quot;&quot;&quot;Branches have diverged and fast-forward is not possible.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, current_sha, new_sha) -&gt;None:</span>
<span class="gi">+    def __init__(self, current_sha, new_sha) -&gt; None:</span>
<span class="w"> </span>        self.current_sha = current_sha
<span class="w"> </span>        self.new_sha = new_sha

<span class="gu">@@ -178,11 +333,20 @@ def check_diverged(repo, current_sha, new_sha):</span>
<span class="w"> </span>      current_sha: Current head sha
<span class="w"> </span>      new_sha: New head sha
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        can = can_fast_forward(repo, current_sha, new_sha)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        can = False</span>
<span class="gi">+    if not can:</span>
<span class="gi">+        raise DivergedBranches(current_sha, new_sha)</span>


<span class="gd">-def archive(repo, committish=None, outstream=default_bytes_out_stream,</span>
<span class="gd">-    errstream=default_bytes_err_stream):</span>
<span class="gi">+def archive(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    committish=None,</span>
<span class="gi">+    outstream=default_bytes_out_stream,</span>
<span class="gi">+    errstream=default_bytes_err_stream,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an archive.

<span class="w"> </span>    Args:
<span class="gu">@@ -191,16 +355,24 @@ def archive(repo, committish=None, outstream=default_bytes_out_stream,</span>
<span class="w"> </span>      outstream: Output stream (defaults to stdout)
<span class="w"> </span>      errstream: Error stream (defaults to stderr)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if committish is None:</span>
<span class="gi">+        committish = &quot;HEAD&quot;</span>
<span class="gi">+    with open_repo_closing(repo) as repo_obj:</span>
<span class="gi">+        c = parse_commit(repo_obj, committish)</span>
<span class="gi">+        for chunk in tar_stream(</span>
<span class="gi">+            repo_obj.object_store, repo_obj.object_store[c.tree], c.commit_time</span>
<span class="gi">+        ):</span>
<span class="gi">+            outstream.write(chunk)</span>


<span class="gd">-def update_server_info(repo=&#39;.&#39;):</span>
<span class="gi">+def update_server_info(repo=&quot;.&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Update server info files for a repository.

<span class="w"> </span>    Args:
<span class="w"> </span>      repo: path to the repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        server_update_server_info(r)</span>


<span class="w"> </span>def symbolic_ref(repo, ref_name, force=False):
<span class="gu">@@ -211,12 +383,36 @@ def symbolic_ref(repo, ref_name, force=False):</span>
<span class="w"> </span>      ref_name: short name of the new ref
<span class="w"> </span>      force: force settings without checking if it exists in refs/heads
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def commit(repo=&#39;.&#39;, message=None, author=None, author_timezone=None,</span>
<span class="gd">-    committer=None, commit_timezone=None, encoding=None, no_verify=False,</span>
<span class="gd">-    signoff=False):</span>
<span class="gi">+    with open_repo_closing(repo) as repo_obj:</span>
<span class="gi">+        ref_path = _make_branch_ref(ref_name)</span>
<span class="gi">+        if not force and ref_path not in repo_obj.refs.keys():</span>
<span class="gi">+            raise Error(f&quot;fatal: ref `{ref_name}` is not a ref&quot;)</span>
<span class="gi">+        repo_obj.refs.set_symbolic_ref(b&quot;HEAD&quot;, ref_path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pack_refs(repo, all=False):</span>
<span class="gi">+    with open_repo_closing(repo) as repo_obj:</span>
<span class="gi">+        refs = repo_obj.refs</span>
<span class="gi">+        packed_refs = {</span>
<span class="gi">+            ref: refs[ref]</span>
<span class="gi">+            for ref in refs</span>
<span class="gi">+            if (all or ref.startswith(LOCAL_TAG_PREFIX)) and ref != b&quot;HEAD&quot;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        refs.add_packed_refs(packed_refs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def commit(</span>
<span class="gi">+    repo=&quot;.&quot;,</span>
<span class="gi">+    message=None,</span>
<span class="gi">+    author=None,</span>
<span class="gi">+    author_timezone=None,</span>
<span class="gi">+    committer=None,</span>
<span class="gi">+    commit_timezone=None,</span>
<span class="gi">+    encoding=None,</span>
<span class="gi">+    no_verify=False,</span>
<span class="gi">+    signoff=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a new commit.

<span class="w"> </span>    Args:
<span class="gu">@@ -232,7 +428,29 @@ def commit(repo=&#39;.&#39;, message=None, author=None, author_timezone=None,</span>
<span class="w"> </span>        pass a str containing Key ID to use a specific GPG key)
<span class="w"> </span>    Returns: SHA1 of the new commit
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # FIXME: Support --all argument</span>
<span class="gi">+    if getattr(message, &quot;encode&quot;, None):</span>
<span class="gi">+        message = message.encode(encoding or DEFAULT_ENCODING)</span>
<span class="gi">+    if getattr(author, &quot;encode&quot;, None):</span>
<span class="gi">+        author = author.encode(encoding or DEFAULT_ENCODING)</span>
<span class="gi">+    if getattr(committer, &quot;encode&quot;, None):</span>
<span class="gi">+        committer = committer.encode(encoding or DEFAULT_ENCODING)</span>
<span class="gi">+    local_timezone = get_user_timezones()</span>
<span class="gi">+    if author_timezone is None:</span>
<span class="gi">+        author_timezone = local_timezone[0]</span>
<span class="gi">+    if commit_timezone is None:</span>
<span class="gi">+        commit_timezone = local_timezone[1]</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        return r.do_commit(</span>
<span class="gi">+            message=message,</span>
<span class="gi">+            author=author,</span>
<span class="gi">+            author_timezone=author_timezone,</span>
<span class="gi">+            committer=committer,</span>
<span class="gi">+            commit_timezone=commit_timezone,</span>
<span class="gi">+            encoding=encoding,</span>
<span class="gi">+            no_verify=no_verify,</span>
<span class="gi">+            sign=signoff if isinstance(signoff, (str, bool)) else None,</span>
<span class="gi">+        )</span>


<span class="w"> </span>def commit_tree(repo, tree, message=None, author=None, committer=None):
<span class="gu">@@ -244,10 +462,13 @@ def commit_tree(repo, tree, message=None, author=None, committer=None):</span>
<span class="w"> </span>      author: Optional author name and email
<span class="w"> </span>      committer: Optional committer name and email
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        return r.do_commit(</span>
<span class="gi">+            message=message, tree=tree, committer=committer, author=author</span>
<span class="gi">+        )</span>


<span class="gd">-def init(path=&#39;.&#39;, *, bare=False, symlinks: Optional[bool]=None):</span>
<span class="gi">+def init(path=&quot;.&quot;, *, bare=False, symlinks: Optional[bool] = None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a new git repository.

<span class="w"> </span>    Args:
<span class="gu">@@ -256,15 +477,52 @@ def init(path=&#39;.&#39;, *, bare=False, symlinks: Optional[bool]=None):</span>
<span class="w"> </span>      symlinks: Whether to create actual symlinks (defaults to autodetect)
<span class="w"> </span>    Returns: A Repo instance
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def clone(source, target=None, bare=False, checkout=None, errstream=</span>
<span class="gd">-    default_bytes_err_stream, outstream=None, origin: Optional[str]=</span>
<span class="gd">-    &#39;origin&#39;, depth: Optional[int]=None, branch: Optional[Union[str, bytes]</span>
<span class="gd">-    ]=None, config: Optional[Config]=None, refspecs=None, refspec_encoding=</span>
<span class="gd">-    DEFAULT_ENCODING, filter_spec=None, protocol_version: Optional[int]=</span>
<span class="gd">-    None, **kwargs):</span>
<span class="gi">+    if not os.path.exists(path):</span>
<span class="gi">+        os.mkdir(path)</span>
<span class="gi">+</span>
<span class="gi">+    if bare:</span>
<span class="gi">+        return Repo.init_bare(path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return Repo.init(path, symlinks=symlinks)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def encode_refspecs(refspecs, refspec_encoding):</span>
<span class="gi">+    if refspecs is None:</span>
<span class="gi">+        return [b&quot;HEAD&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def encode_refspec(ref):</span>
<span class="gi">+        if isinstance(ref, bytes):</span>
<span class="gi">+            return ref</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ref.encode(refspec_encoding)</span>
<span class="gi">+</span>
<span class="gi">+    encoded_refs = []</span>
<span class="gi">+    if isinstance(refspecs, bytes) or isinstance(refspecs, str):</span>
<span class="gi">+        encoded_refs.append(encode_refspec(refspecs))</span>
<span class="gi">+    else:</span>
<span class="gi">+        for ref in refspecs:</span>
<span class="gi">+            encoded_refs.append(encode_refspec(ref))</span>
<span class="gi">+</span>
<span class="gi">+    return encoded_refs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clone(</span>
<span class="gi">+    source,</span>
<span class="gi">+    target=None,</span>
<span class="gi">+    bare=False,</span>
<span class="gi">+    checkout=None,</span>
<span class="gi">+    errstream=default_bytes_err_stream,</span>
<span class="gi">+    outstream=None,</span>
<span class="gi">+    origin: Optional[str] = &quot;origin&quot;,</span>
<span class="gi">+    depth: Optional[int] = None,</span>
<span class="gi">+    branch: Optional[Union[str, bytes]] = None,</span>
<span class="gi">+    config: Optional[Config] = None,</span>
<span class="gi">+    refspecs=None,</span>
<span class="gi">+    refspec_encoding=DEFAULT_ENCODING,</span>
<span class="gi">+    filter_spec=None,</span>
<span class="gi">+    protocol_version: Optional[int] = None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Clone a local or remote git repository.

<span class="w"> </span>    Args:
<span class="gu">@@ -290,10 +548,56 @@ def clone(source, target=None, bare=False, checkout=None, errstream=</span>
<span class="w"> </span>        mutually supported protocol version will be used.
<span class="w"> </span>    Returns: The new repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if outstream is not None:</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;outstream= has been deprecated in favour of errstream=.&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+        # TODO(jelmer): Capture logging output and stream to errstream</span>
<span class="gi">+</span>
<span class="gi">+    if config is None:</span>
<span class="gi">+        config = StackedConfig.default()</span>
<span class="gi">+</span>
<span class="gi">+    if checkout is None:</span>
<span class="gi">+        checkout = not bare</span>
<span class="gi">+    if checkout and bare:</span>
<span class="gi">+        raise Error(&quot;checkout and bare are incompatible&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    encoded_refs = encode_refspecs(refspecs, refspec_encoding)</span>
<span class="gi">+</span>
<span class="gi">+    if target is None:</span>
<span class="gi">+        target = source.split(&quot;/&quot;)[-1]</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(branch, str):</span>
<span class="gi">+        branch = branch.encode(DEFAULT_ENCODING)</span>
<span class="gi">+</span>
<span class="gi">+    mkdir = not os.path.exists(target)</span>

<span class="gi">+    (client, path) = get_transport_and_path(source, config=config, **kwargs)</span>

<span class="gd">-def add(repo=&#39;.&#39;, paths=None):</span>
<span class="gi">+    if filter_spec:</span>
<span class="gi">+        filter_spec = filter_spec.encode(&quot;ascii&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return client.clone(</span>
<span class="gi">+        path,</span>
<span class="gi">+        target,</span>
<span class="gi">+        mkdir=mkdir,</span>
<span class="gi">+        bare=bare,</span>
<span class="gi">+        origin=origin,</span>
<span class="gi">+        checkout=checkout,</span>
<span class="gi">+        branch=branch,</span>
<span class="gi">+        progress=errstream.write,</span>
<span class="gi">+        depth=depth,</span>
<span class="gi">+        ref_prefix=encoded_refs,</span>
<span class="gi">+        filter_spec=filter_spec,</span>
<span class="gi">+        protocol_version=protocol_version,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def add(repo=&quot;.&quot;, paths=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Add files to the staging area.

<span class="w"> </span>    Args:
<span class="gu">@@ -305,7 +609,33 @@ def add(repo=&#39;.&#39;, paths=None):</span>
<span class="w"> </span>    contain the path to an ignored directory (with trailing slash). Individual
<span class="w"> </span>    files within ignored directories will not be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ignored = set()</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        repo_path = Path(r.path).resolve()</span>
<span class="gi">+        ignore_manager = IgnoreFilterManager.from_repo(r)</span>
<span class="gi">+        if not paths:</span>
<span class="gi">+            paths = list(</span>
<span class="gi">+                get_untracked_paths(</span>
<span class="gi">+                    str(Path(os.getcwd()).resolve()),</span>
<span class="gi">+                    str(repo_path),</span>
<span class="gi">+                    r.open_index(),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        relpaths = []</span>
<span class="gi">+        if not isinstance(paths, list):</span>
<span class="gi">+            paths = [paths]</span>
<span class="gi">+        for p in paths:</span>
<span class="gi">+            path = Path(p)</span>
<span class="gi">+            relpath = str(path.resolve().relative_to(repo_path))</span>
<span class="gi">+            # FIXME: Support patterns</span>
<span class="gi">+            if path.is_dir():</span>
<span class="gi">+                relpath = os.path.join(relpath, &quot;&quot;)</span>
<span class="gi">+            if ignore_manager.is_ignored(relpath):</span>
<span class="gi">+                ignored.add(relpath)</span>
<span class="gi">+                continue</span>
<span class="gi">+            relpaths.append(relpath)</span>
<span class="gi">+        r.stage(relpaths)</span>
<span class="gi">+    return (relpaths, ignored)</span>


<span class="w"> </span>def _is_subdir(subdir, parentdir):
<span class="gu">@@ -314,10 +644,13 @@ def _is_subdir(subdir, parentdir):</span>
<span class="w"> </span>    If parentdir or subdir is a relative path, it will be disamgibuated
<span class="w"> </span>    relative to the pwd.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parentdir_abs = os.path.realpath(parentdir) + os.path.sep</span>
<span class="gi">+    subdir_abs = os.path.realpath(subdir) + os.path.sep</span>
<span class="gi">+    return subdir_abs.startswith(parentdir_abs)</span>


<span class="gd">-def clean(repo=&#39;.&#39;, target_dir=None):</span>
<span class="gi">+# TODO: option to remove ignored files also, in line with `git clean -fdx`</span>
<span class="gi">+def clean(repo=&quot;.&quot;, target_dir=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove any untracked files from the target directory recursively.

<span class="w"> </span>    Equivalent to running ``git clean -fd`` in target_dir.
<span class="gu">@@ -326,22 +659,110 @@ def clean(repo=&#39;.&#39;, target_dir=None):</span>
<span class="w"> </span>      repo: Repository where the files may be tracked
<span class="w"> </span>      target_dir: Directory to clean - current directory if None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if target_dir is None:</span>
<span class="gi">+        target_dir = os.getcwd()</span>
<span class="gi">+</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if not _is_subdir(target_dir, r.path):</span>
<span class="gi">+            raise Error(&quot;target_dir must be in the repo&#39;s working dir&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        config = r.get_config_stack()</span>
<span class="gi">+        config.get_boolean((b&quot;clean&quot;,), b&quot;requireForce&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO(jelmer): if require_force is set, then make sure that -f, -i or</span>
<span class="gi">+        # -n is specified.</span>
<span class="gi">+</span>
<span class="gi">+        index = r.open_index()</span>
<span class="gi">+        ignore_manager = IgnoreFilterManager.from_repo(r)</span>
<span class="gi">+</span>
<span class="gi">+        paths_in_wd = _walk_working_dir_paths(target_dir, r.path)</span>
<span class="gi">+        # Reverse file visit order, so that files and subdirectories are</span>
<span class="gi">+        # removed before containing directory</span>
<span class="gi">+        for ap, is_dir in reversed(list(paths_in_wd)):</span>
<span class="gi">+            if is_dir:</span>
<span class="gi">+                # All subdirectories and files have been removed if untracked,</span>
<span class="gi">+                # so dir contains no tracked files iff it is empty.</span>
<span class="gi">+                is_empty = len(os.listdir(ap)) == 0</span>
<span class="gi">+                if is_empty:</span>
<span class="gi">+                    os.rmdir(ap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ip = path_to_tree_path(r.path, ap)</span>
<span class="gi">+                is_tracked = ip in index</span>

<span class="gi">+                rp = os.path.relpath(ap, r.path)</span>
<span class="gi">+                is_ignored = ignore_manager.is_ignored(rp)</span>

<span class="gd">-def remove(repo=&#39;.&#39;, paths=None, cached=False):</span>
<span class="gi">+                if not is_tracked and not is_ignored:</span>
<span class="gi">+                    os.remove(ap)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def remove(repo=&quot;.&quot;, paths=None, cached=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove files from the staging area.

<span class="w"> </span>    Args:
<span class="w"> </span>      repo: Repository for the files
<span class="w"> </span>      paths: Paths to remove
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        index = r.open_index()</span>
<span class="gi">+        for p in paths:</span>
<span class="gi">+            full_path = os.fsencode(os.path.abspath(p))</span>
<span class="gi">+            tree_path = path_to_tree_path(r.path, p)</span>
<span class="gi">+            try:</span>
<span class="gi">+                index_sha = index[tree_path].sha</span>
<span class="gi">+            except KeyError as exc:</span>
<span class="gi">+                raise Error(f&quot;{p} did not match any files&quot;) from exc</span>
<span class="gi">+</span>
<span class="gi">+            if not cached:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    st = os.lstat(full_path)</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        blob = blob_from_path_and_stat(full_path, st)</span>
<span class="gi">+                    except OSError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            committed_sha = tree_lookup_path(</span>
<span class="gi">+                                r.__getitem__, r[r.head()].tree, tree_path</span>
<span class="gi">+                            )[1]</span>
<span class="gi">+                        except KeyError:</span>
<span class="gi">+                            committed_sha = None</span>
<span class="gi">+</span>
<span class="gi">+                        if blob.id != index_sha and index_sha != committed_sha:</span>
<span class="gi">+                            raise Error(</span>
<span class="gi">+                                &quot;file has staged content differing &quot;</span>
<span class="gi">+                                f&quot;from both the file and head: {p}&quot;</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+                        if index_sha != committed_sha:</span>
<span class="gi">+                            raise Error(f&quot;file has staged changes: {p}&quot;)</span>
<span class="gi">+                        os.remove(full_path)</span>
<span class="gi">+            del index[tree_path]</span>
<span class="gi">+        index.write()</span>


<span class="w"> </span>rm = remove


<span class="gi">+def commit_decode(commit, contents, default_encoding=DEFAULT_ENCODING):</span>
<span class="gi">+    if commit.encoding:</span>
<span class="gi">+        encoding = commit.encoding.decode(&quot;ascii&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        encoding = default_encoding</span>
<span class="gi">+    return contents.decode(encoding, &quot;replace&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def commit_encode(commit, contents, default_encoding=DEFAULT_ENCODING):</span>
<span class="gi">+    if commit.encoding:</span>
<span class="gi">+        encoding = commit.encoding.decode(&quot;ascii&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        encoding = default_encoding</span>
<span class="gi">+    return contents.encode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def print_commit(commit, decode, outstream=sys.stdout):
<span class="w"> </span>    &quot;&quot;&quot;Write a human-readable commit log entry.

<span class="gu">@@ -349,7 +770,25 @@ def print_commit(commit, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      commit: A `Commit` object
<span class="w"> </span>      outstream: A stream file to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    outstream.write(&quot;-&quot; * 50 + &quot;\n&quot;)</span>
<span class="gi">+    outstream.write(&quot;commit: &quot; + commit.id.decode(&quot;ascii&quot;) + &quot;\n&quot;)</span>
<span class="gi">+    if len(commit.parents) &gt; 1:</span>
<span class="gi">+        outstream.write(</span>
<span class="gi">+            &quot;merge: &quot;</span>
<span class="gi">+            + &quot;...&quot;.join([c.decode(&quot;ascii&quot;) for c in commit.parents[1:]])</span>
<span class="gi">+            + &quot;\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    outstream.write(&quot;Author: &quot; + decode(commit.author) + &quot;\n&quot;)</span>
<span class="gi">+    if commit.author != commit.committer:</span>
<span class="gi">+        outstream.write(&quot;Committer: &quot; + decode(commit.committer) + &quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    time_tuple = time.gmtime(commit.author_time + commit.author_timezone)</span>
<span class="gi">+    time_str = time.strftime(&quot;%a %b %d %Y %H:%M:%S&quot;, time_tuple)</span>
<span class="gi">+    timezone_str = format_timezone(commit.author_timezone).decode(&quot;ascii&quot;)</span>
<span class="gi">+    outstream.write(&quot;Date:   &quot; + time_str + &quot; &quot; + timezone_str + &quot;\n&quot;)</span>
<span class="gi">+    outstream.write(&quot;\n&quot;)</span>
<span class="gi">+    outstream.write(decode(commit.message) + &quot;\n&quot;)</span>
<span class="gi">+    outstream.write(&quot;\n&quot;)</span>


<span class="w"> </span>def print_tag(tag, decode, outstream=sys.stdout):
<span class="gu">@@ -360,7 +799,14 @@ def print_tag(tag, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      decode: Function for decoding bytes to unicode string
<span class="w"> </span>      outstream: A stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    outstream.write(&quot;Tagger: &quot; + decode(tag.tagger) + &quot;\n&quot;)</span>
<span class="gi">+    time_tuple = time.gmtime(tag.tag_time + tag.tag_timezone)</span>
<span class="gi">+    time_str = time.strftime(&quot;%a %b %d %Y %H:%M:%S&quot;, time_tuple)</span>
<span class="gi">+    timezone_str = format_timezone(tag.tag_timezone).decode(&quot;ascii&quot;)</span>
<span class="gi">+    outstream.write(&quot;Date:   &quot; + time_str + &quot; &quot; + timezone_str + &quot;\n&quot;)</span>
<span class="gi">+    outstream.write(&quot;\n&quot;)</span>
<span class="gi">+    outstream.write(decode(tag.message))</span>
<span class="gi">+    outstream.write(&quot;\n&quot;)</span>


<span class="w"> </span>def show_blob(repo, blob, decode, outstream=sys.stdout):
<span class="gu">@@ -372,7 +818,7 @@ def show_blob(repo, blob, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      decode: Function for decoding bytes to unicode string
<span class="w"> </span>      outstream: A stream file to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    outstream.write(decode(blob.data))</span>


<span class="w"> </span>def show_commit(repo, commit, decode, outstream=sys.stdout):
<span class="gu">@@ -384,7 +830,16 @@ def show_commit(repo, commit, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      decode: Function for decoding bytes to unicode string
<span class="w"> </span>      outstream: Stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print_commit(commit, decode=decode, outstream=outstream)</span>
<span class="gi">+    if commit.parents:</span>
<span class="gi">+        parent_commit = repo[commit.parents[0]]</span>
<span class="gi">+        base_tree = parent_commit.tree</span>
<span class="gi">+    else:</span>
<span class="gi">+        base_tree = None</span>
<span class="gi">+    diffstream = BytesIO()</span>
<span class="gi">+    write_tree_diff(diffstream, repo.object_store, base_tree, commit.tree)</span>
<span class="gi">+    diffstream.seek(0)</span>
<span class="gi">+    outstream.write(commit_decode(commit, diffstream.getvalue()))</span>


<span class="w"> </span>def show_tree(repo, tree, decode, outstream=sys.stdout):
<span class="gu">@@ -396,7 +851,8 @@ def show_tree(repo, tree, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      decode: Function for decoding bytes to unicode string
<span class="w"> </span>      outstream: Stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for n in tree:</span>
<span class="gi">+        outstream.write(decode(n) + &quot;\n&quot;)</span>


<span class="w"> </span>def show_tag(repo, tag, decode, outstream=sys.stdout):
<span class="gu">@@ -408,16 +864,56 @@ def show_tag(repo, tag, decode, outstream=sys.stdout):</span>
<span class="w"> </span>      decode: Function for decoding bytes to unicode string
<span class="w"> </span>      outstream: Stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print_tag(tag, decode, outstream)</span>
<span class="gi">+    show_object(repo, repo[tag.object[1]], decode, outstream)</span>


<span class="gd">-def print_name_status(changes):</span>
<span class="gd">-    &quot;&quot;&quot;Print a simple status summary, listing changed files.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def show_object(repo, obj, decode, outstream):</span>
<span class="gi">+    return {</span>
<span class="gi">+        b&quot;tree&quot;: show_tree,</span>
<span class="gi">+        b&quot;blob&quot;: show_blob,</span>
<span class="gi">+        b&quot;commit&quot;: show_commit,</span>
<span class="gi">+        b&quot;tag&quot;: show_tag,</span>
<span class="gi">+    }[obj.type_name](repo, obj, decode, outstream)</span>


<span class="gd">-def log(repo=&#39;.&#39;, paths=None, outstream=sys.stdout, max_entries=None,</span>
<span class="gd">-    reverse=False, name_status=False):</span>
<span class="gi">+def print_name_status(changes):</span>
<span class="gi">+    &quot;&quot;&quot;Print a simple status summary, listing changed files.&quot;&quot;&quot;</span>
<span class="gi">+    for change in changes:</span>
<span class="gi">+        if not change:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(change, list):</span>
<span class="gi">+            change = change[0]</span>
<span class="gi">+        if change.type == CHANGE_ADD:</span>
<span class="gi">+            path1 = change.new.path</span>
<span class="gi">+            path2 = &quot;&quot;</span>
<span class="gi">+            kind = &quot;A&quot;</span>
<span class="gi">+        elif change.type == CHANGE_DELETE:</span>
<span class="gi">+            path1 = change.old.path</span>
<span class="gi">+            path2 = &quot;&quot;</span>
<span class="gi">+            kind = &quot;D&quot;</span>
<span class="gi">+        elif change.type == CHANGE_MODIFY:</span>
<span class="gi">+            path1 = change.new.path</span>
<span class="gi">+            path2 = &quot;&quot;</span>
<span class="gi">+            kind = &quot;M&quot;</span>
<span class="gi">+        elif change.type in RENAME_CHANGE_TYPES:</span>
<span class="gi">+            path1 = change.old.path</span>
<span class="gi">+            path2 = change.new.path</span>
<span class="gi">+            if change.type == CHANGE_RENAME:</span>
<span class="gi">+                kind = &quot;R&quot;</span>
<span class="gi">+            elif change.type == CHANGE_COPY:</span>
<span class="gi">+                kind = &quot;C&quot;</span>
<span class="gi">+        yield &quot;%-8s%-20s%-20s&quot; % (kind, path1, path2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def log(</span>
<span class="gi">+    repo=&quot;.&quot;,</span>
<span class="gi">+    paths=None,</span>
<span class="gi">+    outstream=sys.stdout,</span>
<span class="gi">+    max_entries=None,</span>
<span class="gi">+    reverse=False,</span>
<span class="gi">+    name_status=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write commit logs.

<span class="w"> </span>    Args:
<span class="gu">@@ -428,11 +924,27 @@ def log(repo=&#39;.&#39;, paths=None, outstream=sys.stdout, max_entries=None,</span>
<span class="w"> </span>      name_status: Print name status
<span class="w"> </span>      max_entries: Optional maximum number of entries to display
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        walker = r.get_walker(max_entries=max_entries, paths=paths, reverse=reverse)</span>
<span class="gi">+        for entry in walker:</span>
<span class="gi">+</span>
<span class="gi">+            def decode(x):</span>
<span class="gi">+                return commit_decode(entry.commit, x)</span>

<span class="gi">+            print_commit(entry.commit, decode, outstream)</span>
<span class="gi">+            if name_status:</span>
<span class="gi">+                outstream.writelines(</span>
<span class="gi">+                    [line + &quot;\n&quot; for line in print_name_status(entry.changes())]</span>
<span class="gi">+                )</span>

<span class="gd">-def show(repo=&#39;.&#39;, objects=None, outstream=sys.stdout, default_encoding=</span>
<span class="gd">-    DEFAULT_ENCODING):</span>
<span class="gi">+</span>
<span class="gi">+# TODO(jelmer): better default for encoding?</span>
<span class="gi">+def show(</span>
<span class="gi">+    repo=&quot;.&quot;,</span>
<span class="gi">+    objects=None,</span>
<span class="gi">+    outstream=sys.stdout,</span>
<span class="gi">+    default_encoding=DEFAULT_ENCODING,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Print the changes in a commit.

<span class="w"> </span>    Args:
<span class="gu">@@ -442,7 +954,24 @@ def show(repo=&#39;.&#39;, objects=None, outstream=sys.stdout, default_encoding=</span>
<span class="w"> </span>      default_encoding: Default encoding to use if none is set in the
<span class="w"> </span>        commit
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if objects is None:</span>
<span class="gi">+        objects = [&quot;HEAD&quot;]</span>
<span class="gi">+    if not isinstance(objects, list):</span>
<span class="gi">+        objects = [objects]</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        for objectish in objects:</span>
<span class="gi">+            o = parse_object(r, objectish)</span>
<span class="gi">+            if isinstance(o, Commit):</span>
<span class="gi">+</span>
<span class="gi">+                def decode(x):</span>
<span class="gi">+                    return commit_decode(o, x, default_encoding)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                def decode(x):</span>
<span class="gi">+                    return x.decode(default_encoding)</span>
<span class="gi">+</span>
<span class="gi">+            show_object(r, o, decode, outstream)</span>


<span class="w"> </span>def diff_tree(repo, old_tree, new_tree, outstream=default_bytes_out_stream):
<span class="gu">@@ -454,7 +983,8 @@ def diff_tree(repo, old_tree, new_tree, outstream=default_bytes_out_stream):</span>
<span class="w"> </span>      new_tree: Id of new tree
<span class="w"> </span>      outstream: Stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        write_tree_diff(outstream, r.object_store, old_tree, new_tree)</span>


<span class="w"> </span>def rev_list(repo, commits, outstream=sys.stdout):
<span class="gu">@@ -465,7 +995,16 @@ def rev_list(repo, commits, outstream=sys.stdout):</span>
<span class="w"> </span>      commits: Commits over which to iterate
<span class="w"> </span>      outstream: Stream to write to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        for entry in r.get_walker(include=[r[c].id for c in commits]):</span>
<span class="gi">+            outstream.write(entry.commit.id + b&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _canonical_part(url: str) -&gt; str:</span>
<span class="gi">+    name = url.rsplit(&quot;/&quot;, 1)[-1]</span>
<span class="gi">+    if name.endswith(&quot;.git&quot;):</span>
<span class="gi">+        name = name[:-4]</span>
<span class="gi">+    return name</span>


<span class="w"> </span>def submodule_add(repo, url, path=None, name=None):
<span class="gu">@@ -476,7 +1015,22 @@ def submodule_add(repo, url, path=None, name=None):</span>
<span class="w"> </span>      url: URL of repository to add as submodule
<span class="w"> </span>      path: Path where submodule should live
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if path is None:</span>
<span class="gi">+            path = os.path.relpath(_canonical_part(url), r.path)</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            name = path</span>
<span class="gi">+</span>
<span class="gi">+        # TODO(jelmer): Move this logic to dulwich.submodule</span>
<span class="gi">+        gitmodules_path = os.path.join(r.path, &quot;.gitmodules&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            config = ConfigFile.from_path(gitmodules_path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            config = ConfigFile()</span>
<span class="gi">+            config.path = gitmodules_path</span>
<span class="gi">+        config.set((&quot;submodule&quot;, name), &quot;url&quot;, url)</span>
<span class="gi">+        config.set((&quot;submodule&quot;, name), &quot;path&quot;, path)</span>
<span class="gi">+        config.write_to_path()</span>


<span class="w"> </span>def submodule_init(repo):
<span class="gu">@@ -485,7 +1039,13 @@ def submodule_init(repo):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      repo: Path to repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        config = r.get_config()</span>
<span class="gi">+        gitmodules_path = os.path.join(r.path, &quot;.gitmodules&quot;)</span>
<span class="gi">+        for path, url, name in read_submodules(gitmodules_path):</span>
<span class="gi">+            config.set((b&quot;submodule&quot;, name), b&quot;active&quot;, True)</span>
<span class="gi">+            config.set((b&quot;submodule&quot;, name), b&quot;url&quot;, url)</span>
<span class="gi">+        config.write_to_path()</span>


<span class="w"> </span>def submodule_list(repo):
<span class="gu">@@ -494,12 +1054,25 @@ def submodule_list(repo):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      repo: Path to repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def tag_create(repo, tag, author=None, message=None, annotated=False,</span>
<span class="gd">-    objectish=&#39;HEAD&#39;, tag_time=None, tag_timezone=None, sign=False,</span>
<span class="gd">-    encoding=DEFAULT_ENCODING):</span>
<span class="gi">+    from .submodule import iter_cached_submodules</span>
<span class="gi">+</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        for path, sha in iter_cached_submodules(r.object_store, r[r.head()].tree):</span>
<span class="gi">+            yield path, sha.decode(DEFAULT_ENCODING)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tag_create(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    tag,</span>
<span class="gi">+    author=None,</span>
<span class="gi">+    message=None,</span>
<span class="gi">+    annotated=False,</span>
<span class="gi">+    objectish=&quot;HEAD&quot;,</span>
<span class="gi">+    tag_time=None,</span>
<span class="gi">+    tag_timezone=None,</span>
<span class="gi">+    sign=False,</span>
<span class="gi">+    encoding=DEFAULT_ENCODING,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a tag in git via dulwich calls.

<span class="w"> </span>    Args:
<span class="gu">@@ -515,7 +1088,35 @@ def tag_create(repo, tag, author=None, message=None, annotated=False,</span>
<span class="w"> </span>        pass True to use default GPG key,
<span class="w"> </span>        pass a str containing Key ID to use a specific GPG key)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        object = parse_object(r, objectish)</span>
<span class="gi">+</span>
<span class="gi">+        if annotated:</span>
<span class="gi">+            # Create the tag object</span>
<span class="gi">+            tag_obj = Tag()</span>
<span class="gi">+            if author is None:</span>
<span class="gi">+                author = get_user_identity(r.get_config_stack())</span>
<span class="gi">+            tag_obj.tagger = author</span>
<span class="gi">+            tag_obj.message = message + &quot;\n&quot;.encode(encoding)</span>
<span class="gi">+            tag_obj.name = tag</span>
<span class="gi">+            tag_obj.object = (type(object), object.id)</span>
<span class="gi">+            if tag_time is None:</span>
<span class="gi">+                tag_time = int(time.time())</span>
<span class="gi">+            tag_obj.tag_time = tag_time</span>
<span class="gi">+            if tag_timezone is None:</span>
<span class="gi">+                tag_timezone = get_user_timezones()[1]</span>
<span class="gi">+            elif isinstance(tag_timezone, str):</span>
<span class="gi">+                tag_timezone = parse_timezone(tag_timezone)</span>
<span class="gi">+            tag_obj.tag_timezone = tag_timezone</span>
<span class="gi">+            if sign:</span>
<span class="gi">+                tag_obj.sign(sign if isinstance(sign, str) else None)</span>
<span class="gi">+</span>
<span class="gi">+            r.object_store.add_object(tag_obj)</span>
<span class="gi">+            tag_id = tag_obj.id</span>
<span class="gi">+        else:</span>
<span class="gi">+            tag_id = object.id</span>
<span class="gi">+</span>
<span class="gi">+        r.refs[_make_tag_ref(tag)] = tag_id</span>


<span class="w"> </span>def tag_list(repo, outstream=sys.stdout):
<span class="gu">@@ -525,7 +1126,9 @@ def tag_list(repo, outstream=sys.stdout):</span>
<span class="w"> </span>      repo: Path to repository
<span class="w"> </span>      outstream: Stream to write tags to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        tags = sorted(r.refs.as_dict(b&quot;refs/tags&quot;))</span>
<span class="gi">+        return tags</span>


<span class="w"> </span>def tag_delete(repo, name):
<span class="gu">@@ -535,10 +1138,18 @@ def tag_delete(repo, name):</span>
<span class="w"> </span>      repo: Path to repository
<span class="w"> </span>      name: Name of tag to remove
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if isinstance(name, bytes):</span>
<span class="gi">+            names = [name]</span>
<span class="gi">+        elif isinstance(name, list):</span>
<span class="gi">+            names = name</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Error(f&quot;Unexpected tag name type {name!r}&quot;)</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            del r.refs[_make_tag_ref(name)]</span>


<span class="gd">-def reset(repo, mode, treeish=&#39;HEAD&#39;):</span>
<span class="gi">+def reset(repo, mode, treeish=&quot;HEAD&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Reset current HEAD to the specified state.

<span class="w"> </span>    Args:
<span class="gu">@@ -546,12 +1157,47 @@ def reset(repo, mode, treeish=&#39;HEAD&#39;):</span>
<span class="w"> </span>      mode: Mode (&quot;hard&quot;, &quot;soft&quot;, &quot;mixed&quot;)
<span class="w"> </span>      treeish: Treeish to reset to
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mode != &quot;hard&quot;:</span>
<span class="gi">+        raise Error(&quot;hard is the only mode currently supported&quot;)</span>

<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        tree = parse_tree(r, treeish)</span>
<span class="gi">+        r.reset_index(tree.id)</span>

<span class="gd">-def push(repo, remote_location=None, refspecs=None, outstream=</span>
<span class="gd">-    default_bytes_out_stream, errstream=default_bytes_err_stream, force=</span>
<span class="gd">-    False, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+def get_remote_repo(</span>
<span class="gi">+    repo: Repo, remote_location: Optional[Union[str, bytes]] = None</span>
<span class="gi">+) -&gt; Tuple[Optional[str], str]:</span>
<span class="gi">+    config = repo.get_config()</span>
<span class="gi">+    if remote_location is None:</span>
<span class="gi">+        remote_location = get_branch_remote(repo)</span>
<span class="gi">+    if isinstance(remote_location, str):</span>
<span class="gi">+        encoded_location = remote_location.encode()</span>
<span class="gi">+    else:</span>
<span class="gi">+        encoded_location = remote_location</span>
<span class="gi">+</span>
<span class="gi">+    section = (b&quot;remote&quot;, encoded_location)</span>
<span class="gi">+</span>
<span class="gi">+    remote_name: Optional[str] = None</span>
<span class="gi">+</span>
<span class="gi">+    if config.has_section(section):</span>
<span class="gi">+        remote_name = encoded_location.decode()</span>
<span class="gi">+        encoded_location = config.get(section, &quot;url&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        remote_name = None</span>
<span class="gi">+</span>
<span class="gi">+    return (remote_name, encoded_location.decode())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def push(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    remote_location=None,</span>
<span class="gi">+    refspecs=None,</span>
<span class="gi">+    outstream=default_bytes_out_stream,</span>
<span class="gi">+    errstream=default_bytes_err_stream,</span>
<span class="gi">+    force=False,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Remote push with dulwich via dulwich.client.

<span class="w"> </span>    Args:
<span class="gu">@@ -562,13 +1208,82 @@ def push(repo, remote_location=None, refspecs=None, outstream=</span>
<span class="w"> </span>      errstream: A stream file to write errors
<span class="w"> </span>      force: Force overwriting refs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def pull(repo, remote_location=None, refspecs=None, outstream=</span>
<span class="gd">-    default_bytes_out_stream, errstream=default_bytes_err_stream,</span>
<span class="gd">-    fast_forward=True, force=False, refspec_encoding=DEFAULT_ENCODING,</span>
<span class="gd">-    filter_spec=None, protocol_version=None, **kwargs):</span>
<span class="gi">+    # Open the repo</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if refspecs is None:</span>
<span class="gi">+            refspecs = [active_branch(r)]</span>
<span class="gi">+        (remote_name, remote_location) = get_remote_repo(r, remote_location)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the client and path</span>
<span class="gi">+        client, path = get_transport_and_path(</span>
<span class="gi">+            remote_location, config=r.get_config_stack(), **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        selected_refs = []</span>
<span class="gi">+        remote_changed_refs = {}</span>
<span class="gi">+</span>
<span class="gi">+        def update_refs(refs):</span>
<span class="gi">+            selected_refs.extend(parse_reftuples(r.refs, refs, refspecs, force=force))</span>
<span class="gi">+            new_refs = {}</span>
<span class="gi">+            # TODO: Handle selected_refs == {None: None}</span>
<span class="gi">+            for lh, rh, force_ref in selected_refs:</span>
<span class="gi">+                if lh is None:</span>
<span class="gi">+                    new_refs[rh] = ZERO_SHA</span>
<span class="gi">+                    remote_changed_refs[rh] = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        localsha = r.refs[lh]</span>
<span class="gi">+                    except KeyError as exc:</span>
<span class="gi">+                        raise Error(f&quot;No valid ref {lh} in local repository&quot;) from exc</span>
<span class="gi">+                    if not force_ref and rh in refs:</span>
<span class="gi">+                        check_diverged(r, refs[rh], localsha)</span>
<span class="gi">+                    new_refs[rh] = localsha</span>
<span class="gi">+                    remote_changed_refs[rh] = localsha</span>
<span class="gi">+            return new_refs</span>
<span class="gi">+</span>
<span class="gi">+        err_encoding = getattr(errstream, &quot;encoding&quot;, None) or DEFAULT_ENCODING</span>
<span class="gi">+        remote_location = client.get_url(path)</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = client.send_pack(</span>
<span class="gi">+                path,</span>
<span class="gi">+                update_refs,</span>
<span class="gi">+                generate_pack_data=r.generate_pack_data,</span>
<span class="gi">+                progress=errstream.write,</span>
<span class="gi">+            )</span>
<span class="gi">+        except SendPackError as exc:</span>
<span class="gi">+            raise Error(</span>
<span class="gi">+                &quot;Push to &quot; + remote_location + &quot; failed -&gt; &quot; + exc.args[0].decode(),</span>
<span class="gi">+            ) from exc</span>
<span class="gi">+        else:</span>
<span class="gi">+            errstream.write(</span>
<span class="gi">+                b&quot;Push to &quot; + remote_location.encode(err_encoding) + b&quot; successful.\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for ref, error in (result.ref_status or {}).items():</span>
<span class="gi">+            if error is not None:</span>
<span class="gi">+                errstream.write(</span>
<span class="gi">+                    b&quot;Push of ref %s failed: %s\n&quot; % (ref, error.encode(err_encoding))</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                errstream.write(b&quot;Ref %s updated\n&quot; % ref)</span>
<span class="gi">+</span>
<span class="gi">+        if remote_name is not None:</span>
<span class="gi">+            _import_remote_refs(r.refs, remote_name, remote_changed_refs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pull(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    remote_location=None,</span>
<span class="gi">+    refspecs=None,</span>
<span class="gi">+    outstream=default_bytes_out_stream,</span>
<span class="gi">+    errstream=default_bytes_err_stream,</span>
<span class="gi">+    fast_forward=True,</span>
<span class="gi">+    force=False,</span>
<span class="gi">+    refspec_encoding=DEFAULT_ENCODING,</span>
<span class="gi">+    filter_spec=None,</span>
<span class="gi">+    protocol_version=None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Pull from remote via dulwich.client.

<span class="w"> </span>    Args:
<span class="gu">@@ -586,10 +1301,58 @@ def pull(repo, remote_location=None, refspecs=None, outstream=</span>
<span class="w"> </span>      protocol_version: desired Git protocol version. By default the highest
<span class="w"> </span>        mutually supported protocol version will be used
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def status(repo=&#39;.&#39;, ignored=False, untracked_files=&#39;all&#39;):</span>
<span class="gi">+    # Open the repo</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        (remote_name, remote_location) = get_remote_repo(r, remote_location)</span>
<span class="gi">+</span>
<span class="gi">+        encoded_refs = encode_refspecs(refspecs, refspec_encoding)</span>
<span class="gi">+        selected_refs = []</span>
<span class="gi">+</span>
<span class="gi">+        def determine_wants(remote_refs, **kwargs):</span>
<span class="gi">+            selected_refs.extend(</span>
<span class="gi">+                parse_reftuples(remote_refs, r.refs, encoded_refs, force=force)</span>
<span class="gi">+            )</span>
<span class="gi">+            return [</span>
<span class="gi">+                remote_refs[lh]</span>
<span class="gi">+                for (lh, rh, force_ref) in selected_refs</span>
<span class="gi">+                if remote_refs[lh] not in r.object_store</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        client, path = get_transport_and_path(</span>
<span class="gi">+            remote_location, config=r.get_config_stack(), **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+        if filter_spec:</span>
<span class="gi">+            filter_spec = filter_spec.encode(&quot;ascii&quot;)</span>
<span class="gi">+        fetch_result = client.fetch(</span>
<span class="gi">+            path,</span>
<span class="gi">+            r,</span>
<span class="gi">+            progress=errstream.write,</span>
<span class="gi">+            determine_wants=determine_wants,</span>
<span class="gi">+            ref_prefix=refspecs,</span>
<span class="gi">+            filter_spec=filter_spec,</span>
<span class="gi">+            protocol_version=protocol_version,</span>
<span class="gi">+        )</span>
<span class="gi">+        for lh, rh, force_ref in selected_refs:</span>
<span class="gi">+            if not force_ref and rh in r.refs:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    check_diverged(r, r.refs.follow(rh)[1], fetch_result.refs[lh])</span>
<span class="gi">+                except DivergedBranches as exc:</span>
<span class="gi">+                    if fast_forward:</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise NotImplementedError(&quot;merge is not yet supported&quot;) from exc</span>
<span class="gi">+            r.refs[rh] = fetch_result.refs[lh]</span>
<span class="gi">+        if selected_refs:</span>
<span class="gi">+            r[b&quot;HEAD&quot;] = fetch_result.refs[selected_refs[0][1]]</span>
<span class="gi">+</span>
<span class="gi">+        # Perform &#39;git checkout .&#39; - syncs staged changes</span>
<span class="gi">+        tree = r[b&quot;HEAD&quot;].tree</span>
<span class="gi">+        r.reset_index(tree=tree)</span>
<span class="gi">+        if remote_name is not None:</span>
<span class="gi">+            _import_remote_refs(r.refs, remote_name, fetch_result.refs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def status(repo=&quot;.&quot;, ignored=False, untracked_files=&quot;all&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns staged, unstaged, and untracked changes relative to the HEAD.

<span class="w"> </span>    Args:
<span class="gu">@@ -608,7 +1371,30 @@ def status(repo=&#39;.&#39;, ignored=False, untracked_files=&#39;all&#39;):</span>
<span class="w"> </span>        unstaged -  list of unstaged paths (diff index/working-tree)
<span class="w"> </span>        untracked - list of untracked, un-ignored &amp; non-.git paths
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        # 1. Get status of staged</span>
<span class="gi">+        tracked_changes = get_tree_changes(r)</span>
<span class="gi">+        # 2. Get status of unstaged</span>
<span class="gi">+        index = r.open_index()</span>
<span class="gi">+        normalizer = r.get_blob_normalizer()</span>
<span class="gi">+        filter_callback = normalizer.checkin_normalize</span>
<span class="gi">+        unstaged_changes = list(get_unstaged_changes(index, r.path, filter_callback))</span>
<span class="gi">+</span>
<span class="gi">+        untracked_paths = get_untracked_paths(</span>
<span class="gi">+            r.path,</span>
<span class="gi">+            r.path,</span>
<span class="gi">+            index,</span>
<span class="gi">+            exclude_ignored=not ignored,</span>
<span class="gi">+            untracked_files=untracked_files,</span>
<span class="gi">+        )</span>
<span class="gi">+        if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+            untracked_changes = [</span>
<span class="gi">+                path.replace(os.path.sep, &quot;/&quot;) for path in untracked_paths</span>
<span class="gi">+            ]</span>
<span class="gi">+        else:</span>
<span class="gi">+            untracked_changes = list(untracked_paths)</span>
<span class="gi">+</span>
<span class="gi">+        return GitStatus(tracked_changes, unstaged_changes, untracked_changes)</span>


<span class="w"> </span>def _walk_working_dir_paths(frompath, basepath, prune_dirnames=None):
<span class="gu">@@ -620,11 +1406,32 @@ def _walk_working_dir_paths(frompath, basepath, prune_dirnames=None):</span>
<span class="w"> </span>      prune_dirnames: Optional callback to prune dirnames during os.walk
<span class="w"> </span>        dirnames will be set to result of prune_dirnames(dirpath, dirnames)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for dirpath, dirnames, filenames in os.walk(frompath):</span>
<span class="gi">+        # Skip .git and below.</span>
<span class="gi">+        if &quot;.git&quot; in dirnames:</span>
<span class="gi">+            dirnames.remove(&quot;.git&quot;)</span>
<span class="gi">+            if dirpath != basepath:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;.git&quot; in filenames:</span>
<span class="gi">+            filenames.remove(&quot;.git&quot;)</span>
<span class="gi">+            if dirpath != basepath:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if dirpath != frompath:</span>
<span class="gi">+            yield dirpath, True</span>
<span class="gi">+</span>
<span class="gi">+        for filename in filenames:</span>
<span class="gi">+            filepath = os.path.join(dirpath, filename)</span>
<span class="gi">+            yield filepath, False</span>
<span class="gi">+</span>
<span class="gi">+        if prune_dirnames:</span>
<span class="gi">+            dirnames[:] = prune_dirnames(dirpath, dirnames)</span>


<span class="gd">-def get_untracked_paths(frompath, basepath, index, exclude_ignored=False,</span>
<span class="gd">-    untracked_files=&#39;all&#39;):</span>
<span class="gi">+def get_untracked_paths(</span>
<span class="gi">+    frompath, basepath, index, exclude_ignored=False, untracked_files=&quot;all&quot;</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Get untracked paths.

<span class="w"> </span>    Args:
<span class="gu">@@ -641,7 +1448,44 @@ def get_untracked_paths(frompath, basepath, index, exclude_ignored=False,</span>
<span class="w"> </span>      If exclude_ignored is False, only the path to an ignored directory will
<span class="w"> </span>      be yielded, no files inside the directory will be returned
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if untracked_files == &quot;normal&quot;:</span>
<span class="gi">+        raise NotImplementedError(&quot;normal is not yet supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if untracked_files not in (&quot;no&quot;, &quot;all&quot;):</span>
<span class="gi">+        raise ValueError(&quot;untracked_files must be one of (no, all)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if untracked_files == &quot;no&quot;:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    with open_repo_closing(basepath) as r:</span>
<span class="gi">+        ignore_manager = IgnoreFilterManager.from_repo(r)</span>
<span class="gi">+</span>
<span class="gi">+    ignored_dirs = []</span>
<span class="gi">+</span>
<span class="gi">+    def prune_dirnames(dirpath, dirnames):</span>
<span class="gi">+        for i in range(len(dirnames) - 1, -1, -1):</span>
<span class="gi">+            path = os.path.join(dirpath, dirnames[i])</span>
<span class="gi">+            ip = os.path.join(os.path.relpath(path, basepath), &quot;&quot;)</span>
<span class="gi">+            if ignore_manager.is_ignored(ip):</span>
<span class="gi">+                if not exclude_ignored:</span>
<span class="gi">+                    ignored_dirs.append(</span>
<span class="gi">+                        os.path.join(os.path.relpath(path, frompath), &quot;&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                del dirnames[i]</span>
<span class="gi">+        return dirnames</span>
<span class="gi">+</span>
<span class="gi">+    for ap, is_dir in _walk_working_dir_paths(</span>
<span class="gi">+        frompath, basepath, prune_dirnames=prune_dirnames</span>
<span class="gi">+    ):</span>
<span class="gi">+        if not is_dir:</span>
<span class="gi">+            ip = path_to_tree_path(basepath, ap)</span>
<span class="gi">+            if ip not in index:</span>
<span class="gi">+                if not exclude_ignored or not ignore_manager.is_ignored(</span>
<span class="gi">+                    os.path.relpath(ap, basepath)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    yield os.path.relpath(ap, frompath)</span>
<span class="gi">+</span>
<span class="gi">+    yield from ignored_dirs</span>


<span class="w"> </span>def get_tree_changes(repo):
<span class="gu">@@ -651,10 +1495,35 @@ def get_tree_changes(repo):</span>
<span class="w"> </span>      repo: repo path or object
<span class="w"> </span>    Returns: dict with lists for each type of change
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def daemon(path=&#39;.&#39;, address=None, port=None):</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        index = r.open_index()</span>
<span class="gi">+</span>
<span class="gi">+        # Compares the Index to the HEAD &amp; determines changes</span>
<span class="gi">+        # Iterate through the changes and report add/delete/modify</span>
<span class="gi">+        # TODO: call out to dulwich.diff_tree somehow.</span>
<span class="gi">+        tracked_changes = {</span>
<span class="gi">+            &quot;add&quot;: [],</span>
<span class="gi">+            &quot;delete&quot;: [],</span>
<span class="gi">+            &quot;modify&quot;: [],</span>
<span class="gi">+        }</span>
<span class="gi">+        try:</span>
<span class="gi">+            tree_id = r[b&quot;HEAD&quot;].tree</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            tree_id = None</span>
<span class="gi">+</span>
<span class="gi">+        for change in index.changes_from_tree(r.object_store, tree_id):</span>
<span class="gi">+            if not change[0][0]:</span>
<span class="gi">+                tracked_changes[&quot;add&quot;].append(change[0][1])</span>
<span class="gi">+            elif not change[0][1]:</span>
<span class="gi">+                tracked_changes[&quot;delete&quot;].append(change[0][0])</span>
<span class="gi">+            elif change[0][0] == change[0][1]:</span>
<span class="gi">+                tracked_changes[&quot;modify&quot;].append(change[0][0])</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NotImplementedError(&quot;git mv ops not yet supported&quot;)</span>
<span class="gi">+        return tracked_changes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def daemon(path=&quot;.&quot;, address=None, port=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Run a daemon serving Git requests over TCP/IP.

<span class="w"> </span>    Args:
<span class="gu">@@ -662,10 +1531,13 @@ def daemon(path=&#39;.&#39;, address=None, port=None):</span>
<span class="w"> </span>      address: Optional address to listen on (defaults to ::)
<span class="w"> </span>      port: Optional port to listen on (defaults to TCP_GIT_PORT)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO(jelmer): Support git-daemon-export-ok and --export-all.</span>
<span class="gi">+    backend = FileSystemBackend(path)</span>
<span class="gi">+    server = TCPGitServer(backend, address, port)</span>
<span class="gi">+    server.serve_forever()</span>


<span class="gd">-def web_daemon(path=&#39;.&#39;, address=None, port=None):</span>
<span class="gi">+def web_daemon(path=&quot;.&quot;, address=None, port=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Run a daemon serving Git requests over HTTP.

<span class="w"> </span>    Args:
<span class="gu">@@ -673,10 +1545,26 @@ def web_daemon(path=&#39;.&#39;, address=None, port=None):</span>
<span class="w"> </span>      address: Optional address to listen on (defaults to ::)
<span class="w"> </span>      port: Optional port to listen on (defaults to 80)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def upload_pack(path=&#39;.&#39;, inf=None, outf=None):</span>
<span class="gi">+    from .web import (</span>
<span class="gi">+        WSGIRequestHandlerLogger,</span>
<span class="gi">+        WSGIServerLogger,</span>
<span class="gi">+        make_server,</span>
<span class="gi">+        make_wsgi_chain,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    backend = FileSystemBackend(path)</span>
<span class="gi">+    app = make_wsgi_chain(backend)</span>
<span class="gi">+    server = make_server(</span>
<span class="gi">+        address,</span>
<span class="gi">+        port,</span>
<span class="gi">+        app,</span>
<span class="gi">+        handler_class=WSGIRequestHandlerLogger,</span>
<span class="gi">+        server_class=WSGIServerLogger,</span>
<span class="gi">+    )</span>
<span class="gi">+    server.serve_forever()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def upload_pack(path=&quot;.&quot;, inf=None, outf=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Upload a pack file after negotiating its contents using smart protocol.

<span class="w"> </span>    Args:
<span class="gu">@@ -684,10 +1572,25 @@ def upload_pack(path=&#39;.&#39;, inf=None, outf=None):</span>
<span class="w"> </span>      inf: Input stream to communicate with client
<span class="w"> </span>      outf: Output stream to communicate with client
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if outf is None:</span>
<span class="gi">+        outf = getattr(sys.stdout, &quot;buffer&quot;, sys.stdout)</span>
<span class="gi">+    if inf is None:</span>
<span class="gi">+        inf = getattr(sys.stdin, &quot;buffer&quot;, sys.stdin)</span>
<span class="gi">+    path = os.path.expanduser(path)</span>
<span class="gi">+    backend = FileSystemBackend(path)</span>
<span class="gi">+</span>
<span class="gi">+    def send_fn(data):</span>
<span class="gi">+        outf.write(data)</span>
<span class="gi">+        outf.flush()</span>

<span class="gi">+    proto = Protocol(inf.read, send_fn)</span>
<span class="gi">+    handler = UploadPackHandler(backend, [path], proto)</span>
<span class="gi">+    # FIXME: Catch exceptions and write a single-line summary to outf.</span>
<span class="gi">+    handler.handle()</span>
<span class="gi">+    return 0</span>

<span class="gd">-def receive_pack(path=&#39;.&#39;, inf=None, outf=None):</span>
<span class="gi">+</span>
<span class="gi">+def receive_pack(path=&quot;.&quot;, inf=None, outf=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Receive a pack file after negotiating its contents using smart protocol.

<span class="w"> </span>    Args:
<span class="gu">@@ -695,7 +1598,34 @@ def receive_pack(path=&#39;.&#39;, inf=None, outf=None):</span>
<span class="w"> </span>      inf: Input stream to communicate with client
<span class="w"> </span>      outf: Output stream to communicate with client
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if outf is None:</span>
<span class="gi">+        outf = getattr(sys.stdout, &quot;buffer&quot;, sys.stdout)</span>
<span class="gi">+    if inf is None:</span>
<span class="gi">+        inf = getattr(sys.stdin, &quot;buffer&quot;, sys.stdin)</span>
<span class="gi">+    path = os.path.expanduser(path)</span>
<span class="gi">+    backend = FileSystemBackend(path)</span>
<span class="gi">+</span>
<span class="gi">+    def send_fn(data):</span>
<span class="gi">+        outf.write(data)</span>
<span class="gi">+        outf.flush()</span>
<span class="gi">+</span>
<span class="gi">+    proto = Protocol(inf.read, send_fn)</span>
<span class="gi">+    handler = ReceivePackHandler(backend, [path], proto)</span>
<span class="gi">+    # FIXME: Catch exceptions and write a single-line summary to outf.</span>
<span class="gi">+    handler.handle()</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_branch_ref(name):</span>
<span class="gi">+    if getattr(name, &quot;encode&quot;, None):</span>
<span class="gi">+        name = name.encode(DEFAULT_ENCODING)</span>
<span class="gi">+    return LOCAL_BRANCH_PREFIX + name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_tag_ref(name):</span>
<span class="gi">+    if getattr(name, &quot;encode&quot;, None):</span>
<span class="gi">+        name = name.encode(DEFAULT_ENCODING)</span>
<span class="gi">+    return LOCAL_TAG_PREFIX + name</span>


<span class="w"> </span>def branch_delete(repo, name):
<span class="gu">@@ -705,7 +1635,13 @@ def branch_delete(repo, name):</span>
<span class="w"> </span>      repo: Path to the repository
<span class="w"> </span>      name: Name of the branch
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if isinstance(name, list):</span>
<span class="gi">+            names = name</span>
<span class="gi">+        else:</span>
<span class="gi">+            names = [name]</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            del r.refs[_make_branch_ref(name)]</span>


<span class="w"> </span>def branch_create(repo, name, objectish=None, force=False):
<span class="gu">@@ -717,7 +1653,17 @@ def branch_create(repo, name, objectish=None, force=False):</span>
<span class="w"> </span>      objectish: Target object to point new branch at (defaults to HEAD)
<span class="w"> </span>      force: Force creation of branch, even if it already exists
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if objectish is None:</span>
<span class="gi">+            objectish = &quot;HEAD&quot;</span>
<span class="gi">+        object = parse_object(r, objectish)</span>
<span class="gi">+        refname = _make_branch_ref(name)</span>
<span class="gi">+        ref_message = b&quot;branch: Created from &quot; + objectish.encode(DEFAULT_ENCODING)</span>
<span class="gi">+        if force:</span>
<span class="gi">+            r.refs.set_if_equals(refname, None, object.id, message=ref_message)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not r.refs.add_if_new(refname, object.id, message=ref_message):</span>
<span class="gi">+                raise Error(f&quot;Branch with name {name} already exists.&quot;)</span>


<span class="w"> </span>def branch_list(repo):
<span class="gu">@@ -726,7 +1672,8 @@ def branch_list(repo):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      repo: Path to the repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        return r.refs.keys(base=LOCAL_BRANCH_PREFIX)</span>


<span class="w"> </span>def active_branch(repo):
<span class="gu">@@ -740,7 +1687,11 @@ def active_branch(repo):</span>
<span class="w"> </span>      KeyError: if the repository does not have a working tree
<span class="w"> </span>      IndexError: if HEAD is floating
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        active_ref = r.refs.follow(b&quot;HEAD&quot;)[0][1]</span>
<span class="gi">+        if not active_ref.startswith(LOCAL_BRANCH_PREFIX):</span>
<span class="gi">+            raise ValueError(active_ref)</span>
<span class="gi">+        return active_ref[len(LOCAL_BRANCH_PREFIX) :]</span>


<span class="w"> </span>def get_branch_remote(repo):
<span class="gu">@@ -753,12 +1704,28 @@ def get_branch_remote(repo):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      KeyError: if the repository does not have a working tree
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def fetch(repo, remote_location=None, outstream=sys.stdout, errstream=</span>
<span class="gd">-    default_bytes_err_stream, message=None, depth=None, prune=False,</span>
<span class="gd">-    prune_tags=False, force=False, **kwargs):</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        branch_name = active_branch(r.path)</span>
<span class="gi">+        config = r.get_config()</span>
<span class="gi">+        try:</span>
<span class="gi">+            remote_name = config.get((b&quot;branch&quot;, branch_name), b&quot;remote&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            remote_name = b&quot;origin&quot;</span>
<span class="gi">+    return remote_name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fetch(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    remote_location=None,</span>
<span class="gi">+    outstream=sys.stdout,</span>
<span class="gi">+    errstream=default_bytes_err_stream,</span>
<span class="gi">+    message=None,</span>
<span class="gi">+    depth=None,</span>
<span class="gi">+    prune=False,</span>
<span class="gi">+    prune_tags=False,</span>
<span class="gi">+    force=False,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Fetch objects from a remote server.

<span class="w"> </span>    Args:
<span class="gu">@@ -773,11 +1740,30 @@ def fetch(repo, remote_location=None, outstream=sys.stdout, errstream=</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Dictionary with refs on the remote
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def for_each_ref(repo: Union[Repo, str]=&#39;.&#39;, pattern: Optional[Union[str,</span>
<span class="gd">-    bytes]]=None) -&gt;List[Tuple[bytes, bytes, bytes]]:</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        (remote_name, remote_location) = get_remote_repo(r, remote_location)</span>
<span class="gi">+        if message is None:</span>
<span class="gi">+            message = b&quot;fetch: from &quot; + remote_location.encode(DEFAULT_ENCODING)</span>
<span class="gi">+        client, path = get_transport_and_path(</span>
<span class="gi">+            remote_location, config=r.get_config_stack(), **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+        fetch_result = client.fetch(path, r, progress=errstream.write, depth=depth)</span>
<span class="gi">+        if remote_name is not None:</span>
<span class="gi">+            _import_remote_refs(</span>
<span class="gi">+                r.refs,</span>
<span class="gi">+                remote_name,</span>
<span class="gi">+                fetch_result.refs,</span>
<span class="gi">+                message,</span>
<span class="gi">+                prune=prune,</span>
<span class="gi">+                prune_tags=prune_tags,</span>
<span class="gi">+            )</span>
<span class="gi">+    return fetch_result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def for_each_ref(</span>
<span class="gi">+    repo: Union[Repo, str] = &quot;.&quot;,</span>
<span class="gi">+    pattern: Optional[Union[str, bytes]] = None,</span>
<span class="gi">+) -&gt; List[Tuple[bytes, bytes, bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over all refs that match the (optional) pattern.

<span class="w"> </span>    Args:
<span class="gu">@@ -786,10 +1772,49 @@ def for_each_ref(repo: Union[Repo, str]=&#39;.&#39;, pattern: Optional[Union[str,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      List of bytes tuples with: (sha, object_type, ref_name)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(pattern, str):</span>
<span class="gi">+        pattern = os.fsencode(pattern)</span>
<span class="gi">+</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        refs = r.get_refs()</span>
<span class="gi">+</span>
<span class="gi">+    if pattern:</span>
<span class="gi">+        matching_refs: Dict[bytes, bytes] = {}</span>
<span class="gi">+        pattern_parts = pattern.split(b&quot;/&quot;)</span>
<span class="gi">+        for ref, sha in refs.items():</span>
<span class="gi">+            matches = False</span>
<span class="gi">+</span>
<span class="gi">+            # git for-each-ref uses glob (7) style patterns, but fnmatch</span>
<span class="gi">+            # is greedy and also matches slashes, unlike glob.glob.</span>
<span class="gi">+            # We have to check parts of the pattern individually.</span>
<span class="gi">+            # See https://github.com/python/cpython/issues/72904</span>
<span class="gi">+            ref_parts = ref.split(b&quot;/&quot;)</span>
<span class="gi">+            if len(ref_parts) &gt; len(pattern_parts):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for pat, ref_part in zip(pattern_parts, ref_parts):</span>
<span class="gi">+                matches = fnmatch.fnmatchcase(ref_part, pat)</span>
<span class="gi">+                if not matches:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if matches:</span>
<span class="gi">+                matching_refs[ref] = sha</span>
<span class="gi">+</span>
<span class="gi">+        refs = matching_refs</span>
<span class="gi">+</span>
<span class="gi">+    ret: List[Tuple[bytes, bytes, bytes]] = [</span>
<span class="gi">+        (sha, r.get_object(sha).type_name, ref)</span>
<span class="gi">+        for ref, sha in sorted(</span>
<span class="gi">+            refs.items(),</span>
<span class="gi">+            key=lambda ref_sha: ref_sha[0],</span>
<span class="gi">+        )</span>
<span class="gi">+        if ref != b&quot;HEAD&quot;</span>
<span class="gi">+    ]</span>

<span class="gi">+    return ret</span>

<span class="gd">-def ls_remote(remote, config: Optional[Config]=None, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+def ls_remote(remote, config: Optional[Config] = None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;List the refs in a remote.

<span class="w"> </span>    Args:
<span class="gu">@@ -798,7 +1823,10 @@ def ls_remote(remote, config: Optional[Config]=None, **kwargs):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Dictionary with remote refs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if config is None:</span>
<span class="gi">+        config = StackedConfig.default()</span>
<span class="gi">+    client, host_path = get_transport_and_path(remote, config=config, **kwargs)</span>
<span class="gi">+    return client.get_refs(host_path)</span>


<span class="w"> </span>def repack(repo):
<span class="gu">@@ -809,11 +1837,19 @@ def repack(repo):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      repo: Path to the repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        r.object_store.pack_loose_objects()</span>


<span class="gd">-def pack_objects(repo, object_ids, packf, idxf, delta_window_size=None,</span>
<span class="gd">-    deltify=None, reuse_deltas=True):</span>
<span class="gi">+def pack_objects(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    object_ids,</span>
<span class="gi">+    packf,</span>
<span class="gi">+    idxf,</span>
<span class="gi">+    delta_window_size=None,</span>
<span class="gi">+    deltify=None,</span>
<span class="gi">+    reuse_deltas=True,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Pack objects into a file.

<span class="w"> </span>    Args:
<span class="gu">@@ -826,11 +1862,27 @@ def pack_objects(repo, object_ids, packf, idxf, delta_window_size=None,</span>
<span class="w"> </span>      deltify: Whether to deltify objects
<span class="w"> </span>      reuse_deltas: Allow reuse of existing deltas while deltifying
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def ls_tree(repo, treeish=b&#39;HEAD&#39;, outstream=sys.stdout, recursive=False,</span>
<span class="gd">-    name_only=False):</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        entries, data_sum = write_pack_from_container(</span>
<span class="gi">+            packf.write,</span>
<span class="gi">+            r.object_store,</span>
<span class="gi">+            [(oid, None) for oid in object_ids],</span>
<span class="gi">+            deltify=deltify,</span>
<span class="gi">+            delta_window_size=delta_window_size,</span>
<span class="gi">+            reuse_deltas=reuse_deltas,</span>
<span class="gi">+        )</span>
<span class="gi">+    if idxf is not None:</span>
<span class="gi">+        entries = sorted([(k, v[0], v[1]) for (k, v) in entries.items()])</span>
<span class="gi">+        write_pack_index(idxf, entries, data_sum)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ls_tree(</span>
<span class="gi">+    repo,</span>
<span class="gi">+    treeish=b&quot;HEAD&quot;,</span>
<span class="gi">+    outstream=sys.stdout,</span>
<span class="gi">+    recursive=False,</span>
<span class="gi">+    name_only=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;List contents of a tree.

<span class="w"> </span>    Args:
<span class="gu">@@ -840,7 +1892,21 @@ def ls_tree(repo, treeish=b&#39;HEAD&#39;, outstream=sys.stdout, recursive=False,</span>
<span class="w"> </span>      recursive: Whether to recursively list files
<span class="w"> </span>      name_only: Only print item name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def list_tree(store, treeid, base):</span>
<span class="gi">+        for name, mode, sha in store[treeid].iteritems():</span>
<span class="gi">+            if base:</span>
<span class="gi">+                name = posixpath.join(base, name)</span>
<span class="gi">+            if name_only:</span>
<span class="gi">+                outstream.write(name + b&quot;\n&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                outstream.write(pretty_format_tree_entry(name, mode, sha))</span>
<span class="gi">+            if stat.S_ISDIR(mode) and recursive:</span>
<span class="gi">+                list_tree(store, sha, name)</span>
<span class="gi">+</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        tree = parse_tree(r, treeish)</span>
<span class="gi">+        list_tree(r.object_store, tree.id, &quot;&quot;)</span>


<span class="w"> </span>def remote_add(repo: Repo, name: Union[bytes, str], url: Union[bytes, str]):
<span class="gu">@@ -851,7 +1917,17 @@ def remote_add(repo: Repo, name: Union[bytes, str], url: Union[bytes, str]):</span>
<span class="w"> </span>      name: Remote name
<span class="w"> </span>      url: Remote URL
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(name, bytes):</span>
<span class="gi">+        name = name.encode(DEFAULT_ENCODING)</span>
<span class="gi">+    if not isinstance(url, bytes):</span>
<span class="gi">+        url = url.encode(DEFAULT_ENCODING)</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        c = r.get_config()</span>
<span class="gi">+        section = (b&quot;remote&quot;, name)</span>
<span class="gi">+        if c.has_section(section):</span>
<span class="gi">+            raise RemoteExists(section)</span>
<span class="gi">+        c.set(section, b&quot;url&quot;, url)</span>
<span class="gi">+        c.write_to_path()</span>


<span class="w"> </span>def remote_remove(repo: Repo, name: Union[bytes, str]):
<span class="gu">@@ -861,7 +1937,13 @@ def remote_remove(repo: Repo, name: Union[bytes, str]):</span>
<span class="w"> </span>      repo: Path to the repository
<span class="w"> </span>      name: Remote name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(name, bytes):</span>
<span class="gi">+        name = name.encode(DEFAULT_ENCODING)</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        c = r.get_config()</span>
<span class="gi">+        section = (b&quot;remote&quot;, name)</span>
<span class="gi">+        del c[section]</span>
<span class="gi">+        c.write_to_path()</span>


<span class="w"> </span>def check_ignore(repo, paths, no_index=False):
<span class="gu">@@ -873,7 +1955,16 @@ def check_ignore(repo, paths, no_index=False):</span>
<span class="w"> </span>      no_index: Don&#39;t check index
<span class="w"> </span>    Returns: List of ignored files
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        index = r.open_index()</span>
<span class="gi">+        ignore_manager = IgnoreFilterManager.from_repo(r)</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            if not no_index and path_to_tree_path(r.path, path) in index:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if os.path.isabs(path):</span>
<span class="gi">+                path = os.path.relpath(path, r.path)</span>
<span class="gi">+            if ignore_manager.is_ignored(path):</span>
<span class="gi">+                yield path</span>


<span class="w"> </span>def update_head(repo, target, detached=False, new_branch=None):
<span class="gu">@@ -887,10 +1978,24 @@ def update_head(repo, target, detached=False, new_branch=None):</span>
<span class="w"> </span>      target: Branch or committish to switch to
<span class="w"> </span>      new_branch: New branch to create
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def reset_file(repo, file_path: str, target: bytes=b&#39;HEAD&#39;, symlink_fn=None):</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        if new_branch is not None:</span>
<span class="gi">+            to_set = _make_branch_ref(new_branch)</span>
<span class="gi">+        else:</span>
<span class="gi">+            to_set = b&quot;HEAD&quot;</span>
<span class="gi">+        if detached:</span>
<span class="gi">+            # TODO(jelmer): Provide some way so that the actual ref gets</span>
<span class="gi">+            # updated rather than what it points to, so the delete isn&#39;t</span>
<span class="gi">+            # necessary.</span>
<span class="gi">+            del r.refs[to_set]</span>
<span class="gi">+            r.refs[to_set] = parse_commit(r, target).id</span>
<span class="gi">+        else:</span>
<span class="gi">+            r.refs.set_symbolic_ref(to_set, parse_ref(r, target))</span>
<span class="gi">+        if new_branch is not None:</span>
<span class="gi">+            r.refs.set_symbolic_ref(b&quot;HEAD&quot;, to_set)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def reset_file(repo, file_path: str, target: bytes = b&quot;HEAD&quot;, symlink_fn=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Reset the file to specific commit or branch.

<span class="w"> </span>    Args:
<span class="gu">@@ -898,10 +2003,43 @@ def reset_file(repo, file_path: str, target: bytes=b&#39;HEAD&#39;, symlink_fn=None):</span>
<span class="w"> </span>      file_path: file to reset, relative to the repository path
<span class="w"> </span>      target: branch or commit or b&#39;HEAD&#39; to reset
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def checkout_branch(repo, target: Union[bytes, str], force: bool=False):</span>
<span class="gi">+    tree = parse_tree(repo, treeish=target)</span>
<span class="gi">+    tree_path = _fs_to_tree_path(file_path)</span>
<span class="gi">+</span>
<span class="gi">+    file_entry = tree.lookup_path(repo.object_store.__getitem__, tree_path)</span>
<span class="gi">+    full_path = os.path.join(os.fsencode(repo.path), tree_path)</span>
<span class="gi">+    blob = repo.object_store[file_entry[1]]</span>
<span class="gi">+    mode = file_entry[0]</span>
<span class="gi">+    build_file_from_blob(blob, mode, full_path, symlink_fn=symlink_fn)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _update_head_during_checkout_branch(repo, target):</span>
<span class="gi">+    checkout_target = None</span>
<span class="gi">+    if target == b&quot;HEAD&quot;:  # Do not update head while trying to checkout to HEAD.</span>
<span class="gi">+        pass</span>
<span class="gi">+    elif target in repo.refs.keys(base=LOCAL_BRANCH_PREFIX):</span>
<span class="gi">+        update_head(repo, target)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If checking out a remote branch, create a local one without the remote name prefix.</span>
<span class="gi">+        config = repo.get_config()</span>
<span class="gi">+        name = target.split(b&quot;/&quot;)[0]</span>
<span class="gi">+        section = (b&quot;remote&quot;, name)</span>
<span class="gi">+        if config.has_section(section):</span>
<span class="gi">+            checkout_target = target.replace(name + b&quot;/&quot;, b&quot;&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                branch_create(</span>
<span class="gi">+                    repo, checkout_target, (LOCAL_REMOTE_PREFIX + target).decode()</span>
<span class="gi">+                )</span>
<span class="gi">+            except Error:</span>
<span class="gi">+                pass</span>
<span class="gi">+            update_head(repo, LOCAL_BRANCH_PREFIX + checkout_target)</span>
<span class="gi">+        else:</span>
<span class="gi">+            update_head(repo, target, detached=True)</span>
<span class="gi">+</span>
<span class="gi">+    return checkout_target</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def checkout_branch(repo, target: Union[bytes, str], force: bool = False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Switch branches or restore working tree files.

<span class="w"> </span>    The implementation of this function will probably not scale well
<span class="gu">@@ -914,7 +2052,78 @@ def checkout_branch(repo, target: Union[bytes, str], force: bool=False):</span>
<span class="w"> </span>      target: branch name or commit sha to checkout
<span class="w"> </span>      force: true or not to force checkout
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    target = to_bytes(target)</span>
<span class="gi">+</span>
<span class="gi">+    current_tree = parse_tree(repo, repo.head())</span>
<span class="gi">+    target_tree = parse_tree(repo, target)</span>
<span class="gi">+</span>
<span class="gi">+    if force:</span>
<span class="gi">+        repo.reset_index(target_tree.id)</span>
<span class="gi">+        _update_head_during_checkout_branch(repo, target)</span>
<span class="gi">+    else:</span>
<span class="gi">+        status_report = status(repo)</span>
<span class="gi">+        changes = list(</span>
<span class="gi">+            set(</span>
<span class="gi">+                status_report[0][&quot;add&quot;]</span>
<span class="gi">+                + status_report[0][&quot;delete&quot;]</span>
<span class="gi">+                + status_report[0][&quot;modify&quot;]</span>
<span class="gi">+                + status_report[1]</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        index = 0</span>
<span class="gi">+        while index &lt; len(changes):</span>
<span class="gi">+            change = changes[index]</span>
<span class="gi">+            try:</span>
<span class="gi">+                current_tree.lookup_path(repo.object_store.__getitem__, change)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    target_tree.lookup_path(repo.object_store.__getitem__, change)</span>
<span class="gi">+                    index += 1</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    raise CheckoutError(</span>
<span class="gi">+                        &quot;Your local changes to the following files would be overwritten by checkout: &quot;</span>
<span class="gi">+                        + change.decode()</span>
<span class="gi">+                    )</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                changes.pop(index)</span>
<span class="gi">+</span>
<span class="gi">+        # Update head.</span>
<span class="gi">+        checkout_target = _update_head_during_checkout_branch(repo, target)</span>
<span class="gi">+        if checkout_target is not None:</span>
<span class="gi">+            target_tree = parse_tree(repo, checkout_target)</span>
<span class="gi">+</span>
<span class="gi">+        dealt_with = set()</span>
<span class="gi">+        repo_index = repo.open_index()</span>
<span class="gi">+        for entry in iter_tree_contents(repo.object_store, target_tree.id):</span>
<span class="gi">+            dealt_with.add(entry.path)</span>
<span class="gi">+            if entry.path in changes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            full_path = os.path.join(os.fsencode(repo.path), entry.path)</span>
<span class="gi">+            blob = repo.object_store[entry.sha]</span>
<span class="gi">+            ensure_dir_exists(os.path.dirname(full_path))</span>
<span class="gi">+            st = build_file_from_blob(blob, entry.mode, full_path)</span>
<span class="gi">+            repo_index[entry.path] = index_entry_from_stat(st, entry.sha)</span>
<span class="gi">+</span>
<span class="gi">+        repo_index.write()</span>
<span class="gi">+</span>
<span class="gi">+        for entry in iter_tree_contents(repo.object_store, current_tree.id):</span>
<span class="gi">+            if entry.path not in dealt_with:</span>
<span class="gi">+                repo.unstage([entry.path])</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the untracked files which are in the current_file_set.</span>
<span class="gi">+    repo_index = repo.open_index()</span>
<span class="gi">+    for change in repo_index.changes_from_tree(repo.object_store, current_tree.id):</span>
<span class="gi">+        path_change = change[0]</span>
<span class="gi">+        if path_change[1] is None:</span>
<span class="gi">+            file_name = path_change[0]</span>
<span class="gi">+            full_path = os.path.join(repo.path, file_name.decode())</span>
<span class="gi">+            if os.path.isfile(full_path):</span>
<span class="gi">+                os.remove(full_path)</span>
<span class="gi">+            dir_path = os.path.dirname(full_path)</span>
<span class="gi">+            while dir_path != repo.path:</span>
<span class="gi">+                is_empty = len(os.listdir(dir_path)) == 0</span>
<span class="gi">+                if is_empty:</span>
<span class="gi">+                    os.rmdir(dir_path)</span>
<span class="gi">+                dir_path = os.path.dirname(dir_path)</span>


<span class="w"> </span>def check_mailmap(repo, contact):
<span class="gu">@@ -925,7 +2134,14 @@ def check_mailmap(repo, contact):</span>
<span class="w"> </span>      contact: Contact name and/or email
<span class="w"> </span>    Returns: Canonical contact data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        from .mailmap import Mailmap</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            mailmap = Mailmap.from_path(os.path.join(r.path, &quot;.mailmap&quot;))</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            mailmap = Mailmap()</span>
<span class="gi">+        return mailmap.lookup(contact)</span>


<span class="w"> </span>def fsck(repo):
<span class="gu">@@ -935,37 +2151,65 @@ def fsck(repo):</span>
<span class="w"> </span>      repo: A path to the repository
<span class="w"> </span>    Returns: Iterator over errors/warnings
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        # TODO(jelmer): check pack files</span>
<span class="gi">+        # TODO(jelmer): check graph</span>
<span class="gi">+        # TODO(jelmer): check refs</span>
<span class="gi">+        for sha in r.object_store:</span>
<span class="gi">+            o = r.object_store[sha]</span>
<span class="gi">+            try:</span>
<span class="gi">+                o.check()</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                yield (sha, e)</span>


<span class="w"> </span>def stash_list(repo):
<span class="w"> </span>    &quot;&quot;&quot;List all stashes in a repository.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        from .stash import Stash</span>
<span class="gi">+</span>
<span class="gi">+        stash = Stash.from_repo(r)</span>
<span class="gi">+        return enumerate(list(stash.stashes()))</span>


<span class="w"> </span>def stash_push(repo):
<span class="w"> </span>    &quot;&quot;&quot;Push a new stash onto the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        from .stash import Stash</span>
<span class="gi">+</span>
<span class="gi">+        stash = Stash.from_repo(r)</span>
<span class="gi">+        stash.push()</span>


<span class="w"> </span>def stash_pop(repo, index):
<span class="w"> </span>    &quot;&quot;&quot;Pop a stash from the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        from .stash import Stash</span>
<span class="gi">+</span>
<span class="gi">+        stash = Stash.from_repo(r)</span>
<span class="gi">+        stash.pop(index)</span>


<span class="w"> </span>def stash_drop(repo, index):
<span class="w"> </span>    &quot;&quot;&quot;Drop a stash from the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        from .stash import Stash</span>
<span class="gi">+</span>
<span class="gi">+        stash = Stash.from_repo(r)</span>
<span class="gi">+        stash.drop(index)</span>


<span class="w"> </span>def ls_files(repo):
<span class="w"> </span>    &quot;&quot;&quot;List all files in an index.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        return sorted(r.open_index())</span>


<span class="w"> </span>def find_unique_abbrev(object_store, object_id):
<span class="w"> </span>    &quot;&quot;&quot;For now, just return 7 characters.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO(jelmer): Add some logic here to return a number of characters that</span>
<span class="gi">+    # scales relative with the size of the repository</span>
<span class="gi">+    return object_id.decode(&quot;ascii&quot;)[:7]</span>


<span class="w"> </span>def describe(repo, abbrev=7):
<span class="gu">@@ -978,7 +2222,64 @@ def describe(repo, abbrev=7):</span>

<span class="w"> </span>    Examples: &quot;gabcdefh&quot;, &quot;v0.1&quot; or &quot;v0.1-5-gabcdefh&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the repository</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        # Get a list of all tags</span>
<span class="gi">+        refs = r.get_refs()</span>
<span class="gi">+        tags = {}</span>
<span class="gi">+        for key, value in refs.items():</span>
<span class="gi">+            key = key.decode()</span>
<span class="gi">+            obj = r.get_object(value)</span>
<span class="gi">+            if &quot;tags&quot; not in key:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            _, tag = key.rsplit(&quot;/&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                commit = obj.object</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                commit = r.get_object(commit[1])</span>
<span class="gi">+            tags[tag] = [</span>
<span class="gi">+                datetime.datetime(*time.gmtime(commit.commit_time)[:6]),</span>
<span class="gi">+                commit.id.decode(&quot;ascii&quot;),</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        sorted_tags = sorted(tags.items(), key=lambda tag: tag[1][0], reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+        # If there are no tags, return the current commit</span>
<span class="gi">+        if len(sorted_tags) == 0:</span>
<span class="gi">+            return f&quot;g{find_unique_abbrev(r.object_store, r[r.head()].id)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # We&#39;re now 0 commits from the top</span>
<span class="gi">+        commit_count = 0</span>
<span class="gi">+</span>
<span class="gi">+        # Get the latest commit</span>
<span class="gi">+        latest_commit = r[r.head()]</span>
<span class="gi">+</span>
<span class="gi">+        # Walk through all commits</span>
<span class="gi">+        walker = r.get_walker()</span>
<span class="gi">+        for entry in walker:</span>
<span class="gi">+            # Check if tag</span>
<span class="gi">+            commit_id = entry.commit.id.decode(&quot;ascii&quot;)</span>
<span class="gi">+            for tag in sorted_tags:</span>
<span class="gi">+                tag_name = tag[0]</span>
<span class="gi">+                tag_commit = tag[1][1]</span>
<span class="gi">+                if commit_id == tag_commit:</span>
<span class="gi">+                    if commit_count == 0:</span>
<span class="gi">+                        return tag_name</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return &quot;{}-{}-g{}&quot;.format(</span>
<span class="gi">+                            tag_name,</span>
<span class="gi">+                            commit_count,</span>
<span class="gi">+                            latest_commit.id.decode(&quot;ascii&quot;)[:abbrev],</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+            commit_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        # Return plain commit if no parent tag can be found</span>
<span class="gi">+        return &quot;g{}&quot;.format(latest_commit.id.decode(&quot;ascii&quot;)[:abbrev])</span>


<span class="w"> </span>def get_object_by_path(repo, path, committish=None):
<span class="gu">@@ -990,7 +2291,16 @@ def get_object_by_path(repo, path, committish=None):</span>
<span class="w"> </span>      committish: Commit to look up path in
<span class="w"> </span>    Returns: A `ShaFile` object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if committish is None:</span>
<span class="gi">+        committish = &quot;HEAD&quot;</span>
<span class="gi">+    # Get the repository</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        commit = parse_commit(r, committish)</span>
<span class="gi">+        base_tree = commit.tree</span>
<span class="gi">+        if not isinstance(path, bytes):</span>
<span class="gi">+            path = commit_encode(commit, path)</span>
<span class="gi">+        (mode, sha) = tree_lookup_path(r.object_store.__getitem__, base_tree, path)</span>
<span class="gi">+        return r[sha]</span>


<span class="w"> </span>def write_tree(repo):
<span class="gu">@@ -1000,4 +2310,5 @@ def write_tree(repo):</span>
<span class="w"> </span>      repo: Repository for which to write tree
<span class="w"> </span>    Returns: tree id for the tree that was written
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open_repo_closing(repo) as r:</span>
<span class="gi">+        return r.open_index().commit(r.object_store)</span>
<span class="gh">diff --git a/dulwich/protocol.py b/dulwich/protocol.py</span>
<span class="gh">index 00409a50..7b489d2e 100644</span>
<span class="gd">--- a/dulwich/protocol.py</span>
<span class="gi">+++ b/dulwich/protocol.py</span>
<span class="gu">@@ -1,62 +1,175 @@</span>
<span class="gi">+# protocol.py -- Shared parts of the git protocols</span>
<span class="gi">+# Copyright (C) 2008 John Carr &lt;john.carr@unrouted.co.uk&gt;</span>
<span class="gi">+# Copyright (C) 2008-2012 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Generic functions for talking the git smart server protocol.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from os import SEEK_END
<span class="gi">+</span>
<span class="w"> </span>import dulwich
<span class="gi">+</span>
<span class="w"> </span>from .errors import GitProtocolError, HangupException
<span class="gi">+</span>
<span class="w"> </span>TCP_GIT_PORT = 9418
<span class="gi">+</span>
<span class="gi">+# Git protocol version 0 is the original Git protocol, which lacked a</span>
<span class="gi">+# version number until Git protocol version 1 was introduced by Brandon</span>
<span class="gi">+# Williams in 2017.</span>
<span class="gi">+#</span>
<span class="gi">+# Protocol version 1 is simply the original v0 protocol with the addition of</span>
<span class="gi">+# a single packet line, which precedes the ref advertisement, indicating the</span>
<span class="gi">+# protocol version being used. This was done in preparation for protocol v2.</span>
<span class="gi">+#</span>
<span class="gi">+# Git protocol version 2 was first introduced by Brandon Williams in 2018 and</span>
<span class="gi">+# adds many features. See the gitprotocol-v2(5) manual page for details.</span>
<span class="gi">+# As of 2024, Git only implements version 2 during &#39;git fetch&#39; and still uses</span>
<span class="gi">+# version 0 during &#39;git push&#39;.</span>
<span class="w"> </span>GIT_PROTOCOL_VERSIONS = [0, 1, 2]
<span class="w"> </span>DEFAULT_GIT_PROTOCOL_VERSION_FETCH = 2
<span class="w"> </span>DEFAULT_GIT_PROTOCOL_VERSION_SEND = 0
<span class="gd">-ZERO_SHA = b&#39;0&#39; * 40</span>
<span class="gi">+</span>
<span class="gi">+ZERO_SHA = b&quot;0&quot; * 40</span>
<span class="gi">+</span>
<span class="w"> </span>SINGLE_ACK = 0
<span class="w"> </span>MULTI_ACK = 1
<span class="w"> </span>MULTI_ACK_DETAILED = 2
<span class="gi">+</span>
<span class="gi">+# pack data</span>
<span class="w"> </span>SIDE_BAND_CHANNEL_DATA = 1
<span class="gi">+# progress messages</span>
<span class="w"> </span>SIDE_BAND_CHANNEL_PROGRESS = 2
<span class="gi">+# fatal error message just before stream aborts</span>
<span class="w"> </span>SIDE_BAND_CHANNEL_FATAL = 3
<span class="gd">-CAPABILITY_ATOMIC = b&#39;atomic&#39;</span>
<span class="gd">-CAPABILITY_DEEPEN_SINCE = b&#39;deepen-since&#39;</span>
<span class="gd">-CAPABILITY_DEEPEN_NOT = b&#39;deepen-not&#39;</span>
<span class="gd">-CAPABILITY_DEEPEN_RELATIVE = b&#39;deepen-relative&#39;</span>
<span class="gd">-CAPABILITY_DELETE_REFS = b&#39;delete-refs&#39;</span>
<span class="gd">-CAPABILITY_INCLUDE_TAG = b&#39;include-tag&#39;</span>
<span class="gd">-CAPABILITY_MULTI_ACK = b&#39;multi_ack&#39;</span>
<span class="gd">-CAPABILITY_MULTI_ACK_DETAILED = b&#39;multi_ack_detailed&#39;</span>
<span class="gd">-CAPABILITY_NO_DONE = b&#39;no-done&#39;</span>
<span class="gd">-CAPABILITY_NO_PROGRESS = b&#39;no-progress&#39;</span>
<span class="gd">-CAPABILITY_OFS_DELTA = b&#39;ofs-delta&#39;</span>
<span class="gd">-CAPABILITY_QUIET = b&#39;quiet&#39;</span>
<span class="gd">-CAPABILITY_REPORT_STATUS = b&#39;report-status&#39;</span>
<span class="gd">-CAPABILITY_SHALLOW = b&#39;shallow&#39;</span>
<span class="gd">-CAPABILITY_SIDE_BAND = b&#39;side-band&#39;</span>
<span class="gd">-CAPABILITY_SIDE_BAND_64K = b&#39;side-band-64k&#39;</span>
<span class="gd">-CAPABILITY_THIN_PACK = b&#39;thin-pack&#39;</span>
<span class="gd">-CAPABILITY_AGENT = b&#39;agent&#39;</span>
<span class="gd">-CAPABILITY_SYMREF = b&#39;symref&#39;</span>
<span class="gd">-CAPABILITY_ALLOW_TIP_SHA1_IN_WANT = b&#39;allow-tip-sha1-in-want&#39;</span>
<span class="gd">-CAPABILITY_ALLOW_REACHABLE_SHA1_IN_WANT = b&#39;allow-reachable-sha1-in-want&#39;</span>
<span class="gd">-CAPABILITY_FETCH = b&#39;fetch&#39;</span>
<span class="gd">-CAPABILITY_FILTER = b&#39;filter&#39;</span>
<span class="gd">-CAPABILITIES_REF = b&#39;capabilities^{}&#39;</span>
<span class="gd">-COMMON_CAPABILITIES = [CAPABILITY_OFS_DELTA, CAPABILITY_SIDE_BAND,</span>
<span class="gd">-    CAPABILITY_SIDE_BAND_64K, CAPABILITY_AGENT, CAPABILITY_NO_PROGRESS]</span>
<span class="gd">-KNOWN_UPLOAD_CAPABILITIES = set([*COMMON_CAPABILITIES, CAPABILITY_THIN_PACK,</span>
<span class="gd">-    CAPABILITY_MULTI_ACK, CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gd">-    CAPABILITY_INCLUDE_TAG, CAPABILITY_DEEPEN_SINCE, CAPABILITY_SYMREF,</span>
<span class="gd">-    CAPABILITY_SHALLOW, CAPABILITY_DEEPEN_NOT, CAPABILITY_DEEPEN_RELATIVE,</span>
<span class="gd">-    CAPABILITY_ALLOW_TIP_SHA1_IN_WANT,</span>
<span class="gd">-    CAPABILITY_ALLOW_REACHABLE_SHA1_IN_WANT, CAPABILITY_FETCH])</span>
<span class="gd">-KNOWN_RECEIVE_CAPABILITIES = set([*COMMON_CAPABILITIES,</span>
<span class="gd">-    CAPABILITY_REPORT_STATUS, CAPABILITY_DELETE_REFS, CAPABILITY_QUIET,</span>
<span class="gd">-    CAPABILITY_ATOMIC])</span>
<span class="gd">-DEPTH_INFINITE = 2147483647</span>
<span class="gd">-NAK_LINE = b&#39;NAK\n&#39;</span>
<span class="gd">-COMMAND_DEEPEN = b&#39;deepen&#39;</span>
<span class="gd">-COMMAND_SHALLOW = b&#39;shallow&#39;</span>
<span class="gd">-COMMAND_UNSHALLOW = b&#39;unshallow&#39;</span>
<span class="gd">-COMMAND_DONE = b&#39;done&#39;</span>
<span class="gd">-COMMAND_WANT = b&#39;want&#39;</span>
<span class="gd">-COMMAND_HAVE = b&#39;have&#39;</span>
<span class="gi">+</span>
<span class="gi">+CAPABILITY_ATOMIC = b&quot;atomic&quot;</span>
<span class="gi">+CAPABILITY_DEEPEN_SINCE = b&quot;deepen-since&quot;</span>
<span class="gi">+CAPABILITY_DEEPEN_NOT = b&quot;deepen-not&quot;</span>
<span class="gi">+CAPABILITY_DEEPEN_RELATIVE = b&quot;deepen-relative&quot;</span>
<span class="gi">+CAPABILITY_DELETE_REFS = b&quot;delete-refs&quot;</span>
<span class="gi">+CAPABILITY_INCLUDE_TAG = b&quot;include-tag&quot;</span>
<span class="gi">+CAPABILITY_MULTI_ACK = b&quot;multi_ack&quot;</span>
<span class="gi">+CAPABILITY_MULTI_ACK_DETAILED = b&quot;multi_ack_detailed&quot;</span>
<span class="gi">+CAPABILITY_NO_DONE = b&quot;no-done&quot;</span>
<span class="gi">+CAPABILITY_NO_PROGRESS = b&quot;no-progress&quot;</span>
<span class="gi">+CAPABILITY_OFS_DELTA = b&quot;ofs-delta&quot;</span>
<span class="gi">+CAPABILITY_QUIET = b&quot;quiet&quot;</span>
<span class="gi">+CAPABILITY_REPORT_STATUS = b&quot;report-status&quot;</span>
<span class="gi">+CAPABILITY_SHALLOW = b&quot;shallow&quot;</span>
<span class="gi">+CAPABILITY_SIDE_BAND = b&quot;side-band&quot;</span>
<span class="gi">+CAPABILITY_SIDE_BAND_64K = b&quot;side-band-64k&quot;</span>
<span class="gi">+CAPABILITY_THIN_PACK = b&quot;thin-pack&quot;</span>
<span class="gi">+CAPABILITY_AGENT = b&quot;agent&quot;</span>
<span class="gi">+CAPABILITY_SYMREF = b&quot;symref&quot;</span>
<span class="gi">+CAPABILITY_ALLOW_TIP_SHA1_IN_WANT = b&quot;allow-tip-sha1-in-want&quot;</span>
<span class="gi">+CAPABILITY_ALLOW_REACHABLE_SHA1_IN_WANT = b&quot;allow-reachable-sha1-in-want&quot;</span>
<span class="gi">+CAPABILITY_FETCH = b&quot;fetch&quot;</span>
<span class="gi">+CAPABILITY_FILTER = b&quot;filter&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Magic ref that is used to attach capabilities to when</span>
<span class="gi">+# there are no refs. Should always be ste to ZERO_SHA.</span>
<span class="gi">+CAPABILITIES_REF = b&quot;capabilities^{}&quot;</span>
<span class="gi">+</span>
<span class="gi">+COMMON_CAPABILITIES = [</span>
<span class="gi">+    CAPABILITY_OFS_DELTA,</span>
<span class="gi">+    CAPABILITY_SIDE_BAND,</span>
<span class="gi">+    CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+    CAPABILITY_AGENT,</span>
<span class="gi">+    CAPABILITY_NO_PROGRESS,</span>
<span class="gi">+]</span>
<span class="gi">+KNOWN_UPLOAD_CAPABILITIES = set(</span>
<span class="gi">+    [</span>
<span class="gi">+        *COMMON_CAPABILITIES,</span>
<span class="gi">+        CAPABILITY_THIN_PACK,</span>
<span class="gi">+        CAPABILITY_MULTI_ACK,</span>
<span class="gi">+        CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gi">+        CAPABILITY_INCLUDE_TAG,</span>
<span class="gi">+        CAPABILITY_DEEPEN_SINCE,</span>
<span class="gi">+        CAPABILITY_SYMREF,</span>
<span class="gi">+        CAPABILITY_SHALLOW,</span>
<span class="gi">+        CAPABILITY_DEEPEN_NOT,</span>
<span class="gi">+        CAPABILITY_DEEPEN_RELATIVE,</span>
<span class="gi">+        CAPABILITY_ALLOW_TIP_SHA1_IN_WANT,</span>
<span class="gi">+        CAPABILITY_ALLOW_REACHABLE_SHA1_IN_WANT,</span>
<span class="gi">+        CAPABILITY_FETCH,</span>
<span class="gi">+    ]</span>
<span class="gi">+)</span>
<span class="gi">+KNOWN_RECEIVE_CAPABILITIES = set(</span>
<span class="gi">+    [</span>
<span class="gi">+        *COMMON_CAPABILITIES,</span>
<span class="gi">+        CAPABILITY_REPORT_STATUS,</span>
<span class="gi">+        CAPABILITY_DELETE_REFS,</span>
<span class="gi">+        CAPABILITY_QUIET,</span>
<span class="gi">+        CAPABILITY_ATOMIC,</span>
<span class="gi">+    ]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+DEPTH_INFINITE = 0x7FFFFFFF</span>
<span class="gi">+</span>
<span class="gi">+NAK_LINE = b&quot;NAK\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def agent_string():</span>
<span class="gi">+    return (&quot;dulwich/&quot; + &quot;.&quot;.join(map(str, dulwich.__version__))).encode(&quot;ascii&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def capability_agent():</span>
<span class="gi">+    return CAPABILITY_AGENT + b&quot;=&quot; + agent_string()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def capability_symref(from_ref, to_ref):</span>
<span class="gi">+    return CAPABILITY_SYMREF + b&quot;=&quot; + from_ref + b&quot;:&quot; + to_ref</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_capability_names(capabilities):</span>
<span class="gi">+    return {parse_capability(c)[0] for c in capabilities}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_capability(capability):</span>
<span class="gi">+    parts = capability.split(b&quot;=&quot;, 1)</span>
<span class="gi">+    if len(parts) == 1:</span>
<span class="gi">+        return (parts[0], None)</span>
<span class="gi">+    return tuple(parts)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def symref_capabilities(symrefs):</span>
<span class="gi">+    return [capability_symref(*k) for k in symrefs]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+COMMAND_DEEPEN = b&quot;deepen&quot;</span>
<span class="gi">+COMMAND_SHALLOW = b&quot;shallow&quot;</span>
<span class="gi">+COMMAND_UNSHALLOW = b&quot;unshallow&quot;</span>
<span class="gi">+COMMAND_DONE = b&quot;done&quot;</span>
<span class="gi">+COMMAND_WANT = b&quot;want&quot;</span>
<span class="gi">+COMMAND_HAVE = b&quot;have&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_cmd_pkt(cmd, *args):</span>
<span class="gi">+    return cmd + b&quot; &quot; + b&quot;&quot;.join([(a + b&quot;\0&quot;) for a in args])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_cmd_pkt(line):</span>
<span class="gi">+    splice_at = line.find(b&quot; &quot;)</span>
<span class="gi">+    cmd, args = line[:splice_at], line[splice_at + 1 :]</span>
<span class="gi">+    assert args[-1:] == b&quot;\x00&quot;</span>
<span class="gi">+    return cmd, args[:-1].split(b&quot;\0&quot;)</span>


<span class="w"> </span>def pkt_line(data):
<span class="gu">@@ -67,7 +180,9 @@ def pkt_line(data):</span>
<span class="w"> </span>    Returns: The data prefixed with its length in pkt-line format; if data was
<span class="w"> </span>        None, returns the flush-pkt (&#39;0000&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        return b&quot;0000&quot;</span>
<span class="gi">+    return (&quot;%04x&quot; % (len(data) + 4)).encode(&quot;ascii&quot;) + data</span>


<span class="w"> </span>class Protocol:
<span class="gu">@@ -82,13 +197,17 @@ class Protocol:</span>
<span class="w"> </span>        Documentation/technical/protocol-common.txt
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, read, write, close=None, report_activity=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, read, write, close=None, report_activity=None) -&gt; None:</span>
<span class="w"> </span>        self.read = read
<span class="w"> </span>        self.write = write
<span class="w"> </span>        self._close = close
<span class="w"> </span>        self.report_activity = report_activity
<span class="w"> </span>        self._readahead = None

<span class="gi">+    def close(self):</span>
<span class="gi">+        if self._close:</span>
<span class="gi">+            self._close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="gu">@@ -103,7 +222,34 @@ class Protocol:</span>
<span class="w"> </span>        Returns: The next string from the stream, without the length prefix, or
<span class="w"> </span>            None for a flush-pkt (&#39;0000&#39;) or delim-pkt (&#39;0001&#39;).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._readahead is None:</span>
<span class="gi">+            read = self.read</span>
<span class="gi">+        else:</span>
<span class="gi">+            read = self._readahead.read</span>
<span class="gi">+            self._readahead = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            sizestr = read(4)</span>
<span class="gi">+            if not sizestr:</span>
<span class="gi">+                raise HangupException</span>
<span class="gi">+            size = int(sizestr, 16)</span>
<span class="gi">+            if size == 0 or size == 1:  # flush-pkt or delim-pkt</span>
<span class="gi">+                if self.report_activity:</span>
<span class="gi">+                    self.report_activity(4, &quot;read&quot;)</span>
<span class="gi">+                return None</span>
<span class="gi">+            if self.report_activity:</span>
<span class="gi">+                self.report_activity(size, &quot;read&quot;)</span>
<span class="gi">+            pkt_contents = read(size - 4)</span>
<span class="gi">+        except ConnectionResetError as exc:</span>
<span class="gi">+            raise HangupException from exc</span>
<span class="gi">+        except OSError as exc:</span>
<span class="gi">+            raise GitProtocolError(str(exc)) from exc</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(pkt_contents) + 4 != size:</span>
<span class="gi">+                raise GitProtocolError(</span>
<span class="gi">+                    f&quot;Length of pkt read {len(pkt_contents) + 4:04x} does not match length prefix {size:04x}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            return pkt_contents</span>

<span class="w"> </span>    def eof(self):
<span class="w"> </span>        &quot;&quot;&quot;Test whether the protocol stream has reached EOF.
<span class="gu">@@ -113,7 +259,12 @@ class Protocol:</span>

<span class="w"> </span>        Returns: True if the stream is at EOF, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            next_line = self.read_pkt_line()</span>
<span class="gi">+        except HangupException:</span>
<span class="gi">+            return True</span>
<span class="gi">+        self.unread_pkt_line(next_line)</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def unread_pkt_line(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Unread a single line of data into the readahead buffer.
<span class="gu">@@ -127,7 +278,9 @@ class Protocol:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          ValueError: If more than one pkt-line is unread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._readahead is not None:</span>
<span class="gi">+            raise ValueError(&quot;Attempted to unread multiple pkt-lines.&quot;)</span>
<span class="gi">+        self._readahead = BytesIO(pkt_line(data))</span>

<span class="w"> </span>    def read_pkt_seq(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a sequence of pkt-lines from the remote git process.
<span class="gu">@@ -135,7 +288,10 @@ class Protocol:</span>
<span class="w"> </span>        Returns: Yields each line of data up to but not including the next
<span class="w"> </span>            flush-pkt.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pkt = self.read_pkt_line()</span>
<span class="gi">+        while pkt:</span>
<span class="gi">+            yield pkt</span>
<span class="gi">+            pkt = self.read_pkt_line()</span>

<span class="w"> </span>    def write_pkt_line(self, line):
<span class="w"> </span>        &quot;&quot;&quot;Sends a pkt-line to the remote git process.
<span class="gu">@@ -144,7 +300,13 @@ class Protocol:</span>
<span class="w"> </span>          line: A string containing the data to send, without the length
<span class="w"> </span>            prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            line = pkt_line(line)</span>
<span class="gi">+            self.write(line)</span>
<span class="gi">+            if self.report_activity:</span>
<span class="gi">+                self.report_activity(len(line), &quot;write&quot;)</span>
<span class="gi">+        except OSError as exc:</span>
<span class="gi">+            raise GitProtocolError(str(exc)) from exc</span>

<span class="w"> </span>    def write_sideband(self, channel, blob):
<span class="w"> </span>        &quot;&quot;&quot;Write multiplexed data to the sideband.
<span class="gu">@@ -153,7 +315,12 @@ class Protocol:</span>
<span class="w"> </span>          channel: An int specifying the channel to write to.
<span class="w"> </span>          blob: A blob of data (as a string) to send on this channel.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # a pktline can be a max of 65520. a sideband line can therefore be</span>
<span class="gi">+        # 65520-5 = 65515</span>
<span class="gi">+        # WTF: Why have the len in ASCII, but the channel in binary.</span>
<span class="gi">+        while blob:</span>
<span class="gi">+            self.write_pkt_line(bytes(bytearray([channel])) + blob[:65515])</span>
<span class="gi">+            blob = blob[65515:]</span>

<span class="w"> </span>    def send_cmd(self, cmd, *args):
<span class="w"> </span>        &quot;&quot;&quot;Send a command and some arguments to a git server.
<span class="gu">@@ -164,7 +331,7 @@ class Protocol:</span>
<span class="w"> </span>          cmd: The remote service to access.
<span class="w"> </span>          args: List of arguments to send to remove service.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_pkt_line(format_cmd_pkt(cmd, *args))</span>

<span class="w"> </span>    def read_cmd(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a command and some arguments from the git client.
<span class="gu">@@ -173,10 +340,11 @@ class Protocol:</span>

<span class="w"> </span>        Returns: A tuple of (command, [list of arguments]).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line = self.read_pkt_line()</span>
<span class="gi">+        return parse_cmd_pkt(line)</span>


<span class="gd">-_RBUFSIZE = 8192</span>
<span class="gi">+_RBUFSIZE = 8192  # Default read buffer size.</span>


<span class="w"> </span>class ReceivableProtocol(Protocol):
<span class="gu">@@ -191,14 +359,98 @@ class ReceivableProtocol(Protocol):</span>
<span class="w"> </span>    will still block until at least one byte is read.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, recv, write, close=None, report_activity=None,</span>
<span class="gd">-        rbufsize=_RBUFSIZE) -&gt;None:</span>
<span class="gd">-        super().__init__(self.read, write, close=close, report_activity=</span>
<span class="gd">-            report_activity)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, recv, write, close=None, report_activity=None, rbufsize=_RBUFSIZE</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(self.read, write, close=close, report_activity=report_activity)</span>
<span class="w"> </span>        self._recv = recv
<span class="w"> </span>        self._rbuf = BytesIO()
<span class="w"> </span>        self._rbufsize = rbufsize

<span class="gi">+    def read(self, size):</span>
<span class="gi">+        # From _fileobj.read in socket.py in the Python 2.6.5 standard library,</span>
<span class="gi">+        # with the following modifications:</span>
<span class="gi">+        #  - omit the size &lt;= 0 branch</span>
<span class="gi">+        #  - seek back to start rather than 0 in case some buffer has been</span>
<span class="gi">+        #    consumed.</span>
<span class="gi">+        #  - use SEEK_END instead of the magic number.</span>
<span class="gi">+        # Copyright (c) 2001-2010 Python Software Foundation; All Rights</span>
<span class="gi">+        # Reserved</span>
<span class="gi">+        # Licensed under the Python Software Foundation License.</span>
<span class="gi">+        # TODO: see if buffer is more efficient than cBytesIO.</span>
<span class="gi">+        assert size &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        # Our use of BytesIO rather than lists of string objects returned by</span>
<span class="gi">+        # recv() minimizes memory usage and fragmentation that occurs when</span>
<span class="gi">+        # rbufsize is large compared to the typical return value of recv().</span>
<span class="gi">+        buf = self._rbuf</span>
<span class="gi">+        start = buf.tell()</span>
<span class="gi">+        buf.seek(0, SEEK_END)</span>
<span class="gi">+        # buffer may have been partially consumed by recv()</span>
<span class="gi">+        buf_len = buf.tell() - start</span>
<span class="gi">+        if buf_len &gt;= size:</span>
<span class="gi">+            # Already have size bytes in our buffer?  Extract and return.</span>
<span class="gi">+            buf.seek(start)</span>
<span class="gi">+            rv = buf.read(size)</span>
<span class="gi">+            self._rbuf = BytesIO()</span>
<span class="gi">+            self._rbuf.write(buf.read())</span>
<span class="gi">+            self._rbuf.seek(0)</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        self._rbuf = BytesIO()  # reset _rbuf.  we consume it via buf.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            left = size - buf_len</span>
<span class="gi">+            # recv() will malloc the amount of memory given as its</span>
<span class="gi">+            # parameter even though it often returns much less data</span>
<span class="gi">+            # than that.  The returned data string is short lived</span>
<span class="gi">+            # as we copy it into a BytesIO and free it.  This avoids</span>
<span class="gi">+            # fragmentation issues on many platforms.</span>
<span class="gi">+            data = self._recv(left)</span>
<span class="gi">+            if not data:</span>
<span class="gi">+                break</span>
<span class="gi">+            n = len(data)</span>
<span class="gi">+            if n == size and not buf_len:</span>
<span class="gi">+                # Shortcut.  Avoid buffer data copies when:</span>
<span class="gi">+                # - We have no data in our buffer.</span>
<span class="gi">+                # AND</span>
<span class="gi">+                # - Our call to recv returned exactly the</span>
<span class="gi">+                #   number of bytes we were asked to read.</span>
<span class="gi">+                return data</span>
<span class="gi">+            if n == left:</span>
<span class="gi">+                buf.write(data)</span>
<span class="gi">+                del data  # explicit free</span>
<span class="gi">+                break</span>
<span class="gi">+            assert n &lt;= left, &quot;_recv(%d) returned %d bytes&quot; % (left, n)</span>
<span class="gi">+            buf.write(data)</span>
<span class="gi">+            buf_len += n</span>
<span class="gi">+            del data  # explicit free</span>
<span class="gi">+            # assert buf_len == buf.tell()</span>
<span class="gi">+        buf.seek(start)</span>
<span class="gi">+        return buf.read()</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, size):</span>
<span class="gi">+        assert size &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        buf = self._rbuf</span>
<span class="gi">+        start = buf.tell()</span>
<span class="gi">+        buf.seek(0, SEEK_END)</span>
<span class="gi">+        buf_len = buf.tell()</span>
<span class="gi">+        buf.seek(start)</span>
<span class="gi">+</span>
<span class="gi">+        left = buf_len - start</span>
<span class="gi">+        if not left:</span>
<span class="gi">+            # only read from the wire if our read buffer is exhausted</span>
<span class="gi">+            data = self._recv(self._rbufsize)</span>
<span class="gi">+            if len(data) == size:</span>
<span class="gi">+                # shortcut: skip the buffer if we read exactly size bytes</span>
<span class="gi">+                return data</span>
<span class="gi">+            buf = BytesIO()</span>
<span class="gi">+            buf.write(data)</span>
<span class="gi">+            buf.seek(0)</span>
<span class="gi">+            del data  # explicit free</span>
<span class="gi">+            self._rbuf = buf</span>
<span class="gi">+        return buf.read(size)</span>
<span class="gi">+</span>

<span class="w"> </span>def extract_capabilities(text):
<span class="w"> </span>    &quot;&quot;&quot;Extract a capabilities list from a string, if present.
<span class="gu">@@ -207,7 +459,10 @@ def extract_capabilities(text):</span>
<span class="w"> </span>      text: String to extract from
<span class="w"> </span>    Returns: Tuple with text with capabilities removed and list of capabilities
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if b&quot;\0&quot; not in text:</span>
<span class="gi">+        return text, []</span>
<span class="gi">+    text, capabilities = text.rstrip().split(b&quot;\0&quot;)</span>
<span class="gi">+    return (text, capabilities.strip().split(b&quot; &quot;))</span>


<span class="w"> </span>def extract_want_line_capabilities(text):
<span class="gu">@@ -222,12 +477,19 @@ def extract_want_line_capabilities(text):</span>
<span class="w"> </span>      text: Want line to extract from
<span class="w"> </span>    Returns: Tuple with text with capabilities removed and list of capabilities
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    split_text = text.rstrip().split(b&quot; &quot;)</span>
<span class="gi">+    if len(split_text) &lt; 3:</span>
<span class="gi">+        return text, []</span>
<span class="gi">+    return (b&quot; &quot;.join(split_text[:2]), split_text[2:])</span>


<span class="w"> </span>def ack_type(capabilities):
<span class="w"> </span>    &quot;&quot;&quot;Extract the ack type from a capabilities list.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if b&quot;multi_ack_detailed&quot; in capabilities:</span>
<span class="gi">+        return MULTI_ACK_DETAILED</span>
<span class="gi">+    elif b&quot;multi_ack&quot; in capabilities:</span>
<span class="gi">+        return MULTI_ACK</span>
<span class="gi">+    return SINGLE_ACK</span>


<span class="w"> </span>class BufferedPktLineWriter:
<span class="gu">@@ -238,7 +500,7 @@ class BufferedPktLineWriter:</span>
<span class="w"> </span>    (including length prefix) reach the buffer size.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, write, bufsize=65515) -&gt;None:</span>
<span class="gi">+    def __init__(self, write, bufsize=65515) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the BufferedPktLineWriter.

<span class="w"> </span>        Args:
<span class="gu">@@ -252,24 +514,79 @@ class BufferedPktLineWriter:</span>

<span class="w"> </span>    def write(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Write data, wrapping it in a pkt-line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line = pkt_line(data)</span>
<span class="gi">+        line_len = len(line)</span>
<span class="gi">+        over = self._buflen + line_len - self._bufsize</span>
<span class="gi">+        if over &gt;= 0:</span>
<span class="gi">+            start = line_len - over</span>
<span class="gi">+            self._wbuf.write(line[:start])</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = 0</span>
<span class="gi">+        saved = line[start:]</span>
<span class="gi">+        self._wbuf.write(saved)</span>
<span class="gi">+        self._buflen += len(saved)</span>

<span class="w"> </span>    def flush(self):
<span class="w"> </span>        &quot;&quot;&quot;Flush all data from the buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self._wbuf.getvalue()</span>
<span class="gi">+        if data:</span>
<span class="gi">+            self._write(data)</span>
<span class="gi">+        self._len = 0</span>
<span class="gi">+        self._wbuf = BytesIO()</span>


<span class="w"> </span>class PktLineParser:
<span class="w"> </span>    &quot;&quot;&quot;Packet line parser that hands completed packets off to a callback.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, handle_pkt) -&gt;None:</span>
<span class="gi">+    def __init__(self, handle_pkt) -&gt; None:</span>
<span class="w"> </span>        self.handle_pkt = handle_pkt
<span class="w"> </span>        self._readahead = BytesIO()

<span class="w"> </span>    def parse(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Parse a fragment of data and call back for any completed packets.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._readahead.write(data)</span>
<span class="gi">+        buf = self._readahead.getvalue()</span>
<span class="gi">+        if len(buf) &lt; 4:</span>
<span class="gi">+            return</span>
<span class="gi">+        while len(buf) &gt;= 4:</span>
<span class="gi">+            size = int(buf[:4], 16)</span>
<span class="gi">+            if size == 0:</span>
<span class="gi">+                self.handle_pkt(None)</span>
<span class="gi">+                buf = buf[4:]</span>
<span class="gi">+            elif size &lt;= len(buf):</span>
<span class="gi">+                self.handle_pkt(buf[4:size])</span>
<span class="gi">+                buf = buf[size:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        self._readahead = BytesIO()</span>
<span class="gi">+        self._readahead.write(buf)</span>

<span class="w"> </span>    def get_tail(self):
<span class="w"> </span>        &quot;&quot;&quot;Read back any unused data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._readahead.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_capability_line(capabilities):</span>
<span class="gi">+    return b&quot;&quot;.join([b&quot; &quot; + c for c in capabilities])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_ref_line(ref, sha, capabilities=None):</span>
<span class="gi">+    if capabilities is None:</span>
<span class="gi">+        return sha + b&quot; &quot; + ref + b&quot;\n&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return sha + b&quot; &quot; + ref + b&quot;\0&quot; + format_capability_line(capabilities) + b&quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_shallow_line(sha):</span>
<span class="gi">+    return COMMAND_SHALLOW + b&quot; &quot; + sha</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_unshallow_line(sha):</span>
<span class="gi">+    return COMMAND_UNSHALLOW + b&quot; &quot; + sha</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_ack_line(sha, ack_type=b&quot;&quot;):</span>
<span class="gi">+    if ack_type:</span>
<span class="gi">+        ack_type = b&quot; &quot; + ack_type</span>
<span class="gi">+    return b&quot;ACK &quot; + sha + ack_type + b&quot;\n&quot;</span>
<span class="gh">diff --git a/dulwich/reflog.py b/dulwich/reflog.py</span>
<span class="gh">index eb9fc2f8..9bea4485 100644</span>
<span class="gd">--- a/dulwich/reflog.py</span>
<span class="gi">+++ b/dulwich/reflog.py</span>
<span class="gu">@@ -1,12 +1,36 @@</span>
<span class="gi">+# reflog.py -- Parsing and writing reflog files</span>
<span class="gi">+# Copyright (C) 2015 Jelmer Vernooij and others.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for reading and generating reflogs.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="gi">+</span>
<span class="w"> </span>from .objects import ZERO_SHA, format_timezone, parse_timezone
<span class="gd">-Entry = collections.namedtuple(&#39;Entry&#39;, [&#39;old_sha&#39;, &#39;new_sha&#39;, &#39;committer&#39;,</span>
<span class="gd">-    &#39;timestamp&#39;, &#39;timezone&#39;, &#39;message&#39;])</span>

<span class="gi">+Entry = collections.namedtuple(</span>
<span class="gi">+    &quot;Entry&quot;,</span>
<span class="gi">+    [&quot;old_sha&quot;, &quot;new_sha&quot;, &quot;committer&quot;, &quot;timestamp&quot;, &quot;timezone&quot;, &quot;message&quot;],</span>
<span class="gi">+)</span>

<span class="gd">-def format_reflog_line(old_sha, new_sha, committer, timestamp, timezone,</span>
<span class="gd">-    message):</span>
<span class="gi">+</span>
<span class="gi">+def format_reflog_line(old_sha, new_sha, committer, timestamp, timezone, message):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a single reflog line.

<span class="w"> </span>    Args:
<span class="gu">@@ -17,7 +41,21 @@ def format_reflog_line(old_sha, new_sha, committer, timestamp, timezone,</span>
<span class="w"> </span>      timezone: Timezone
<span class="w"> </span>      message: Message
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if old_sha is None:</span>
<span class="gi">+        old_sha = ZERO_SHA</span>
<span class="gi">+    return (</span>
<span class="gi">+        old_sha</span>
<span class="gi">+        + b&quot; &quot;</span>
<span class="gi">+        + new_sha</span>
<span class="gi">+        + b&quot; &quot;</span>
<span class="gi">+        + committer</span>
<span class="gi">+        + b&quot; &quot;</span>
<span class="gi">+        + str(int(timestamp)).encode(&quot;ascii&quot;)</span>
<span class="gi">+        + b&quot; &quot;</span>
<span class="gi">+        + format_timezone(timezone)</span>
<span class="gi">+        + b&quot;\t&quot;</span>
<span class="gi">+        + message</span>
<span class="gi">+    )</span>


<span class="w"> </span>def parse_reflog_line(line):
<span class="gu">@@ -28,7 +66,17 @@ def parse_reflog_line(line):</span>
<span class="w"> </span>    Returns: Tuple of (old_sha, new_sha, committer, timestamp, timezone,
<span class="w"> </span>        message)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (begin, message) = line.split(b&quot;\t&quot;, 1)</span>
<span class="gi">+    (old_sha, new_sha, rest) = begin.split(b&quot; &quot;, 2)</span>
<span class="gi">+    (committer, timestamp_str, timezone_str) = rest.rsplit(b&quot; &quot;, 2)</span>
<span class="gi">+    return Entry(</span>
<span class="gi">+        old_sha,</span>
<span class="gi">+        new_sha,</span>
<span class="gi">+        committer,</span>
<span class="gi">+        int(timestamp_str),</span>
<span class="gi">+        parse_timezone(timezone_str)[0],</span>
<span class="gi">+        message,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def read_reflog(f):
<span class="gu">@@ -38,7 +86,8 @@ def read_reflog(f):</span>
<span class="w"> </span>      f: File-like object
<span class="w"> </span>    Returns: Iterator over Entry objects
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        yield parse_reflog_line(line)</span>


<span class="w"> </span>def drop_reflog_entry(f, index, rewrite=False):
<span class="gu">@@ -50,4 +99,51 @@ def drop_reflog_entry(f, index, rewrite=False):</span>
<span class="w"> </span>        rewrite: If a reflog entry&#39;s predecessor is removed, set its
<span class="w"> </span>            old SHA to the new SHA of the entry that now precedes it
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if index &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;Invalid reflog index %d&quot; % index)</span>
<span class="gi">+</span>
<span class="gi">+    log = []</span>
<span class="gi">+    offset = f.tell()</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        log.append((offset, parse_reflog_line(line)))</span>
<span class="gi">+        offset = f.tell()</span>
<span class="gi">+</span>
<span class="gi">+    inverse_index = len(log) - index - 1</span>
<span class="gi">+    write_offset = log[inverse_index][0]</span>
<span class="gi">+    f.seek(write_offset)</span>
<span class="gi">+</span>
<span class="gi">+    if index == 0:</span>
<span class="gi">+        f.truncate()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    del log[inverse_index]</span>
<span class="gi">+    if rewrite and index &gt; 0 and log:</span>
<span class="gi">+        if inverse_index == 0:</span>
<span class="gi">+            previous_new = ZERO_SHA</span>
<span class="gi">+        else:</span>
<span class="gi">+            previous_new = log[inverse_index - 1][1].new_sha</span>
<span class="gi">+        offset, entry = log[inverse_index]</span>
<span class="gi">+        log[inverse_index] = (</span>
<span class="gi">+            offset,</span>
<span class="gi">+            Entry(</span>
<span class="gi">+                previous_new,</span>
<span class="gi">+                entry.new_sha,</span>
<span class="gi">+                entry.committer,</span>
<span class="gi">+                entry.timestamp,</span>
<span class="gi">+                entry.timezone,</span>
<span class="gi">+                entry.message,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    for _, entry in log[inverse_index:]:</span>
<span class="gi">+        f.write(</span>
<span class="gi">+            format_reflog_line(</span>
<span class="gi">+                entry.old_sha,</span>
<span class="gi">+                entry.new_sha,</span>
<span class="gi">+                entry.committer,</span>
<span class="gi">+                entry.timestamp,</span>
<span class="gi">+                entry.timezone,</span>
<span class="gi">+                entry.message,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    f.truncate()</span>
<span class="gh">diff --git a/dulwich/refs.py b/dulwich/refs.py</span>
<span class="gh">index 3cbaa3f6..f9eb7999 100644</span>
<span class="gd">--- a/dulwich/refs.py</span>
<span class="gi">+++ b/dulwich/refs.py</span>
<span class="gu">@@ -1,27 +1,54 @@</span>
<span class="gi">+# refs.py -- For dealing with git refs</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Ref handling.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import warnings
<span class="w"> </span>from contextlib import suppress
<span class="w"> </span>from typing import Any, Dict, Optional, Set
<span class="gi">+</span>
<span class="w"> </span>from .errors import PackedRefsException, RefFormatError
<span class="w"> </span>from .file import GitFile, ensure_dir_exists
<span class="w"> </span>from .objects import ZERO_SHA, ObjectID, Tag, git_line, valid_hexsha
<span class="w"> </span>from .pack import ObjectContainer
<span class="gi">+</span>
<span class="w"> </span>Ref = bytes
<span class="gd">-HEADREF = b&#39;HEAD&#39;</span>
<span class="gd">-SYMREF = b&#39;ref: &#39;</span>
<span class="gd">-LOCAL_BRANCH_PREFIX = b&#39;refs/heads/&#39;</span>
<span class="gd">-LOCAL_TAG_PREFIX = b&#39;refs/tags/&#39;</span>
<span class="gd">-LOCAL_REMOTE_PREFIX = b&#39;refs/remotes/&#39;</span>
<span class="gd">-BAD_REF_CHARS = set(b&#39;\x7f ~^:?*[&#39;)</span>
<span class="gd">-PEELED_TAG_SUFFIX = b&#39;^{}&#39;</span>
<span class="gi">+</span>
<span class="gi">+HEADREF = b&quot;HEAD&quot;</span>
<span class="gi">+SYMREF = b&quot;ref: &quot;</span>
<span class="gi">+LOCAL_BRANCH_PREFIX = b&quot;refs/heads/&quot;</span>
<span class="gi">+LOCAL_TAG_PREFIX = b&quot;refs/tags/&quot;</span>
<span class="gi">+LOCAL_REMOTE_PREFIX = b&quot;refs/remotes/&quot;</span>
<span class="gi">+BAD_REF_CHARS = set(b&quot;\177 ~^:?*[&quot;)</span>
<span class="gi">+PEELED_TAG_SUFFIX = b&quot;^{}&quot;</span>
<span class="gi">+</span>
<span class="gi">+# For backwards compatibility</span>
<span class="w"> </span>ANNOTATED_TAG_SUFFIX = PEELED_TAG_SUFFIX


<span class="w"> </span>class SymrefLoop(Exception):
<span class="w"> </span>    &quot;&quot;&quot;There is a loop between one or more symrefs.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, ref, depth) -&gt;None:</span>
<span class="gi">+    def __init__(self, ref, depth) -&gt; None:</span>
<span class="w"> </span>        self.ref = ref
<span class="w"> </span>        self.depth = depth

<span class="gu">@@ -33,7 +60,9 @@ def parse_symref_value(contents):</span>
<span class="w"> </span>      contents: Contents to parse
<span class="w"> </span>    Returns: Destination
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if contents.startswith(SYMREF):</span>
<span class="gi">+        return contents[len(SYMREF) :].rstrip(b&quot;\r\n&quot;)</span>
<span class="gi">+    raise ValueError(contents)</span>


<span class="w"> </span>def check_ref_format(refname: Ref):
<span class="gu">@@ -48,17 +77,59 @@ def check_ref_format(refname: Ref):</span>
<span class="w"> </span>      refname: The refname to check
<span class="w"> </span>    Returns: True if refname is valid, False otherwise
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # These could be combined into one big expression, but are listed</span>
<span class="gi">+    # separately to parallel [1].</span>
<span class="gi">+    if b&quot;/.&quot; in refname or refname.startswith(b&quot;.&quot;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if b&quot;/&quot; not in refname:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if b&quot;..&quot; in refname:</span>
<span class="gi">+        return False</span>
<span class="gi">+    for i, c in enumerate(refname):</span>
<span class="gi">+        if ord(refname[i : i + 1]) &lt; 0o40 or c in BAD_REF_CHARS:</span>
<span class="gi">+            return False</span>
<span class="gi">+    if refname[-1] in b&quot;/.&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if refname.endswith(b&quot;.lock&quot;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if b&quot;@{&quot; in refname:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if b&quot;\\&quot; in refname:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class RefsContainer:
<span class="w"> </span>    &quot;&quot;&quot;A container for refs.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, logger=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, logger=None) -&gt; None:</span>
<span class="w"> </span>        self._logger = logger

<span class="gd">-    def set_symbolic_ref(self, name, other, committer=None, timestamp=None,</span>
<span class="gd">-        timezone=None, message=None):</span>
<span class="gi">+    def _log(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ref,</span>
<span class="gi">+        old_sha,</span>
<span class="gi">+        new_sha,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if self._logger is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        if message is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._logger(ref, old_sha, new_sha, committer, timestamp, timezone, message)</span>
<span class="gi">+</span>
<span class="gi">+    def set_symbolic_ref(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        other,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Make a ref point at another ref.

<span class="w"> </span>        Args:
<span class="gu">@@ -66,7 +137,7 @@ class RefsContainer:</span>
<span class="w"> </span>          other: Name of the ref to point at
<span class="w"> </span>          message: Optional message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.set_symbolic_ref)</span>

<span class="w"> </span>    def get_packed_refs(self):
<span class="w"> </span>        &quot;&quot;&quot;Get contents of the packed-refs file.
<span class="gu">@@ -76,7 +147,7 @@ class RefsContainer:</span>
<span class="w"> </span>        Note: Will return an empty dictionary when no packed-refs file is
<span class="w"> </span>            present.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_packed_refs)</span>

<span class="w"> </span>    def add_packed_refs(self, new_refs: Dict[Ref, Optional[ObjectID]]):
<span class="w"> </span>        &quot;&quot;&quot;Add the given refs as packed refs.
<span class="gu">@@ -85,7 +156,7 @@ class RefsContainer:</span>
<span class="w"> </span>          new_refs: A mapping of ref names to targets; if a target is None that
<span class="w"> </span>            means remove the ref
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.add_packed_refs)</span>

<span class="w"> </span>    def get_peeled(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Return the cached peeled value of a ref, if available.
<span class="gu">@@ -96,11 +167,40 @@ class RefsContainer:</span>
<span class="w"> </span>            a tag, this will be the SHA the ref refers to. If the ref may point
<span class="w"> </span>            to a tag, but no cached information is available, None is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def import_refs(</span>
<span class="gi">+        self,</span>
<span class="gi">+        base: Ref,</span>
<span class="gi">+        other: Dict[Ref, ObjectID],</span>
<span class="gi">+        committer: Optional[bytes] = None,</span>
<span class="gi">+        timestamp: Optional[bytes] = None,</span>
<span class="gi">+        timezone: Optional[bytes] = None,</span>
<span class="gi">+        message: Optional[bytes] = None,</span>
<span class="gi">+        prune: bool = False,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if prune:</span>
<span class="gi">+            to_delete = set(self.subkeys(base))</span>
<span class="gi">+        else:</span>
<span class="gi">+            to_delete = set()</span>
<span class="gi">+        for name, value in other.items():</span>
<span class="gi">+            if value is None:</span>
<span class="gi">+                to_delete.add(name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.set_if_equals(</span>
<span class="gi">+                    b&quot;/&quot;.join((base, name)), None, value, message=message</span>
<span class="gi">+                )</span>
<span class="gi">+            if to_delete:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    to_delete.remove(name)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        for ref in to_delete:</span>
<span class="gi">+            self.remove_if_equals(b&quot;/&quot;.join((base, ref)), None, message=message)</span>

<span class="w"> </span>    def allkeys(self):
<span class="w"> </span>        &quot;&quot;&quot;All refs present in this container.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.allkeys)</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter(self.allkeys())
<span class="gu">@@ -113,7 +213,10 @@ class RefsContainer:</span>
<span class="w"> </span>        Returns: An unsorted set of valid refs in this container, including
<span class="w"> </span>            packed refs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if base is not None:</span>
<span class="gi">+            return self.subkeys(base)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.allkeys()</span>

<span class="w"> </span>    def subkeys(self, base):
<span class="w"> </span>        &quot;&quot;&quot;Refs present in this container under a base.
<span class="gu">@@ -123,11 +226,28 @@ class RefsContainer:</span>
<span class="w"> </span>        Returns: A set of valid refs in this container under the base; the base
<span class="w"> </span>            prefix is stripped from the ref names returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        base_len = len(base) + 1</span>
<span class="gi">+        for refname in self.allkeys():</span>
<span class="gi">+            if refname.startswith(base):</span>
<span class="gi">+                keys.add(refname[base_len:])</span>
<span class="gi">+        return keys</span>

<span class="w"> </span>    def as_dict(self, base=None):
<span class="w"> </span>        &quot;&quot;&quot;Return the contents of this container as a dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = {}</span>
<span class="gi">+        keys = self.keys(base)</span>
<span class="gi">+        if base is None:</span>
<span class="gi">+            base = b&quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            base = base.rstrip(b&quot;/&quot;)</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ret[key] = self[(base + b&quot;/&quot; + key).strip(b&quot;/&quot;)]</span>
<span class="gi">+            except (SymrefLoop, KeyError):</span>
<span class="gi">+                continue  # Unable to resolve</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def _check_refname(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Ensure a refname is valid and lives in refs or is HEAD.
<span class="gu">@@ -143,7 +263,10 @@ class RefsContainer:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          KeyError: if a refname is not HEAD or is otherwise not valid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name in (HEADREF, b&quot;refs/stash&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not name.startswith(b&quot;refs/&quot;) or not check_ref_format(name[5:]):</span>
<span class="gi">+            raise RefFormatError(name)</span>

<span class="w"> </span>    def read_ref(self, refname):
<span class="w"> </span>        &quot;&quot;&quot;Read a reference without following any references.
<span class="gu">@@ -153,7 +276,10 @@ class RefsContainer:</span>
<span class="w"> </span>        Returns: The contents of the ref file, or None if it does
<span class="w"> </span>            not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        contents = self.read_loose_ref(refname)</span>
<span class="gi">+        if not contents:</span>
<span class="gi">+            contents = self.get_packed_refs().get(refname, None)</span>
<span class="gi">+        return contents</span>

<span class="w"> </span>    def read_loose_ref(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Read a loose reference and return its contents.
<span class="gu">@@ -163,7 +289,7 @@ class RefsContainer:</span>
<span class="w"> </span>        Returns: The contents of the ref file, or None if it does
<span class="w"> </span>            not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.read_loose_ref)</span>

<span class="w"> </span>    def follow(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Follow a reference name.
<span class="gu">@@ -171,9 +297,21 @@ class RefsContainer:</span>
<span class="w"> </span>        Returns: a tuple of (refnames, sha), wheres refnames are the names of
<span class="w"> </span>            references in the chain
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __contains__(self, refname) -&gt;bool:</span>
<span class="gi">+        contents = SYMREF + name</span>
<span class="gi">+        depth = 0</span>
<span class="gi">+        refnames = []</span>
<span class="gi">+        while contents.startswith(SYMREF):</span>
<span class="gi">+            refname = contents[len(SYMREF) :]</span>
<span class="gi">+            refnames.append(refname)</span>
<span class="gi">+            contents = self.read_ref(refname)</span>
<span class="gi">+            if not contents:</span>
<span class="gi">+                break</span>
<span class="gi">+            depth += 1</span>
<span class="gi">+            if depth &gt; 5:</span>
<span class="gi">+                raise SymrefLoop(name, depth)</span>
<span class="gi">+        return refnames, contents</span>
<span class="gi">+</span>
<span class="gi">+    def __contains__(self, refname) -&gt; bool:</span>
<span class="w"> </span>        if self.read_ref(refname):
<span class="w"> </span>            return True
<span class="w"> </span>        return False
<span class="gu">@@ -188,8 +326,16 @@ class RefsContainer:</span>
<span class="w"> </span>            raise KeyError(name)
<span class="w"> </span>        return sha

<span class="gd">-    def set_if_equals(self, name, old_ref, new_ref, committer=None,</span>
<span class="gd">-        timestamp=None, timezone=None, message=None):</span>
<span class="gi">+    def set_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        new_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a refname to new_ref only if it currently equals old_ref.

<span class="w"> </span>        This method follows all symbolic references if applicable for the
<span class="gu">@@ -204,19 +350,20 @@ class RefsContainer:</span>
<span class="w"> </span>          message: Message for reflog
<span class="w"> </span>        Returns: True if the set was successful, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.set_if_equals)</span>

<span class="gd">-    def add_if_new(self, name, ref, committer=None, timestamp=None,</span>
<span class="gd">-        timezone=None, message=None):</span>
<span class="gi">+    def add_if_new(</span>
<span class="gi">+        self, name, ref, committer=None, timestamp=None, timezone=None, message=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new reference only if it does not already exist.

<span class="w"> </span>        Args:
<span class="w"> </span>          name: Ref name
<span class="w"> </span>          ref: Ref value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.add_if_new)</span>

<span class="gd">-    def __setitem__(self, name, ref) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name, ref) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a reference name to point to the given SHA1.

<span class="w"> </span>        This method follows all symbolic references if applicable for the
<span class="gu">@@ -232,8 +379,15 @@ class RefsContainer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.set_if_equals(name, None, ref)

<span class="gd">-    def remove_if_equals(self, name, old_ref, committer=None, timestamp=</span>
<span class="gd">-        None, timezone=None, message=None):</span>
<span class="gi">+    def remove_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove a refname only if it currently equals old_ref.

<span class="w"> </span>        This method does not follow symbolic references, even if applicable for
<span class="gu">@@ -247,9 +401,9 @@ class RefsContainer:</span>
<span class="w"> </span>          message: Message for reflog
<span class="w"> </span>        Returns: True if the delete was successful, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.remove_if_equals)</span>

<span class="gd">-    def __delitem__(self, name) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove a refname.

<span class="w"> </span>        This method does not follow symbolic references, even if applicable for
<span class="gu">@@ -269,7 +423,15 @@ class RefsContainer:</span>

<span class="w"> </span>        Returns: Dictionary mapping source ref to target ref
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = {}</span>
<span class="gi">+        for src in self.allkeys():</span>
<span class="gi">+            try:</span>
<span class="gi">+                dst = parse_symref_value(self.read_ref(src))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                ret[src] = dst</span>
<span class="gi">+        return ret</span>


<span class="w"> </span>class DictRefsContainer(RefsContainer):
<span class="gu">@@ -279,62 +441,243 @@ class DictRefsContainer(RefsContainer):</span>
<span class="w"> </span>    threadsafe.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, refs, logger=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, refs, logger=None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(logger=logger)
<span class="w"> </span>        self._refs = refs
<span class="w"> </span>        self._peeled: Dict[bytes, ObjectID] = {}
<span class="w"> </span>        self._watchers: Set[Any] = set()

<span class="gi">+    def allkeys(self):</span>
<span class="gi">+        return self._refs.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def read_loose_ref(self, name):</span>
<span class="gi">+        return self._refs.get(name, None)</span>
<span class="gi">+</span>
<span class="gi">+    def get_packed_refs(self):</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    def _notify(self, ref, newsha):</span>
<span class="gi">+        for watcher in self._watchers:</span>
<span class="gi">+            watcher._notify((ref, newsha))</span>
<span class="gi">+</span>
<span class="gi">+    def set_symbolic_ref(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Ref,</span>
<span class="gi">+        other: Ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        old = self.follow(name)[-1]</span>
<span class="gi">+        new = SYMREF + other</span>
<span class="gi">+        self._refs[name] = new</span>
<span class="gi">+        self._notify(name, new)</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            name,</span>
<span class="gi">+            old,</span>
<span class="gi">+            new,</span>
<span class="gi">+            committer=committer,</span>
<span class="gi">+            timestamp=timestamp,</span>
<span class="gi">+            timezone=timezone,</span>
<span class="gi">+            message=message,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        new_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if old_ref is not None and self._refs.get(name, ZERO_SHA) != old_ref:</span>
<span class="gi">+            return False</span>
<span class="gi">+        realnames, _ = self.follow(name)</span>
<span class="gi">+        for realname in realnames:</span>
<span class="gi">+            self._check_refname(realname)</span>
<span class="gi">+            old = self._refs.get(realname)</span>
<span class="gi">+            self._refs[realname] = new_ref</span>
<span class="gi">+            self._notify(realname, new_ref)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                realname,</span>
<span class="gi">+                old,</span>
<span class="gi">+                new_ref,</span>
<span class="gi">+                committer=committer,</span>
<span class="gi">+                timestamp=timestamp,</span>
<span class="gi">+                timezone=timezone,</span>
<span class="gi">+                message=message,</span>
<span class="gi">+            )</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def add_if_new(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Ref,</span>
<span class="gi">+        ref: ObjectID,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message: Optional[bytes] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if name in self._refs:</span>
<span class="gi">+            return False</span>
<span class="gi">+        self._refs[name] = ref</span>
<span class="gi">+        self._notify(name, ref)</span>
<span class="gi">+        self._log(</span>
<span class="gi">+            name,</span>
<span class="gi">+            None,</span>
<span class="gi">+            ref,</span>
<span class="gi">+            committer=committer,</span>
<span class="gi">+            timestamp=timestamp,</span>
<span class="gi">+            timezone=timezone,</span>
<span class="gi">+            message=message,</span>
<span class="gi">+        )</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def remove_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if old_ref is not None and self._refs.get(name, ZERO_SHA) != old_ref:</span>
<span class="gi">+            return False</span>
<span class="gi">+        try:</span>
<span class="gi">+            old = self._refs.pop(name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._notify(name, None)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                name,</span>
<span class="gi">+                old,</span>
<span class="gi">+                None,</span>
<span class="gi">+                committer=committer,</span>
<span class="gi">+                timestamp=timestamp,</span>
<span class="gi">+                timezone=timezone,</span>
<span class="gi">+                message=message,</span>
<span class="gi">+            )</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_peeled(self, name):</span>
<span class="gi">+        return self._peeled.get(name)</span>
<span class="gi">+</span>
<span class="w"> </span>    def _update(self, refs):
<span class="w"> </span>        &quot;&quot;&quot;Update multiple refs; intended only for testing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO(dborowitz): replace this with a public function that uses</span>
<span class="gi">+        # set_if_equal.</span>
<span class="gi">+        for ref, sha in refs.items():</span>
<span class="gi">+            self.set_if_equals(ref, None, sha)</span>

<span class="w"> </span>    def _update_peeled(self, peeled):
<span class="w"> </span>        &quot;&quot;&quot;Update cached peeled refs; intended only for testing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._peeled.update(peeled)</span>


<span class="w"> </span>class InfoRefsContainer(RefsContainer):
<span class="w"> </span>    &quot;&quot;&quot;Refs container that reads refs from a info/refs file.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, f) -&gt;None:</span>
<span class="gi">+    def __init__(self, f) -&gt; None:</span>
<span class="w"> </span>        self._refs = {}
<span class="w"> </span>        self._peeled = {}
<span class="w"> </span>        for line in f.readlines():
<span class="gd">-            sha, name = line.rstrip(b&#39;\n&#39;).split(b&#39;\t&#39;)</span>
<span class="gi">+            sha, name = line.rstrip(b&quot;\n&quot;).split(b&quot;\t&quot;)</span>
<span class="w"> </span>            if name.endswith(PEELED_TAG_SUFFIX):
<span class="w"> </span>                name = name[:-3]
<span class="w"> </span>                if not check_ref_format(name):
<span class="gd">-                    raise ValueError(f&#39;invalid ref name {name!r}&#39;)</span>
<span class="gi">+                    raise ValueError(f&quot;invalid ref name {name!r}&quot;)</span>
<span class="w"> </span>                self._peeled[name] = sha
<span class="w"> </span>            else:
<span class="w"> </span>                if not check_ref_format(name):
<span class="gd">-                    raise ValueError(f&#39;invalid ref name {name!r}&#39;)</span>
<span class="gi">+                    raise ValueError(f&quot;invalid ref name {name!r}&quot;)</span>
<span class="w"> </span>                self._refs[name] = sha

<span class="gi">+    def allkeys(self):</span>
<span class="gi">+        return self._refs.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def read_loose_ref(self, name):</span>
<span class="gi">+        return self._refs.get(name, None)</span>
<span class="gi">+</span>
<span class="gi">+    def get_packed_refs(self):</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    def get_peeled(self, name):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._peeled[name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return self._refs[name]</span>
<span class="gi">+</span>

<span class="w"> </span>class DiskRefsContainer(RefsContainer):
<span class="w"> </span>    &quot;&quot;&quot;Refs container that reads refs from disk.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path, worktree_path=None, logger=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, path, worktree_path=None, logger=None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(logger=logger)
<span class="gd">-        if getattr(path, &#39;encode&#39;, None) is not None:</span>
<span class="gi">+        if getattr(path, &quot;encode&quot;, None) is not None:</span>
<span class="w"> </span>            path = os.fsencode(path)
<span class="w"> </span>        self.path = path
<span class="w"> </span>        if worktree_path is None:
<span class="w"> </span>            worktree_path = path
<span class="gd">-        if getattr(worktree_path, &#39;encode&#39;, None) is not None:</span>
<span class="gi">+        if getattr(worktree_path, &quot;encode&quot;, None) is not None:</span>
<span class="w"> </span>            worktree_path = os.fsencode(worktree_path)
<span class="w"> </span>        self.worktree_path = worktree_path
<span class="w"> </span>        self._packed_refs = None
<span class="w"> </span>        self._peeled_refs = None

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self.__class__.__name__}({self.path!r})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self.path!r})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def subkeys(self, base):</span>
<span class="gi">+        subkeys = set()</span>
<span class="gi">+        path = self.refpath(base)</span>
<span class="gi">+        for root, unused_dirs, files in os.walk(path):</span>
<span class="gi">+            dir = root[len(path) :]</span>
<span class="gi">+            if os.path.sep != &quot;/&quot;:</span>
<span class="gi">+                dir = dir.replace(os.fsencode(os.path.sep), b&quot;/&quot;)</span>
<span class="gi">+            dir = dir.strip(b&quot;/&quot;)</span>
<span class="gi">+            for filename in files:</span>
<span class="gi">+                refname = b&quot;/&quot;.join(([dir] if dir else []) + [filename])</span>
<span class="gi">+                # check_ref_format requires at least one /, so we prepend the</span>
<span class="gi">+                # base before calling it.</span>
<span class="gi">+                if check_ref_format(base + b&quot;/&quot; + refname):</span>
<span class="gi">+                    subkeys.add(refname)</span>
<span class="gi">+        for key in self.get_packed_refs():</span>
<span class="gi">+            if key.startswith(base):</span>
<span class="gi">+                subkeys.add(key[len(base) :].strip(b&quot;/&quot;))</span>
<span class="gi">+        return subkeys</span>
<span class="gi">+</span>
<span class="gi">+    def allkeys(self):</span>
<span class="gi">+        allkeys = set()</span>
<span class="gi">+        if os.path.exists(self.refpath(HEADREF)):</span>
<span class="gi">+            allkeys.add(HEADREF)</span>
<span class="gi">+        path = self.refpath(b&quot;&quot;)</span>
<span class="gi">+        refspath = self.refpath(b&quot;refs&quot;)</span>
<span class="gi">+        for root, unused_dirs, files in os.walk(refspath):</span>
<span class="gi">+            dir = root[len(path) :]</span>
<span class="gi">+            if os.path.sep != &quot;/&quot;:</span>
<span class="gi">+                dir = dir.replace(os.fsencode(os.path.sep), b&quot;/&quot;)</span>
<span class="gi">+            for filename in files:</span>
<span class="gi">+                refname = b&quot;/&quot;.join([dir, filename])</span>
<span class="gi">+                if check_ref_format(refname):</span>
<span class="gi">+                    allkeys.add(refname)</span>
<span class="gi">+        allkeys.update(self.get_packed_refs())</span>
<span class="gi">+        return allkeys</span>

<span class="w"> </span>    def refpath(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Return the disk path of a ref.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if os.path.sep != &quot;/&quot;:</span>
<span class="gi">+            name = name.replace(b&quot;/&quot;, os.fsencode(os.path.sep))</span>
<span class="gi">+        # TODO: as the &#39;HEAD&#39; reference is working tree specific, it</span>
<span class="gi">+        # should actually not be a part of RefsContainer</span>
<span class="gi">+        if name == HEADREF:</span>
<span class="gi">+            return os.path.join(self.worktree_path, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return os.path.join(self.path, name)</span>

<span class="w"> </span>    def get_packed_refs(self):
<span class="w"> </span>        &quot;&quot;&quot;Get contents of the packed-refs file.
<span class="gu">@@ -344,7 +687,29 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>        Note: Will return an empty dictionary when no packed-refs file is
<span class="w"> </span>            present.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: invalidate the cache on repacking</span>
<span class="gi">+        if self._packed_refs is None:</span>
<span class="gi">+            # set both to empty because we want _peeled_refs to be</span>
<span class="gi">+            # None if and only if _packed_refs is also None.</span>
<span class="gi">+            self._packed_refs = {}</span>
<span class="gi">+            self._peeled_refs = {}</span>
<span class="gi">+            path = os.path.join(self.path, b&quot;packed-refs&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                f = GitFile(path, &quot;rb&quot;)</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                return {}</span>
<span class="gi">+            with f:</span>
<span class="gi">+                first_line = next(iter(f)).rstrip()</span>
<span class="gi">+                if first_line.startswith(b&quot;# pack-refs&quot;) and b&quot; peeled&quot; in first_line:</span>
<span class="gi">+                    for sha, name, peeled in read_packed_refs_with_peeled(f):</span>
<span class="gi">+                        self._packed_refs[name] = sha</span>
<span class="gi">+                        if peeled:</span>
<span class="gi">+                            self._peeled_refs[name] = peeled</span>
<span class="gi">+                else:</span>
<span class="gi">+                    f.seek(0)</span>
<span class="gi">+                    for sha, name in read_packed_refs(f):</span>
<span class="gi">+                        self._packed_refs[name] = sha</span>
<span class="gi">+        return self._packed_refs</span>

<span class="w"> </span>    def add_packed_refs(self, new_refs: Dict[Ref, Optional[ObjectID]]):
<span class="w"> </span>        &quot;&quot;&quot;Add the given refs as packed refs.
<span class="gu">@@ -353,7 +718,34 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>          new_refs: A mapping of ref names to targets; if a target is None that
<span class="w"> </span>            means remove the ref
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not new_refs:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        path = os.path.join(self.path, b&quot;packed-refs&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        with GitFile(path, &quot;wb&quot;) as f:</span>
<span class="gi">+            # reread cached refs from disk, while holding the lock</span>
<span class="gi">+            packed_refs = self.get_packed_refs().copy()</span>
<span class="gi">+</span>
<span class="gi">+            for ref, target in new_refs.items():</span>
<span class="gi">+                # sanity check</span>
<span class="gi">+                if ref == HEADREF:</span>
<span class="gi">+                    raise ValueError(&quot;cannot pack HEAD&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # remove any loose refs pointing to this one -- please</span>
<span class="gi">+                # note that this bypasses remove_if_equals as we don&#39;t</span>
<span class="gi">+                # want to affect packed refs in here</span>
<span class="gi">+                with suppress(OSError):</span>
<span class="gi">+                    os.remove(self.refpath(ref))</span>
<span class="gi">+</span>
<span class="gi">+                if target is not None:</span>
<span class="gi">+                    packed_refs[ref] = target</span>
<span class="gi">+                else:</span>
<span class="gi">+                    packed_refs.pop(ref, None)</span>
<span class="gi">+</span>
<span class="gi">+            write_packed_refs(f, packed_refs, self._peeled_refs)</span>
<span class="gi">+</span>
<span class="gi">+            self._packed_refs = packed_refs</span>

<span class="w"> </span>    def get_peeled(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Return the cached peeled value of a ref, if available.
<span class="gu">@@ -364,7 +756,15 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>            a tag, this will be the SHA the ref refers to. If the ref may point
<span class="w"> </span>            to a tag, but no cached information is available, None is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.get_packed_refs()</span>
<span class="gi">+        if self._peeled_refs is None or name not in self._packed_refs:</span>
<span class="gi">+            # No cache: no peeled refs were read, or this ref is loose</span>
<span class="gi">+            return None</span>
<span class="gi">+        if name in self._peeled_refs:</span>
<span class="gi">+            return self._peeled_refs[name]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Known not peelable</span>
<span class="gi">+            return self[name]</span>

<span class="w"> </span>    def read_loose_ref(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Read a reference file and return its contents.
<span class="gu">@@ -380,10 +780,52 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          IOError: if any other error occurs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_symbolic_ref(self, name, other, committer=None, timestamp=None,</span>
<span class="gd">-        timezone=None, message=None):</span>
<span class="gi">+        filename = self.refpath(name)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with GitFile(filename, &quot;rb&quot;) as f:</span>
<span class="gi">+                header = f.read(len(SYMREF))</span>
<span class="gi">+                if header == SYMREF:</span>
<span class="gi">+                    # Read only the first line</span>
<span class="gi">+                    return header + next(iter(f)).rstrip(b&quot;\r\n&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Read only the first 40 bytes</span>
<span class="gi">+                    return header + f.read(40 - len(SYMREF))</span>
<span class="gi">+        except (OSError, UnicodeError):</span>
<span class="gi">+            # don&#39;t assume anything specific about the error; in</span>
<span class="gi">+            # particular, invalid or forbidden paths can raise weird</span>
<span class="gi">+            # errors depending on the specific operating system</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_packed_ref(self, name):</span>
<span class="gi">+        if self._packed_refs is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        filename = os.path.join(self.path, b&quot;packed-refs&quot;)</span>
<span class="gi">+        # reread cached refs from disk, while holding the lock</span>
<span class="gi">+        f = GitFile(filename, &quot;wb&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._packed_refs = None</span>
<span class="gi">+            self.get_packed_refs()</span>
<span class="gi">+</span>
<span class="gi">+            if name not in self._packed_refs:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            del self._packed_refs[name]</span>
<span class="gi">+            with suppress(KeyError):</span>
<span class="gi">+                del self._peeled_refs[name]</span>
<span class="gi">+            write_packed_refs(f, self._packed_refs, self._peeled_refs)</span>
<span class="gi">+            f.close()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            f.abort()</span>
<span class="gi">+</span>
<span class="gi">+    def set_symbolic_ref(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        other,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Make a ref point at another ref.

<span class="w"> </span>        Args:
<span class="gu">@@ -391,10 +833,38 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>          other: Name of the ref to point at
<span class="w"> </span>          message: Optional message to describe the change
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_if_equals(self, name, old_ref, new_ref, committer=None,</span>
<span class="gd">-        timestamp=None, timezone=None, message=None):</span>
<span class="gi">+        self._check_refname(name)</span>
<span class="gi">+        self._check_refname(other)</span>
<span class="gi">+        filename = self.refpath(name)</span>
<span class="gi">+        f = GitFile(filename, &quot;wb&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            f.write(SYMREF + other + b&quot;\n&quot;)</span>
<span class="gi">+            sha = self.follow(name)[-1]</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                name,</span>
<span class="gi">+                sha,</span>
<span class="gi">+                sha,</span>
<span class="gi">+                committer=committer,</span>
<span class="gi">+                timestamp=timestamp,</span>
<span class="gi">+                timezone=timezone,</span>
<span class="gi">+                message=message,</span>
<span class="gi">+            )</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            f.abort()</span>
<span class="gi">+            raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            f.close()</span>
<span class="gi">+</span>
<span class="gi">+    def set_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        new_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a refname to new_ref only if it currently equals old_ref.

<span class="w"> </span>        This method follows all symbolic references, and can be used to perform
<span class="gu">@@ -408,10 +878,61 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>          message: Set message for reflog
<span class="w"> </span>        Returns: True if the set was successful, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_if_new(self, name: bytes, ref: bytes, committer=None, timestamp</span>
<span class="gd">-        =None, timezone=None, message: Optional[bytes]=None):</span>
<span class="gi">+        self._check_refname(name)</span>
<span class="gi">+        try:</span>
<span class="gi">+            realnames, _ = self.follow(name)</span>
<span class="gi">+            realname = realnames[-1]</span>
<span class="gi">+        except (KeyError, IndexError, SymrefLoop):</span>
<span class="gi">+            realname = name</span>
<span class="gi">+        filename = self.refpath(realname)</span>
<span class="gi">+</span>
<span class="gi">+        # make sure none of the ancestor folders is in packed refs</span>
<span class="gi">+        probe_ref = os.path.dirname(realname)</span>
<span class="gi">+        packed_refs = self.get_packed_refs()</span>
<span class="gi">+        while probe_ref:</span>
<span class="gi">+            if packed_refs.get(probe_ref, None) is not None:</span>
<span class="gi">+                raise NotADirectoryError(filename)</span>
<span class="gi">+            probe_ref = os.path.dirname(probe_ref)</span>
<span class="gi">+</span>
<span class="gi">+        ensure_dir_exists(os.path.dirname(filename))</span>
<span class="gi">+        with GitFile(filename, &quot;wb&quot;) as f:</span>
<span class="gi">+            if old_ref is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # read again while holding the lock</span>
<span class="gi">+                    orig_ref = self.read_loose_ref(realname)</span>
<span class="gi">+                    if orig_ref is None:</span>
<span class="gi">+                        orig_ref = self.get_packed_refs().get(realname, ZERO_SHA)</span>
<span class="gi">+                    if orig_ref != old_ref:</span>
<span class="gi">+                        f.abort()</span>
<span class="gi">+                        return False</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    f.abort()</span>
<span class="gi">+                    raise</span>
<span class="gi">+            try:</span>
<span class="gi">+                f.write(new_ref + b&quot;\n&quot;)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                f.abort()</span>
<span class="gi">+                raise</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                realname,</span>
<span class="gi">+                old_ref,</span>
<span class="gi">+                new_ref,</span>
<span class="gi">+                committer=committer,</span>
<span class="gi">+                timestamp=timestamp,</span>
<span class="gi">+                timezone=timezone,</span>
<span class="gi">+                message=message,</span>
<span class="gi">+            )</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def add_if_new(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: bytes,</span>
<span class="gi">+        ref: bytes,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message: Optional[bytes] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a new reference only if it does not already exist.

<span class="w"> </span>        This method follows symrefs, and only ensures that the last ref in the
<span class="gu">@@ -423,10 +944,46 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>          message: Optional message for reflog
<span class="w"> </span>        Returns: True if the add was successful, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def remove_if_equals(self, name, old_ref, committer=None, timestamp=</span>
<span class="gd">-        None, timezone=None, message=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            realnames, contents = self.follow(name)</span>
<span class="gi">+            if contents is not None:</span>
<span class="gi">+                return False</span>
<span class="gi">+            realname = realnames[-1]</span>
<span class="gi">+        except (KeyError, IndexError):</span>
<span class="gi">+            realname = name</span>
<span class="gi">+        self._check_refname(realname)</span>
<span class="gi">+        filename = self.refpath(realname)</span>
<span class="gi">+        ensure_dir_exists(os.path.dirname(filename))</span>
<span class="gi">+        with GitFile(filename, &quot;wb&quot;) as f:</span>
<span class="gi">+            if os.path.exists(filename) or name in self.get_packed_refs():</span>
<span class="gi">+                f.abort()</span>
<span class="gi">+                return False</span>
<span class="gi">+            try:</span>
<span class="gi">+                f.write(ref + b&quot;\n&quot;)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                f.abort()</span>
<span class="gi">+                raise</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._log(</span>
<span class="gi">+                    name,</span>
<span class="gi">+                    None,</span>
<span class="gi">+                    ref,</span>
<span class="gi">+                    committer=committer,</span>
<span class="gi">+                    timestamp=timestamp,</span>
<span class="gi">+                    timezone=timezone,</span>
<span class="gi">+                    message=message,</span>
<span class="gi">+                )</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def remove_if_equals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        old_ref,</span>
<span class="gi">+        committer=None,</span>
<span class="gi">+        timestamp=None,</span>
<span class="gi">+        timezone=None,</span>
<span class="gi">+        message=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove a refname only if it currently equals old_ref.

<span class="w"> </span>        This method does not follow symbolic references. It can be used to
<span class="gu">@@ -439,12 +996,78 @@ class DiskRefsContainer(RefsContainer):</span>
<span class="w"> </span>          message: Optional message
<span class="w"> </span>        Returns: True if the delete was successful, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_refname(name)</span>
<span class="gi">+        filename = self.refpath(name)</span>
<span class="gi">+        ensure_dir_exists(os.path.dirname(filename))</span>
<span class="gi">+        f = GitFile(filename, &quot;wb&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if old_ref is not None:</span>
<span class="gi">+                orig_ref = self.read_loose_ref(name)</span>
<span class="gi">+                if orig_ref is None:</span>
<span class="gi">+                    orig_ref = self.get_packed_refs().get(name, ZERO_SHA)</span>
<span class="gi">+                if orig_ref != old_ref:</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # remove the reference file itself</span>
<span class="gi">+            try:</span>
<span class="gi">+                found = os.path.lexists(filename)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # may only be packed, or otherwise unstorable</span>
<span class="gi">+                found = False</span>
<span class="gi">+</span>
<span class="gi">+            if found:</span>
<span class="gi">+                os.remove(filename)</span>
<span class="gi">+</span>
<span class="gi">+            self._remove_packed_ref(name)</span>
<span class="gi">+            self._log(</span>
<span class="gi">+                name,</span>
<span class="gi">+                old_ref,</span>
<span class="gi">+                None,</span>
<span class="gi">+                committer=committer,</span>
<span class="gi">+                timestamp=timestamp,</span>
<span class="gi">+                timezone=timezone,</span>
<span class="gi">+                message=message,</span>
<span class="gi">+            )</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # never write, we just wanted the lock</span>
<span class="gi">+            f.abort()</span>
<span class="gi">+</span>
<span class="gi">+        # outside of the lock, clean-up any parent directory that might now</span>
<span class="gi">+        # be empty. this ensures that re-creating a reference of the same</span>
<span class="gi">+        # name of what was previously a directory works as expected</span>
<span class="gi">+        parent = name</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                parent, _ = parent.rsplit(b&quot;/&quot;, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if parent == b&quot;refs&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            parent_filename = self.refpath(parent)</span>
<span class="gi">+            try:</span>
<span class="gi">+                os.rmdir(parent_filename)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # this can be caused by the parent directory being</span>
<span class="gi">+                # removed by another process, being not empty, etc.</span>
<span class="gi">+                # in any case, this is non fatal because we already</span>
<span class="gi">+                # removed the reference, just ignore it</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>


<span class="w"> </span>def _split_ref_line(line):
<span class="w"> </span>    &quot;&quot;&quot;Split a single ref line into a tuple of SHA1 and name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields = line.rstrip(b&quot;\n\r&quot;).split(b&quot; &quot;)</span>
<span class="gi">+    if len(fields) != 2:</span>
<span class="gi">+        raise PackedRefsException(f&quot;invalid ref line {line!r}&quot;)</span>
<span class="gi">+    sha, name = fields</span>
<span class="gi">+    if not valid_hexsha(sha):</span>
<span class="gi">+        raise PackedRefsException(f&quot;Invalid hex sha {sha!r}&quot;)</span>
<span class="gi">+    if not check_ref_format(name):</span>
<span class="gi">+        raise PackedRefsException(f&quot;invalid ref name {name!r}&quot;)</span>
<span class="gi">+    return (sha, name)</span>


<span class="w"> </span>def read_packed_refs(f):
<span class="gu">@@ -454,7 +1077,13 @@ def read_packed_refs(f):</span>
<span class="w"> </span>      f: file-like object to read from
<span class="w"> </span>    Returns: Iterator over tuples with SHA1s and ref names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        if line.startswith(b&quot;#&quot;):</span>
<span class="gi">+            # Comment</span>
<span class="gi">+            continue</span>
<span class="gi">+        if line.startswith(b&quot;^&quot;):</span>
<span class="gi">+            raise PackedRefsException(&quot;found peeled ref in packed-refs without peeled&quot;)</span>
<span class="gi">+        yield _split_ref_line(line)</span>


<span class="w"> </span>def read_packed_refs_with_peeled(f):
<span class="gu">@@ -466,7 +1095,27 @@ def read_packed_refs_with_peeled(f):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>      f: file-like object to read from, seek&#39;ed to the second line
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    last = None</span>
<span class="gi">+    for line in f:</span>
<span class="gi">+        if line[0] == b&quot;#&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        line = line.rstrip(b&quot;\r\n&quot;)</span>
<span class="gi">+        if line.startswith(b&quot;^&quot;):</span>
<span class="gi">+            if not last:</span>
<span class="gi">+                raise PackedRefsException(&quot;unexpected peeled ref line&quot;)</span>
<span class="gi">+            if not valid_hexsha(line[1:]):</span>
<span class="gi">+                raise PackedRefsException(f&quot;Invalid hex sha {line[1:]!r}&quot;)</span>
<span class="gi">+            sha, name = _split_ref_line(last)</span>
<span class="gi">+            last = None</span>
<span class="gi">+            yield (sha, name, line[1:])</span>
<span class="gi">+        else:</span>
<span class="gi">+            if last:</span>
<span class="gi">+                sha, name = _split_ref_line(last)</span>
<span class="gi">+                yield (sha, name, None)</span>
<span class="gi">+            last = line</span>
<span class="gi">+    if last:</span>
<span class="gi">+        sha, name = _split_ref_line(last)</span>
<span class="gi">+        yield (sha, name, None)</span>


<span class="w"> </span>def write_packed_refs(f, packed_refs, peeled_refs=None):
<span class="gu">@@ -477,20 +1126,167 @@ def write_packed_refs(f, packed_refs, peeled_refs=None):</span>
<span class="w"> </span>      packed_refs: dict of refname to sha of packed refs to write
<span class="w"> </span>      peeled_refs: dict of refname to peeled value of sha
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if peeled_refs is None:</span>
<span class="gi">+        peeled_refs = {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        f.write(b&quot;# pack-refs with: peeled\n&quot;)</span>
<span class="gi">+    for refname in sorted(packed_refs.keys()):</span>
<span class="gi">+        f.write(git_line(packed_refs[refname], refname))</span>
<span class="gi">+        if refname in peeled_refs:</span>
<span class="gi">+            f.write(b&quot;^&quot; + peeled_refs[refname] + b&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def read_info_refs(f):</span>
<span class="gi">+    ret = {}</span>
<span class="gi">+    for line in f.readlines():</span>
<span class="gi">+        (sha, name) = line.rstrip(b&quot;\r\n&quot;).split(b&quot;\t&quot;, 1)</span>
<span class="gi">+        ret[name] = sha</span>
<span class="gi">+    return ret</span>


<span class="w"> </span>def write_info_refs(refs, store: ObjectContainer):
<span class="w"> </span>    &quot;&quot;&quot;Generate info refs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO: Avoid recursive import :(</span>
<span class="gi">+    from .object_store import peel_sha</span>

<span class="gi">+    for name, sha in sorted(refs.items()):</span>
<span class="gi">+        # get_refs() includes HEAD as a special case, but we don&#39;t want to</span>
<span class="gi">+        # advertise it</span>
<span class="gi">+        if name == HEADREF:</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            o = store[sha]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        unpeeled, peeled = peel_sha(store, sha)</span>
<span class="gi">+        yield o.id + b&quot;\t&quot; + name + b&quot;\n&quot;</span>
<span class="gi">+        if o.id != peeled.id:</span>
<span class="gi">+            yield peeled.id + b&quot;\t&quot; + name + PEELED_TAG_SUFFIX + b&quot;\n&quot;</span>

<span class="gd">-def strip_peeled_refs(refs):</span>
<span class="gd">-    &quot;&quot;&quot;Remove all peeled refs.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>

<span class="gi">+def is_local_branch(x):</span>
<span class="gi">+    return x.startswith(LOCAL_BRANCH_PREFIX)</span>

<span class="gd">-def _set_default_branch(refs: RefsContainer, origin: bytes, origin_head:</span>
<span class="gd">-    bytes, branch: bytes, ref_message: Optional[bytes]) -&gt;bytes:</span>
<span class="gi">+</span>
<span class="gi">+def strip_peeled_refs(refs):</span>
<span class="gi">+    &quot;&quot;&quot;Remove all peeled refs.&quot;&quot;&quot;</span>
<span class="gi">+    return {</span>
<span class="gi">+        ref: sha for (ref, sha) in refs.items() if not ref.endswith(PEELED_TAG_SUFFIX)</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_origin_head(refs, origin, origin_head):</span>
<span class="gi">+    # set refs/remotes/origin/HEAD</span>
<span class="gi">+    origin_base = b&quot;refs/remotes/&quot; + origin + b&quot;/&quot;</span>
<span class="gi">+    if origin_head and origin_head.startswith(LOCAL_BRANCH_PREFIX):</span>
<span class="gi">+        origin_ref = origin_base + HEADREF</span>
<span class="gi">+        target_ref = origin_base + origin_head[len(LOCAL_BRANCH_PREFIX) :]</span>
<span class="gi">+        if target_ref in refs:</span>
<span class="gi">+            refs.set_symbolic_ref(origin_ref, target_ref)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_default_branch(</span>
<span class="gi">+    refs: RefsContainer,</span>
<span class="gi">+    origin: bytes,</span>
<span class="gi">+    origin_head: bytes,</span>
<span class="gi">+    branch: bytes,</span>
<span class="gi">+    ref_message: Optional[bytes],</span>
<span class="gi">+) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the default branch.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    origin_base = b&quot;refs/remotes/&quot; + origin + b&quot;/&quot;</span>
<span class="gi">+    if branch:</span>
<span class="gi">+        origin_ref = origin_base + branch</span>
<span class="gi">+        if origin_ref in refs:</span>
<span class="gi">+            local_ref = LOCAL_BRANCH_PREFIX + branch</span>
<span class="gi">+            refs.add_if_new(local_ref, refs[origin_ref], ref_message)</span>
<span class="gi">+            head_ref = local_ref</span>
<span class="gi">+        elif LOCAL_TAG_PREFIX + branch in refs:</span>
<span class="gi">+            head_ref = LOCAL_TAG_PREFIX + branch</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;{os.fsencode(branch)!r} is not a valid branch or tag&quot;)</span>
<span class="gi">+    elif origin_head:</span>
<span class="gi">+        head_ref = origin_head</span>
<span class="gi">+        if origin_head.startswith(LOCAL_BRANCH_PREFIX):</span>
<span class="gi">+            origin_ref = origin_base + origin_head[len(LOCAL_BRANCH_PREFIX) :]</span>
<span class="gi">+        else:</span>
<span class="gi">+            origin_ref = origin_head</span>
<span class="gi">+        try:</span>
<span class="gi">+            refs.add_if_new(head_ref, refs[origin_ref], ref_message)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;neither origin_head nor branch are provided&quot;)</span>
<span class="gi">+    return head_ref</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _set_head(refs, head_ref, ref_message):</span>
<span class="gi">+    if head_ref.startswith(LOCAL_TAG_PREFIX):</span>
<span class="gi">+        # detach HEAD at specified tag</span>
<span class="gi">+        head = refs[head_ref]</span>
<span class="gi">+        if isinstance(head, Tag):</span>
<span class="gi">+            _cls, obj = head.object</span>
<span class="gi">+            head = obj.get_object(obj).id</span>
<span class="gi">+        del refs[HEADREF]</span>
<span class="gi">+        refs.set_if_equals(HEADREF, None, head, message=ref_message)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # set HEAD to specific branch</span>
<span class="gi">+        try:</span>
<span class="gi">+            head = refs[head_ref]</span>
<span class="gi">+            refs.set_symbolic_ref(HEADREF, head_ref)</span>
<span class="gi">+            refs.set_if_equals(HEADREF, None, head, message=ref_message)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            head = None</span>
<span class="gi">+    return head</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _import_remote_refs(</span>
<span class="gi">+    refs_container: RefsContainer,</span>
<span class="gi">+    remote_name: str,</span>
<span class="gi">+    refs: Dict[str, str],</span>
<span class="gi">+    message: Optional[bytes] = None,</span>
<span class="gi">+    prune: bool = False,</span>
<span class="gi">+    prune_tags: bool = False,</span>
<span class="gi">+):</span>
<span class="gi">+    stripped_refs = strip_peeled_refs(refs)</span>
<span class="gi">+    branches = {</span>
<span class="gi">+        n[len(LOCAL_BRANCH_PREFIX) :]: v</span>
<span class="gi">+        for (n, v) in stripped_refs.items()</span>
<span class="gi">+        if n.startswith(LOCAL_BRANCH_PREFIX)</span>
<span class="gi">+    }</span>
<span class="gi">+    refs_container.import_refs(</span>
<span class="gi">+        b&quot;refs/remotes/&quot; + remote_name.encode(),</span>
<span class="gi">+        branches,</span>
<span class="gi">+        message=message,</span>
<span class="gi">+        prune=prune,</span>
<span class="gi">+    )</span>
<span class="gi">+    tags = {</span>
<span class="gi">+        n[len(LOCAL_TAG_PREFIX) :]: v</span>
<span class="gi">+        for (n, v) in stripped_refs.items()</span>
<span class="gi">+        if n.startswith(LOCAL_TAG_PREFIX) and not n.endswith(PEELED_TAG_SUFFIX)</span>
<span class="gi">+    }</span>
<span class="gi">+    refs_container.import_refs(</span>
<span class="gi">+        LOCAL_TAG_PREFIX, tags, message=message, prune=prune_tags</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def serialize_refs(store, refs):</span>
<span class="gi">+    # TODO: Avoid recursive import :(</span>
<span class="gi">+    from .object_store import peel_sha</span>
<span class="gi">+</span>
<span class="gi">+    ret = {}</span>
<span class="gi">+    for ref, sha in refs.items():</span>
<span class="gi">+        try:</span>
<span class="gi">+            unpeeled, peeled = peel_sha(store, sha)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &quot;ref {} points at non-present sha {}&quot;.format(</span>
<span class="gi">+                    ref.decode(&quot;utf-8&quot;, &quot;replace&quot;), sha.decode(&quot;ascii&quot;)</span>
<span class="gi">+                ),</span>
<span class="gi">+                UserWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(unpeeled, Tag):</span>
<span class="gi">+                ret[ref + PEELED_TAG_SUFFIX] = peeled.id</span>
<span class="gi">+            ret[ref] = unpeeled.id</span>
<span class="gi">+    return ret</span>
<span class="gh">diff --git a/dulwich/repo.py b/dulwich/repo.py</span>
<span class="gh">index bdec106d..63af3208 100644</span>
<span class="gd">--- a/dulwich/repo.py</span>
<span class="gi">+++ b/dulwich/repo.py</span>
<span class="gu">@@ -1,3 +1,25 @@</span>
<span class="gi">+# repo.py -- For dealing with git repositories.</span>
<span class="gi">+# Copyright (C) 2007 James Westby &lt;jw+debian@jameswestby.net&gt;</span>
<span class="gi">+# Copyright (C) 2008-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Repository access.

<span class="w"> </span>This module contains the base class for git repositories
<span class="gu">@@ -5,42 +27,120 @@ This module contains the base class for git repositories</span>
<span class="w"> </span>local disk (Repo).

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import stat
<span class="w"> </span>import sys
<span class="w"> </span>import time
<span class="w"> </span>import warnings
<span class="w"> </span>from io import BytesIO
<span class="gd">-from typing import TYPE_CHECKING, Any, BinaryIO, Callable, Dict, FrozenSet, Iterable, List, Optional, Set, Tuple, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    BinaryIO,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    FrozenSet,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Set,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gi">+    # There are no circular imports here, but we try to defer imports as long</span>
<span class="gi">+    # as possible to reduce start-up time for anything that doesn&#39;t need</span>
<span class="gi">+    # these imports.</span>
<span class="w"> </span>    from .config import ConfigFile, StackedConfig
<span class="w"> </span>    from .index import Index
<span class="gd">-from .errors import CommitError, HookError, NoIndexPresent, NotBlobError, NotCommitError, NotGitRepository, NotTagError, NotTreeError, RefFormatError</span>
<span class="gi">+</span>
<span class="gi">+from .errors import (</span>
<span class="gi">+    CommitError,</span>
<span class="gi">+    HookError,</span>
<span class="gi">+    NoIndexPresent,</span>
<span class="gi">+    NotBlobError,</span>
<span class="gi">+    NotCommitError,</span>
<span class="gi">+    NotGitRepository,</span>
<span class="gi">+    NotTagError,</span>
<span class="gi">+    NotTreeError,</span>
<span class="gi">+    RefFormatError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .file import GitFile
<span class="gd">-from .hooks import CommitMsgShellHook, Hook, PostCommitShellHook, PostReceiveShellHook, PreCommitShellHook</span>
<span class="gi">+from .hooks import (</span>
<span class="gi">+    CommitMsgShellHook,</span>
<span class="gi">+    Hook,</span>
<span class="gi">+    PostCommitShellHook,</span>
<span class="gi">+    PostReceiveShellHook,</span>
<span class="gi">+    PreCommitShellHook,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .line_ending import BlobNormalizer, TreeBlobNormalizer
<span class="gd">-from .object_store import DiskObjectStore, MemoryObjectStore, MissingObjectFinder, ObjectStoreGraphWalker, PackBasedObjectStore, peel_sha</span>
<span class="gd">-from .objects import Blob, Commit, ObjectID, ShaFile, Tag, Tree, check_hexsha, valid_hexsha</span>
<span class="gi">+from .object_store import (</span>
<span class="gi">+    DiskObjectStore,</span>
<span class="gi">+    MemoryObjectStore,</span>
<span class="gi">+    MissingObjectFinder,</span>
<span class="gi">+    ObjectStoreGraphWalker,</span>
<span class="gi">+    PackBasedObjectStore,</span>
<span class="gi">+    peel_sha,</span>
<span class="gi">+)</span>
<span class="gi">+from .objects import (</span>
<span class="gi">+    Blob,</span>
<span class="gi">+    Commit,</span>
<span class="gi">+    ObjectID,</span>
<span class="gi">+    ShaFile,</span>
<span class="gi">+    Tag,</span>
<span class="gi">+    Tree,</span>
<span class="gi">+    check_hexsha,</span>
<span class="gi">+    valid_hexsha,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .pack import generate_unpacked_objects
<span class="gd">-from .refs import ANNOTATED_TAG_SUFFIX, LOCAL_BRANCH_PREFIX, LOCAL_TAG_PREFIX, SYMREF, DictRefsContainer, DiskRefsContainer, InfoRefsContainer, Ref, RefsContainer, _set_default_branch, _set_head, _set_origin_head, check_ref_format, read_packed_refs, read_packed_refs_with_peeled, serialize_refs, write_packed_refs</span>
<span class="gd">-CONTROLDIR = &#39;.git&#39;</span>
<span class="gd">-OBJECTDIR = &#39;objects&#39;</span>
<span class="gd">-REFSDIR = &#39;refs&#39;</span>
<span class="gd">-REFSDIR_TAGS = &#39;tags&#39;</span>
<span class="gd">-REFSDIR_HEADS = &#39;heads&#39;</span>
<span class="gd">-INDEX_FILENAME = &#39;index&#39;</span>
<span class="gd">-COMMONDIR = &#39;commondir&#39;</span>
<span class="gd">-GITDIR = &#39;gitdir&#39;</span>
<span class="gd">-WORKTREES = &#39;worktrees&#39;</span>
<span class="gd">-BASE_DIRECTORIES = [[&#39;branches&#39;], [REFSDIR], [REFSDIR, REFSDIR_TAGS], [</span>
<span class="gd">-    REFSDIR, REFSDIR_HEADS], [&#39;hooks&#39;], [&#39;info&#39;]]</span>
<span class="gd">-DEFAULT_BRANCH = b&#39;master&#39;</span>
<span class="gi">+from .refs import (</span>
<span class="gi">+    ANNOTATED_TAG_SUFFIX,  # noqa: F401</span>
<span class="gi">+    LOCAL_BRANCH_PREFIX,</span>
<span class="gi">+    LOCAL_TAG_PREFIX,  # noqa: F401</span>
<span class="gi">+    SYMREF,  # noqa: F401</span>
<span class="gi">+    DictRefsContainer,</span>
<span class="gi">+    DiskRefsContainer,</span>
<span class="gi">+    InfoRefsContainer,  # noqa: F401</span>
<span class="gi">+    Ref,</span>
<span class="gi">+    RefsContainer,</span>
<span class="gi">+    _set_default_branch,</span>
<span class="gi">+    _set_head,</span>
<span class="gi">+    _set_origin_head,</span>
<span class="gi">+    check_ref_format,  # noqa: F401</span>
<span class="gi">+    read_packed_refs,  # noqa: F401</span>
<span class="gi">+    read_packed_refs_with_peeled,  # noqa: F401</span>
<span class="gi">+    serialize_refs,</span>
<span class="gi">+    write_packed_refs,  # noqa: F401</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+CONTROLDIR = &quot;.git&quot;</span>
<span class="gi">+OBJECTDIR = &quot;objects&quot;</span>
<span class="gi">+REFSDIR = &quot;refs&quot;</span>
<span class="gi">+REFSDIR_TAGS = &quot;tags&quot;</span>
<span class="gi">+REFSDIR_HEADS = &quot;heads&quot;</span>
<span class="gi">+INDEX_FILENAME = &quot;index&quot;</span>
<span class="gi">+COMMONDIR = &quot;commondir&quot;</span>
<span class="gi">+GITDIR = &quot;gitdir&quot;</span>
<span class="gi">+WORKTREES = &quot;worktrees&quot;</span>
<span class="gi">+</span>
<span class="gi">+BASE_DIRECTORIES = [</span>
<span class="gi">+    [&quot;branches&quot;],</span>
<span class="gi">+    [REFSDIR],</span>
<span class="gi">+    [REFSDIR, REFSDIR_TAGS],</span>
<span class="gi">+    [REFSDIR, REFSDIR_HEADS],</span>
<span class="gi">+    [&quot;hooks&quot;],</span>
<span class="gi">+    [&quot;info&quot;],</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_BRANCH = b&quot;master&quot;</span>


<span class="w"> </span>class InvalidUserIdentity(Exception):
<span class="w"> </span>    &quot;&quot;&quot;User identity is not of the format &#39;user &lt;email&gt;&#39;.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, identity) -&gt;None:</span>
<span class="gi">+    def __init__(self, identity) -&gt; None:</span>
<span class="w"> </span>        self.identity = identity


<span class="gu">@@ -48,8 +148,46 @@ class DefaultIdentityNotFound(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;Default identity could not be determined.&quot;&quot;&quot;


<span class="gd">-def get_user_identity(config: &#39;StackedConfig&#39;, kind: Optional[str]=None</span>
<span class="gd">-    ) -&gt;bytes:</span>
<span class="gi">+# TODO(jelmer): Cache?</span>
<span class="gi">+def _get_default_identity() -&gt; Tuple[str, str]:</span>
<span class="gi">+    import socket</span>
<span class="gi">+</span>
<span class="gi">+    for name in (&quot;LOGNAME&quot;, &quot;USER&quot;, &quot;LNAME&quot;, &quot;USERNAME&quot;):</span>
<span class="gi">+        username = os.environ.get(name)</span>
<span class="gi">+        if username:</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        username = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import pwd</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        fullname = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            entry = pwd.getpwuid(os.getuid())  # type: ignore</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            fullname = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if getattr(entry, &quot;gecos&quot;, None):</span>
<span class="gi">+                fullname = entry.pw_gecos.split(&quot;,&quot;)[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                fullname = None</span>
<span class="gi">+            if username is None:</span>
<span class="gi">+                username = entry.pw_name</span>
<span class="gi">+    if not fullname:</span>
<span class="gi">+        if username is None:</span>
<span class="gi">+            raise DefaultIdentityNotFound(&quot;no username found&quot;)</span>
<span class="gi">+        fullname = username</span>
<span class="gi">+    email = os.environ.get(&quot;EMAIL&quot;)</span>
<span class="gi">+    if email is None:</span>
<span class="gi">+        if username is None:</span>
<span class="gi">+            raise DefaultIdentityNotFound(&quot;no username found&quot;)</span>
<span class="gi">+        email = f&quot;{username}@{socket.gethostname()}&quot;</span>
<span class="gi">+    return (fullname, email)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_user_identity(config: &quot;StackedConfig&quot;, kind: Optional[str] = None) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the identity to use for new commits.

<span class="w"> </span>    If kind is set, this first checks
<span class="gu">@@ -70,7 +208,33 @@ def get_user_identity(config: &#39;StackedConfig&#39;, kind: Optional[str]=None</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      A user identity
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    user: Optional[bytes] = None</span>
<span class="gi">+    email: Optional[bytes] = None</span>
<span class="gi">+    if kind:</span>
<span class="gi">+        user_uc = os.environ.get(&quot;GIT_&quot; + kind + &quot;_NAME&quot;)</span>
<span class="gi">+        if user_uc is not None:</span>
<span class="gi">+            user = user_uc.encode(&quot;utf-8&quot;)</span>
<span class="gi">+        email_uc = os.environ.get(&quot;GIT_&quot; + kind + &quot;_EMAIL&quot;)</span>
<span class="gi">+        if email_uc is not None:</span>
<span class="gi">+            email = email_uc.encode(&quot;utf-8&quot;)</span>
<span class="gi">+    if user is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            user = config.get((&quot;user&quot;,), &quot;name&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            user = None</span>
<span class="gi">+    if email is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            email = config.get((&quot;user&quot;,), &quot;email&quot;)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            email = None</span>
<span class="gi">+    default_user, default_email = _get_default_identity()</span>
<span class="gi">+    if user is None:</span>
<span class="gi">+        user = default_user.encode(&quot;utf-8&quot;)</span>
<span class="gi">+    if email is None:</span>
<span class="gi">+        email = default_email.encode(&quot;utf-8&quot;)</span>
<span class="gi">+    if email.startswith(b&quot;&lt;&quot;) and email.endswith(b&quot;&gt;&quot;):</span>
<span class="gi">+        email = email[1:-1]</span>
<span class="gi">+    return user + b&quot; &lt;&quot; + email + b&quot;&gt;&quot;</span>


<span class="w"> </span>def check_user_identity(identity):
<span class="gu">@@ -81,10 +245,19 @@ def check_user_identity(identity):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      InvalidUserIdentity: Raised when identity is invalid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_graftpoints(graftpoints: Iterable[bytes]) -&gt;Dict[bytes, List[bytes]]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        fst, snd = identity.split(b&quot; &lt;&quot;, 1)</span>
<span class="gi">+    except ValueError as exc:</span>
<span class="gi">+        raise InvalidUserIdentity(identity) from exc</span>
<span class="gi">+    if b&quot;&gt;&quot; not in snd:</span>
<span class="gi">+        raise InvalidUserIdentity(identity)</span>
<span class="gi">+    if b&quot;\0&quot; in identity or b&quot;\n&quot; in identity:</span>
<span class="gi">+        raise InvalidUserIdentity(identity)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_graftpoints(</span>
<span class="gi">+    graftpoints: Iterable[bytes],</span>
<span class="gi">+) -&gt; Dict[bytes, List[bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a list of graftpoints into a dict.

<span class="w"> </span>    Args:
<span class="gu">@@ -98,10 +271,24 @@ def parse_graftpoints(graftpoints: Iterable[bytes]) -&gt;Dict[bytes, List[bytes]]:</span>

<span class="w"> </span>    https://git.wiki.kernel.org/index.php/GraftPoint
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    grafts = {}</span>
<span class="gi">+    for line in graftpoints:</span>
<span class="gi">+        raw_graft = line.split(None, 1)</span>
<span class="gi">+</span>
<span class="gi">+        commit = raw_graft[0]</span>
<span class="gi">+        if len(raw_graft) == 2:</span>
<span class="gi">+            parents = raw_graft[1].split()</span>
<span class="gi">+        else:</span>
<span class="gi">+            parents = []</span>
<span class="gi">+</span>
<span class="gi">+        for sha in [commit, *parents]:</span>
<span class="gi">+            check_hexsha(sha, &quot;Invalid graftpoint&quot;)</span>

<span class="gi">+        grafts[commit] = parents</span>
<span class="gi">+    return grafts</span>

<span class="gd">-def serialize_graftpoints(graftpoints: Dict[bytes, List[bytes]]) -&gt;bytes:</span>
<span class="gi">+</span>
<span class="gi">+def serialize_graftpoints(graftpoints: Dict[bytes, List[bytes]]) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a dictionary of grafts into string.

<span class="w"> </span>    The graft dictionary is:
<span class="gu">@@ -113,7 +300,13 @@ def serialize_graftpoints(graftpoints: Dict[bytes, List[bytes]]) -&gt;bytes:</span>
<span class="w"> </span>    https://git.wiki.kernel.org/index.php/GraftPoint

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graft_lines = []</span>
<span class="gi">+    for commit, parents in graftpoints.items():</span>
<span class="gi">+        if parents:</span>
<span class="gi">+            graft_lines.append(commit + b&quot; &quot; + b&quot; &quot;.join(parents))</span>
<span class="gi">+        else:</span>
<span class="gi">+            graft_lines.append(commit)</span>
<span class="gi">+    return b&quot;\n&quot;.join(graft_lines)</span>


<span class="w"> </span>def _set_filesystem_hidden(path):
<span class="gu">@@ -122,16 +315,40 @@ def _set_filesystem_hidden(path):</span>
<span class="w"> </span>    On win32 uses SetFileAttributesW api:
<span class="w"> </span>    &lt;https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesw&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        import ctypes</span>
<span class="gi">+        from ctypes.wintypes import BOOL, DWORD, LPCWSTR</span>

<span class="gi">+        FILE_ATTRIBUTE_HIDDEN = 2</span>
<span class="gi">+        SetFileAttributesW = ctypes.WINFUNCTYPE(BOOL, LPCWSTR, DWORD)(</span>
<span class="gi">+            (&quot;SetFileAttributesW&quot;, ctypes.windll.kernel32)</span>
<span class="gi">+        )</span>

<span class="gd">-class ParentsProvider:</span>
<span class="gi">+        if isinstance(path, bytes):</span>
<span class="gi">+            path = os.fsdecode(path)</span>
<span class="gi">+        if not SetFileAttributesW(path, FILE_ATTRIBUTE_HIDDEN):</span>
<span class="gi">+            pass  # Could raise or log `ctypes.WinError()` here</span>
<span class="gi">+</span>
<span class="gi">+    # Could implement other platform specific filesystem hiding here</span>

<span class="gd">-    def __init__(self, store, grafts={}, shallows=[]) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ParentsProvider:</span>
<span class="gi">+    def __init__(self, store, grafts={}, shallows=[]) -&gt; None:</span>
<span class="w"> </span>        self.store = store
<span class="w"> </span>        self.grafts = grafts
<span class="w"> </span>        self.shallows = set(shallows)

<span class="gi">+    def get_parents(self, commit_id, commit=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.grafts[commit_id]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        if commit_id in self.shallows:</span>
<span class="gi">+            return []</span>
<span class="gi">+        if commit is None:</span>
<span class="gi">+            commit = self.store[commit_id]</span>
<span class="gi">+        return commit.parents</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseRepo:
<span class="w"> </span>    &quot;&quot;&quot;Base class for a git repository.
<span class="gu">@@ -146,8 +363,7 @@ class BaseRepo:</span>
<span class="w"> </span>        repository
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, object_store: PackBasedObjectStore, refs: RefsContainer</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, object_store: PackBasedObjectStore, refs: RefsContainer) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open a repository.

<span class="w"> </span>        This shouldn&#39;t be called directly, but rather through one of the
<span class="gu">@@ -159,28 +375,51 @@ class BaseRepo:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.object_store = object_store
<span class="w"> </span>        self.refs = refs
<span class="gi">+</span>
<span class="w"> </span>        self._graftpoints: Dict[bytes, List[bytes]] = {}
<span class="w"> </span>        self.hooks: Dict[str, Hook] = {}

<span class="gd">-    def _determine_file_mode(self) -&gt;bool:</span>
<span class="gi">+    def _determine_file_mode(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Probe the file-system to determine whether permissions can be trusted.

<span class="w"> </span>        Returns: True if permissions can be trusted, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._determine_file_mode)</span>

<span class="gd">-    def _determine_symlinks(self) -&gt;bool:</span>
<span class="gi">+    def _determine_symlinks(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Probe the filesystem to determine whether symlinks can be created.

<span class="w"> </span>        Returns: True if symlinks can be created, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # For now, just mimic the old behaviour</span>
<span class="gi">+        return sys.platform != &quot;win32&quot;</span>

<span class="gd">-    def _init_files(self, bare: bool, symlinks: Optional[bool]=None) -&gt;None:</span>
<span class="gi">+    def _init_files(self, bare: bool, symlinks: Optional[bool] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a default set of named files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .config import ConfigFile</span>

<span class="gd">-    def get_named_file(self, path: str) -&gt;Optional[BinaryIO]:</span>
<span class="gi">+        self._put_named_file(&quot;description&quot;, b&quot;Unnamed repository&quot;)</span>
<span class="gi">+        f = BytesIO()</span>
<span class="gi">+        cf = ConfigFile()</span>
<span class="gi">+        cf.set(&quot;core&quot;, &quot;repositoryformatversion&quot;, &quot;0&quot;)</span>
<span class="gi">+        if self._determine_file_mode():</span>
<span class="gi">+            cf.set(&quot;core&quot;, &quot;filemode&quot;, True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cf.set(&quot;core&quot;, &quot;filemode&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+        if symlinks is None and not bare:</span>
<span class="gi">+            symlinks = self._determine_symlinks()</span>
<span class="gi">+</span>
<span class="gi">+        if symlinks is False:</span>
<span class="gi">+            cf.set(&quot;core&quot;, &quot;symlinks&quot;, symlinks)</span>
<span class="gi">+</span>
<span class="gi">+        cf.set(&quot;core&quot;, &quot;bare&quot;, bare)</span>
<span class="gi">+        cf.set(&quot;core&quot;, &quot;logallrefupdates&quot;, True)</span>
<span class="gi">+        cf.write_to_file(f)</span>
<span class="gi">+        self._put_named_file(&quot;config&quot;, f.getvalue())</span>
<span class="gi">+        self._put_named_file(os.path.join(&quot;info&quot;, &quot;exclude&quot;), b&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_named_file(self, path: str) -&gt; Optional[BinaryIO]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a file from the control dir with a specific name.

<span class="w"> </span>        Although the filename should be interpreted as a filename relative to
<span class="gu">@@ -191,7 +430,7 @@ class BaseRepo:</span>
<span class="w"> </span>          path: The path to the file, relative to the control dir.
<span class="w"> </span>        Returns: An open file object, or None if the file does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_named_file)</span>

<span class="w"> </span>    def _put_named_file(self, path: str, contents: bytes):
<span class="w"> </span>        &quot;&quot;&quot;Write a file to the control dir with the given name and contents.
<span class="gu">@@ -200,20 +439,20 @@ class BaseRepo:</span>
<span class="w"> </span>          path: The path to the file, relative to the control dir.
<span class="w"> </span>          contents: A string to write to the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._put_named_file)</span>

<span class="w"> </span>    def _del_named_file(self, path: str):
<span class="w"> </span>        &quot;&quot;&quot;Delete a file in the control directory with the given name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self._del_named_file)</span>

<span class="gd">-    def open_index(self) -&gt;&#39;Index&#39;:</span>
<span class="gi">+    def open_index(self) -&gt; &quot;Index&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open the index for this repository.

<span class="w"> </span>        Raises:
<span class="w"> </span>          NoIndexPresent: If no index is present
<span class="w"> </span>        Returns: The matching `Index`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.open_index)</span>

<span class="w"> </span>    def fetch(self, target, determine_wants=None, progress=None, depth=None):
<span class="w"> </span>        &quot;&quot;&quot;Fetch objects into another repository.
<span class="gu">@@ -226,10 +465,25 @@ class BaseRepo:</span>
<span class="w"> </span>          depth: Optional shallow fetch depth
<span class="w"> </span>        Returns: The local refs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fetch_pack_data(self, determine_wants, graph_walker, progress,</span>
<span class="gd">-        get_tagged=None, depth=None):</span>
<span class="gi">+        if determine_wants is None:</span>
<span class="gi">+            determine_wants = target.object_store.determine_wants_all</span>
<span class="gi">+        count, pack_data = self.fetch_pack_data(</span>
<span class="gi">+            determine_wants,</span>
<span class="gi">+            target.get_graph_walker(),</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            depth=depth,</span>
<span class="gi">+        )</span>
<span class="gi">+        target.object_store.add_pack_data(count, pack_data, progress)</span>
<span class="gi">+        return self.get_refs()</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_pack_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        progress,</span>
<span class="gi">+        get_tagged=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch the pack data required for a set of revisions.

<span class="w"> </span>        Args:
<span class="gu">@@ -245,10 +499,23 @@ class BaseRepo:</span>
<span class="w"> </span>          depth: Shallow fetch depth
<span class="w"> </span>        Returns: count and iterator over pack data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find_missing_objects(self, determine_wants, graph_walker, progress,</span>
<span class="gd">-        get_tagged=None, depth=None) -&gt;Optional[MissingObjectFinder]:</span>
<span class="gi">+        missing_objects = self.find_missing_objects(</span>
<span class="gi">+            determine_wants, graph_walker, progress, get_tagged, depth=depth</span>
<span class="gi">+        )</span>
<span class="gi">+        remote_has = missing_objects.get_remote_has()</span>
<span class="gi">+        object_ids = list(missing_objects)</span>
<span class="gi">+        return len(object_ids), generate_unpacked_objects(</span>
<span class="gi">+            self.object_store, object_ids, progress=progress, other_haves=remote_has</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def find_missing_objects(</span>
<span class="gi">+        self,</span>
<span class="gi">+        determine_wants,</span>
<span class="gi">+        graph_walker,</span>
<span class="gi">+        progress,</span>
<span class="gi">+        get_tagged=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+    ) -&gt; Optional[MissingObjectFinder]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch the missing objects required for a set of revisions.

<span class="w"> </span>        Args:
<span class="gu">@@ -264,11 +531,74 @@ class BaseRepo:</span>
<span class="w"> </span>          depth: Shallow fetch depth
<span class="w"> </span>        Returns: iterator over objects, with __len__ implemented
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def generate_pack_data(self, have: List[ObjectID], want: List[ObjectID],</span>
<span class="gd">-        progress: Optional[Callable[[str], None]]=None, ofs_delta: Optional</span>
<span class="gd">-        [bool]=None):</span>
<span class="gi">+        if depth not in (None, 0):</span>
<span class="gi">+            raise NotImplementedError(&quot;depth not supported yet&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        refs = serialize_refs(self.object_store, self.get_refs())</span>
<span class="gi">+</span>
<span class="gi">+        wants = determine_wants(refs)</span>
<span class="gi">+        if not isinstance(wants, list):</span>
<span class="gi">+            raise TypeError(&quot;determine_wants() did not return a list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        shallows: FrozenSet[ObjectID] = getattr(graph_walker, &quot;shallow&quot;, frozenset())</span>
<span class="gi">+        unshallows: FrozenSet[ObjectID] = getattr(</span>
<span class="gi">+            graph_walker, &quot;unshallow&quot;, frozenset()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if wants == []:</span>
<span class="gi">+            # TODO(dborowitz): find a way to short-circuit that doesn&#39;t change</span>
<span class="gi">+            # this interface.</span>
<span class="gi">+</span>
<span class="gi">+            if shallows or unshallows:</span>
<span class="gi">+                # Do not send a pack in shallow short-circuit path</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            class DummyMissingObjectFinder:</span>
<span class="gi">+                def get_remote_has(self):</span>
<span class="gi">+                    return None</span>
<span class="gi">+</span>
<span class="gi">+                def __len__(self) -&gt; int:</span>
<span class="gi">+                    return 0</span>
<span class="gi">+</span>
<span class="gi">+                def __iter__(self):</span>
<span class="gi">+                    yield from []</span>
<span class="gi">+</span>
<span class="gi">+            return DummyMissingObjectFinder()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        # If the graph walker is set up with an implementation that can</span>
<span class="gi">+        # ACK/NAK to the wire, it will write data to the client through</span>
<span class="gi">+        # this call as a side-effect.</span>
<span class="gi">+        haves = self.object_store.find_common_revisions(graph_walker)</span>
<span class="gi">+</span>
<span class="gi">+        # Deal with shallow requests separately because the haves do</span>
<span class="gi">+        # not reflect what objects are missing</span>
<span class="gi">+        if shallows or unshallows:</span>
<span class="gi">+            # TODO: filter the haves commits from iter_shas. the specific</span>
<span class="gi">+            # commits aren&#39;t missing.</span>
<span class="gi">+            haves = []</span>
<span class="gi">+</span>
<span class="gi">+        parents_provider = ParentsProvider(self.object_store, shallows=shallows)</span>
<span class="gi">+</span>
<span class="gi">+        def get_parents(commit):</span>
<span class="gi">+            return parents_provider.get_parents(commit.id, commit)</span>
<span class="gi">+</span>
<span class="gi">+        return MissingObjectFinder(</span>
<span class="gi">+            self.object_store,</span>
<span class="gi">+            haves=haves,</span>
<span class="gi">+            wants=wants,</span>
<span class="gi">+            shallow=self.get_shallow(),</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            get_tagged=get_tagged,</span>
<span class="gi">+            get_parents=get_parents,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def generate_pack_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        have: List[ObjectID],</span>
<span class="gi">+        want: List[ObjectID],</span>
<span class="gi">+        progress: Optional[Callable[[str], None]] = None,</span>
<span class="gi">+        ofs_delta: Optional[bool] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate pack data objects for a set of wants/haves.

<span class="w"> </span>        Args:
<span class="gu">@@ -277,10 +607,17 @@ class BaseRepo:</span>
<span class="w"> </span>          ofs_delta: Whether OFS deltas can be included
<span class="w"> </span>          progress: Optional progress reporting method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_graph_walker(self, heads: Optional[List[ObjectID]]=None</span>
<span class="gd">-        ) -&gt;ObjectStoreGraphWalker:</span>
<span class="gi">+        return self.object_store.generate_pack_data(</span>
<span class="gi">+            have,</span>
<span class="gi">+            want,</span>
<span class="gi">+            shallow=self.get_shallow(),</span>
<span class="gi">+            progress=progress,</span>
<span class="gi">+            ofs_delta=ofs_delta,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_graph_walker(</span>
<span class="gi">+        self, heads: Optional[List[ObjectID]] = None</span>
<span class="gi">+    ) -&gt; ObjectStoreGraphWalker:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a graph walker.

<span class="w"> </span>        A graph walker is used by a remote repository (or proxy)
<span class="gu">@@ -290,20 +627,45 @@ class BaseRepo:</span>
<span class="w"> </span>          heads: Repository heads to use (optional)
<span class="w"> </span>        Returns: A graph walker object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_refs(self) -&gt;Dict[bytes, bytes]:</span>
<span class="gi">+        if heads is None:</span>
<span class="gi">+            heads = [</span>
<span class="gi">+                sha</span>
<span class="gi">+                for sha in self.refs.as_dict(b&quot;refs/heads&quot;).values()</span>
<span class="gi">+                if sha in self.object_store</span>
<span class="gi">+            ]</span>
<span class="gi">+        parents_provider = ParentsProvider(self.object_store)</span>
<span class="gi">+        return ObjectStoreGraphWalker(</span>
<span class="gi">+            heads, parents_provider.get_parents, shallow=self.get_shallow()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_refs(self) -&gt; Dict[bytes, bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get dictionary with all refs.

<span class="w"> </span>        Returns: A ``dict`` mapping ref names to SHA1s
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.refs.as_dict()</span>

<span class="gd">-    def head(self) -&gt;bytes:</span>
<span class="gi">+    def head(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the SHA1 pointed at by HEAD.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.refs[b&quot;HEAD&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_object(self, sha, cls):</span>
<span class="gi">+        assert len(sha) in (20, 40)</span>
<span class="gi">+        ret = self.get_object(sha)</span>
<span class="gi">+        if not isinstance(ret, cls):</span>
<span class="gi">+            if cls is Commit:</span>
<span class="gi">+                raise NotCommitError(ret)</span>
<span class="gi">+            elif cls is Blob:</span>
<span class="gi">+                raise NotBlobError(ret)</span>
<span class="gi">+            elif cls is Tree:</span>
<span class="gi">+                raise NotTreeError(ret)</span>
<span class="gi">+            elif cls is Tag:</span>
<span class="gi">+                raise NotTagError(ret)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise Exception(f&quot;Type invalid: {ret.type_name!r} != {cls.type_name!r}&quot;)</span>
<span class="gi">+        return ret</span>

<span class="gd">-    def get_object(self, sha: bytes) -&gt;ShaFile:</span>
<span class="gi">+    def get_object(self, sha: bytes) -&gt; ShaFile:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the object with the specified SHA.

<span class="w"> </span>        Args:
<span class="gu">@@ -312,10 +674,16 @@ class BaseRepo:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          KeyError: when the object can not be found
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.object_store[sha]</span>

<span class="gd">-    def get_parents(self, sha: bytes, commit: Optional[Commit]=None) -&gt;List[</span>
<span class="gd">-        bytes]:</span>
<span class="gi">+    def parents_provider(self) -&gt; ParentsProvider:</span>
<span class="gi">+        return ParentsProvider(</span>
<span class="gi">+            self.object_store,</span>
<span class="gi">+            grafts=self._graftpoints,</span>
<span class="gi">+            shallows=self.get_shallow(),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_parents(self, sha: bytes, commit: Optional[Commit] = None) -&gt; List[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the parents of a specific commit.

<span class="w"> </span>        If the specific commit is a graftpoint, the graft parents
<span class="gu">@@ -326,18 +694,18 @@ class BaseRepo:</span>
<span class="w"> </span>          commit: Optional commit matching the sha
<span class="w"> </span>        Returns: List of parents
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.parents_provider().get_parents(sha, commit)</span>

<span class="gd">-    def get_config(self) -&gt;&#39;ConfigFile&#39;:</span>
<span class="gi">+    def get_config(self) -&gt; &quot;ConfigFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the config object.

<span class="w"> </span>        Returns: `ConfigFile` object for the ``.git/config`` file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_config)</span>

<span class="gd">-    def get_worktree_config(self) -&gt;&#39;ConfigFile&#39;:</span>
<span class="gi">+    def get_worktree_config(self) -&gt; &quot;ConfigFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the worktree config object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_worktree_config)</span>

<span class="w"> </span>    def get_description(self):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the description for this repository.
<span class="gu">@@ -345,7 +713,7 @@ class BaseRepo:</span>
<span class="w"> </span>        Returns: String with the description of the repository
<span class="w"> </span>            as set by the user.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.get_description)</span>

<span class="w"> </span>    def set_description(self, description):
<span class="w"> </span>        &quot;&quot;&quot;Set the description for this repository.
<span class="gu">@@ -353,9 +721,9 @@ class BaseRepo:</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          description: Text to set as description for this repository.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.set_description)</span>

<span class="gd">-    def get_config_stack(self) -&gt;&#39;StackedConfig&#39;:</span>
<span class="gi">+    def get_config_stack(self) -&gt; &quot;StackedConfig&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a config stack for this repository.

<span class="w"> </span>        This stack accesses the configuration for both this repository
<span class="gu">@@ -364,14 +732,26 @@ class BaseRepo:</span>

<span class="w"> </span>        Returns: `Config` instance for this repository
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .config import ConfigFile, StackedConfig</span>
<span class="gi">+</span>
<span class="gi">+        local_config = self.get_config()</span>
<span class="gi">+        backends: List[ConfigFile] = [local_config]</span>
<span class="gi">+        if local_config.get_boolean((b&quot;extensions&quot;,), b&quot;worktreeconfig&quot;, False):</span>
<span class="gi">+            backends.append(self.get_worktree_config())</span>

<span class="gd">-    def get_shallow(self) -&gt;Set[ObjectID]:</span>
<span class="gi">+        backends += StackedConfig.default_backends()</span>
<span class="gi">+        return StackedConfig(backends, writable=local_config)</span>
<span class="gi">+</span>
<span class="gi">+    def get_shallow(self) -&gt; Set[ObjectID]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the set of shallow commits.

<span class="w"> </span>        Returns: Set of shallow commits.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = self.get_named_file(&quot;shallow&quot;)</span>
<span class="gi">+        if f is None:</span>
<span class="gi">+            return set()</span>
<span class="gi">+        with f:</span>
<span class="gi">+            return {line.strip() for line in f}</span>

<span class="w"> </span>    def update_shallow(self, new_shallow, new_unshallow):
<span class="w"> </span>        &quot;&quot;&quot;Update the list of shallow objects.
<span class="gu">@@ -380,9 +760,17 @@ class BaseRepo:</span>
<span class="w"> </span>          new_shallow: Newly shallow objects
<span class="w"> </span>          new_unshallow: Newly no longer shallow objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shallow = self.get_shallow()</span>
<span class="gi">+        if new_shallow:</span>
<span class="gi">+            shallow.update(new_shallow)</span>
<span class="gi">+        if new_unshallow:</span>
<span class="gi">+            shallow.difference_update(new_unshallow)</span>
<span class="gi">+        if shallow:</span>
<span class="gi">+            self._put_named_file(&quot;shallow&quot;, b&quot;&quot;.join([sha + b&quot;\n&quot; for sha in shallow]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._del_named_file(&quot;shallow&quot;)</span>

<span class="gd">-    def get_peeled(self, ref: Ref) -&gt;ObjectID:</span>
<span class="gi">+    def get_peeled(self, ref: Ref) -&gt; ObjectID:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the peeled value of a ref.

<span class="w"> </span>        Args:
<span class="gu">@@ -391,9 +779,12 @@ class BaseRepo:</span>
<span class="w"> </span>            intermediate tags; if the original ref does not point to a tag,
<span class="w"> </span>            this will equal the original SHA1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cached = self.refs.get_peeled(ref)</span>
<span class="gi">+        if cached is not None:</span>
<span class="gi">+            return cached</span>
<span class="gi">+        return peel_sha(self.object_store, self.refs[ref])[1].id</span>

<span class="gd">-    def get_walker(self, include: Optional[List[bytes]]=None, *args, **kwargs):</span>
<span class="gi">+    def get_walker(self, include: Optional[List[bytes]] = None, *args, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Obtain a walker for this repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -419,7 +810,14 @@ class BaseRepo:</span>
<span class="w"> </span>            Walker.
<span class="w"> </span>        Returns: A `Walker` object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .walk import Walker</span>
<span class="gi">+</span>
<span class="gi">+        if include is None:</span>
<span class="gi">+            include = [self.head()]</span>
<span class="gi">+</span>
<span class="gi">+        kwargs[&quot;get_parents&quot;] = lambda commit: self.get_parents(commit.id, commit)</span>
<span class="gi">+</span>
<span class="gi">+        return Walker(self.object_store, include, *args, **kwargs)</span>

<span class="w"> </span>    def __getitem__(self, name: Union[ObjectID, Ref]):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve a Git object by SHA1 or ref.
<span class="gu">@@ -431,8 +829,7 @@ class BaseRepo:</span>
<span class="w"> </span>          KeyError: when the specified ref or object does not exist
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not isinstance(name, bytes):
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&quot;&#39;name&#39; must be bytestring, not {type(name).__name__:.80}&quot;)</span>
<span class="gi">+            raise TypeError(f&quot;&#39;name&#39; must be bytestring, not {type(name).__name__:.80}&quot;)</span>
<span class="w"> </span>        if len(name) in (20, 40):
<span class="w"> </span>            try:
<span class="w"> </span>                return self.object_store[name]
<span class="gu">@@ -443,25 +840,25 @@ class BaseRepo:</span>
<span class="w"> </span>        except RefFormatError as exc:
<span class="w"> </span>            raise KeyError(name) from exc

<span class="gd">-    def __contains__(self, name: bytes) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name: bytes) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a specific Git object or ref is present.

<span class="w"> </span>        Args:
<span class="w"> </span>          name: Git object SHA1 or ref name
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if len(name) == 20 or len(name) == 40 and valid_hexsha(name):</span>
<span class="gi">+        if len(name) == 20 or (len(name) == 40 and valid_hexsha(name)):</span>
<span class="w"> </span>            return name in self.object_store or name in self.refs
<span class="w"> </span>        else:
<span class="w"> </span>            return name in self.refs

<span class="gd">-    def __setitem__(self, name: bytes, value: Union[ShaFile, bytes]) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name: bytes, value: Union[ShaFile, bytes]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a ref.

<span class="w"> </span>        Args:
<span class="w"> </span>          name: ref name
<span class="w"> </span>          value: Ref value - either a ShaFile object, or a hex sha
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if name.startswith(b&#39;refs/&#39;) or name == b&#39;HEAD&#39;:</span>
<span class="gi">+        if name.startswith(b&quot;refs/&quot;) or name == b&quot;HEAD&quot;:</span>
<span class="w"> </span>            if isinstance(value, ShaFile):
<span class="w"> </span>                self.refs[name] = value.id
<span class="w"> </span>            elif isinstance(value, bytes):
<span class="gu">@@ -471,21 +868,26 @@ class BaseRepo:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(name)

<span class="gd">-    def __delitem__(self, name: bytes) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove a ref.

<span class="w"> </span>        Args:
<span class="w"> </span>          name: Name of the ref to remove
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if name.startswith(b&#39;refs/&#39;) or name == b&#39;HEAD&#39;:</span>
<span class="gi">+        if name.startswith(b&quot;refs/&quot;) or name == b&quot;HEAD&quot;:</span>
<span class="w"> </span>            del self.refs[name]
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(name)

<span class="gd">-    def _get_user_identity(self, config: &#39;StackedConfig&#39;, kind: Optional[</span>
<span class="gd">-        str]=None) -&gt;bytes:</span>
<span class="gi">+    def _get_user_identity(</span>
<span class="gi">+        self, config: &quot;StackedConfig&quot;, kind: Optional[str] = None</span>
<span class="gi">+    ) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine the identity to use for new commits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;use get_user_identity() rather than Repo._get_user_identity&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        return get_user_identity(config)</span>

<span class="w"> </span>    def _add_graftpoints(self, updated_graftpoints: Dict[bytes, List[bytes]]):
<span class="w"> </span>        &quot;&quot;&quot;Add or modify graftpoints.
<span class="gu">@@ -493,22 +895,45 @@ class BaseRepo:</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          updated_graftpoints: Dict of commit shas to list of parent shas
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Simple validation</span>
<span class="gi">+        for commit, parents in updated_graftpoints.items():</span>
<span class="gi">+            for sha in [commit, *parents]:</span>
<span class="gi">+                check_hexsha(sha, &quot;Invalid graftpoint&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._graftpoints.update(updated_graftpoints)</span>

<span class="gd">-    def _remove_graftpoints(self, to_remove: List[bytes]=[]) -&gt;None:</span>
<span class="gi">+    def _remove_graftpoints(self, to_remove: List[bytes] = []) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove graftpoints.

<span class="w"> </span>        Args:
<span class="w"> </span>          to_remove: List of commit shas
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def do_commit(self, message: Optional[bytes]=None, committer: Optional[</span>
<span class="gd">-        bytes]=None, author: Optional[bytes]=None, commit_timestamp=None,</span>
<span class="gd">-        commit_timezone=None, author_timestamp=None, author_timezone=None,</span>
<span class="gd">-        tree: Optional[ObjectID]=None, encoding: Optional[bytes]=None, ref:</span>
<span class="gd">-        Ref=b&#39;HEAD&#39;, merge_heads: Optional[List[ObjectID]]=None, no_verify:</span>
<span class="gd">-        bool=False, sign: bool=False):</span>
<span class="gi">+        for sha in to_remove:</span>
<span class="gi">+            del self._graftpoints[sha]</span>
<span class="gi">+</span>
<span class="gi">+    def _read_heads(self, name):</span>
<span class="gi">+        f = self.get_named_file(name)</span>
<span class="gi">+        if f is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        with f:</span>
<span class="gi">+            return [line.strip() for line in f.readlines() if line.strip()]</span>
<span class="gi">+</span>
<span class="gi">+    def do_commit(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: Optional[bytes] = None,</span>
<span class="gi">+        committer: Optional[bytes] = None,</span>
<span class="gi">+        author: Optional[bytes] = None,</span>
<span class="gi">+        commit_timestamp=None,</span>
<span class="gi">+        commit_timezone=None,</span>
<span class="gi">+        author_timestamp=None,</span>
<span class="gi">+        author_timezone=None,</span>
<span class="gi">+        tree: Optional[ObjectID] = None,</span>
<span class="gi">+        encoding: Optional[bytes] = None,</span>
<span class="gi">+        ref: Ref = b&quot;HEAD&quot;,</span>
<span class="gi">+        merge_heads: Optional[List[ObjectID]] = None,</span>
<span class="gi">+        no_verify: bool = False,</span>
<span class="gi">+        sign: bool = False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new commit.

<span class="w"> </span>        If not specified, committer and author default to
<span class="gu">@@ -538,7 +963,124 @@ class BaseRepo:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>          New commit SHA1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not no_verify:</span>
<span class="gi">+                self.hooks[&quot;pre-commit&quot;].execute()</span>
<span class="gi">+        except HookError as exc:</span>
<span class="gi">+            raise CommitError(exc) from exc</span>
<span class="gi">+        except KeyError:  # no hook defined, silent fallthrough</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        c = Commit()</span>
<span class="gi">+        if tree is None:</span>
<span class="gi">+            index = self.open_index()</span>
<span class="gi">+            c.tree = index.commit(self.object_store)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(tree) != 40:</span>
<span class="gi">+                raise ValueError(&quot;tree must be a 40-byte hex sha string&quot;)</span>
<span class="gi">+            c.tree = tree</span>
<span class="gi">+</span>
<span class="gi">+        config = self.get_config_stack()</span>
<span class="gi">+        if merge_heads is None:</span>
<span class="gi">+            merge_heads = self._read_heads(&quot;MERGE_HEAD&quot;)</span>
<span class="gi">+        if committer is None:</span>
<span class="gi">+            committer = get_user_identity(config, kind=&quot;COMMITTER&quot;)</span>
<span class="gi">+        check_user_identity(committer)</span>
<span class="gi">+        c.committer = committer</span>
<span class="gi">+        if commit_timestamp is None:</span>
<span class="gi">+            # FIXME: Support GIT_COMMITTER_DATE environment variable</span>
<span class="gi">+            commit_timestamp = time.time()</span>
<span class="gi">+        c.commit_time = int(commit_timestamp)</span>
<span class="gi">+        if commit_timezone is None:</span>
<span class="gi">+            # FIXME: Use current user timezone rather than UTC</span>
<span class="gi">+            commit_timezone = 0</span>
<span class="gi">+        c.commit_timezone = commit_timezone</span>
<span class="gi">+        if author is None:</span>
<span class="gi">+            author = get_user_identity(config, kind=&quot;AUTHOR&quot;)</span>
<span class="gi">+        c.author = author</span>
<span class="gi">+        check_user_identity(author)</span>
<span class="gi">+        if author_timestamp is None:</span>
<span class="gi">+            # FIXME: Support GIT_AUTHOR_DATE environment variable</span>
<span class="gi">+            author_timestamp = commit_timestamp</span>
<span class="gi">+        c.author_time = int(author_timestamp)</span>
<span class="gi">+        if author_timezone is None:</span>
<span class="gi">+            author_timezone = commit_timezone</span>
<span class="gi">+        c.author_timezone = author_timezone</span>
<span class="gi">+        if encoding is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                encoding = config.get((&quot;i18n&quot;,), &quot;commitEncoding&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass  # No dice</span>
<span class="gi">+        if encoding is not None:</span>
<span class="gi">+            c.encoding = encoding</span>
<span class="gi">+        if message is None:</span>
<span class="gi">+            # FIXME: Try to read commit message from .git/MERGE_MSG</span>
<span class="gi">+            raise ValueError(&quot;No commit message specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if no_verify:</span>
<span class="gi">+                c.message = message</span>
<span class="gi">+            else:</span>
<span class="gi">+                c.message = self.hooks[&quot;commit-msg&quot;].execute(message)</span>
<span class="gi">+                if c.message is None:</span>
<span class="gi">+                    c.message = message</span>
<span class="gi">+        except HookError as exc:</span>
<span class="gi">+            raise CommitError(exc) from exc</span>
<span class="gi">+        except KeyError:  # no hook defined, message not modified</span>
<span class="gi">+            c.message = message</span>
<span class="gi">+</span>
<span class="gi">+        keyid = sign if isinstance(sign, str) else None</span>
<span class="gi">+</span>
<span class="gi">+        if ref is None:</span>
<span class="gi">+            # Create a dangling commit</span>
<span class="gi">+            c.parents = merge_heads</span>
<span class="gi">+            if sign:</span>
<span class="gi">+                c.sign(keyid)</span>
<span class="gi">+            self.object_store.add_object(c)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                old_head = self.refs[ref]</span>
<span class="gi">+                c.parents = [old_head, *merge_heads]</span>
<span class="gi">+                if sign:</span>
<span class="gi">+                    c.sign(keyid)</span>
<span class="gi">+                self.object_store.add_object(c)</span>
<span class="gi">+                ok = self.refs.set_if_equals(</span>
<span class="gi">+                    ref,</span>
<span class="gi">+                    old_head,</span>
<span class="gi">+                    c.id,</span>
<span class="gi">+                    message=b&quot;commit: &quot; + message,</span>
<span class="gi">+                    committer=committer,</span>
<span class="gi">+                    timestamp=commit_timestamp,</span>
<span class="gi">+                    timezone=commit_timezone,</span>
<span class="gi">+                )</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                c.parents = merge_heads</span>
<span class="gi">+                if sign:</span>
<span class="gi">+                    c.sign(keyid)</span>
<span class="gi">+                self.object_store.add_object(c)</span>
<span class="gi">+                ok = self.refs.add_if_new(</span>
<span class="gi">+                    ref,</span>
<span class="gi">+                    c.id,</span>
<span class="gi">+                    message=b&quot;commit: &quot; + message,</span>
<span class="gi">+                    committer=committer,</span>
<span class="gi">+                    timestamp=commit_timestamp,</span>
<span class="gi">+                    timezone=commit_timezone,</span>
<span class="gi">+                )</span>
<span class="gi">+            if not ok:</span>
<span class="gi">+                # Fail if the atomic compare-and-swap failed, leaving the</span>
<span class="gi">+                # commit and all its objects as garbage.</span>
<span class="gi">+                raise CommitError(f&quot;{ref!r} changed during commit&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._del_named_file(&quot;MERGE_HEAD&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.hooks[&quot;post-commit&quot;].execute()</span>
<span class="gi">+        except HookError as e:  # silent failure</span>
<span class="gi">+            warnings.warn(f&quot;post-commit hook failed: {e}&quot;, UserWarning)</span>
<span class="gi">+        except KeyError:  # no hook defined, silent fallthrough</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return c.id</span>


<span class="w"> </span>def read_gitfile(f):
<span class="gu">@@ -550,20 +1092,23 @@ def read_gitfile(f):</span>
<span class="w"> </span>      f: File-like object to read from
<span class="w"> </span>    Returns: A path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = f.read()</span>
<span class="gi">+    if not cs.startswith(&quot;gitdir: &quot;):</span>
<span class="gi">+        raise ValueError(&quot;Expected file to start with &#39;gitdir: &#39;&quot;)</span>
<span class="gi">+    return cs[len(&quot;gitdir: &quot;) :].rstrip(&quot;\n&quot;)</span>


<span class="w"> </span>class UnsupportedVersion(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Unsupported repository version.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, version) -&gt;None:</span>
<span class="gi">+    def __init__(self, version) -&gt; None:</span>
<span class="w"> </span>        self.version = version


<span class="w"> </span>class UnsupportedExtension(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Unsupported repository extension.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, extension) -&gt;None:</span>
<span class="gi">+    def __init__(self, extension) -&gt; None:</span>
<span class="w"> </span>        self.extension = extension


<span class="gu">@@ -584,22 +1129,31 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>        directory (if the repository is bare)
<span class="w"> </span>      bare: Whether this is a bare repository
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    path: str
<span class="w"> </span>    bare: bool

<span class="gd">-    def __init__(self, root: str, object_store: Optional[</span>
<span class="gd">-        PackBasedObjectStore]=None, bare: Optional[bool]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        root: str,</span>
<span class="gi">+        object_store: Optional[PackBasedObjectStore] = None,</span>
<span class="gi">+        bare: Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        hidden_path = os.path.join(root, CONTROLDIR)
<span class="w"> </span>        if bare is None:
<span class="gd">-            if os.path.isfile(hidden_path) or os.path.isdir(os.path.join(</span>
<span class="gd">-                hidden_path, OBJECTDIR)):</span>
<span class="gi">+            if os.path.isfile(hidden_path) or os.path.isdir(</span>
<span class="gi">+                os.path.join(hidden_path, OBJECTDIR)</span>
<span class="gi">+            ):</span>
<span class="w"> </span>                bare = False
<span class="gd">-            elif os.path.isdir(os.path.join(root, OBJECTDIR)</span>
<span class="gd">-                ) and os.path.isdir(os.path.join(root, REFSDIR)):</span>
<span class="gi">+            elif os.path.isdir(os.path.join(root, OBJECTDIR)) and os.path.isdir(</span>
<span class="gi">+                os.path.join(root, REFSDIR)</span>
<span class="gi">+            ):</span>
<span class="w"> </span>                bare = True
<span class="w"> </span>            else:
<span class="gd">-                raise NotGitRepository(&#39;No git repository was found at {path}&#39;</span>
<span class="gd">-                    .format(**dict(path=root)))</span>
<span class="gi">+                raise NotGitRepository(</span>
<span class="gi">+                    &quot;No git repository was found at {path}&quot;.format(**dict(path=root))</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.bare = bare
<span class="w"> </span>        if bare is False:
<span class="w"> </span>            if os.path.isfile(hidden_path):
<span class="gu">@@ -613,48 +1167,85 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>        commondir = self.get_named_file(COMMONDIR)
<span class="w"> </span>        if commondir is not None:
<span class="w"> </span>            with commondir:
<span class="gd">-                self._commondir = os.path.join(self.controldir(), os.</span>
<span class="gd">-                    fsdecode(commondir.read().rstrip(b&#39;\r\n&#39;)))</span>
<span class="gi">+                self._commondir = os.path.join(</span>
<span class="gi">+                    self.controldir(),</span>
<span class="gi">+                    os.fsdecode(commondir.read().rstrip(b&quot;\r\n&quot;)),</span>
<span class="gi">+                )</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._commondir = self._controldir
<span class="w"> </span>        self.path = root
<span class="w"> </span>        config = self.get_config()
<span class="w"> </span>        try:
<span class="gd">-            repository_format_version = config.get(&#39;core&#39;,</span>
<span class="gd">-                &#39;repositoryformatversion&#39;)</span>
<span class="gd">-            format_version = 0 if repository_format_version is None else int(</span>
<span class="gd">-                repository_format_version)</span>
<span class="gi">+            repository_format_version = config.get(&quot;core&quot;, &quot;repositoryformatversion&quot;)</span>
<span class="gi">+            format_version = (</span>
<span class="gi">+                0</span>
<span class="gi">+                if repository_format_version is None</span>
<span class="gi">+                else int(repository_format_version)</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            format_version = 0
<span class="gi">+</span>
<span class="w"> </span>        if format_version not in (0, 1):
<span class="w"> </span>            raise UnsupportedVersion(format_version)
<span class="gd">-        for extension, _value in config.items((b&#39;extensions&#39;,)):</span>
<span class="gd">-            if extension.lower() not in (b&#39;worktreeconfig&#39;,):</span>
<span class="gi">+</span>
<span class="gi">+        for extension, _value in config.items((b&quot;extensions&quot;,)):</span>
<span class="gi">+            if extension.lower() not in (b&quot;worktreeconfig&quot;,):</span>
<span class="w"> </span>                raise UnsupportedExtension(extension)
<span class="gi">+</span>
<span class="w"> </span>        if object_store is None:
<span class="gd">-            object_store = DiskObjectStore.from_config(os.path.join(self.</span>
<span class="gd">-                commondir(), OBJECTDIR), config)</span>
<span class="gd">-        refs = DiskRefsContainer(self.commondir(), self._controldir, logger</span>
<span class="gd">-            =self._write_reflog)</span>
<span class="gi">+            object_store = DiskObjectStore.from_config(</span>
<span class="gi">+                os.path.join(self.commondir(), OBJECTDIR), config</span>
<span class="gi">+            )</span>
<span class="gi">+        refs = DiskRefsContainer(</span>
<span class="gi">+            self.commondir(), self._controldir, logger=self._write_reflog</span>
<span class="gi">+        )</span>
<span class="w"> </span>        BaseRepo.__init__(self, object_store, refs)
<span class="gi">+</span>
<span class="w"> </span>        self._graftpoints = {}
<span class="gd">-        graft_file = self.get_named_file(os.path.join(&#39;info&#39;, &#39;grafts&#39;),</span>
<span class="gd">-            basedir=self.commondir())</span>
<span class="gi">+        graft_file = self.get_named_file(</span>
<span class="gi">+            os.path.join(&quot;info&quot;, &quot;grafts&quot;), basedir=self.commondir()</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if graft_file:
<span class="w"> </span>            with graft_file:
<span class="w"> </span>                self._graftpoints.update(parse_graftpoints(graft_file))
<span class="gd">-        graft_file = self.get_named_file(&#39;shallow&#39;, basedir=self.commondir())</span>
<span class="gi">+        graft_file = self.get_named_file(&quot;shallow&quot;, basedir=self.commondir())</span>
<span class="w"> </span>        if graft_file:
<span class="w"> </span>            with graft_file:
<span class="w"> </span>                self._graftpoints.update(parse_graftpoints(graft_file))
<span class="gd">-        self.hooks[&#39;pre-commit&#39;] = PreCommitShellHook(self.path, self.</span>
<span class="gd">-            controldir())</span>
<span class="gd">-        self.hooks[&#39;commit-msg&#39;] = CommitMsgShellHook(self.controldir())</span>
<span class="gd">-        self.hooks[&#39;post-commit&#39;] = PostCommitShellHook(self.controldir())</span>
<span class="gd">-        self.hooks[&#39;post-receive&#39;] = PostReceiveShellHook(self.controldir())</span>
<span class="gi">+</span>
<span class="gi">+        self.hooks[&quot;pre-commit&quot;] = PreCommitShellHook(self.path, self.controldir())</span>
<span class="gi">+        self.hooks[&quot;commit-msg&quot;] = CommitMsgShellHook(self.controldir())</span>
<span class="gi">+        self.hooks[&quot;post-commit&quot;] = PostCommitShellHook(self.controldir())</span>
<span class="gi">+        self.hooks[&quot;post-receive&quot;] = PostReceiveShellHook(self.controldir())</span>
<span class="gi">+</span>
<span class="gi">+    def _write_reflog(</span>
<span class="gi">+        self, ref, old_sha, new_sha, committer, timestamp, timezone, message</span>
<span class="gi">+    ):</span>
<span class="gi">+        from .reflog import format_reflog_line</span>
<span class="gi">+</span>
<span class="gi">+        path = os.path.join(self.controldir(), &quot;logs&quot;, os.fsdecode(ref))</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.makedirs(os.path.dirname(path))</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        if committer is None:</span>
<span class="gi">+            config = self.get_config_stack()</span>
<span class="gi">+            committer = self._get_user_identity(config)</span>
<span class="gi">+        check_user_identity(committer)</span>
<span class="gi">+        if timestamp is None:</span>
<span class="gi">+            timestamp = int(time.time())</span>
<span class="gi">+        if timezone is None:</span>
<span class="gi">+            timezone = 0  # FIXME</span>
<span class="gi">+        with open(path, &quot;ab&quot;) as f:</span>
<span class="gi">+            f.write(</span>
<span class="gi">+                format_reflog_line(</span>
<span class="gi">+                    old_sha, new_sha, committer, timestamp, timezone, message</span>
<span class="gi">+                )</span>
<span class="gi">+                + b&quot;\n&quot;</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def discover(cls, start=&#39;.&#39;):</span>
<span class="gi">+    def discover(cls, start=&quot;.&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate parent directories to discover a repository.

<span class="w"> </span>        Return a Repo object for the first parent directory that looks like a
<span class="gu">@@ -663,11 +1254,20 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          start: The directory to start discovery from (defaults to &#39;.&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        remaining = True</span>
<span class="gi">+        path = os.path.abspath(start)</span>
<span class="gi">+        while remaining:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls(path)</span>
<span class="gi">+            except NotGitRepository:</span>
<span class="gi">+                path, remaining = os.path.split(path)</span>
<span class="gi">+        raise NotGitRepository(</span>
<span class="gi">+            &quot;No git repository was found at {path}&quot;.format(**dict(path=start))</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def controldir(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the path of the control directory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._controldir</span>

<span class="w"> </span>    def commondir(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the path of the common directory.
<span class="gu">@@ -677,21 +1277,38 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>        For a linked working tree, it is the control directory of the
<span class="w"> </span>        main working tree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._commondir</span>

<span class="w"> </span>    def _determine_file_mode(self):
<span class="w"> </span>        &quot;&quot;&quot;Probe the file-system to determine whether permissions can be trusted.

<span class="w"> </span>        Returns: True if permissions can be trusted, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fname = os.path.join(self.path, &quot;.probe-permissions&quot;)</span>
<span class="gi">+        with open(fname, &quot;w&quot;) as f:</span>
<span class="gi">+            f.write(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        st1 = os.lstat(fname)</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.chmod(fname, st1.st_mode ^ stat.S_IXUSR)</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        st2 = os.lstat(fname)</span>
<span class="gi">+</span>
<span class="gi">+        os.unlink(fname)</span>
<span class="gi">+</span>
<span class="gi">+        mode_differs = st1.st_mode != st2.st_mode</span>
<span class="gi">+        st2_has_exec = (st2.st_mode &amp; stat.S_IXUSR) != 0</span>
<span class="gi">+</span>
<span class="gi">+        return mode_differs and st2_has_exec</span>

<span class="w"> </span>    def _determine_symlinks(self):
<span class="w"> </span>        &quot;&quot;&quot;Probe the filesystem to determine whether symlinks can be created.

<span class="w"> </span>        Returns: True if symlinks can be created, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO(jelmer): Actually probe disk / look at filesystem</span>
<span class="gi">+        return sys.platform != &quot;win32&quot;</span>

<span class="w"> </span>    def _put_named_file(self, path, contents):
<span class="w"> </span>        &quot;&quot;&quot;Write a file to the control dir with the given name and contents.
<span class="gu">@@ -700,7 +1317,15 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          path: The path to the file, relative to the control dir.
<span class="w"> </span>          contents: A string to write to the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = path.lstrip(os.path.sep)</span>
<span class="gi">+        with GitFile(os.path.join(self.controldir(), path), &quot;wb&quot;) as f:</span>
<span class="gi">+            f.write(contents)</span>
<span class="gi">+</span>
<span class="gi">+    def _del_named_file(self, path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.unlink(os.path.join(self.controldir(), path))</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return</span>

<span class="w"> </span>    def get_named_file(self, path, basedir=None):
<span class="w"> </span>        &quot;&quot;&quot;Get a file from the control dir with a specific name.
<span class="gu">@@ -715,33 +1340,104 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>            control dir.
<span class="w"> </span>        Returns: An open file object, or None if the file does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO(dborowitz): sanitize filenames, since this is used directly by</span>
<span class="gi">+        # the dumb web serving code.</span>
<span class="gi">+        if basedir is None:</span>
<span class="gi">+            basedir = self.controldir()</span>
<span class="gi">+        path = path.lstrip(os.path.sep)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return open(os.path.join(basedir, path), &quot;rb&quot;)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def index_path(self):
<span class="w"> </span>        &quot;&quot;&quot;Return path to the index file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.join(self.controldir(), INDEX_FILENAME)</span>

<span class="gd">-    def open_index(self) -&gt;&#39;Index&#39;:</span>
<span class="gi">+    def open_index(self) -&gt; &quot;Index&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Open the index for this repository.

<span class="w"> </span>        Raises:
<span class="w"> </span>          NoIndexPresent: If no index is present
<span class="w"> </span>        Returns: The matching `Index`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .index import Index</span>
<span class="gi">+</span>
<span class="gi">+        if not self.has_index():</span>
<span class="gi">+            raise NoIndexPresent</span>
<span class="gi">+        return Index(self.index_path())</span>

<span class="w"> </span>    def has_index(self):
<span class="w"> </span>        &quot;&quot;&quot;Check if an index is present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def stage(self, fs_paths: Union[str, bytes, os.PathLike, Iterable[Union</span>
<span class="gd">-        [str, bytes, os.PathLike]]]) -&gt;None:</span>
<span class="gi">+        # Bare repos must never have index files; non-bare repos may have a</span>
<span class="gi">+        # missing index file, which is treated as empty.</span>
<span class="gi">+        return not self.bare</span>
<span class="gi">+</span>
<span class="gi">+    def stage(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fs_paths: Union[</span>
<span class="gi">+            str, bytes, os.PathLike, Iterable[Union[str, bytes, os.PathLike]]</span>
<span class="gi">+        ],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stage a set of paths.

<span class="w"> </span>        Args:
<span class="w"> </span>          fs_paths: List of paths, relative to the repository path
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        root_path_bytes = os.fsencode(self.path)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(fs_paths, (str, bytes, os.PathLike)):</span>
<span class="gi">+            fs_paths = [fs_paths]</span>
<span class="gi">+        fs_paths = list(fs_paths)</span>
<span class="gi">+</span>
<span class="gi">+        from .index import (</span>
<span class="gi">+            _fs_to_tree_path,</span>
<span class="gi">+            blob_from_path_and_stat,</span>
<span class="gi">+            index_entry_from_directory,</span>
<span class="gi">+            index_entry_from_stat,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        index = self.open_index()</span>
<span class="gi">+        blob_normalizer = self.get_blob_normalizer()</span>
<span class="gi">+        for fs_path in fs_paths:</span>
<span class="gi">+            if not isinstance(fs_path, bytes):</span>
<span class="gi">+                fs_path = os.fsencode(fs_path)</span>
<span class="gi">+            if os.path.isabs(fs_path):</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;path {fs_path!r} should be relative to &quot;</span>
<span class="gi">+                    &quot;repository root, not absolute&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            tree_path = _fs_to_tree_path(fs_path)</span>
<span class="gi">+            full_path = os.path.join(root_path_bytes, fs_path)</span>
<span class="gi">+            try:</span>
<span class="gi">+                st = os.lstat(full_path)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # File no longer exists</span>
<span class="gi">+                try:</span>
<span class="gi">+                    del index[tree_path]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass  # already removed</span>
<span class="gi">+            else:</span>
<span class="gi">+                if stat.S_ISDIR(st.st_mode):</span>
<span class="gi">+                    entry = index_entry_from_directory(st, full_path)</span>
<span class="gi">+                    if entry:</span>
<span class="gi">+                        index[tree_path] = entry</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            del index[tree_path]</span>
<span class="gi">+                        except KeyError:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                elif not stat.S_ISREG(st.st_mode) and not stat.S_ISLNK(st.st_mode):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        del index[tree_path]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    blob = blob_from_path_and_stat(full_path, st)</span>
<span class="gi">+                    blob = blob_normalizer.checkin_normalize(blob, fs_path)</span>
<span class="gi">+                    self.object_store.add_object(blob)</span>
<span class="gi">+                    index[tree_path] = index_entry_from_stat(st, blob.id)</span>
<span class="gi">+        index.write()</span>

<span class="w"> </span>    def unstage(self, fs_paths: List[str]):
<span class="w"> </span>        &quot;&quot;&quot;Unstage specific file in the index
<span class="gu">@@ -749,11 +1445,68 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          fs_paths: a list of files to unstage,
<span class="w"> </span>            relative to the repository path.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .index import IndexEntry, _fs_to_tree_path</span>
<span class="gi">+</span>
<span class="gi">+        index = self.open_index()</span>
<span class="gi">+        try:</span>
<span class="gi">+            tree_id = self[b&quot;HEAD&quot;].tree</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # no head mean no commit in the repo</span>
<span class="gi">+            for fs_path in fs_paths:</span>
<span class="gi">+                tree_path = _fs_to_tree_path(fs_path)</span>
<span class="gi">+                del index[tree_path]</span>
<span class="gi">+            index.write()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for fs_path in fs_paths:</span>
<span class="gi">+            tree_path = _fs_to_tree_path(fs_path)</span>
<span class="gi">+            try:</span>
<span class="gi">+                tree = self.object_store[tree_id]</span>
<span class="gi">+                assert isinstance(tree, Tree)</span>
<span class="gi">+                tree_entry = tree.lookup_path(self.object_store.__getitem__, tree_path)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # if tree_entry didn&#39;t exist, this file was being added, so</span>
<span class="gi">+                # remove index entry</span>
<span class="gi">+                try:</span>
<span class="gi">+                    del index[tree_path]</span>
<span class="gi">+                    continue</span>
<span class="gi">+                except KeyError as exc:</span>
<span class="gi">+                    raise KeyError(f&quot;file &#39;{tree_path.decode()}&#39; not in index&quot;) from exc</span>
<span class="gi">+</span>
<span class="gi">+            st = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                st = os.lstat(os.path.join(self.path, fs_path))</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                pass</span>

<span class="gd">-    def clone(self, target_path, *, mkdir=True, bare=False, origin=</span>
<span class="gd">-        b&#39;origin&#39;, checkout=None, branch=None, progress=None, depth=None,</span>
<span class="gd">-        symlinks=None) -&gt;&#39;Repo&#39;:</span>
<span class="gi">+            index_entry = IndexEntry(</span>
<span class="gi">+                ctime=(self[b&quot;HEAD&quot;].commit_time, 0),</span>
<span class="gi">+                mtime=(self[b&quot;HEAD&quot;].commit_time, 0),</span>
<span class="gi">+                dev=st.st_dev if st else 0,</span>
<span class="gi">+                ino=st.st_ino if st else 0,</span>
<span class="gi">+                mode=tree_entry[0],</span>
<span class="gi">+                uid=st.st_uid if st else 0,</span>
<span class="gi">+                gid=st.st_gid if st else 0,</span>
<span class="gi">+                size=len(self[tree_entry[1]].data),</span>
<span class="gi">+                sha=tree_entry[1],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            index[tree_path] = index_entry</span>
<span class="gi">+        index.write()</span>
<span class="gi">+</span>
<span class="gi">+    def clone(</span>
<span class="gi">+        self,</span>
<span class="gi">+        target_path,</span>
<span class="gi">+        *,</span>
<span class="gi">+        mkdir=True,</span>
<span class="gi">+        bare=False,</span>
<span class="gi">+        origin=b&quot;origin&quot;,</span>
<span class="gi">+        checkout=None,</span>
<span class="gi">+        branch=None,</span>
<span class="gi">+        progress=None,</span>
<span class="gi">+        depth=None,</span>
<span class="gi">+        symlinks=None,</span>
<span class="gi">+    ) -&gt; &quot;Repo&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clone this repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -770,32 +1523,157 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          symlinks: Symlinks setting (default to autodetect)
<span class="w"> </span>        Returns: Created repository as `Repo`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encoded_path = os.fsencode(self.path)</span>
<span class="gi">+</span>
<span class="gi">+        if mkdir:</span>
<span class="gi">+            os.mkdir(target_path)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not bare:</span>
<span class="gi">+                target = Repo.init(target_path, symlinks=symlinks)</span>
<span class="gi">+                if checkout is None:</span>
<span class="gi">+                    checkout = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                if checkout:</span>
<span class="gi">+                    raise ValueError(&quot;checkout and bare are incompatible&quot;)</span>
<span class="gi">+                target = Repo.init_bare(target_path)</span>

<span class="gd">-    def reset_index(self, tree: Optional[bytes]=None):</span>
<span class="gi">+            try:</span>
<span class="gi">+                target_config = target.get_config()</span>
<span class="gi">+                target_config.set((b&quot;remote&quot;, origin), b&quot;url&quot;, encoded_path)</span>
<span class="gi">+                target_config.set(</span>
<span class="gi">+                    (b&quot;remote&quot;, origin),</span>
<span class="gi">+                    b&quot;fetch&quot;,</span>
<span class="gi">+                    b&quot;+refs/heads/*:refs/remotes/&quot; + origin + b&quot;/*&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+                target_config.write_to_path()</span>
<span class="gi">+</span>
<span class="gi">+                ref_message = b&quot;clone: from &quot; + encoded_path</span>
<span class="gi">+                self.fetch(target, depth=depth)</span>
<span class="gi">+                target.refs.import_refs(</span>
<span class="gi">+                    b&quot;refs/remotes/&quot; + origin,</span>
<span class="gi">+                    self.refs.as_dict(b&quot;refs/heads&quot;),</span>
<span class="gi">+                    message=ref_message,</span>
<span class="gi">+                )</span>
<span class="gi">+                target.refs.import_refs(</span>
<span class="gi">+                    b&quot;refs/tags&quot;, self.refs.as_dict(b&quot;refs/tags&quot;), message=ref_message</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                head_chain, origin_sha = self.refs.follow(b&quot;HEAD&quot;)</span>
<span class="gi">+                origin_head = head_chain[-1] if head_chain else None</span>
<span class="gi">+                if origin_sha and not origin_head:</span>
<span class="gi">+                    # set detached HEAD</span>
<span class="gi">+                    target.refs[b&quot;HEAD&quot;] = origin_sha</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _set_origin_head(target.refs, origin, origin_head)</span>
<span class="gi">+                    head_ref = _set_default_branch(</span>
<span class="gi">+                        target.refs, origin, origin_head, branch, ref_message</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Update target head</span>
<span class="gi">+                    if head_ref:</span>
<span class="gi">+                        head = _set_head(target.refs, head_ref, ref_message)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        head = None</span>
<span class="gi">+</span>
<span class="gi">+                if checkout and head is not None:</span>
<span class="gi">+                    target.reset_index()</span>
<span class="gi">+            except BaseException:</span>
<span class="gi">+                target.close()</span>
<span class="gi">+                raise</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            if mkdir:</span>
<span class="gi">+                import shutil</span>
<span class="gi">+</span>
<span class="gi">+                shutil.rmtree(target_path)</span>
<span class="gi">+            raise</span>
<span class="gi">+        return target</span>
<span class="gi">+</span>
<span class="gi">+    def reset_index(self, tree: Optional[bytes] = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the index back to a specific tree.

<span class="w"> </span>        Args:
<span class="w"> </span>          tree: Tree SHA to reset to, None for current HEAD tree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .index import (</span>
<span class="gi">+            build_index_from_tree,</span>
<span class="gi">+            symlink,</span>
<span class="gi">+            validate_path_element_default,</span>
<span class="gi">+            validate_path_element_ntfs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if tree is None:</span>
<span class="gi">+            head = self[b&quot;HEAD&quot;]</span>
<span class="gi">+            if isinstance(head, Tag):</span>
<span class="gi">+                _cls, obj = head.object</span>
<span class="gi">+                head = self.get_object(obj)</span>
<span class="gi">+            tree = head.tree</span>
<span class="gi">+        config = self.get_config()</span>
<span class="gi">+        honor_filemode = config.get_boolean(b&quot;core&quot;, b&quot;filemode&quot;, os.name != &quot;nt&quot;)</span>
<span class="gi">+        if config.get_boolean(b&quot;core&quot;, b&quot;core.protectNTFS&quot;, os.name == &quot;nt&quot;):</span>
<span class="gi">+            validate_path_element = validate_path_element_ntfs</span>
<span class="gi">+        else:</span>
<span class="gi">+            validate_path_element = validate_path_element_default</span>
<span class="gi">+        if config.get_boolean(b&quot;core&quot;, b&quot;symlinks&quot;, True):</span>
<span class="gi">+            symlink_fn = symlink</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def symlink_fn(source, target):  # type: ignore</span>
<span class="gi">+                with open(</span>
<span class="gi">+                    target, &quot;w&quot; + (&quot;b&quot; if isinstance(source, bytes) else &quot;&quot;)</span>
<span class="gi">+                ) as f:</span>
<span class="gi">+                    f.write(source)</span>
<span class="gi">+</span>
<span class="gi">+        return build_index_from_tree(</span>
<span class="gi">+            self.path,</span>
<span class="gi">+            self.index_path(),</span>
<span class="gi">+            self.object_store,</span>
<span class="gi">+            tree,</span>
<span class="gi">+            honor_filemode=honor_filemode,</span>
<span class="gi">+            validate_path_element=validate_path_element,</span>
<span class="gi">+            symlink_fn=symlink_fn,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_worktree_config(self) -&gt; &quot;ConfigFile&quot;:</span>
<span class="gi">+        from .config import ConfigFile</span>
<span class="gi">+</span>
<span class="gi">+        path = os.path.join(self.commondir(), &quot;config.worktree&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ConfigFile.from_path(path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            cf = ConfigFile()</span>
<span class="gi">+            cf.path = path</span>
<span class="gi">+            return cf</span>

<span class="gd">-    def get_config(self) -&gt;&#39;ConfigFile&#39;:</span>
<span class="gi">+    def get_config(self) -&gt; &quot;ConfigFile&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the config object.

<span class="w"> </span>        Returns: `ConfigFile` object for the ``.git/config`` file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .config import ConfigFile</span>
<span class="gi">+</span>
<span class="gi">+        path = os.path.join(self._commondir, &quot;config&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ConfigFile.from_path(path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            ret = ConfigFile()</span>
<span class="gi">+            ret.path = path</span>
<span class="gi">+            return ret</span>

<span class="w"> </span>    def get_description(self):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the description of this repository.

<span class="w"> </span>        Returns: A string describing the repository or None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = os.path.join(self._controldir, &quot;description&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with GitFile(path, &quot;rb&quot;) as f:</span>
<span class="gi">+                return f.read()</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return None</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;Repo at {self.path!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;Repo at {self.path!r}&gt;&quot;</span>

<span class="w"> </span>    def set_description(self, description):
<span class="w"> </span>        &quot;&quot;&quot;Set the description for this repository.
<span class="gu">@@ -803,11 +1681,47 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          description: Text to set as description for this repository.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._put_named_file(&quot;description&quot;, description)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def init(cls, path: str, *, mkdir: bool=False, config=None,</span>
<span class="gd">-        default_branch=None, symlinks: Optional[bool]=None) -&gt;&#39;Repo&#39;:</span>
<span class="gi">+    def _init_maybe_bare(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        path,</span>
<span class="gi">+        controldir,</span>
<span class="gi">+        bare,</span>
<span class="gi">+        object_store=None,</span>
<span class="gi">+        config=None,</span>
<span class="gi">+        default_branch=None,</span>
<span class="gi">+        symlinks: Optional[bool] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        for d in BASE_DIRECTORIES:</span>
<span class="gi">+            os.mkdir(os.path.join(controldir, *d))</span>
<span class="gi">+        if object_store is None:</span>
<span class="gi">+            object_store = DiskObjectStore.init(os.path.join(controldir, OBJECTDIR))</span>
<span class="gi">+        ret = cls(path, bare=bare, object_store=object_store)</span>
<span class="gi">+        if default_branch is None:</span>
<span class="gi">+            if config is None:</span>
<span class="gi">+                from .config import StackedConfig</span>
<span class="gi">+</span>
<span class="gi">+                config = StackedConfig.default()</span>
<span class="gi">+            try:</span>
<span class="gi">+                default_branch = config.get(&quot;init&quot;, &quot;defaultBranch&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                default_branch = DEFAULT_BRANCH</span>
<span class="gi">+        ret.refs.set_symbolic_ref(b&quot;HEAD&quot;, LOCAL_BRANCH_PREFIX + default_branch)</span>
<span class="gi">+        ret._init_files(bare=bare, symlinks=symlinks)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def init(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        path: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        mkdir: bool = False,</span>
<span class="gi">+        config=None,</span>
<span class="gi">+        default_branch=None,</span>
<span class="gi">+        symlinks: Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; &quot;Repo&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -815,11 +1729,22 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          mkdir: Whether to create the directory
<span class="w"> </span>        Returns: `Repo` instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mkdir:</span>
<span class="gi">+            os.mkdir(path)</span>
<span class="gi">+        controldir = os.path.join(path, CONTROLDIR)</span>
<span class="gi">+        os.mkdir(controldir)</span>
<span class="gi">+        _set_filesystem_hidden(controldir)</span>
<span class="gi">+        return cls._init_maybe_bare(</span>
<span class="gi">+            path,</span>
<span class="gi">+            controldir,</span>
<span class="gi">+            False,</span>
<span class="gi">+            config=config,</span>
<span class="gi">+            default_branch=default_branch,</span>
<span class="gi">+            symlinks=symlinks,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _init_new_working_directory(cls, path, main_repo, identifier=None,</span>
<span class="gd">-        mkdir=False):</span>
<span class="gi">+    def _init_new_working_directory(cls, path, main_repo, identifier=None, mkdir=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new working directory linked to a repository.

<span class="w"> </span>        Args:
<span class="gu">@@ -829,11 +1754,37 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          mkdir: Whether to create the directory
<span class="w"> </span>        Returns: `Repo` instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mkdir:</span>
<span class="gi">+            os.mkdir(path)</span>
<span class="gi">+        if identifier is None:</span>
<span class="gi">+            identifier = os.path.basename(path)</span>
<span class="gi">+        main_worktreesdir = os.path.join(main_repo.controldir(), WORKTREES)</span>
<span class="gi">+        worktree_controldir = os.path.join(main_worktreesdir, identifier)</span>
<span class="gi">+        gitdirfile = os.path.join(path, CONTROLDIR)</span>
<span class="gi">+        with open(gitdirfile, &quot;wb&quot;) as f:</span>
<span class="gi">+            f.write(b&quot;gitdir: &quot; + os.fsencode(worktree_controldir) + b&quot;\n&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(main_worktreesdir)</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(worktree_controldir)</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        with open(os.path.join(worktree_controldir, GITDIR), &quot;wb&quot;) as f:</span>
<span class="gi">+            f.write(os.fsencode(gitdirfile) + b&quot;\n&quot;)</span>
<span class="gi">+        with open(os.path.join(worktree_controldir, COMMONDIR), &quot;wb&quot;) as f:</span>
<span class="gi">+            f.write(b&quot;../..\n&quot;)</span>
<span class="gi">+        with open(os.path.join(worktree_controldir, &quot;HEAD&quot;), &quot;wb&quot;) as f:</span>
<span class="gi">+            f.write(main_repo.head() + b&quot;\n&quot;)</span>
<span class="gi">+        r = cls(path)</span>
<span class="gi">+        r.reset_index()</span>
<span class="gi">+        return r</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def init_bare(cls, path, *, mkdir=False, object_store=None, config=None,</span>
<span class="gd">-        default_branch=None):</span>
<span class="gi">+    def init_bare(</span>
<span class="gi">+        cls, path, *, mkdir=False, object_store=None, config=None, default_branch=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new bare repository.

<span class="w"> </span>        ``path`` should already exist and be an empty directory.
<span class="gu">@@ -842,12 +1793,22 @@ class Repo(BaseRepo):</span>
<span class="w"> </span>          path: Path to create bare repository in
<span class="w"> </span>        Returns: a `Repo` instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mkdir:</span>
<span class="gi">+            os.mkdir(path)</span>
<span class="gi">+        return cls._init_maybe_bare(</span>
<span class="gi">+            path,</span>
<span class="gi">+            path,</span>
<span class="gi">+            True,</span>
<span class="gi">+            object_store=object_store,</span>
<span class="gi">+            config=config,</span>
<span class="gi">+            default_branch=default_branch,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    create = init_bare

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close any files opened by this repository.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.object_store.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -857,7 +1818,19 @@ class Repo(BaseRepo):</span>

<span class="w"> </span>    def get_blob_normalizer(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a BlobNormalizer object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO Parse the git attributes files</span>
<span class="gi">+        git_attributes = {}</span>
<span class="gi">+        config_stack = self.get_config_stack()</span>
<span class="gi">+        try:</span>
<span class="gi">+            tree = self.object_store[self.refs[b&quot;HEAD&quot;]].tree</span>
<span class="gi">+            return TreeBlobNormalizer(</span>
<span class="gi">+                config_stack,</span>
<span class="gi">+                git_attributes,</span>
<span class="gi">+                self.object_store,</span>
<span class="gi">+                tree,</span>
<span class="gi">+            )</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return BlobNormalizer(config_stack, git_attributes)</span>


<span class="w"> </span>class MemoryRepo(BaseRepo):
<span class="gu">@@ -867,29 +1840,39 @@ class MemoryRepo(BaseRepo):</span>
<span class="w"> </span>    those have a stronger dependency on the filesystem.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        from .config import ConfigFile
<span class="gi">+</span>
<span class="w"> </span>        self._reflog: List[Any] = []
<span class="w"> </span>        refs_container = DictRefsContainer({}, logger=self._append_reflog)
<span class="gd">-        BaseRepo.__init__(self, MemoryObjectStore(), refs_container)</span>
<span class="gi">+        BaseRepo.__init__(self, MemoryObjectStore(), refs_container)  # type: ignore</span>
<span class="w"> </span>        self._named_files: Dict[str, bytes] = {}
<span class="w"> </span>        self.bare = True
<span class="w"> </span>        self._config = ConfigFile()
<span class="w"> </span>        self._description = None

<span class="gi">+    def _append_reflog(self, *args):</span>
<span class="gi">+        self._reflog.append(args)</span>
<span class="gi">+</span>
<span class="gi">+    def set_description(self, description):</span>
<span class="gi">+        self._description = description</span>
<span class="gi">+</span>
<span class="gi">+    def get_description(self):</span>
<span class="gi">+        return self._description</span>
<span class="gi">+</span>
<span class="w"> </span>    def _determine_file_mode(self):
<span class="w"> </span>        &quot;&quot;&quot;Probe the file-system to determine whether permissions can be trusted.

<span class="w"> </span>        Returns: True if permissions can be trusted, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sys.platform != &quot;win32&quot;</span>

<span class="w"> </span>    def _determine_symlinks(self):
<span class="w"> </span>        &quot;&quot;&quot;Probe the file-system to determine whether permissions can be trusted.

<span class="w"> </span>        Returns: True if permissions can be trusted, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sys.platform != &quot;win32&quot;</span>

<span class="w"> </span>    def _put_named_file(self, path, contents):
<span class="w"> </span>        &quot;&quot;&quot;Write a file to the control dir with the given name and contents.
<span class="gu">@@ -898,7 +1881,13 @@ class MemoryRepo(BaseRepo):</span>
<span class="w"> </span>          path: The path to the file, relative to the control dir.
<span class="w"> </span>          contents: A string to write to the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._named_files[path] = contents</span>
<span class="gi">+</span>
<span class="gi">+    def _del_named_file(self, path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._named_files[path]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def get_named_file(self, path, basedir=None):
<span class="w"> </span>        &quot;&quot;&quot;Get a file from the control dir with a specific name.
<span class="gu">@@ -911,7 +1900,10 @@ class MemoryRepo(BaseRepo):</span>
<span class="w"> </span>          path: The path to the file, relative to the control dir.
<span class="w"> </span>        Returns: An open file object, or None if the file does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        contents = self._named_files.get(path, None)</span>
<span class="gi">+        if contents is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return BytesIO(contents)</span>

<span class="w"> </span>    def open_index(self):
<span class="w"> </span>        &quot;&quot;&quot;Fail to open index for this repo, since it is bare.
<span class="gu">@@ -919,14 +1911,14 @@ class MemoryRepo(BaseRepo):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          NoIndexPresent: Raised when no index is present
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NoIndexPresent</span>

<span class="w"> </span>    def get_config(self):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve the config object.

<span class="w"> </span>        Returns: `ConfigFile` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._config</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def init_bare(cls, objects, refs):
<span class="gu">@@ -938,4 +1930,10 @@ class MemoryRepo(BaseRepo):</span>
<span class="w"> </span>          refs: Refs as dictionary, mapping names
<span class="w"> </span>            to object SHA1s
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = cls()</span>
<span class="gi">+        for obj in objects:</span>
<span class="gi">+            ret.object_store.add_object(obj)</span>
<span class="gi">+        for refname, sha in refs.items():</span>
<span class="gi">+            ret.refs.add_if_new(refname, sha)</span>
<span class="gi">+        ret._init_files(bare=True)</span>
<span class="gi">+        return ret</span>
<span class="gh">diff --git a/dulwich/server.py b/dulwich/server.py</span>
<span class="gh">index 77efd9ac..281577fb 100644</span>
<span class="gd">--- a/dulwich/server.py</span>
<span class="gi">+++ b/dulwich/server.py</span>
<span class="gu">@@ -1,3 +1,24 @@</span>
<span class="gi">+# server.py -- Implementation of the server side git protocols</span>
<span class="gi">+# Copyright (C) 2008 John Carr &lt;john.carr@unrouted.co.uk&gt;</span>
<span class="gi">+# Copyright(C) 2011-2012 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Git smart network protocol server implementation.

<span class="w"> </span>For more detailed implementation on the network protocol, see the
<span class="gu">@@ -20,6 +41,7 @@ Currently supported capabilities:</span>
<span class="w"> </span> * shallow
<span class="w"> </span> * symref
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import os
<span class="w"> </span>import socket
<span class="gu">@@ -30,15 +52,68 @@ import zlib</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import Dict, Iterable, List, Optional, Set, Tuple, cast
<span class="w"> </span>from typing import Protocol as TypingProtocol
<span class="gi">+</span>
<span class="w"> </span>from dulwich import log_utils
<span class="gi">+</span>
<span class="w"> </span>from .archive import tar_stream
<span class="gd">-from .errors import ApplyDeltaError, ChecksumMismatch, GitProtocolError, HookError, NotGitRepository, ObjectFormatException, UnexpectedCommandError</span>
<span class="gi">+from .errors import (</span>
<span class="gi">+    ApplyDeltaError,</span>
<span class="gi">+    ChecksumMismatch,</span>
<span class="gi">+    GitProtocolError,</span>
<span class="gi">+    HookError,</span>
<span class="gi">+    NotGitRepository,</span>
<span class="gi">+    ObjectFormatException,</span>
<span class="gi">+    UnexpectedCommandError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .object_store import peel_sha
<span class="w"> </span>from .objects import Commit, ObjectID, valid_hexsha
<span class="w"> </span>from .pack import ObjectContainer, PackedObjectContainer, write_pack_from_container
<span class="gd">-from .protocol import CAPABILITIES_REF, CAPABILITY_AGENT, CAPABILITY_DELETE_REFS, CAPABILITY_INCLUDE_TAG, CAPABILITY_MULTI_ACK, CAPABILITY_MULTI_ACK_DETAILED, CAPABILITY_NO_DONE, CAPABILITY_NO_PROGRESS, CAPABILITY_OFS_DELTA, CAPABILITY_QUIET, CAPABILITY_REPORT_STATUS, CAPABILITY_SHALLOW, CAPABILITY_SIDE_BAND_64K, CAPABILITY_THIN_PACK, COMMAND_DEEPEN, COMMAND_DONE, COMMAND_HAVE, COMMAND_SHALLOW, COMMAND_UNSHALLOW, COMMAND_WANT, MULTI_ACK, MULTI_ACK_DETAILED, NAK_LINE, SIDE_BAND_CHANNEL_DATA, SIDE_BAND_CHANNEL_FATAL, SIDE_BAND_CHANNEL_PROGRESS, SINGLE_ACK, TCP_GIT_PORT, ZERO_SHA, BufferedPktLineWriter, Protocol, ReceivableProtocol, ack_type, capability_agent, extract_capabilities, extract_want_line_capabilities, format_ack_line, format_ref_line, format_shallow_line, format_unshallow_line, symref_capabilities</span>
<span class="gi">+from .protocol import (</span>
<span class="gi">+    CAPABILITIES_REF,</span>
<span class="gi">+    CAPABILITY_AGENT,</span>
<span class="gi">+    CAPABILITY_DELETE_REFS,</span>
<span class="gi">+    CAPABILITY_INCLUDE_TAG,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK,</span>
<span class="gi">+    CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gi">+    CAPABILITY_NO_DONE,</span>
<span class="gi">+    CAPABILITY_NO_PROGRESS,</span>
<span class="gi">+    CAPABILITY_OFS_DELTA,</span>
<span class="gi">+    CAPABILITY_QUIET,</span>
<span class="gi">+    CAPABILITY_REPORT_STATUS,</span>
<span class="gi">+    CAPABILITY_SHALLOW,</span>
<span class="gi">+    CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+    CAPABILITY_THIN_PACK,</span>
<span class="gi">+    COMMAND_DEEPEN,</span>
<span class="gi">+    COMMAND_DONE,</span>
<span class="gi">+    COMMAND_HAVE,</span>
<span class="gi">+    COMMAND_SHALLOW,</span>
<span class="gi">+    COMMAND_UNSHALLOW,</span>
<span class="gi">+    COMMAND_WANT,</span>
<span class="gi">+    MULTI_ACK,</span>
<span class="gi">+    MULTI_ACK_DETAILED,</span>
<span class="gi">+    NAK_LINE,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_DATA,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_FATAL,</span>
<span class="gi">+    SIDE_BAND_CHANNEL_PROGRESS,</span>
<span class="gi">+    SINGLE_ACK,</span>
<span class="gi">+    TCP_GIT_PORT,</span>
<span class="gi">+    ZERO_SHA,</span>
<span class="gi">+    BufferedPktLineWriter,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    ReceivableProtocol,</span>
<span class="gi">+    ack_type,</span>
<span class="gi">+    capability_agent,</span>
<span class="gi">+    extract_capabilities,</span>
<span class="gi">+    extract_want_line_capabilities,</span>
<span class="gi">+    format_ack_line,</span>
<span class="gi">+    format_ref_line,</span>
<span class="gi">+    format_shallow_line,</span>
<span class="gi">+    format_unshallow_line,</span>
<span class="gi">+    symref_capabilities,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .refs import PEELED_TAG_SUFFIX, RefsContainer, write_info_refs
<span class="w"> </span>from .repo import BaseRepo, Repo
<span class="gi">+</span>
<span class="w"> </span>logger = log_utils.getLogger(__name__)


<span class="gu">@@ -54,7 +129,7 @@ class Backend:</span>
<span class="w"> </span>          NotGitRepository: no git repository was found at path
<span class="w"> </span>        Returns: Instance of BackendRepo
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self.open_repository)</span>


<span class="w"> </span>class BackendRepo(TypingProtocol):
<span class="gu">@@ -63,17 +138,18 @@ class BackendRepo(TypingProtocol):</span>
<span class="w"> </span>    The methods required here are a subset of those provided by
<span class="w"> </span>    dulwich.repo.Repo.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    object_store: PackedObjectContainer
<span class="w"> </span>    refs: RefsContainer

<span class="gd">-    def get_refs(self) -&gt;Dict[bytes, bytes]:</span>
<span class="gi">+    def get_refs(self) -&gt; Dict[bytes, bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get all the refs in the repository.

<span class="w"> </span>        Returns: dict of name -&gt; sha
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def get_peeled(self, name: bytes) -&gt;Optional[bytes]:</span>
<span class="gi">+    def get_peeled(self, name: bytes) -&gt; Optional[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the cached peeled value of a ref, if available.

<span class="w"> </span>        Args:
<span class="gu">@@ -83,10 +159,11 @@ class BackendRepo(TypingProtocol):</span>
<span class="w"> </span>            information about a tag is available, this method may return None,
<span class="w"> </span>            but it should attempt to peel the tag if possible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="gd">-    def find_missing_objects(self, determine_wants, graph_walker, progress,</span>
<span class="gd">-        get_tagged=None):</span>
<span class="gi">+    def find_missing_objects(</span>
<span class="gi">+        self, determine_wants, graph_walker, progress, get_tagged=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield the objects required for a list of commits.

<span class="w"> </span>        Args:
<span class="gu">@@ -94,60 +171,167 @@ class BackendRepo(TypingProtocol):</span>
<span class="w"> </span>          get_tagged: Function that returns a dict of pointed-to sha -&gt;
<span class="w"> </span>            tag sha for including tags.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class DictBackend(Backend):
<span class="w"> </span>    &quot;&quot;&quot;Trivial backend that looks up Git repositories in a dictionary.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, repos) -&gt;None:</span>
<span class="gi">+    def __init__(self, repos) -&gt; None:</span>
<span class="w"> </span>        self.repos = repos

<span class="gi">+    def open_repository(self, path: str) -&gt; BaseRepo:</span>
<span class="gi">+        logger.debug(&quot;Opening repository at %s&quot;, path)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.repos[path]</span>
<span class="gi">+        except KeyError as exc:</span>
<span class="gi">+            raise NotGitRepository(</span>
<span class="gi">+                &quot;No git repository was found at {path}&quot;.format(**dict(path=path))</span>
<span class="gi">+            ) from exc</span>
<span class="gi">+</span>

<span class="w"> </span>class FileSystemBackend(Backend):
<span class="w"> </span>    &quot;&quot;&quot;Simple backend looking up Git repositories in the local file system.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, root=os.sep) -&gt;None:</span>
<span class="gi">+    def __init__(self, root=os.sep) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gd">-        self.root = (os.path.abspath(root) + os.sep).replace(os.sep * 2, os.sep</span>
<span class="gd">-            )</span>
<span class="gi">+        self.root = (os.path.abspath(root) + os.sep).replace(os.sep * 2, os.sep)</span>
<span class="gi">+</span>
<span class="gi">+    def open_repository(self, path):</span>
<span class="gi">+        logger.debug(&quot;opening repository at %s&quot;, path)</span>
<span class="gi">+        abspath = os.path.abspath(os.path.join(self.root, path)) + os.sep</span>
<span class="gi">+        normcase_abspath = os.path.normcase(abspath)</span>
<span class="gi">+        normcase_root = os.path.normcase(self.root)</span>
<span class="gi">+        if not normcase_abspath.startswith(normcase_root):</span>
<span class="gi">+            raise NotGitRepository(f&quot;Path {path!r} not inside root {self.root!r}&quot;)</span>
<span class="gi">+        return Repo(abspath)</span>


<span class="w"> </span>class Handler:
<span class="w"> </span>    &quot;&quot;&quot;Smart protocol command handler base class.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, backend, proto, stateless_rpc=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, backend, proto, stateless_rpc=False) -&gt; None:</span>
<span class="w"> </span>        self.backend = backend
<span class="w"> </span>        self.proto = proto
<span class="w"> </span>        self.stateless_rpc = stateless_rpc

<span class="gi">+    def handle(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(self.handle)</span>
<span class="gi">+</span>

<span class="w"> </span>class PackHandler(Handler):
<span class="w"> </span>    &quot;&quot;&quot;Protocol handler for packs.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, backend, proto, stateless_rpc=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, backend, proto, stateless_rpc=False) -&gt; None:</span>
<span class="w"> </span>        super().__init__(backend, proto, stateless_rpc)
<span class="w"> </span>        self._client_capabilities: Optional[Set[bytes]] = None
<span class="gi">+        # Flags needed for the no-done capability</span>
<span class="w"> </span>        self._done_received = False

<span class="w"> </span>    @classmethod
<span class="gd">-    def required_capabilities(cls) -&gt;Iterable[bytes]:</span>
<span class="gi">+    def capabilities(cls) -&gt; Iterable[bytes]:</span>
<span class="gi">+        raise NotImplementedError(cls.capabilities)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def innocuous_capabilities(cls) -&gt; Iterable[bytes]:</span>
<span class="gi">+        return [</span>
<span class="gi">+            CAPABILITY_INCLUDE_TAG,</span>
<span class="gi">+            CAPABILITY_THIN_PACK,</span>
<span class="gi">+            CAPABILITY_NO_PROGRESS,</span>
<span class="gi">+            CAPABILITY_OFS_DELTA,</span>
<span class="gi">+            capability_agent(),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def required_capabilities(cls) -&gt; Iterable[bytes]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of capabilities that we require the client to have.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def set_client_capabilities(self, caps: Iterable[bytes]) -&gt; None:</span>
<span class="gi">+        allowable_caps = set(self.innocuous_capabilities())</span>
<span class="gi">+        allowable_caps.update(self.capabilities())</span>
<span class="gi">+        for cap in caps:</span>
<span class="gi">+            if cap.startswith(CAPABILITY_AGENT + b&quot;=&quot;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if cap not in allowable_caps:</span>
<span class="gi">+                raise GitProtocolError(</span>
<span class="gi">+                    f&quot;Client asked for capability {cap!r} that &quot; &quot;was not advertised.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        for cap in self.required_capabilities():</span>
<span class="gi">+            if cap not in caps:</span>
<span class="gi">+                raise GitProtocolError(</span>
<span class="gi">+                    &quot;Client does not support required &quot; f&quot;capability {cap!r}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        self._client_capabilities = set(caps)</span>
<span class="gi">+        logger.info(&quot;Client capabilities: %s&quot;, caps)</span>
<span class="gi">+</span>
<span class="gi">+    def has_capability(self, cap: bytes) -&gt; bool:</span>
<span class="gi">+        if self._client_capabilities is None:</span>
<span class="gi">+            raise GitProtocolError(</span>
<span class="gi">+                f&quot;Server attempted to access capability {cap!r} &quot; &quot;before asking client&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return cap in self._client_capabilities</span>
<span class="gi">+</span>
<span class="gi">+    def notify_done(self) -&gt; None:</span>
<span class="gi">+        self._done_received = True</span>


<span class="w"> </span>class UploadPackHandler(PackHandler):
<span class="w"> </span>    &quot;&quot;&quot;Protocol handler for uploading a pack to the client.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, backend, args, proto, stateless_rpc=False,</span>
<span class="gd">-        advertise_refs=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, backend, args, proto, stateless_rpc=False, advertise_refs=False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(backend, proto, stateless_rpc=stateless_rpc)
<span class="w"> </span>        self.repo = backend.open_repository(args[0])
<span class="w"> </span>        self._graph_walker = None
<span class="w"> </span>        self.advertise_refs = advertise_refs
<span class="gi">+        # A state variable for denoting that the have list is still</span>
<span class="gi">+        # being processed, and the client is not accepting any other</span>
<span class="gi">+        # data (such as side-band, see the progress method here).</span>
<span class="w"> </span>        self._processing_have_lines = False

<span class="gd">-    def get_tagged(self, refs=None, repo=None) -&gt;Dict[ObjectID, ObjectID]:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def capabilities(cls):</span>
<span class="gi">+        return [</span>
<span class="gi">+            CAPABILITY_MULTI_ACK_DETAILED,</span>
<span class="gi">+            CAPABILITY_MULTI_ACK,</span>
<span class="gi">+            CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+            CAPABILITY_THIN_PACK,</span>
<span class="gi">+            CAPABILITY_OFS_DELTA,</span>
<span class="gi">+            CAPABILITY_NO_PROGRESS,</span>
<span class="gi">+            CAPABILITY_INCLUDE_TAG,</span>
<span class="gi">+            CAPABILITY_SHALLOW,</span>
<span class="gi">+            CAPABILITY_NO_DONE,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def required_capabilities(cls):</span>
<span class="gi">+        return (</span>
<span class="gi">+            CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+            CAPABILITY_THIN_PACK,</span>
<span class="gi">+            CAPABILITY_OFS_DELTA,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def progress(self, message: bytes):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _start_pack_send_phase(self):</span>
<span class="gi">+        if self.has_capability(CAPABILITY_SIDE_BAND_64K):</span>
<span class="gi">+            # The provided haves are processed, and it is safe to send side-</span>
<span class="gi">+            # band data now.</span>
<span class="gi">+            if not self.has_capability(CAPABILITY_NO_PROGRESS):</span>
<span class="gi">+                self.progress = partial(</span>
<span class="gi">+                    self.proto.write_sideband, SIDE_BAND_CHANNEL_PROGRESS</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            self.write_pack_data = partial(</span>
<span class="gi">+                self.proto.write_sideband, SIDE_BAND_CHANNEL_DATA</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write_pack_data = self.proto.write</span>
<span class="gi">+</span>
<span class="gi">+    def get_tagged(self, refs=None, repo=None) -&gt; Dict[ObjectID, ObjectID]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a dict of peeled values of tags to their original tag shas.

<span class="w"> </span>        Args:
<span class="gu">@@ -158,7 +342,78 @@ class UploadPackHandler(PackHandler):</span>
<span class="w"> </span>        Returns: dict of peeled_sha -&gt; tag_sha, where tag_sha is the sha of a
<span class="w"> </span>            tag whose peeled value is peeled_sha.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.has_capability(CAPABILITY_INCLUDE_TAG):</span>
<span class="gi">+            return {}</span>
<span class="gi">+        if refs is None:</span>
<span class="gi">+            refs = self.repo.get_refs()</span>
<span class="gi">+        if repo is None:</span>
<span class="gi">+            repo = getattr(self.repo, &quot;repo&quot;, None)</span>
<span class="gi">+            if repo is None:</span>
<span class="gi">+                # Bail if we don&#39;t have a Repo available; this is ok since</span>
<span class="gi">+                # clients must be able to handle if the server doesn&#39;t include</span>
<span class="gi">+                # all relevant tags.</span>
<span class="gi">+                # TODO: fix behavior when missing</span>
<span class="gi">+                return {}</span>
<span class="gi">+        # TODO(jelmer): Integrate this with the refs logic in</span>
<span class="gi">+        # Repo.find_missing_objects</span>
<span class="gi">+        tagged = {}</span>
<span class="gi">+        for name, sha in refs.items():</span>
<span class="gi">+            peeled_sha = repo.get_peeled(name)</span>
<span class="gi">+            if peeled_sha != sha:</span>
<span class="gi">+                tagged[peeled_sha] = sha</span>
<span class="gi">+        return tagged</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self):</span>
<span class="gi">+        # Note the fact that client is only processing responses related</span>
<span class="gi">+        # to the have lines it sent, and any other data (including side-</span>
<span class="gi">+        # band) will be be considered a fatal error.</span>
<span class="gi">+        self._processing_have_lines = True</span>
<span class="gi">+</span>
<span class="gi">+        graph_walker = _ProtocolGraphWalker(</span>
<span class="gi">+            self,</span>
<span class="gi">+            self.repo.object_store,</span>
<span class="gi">+            self.repo.get_peeled,</span>
<span class="gi">+            self.repo.refs.get_symrefs,</span>
<span class="gi">+        )</span>
<span class="gi">+        wants = []</span>
<span class="gi">+</span>
<span class="gi">+        def wants_wrapper(refs, **kwargs):</span>
<span class="gi">+            wants.extend(graph_walker.determine_wants(refs, **kwargs))</span>
<span class="gi">+            return wants</span>
<span class="gi">+</span>
<span class="gi">+        missing_objects = self.repo.find_missing_objects(</span>
<span class="gi">+            wants_wrapper,</span>
<span class="gi">+            graph_walker,</span>
<span class="gi">+            self.progress,</span>
<span class="gi">+            get_tagged=self.get_tagged,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        object_ids = list(missing_objects)</span>
<span class="gi">+</span>
<span class="gi">+        # Did the process short-circuit (e.g. in a stateless RPC call)? Note</span>
<span class="gi">+        # that the client still expects a 0-object pack in most cases.</span>
<span class="gi">+        # Also, if it also happens that the object_iter is instantiated</span>
<span class="gi">+        # with a graph walker with an implementation that talks over the</span>
<span class="gi">+        # wire (which is this instance of this class) this will actually</span>
<span class="gi">+        # iterate through everything and write things out to the wire.</span>
<span class="gi">+        if len(wants) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not graph_walker.handle_done(</span>
<span class="gi">+            not self.has_capability(CAPABILITY_NO_DONE), self._done_received</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._start_pack_send_phase()</span>
<span class="gi">+        self.progress(</span>
<span class="gi">+            (&quot;counting objects: %d, done.\n&quot; % len(object_ids)).encode(&quot;ascii&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        write_pack_from_container(</span>
<span class="gi">+            self.write_pack_data, self.repo.object_store, object_ids</span>
<span class="gi">+        )</span>
<span class="gi">+        # we are done</span>
<span class="gi">+        self.proto.write_pkt_line(None)</span>


<span class="w"> </span>def _split_proto_line(line, allowed):
<span class="gu">@@ -180,7 +435,28 @@ def _split_proto_line(line, allowed):</span>
<span class="w"> </span>      UnexpectedCommandError: if the line cannot be parsed into one of the
<span class="w"> </span>        allowed return values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not line:</span>
<span class="gi">+        fields = [None]</span>
<span class="gi">+    else:</span>
<span class="gi">+        fields = line.rstrip(b&quot;\n&quot;).split(b&quot; &quot;, 1)</span>
<span class="gi">+    command = fields[0]</span>
<span class="gi">+    if allowed is not None and command not in allowed:</span>
<span class="gi">+        raise UnexpectedCommandError(command)</span>
<span class="gi">+    if len(fields) == 1 and command in (COMMAND_DONE, None):</span>
<span class="gi">+        return (command, None)</span>
<span class="gi">+    elif len(fields) == 2:</span>
<span class="gi">+        if command in (</span>
<span class="gi">+            COMMAND_WANT,</span>
<span class="gi">+            COMMAND_HAVE,</span>
<span class="gi">+            COMMAND_SHALLOW,</span>
<span class="gi">+            COMMAND_UNSHALLOW,</span>
<span class="gi">+        ):</span>
<span class="gi">+            if not valid_hexsha(fields[1]):</span>
<span class="gi">+                raise GitProtocolError(&quot;Invalid sha&quot;)</span>
<span class="gi">+            return tuple(fields)</span>
<span class="gi">+        elif command == COMMAND_DEEPEN:</span>
<span class="gi">+            return command, int(fields[1])</span>
<span class="gi">+    raise GitProtocolError(f&quot;Received invalid line from client: {line!r}&quot;)</span>


<span class="w"> </span>def _find_shallow(store: ObjectContainer, heads, depth):
<span class="gu">@@ -195,7 +471,56 @@ def _find_shallow(store: ObjectContainer, heads, depth):</span>
<span class="w"> </span>        considered shallow and unshallow according to the arguments. Note that
<span class="w"> </span>        these sets may overlap if a commit is reachable along multiple paths.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parents: Dict[bytes, List[bytes]] = {}</span>
<span class="gi">+</span>
<span class="gi">+    def get_parents(sha):</span>
<span class="gi">+        result = parents.get(sha, None)</span>
<span class="gi">+        if not result:</span>
<span class="gi">+            result = store[sha].parents</span>
<span class="gi">+            parents[sha] = result</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    todo = []  # stack of (sha, depth)</span>
<span class="gi">+    for head_sha in heads:</span>
<span class="gi">+        _unpeeled, peeled = peel_sha(store, head_sha)</span>
<span class="gi">+        if isinstance(peeled, Commit):</span>
<span class="gi">+            todo.append((peeled.id, 1))</span>
<span class="gi">+</span>
<span class="gi">+    not_shallow = set()</span>
<span class="gi">+    shallow = set()</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        sha, cur_depth = todo.pop()</span>
<span class="gi">+        if cur_depth &lt; depth:</span>
<span class="gi">+            not_shallow.add(sha)</span>
<span class="gi">+            new_depth = cur_depth + 1</span>
<span class="gi">+            todo.extend((p, new_depth) for p in get_parents(sha))</span>
<span class="gi">+        else:</span>
<span class="gi">+            shallow.add(sha)</span>
<span class="gi">+</span>
<span class="gi">+    return shallow, not_shallow</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _want_satisfied(store: ObjectContainer, haves, want, earliest):</span>
<span class="gi">+    o = store[want]</span>
<span class="gi">+    pending = collections.deque([o])</span>
<span class="gi">+    known = {want}</span>
<span class="gi">+    while pending:</span>
<span class="gi">+        commit = pending.popleft()</span>
<span class="gi">+        if commit.id in haves:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if not isinstance(commit, Commit):</span>
<span class="gi">+            # non-commit wants are assumed to be satisfied</span>
<span class="gi">+            continue</span>
<span class="gi">+        for parent in commit.parents:</span>
<span class="gi">+            if parent in known:</span>
<span class="gi">+                continue</span>
<span class="gi">+            known.add(parent)</span>
<span class="gi">+            parent_obj = store[parent]</span>
<span class="gi">+            assert isinstance(parent_obj, Commit)</span>
<span class="gi">+            # TODO: handle parents with later commit times than children</span>
<span class="gi">+            if parent_obj.commit_time &gt;= earliest:</span>
<span class="gi">+                pending.append(parent_obj)</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _all_wants_satisfied(store: ObjectContainer, haves, wants):
<span class="gu">@@ -208,7 +533,17 @@ def _all_wants_satisfied(store: ObjectContainer, haves, wants):</span>
<span class="w"> </span>    Note: Wants are specified with set_wants rather than passed in since
<span class="w"> </span>        in the current interface they are determined outside this class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    haves = set(haves)</span>
<span class="gi">+    if haves:</span>
<span class="gi">+        have_objs = [store[h] for h in haves]</span>
<span class="gi">+        earliest = min([h.commit_time for h in have_objs if isinstance(h, Commit)])</span>
<span class="gi">+    else:</span>
<span class="gi">+        earliest = 0</span>
<span class="gi">+    for want in wants:</span>
<span class="gi">+        if not _want_satisfied(store, haves, want, earliest):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class _ProtocolGraphWalker:
<span class="gu">@@ -225,8 +560,9 @@ class _ProtocolGraphWalker:</span>
<span class="w"> </span>    any calls to next() or ack() are made.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, handler, object_store: ObjectContainer, get_peeled,</span>
<span class="gd">-        get_symrefs) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, handler, object_store: ObjectContainer, get_peeled, get_symrefs</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.handler = handler
<span class="w"> </span>        self.store: ObjectContainer = object_store
<span class="w"> </span>        self.get_peeled = get_peeled
<span class="gu">@@ -261,7 +597,97 @@ class _ProtocolGraphWalker:</span>
<span class="w"> </span>          heads: a dict of refname-&gt;SHA1 to advertise
<span class="w"> </span>        Returns: a list of SHA1s requested by the client
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        symrefs = self.get_symrefs()</span>
<span class="gi">+        values = set(heads.values())</span>
<span class="gi">+        if self.advertise_refs or not self.stateless_rpc:</span>
<span class="gi">+            for i, (ref, sha) in enumerate(sorted(heads.items())):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    peeled_sha = self.get_peeled(ref)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    # Skip refs that are inaccessible</span>
<span class="gi">+                    # TODO(jelmer): Integrate with Repo.find_missing_objects refs</span>
<span class="gi">+                    # logic.</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if i == 0:</span>
<span class="gi">+                    logger.info(&quot;Sending capabilities: %s&quot;, self.handler.capabilities())</span>
<span class="gi">+                    line = format_ref_line(</span>
<span class="gi">+                        ref,</span>
<span class="gi">+                        sha,</span>
<span class="gi">+                        self.handler.capabilities()</span>
<span class="gi">+                        + symref_capabilities(symrefs.items()),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    line = format_ref_line(ref, sha)</span>
<span class="gi">+                self.proto.write_pkt_line(line)</span>
<span class="gi">+                if peeled_sha != sha:</span>
<span class="gi">+                    self.proto.write_pkt_line(</span>
<span class="gi">+                        format_ref_line(ref + PEELED_TAG_SUFFIX, peeled_sha)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            # i&#39;m done..</span>
<span class="gi">+            self.proto.write_pkt_line(None)</span>
<span class="gi">+</span>
<span class="gi">+            if self.advertise_refs:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+        # Now client will sending want want want commands</span>
<span class="gi">+        want = self.proto.read_pkt_line()</span>
<span class="gi">+        if not want:</span>
<span class="gi">+            return []</span>
<span class="gi">+        line, caps = extract_want_line_capabilities(want)</span>
<span class="gi">+        self.handler.set_client_capabilities(caps)</span>
<span class="gi">+        self.set_ack_type(ack_type(caps))</span>
<span class="gi">+        allowed = (COMMAND_WANT, COMMAND_SHALLOW, COMMAND_DEEPEN, None)</span>
<span class="gi">+        command, sha = _split_proto_line(line, allowed)</span>
<span class="gi">+</span>
<span class="gi">+        want_revs = []</span>
<span class="gi">+        while command == COMMAND_WANT:</span>
<span class="gi">+            if sha not in values:</span>
<span class="gi">+                raise GitProtocolError(f&quot;Client wants invalid object {sha}&quot;)</span>
<span class="gi">+            want_revs.append(sha)</span>
<span class="gi">+            command, sha = self.read_proto_line(allowed)</span>
<span class="gi">+</span>
<span class="gi">+        self.set_wants(want_revs)</span>
<span class="gi">+        if command in (COMMAND_SHALLOW, COMMAND_DEEPEN):</span>
<span class="gi">+            self.unread_proto_line(command, sha)</span>
<span class="gi">+            self._handle_shallow_request(want_revs)</span>
<span class="gi">+</span>
<span class="gi">+        if self.stateless_rpc and self.proto.eof():</span>
<span class="gi">+            # The client may close the socket at this point, expecting a</span>
<span class="gi">+            # flush-pkt from the server. We might be ready to send a packfile</span>
<span class="gi">+            # at this point, so we need to explicitly short-circuit in this</span>
<span class="gi">+            # case.</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        return want_revs</span>
<span class="gi">+</span>
<span class="gi">+    def unread_proto_line(self, command, value):</span>
<span class="gi">+        if isinstance(value, int):</span>
<span class="gi">+            value = str(value).encode(&quot;ascii&quot;)</span>
<span class="gi">+        self.proto.unread_pkt_line(command + b&quot; &quot; + value)</span>
<span class="gi">+</span>
<span class="gi">+    def nak(self):</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def ack(self, have_ref):</span>
<span class="gi">+        if len(have_ref) != 40:</span>
<span class="gi">+            raise ValueError(f&quot;invalid sha {have_ref!r}&quot;)</span>
<span class="gi">+        return self._impl.ack(have_ref)</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self):</span>
<span class="gi">+        self._cached = True</span>
<span class="gi">+        self._cache_index = 0</span>
<span class="gi">+</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        if not self._cached:</span>
<span class="gi">+            if not self._impl and self.stateless_rpc:</span>
<span class="gi">+                return None</span>
<span class="gi">+            return next(self._impl)</span>
<span class="gi">+        self._cache_index += 1</span>
<span class="gi">+        if self._cache_index &gt; len(self._cache):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._cache[self._cache_index]</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next

<span class="w"> </span>    def read_proto_line(self, allowed):
<span class="gu">@@ -274,7 +700,48 @@ class _ProtocolGraphWalker:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>          UnexpectedCommandError: If an error occurred reading the line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _split_proto_line(self.proto.read_pkt_line(), allowed)</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_shallow_request(self, wants):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            command, val = self.read_proto_line((COMMAND_DEEPEN, COMMAND_SHALLOW))</span>
<span class="gi">+            if command == COMMAND_DEEPEN:</span>
<span class="gi">+                depth = val</span>
<span class="gi">+                break</span>
<span class="gi">+            self.client_shallow.add(val)</span>
<span class="gi">+        self.read_proto_line((None,))  # consume client&#39;s flush-pkt</span>
<span class="gi">+</span>
<span class="gi">+        shallow, not_shallow = _find_shallow(self.store, wants, depth)</span>
<span class="gi">+</span>
<span class="gi">+        # Update self.shallow instead of reassigning it since we passed a</span>
<span class="gi">+        # reference to it before this method was called.</span>
<span class="gi">+        self.shallow.update(shallow - not_shallow)</span>
<span class="gi">+        new_shallow = self.shallow - self.client_shallow</span>
<span class="gi">+        unshallow = self.unshallow = not_shallow &amp; self.client_shallow</span>
<span class="gi">+</span>
<span class="gi">+        for sha in sorted(new_shallow):</span>
<span class="gi">+            self.proto.write_pkt_line(format_shallow_line(sha))</span>
<span class="gi">+        for sha in sorted(unshallow):</span>
<span class="gi">+            self.proto.write_pkt_line(format_unshallow_line(sha))</span>
<span class="gi">+</span>
<span class="gi">+        self.proto.write_pkt_line(None)</span>
<span class="gi">+</span>
<span class="gi">+    def notify_done(self):</span>
<span class="gi">+        # relay the message down to the handler.</span>
<span class="gi">+        self.handler.notify_done()</span>
<span class="gi">+</span>
<span class="gi">+    def send_ack(self, sha, ack_type=b&quot;&quot;):</span>
<span class="gi">+        self.proto.write_pkt_line(format_ack_line(sha, ack_type))</span>
<span class="gi">+</span>
<span class="gi">+    def send_nak(self):</span>
<span class="gi">+        self.proto.write_pkt_line(NAK_LINE)</span>
<span class="gi">+</span>
<span class="gi">+    def handle_done(self, done_required, done_received):</span>
<span class="gi">+        # Delegate this to the implementation.</span>
<span class="gi">+        return self._impl.handle_done(done_required, done_received)</span>
<span class="gi">+</span>
<span class="gi">+    def set_wants(self, wants):</span>
<span class="gi">+        self._wants = wants</span>

<span class="w"> </span>    def all_wants_satisfied(self, haves):
<span class="w"> </span>        &quot;&quot;&quot;Check whether all the current wants are satisfied by a set of haves.
<span class="gu">@@ -284,92 +751,483 @@ class _ProtocolGraphWalker:</span>
<span class="w"> </span>        Note: Wants are specified with set_wants rather than passed in since
<span class="w"> </span>            in the current interface they are determined outside this class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _all_wants_satisfied(self.store, haves, self._wants)</span>
<span class="gi">+</span>
<span class="gi">+    def set_ack_type(self, ack_type):</span>
<span class="gi">+        impl_classes = {</span>
<span class="gi">+            MULTI_ACK: MultiAckGraphWalkerImpl,</span>
<span class="gi">+            MULTI_ACK_DETAILED: MultiAckDetailedGraphWalkerImpl,</span>
<span class="gi">+            SINGLE_ACK: SingleAckGraphWalkerImpl,</span>
<span class="gi">+        }</span>
<span class="gi">+        self._impl = impl_classes[ack_type](self)</span>


<span class="gd">-_GRAPH_WALKER_COMMANDS = COMMAND_HAVE, COMMAND_DONE, None</span>
<span class="gi">+_GRAPH_WALKER_COMMANDS = (COMMAND_HAVE, COMMAND_DONE, None)</span>


<span class="w"> </span>class SingleAckGraphWalkerImpl:
<span class="w"> </span>    &quot;&quot;&quot;Graph walker implementation that speaks the single-ack protocol.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, walker) -&gt;None:</span>
<span class="gi">+    def __init__(self, walker) -&gt; None:</span>
<span class="w"> </span>        self.walker = walker
<span class="w"> </span>        self._common: List[bytes] = []
<span class="gi">+</span>
<span class="gi">+    def ack(self, have_ref):</span>
<span class="gi">+        if not self._common:</span>
<span class="gi">+            self.walker.send_ack(have_ref)</span>
<span class="gi">+            self._common.append(have_ref)</span>
<span class="gi">+</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)</span>
<span class="gi">+        if command in (None, COMMAND_DONE):</span>
<span class="gi">+            # defer the handling of done</span>
<span class="gi">+            self.walker.notify_done()</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif command == COMMAND_HAVE:</span>
<span class="gi">+            return sha</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next

<span class="gi">+    def handle_done(self, done_required, done_received):</span>
<span class="gi">+        if not self._common:</span>
<span class="gi">+            self.walker.send_nak()</span>
<span class="gi">+</span>
<span class="gi">+        if done_required and not done_received:</span>
<span class="gi">+            # we are not done, especially when done is required; skip</span>
<span class="gi">+            # the pack for this request and especially do not handle</span>
<span class="gi">+            # the done.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if not done_received and not self._common:</span>
<span class="gi">+            # Okay we are not actually done then since the walker picked</span>
<span class="gi">+            # up no haves.  This is usually triggered when client attempts</span>
<span class="gi">+            # to pull from a source that has no common base_commit.</span>
<span class="gi">+            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\</span>
<span class="gi">+            #          test_multi_ack_stateless_nodone</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class MultiAckGraphWalkerImpl:
<span class="w"> </span>    &quot;&quot;&quot;Graph walker implementation that speaks the multi-ack protocol.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, walker) -&gt;None:</span>
<span class="gi">+    def __init__(self, walker) -&gt; None:</span>
<span class="w"> </span>        self.walker = walker
<span class="w"> </span>        self._found_base = False
<span class="w"> </span>        self._common: List[bytes] = []
<span class="gi">+</span>
<span class="gi">+    def ack(self, have_ref):</span>
<span class="gi">+        self._common.append(have_ref)</span>
<span class="gi">+        if not self._found_base:</span>
<span class="gi">+            self.walker.send_ack(have_ref, b&quot;continue&quot;)</span>
<span class="gi">+            if self.walker.all_wants_satisfied(self._common):</span>
<span class="gi">+                self._found_base = True</span>
<span class="gi">+        # else we blind ack within next</span>
<span class="gi">+</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)</span>
<span class="gi">+            if command is None:</span>
<span class="gi">+                self.walker.send_nak()</span>
<span class="gi">+                # in multi-ack mode, a flush-pkt indicates the client wants to</span>
<span class="gi">+                # flush but more have lines are still coming</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif command == COMMAND_DONE:</span>
<span class="gi">+                self.walker.notify_done()</span>
<span class="gi">+                return None</span>
<span class="gi">+            elif command == COMMAND_HAVE:</span>
<span class="gi">+                if self._found_base:</span>
<span class="gi">+                    # blind ack</span>
<span class="gi">+                    self.walker.send_ack(sha, b&quot;continue&quot;)</span>
<span class="gi">+                return sha</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next

<span class="gi">+    def handle_done(self, done_required, done_received):</span>
<span class="gi">+        if done_required and not done_received:</span>
<span class="gi">+            # we are not done, especially when done is required; skip</span>
<span class="gi">+            # the pack for this request and especially do not handle</span>
<span class="gi">+            # the done.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if not done_received and not self._common:</span>
<span class="gi">+            # Okay we are not actually done then since the walker picked</span>
<span class="gi">+            # up no haves.  This is usually triggered when client attempts</span>
<span class="gi">+            # to pull from a source that has no common base_commit.</span>
<span class="gi">+            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\</span>
<span class="gi">+            #          test_multi_ack_stateless_nodone</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # don&#39;t nak unless no common commits were found, even if not</span>
<span class="gi">+        # everything is satisfied</span>
<span class="gi">+        if self._common:</span>
<span class="gi">+            self.walker.send_ack(self._common[-1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.walker.send_nak()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class MultiAckDetailedGraphWalkerImpl:
<span class="w"> </span>    &quot;&quot;&quot;Graph walker implementation speaking the multi-ack-detailed protocol.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, walker) -&gt;None:</span>
<span class="gi">+    def __init__(self, walker) -&gt; None:</span>
<span class="w"> </span>        self.walker = walker
<span class="w"> </span>        self._common: List[bytes] = []
<span class="gi">+</span>
<span class="gi">+    def ack(self, have_ref):</span>
<span class="gi">+        # Should only be called iff have_ref is common</span>
<span class="gi">+        self._common.append(have_ref)</span>
<span class="gi">+        self.walker.send_ack(have_ref, b&quot;common&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)</span>
<span class="gi">+            if command is None:</span>
<span class="gi">+                if self.walker.all_wants_satisfied(self._common):</span>
<span class="gi">+                    self.walker.send_ack(self._common[-1], b&quot;ready&quot;)</span>
<span class="gi">+                self.walker.send_nak()</span>
<span class="gi">+                if self.walker.stateless_rpc:</span>
<span class="gi">+                    # The HTTP version of this request a flush-pkt always</span>
<span class="gi">+                    # signifies an end of request, so we also return</span>
<span class="gi">+                    # nothing here as if we are done (but not really, as</span>
<span class="gi">+                    # it depends on whether no-done capability was</span>
<span class="gi">+                    # specified and that&#39;s handled in handle_done which</span>
<span class="gi">+                    # may or may not call post_nodone_check depending on</span>
<span class="gi">+                    # that).</span>
<span class="gi">+                    return None</span>
<span class="gi">+            elif command == COMMAND_DONE:</span>
<span class="gi">+                # Let the walker know that we got a done.</span>
<span class="gi">+                self.walker.notify_done()</span>
<span class="gi">+                break</span>
<span class="gi">+            elif command == COMMAND_HAVE:</span>
<span class="gi">+                # return the sha and let the caller ACK it with the</span>
<span class="gi">+                # above ack method.</span>
<span class="gi">+                return sha</span>
<span class="gi">+        # don&#39;t nak unless no common commits were found, even if not</span>
<span class="gi">+        # everything is satisfied</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next

<span class="gi">+    def handle_done(self, done_required, done_received):</span>
<span class="gi">+        if done_required and not done_received:</span>
<span class="gi">+            # we are not done, especially when done is required; skip</span>
<span class="gi">+            # the pack for this request and especially do not handle</span>
<span class="gi">+            # the done.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if not done_received and not self._common:</span>
<span class="gi">+            # Okay we are not actually done then since the walker picked</span>
<span class="gi">+            # up no haves.  This is usually triggered when client attempts</span>
<span class="gi">+            # to pull from a source that has no common base_commit.</span>
<span class="gi">+            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\</span>
<span class="gi">+            #          test_multi_ack_stateless_nodone</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # don&#39;t nak unless no common commits were found, even if not</span>
<span class="gi">+        # everything is satisfied</span>
<span class="gi">+        if self._common:</span>
<span class="gi">+            self.walker.send_ack(self._common[-1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.walker.send_nak()</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class ReceivePackHandler(PackHandler):
<span class="w"> </span>    &quot;&quot;&quot;Protocol handler for downloading a pack from the client.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, backend, args, proto, stateless_rpc=False,</span>
<span class="gd">-        advertise_refs=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, backend, args, proto, stateless_rpc=False, advertise_refs=False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(backend, proto, stateless_rpc=stateless_rpc)
<span class="w"> </span>        self.repo = backend.open_repository(args[0])
<span class="w"> </span>        self.advertise_refs = advertise_refs

<span class="gi">+    @classmethod</span>
<span class="gi">+    def capabilities(cls) -&gt; Iterable[bytes]:</span>
<span class="gi">+        return [</span>
<span class="gi">+            CAPABILITY_REPORT_STATUS,</span>
<span class="gi">+            CAPABILITY_DELETE_REFS,</span>
<span class="gi">+            CAPABILITY_QUIET,</span>
<span class="gi">+            CAPABILITY_OFS_DELTA,</span>
<span class="gi">+            CAPABILITY_SIDE_BAND_64K,</span>
<span class="gi">+            CAPABILITY_NO_DONE,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_pack(</span>
<span class="gi">+        self, refs: List[Tuple[bytes, bytes, bytes]]</span>
<span class="gi">+    ) -&gt; List[Tuple[bytes, bytes]]:</span>
<span class="gi">+        all_exceptions = (</span>
<span class="gi">+            IOError,</span>
<span class="gi">+            OSError,</span>
<span class="gi">+            ChecksumMismatch,</span>
<span class="gi">+            ApplyDeltaError,</span>
<span class="gi">+            AssertionError,</span>
<span class="gi">+            socket.error,</span>
<span class="gi">+            zlib.error,</span>
<span class="gi">+            ObjectFormatException,</span>
<span class="gi">+        )</span>
<span class="gi">+        status = []</span>
<span class="gi">+        will_send_pack = False</span>
<span class="gi">+</span>
<span class="gi">+        for command in refs:</span>
<span class="gi">+            if command[1] != ZERO_SHA:</span>
<span class="gi">+                will_send_pack = True</span>
<span class="gi">+</span>
<span class="gi">+        if will_send_pack:</span>
<span class="gi">+            # TODO: more informative error messages than just the exception</span>
<span class="gi">+            # string</span>
<span class="gi">+            try:</span>
<span class="gi">+                recv = getattr(self.proto, &quot;recv&quot;, None)</span>
<span class="gi">+                self.repo.object_store.add_thin_pack(self.proto.read, recv)</span>
<span class="gi">+                status.append((b&quot;unpack&quot;, b&quot;ok&quot;))</span>
<span class="gi">+            except all_exceptions as e:</span>
<span class="gi">+                status.append((b&quot;unpack&quot;, str(e).replace(&quot;\n&quot;, &quot;&quot;).encode(&quot;utf-8&quot;)))</span>
<span class="gi">+                # The pack may still have been moved in, but it may contain</span>
<span class="gi">+                # broken objects. We trust a later GC to clean it up.</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The git protocol want to find a status entry related to unpack</span>
<span class="gi">+            # process even if no pack data has been sent.</span>
<span class="gi">+            status.append((b&quot;unpack&quot;, b&quot;ok&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        for oldsha, sha, ref in refs:</span>
<span class="gi">+            ref_status = b&quot;ok&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                if sha == ZERO_SHA:</span>
<span class="gi">+                    if CAPABILITY_DELETE_REFS not in self.capabilities():</span>
<span class="gi">+                        raise GitProtocolError(</span>
<span class="gi">+                            &quot;Attempted to delete refs without delete-refs &quot;</span>
<span class="gi">+                            &quot;capability.&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        self.repo.refs.remove_if_equals(ref, oldsha)</span>
<span class="gi">+                    except all_exceptions:</span>
<span class="gi">+                        ref_status = b&quot;failed to delete&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        self.repo.refs.set_if_equals(ref, oldsha, sha)</span>
<span class="gi">+                    except all_exceptions:</span>
<span class="gi">+                        ref_status = b&quot;failed to write&quot;</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                ref_status = b&quot;bad ref&quot;</span>
<span class="gi">+            status.append((ref, ref_status))</span>
<span class="gi">+</span>
<span class="gi">+        return status</span>
<span class="gi">+</span>
<span class="gi">+    def _report_status(self, status: List[Tuple[bytes, bytes]]) -&gt; None:</span>
<span class="gi">+        if self.has_capability(CAPABILITY_SIDE_BAND_64K):</span>
<span class="gi">+            writer = BufferedPktLineWriter(</span>
<span class="gi">+                lambda d: self.proto.write_sideband(SIDE_BAND_CHANNEL_DATA, d)</span>
<span class="gi">+            )</span>
<span class="gi">+            write = writer.write</span>
<span class="gi">+</span>
<span class="gi">+            def flush():</span>
<span class="gi">+                writer.flush()</span>
<span class="gi">+                self.proto.write_pkt_line(None)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            write = self.proto.write_pkt_line</span>
<span class="gi">+</span>
<span class="gi">+            def flush():</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        for name, msg in status:</span>
<span class="gi">+            if name == b&quot;unpack&quot;:</span>
<span class="gi">+                write(b&quot;unpack &quot; + msg + b&quot;\n&quot;)</span>
<span class="gi">+            elif msg == b&quot;ok&quot;:</span>
<span class="gi">+                write(b&quot;ok &quot; + name + b&quot;\n&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                write(b&quot;ng &quot; + name + b&quot; &quot; + msg + b&quot;\n&quot;)</span>
<span class="gi">+        write(None)</span>
<span class="gi">+        flush()</span>
<span class="gi">+</span>
<span class="gi">+    def _on_post_receive(self, client_refs):</span>
<span class="gi">+        hook = self.repo.hooks.get(&quot;post-receive&quot;, None)</span>
<span class="gi">+        if not hook:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            output = hook.execute(client_refs)</span>
<span class="gi">+            if output:</span>
<span class="gi">+                self.proto.write_sideband(SIDE_BAND_CHANNEL_PROGRESS, output)</span>
<span class="gi">+        except HookError as err:</span>
<span class="gi">+            self.proto.write_sideband(SIDE_BAND_CHANNEL_FATAL, str(err).encode(&quot;utf-8&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self) -&gt; None:</span>
<span class="gi">+        if self.advertise_refs or not self.stateless_rpc:</span>
<span class="gi">+            refs = sorted(self.repo.get_refs().items())</span>
<span class="gi">+            symrefs = sorted(self.repo.refs.get_symrefs().items())</span>
<span class="gi">+</span>
<span class="gi">+            if not refs:</span>
<span class="gi">+                refs = [(CAPABILITIES_REF, ZERO_SHA)]</span>
<span class="gi">+            logger.info(&quot;Sending capabilities: %s&quot;, self.capabilities())</span>
<span class="gi">+            self.proto.write_pkt_line(</span>
<span class="gi">+                format_ref_line(</span>
<span class="gi">+                    refs[0][0],</span>
<span class="gi">+                    refs[0][1],</span>
<span class="gi">+                    self.capabilities() + symref_capabilities(symrefs),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            for i in range(1, len(refs)):</span>
<span class="gi">+                ref = refs[i]</span>
<span class="gi">+                self.proto.write_pkt_line(format_ref_line(ref[0], ref[1]))</span>

<span class="gd">-class UploadArchiveHandler(Handler):</span>
<span class="gi">+            self.proto.write_pkt_line(None)</span>
<span class="gi">+            if self.advertise_refs:</span>
<span class="gi">+                return</span>

<span class="gd">-    def __init__(self, backend, args, proto, stateless_rpc=False) -&gt;None:</span>
<span class="gi">+        client_refs = []</span>
<span class="gi">+        ref = self.proto.read_pkt_line()</span>
<span class="gi">+</span>
<span class="gi">+        # if ref is none then client doesn&#39;t want to send us anything..</span>
<span class="gi">+        if ref is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        ref, caps = extract_capabilities(ref)</span>
<span class="gi">+        self.set_client_capabilities(caps)</span>
<span class="gi">+</span>
<span class="gi">+        # client will now send us a list of (oldsha, newsha, ref)</span>
<span class="gi">+        while ref:</span>
<span class="gi">+            client_refs.append(ref.split())</span>
<span class="gi">+            ref = self.proto.read_pkt_line()</span>
<span class="gi">+</span>
<span class="gi">+        # backend can now deal with this refs and read a pack using self.read</span>
<span class="gi">+        status = self._apply_pack(client_refs)</span>
<span class="gi">+</span>
<span class="gi">+        self._on_post_receive(client_refs)</span>
<span class="gi">+</span>
<span class="gi">+        # when we have read all the pack from the client, send a status report</span>
<span class="gi">+        # if the client asked for it</span>
<span class="gi">+        if self.has_capability(CAPABILITY_REPORT_STATUS):</span>
<span class="gi">+            self._report_status(status)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class UploadArchiveHandler(Handler):</span>
<span class="gi">+    def __init__(self, backend, args, proto, stateless_rpc=False) -&gt; None:</span>
<span class="w"> </span>        super().__init__(backend, proto, stateless_rpc)
<span class="w"> </span>        self.repo = backend.open_repository(args[0])

<span class="gd">-</span>
<span class="gd">-DEFAULT_HANDLERS = {b&#39;git-upload-pack&#39;: UploadPackHandler,</span>
<span class="gd">-    b&#39;git-receive-pack&#39;: ReceivePackHandler, b&#39;git-upload-archive&#39;:</span>
<span class="gd">-    UploadArchiveHandler}</span>
<span class="gi">+    def handle(self) -&gt; None:</span>
<span class="gi">+        def write(x):</span>
<span class="gi">+            return self.proto.write_sideband(SIDE_BAND_CHANNEL_DATA, x)</span>
<span class="gi">+</span>
<span class="gi">+        arguments = []</span>
<span class="gi">+        for pkt in self.proto.read_pkt_seq():</span>
<span class="gi">+            (key, value) = pkt.split(b&quot; &quot;, 1)</span>
<span class="gi">+            if key != b&quot;argument&quot;:</span>
<span class="gi">+                raise GitProtocolError(f&quot;unknown command {key}&quot;)</span>
<span class="gi">+            arguments.append(value.rstrip(b&quot;\n&quot;))</span>
<span class="gi">+        prefix = b&quot;&quot;</span>
<span class="gi">+        format = &quot;tar&quot;</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        store: ObjectContainer = self.repo.object_store</span>
<span class="gi">+        while i &lt; len(arguments):</span>
<span class="gi">+            argument = arguments[i]</span>
<span class="gi">+            if argument == b&quot;--prefix&quot;:</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                prefix = arguments[i]</span>
<span class="gi">+            elif argument == b&quot;--format&quot;:</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                format = arguments[i].decode(&quot;ascii&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                commit_sha = self.repo.refs[argument]</span>
<span class="gi">+                tree = store[cast(Commit, store[commit_sha]).tree]</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        self.proto.write_pkt_line(b&quot;ACK&quot;)</span>
<span class="gi">+        self.proto.write_pkt_line(None)</span>
<span class="gi">+        for chunk in tar_stream(</span>
<span class="gi">+            store, tree, mtime=time.time(), prefix=prefix, format=format</span>
<span class="gi">+        ):</span>
<span class="gi">+            write(chunk)</span>
<span class="gi">+        self.proto.write_pkt_line(None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Default handler classes for git services.</span>
<span class="gi">+DEFAULT_HANDLERS = {</span>
<span class="gi">+    b&quot;git-upload-pack&quot;: UploadPackHandler,</span>
<span class="gi">+    b&quot;git-receive-pack&quot;: ReceivePackHandler,</span>
<span class="gi">+    b&quot;git-upload-archive&quot;: UploadArchiveHandler,</span>
<span class="gi">+}</span>


<span class="w"> </span>class TCPGitRequestHandler(socketserver.StreamRequestHandler):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, handlers, *args, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, handlers, *args, **kwargs) -&gt; None:</span>
<span class="w"> </span>        self.handlers = handlers
<span class="w"> </span>        socketserver.StreamRequestHandler.__init__(self, *args, **kwargs)

<span class="gi">+    def handle(self):</span>
<span class="gi">+        proto = ReceivableProtocol(self.connection.recv, self.wfile.write)</span>
<span class="gi">+        command, args = proto.read_cmd()</span>
<span class="gi">+        logger.info(&quot;Handling %s request, args=%s&quot;, command, args)</span>
<span class="gi">+</span>
<span class="gi">+        cls = self.handlers.get(command, None)</span>
<span class="gi">+        if not callable(cls):</span>
<span class="gi">+            raise GitProtocolError(f&quot;Invalid service {command}&quot;)</span>
<span class="gi">+        h = cls(self.server.backend, args, proto)</span>
<span class="gi">+        h.handle()</span>
<span class="gi">+</span>

<span class="w"> </span>class TCPGitServer(socketserver.TCPServer):
<span class="w"> </span>    allow_reuse_address = True
<span class="w"> </span>    serve = socketserver.TCPServer.serve_forever

<span class="gd">-    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _make_handler(self, *args, **kwargs):</span>
<span class="gi">+        return TCPGitRequestHandler(self.handlers, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None) -&gt; None:</span>
<span class="w"> </span>        self.handlers = dict(DEFAULT_HANDLERS)
<span class="w"> </span>        if handlers is not None:
<span class="w"> </span>            self.handlers.update(handlers)
<span class="w"> </span>        self.backend = backend
<span class="gd">-        logger.info(&#39;Listening for TCP connections on %s:%d&#39;, listen_addr, port</span>
<span class="gd">-            )</span>
<span class="gd">-        socketserver.TCPServer.__init__(self, (listen_addr, port), self.</span>
<span class="gd">-            _make_handler)</span>
<span class="gi">+        logger.info(&quot;Listening for TCP connections on %s:%d&quot;, listen_addr, port)</span>
<span class="gi">+        socketserver.TCPServer.__init__(self, (listen_addr, port), self._make_handler)</span>

<span class="gi">+    def verify_request(self, request, client_address):</span>
<span class="gi">+        logger.info(&quot;Handling request from %s&quot;, client_address)</span>
<span class="gi">+        return True</span>

<span class="gd">-def main(argv=sys.argv):</span>
<span class="gd">-    &quot;&quot;&quot;Entry point for starting a TCP git server.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    def handle_error(self, request, client_address):</span>
<span class="gi">+        logger.exception(</span>
<span class="gi">+            &quot;Exception happened during processing of request &quot; &quot;from %s&quot;,</span>
<span class="gi">+            client_address,</span>
<span class="gi">+        )</span>


<span class="gd">-def serve_command(handler_cls, argv=sys.argv, backend=None, inf=sys.stdin,</span>
<span class="gd">-    outf=sys.stdout):</span>
<span class="gi">+def main(argv=sys.argv):</span>
<span class="gi">+    &quot;&quot;&quot;Entry point for starting a TCP git server.&quot;&quot;&quot;</span>
<span class="gi">+    import optparse</span>
<span class="gi">+</span>
<span class="gi">+    parser = optparse.OptionParser()</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-l&quot;,</span>
<span class="gi">+        &quot;--listen_address&quot;,</span>
<span class="gi">+        dest=&quot;listen_address&quot;,</span>
<span class="gi">+        default=&quot;localhost&quot;,</span>
<span class="gi">+        help=&quot;Binding IP address.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-p&quot;,</span>
<span class="gi">+        &quot;--port&quot;,</span>
<span class="gi">+        dest=&quot;port&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=TCP_GIT_PORT,</span>
<span class="gi">+        help=&quot;Binding TCP port.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options, args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+    log_utils.default_logging_config()</span>
<span class="gi">+    if len(args) &gt; 1:</span>
<span class="gi">+        gitdir = args[1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        gitdir = &quot;.&quot;</span>
<span class="gi">+    # TODO(jelmer): Support git-daemon-export-ok and --export-all.</span>
<span class="gi">+    backend = FileSystemBackend(gitdir)</span>
<span class="gi">+    server = TCPGitServer(backend, options.listen_address, options.port)</span>
<span class="gi">+    server.serve_forever()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def serve_command(</span>
<span class="gi">+    handler_cls, argv=sys.argv, backend=None, inf=sys.stdin, outf=sys.stdout</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Serve a single command.

<span class="w"> </span>    This is mostly useful for the implementation of commands used by e.g.
<span class="gu">@@ -383,17 +1241,30 @@ def serve_command(handler_cls, argv=sys.argv, backend=None, inf=sys.stdin,</span>
<span class="w"> </span>      outf: File-like object to write to, defaults to standard output.
<span class="w"> </span>    Returns: Exit code for use with sys.exit. 0 on success, 1 on failure.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if backend is None:</span>
<span class="gi">+        backend = FileSystemBackend()</span>
<span class="gi">+</span>
<span class="gi">+    def send_fn(data):</span>
<span class="gi">+        outf.write(data)</span>
<span class="gi">+        outf.flush()</span>
<span class="gi">+</span>
<span class="gi">+    proto = Protocol(inf.read, send_fn)</span>
<span class="gi">+    handler = handler_cls(backend, argv[1:], proto)</span>
<span class="gi">+    # FIXME: Catch exceptions and write a single-line summary to outf.</span>
<span class="gi">+    handler.handle()</span>
<span class="gi">+    return 0</span>


<span class="w"> </span>def generate_info_refs(repo):
<span class="w"> </span>    &quot;&quot;&quot;Generate an info refs file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refs = repo.get_refs()</span>
<span class="gi">+    return write_info_refs(refs, repo.object_store)</span>


<span class="w"> </span>def generate_objects_info_packs(repo):
<span class="w"> </span>    &quot;&quot;&quot;Generate an index for for packs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for pack in repo.object_store.packs:</span>
<span class="gi">+        yield (b&quot;P &quot; + os.fsencode(pack.data.filename) + b&quot;\n&quot;)</span>


<span class="w"> </span>def update_server_info(repo):
<span class="gu">@@ -402,8 +1273,15 @@ def update_server_info(repo):</span>
<span class="w"> </span>    This generates info/refs and objects/info/packs,
<span class="w"> </span>    similar to &quot;git update-server-info&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    repo._put_named_file(</span>
<span class="gi">+        os.path.join(&quot;info&quot;, &quot;refs&quot;), b&quot;&quot;.join(generate_info_refs(repo))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    repo._put_named_file(</span>
<span class="gi">+        os.path.join(&quot;objects&quot;, &quot;info&quot;, &quot;packs&quot;),</span>
<span class="gi">+        b&quot;&quot;.join(generate_objects_info_packs(repo)),</span>
<span class="gi">+    )</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/dulwich/stash.py b/dulwich/stash.py</span>
<span class="gh">index c4d9b763..0b577241 100644</span>
<span class="gd">--- a/dulwich/stash.py</span>
<span class="gi">+++ b/dulwich/stash.py</span>
<span class="gu">@@ -1,9 +1,32 @@</span>
<span class="gi">+# stash.py</span>
<span class="gi">+# Copyright (C) 2018 Jelmer Vernooij &lt;jelmer@samba.org&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Stash handling.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from .file import GitFile
<span class="w"> </span>from .index import commit_tree, iter_fresh_objects
<span class="w"> </span>from .reflog import drop_reflog_entry, read_reflog
<span class="gd">-DEFAULT_STASH_REF = b&#39;refs/stash&#39;</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_STASH_REF = b&quot;refs/stash&quot;</span>


<span class="w"> </span>class Stash:
<span class="gu">@@ -12,18 +35,39 @@ class Stash:</span>
<span class="w"> </span>    Note that this doesn&#39;t currently update the working tree.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, repo, ref=DEFAULT_STASH_REF) -&gt;None:</span>
<span class="gi">+    def __init__(self, repo, ref=DEFAULT_STASH_REF) -&gt; None:</span>
<span class="w"> </span>        self._ref = ref
<span class="w"> </span>        self._repo = repo

<span class="gi">+    @property</span>
<span class="gi">+    def _reflog_path(self):</span>
<span class="gi">+        return os.path.join(self._repo.commondir(), &quot;logs&quot;, os.fsdecode(self._ref))</span>
<span class="gi">+</span>
<span class="gi">+    def stashes(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            with GitFile(self._reflog_path, &quot;rb&quot;) as f:</span>
<span class="gi">+                return reversed(list(read_reflog(f)))</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_repo(cls, repo):
<span class="w"> </span>        &quot;&quot;&quot;Create a new stash from a Repo object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(repo)</span>

<span class="w"> </span>    def drop(self, index):
<span class="w"> </span>        &quot;&quot;&quot;Drop entry with specified index.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self._reflog_path, &quot;rb+&quot;) as f:</span>
<span class="gi">+            drop_reflog_entry(f, index, rewrite=True)</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            os.remove(self._reflog_path)</span>
<span class="gi">+            del self._repo.refs[self._ref]</span>
<span class="gi">+            return</span>
<span class="gi">+        if index == 0:</span>
<span class="gi">+            self._repo.refs[self._ref] = self[0].new_sha</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self, index):</span>
<span class="gi">+        raise NotImplementedError(self.pop)</span>

<span class="w"> </span>    def push(self, committer=None, author=None, message=None):
<span class="w"> </span>        &quot;&quot;&quot;Create a new stash.
<span class="gu">@@ -33,10 +77,53 @@ class Stash:</span>
<span class="w"> </span>          author: Optional author name to use
<span class="w"> </span>          message: Optional commit message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First, create the index commit.</span>
<span class="gi">+        commit_kwargs = {}</span>
<span class="gi">+        if committer is not None:</span>
<span class="gi">+            commit_kwargs[&quot;committer&quot;] = committer</span>
<span class="gi">+        if author is not None:</span>
<span class="gi">+            commit_kwargs[&quot;author&quot;] = author</span>
<span class="gi">+</span>
<span class="gi">+        index = self._repo.open_index()</span>
<span class="gi">+        index_tree_id = index.commit(self._repo.object_store)</span>
<span class="gi">+        index_commit_id = self._repo.do_commit(</span>
<span class="gi">+            ref=None,</span>
<span class="gi">+            tree=index_tree_id,</span>
<span class="gi">+            message=b&quot;Index stash&quot;,</span>
<span class="gi">+            merge_heads=[self._repo.head()],</span>
<span class="gi">+            no_verify=True,</span>
<span class="gi">+            **commit_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Then, the working tree one.</span>
<span class="gi">+        stash_tree_id = commit_tree(</span>
<span class="gi">+            self._repo.object_store,</span>
<span class="gi">+            iter_fresh_objects(</span>
<span class="gi">+                index,</span>
<span class="gi">+                os.fsencode(self._repo.path),</span>
<span class="gi">+                object_store=self._repo.object_store,</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if message is None:</span>
<span class="gi">+            message = b&quot;A stash on &quot; + self._repo.head()</span>
<span class="gi">+</span>
<span class="gi">+        # TODO(jelmer): Just pass parents into do_commit()?</span>
<span class="gi">+        self._repo.refs[self._ref] = self._repo.head()</span>
<span class="gi">+</span>
<span class="gi">+        cid = self._repo.do_commit(</span>
<span class="gi">+            ref=self._ref,</span>
<span class="gi">+            tree=stash_tree_id,</span>
<span class="gi">+            message=message,</span>
<span class="gi">+            merge_heads=[index_commit_id],</span>
<span class="gi">+            no_verify=True,</span>
<span class="gi">+            **commit_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return cid</span>

<span class="w"> </span>    def __getitem__(self, index):
<span class="w"> </span>        return list(self.stashes())[index]

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(list(self.stashes()))
<span class="gh">diff --git a/dulwich/submodule.py b/dulwich/submodule.py</span>
<span class="gh">index 5b8c520a..895c3408 100644</span>
<span class="gd">--- a/dulwich/submodule.py</span>
<span class="gi">+++ b/dulwich/submodule.py</span>
<span class="gu">@@ -1,11 +1,32 @@</span>
<span class="gi">+# config.py - Reading and writing Git config files</span>
<span class="gi">+# Copyright (C) 2011-2013 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Working with Git submodules.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterator, Tuple
<span class="gi">+</span>
<span class="w"> </span>from .object_store import iter_tree_contents
<span class="w"> </span>from .objects import S_ISGITLINK


<span class="gd">-def iter_cached_submodules(store, root_tree_id: bytes) -&gt;Iterator[Tuple[str,</span>
<span class="gd">-    bytes]]:</span>
<span class="gi">+def iter_cached_submodules(store, root_tree_id: bytes) -&gt; Iterator[Tuple[str, bytes]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over cached submodules.

<span class="w"> </span>    Args:
<span class="gu">@@ -15,4 +36,6 @@ def iter_cached_submodules(store, root_tree_id: bytes) -&gt;Iterator[Tuple[str,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Iterator over over (path, sha) tuples
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for entry in iter_tree_contents(store, root_tree_id):</span>
<span class="gi">+        if S_ISGITLINK(entry.mode):</span>
<span class="gi">+            yield entry.path, entry.sha</span>
<span class="gh">diff --git a/dulwich/tests/test_object_store.py b/dulwich/tests/test_object_store.py</span>
<span class="gh">index 85d70259..313be5d3 100644</span>
<span class="gd">--- a/dulwich/tests/test_object_store.py</span>
<span class="gi">+++ b/dulwich/tests/test_object_store.py</span>
<span class="gu">@@ -1,25 +1,296 @@</span>
<span class="gi">+# test_object_store.py -- tests for object_store.py</span>
<span class="gi">+# Copyright (C) 2008 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Tests for the object store interface.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from unittest import skipUnless
<span class="gi">+</span>
<span class="w"> </span>from dulwich.index import commit_tree
<span class="gd">-from dulwich.object_store import iter_tree_contents, peel_sha</span>
<span class="gd">-from dulwich.objects import Blob, TreeEntry</span>
<span class="gi">+from dulwich.object_store import (</span>
<span class="gi">+    iter_tree_contents,</span>
<span class="gi">+    peel_sha,</span>
<span class="gi">+)</span>
<span class="gi">+from dulwich.objects import (</span>
<span class="gi">+    Blob,</span>
<span class="gi">+    TreeEntry,</span>
<span class="gi">+)</span>
<span class="w"> </span>from dulwich.protocol import DEPTH_INFINITE
<span class="gi">+</span>
<span class="w"> </span>from .utils import make_object, make_tag
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from unittest.mock import patch
<span class="w"> </span>except ImportError:
<span class="gd">-    patch = None</span>
<span class="gd">-testobject = make_object(Blob, data=b&#39;yummy data&#39;)</span>
<span class="gi">+    patch = None  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+testobject = make_object(Blob, data=b&quot;yummy data&quot;)</span>


<span class="w"> </span>class ObjectStoreTests:
<span class="gi">+    def test_determine_wants_all(self):</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            [b&quot;1&quot; * 40],</span>
<span class="gi">+            self.store.determine_wants_all({b&quot;refs/heads/foo&quot;: b&quot;1&quot; * 40}),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def test_determine_wants_all_zero(self):</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            [], self.store.determine_wants_all({b&quot;refs/heads/foo&quot;: b&quot;0&quot; * 40})</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @skipUnless(patch, &quot;Required mock.patch&quot;)</span>
<span class="gi">+    def test_determine_wants_all_depth(self):</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        refs = {b&quot;refs/heads/foo&quot;: testobject.id}</span>
<span class="gi">+        with patch.object(self.store, &quot;_get_depth&quot;, return_value=1) as m:</span>
<span class="gi">+            self.assertEqual([], self.store.determine_wants_all(refs, depth=0))</span>
<span class="gi">+            self.assertEqual(</span>
<span class="gi">+                [testobject.id],</span>
<span class="gi">+                self.store.determine_wants_all(refs, depth=DEPTH_INFINITE),</span>
<span class="gi">+            )</span>
<span class="gi">+            m.assert_not_called()</span>
<span class="gi">+</span>
<span class="gi">+            self.assertEqual([], self.store.determine_wants_all(refs, depth=1))</span>
<span class="gi">+            m.assert_called_with(testobject.id)</span>
<span class="gi">+            self.assertEqual(</span>
<span class="gi">+                [testobject.id], self.store.determine_wants_all(refs, depth=2)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def test_get_depth(self):</span>
<span class="gi">+        self.assertEqual(0, self.store._get_depth(testobject.id))</span>
<span class="gi">+</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            1, self.store._get_depth(testobject.id, get_parents=lambda x: [])</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        parent = make_object(Blob, data=b&quot;parent data&quot;)</span>
<span class="gi">+        self.store.add_object(parent)</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            2,</span>
<span class="gi">+            self.store._get_depth(</span>
<span class="gi">+                testobject.id,</span>
<span class="gi">+                get_parents=lambda x: [parent.id] if x == testobject else [],</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def test_iter(self):</span>
<span class="gi">+        self.assertEqual([], list(self.store))</span>
<span class="gi">+</span>
<span class="gi">+    def test_get_nonexistant(self):</span>
<span class="gi">+        self.assertRaises(KeyError, lambda: self.store[b&quot;a&quot; * 40])</span>
<span class="gi">+</span>
<span class="gi">+    def test_contains_nonexistant(self):</span>
<span class="gi">+        self.assertNotIn(b&quot;a&quot; * 40, self.store)</span>
<span class="gi">+</span>
<span class="gi">+    def test_add_objects_empty(self):</span>
<span class="gi">+        self.store.add_objects([])</span>
<span class="gi">+</span>
<span class="gi">+    def test_add_commit(self):</span>
<span class="gi">+        # TODO: Argh, no way to construct Git commit objects without</span>
<span class="gi">+        # access to a serialized form.</span>
<span class="gi">+        self.store.add_objects([])</span>

<span class="w"> </span>    def test_store_resilience(self):
<span class="w"> </span>        &quot;&quot;&quot;Test if updating an existing stored object doesn&#39;t erase the
<span class="w"> </span>        object from the store.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        test_object = make_object(Blob, data=b&quot;data&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.store.add_object(test_object)</span>
<span class="gi">+        test_object_id = test_object.id</span>
<span class="gi">+        test_object.data = test_object.data + b&quot;update&quot;</span>
<span class="gi">+        stored_test_object = self.store[test_object_id]</span>
<span class="gi">+</span>
<span class="gi">+        self.assertNotEqual(test_object.id, stored_test_object.id)</span>
<span class="gi">+        self.assertEqual(stored_test_object.id, test_object_id)</span>
<span class="gi">+</span>
<span class="gi">+    def test_add_object(self):</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        self.assertEqual({testobject.id}, set(self.store))</span>
<span class="gi">+        self.assertIn(testobject.id, self.store)</span>
<span class="gi">+        r = self.store[testobject.id]</span>
<span class="gi">+        self.assertEqual(r, testobject)</span>
<span class="gi">+</span>
<span class="gi">+    def test_add_objects(self):</span>
<span class="gi">+        data = [(testobject, &quot;mypath&quot;)]</span>
<span class="gi">+        self.store.add_objects(data)</span>
<span class="gi">+        self.assertEqual({testobject.id}, set(self.store))</span>
<span class="gi">+        self.assertIn(testobject.id, self.store)</span>
<span class="gi">+        r = self.store[testobject.id]</span>
<span class="gi">+        self.assertEqual(r, testobject)</span>
<span class="gi">+</span>
<span class="gi">+    def test_tree_changes(self):</span>
<span class="gi">+        blob_a1 = make_object(Blob, data=b&quot;a1&quot;)</span>
<span class="gi">+        blob_a2 = make_object(Blob, data=b&quot;a2&quot;)</span>
<span class="gi">+        blob_b = make_object(Blob, data=b&quot;b&quot;)</span>
<span class="gi">+        for blob in [blob_a1, blob_a2, blob_b]:</span>
<span class="gi">+            self.store.add_object(blob)</span>
<span class="gi">+</span>
<span class="gi">+        blobs_1 = [(b&quot;a&quot;, blob_a1.id, 0o100644), (b&quot;b&quot;, blob_b.id, 0o100644)]</span>
<span class="gi">+        tree1_id = commit_tree(self.store, blobs_1)</span>
<span class="gi">+        blobs_2 = [(b&quot;a&quot;, blob_a2.id, 0o100644), (b&quot;b&quot;, blob_b.id, 0o100644)]</span>
<span class="gi">+        tree2_id = commit_tree(self.store, blobs_2)</span>
<span class="gi">+        change_a = (</span>
<span class="gi">+            (b&quot;a&quot;, b&quot;a&quot;),</span>
<span class="gi">+            (0o100644, 0o100644),</span>
<span class="gi">+            (blob_a1.id, blob_a2.id),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.assertEqual([change_a], list(self.store.tree_changes(tree1_id, tree2_id)))</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            [</span>
<span class="gi">+                change_a,</span>
<span class="gi">+                ((b&quot;b&quot;, b&quot;b&quot;), (0o100644, 0o100644), (blob_b.id, blob_b.id)),</span>
<span class="gi">+            ],</span>
<span class="gi">+            list(self.store.tree_changes(tree1_id, tree2_id, want_unchanged=True)),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def test_iter_tree_contents(self):</span>
<span class="gi">+        blob_a = make_object(Blob, data=b&quot;a&quot;)</span>
<span class="gi">+        blob_b = make_object(Blob, data=b&quot;b&quot;)</span>
<span class="gi">+        blob_c = make_object(Blob, data=b&quot;c&quot;)</span>
<span class="gi">+        for blob in [blob_a, blob_b, blob_c]:</span>
<span class="gi">+            self.store.add_object(blob)</span>
<span class="gi">+</span>
<span class="gi">+        blobs = [</span>
<span class="gi">+            (b&quot;a&quot;, blob_a.id, 0o100644),</span>
<span class="gi">+            (b&quot;ad/b&quot;, blob_b.id, 0o100644),</span>
<span class="gi">+            (b&quot;ad/bd/c&quot;, blob_c.id, 0o100755),</span>
<span class="gi">+            (b&quot;ad/c&quot;, blob_c.id, 0o100644),</span>
<span class="gi">+            (b&quot;c&quot;, blob_c.id, 0o100644),</span>
<span class="gi">+        ]</span>
<span class="gi">+        tree_id = commit_tree(self.store, blobs)</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            [TreeEntry(p, m, h) for (p, h, m) in blobs],</span>
<span class="gi">+            list(iter_tree_contents(self.store, tree_id)),</span>
<span class="gi">+        )</span>
<span class="gi">+        self.assertEqual([], list(iter_tree_contents(self.store, None)))</span>
<span class="gi">+</span>
<span class="gi">+    def test_iter_tree_contents_include_trees(self):</span>
<span class="gi">+        blob_a = make_object(Blob, data=b&quot;a&quot;)</span>
<span class="gi">+        blob_b = make_object(Blob, data=b&quot;b&quot;)</span>
<span class="gi">+        blob_c = make_object(Blob, data=b&quot;c&quot;)</span>
<span class="gi">+        for blob in [blob_a, blob_b, blob_c]:</span>
<span class="gi">+            self.store.add_object(blob)</span>
<span class="gi">+</span>
<span class="gi">+        blobs = [</span>
<span class="gi">+            (b&quot;a&quot;, blob_a.id, 0o100644),</span>
<span class="gi">+            (b&quot;ad/b&quot;, blob_b.id, 0o100644),</span>
<span class="gi">+            (b&quot;ad/bd/c&quot;, blob_c.id, 0o100755),</span>
<span class="gi">+        ]</span>
<span class="gi">+        tree_id = commit_tree(self.store, blobs)</span>
<span class="gi">+        tree = self.store[tree_id]</span>
<span class="gi">+        tree_ad = self.store[tree[b&quot;ad&quot;][1]]</span>
<span class="gi">+        tree_bd = self.store[tree_ad[b&quot;bd&quot;][1]]</span>
<span class="gi">+</span>
<span class="gi">+        expected = [</span>
<span class="gi">+            TreeEntry(b&quot;&quot;, 0o040000, tree_id),</span>
<span class="gi">+            TreeEntry(b&quot;a&quot;, 0o100644, blob_a.id),</span>
<span class="gi">+            TreeEntry(b&quot;ad&quot;, 0o040000, tree_ad.id),</span>
<span class="gi">+            TreeEntry(b&quot;ad/b&quot;, 0o100644, blob_b.id),</span>
<span class="gi">+            TreeEntry(b&quot;ad/bd&quot;, 0o040000, tree_bd.id),</span>
<span class="gi">+            TreeEntry(b&quot;ad/bd/c&quot;, 0o100755, blob_c.id),</span>
<span class="gi">+        ]</span>
<span class="gi">+        actual = iter_tree_contents(self.store, tree_id, include_trees=True)</span>
<span class="gi">+        self.assertEqual(expected, list(actual))</span>
<span class="gi">+</span>
<span class="gi">+    def make_tag(self, name, obj):</span>
<span class="gi">+        tag = make_tag(obj, name=name)</span>
<span class="gi">+        self.store.add_object(tag)</span>
<span class="gi">+        return tag</span>
<span class="gi">+</span>
<span class="gi">+    def test_peel_sha(self):</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        tag1 = self.make_tag(b&quot;1&quot;, testobject)</span>
<span class="gi">+        tag2 = self.make_tag(b&quot;2&quot;, testobject)</span>
<span class="gi">+        tag3 = self.make_tag(b&quot;3&quot;, testobject)</span>
<span class="gi">+        for obj in [testobject, tag1, tag2, tag3]:</span>
<span class="gi">+            self.assertEqual((obj, testobject), peel_sha(self.store, obj.id))</span>
<span class="gi">+</span>
<span class="gi">+    def test_get_raw(self):</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        self.assertEqual(</span>
<span class="gi">+            (Blob.type_num, b&quot;yummy data&quot;), self.store.get_raw(testobject.id)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def test_close(self):</span>
<span class="gi">+        # For now, just check that close doesn&#39;t barf.</span>
<span class="gi">+        self.store.add_object(testobject)</span>
<span class="gi">+        self.store.close()</span>


<span class="w"> </span>class PackBasedObjectStoreTests(ObjectStoreTests):
<span class="gd">-    pass</span>
<span class="gi">+    def tearDown(self):</span>
<span class="gi">+        for pack in self.store.packs:</span>
<span class="gi">+            pack.close()</span>
<span class="gi">+</span>
<span class="gi">+    def test_empty_packs(self):</span>
<span class="gi">+        self.assertEqual([], list(self.store.packs))</span>
<span class="gi">+</span>
<span class="gi">+    def test_pack_loose_objects(self):</span>
<span class="gi">+        b1 = make_object(Blob, data=b&quot;yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b1)</span>
<span class="gi">+        b2 = make_object(Blob, data=b&quot;more yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b2)</span>
<span class="gi">+        b3 = make_object(Blob, data=b&quot;even more yummy data&quot;)</span>
<span class="gi">+        b4 = make_object(Blob, data=b&quot;and more yummy data&quot;)</span>
<span class="gi">+        self.store.add_objects([(b3, None), (b4, None)])</span>
<span class="gi">+        self.assertEqual({b1.id, b2.id, b3.id, b4.id}, set(self.store))</span>
<span class="gi">+        self.assertEqual(1, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(2, self.store.pack_loose_objects())</span>
<span class="gi">+        self.assertNotEqual([], list(self.store.packs))</span>
<span class="gi">+        self.assertEqual(0, self.store.pack_loose_objects())</span>
<span class="gi">+</span>
<span class="gi">+    def test_repack(self):</span>
<span class="gi">+        b1 = make_object(Blob, data=b&quot;yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b1)</span>
<span class="gi">+        b2 = make_object(Blob, data=b&quot;more yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b2)</span>
<span class="gi">+        b3 = make_object(Blob, data=b&quot;even more yummy data&quot;)</span>
<span class="gi">+        b4 = make_object(Blob, data=b&quot;and more yummy data&quot;)</span>
<span class="gi">+        self.store.add_objects([(b3, None), (b4, None)])</span>
<span class="gi">+        b5 = make_object(Blob, data=b&quot;and more data&quot;)</span>
<span class="gi">+        b6 = make_object(Blob, data=b&quot;and some more data&quot;)</span>
<span class="gi">+        self.store.add_objects([(b5, None), (b6, None)])</span>
<span class="gi">+        self.assertEqual({b1.id, b2.id, b3.id, b4.id, b5.id, b6.id}, set(self.store))</span>
<span class="gi">+        self.assertEqual(2, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(6, self.store.repack())</span>
<span class="gi">+        self.assertEqual(1, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(0, self.store.pack_loose_objects())</span>
<span class="gi">+</span>
<span class="gi">+    def test_repack_existing(self):</span>
<span class="gi">+        b1 = make_object(Blob, data=b&quot;yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b1)</span>
<span class="gi">+        b2 = make_object(Blob, data=b&quot;more yummy data&quot;)</span>
<span class="gi">+        self.store.add_object(b2)</span>
<span class="gi">+        self.store.add_objects([(b1, None), (b2, None)])</span>
<span class="gi">+        self.store.add_objects([(b2, None)])</span>
<span class="gi">+        self.assertEqual({b1.id, b2.id}, set(self.store))</span>
<span class="gi">+        self.assertEqual(2, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(2, self.store.repack())</span>
<span class="gi">+        self.assertEqual(1, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(0, self.store.pack_loose_objects())</span>
<span class="gi">+</span>
<span class="gi">+        self.assertEqual({b1.id, b2.id}, set(self.store))</span>
<span class="gi">+        self.assertEqual(1, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(2, self.store.repack())</span>
<span class="gi">+        self.assertEqual(1, len(self.store.packs))</span>
<span class="gi">+        self.assertEqual(0, self.store.pack_loose_objects())</span>
<span class="gh">diff --git a/dulwich/tests/utils.py b/dulwich/tests/utils.py</span>
<span class="gh">index 51ce7d04..2a1dafd3 100644</span>
<span class="gd">--- a/dulwich/tests/utils.py</span>
<span class="gi">+++ b/dulwich/tests/utils.py</span>
<span class="gu">@@ -1,4 +1,25 @@</span>
<span class="gi">+# utils.py -- Test utilities for Dulwich.</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utility functions common to Dulwich tests.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import os
<span class="w"> </span>import shutil
<span class="gu">@@ -7,11 +28,23 @@ import time</span>
<span class="w"> </span>import types
<span class="w"> </span>import warnings
<span class="w"> </span>from unittest import SkipTest
<span class="gi">+</span>
<span class="w"> </span>from dulwich.index import commit_tree
<span class="w"> </span>from dulwich.objects import Commit, FixedSha, Tag, object_class
<span class="gd">-from dulwich.pack import DELTA_TYPES, OFS_DELTA, REF_DELTA, SHA1Writer, create_delta, obj_sha, write_pack_header, write_pack_object</span>
<span class="gi">+from dulwich.pack import (</span>
<span class="gi">+    DELTA_TYPES,</span>
<span class="gi">+    OFS_DELTA,</span>
<span class="gi">+    REF_DELTA,</span>
<span class="gi">+    SHA1Writer,</span>
<span class="gi">+    create_delta,</span>
<span class="gi">+    obj_sha,</span>
<span class="gi">+    write_pack_header,</span>
<span class="gi">+    write_pack_object,</span>
<span class="gi">+)</span>
<span class="w"> </span>from dulwich.repo import Repo
<span class="gd">-F = 33188</span>
<span class="gi">+</span>
<span class="gi">+# Plain files are very frequently used in tests, so let the mode be very short.</span>
<span class="gi">+F = 0o100644  # Shorthand mode for Files.</span>


<span class="w"> </span>def open_repo(name, temp_dir=None):
<span class="gu">@@ -28,12 +61,21 @@ def open_repo(name, temp_dir=None):</span>
<span class="w"> </span>        temporary directory will be created.
<span class="w"> </span>    Returns: An initialized Repo object that lives in a temporary directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if temp_dir is None:</span>
<span class="gi">+        temp_dir = tempfile.mkdtemp()</span>
<span class="gi">+    repo_dir = os.path.join(</span>
<span class="gi">+        os.path.dirname(__file__), &quot;..&quot;, &quot;..&quot;, &quot;testdata&quot;, &quot;repos&quot;, name</span>
<span class="gi">+    )</span>
<span class="gi">+    temp_repo_dir = os.path.join(temp_dir, name)</span>
<span class="gi">+    shutil.copytree(repo_dir, temp_repo_dir, symlinks=True)</span>
<span class="gi">+    return Repo(temp_repo_dir)</span>


<span class="w"> </span>def tear_down_repo(repo):
<span class="w"> </span>    &quot;&quot;&quot;Tear down a test repository.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    repo.close()</span>
<span class="gi">+    temp_dir = os.path.dirname(repo.path.rstrip(os.sep))</span>
<span class="gi">+    shutil.rmtree(temp_dir)</span>


<span class="w"> </span>def make_object(cls, **attrs):
<span class="gu">@@ -47,7 +89,26 @@ def make_object(cls, **attrs):</span>
<span class="w"> </span>      attrs: dict of attributes to set on the new object.
<span class="w"> </span>    Returns: A newly initialized object of type cls.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    class TestObject(cls):</span>
<span class="gi">+        &quot;&quot;&quot;Class that inherits from the given class, but without __slots__.</span>
<span class="gi">+</span>
<span class="gi">+        Note that classes with __slots__ can&#39;t have arbitrary attributes</span>
<span class="gi">+        monkey-patched in, so this is a class that is exactly the same only</span>
<span class="gi">+        with a __dict__ instead of __slots__.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    TestObject.__name__ = &quot;TestObject_&quot; + cls.__name__</span>
<span class="gi">+</span>
<span class="gi">+    obj = TestObject()</span>
<span class="gi">+    for name, value in attrs.items():</span>
<span class="gi">+        if name == &quot;id&quot;:</span>
<span class="gi">+            # id property is read-only, so we overwrite sha instead.</span>
<span class="gi">+            sha = FixedSha(value)</span>
<span class="gi">+            obj.sha = lambda: sha</span>
<span class="gi">+        else:</span>
<span class="gi">+            setattr(obj, name, value)</span>
<span class="gi">+    return obj</span>


<span class="w"> </span>def make_commit(**attrs):
<span class="gu">@@ -57,7 +118,20 @@ def make_commit(**attrs):</span>
<span class="w"> </span>      attrs: dict of attributes to overwrite from the default values.
<span class="w"> </span>    Returns: A newly initialized Commit object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    default_time = 1262304000  # 2010-01-01 00:00:00</span>
<span class="gi">+    all_attrs = {</span>
<span class="gi">+        &quot;author&quot;: b&quot;Test Author &lt;test@nodomain.com&gt;&quot;,</span>
<span class="gi">+        &quot;author_time&quot;: default_time,</span>
<span class="gi">+        &quot;author_timezone&quot;: 0,</span>
<span class="gi">+        &quot;committer&quot;: b&quot;Test Committer &lt;test@nodomain.com&gt;&quot;,</span>
<span class="gi">+        &quot;commit_time&quot;: default_time,</span>
<span class="gi">+        &quot;commit_timezone&quot;: 0,</span>
<span class="gi">+        &quot;message&quot;: b&quot;Test message.&quot;,</span>
<span class="gi">+        &quot;parents&quot;: [],</span>
<span class="gi">+        &quot;tree&quot;: b&quot;0&quot; * 40,</span>
<span class="gi">+    }</span>
<span class="gi">+    all_attrs.update(attrs)</span>
<span class="gi">+    return make_object(Commit, **all_attrs)</span>


<span class="w"> </span>def make_tag(target, **attrs):
<span class="gu">@@ -68,12 +142,28 @@ def make_tag(target, **attrs):</span>
<span class="w"> </span>      attrs: dict of attributes to overwrite from the default values.
<span class="w"> </span>    Returns: A newly initialized Tag object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    target_id = target.id</span>
<span class="gi">+    target_type = object_class(target.type_name)</span>
<span class="gi">+    default_time = int(time.mktime(datetime.datetime(2010, 1, 1).timetuple()))</span>
<span class="gi">+    all_attrs = {</span>
<span class="gi">+        &quot;tagger&quot;: b&quot;Test Author &lt;test@nodomain.com&gt;&quot;,</span>
<span class="gi">+        &quot;tag_time&quot;: default_time,</span>
<span class="gi">+        &quot;tag_timezone&quot;: 0,</span>
<span class="gi">+        &quot;message&quot;: b&quot;Test message.&quot;,</span>
<span class="gi">+        &quot;object&quot;: (target_type, target_id),</span>
<span class="gi">+        &quot;name&quot;: b&quot;Test Tag&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    all_attrs.update(attrs)</span>
<span class="gi">+    return make_object(Tag, **all_attrs)</span>


<span class="w"> </span>def functest_builder(method, func):
<span class="w"> </span>    &quot;&quot;&quot;Generate a test method that tests the given function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def do_test(self):</span>
<span class="gi">+        method(self, func)</span>
<span class="gi">+</span>
<span class="gi">+    return do_test</span>


<span class="w"> </span>def ext_functest_builder(method, func):
<span class="gu">@@ -97,7 +187,13 @@ def ext_functest_builder(method, func):</span>
<span class="w"> </span>        function implementation to test.
<span class="w"> </span>      func: The function implementation to pass to method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def do_test(self):</span>
<span class="gi">+        if not isinstance(func, types.BuiltinFunctionType):</span>
<span class="gi">+            raise SkipTest(f&quot;{func} extension not found&quot;)</span>
<span class="gi">+        method(self, func)</span>
<span class="gi">+</span>
<span class="gi">+    return do_test</span>


<span class="w"> </span>def build_pack(f, objects_spec, store=None):
<span class="gu">@@ -119,7 +215,61 @@ def build_pack(f, objects_spec, store=None):</span>
<span class="w"> </span>    Returns: A list of tuples in the order specified by objects_spec:
<span class="w"> </span>        (offset, type num, data, sha, CRC32)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sf = SHA1Writer(f)</span>
<span class="gi">+    num_objects = len(objects_spec)</span>
<span class="gi">+    write_pack_header(sf.write, num_objects)</span>
<span class="gi">+</span>
<span class="gi">+    full_objects = {}</span>
<span class="gi">+    offsets = {}</span>
<span class="gi">+    crc32s = {}</span>
<span class="gi">+</span>
<span class="gi">+    while len(full_objects) &lt; num_objects:</span>
<span class="gi">+        for i, (type_num, data) in enumerate(objects_spec):</span>
<span class="gi">+            if type_num not in DELTA_TYPES:</span>
<span class="gi">+                full_objects[i] = (type_num, data, obj_sha(type_num, [data]))</span>
<span class="gi">+                continue</span>
<span class="gi">+            base, data = data</span>
<span class="gi">+            if isinstance(base, int):</span>
<span class="gi">+                if base not in full_objects:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                base_type_num, _, _ = full_objects[base]</span>
<span class="gi">+            else:</span>
<span class="gi">+                base_type_num, _ = store.get_raw(base)</span>
<span class="gi">+            full_objects[i] = (</span>
<span class="gi">+                base_type_num,</span>
<span class="gi">+                data,</span>
<span class="gi">+                obj_sha(base_type_num, [data]),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    for i, (type_num, obj) in enumerate(objects_spec):</span>
<span class="gi">+        offset = f.tell()</span>
<span class="gi">+        if type_num == OFS_DELTA:</span>
<span class="gi">+            base_index, data = obj</span>
<span class="gi">+            base = offset - offsets[base_index]</span>
<span class="gi">+            _, base_data, _ = full_objects[base_index]</span>
<span class="gi">+            obj = (base, list(create_delta(base_data, data)))</span>
<span class="gi">+        elif type_num == REF_DELTA:</span>
<span class="gi">+            base_ref, data = obj</span>
<span class="gi">+            if isinstance(base_ref, int):</span>
<span class="gi">+                _, base_data, base = full_objects[base_ref]</span>
<span class="gi">+            else:</span>
<span class="gi">+                base_type_num, base_data = store.get_raw(base_ref)</span>
<span class="gi">+                base = obj_sha(base_type_num, base_data)</span>
<span class="gi">+            obj = (base, list(create_delta(base_data, data)))</span>
<span class="gi">+</span>
<span class="gi">+        crc32 = write_pack_object(sf.write, type_num, obj)</span>
<span class="gi">+        offsets[i] = offset</span>
<span class="gi">+        crc32s[i] = crc32</span>
<span class="gi">+</span>
<span class="gi">+    expected = []</span>
<span class="gi">+    for i in range(num_objects):</span>
<span class="gi">+        type_num, data, sha = full_objects[i]</span>
<span class="gi">+        assert len(sha) == 20</span>
<span class="gi">+        expected.append((offsets[i], type_num, data, sha, crc32s[i]))</span>
<span class="gi">+</span>
<span class="gi">+    sf.write_sha()</span>
<span class="gi">+    f.seek(0)</span>
<span class="gi">+    return expected</span>


<span class="w"> </span>def build_commit_graph(object_store, commit_spec, trees=None, attrs=None):
<span class="gu">@@ -154,9 +304,62 @@ def build_commit_graph(object_store, commit_spec, trees=None, attrs=None):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ValueError: If an undefined commit identifier is listed as a parent.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if trees is None:</span>
<span class="gi">+        trees = {}</span>
<span class="gi">+    if attrs is None:</span>
<span class="gi">+        attrs = {}</span>
<span class="gi">+    commit_time = 0</span>
<span class="gi">+    nums = {}</span>
<span class="gi">+    commits = []</span>
<span class="gi">+</span>
<span class="gi">+    for commit in commit_spec:</span>
<span class="gi">+        commit_num = commit[0]</span>
<span class="gi">+        try:</span>
<span class="gi">+            parent_ids = [nums[pn] for pn in commit[1:]]</span>
<span class="gi">+        except KeyError as exc:</span>
<span class="gi">+            (missing_parent,) = exc.args</span>
<span class="gi">+            raise ValueError(&quot;Unknown parent %i&quot; % missing_parent) from exc</span>
<span class="gi">+</span>
<span class="gi">+        blobs = []</span>
<span class="gi">+        for entry in trees.get(commit_num, []):</span>
<span class="gi">+            if len(entry) == 2:</span>
<span class="gi">+                path, blob = entry</span>
<span class="gi">+                entry = (path, blob, F)</span>
<span class="gi">+            path, blob, mode = entry</span>
<span class="gi">+            blobs.append((path, blob.id, mode))</span>
<span class="gi">+            object_store.add_object(blob)</span>
<span class="gi">+        tree_id = commit_tree(object_store, blobs)</span>
<span class="gi">+</span>
<span class="gi">+        commit_attrs = {</span>
<span class="gi">+            &quot;message&quot;: (&quot;Commit %i&quot; % commit_num).encode(&quot;ascii&quot;),</span>
<span class="gi">+            &quot;parents&quot;: parent_ids,</span>
<span class="gi">+            &quot;tree&quot;: tree_id,</span>
<span class="gi">+            &quot;commit_time&quot;: commit_time,</span>
<span class="gi">+        }</span>
<span class="gi">+        commit_attrs.update(attrs.get(commit_num, {}))</span>
<span class="gi">+        commit_obj = make_commit(**commit_attrs)</span>
<span class="gi">+</span>
<span class="gi">+        # By default, increment the time by a lot. Out-of-order commits should</span>
<span class="gi">+        # be closer together than this because their main cause is clock skew.</span>
<span class="gi">+        commit_time = commit_attrs[&quot;commit_time&quot;] + 100</span>
<span class="gi">+        nums[commit_num] = commit_obj.id</span>
<span class="gi">+        object_store.add_object(commit_obj)</span>
<span class="gi">+        commits.append(commit_obj)</span>
<span class="gi">+</span>
<span class="gi">+    return commits</span>


<span class="w"> </span>def setup_warning_catcher():
<span class="w"> </span>    &quot;&quot;&quot;Wrap warnings.showwarning with code that records warnings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    caught_warnings = []</span>
<span class="gi">+    original_showwarning = warnings.showwarning</span>
<span class="gi">+</span>
<span class="gi">+    def custom_showwarning(*args, **kwargs):</span>
<span class="gi">+        caught_warnings.append(args[0])</span>
<span class="gi">+</span>
<span class="gi">+    warnings.showwarning = custom_showwarning</span>
<span class="gi">+</span>
<span class="gi">+    def restore_showwarning():</span>
<span class="gi">+        warnings.showwarning = original_showwarning</span>
<span class="gi">+</span>
<span class="gi">+    return caught_warnings, restore_showwarning</span>
<span class="gh">diff --git a/dulwich/walk.py b/dulwich/walk.py</span>
<span class="gh">index bdb51329..58f9a428 100644</span>
<span class="gd">--- a/dulwich/walk.py</span>
<span class="gi">+++ b/dulwich/walk.py</span>
<span class="gu">@@ -1,21 +1,53 @@</span>
<span class="gi">+# walk.py -- General implementation of walking commits and their contents.</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;General implementation of walking commits and their contents.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import heapq
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from typing import Deque, Dict, List, Optional, Set, Tuple
<span class="gd">-from .diff_tree import RENAME_CHANGE_TYPES, RenameDetector, TreeChange, tree_changes, tree_changes_for_merge</span>
<span class="gi">+</span>
<span class="gi">+from .diff_tree import (</span>
<span class="gi">+    RENAME_CHANGE_TYPES,</span>
<span class="gi">+    RenameDetector,</span>
<span class="gi">+    TreeChange,</span>
<span class="gi">+    tree_changes,</span>
<span class="gi">+    tree_changes_for_merge,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .errors import MissingCommitError
<span class="w"> </span>from .objects import Commit, ObjectID, Tag
<span class="gd">-ORDER_DATE = &#39;date&#39;</span>
<span class="gd">-ORDER_TOPO = &#39;topo&#39;</span>
<span class="gd">-ALL_ORDERS = ORDER_DATE, ORDER_TOPO</span>
<span class="gi">+</span>
<span class="gi">+ORDER_DATE = &quot;date&quot;</span>
<span class="gi">+ORDER_TOPO = &quot;topo&quot;</span>
<span class="gi">+</span>
<span class="gi">+ALL_ORDERS = (ORDER_DATE, ORDER_TOPO)</span>
<span class="gi">+</span>
<span class="gi">+# Maximum number of commits to walk past a commit time boundary.</span>
<span class="w"> </span>_MAX_EXTRA_COMMITS = 5


<span class="w"> </span>class WalkEntry:
<span class="w"> </span>    &quot;&quot;&quot;Object encapsulating a single result from a walk.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, walker, commit) -&gt;None:</span>
<span class="gi">+    def __init__(self, walker, commit) -&gt; None:</span>
<span class="w"> </span>        self.commit = commit
<span class="w"> </span>        self._store = walker.store
<span class="w"> </span>        self._get_parents = walker.get_parents
<span class="gu">@@ -34,17 +66,63 @@ class WalkEntry:</span>
<span class="w"> </span>            the empty tree. For merge commits, a list of lists of TreeChange
<span class="w"> </span>            objects; see dulwich.diff.tree_changes_for_merge.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cached = self._changes.get(path_prefix)</span>
<span class="gi">+        if cached is None:</span>
<span class="gi">+            commit = self.commit</span>
<span class="gi">+            if not self._get_parents(commit):</span>
<span class="gi">+                changes_func = tree_changes</span>
<span class="gi">+                parent = None</span>
<span class="gi">+            elif len(self._get_parents(commit)) == 1:</span>
<span class="gi">+                changes_func = tree_changes</span>
<span class="gi">+                parent = self._store[self._get_parents(commit)[0]].tree</span>
<span class="gi">+                if path_prefix:</span>
<span class="gi">+                    mode, subtree_sha = parent.lookup_path(</span>
<span class="gi">+                        self._store.__getitem__,</span>
<span class="gi">+                        path_prefix,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    parent = self._store[subtree_sha]</span>
<span class="gi">+            else:</span>
<span class="gi">+                changes_func = tree_changes_for_merge</span>
<span class="gi">+                parent = [self._store[p].tree for p in self._get_parents(commit)]</span>
<span class="gi">+                if path_prefix:</span>
<span class="gi">+                    parent_trees = [self._store[p] for p in parent]</span>
<span class="gi">+                    parent = []</span>
<span class="gi">+                    for p in parent_trees:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            mode, st = p.lookup_path(</span>
<span class="gi">+                                self._store.__getitem__,</span>
<span class="gi">+                                path_prefix,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except KeyError:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            parent.append(st)</span>
<span class="gi">+            commit_tree_sha = commit.tree</span>
<span class="gi">+            if path_prefix:</span>
<span class="gi">+                commit_tree = self._store[commit_tree_sha]</span>
<span class="gi">+                mode, commit_tree_sha = commit_tree.lookup_path(</span>
<span class="gi">+                    self._store.__getitem__,</span>
<span class="gi">+                    path_prefix,</span>
<span class="gi">+                )</span>
<span class="gi">+            cached = list(</span>
<span class="gi">+                changes_func(</span>
<span class="gi">+                    self._store,</span>
<span class="gi">+                    parent,</span>
<span class="gi">+                    commit_tree_sha,</span>
<span class="gi">+                    rename_detector=self._rename_detector,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            self._changes[path_prefix] = cached</span>
<span class="gi">+        return self._changes[path_prefix]</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;WalkEntry commit={self.commit.id}, changes={self.changes()!r}&gt;&#39;)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;WalkEntry commit={self.commit.id}, changes={self.changes()!r}&gt;&quot;</span>


<span class="w"> </span>class _CommitTimeQueue:
<span class="w"> </span>    &quot;&quot;&quot;Priority queue of WalkEntry objects by commit time.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, walker: &#39;Walker&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, walker: &quot;Walker&quot;) -&gt; None:</span>
<span class="w"> </span>        self._walker = walker
<span class="w"> </span>        self._store = walker.store
<span class="w"> </span>        self._get_parents = walker.get_parents
<span class="gu">@@ -57,8 +135,91 @@ class _CommitTimeQueue:</span>
<span class="w"> </span>        self._last = None
<span class="w"> </span>        self._extra_commits_left = _MAX_EXTRA_COMMITS
<span class="w"> </span>        self._is_finished = False
<span class="gi">+</span>
<span class="w"> </span>        for commit_id in chain(walker.include, walker.excluded):
<span class="w"> </span>            self._push(commit_id)
<span class="gi">+</span>
<span class="gi">+    def _push(self, object_id: bytes):</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = self._store[object_id]</span>
<span class="gi">+        except KeyError as exc:</span>
<span class="gi">+            raise MissingCommitError(object_id) from exc</span>
<span class="gi">+        if isinstance(obj, Tag):</span>
<span class="gi">+            self._push(obj.object[1])</span>
<span class="gi">+            return</span>
<span class="gi">+        # TODO(jelmer): What to do about non-Commit and non-Tag objects?</span>
<span class="gi">+        commit = obj</span>
<span class="gi">+        if commit.id not in self._pq_set and commit.id not in self._done:</span>
<span class="gi">+            heapq.heappush(self._pq, (-commit.commit_time, commit))</span>
<span class="gi">+            self._pq_set.add(commit.id)</span>
<span class="gi">+            self._seen.add(commit.id)</span>
<span class="gi">+</span>
<span class="gi">+    def _exclude_parents(self, commit):</span>
<span class="gi">+        excluded = self._excluded</span>
<span class="gi">+        seen = self._seen</span>
<span class="gi">+        todo = [commit]</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            commit = todo.pop()</span>
<span class="gi">+            for parent in self._get_parents(commit):</span>
<span class="gi">+                if parent not in excluded and parent in seen:</span>
<span class="gi">+                    # TODO: This is inefficient unless the object store does</span>
<span class="gi">+                    # some caching (which DiskObjectStore currently does not).</span>
<span class="gi">+                    # We could either add caching in this class or pass around</span>
<span class="gi">+                    # parsed queue entry objects instead of commits.</span>
<span class="gi">+                    todo.append(self._store[parent])</span>
<span class="gi">+                excluded.add(parent)</span>
<span class="gi">+</span>
<span class="gi">+    def next(self):</span>
<span class="gi">+        if self._is_finished:</span>
<span class="gi">+            return None</span>
<span class="gi">+        while self._pq:</span>
<span class="gi">+            _, commit = heapq.heappop(self._pq)</span>
<span class="gi">+            sha = commit.id</span>
<span class="gi">+            self._pq_set.remove(sha)</span>
<span class="gi">+            if sha in self._done:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._done.add(sha)</span>
<span class="gi">+</span>
<span class="gi">+            for parent_id in self._get_parents(commit):</span>
<span class="gi">+                self._push(parent_id)</span>
<span class="gi">+</span>
<span class="gi">+            reset_extra_commits = True</span>
<span class="gi">+            is_excluded = sha in self._excluded</span>
<span class="gi">+            if is_excluded:</span>
<span class="gi">+                self._exclude_parents(commit)</span>
<span class="gi">+                if self._pq and all(c.id in self._excluded for _, c in self._pq):</span>
<span class="gi">+                    _, n = self._pq[0]</span>
<span class="gi">+                    if self._last and n.commit_time &gt;= self._last.commit_time:</span>
<span class="gi">+                        # If the next commit is newer than the last one, we</span>
<span class="gi">+                        # need to keep walking in case its parents (which we</span>
<span class="gi">+                        # may not have seen yet) are excluded. This gives the</span>
<span class="gi">+                        # excluded set a chance to &quot;catch up&quot; while the commit</span>
<span class="gi">+                        # is still in the Walker&#39;s output queue.</span>
<span class="gi">+                        reset_extra_commits = True</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        reset_extra_commits = False</span>
<span class="gi">+</span>
<span class="gi">+            if self._min_time is not None and commit.commit_time &lt; self._min_time:</span>
<span class="gi">+                # We want to stop walking at min_time, but commits at the</span>
<span class="gi">+                # boundary may be out of order with respect to their parents.</span>
<span class="gi">+                # So we walk _MAX_EXTRA_COMMITS more commits once we hit this</span>
<span class="gi">+                # boundary.</span>
<span class="gi">+                reset_extra_commits = False</span>
<span class="gi">+</span>
<span class="gi">+            if reset_extra_commits:</span>
<span class="gi">+                # We&#39;re not at a boundary, so reset the counter.</span>
<span class="gi">+                self._extra_commits_left = _MAX_EXTRA_COMMITS</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._extra_commits_left -= 1</span>
<span class="gi">+                if not self._extra_commits_left:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if not is_excluded:</span>
<span class="gi">+                self._last = commit</span>
<span class="gi">+                return WalkEntry(self._walker, commit)</span>
<span class="gi">+        self._is_finished = True</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next


<span class="gu">@@ -69,12 +230,22 @@ class Walker:</span>
<span class="w"> </span>    be treated as iterators of Commit objects.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, store, include: List[bytes], exclude: Optional[List[</span>
<span class="gd">-        bytes]]=None, order: str=&#39;date&#39;, reverse: bool=False, max_entries:</span>
<span class="gd">-        Optional[int]=None, paths: Optional[List[bytes]]=None,</span>
<span class="gd">-        rename_detector: Optional[RenameDetector]=None, follow: bool=False,</span>
<span class="gd">-        since: Optional[int]=None, until: Optional[int]=None, get_parents=</span>
<span class="gd">-        lambda commit: commit.parents, queue_cls=_CommitTimeQueue) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        store,</span>
<span class="gi">+        include: List[bytes],</span>
<span class="gi">+        exclude: Optional[List[bytes]] = None,</span>
<span class="gi">+        order: str = &quot;date&quot;,</span>
<span class="gi">+        reverse: bool = False,</span>
<span class="gi">+        max_entries: Optional[int] = None,</span>
<span class="gi">+        paths: Optional[List[bytes]] = None,</span>
<span class="gi">+        rename_detector: Optional[RenameDetector] = None,</span>
<span class="gi">+        follow: bool = False,</span>
<span class="gi">+        since: Optional[int] = None,</span>
<span class="gi">+        until: Optional[int] = None,</span>
<span class="gi">+        get_parents=lambda commit: commit.parents,</span>
<span class="gi">+        queue_cls=_CommitTimeQueue,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructor.

<span class="w"> </span>        Args:
<span class="gu">@@ -101,10 +272,14 @@ class Walker:</span>
<span class="w"> </span>            iterator protocol. The constructor takes a single argument, the
<span class="w"> </span>            Walker.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # Note: when adding arguments to this method, please also update</span>
<span class="gi">+        # dulwich.repo.BaseRepo.get_walker</span>
<span class="w"> </span>        if order not in ALL_ORDERS:
<span class="gd">-            raise ValueError(f&#39;Unknown walk order {order}&#39;)</span>
<span class="gi">+            raise ValueError(f&quot;Unknown walk order {order}&quot;)</span>
<span class="w"> </span>        self.store = store
<span class="w"> </span>        if isinstance(include, bytes):
<span class="gi">+            # TODO(jelmer): Really, this should require a single type.</span>
<span class="gi">+            # Print deprecation warning here?</span>
<span class="w"> </span>            include = [include]
<span class="w"> </span>        self.include = include
<span class="w"> </span>        self.excluded = set(exclude or [])
<span class="gu">@@ -119,10 +294,41 @@ class Walker:</span>
<span class="w"> </span>        self.follow = follow
<span class="w"> </span>        self.since = since
<span class="w"> </span>        self.until = until
<span class="gi">+</span>
<span class="w"> </span>        self._num_entries = 0
<span class="w"> </span>        self._queue = queue_cls(self)
<span class="w"> </span>        self._out_queue: Deque[WalkEntry] = collections.deque()

<span class="gi">+    def _path_matches(self, changed_path):</span>
<span class="gi">+        if changed_path is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.paths is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        for followed_path in self.paths:</span>
<span class="gi">+            if changed_path == followed_path:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if (</span>
<span class="gi">+                changed_path.startswith(followed_path)</span>
<span class="gi">+                and changed_path[len(followed_path)] == b&quot;/&quot;[0]</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _change_matches(self, change):</span>
<span class="gi">+        if not change:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        old_path = change.old.path</span>
<span class="gi">+        new_path = change.new.path</span>
<span class="gi">+        if self._path_matches(new_path):</span>
<span class="gi">+            if self.follow and change.type in RENAME_CHANGE_TYPES:</span>
<span class="gi">+                self.paths.add(old_path)</span>
<span class="gi">+                self.paths.remove(new_path)</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif self._path_matches(old_path):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def _should_return(self, entry):
<span class="w"> </span>        &quot;&quot;&quot;Determine if a walk entry should be returned..

<span class="gu">@@ -131,7 +337,45 @@ class Walker:</span>
<span class="w"> </span>        Returns: True if the WalkEntry should be returned by this walk, or
<span class="w"> </span>            False otherwise (e.g. if it doesn&#39;t match any requested paths).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        commit = entry.commit</span>
<span class="gi">+        if self.since is not None and commit.commit_time &lt; self.since:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.until is not None and commit.commit_time &gt; self.until:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if commit.id in self.excluded:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if self.paths is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if len(self.get_parents(commit)) &gt; 1:</span>
<span class="gi">+            for path_changes in entry.changes():</span>
<span class="gi">+                # For merge commits, only include changes with conflicts for</span>
<span class="gi">+                # this path. Since a rename conflict may include different</span>
<span class="gi">+                # old.paths, we have to check all of them.</span>
<span class="gi">+                for change in path_changes:</span>
<span class="gi">+                    if self._change_matches(change):</span>
<span class="gi">+                        return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            for change in entry.changes():</span>
<span class="gi">+                if self._change_matches(change):</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _next(self):</span>
<span class="gi">+        max_entries = self.max_entries</span>
<span class="gi">+        while max_entries is None or self._num_entries &lt; max_entries:</span>
<span class="gi">+            entry = next(self._queue)</span>
<span class="gi">+            if entry is not None:</span>
<span class="gi">+                self._out_queue.append(entry)</span>
<span class="gi">+            if entry is None or len(self._out_queue) &gt; _MAX_EXTRA_COMMITS:</span>
<span class="gi">+                if not self._out_queue:</span>
<span class="gi">+                    return None</span>
<span class="gi">+                entry = self._out_queue.popleft()</span>
<span class="gi">+                if self._should_return(entry):</span>
<span class="gi">+                    self._num_entries += 1</span>
<span class="gi">+                    return entry</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _reorder(self, results):
<span class="w"> </span>        &quot;&quot;&quot;Possibly reorder a results iterator.
<span class="gu">@@ -142,7 +386,11 @@ class Walker:</span>
<span class="w"> </span>        Returns: An iterator or list of WalkEntry objects, in the order
<span class="w"> </span>            required by the Walker.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.order == ORDER_TOPO:</span>
<span class="gi">+            results = _topo_reorder(results, self.get_parents)</span>
<span class="gi">+        if self.reverse:</span>
<span class="gi">+            results = reversed(list(results))</span>
<span class="gi">+        return results</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter(self._reorder(iter(self._next, None)))
<span class="gu">@@ -160,4 +408,25 @@ def _topo_reorder(entries, get_parents=lambda commit: commit.parents):</span>
<span class="w"> </span>    Returns: iterator over WalkEntry objects from entries in FIFO order, except
<span class="w"> </span>        where a parent would be yielded before any of its children.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    todo = collections.deque()</span>
<span class="gi">+    pending = {}</span>
<span class="gi">+    num_children = collections.defaultdict(int)</span>
<span class="gi">+    for entry in entries:</span>
<span class="gi">+        todo.append(entry)</span>
<span class="gi">+        for p in get_parents(entry.commit):</span>
<span class="gi">+            num_children[p] += 1</span>
<span class="gi">+</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        entry = todo.popleft()</span>
<span class="gi">+        commit = entry.commit</span>
<span class="gi">+        commit_id = commit.id</span>
<span class="gi">+        if num_children[commit_id]:</span>
<span class="gi">+            pending[commit_id] = entry</span>
<span class="gi">+            continue</span>
<span class="gi">+        for parent_id in get_parents(commit):</span>
<span class="gi">+            num_children[parent_id] -= 1</span>
<span class="gi">+            if not num_children[parent_id]:</span>
<span class="gi">+                parent_entry = pending.pop(parent_id, None)</span>
<span class="gi">+                if parent_entry:</span>
<span class="gi">+                    todo.appendleft(parent_entry)</span>
<span class="gi">+        yield entry</span>
<span class="gh">diff --git a/dulwich/web.py b/dulwich/web.py</span>
<span class="gh">index f8c648e5..f62b3f1c 100644</span>
<span class="gd">--- a/dulwich/web.py</span>
<span class="gi">+++ b/dulwich/web.py</span>
<span class="gu">@@ -1,4 +1,26 @@</span>
<span class="gi">+# web.py -- WSGI smart-http server</span>
<span class="gi">+# Copyright (C) 2010 Google, Inc.</span>
<span class="gi">+# Copyright (C) 2012 Jelmer Vernooij &lt;jelmer@jelmer.uk&gt;</span>
<span class="gi">+#</span>
<span class="gi">+# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU</span>
<span class="gi">+# General Public License as public by the Free Software Foundation; version 2.0</span>
<span class="gi">+# or (at your option) any later version. You can redistribute it and/or</span>
<span class="gi">+# modify it under the terms of either of these two licenses.</span>
<span class="gi">+#</span>
<span class="gi">+# Unless required by applicable law or agreed to in writing, software</span>
<span class="gi">+# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="gi">+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="gi">+# See the License for the specific language governing permissions and</span>
<span class="gi">+# limitations under the License.</span>
<span class="gi">+#</span>
<span class="gi">+# You should have received a copy of the licenses; if not, see</span>
<span class="gi">+# &lt;http://www.gnu.org/licenses/&gt; for a copy of the GNU General Public License</span>
<span class="gi">+# and &lt;http://www.apache.org/licenses/LICENSE-2.0&gt; for a copy of the Apache</span>
<span class="gi">+# License, Version 2.0.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;HTTP server for dulwich that implements the git smart HTTP protocol.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gu">@@ -6,21 +28,90 @@ import time</span>
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from typing import Callable, ClassVar, Dict, Iterator, List, Optional, Tuple
<span class="w"> </span>from urllib.parse import parse_qs
<span class="gd">-from wsgiref.simple_server import ServerHandler, WSGIRequestHandler, WSGIServer, make_server</span>
<span class="gi">+from wsgiref.simple_server import (</span>
<span class="gi">+    ServerHandler,</span>
<span class="gi">+    WSGIRequestHandler,</span>
<span class="gi">+    WSGIServer,</span>
<span class="gi">+    make_server,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from dulwich import log_utils
<span class="gi">+</span>
<span class="w"> </span>from .protocol import ReceivableProtocol
<span class="w"> </span>from .repo import BaseRepo, NotGitRepository, Repo
<span class="gd">-from .server import DEFAULT_HANDLERS, Backend, DictBackend, generate_info_refs, generate_objects_info_packs</span>
<span class="gi">+from .server import (</span>
<span class="gi">+    DEFAULT_HANDLERS,</span>
<span class="gi">+    Backend,</span>
<span class="gi">+    DictBackend,</span>
<span class="gi">+    generate_info_refs,</span>
<span class="gi">+    generate_objects_info_packs,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>logger = log_utils.getLogger(__name__)
<span class="gd">-HTTP_OK = &#39;200 OK&#39;</span>
<span class="gd">-HTTP_NOT_FOUND = &#39;404 Not Found&#39;</span>
<span class="gd">-HTTP_FORBIDDEN = &#39;403 Forbidden&#39;</span>
<span class="gd">-HTTP_ERROR = &#39;500 Internal Server Error&#39;</span>
<span class="gd">-NO_CACHE_HEADERS = [(&#39;Expires&#39;, &#39;Fri, 01 Jan 1980 00:00:00 GMT&#39;), (&#39;Pragma&#39;,</span>
<span class="gd">-    &#39;no-cache&#39;), (&#39;Cache-Control&#39;, &#39;no-cache, max-age=0, must-revalidate&#39;)]</span>


<span class="gd">-def url_prefix(mat) -&gt;str:</span>
<span class="gi">+# HTTP error strings</span>
<span class="gi">+HTTP_OK = &quot;200 OK&quot;</span>
<span class="gi">+HTTP_NOT_FOUND = &quot;404 Not Found&quot;</span>
<span class="gi">+HTTP_FORBIDDEN = &quot;403 Forbidden&quot;</span>
<span class="gi">+HTTP_ERROR = &quot;500 Internal Server Error&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+NO_CACHE_HEADERS = [</span>
<span class="gi">+    (&quot;Expires&quot;, &quot;Fri, 01 Jan 1980 00:00:00 GMT&quot;),</span>
<span class="gi">+    (&quot;Pragma&quot;, &quot;no-cache&quot;),</span>
<span class="gi">+    (&quot;Cache-Control&quot;, &quot;no-cache, max-age=0, must-revalidate&quot;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cache_forever_headers(now=None):</span>
<span class="gi">+    if now is None:</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+    return [</span>
<span class="gi">+        (&quot;Date&quot;, date_time_string(now)),</span>
<span class="gi">+        (&quot;Expires&quot;, date_time_string(now + 31536000)),</span>
<span class="gi">+        (&quot;Cache-Control&quot;, &quot;public, max-age=31536000&quot;),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def date_time_string(timestamp: Optional[float] = None) -&gt; str:</span>
<span class="gi">+    # From BaseHTTPRequestHandler.date_time_string in BaseHTTPServer.py in the</span>
<span class="gi">+    # Python 2.6.5 standard library, following modifications:</span>
<span class="gi">+    #  - Made a global rather than an instance method.</span>
<span class="gi">+    #  - weekdayname and monthname are renamed and locals rather than class</span>
<span class="gi">+    #    variables.</span>
<span class="gi">+    # Copyright (c) 2001-2010 Python Software Foundation; All Rights Reserved</span>
<span class="gi">+    weekdays = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]</span>
<span class="gi">+    months = [</span>
<span class="gi">+        None,</span>
<span class="gi">+        &quot;Jan&quot;,</span>
<span class="gi">+        &quot;Feb&quot;,</span>
<span class="gi">+        &quot;Mar&quot;,</span>
<span class="gi">+        &quot;Apr&quot;,</span>
<span class="gi">+        &quot;May&quot;,</span>
<span class="gi">+        &quot;Jun&quot;,</span>
<span class="gi">+        &quot;Jul&quot;,</span>
<span class="gi">+        &quot;Aug&quot;,</span>
<span class="gi">+        &quot;Sep&quot;,</span>
<span class="gi">+        &quot;Oct&quot;,</span>
<span class="gi">+        &quot;Nov&quot;,</span>
<span class="gi">+        &quot;Dec&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    if timestamp is None:</span>
<span class="gi">+        timestamp = time.time()</span>
<span class="gi">+    year, month, day, hh, mm, ss, wd = time.gmtime(timestamp)[:7]</span>
<span class="gi">+    return &quot;%s, %02d %3s %4d %02d:%02d:%02d GMD&quot; % (</span>
<span class="gi">+        weekdays[wd],</span>
<span class="gi">+        day,</span>
<span class="gi">+        months[month],</span>
<span class="gi">+        year,</span>
<span class="gi">+        hh,</span>
<span class="gi">+        mm,</span>
<span class="gi">+        ss,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def url_prefix(mat) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract the URL prefix from a regex match.

<span class="w"> </span>    Args:
<span class="gu">@@ -29,12 +120,12 @@ def url_prefix(mat) -&gt;str:</span>
<span class="w"> </span>        original string. Normalized to start with one leading slash and end
<span class="w"> </span>        with zero.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &quot;/&quot; + mat.string[: mat.start()].strip(&quot;/&quot;)</span>


<span class="gd">-def get_repo(backend, mat) -&gt;BaseRepo:</span>
<span class="gi">+def get_repo(backend, mat) -&gt; BaseRepo:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get a Repo instance for the given backend and URL regex match.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return backend.open_repository(url_prefix(mat))</span>


<span class="w"> </span>def send_file(req, f, content_type):
<span class="gu">@@ -46,15 +137,140 @@ def send_file(req, f, content_type):</span>
<span class="w"> </span>      content_type: The MIME type for the file.
<span class="w"> </span>    Returns: Iterator over the contents of the file, as chunks.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if f is None:</span>
<span class="gi">+        yield req.not_found(&quot;File not found&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+    try:</span>
<span class="gi">+        req.respond(HTTP_OK, content_type)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            data = f.read(10240)</span>
<span class="gi">+            if not data:</span>
<span class="gi">+                break</span>
<span class="gi">+            yield data</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        yield req.error(&quot;Error reading file&quot;)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        f.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _url_to_path(url):</span>
<span class="gi">+    return url.replace(&quot;/&quot;, os.path.sep)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_text_file(req, backend, mat):</span>
<span class="gi">+    req.nocache()</span>
<span class="gi">+    path = _url_to_path(mat.group())</span>
<span class="gi">+    logger.info(&quot;Sending plain text file %s&quot;, path)</span>
<span class="gi">+    return send_file(req, get_repo(backend, mat).get_named_file(path), &quot;text/plain&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_loose_object(req, backend, mat):</span>
<span class="gi">+    sha = (mat.group(1) + mat.group(2)).encode(&quot;ascii&quot;)</span>
<span class="gi">+    logger.info(&quot;Sending loose object %s&quot;, sha)</span>
<span class="gi">+    object_store = get_repo(backend, mat).object_store</span>
<span class="gi">+    if not object_store.contains_loose(sha):</span>
<span class="gi">+        yield req.not_found(&quot;Object not found&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+    try:</span>
<span class="gi">+        data = object_store[sha].as_legacy_object()</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        yield req.error(&quot;Error reading object&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+    req.cache_forever()</span>
<span class="gi">+    req.respond(HTTP_OK, &quot;application/x-git-loose-object&quot;)</span>
<span class="gi">+    yield data</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_pack_file(req, backend, mat):</span>
<span class="gi">+    req.cache_forever()</span>
<span class="gi">+    path = _url_to_path(mat.group())</span>
<span class="gi">+    logger.info(&quot;Sending pack file %s&quot;, path)</span>
<span class="gi">+    return send_file(</span>
<span class="gi">+        req,</span>
<span class="gi">+        get_repo(backend, mat).get_named_file(path),</span>
<span class="gi">+        &quot;application/x-git-packed-objects&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_idx_file(req, backend, mat):</span>
<span class="gi">+    req.cache_forever()</span>
<span class="gi">+    path = _url_to_path(mat.group())</span>
<span class="gi">+    logger.info(&quot;Sending pack file %s&quot;, path)</span>
<span class="gi">+    return send_file(</span>
<span class="gi">+        req,</span>
<span class="gi">+        get_repo(backend, mat).get_named_file(path),</span>
<span class="gi">+        &quot;application/x-git-packed-objects-toc&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_info_refs(req, backend, mat):</span>
<span class="gi">+    params = parse_qs(req.environ[&quot;QUERY_STRING&quot;])</span>
<span class="gi">+    service = params.get(&quot;service&quot;, [None])[0]</span>
<span class="gi">+    try:</span>
<span class="gi">+        repo = get_repo(backend, mat)</span>
<span class="gi">+    except NotGitRepository as e:</span>
<span class="gi">+        yield req.not_found(str(e))</span>
<span class="gi">+        return</span>
<span class="gi">+    if service and not req.dumb:</span>
<span class="gi">+        handler_cls = req.handlers.get(service.encode(&quot;ascii&quot;), None)</span>
<span class="gi">+        if handler_cls is None:</span>
<span class="gi">+            yield req.forbidden(&quot;Unsupported service&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+        req.nocache()</span>
<span class="gi">+        write = req.respond(HTTP_OK, f&quot;application/x-{service}-advertisement&quot;)</span>
<span class="gi">+        proto = ReceivableProtocol(BytesIO().read, write)</span>
<span class="gi">+        handler = handler_cls(</span>
<span class="gi">+            backend,</span>
<span class="gi">+            [url_prefix(mat)],</span>
<span class="gi">+            proto,</span>
<span class="gi">+            stateless_rpc=True,</span>
<span class="gi">+            advertise_refs=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        handler.proto.write_pkt_line(b&quot;# service=&quot; + service.encode(&quot;ascii&quot;) + b&quot;\n&quot;)</span>
<span class="gi">+        handler.proto.write_pkt_line(None)</span>
<span class="gi">+        handler.handle()</span>
<span class="gi">+    else:</span>
<span class="gi">+        # non-smart fallback</span>
<span class="gi">+        # TODO: select_getanyfile() (see http-backend.c)</span>
<span class="gi">+        req.nocache()</span>
<span class="gi">+        req.respond(HTTP_OK, &quot;text/plain&quot;)</span>
<span class="gi">+        logger.info(&quot;Emulating dumb info/refs&quot;)</span>
<span class="gi">+        yield from generate_info_refs(repo)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_info_packs(req, backend, mat):</span>
<span class="gi">+    req.nocache()</span>
<span class="gi">+    req.respond(HTTP_OK, &quot;text/plain&quot;)</span>
<span class="gi">+    logger.info(&quot;Emulating dumb info/packs&quot;)</span>
<span class="gi">+    return generate_objects_info_packs(get_repo(backend, mat))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _chunk_iter(f):</span>
<span class="gi">+    while True:</span>
<span class="gi">+        line = f.readline()</span>
<span class="gi">+        length = int(line.rstrip(), 16)</span>
<span class="gi">+        chunk = f.read(length + 2)</span>
<span class="gi">+        if length == 0:</span>
<span class="gi">+            break</span>
<span class="gi">+        yield chunk[:-2]</span>


<span class="w"> </span>class ChunkReader:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, f) -&gt;None:</span>
<span class="gi">+    def __init__(self, f) -&gt; None:</span>
<span class="w"> </span>        self._iter = _chunk_iter(f)
<span class="w"> </span>        self._buffer: List[bytes] = []

<span class="gi">+    def read(self, n):</span>
<span class="gi">+        while sum(map(len, self._buffer)) &lt; n:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._buffer.append(next(self._iter))</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                break</span>
<span class="gi">+        f = b&quot;&quot;.join(self._buffer)</span>
<span class="gi">+        ret = f[:n]</span>
<span class="gi">+        self._buffer = [f[n:]]</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>

<span class="w"> </span>class _LengthLimitedFile:
<span class="w"> </span>    &quot;&quot;&quot;Wrapper class to limit the length of reads from a file-like object.
<span class="gu">@@ -64,10 +280,45 @@ class _LengthLimitedFile:</span>
<span class="w"> </span>    but not implemented in wsgiref as of 2.5.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, input, max_bytes) -&gt;None:</span>
<span class="gi">+    def __init__(self, input, max_bytes) -&gt; None:</span>
<span class="w"> </span>        self._input = input
<span class="w"> </span>        self._bytes_avail = max_bytes

<span class="gi">+    def read(self, size=-1):</span>
<span class="gi">+        if self._bytes_avail &lt;= 0:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        if size == -1 or size &gt; self._bytes_avail:</span>
<span class="gi">+            size = self._bytes_avail</span>
<span class="gi">+        self._bytes_avail -= size</span>
<span class="gi">+        return self._input.read(size)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: support more methods as necessary</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_service_request(req, backend, mat):</span>
<span class="gi">+    service = mat.group().lstrip(&quot;/&quot;)</span>
<span class="gi">+    logger.info(&quot;Handling service request for %s&quot;, service)</span>
<span class="gi">+    handler_cls = req.handlers.get(service.encode(&quot;ascii&quot;), None)</span>
<span class="gi">+    if handler_cls is None:</span>
<span class="gi">+        yield req.forbidden(&quot;Unsupported service&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+    try:</span>
<span class="gi">+        get_repo(backend, mat)</span>
<span class="gi">+    except NotGitRepository as e:</span>
<span class="gi">+        yield req.not_found(str(e))</span>
<span class="gi">+        return</span>
<span class="gi">+    req.nocache()</span>
<span class="gi">+    write = req.respond(HTTP_OK, f&quot;application/x-{service}-result&quot;)</span>
<span class="gi">+    if req.environ.get(&quot;HTTP_TRANSFER_ENCODING&quot;) == &quot;chunked&quot;:</span>
<span class="gi">+        read = ChunkReader(req.environ[&quot;wsgi.input&quot;]).read</span>
<span class="gi">+    else:</span>
<span class="gi">+        read = req.environ[&quot;wsgi.input&quot;].read</span>
<span class="gi">+    proto = ReceivableProtocol(read, write)</span>
<span class="gi">+    # TODO(jelmer): Find a way to pass in repo, rather than having handler_cls</span>
<span class="gi">+    # reopen.</span>
<span class="gi">+    handler = handler_cls(backend, [url_prefix(mat)], proto, stateless_rpc=True)</span>
<span class="gi">+    handler.handle()</span>
<span class="gi">+</span>

<span class="w"> </span>class HTTPGitRequest:
<span class="w"> </span>    &quot;&quot;&quot;Class encapsulating the state of a single git HTTP request.
<span class="gu">@@ -76,8 +327,9 @@ class HTTPGitRequest:</span>
<span class="w"> </span>      environ: the WSGI environment for the request.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environ, start_response, dumb: bool=False, handlers=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, environ, start_response, dumb: bool = False, handlers=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.environ = environ
<span class="w"> </span>        self.dumb = dumb
<span class="w"> </span>        self.handlers = handlers
<span class="gu">@@ -87,32 +339,51 @@ class HTTPGitRequest:</span>

<span class="w"> </span>    def add_header(self, name, value):
<span class="w"> </span>        &quot;&quot;&quot;Add a header to the response.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def respond(self, status: str=HTTP_OK, content_type: Optional[str]=None,</span>
<span class="gd">-        headers: Optional[List[Tuple[str, str]]]=None):</span>
<span class="gi">+        self._headers.append((name, value))</span>
<span class="gi">+</span>
<span class="gi">+    def respond(</span>
<span class="gi">+        self,</span>
<span class="gi">+        status: str = HTTP_OK,</span>
<span class="gi">+        content_type: Optional[str] = None,</span>
<span class="gi">+        headers: Optional[List[Tuple[str, str]]] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a response with the given status and other headers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if headers:</span>
<span class="gi">+            self._headers.extend(headers)</span>
<span class="gi">+        if content_type:</span>
<span class="gi">+            self._headers.append((&quot;Content-Type&quot;, content_type))</span>
<span class="gi">+        self._headers.extend(self._cache_headers)</span>

<span class="gd">-    def not_found(self, message: str) -&gt;bytes:</span>
<span class="gi">+        return self._start_response(status, self._headers)</span>
<span class="gi">+</span>
<span class="gi">+    def not_found(self, message: str) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a HTTP 404 response and return the text of a message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache_headers = []</span>
<span class="gi">+        logger.info(&quot;Not found: %s&quot;, message)</span>
<span class="gi">+        self.respond(HTTP_NOT_FOUND, &quot;text/plain&quot;)</span>
<span class="gi">+        return message.encode(&quot;ascii&quot;)</span>

<span class="gd">-    def forbidden(self, message: str) -&gt;bytes:</span>
<span class="gi">+    def forbidden(self, message: str) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a HTTP 403 response and return the text of a message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache_headers = []</span>
<span class="gi">+        logger.info(&quot;Forbidden: %s&quot;, message)</span>
<span class="gi">+        self.respond(HTTP_FORBIDDEN, &quot;text/plain&quot;)</span>
<span class="gi">+        return message.encode(&quot;ascii&quot;)</span>

<span class="gd">-    def error(self, message: str) -&gt;bytes:</span>
<span class="gi">+    def error(self, message: str) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin a HTTP 500 response and return the text of a message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache_headers = []</span>
<span class="gi">+        logger.error(&quot;Error: %s&quot;, message)</span>
<span class="gi">+        self.respond(HTTP_ERROR, &quot;text/plain&quot;)</span>
<span class="gi">+        return message.encode(&quot;ascii&quot;)</span>

<span class="gd">-    def nocache(self) -&gt;None:</span>
<span class="gi">+    def nocache(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the response to never be cached by the client.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache_headers = NO_CACHE_HEADERS</span>

<span class="gd">-    def cache_forever(self) -&gt;None:</span>
<span class="gi">+    def cache_forever(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the response to be cached forever by the client.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cache_headers = cache_forever_headers()</span>


<span class="w"> </span>class HTTPGitApplication:
<span class="gu">@@ -121,23 +392,37 @@ class HTTPGitApplication:</span>
<span class="w"> </span>    Attributes:
<span class="w"> </span>      backend: the Backend object backing this application
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    services: ClassVar[Dict[Tuple[str, re.Pattern], Callable[[</span>
<span class="gd">-        HTTPGitRequest, Backend, re.Match], Iterator[bytes]]]] = {(&#39;GET&#39;,</span>
<span class="gd">-        re.compile(&#39;/HEAD$&#39;)): get_text_file, (&#39;GET&#39;, re.compile(</span>
<span class="gd">-        &#39;/info/refs$&#39;)): get_info_refs, (&#39;GET&#39;, re.compile(</span>
<span class="gd">-        &#39;/objects/info/alternates$&#39;)): get_text_file, (&#39;GET&#39;, re.compile(</span>
<span class="gd">-        &#39;/objects/info/http-alternates$&#39;)): get_text_file, (&#39;GET&#39;, re.</span>
<span class="gd">-        compile(&#39;/objects/info/packs$&#39;)): get_info_packs, (&#39;GET&#39;, re.</span>
<span class="gd">-        compile(&#39;/objects/([0-9a-f]{2})/([0-9a-f]{38})$&#39;)):</span>
<span class="gd">-        get_loose_object, (&#39;GET&#39;, re.compile(</span>
<span class="gd">-        &#39;/objects/pack/pack-([0-9a-f]{40})\\.pack$&#39;)): get_pack_file, (</span>
<span class="gd">-        &#39;GET&#39;, re.compile(&#39;/objects/pack/pack-([0-9a-f]{40})\\.idx$&#39;)):</span>
<span class="gd">-        get_idx_file, (&#39;POST&#39;, re.compile(&#39;/git-upload-pack$&#39;)):</span>
<span class="gd">-        handle_service_request, (&#39;POST&#39;, re.compile(&#39;/git-receive-pack$&#39;)):</span>
<span class="gd">-        handle_service_request}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, backend, dumb: bool=False, handlers=None,</span>
<span class="gd">-        fallback_app=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    services: ClassVar[</span>
<span class="gi">+        Dict[</span>
<span class="gi">+            Tuple[str, re.Pattern],</span>
<span class="gi">+            Callable[[HTTPGitRequest, Backend, re.Match], Iterator[bytes]],</span>
<span class="gi">+        ]</span>
<span class="gi">+    ] = {</span>
<span class="gi">+        (&quot;GET&quot;, re.compile(&quot;/HEAD$&quot;)): get_text_file,</span>
<span class="gi">+        (&quot;GET&quot;, re.compile(&quot;/info/refs$&quot;)): get_info_refs,</span>
<span class="gi">+        (&quot;GET&quot;, re.compile(&quot;/objects/info/alternates$&quot;)): get_text_file,</span>
<span class="gi">+        (&quot;GET&quot;, re.compile(&quot;/objects/info/http-alternates$&quot;)): get_text_file,</span>
<span class="gi">+        (&quot;GET&quot;, re.compile(&quot;/objects/info/packs$&quot;)): get_info_packs,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;GET&quot;,</span>
<span class="gi">+            re.compile(&quot;/objects/([0-9a-f]{2})/([0-9a-f]{38})$&quot;),</span>
<span class="gi">+        ): get_loose_object,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;GET&quot;,</span>
<span class="gi">+            re.compile(&quot;/objects/pack/pack-([0-9a-f]{40})\\.pack$&quot;),</span>
<span class="gi">+        ): get_pack_file,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;GET&quot;,</span>
<span class="gi">+            re.compile(&quot;/objects/pack/pack-([0-9a-f]{40})\\.idx$&quot;),</span>
<span class="gi">+        ): get_idx_file,</span>
<span class="gi">+        (&quot;POST&quot;, re.compile(&quot;/git-upload-pack$&quot;)): handle_service_request,</span>
<span class="gi">+        (&quot;POST&quot;, re.compile(&quot;/git-receive-pack$&quot;)): handle_service_request,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, backend, dumb: bool = False, handlers=None, fallback_app=None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.backend = backend
<span class="w"> </span>        self.dumb = dumb
<span class="w"> </span>        self.handlers = dict(DEFAULT_HANDLERS)
<span class="gu">@@ -146,10 +431,12 @@ class HTTPGitApplication:</span>
<span class="w"> </span>            self.handlers.update(handlers)

<span class="w"> </span>    def __call__(self, environ, start_response):
<span class="gd">-        path = environ[&#39;PATH_INFO&#39;]</span>
<span class="gd">-        method = environ[&#39;REQUEST_METHOD&#39;]</span>
<span class="gd">-        req = HTTPGitRequest(environ, start_response, dumb=self.dumb,</span>
<span class="gd">-            handlers=self.handlers)</span>
<span class="gi">+        path = environ[&quot;PATH_INFO&quot;]</span>
<span class="gi">+        method = environ[&quot;REQUEST_METHOD&quot;]</span>
<span class="gi">+        req = HTTPGitRequest(</span>
<span class="gi">+            environ, start_response, dumb=self.dumb, handlers=self.handlers</span>
<span class="gi">+        )</span>
<span class="gi">+        # environ[&#39;QUERY_STRING&#39;] has qs args</span>
<span class="w"> </span>        handler = None
<span class="w"> </span>        for smethod, spath in self.services.keys():
<span class="w"> </span>            if smethod != method:
<span class="gu">@@ -158,11 +445,13 @@ class HTTPGitApplication:</span>
<span class="w"> </span>            if mat:
<span class="w"> </span>                handler = self.services[smethod, spath]
<span class="w"> </span>                break
<span class="gi">+</span>
<span class="w"> </span>        if handler is None:
<span class="w"> </span>            if self.fallback_app is not None:
<span class="w"> </span>                return self.fallback_app(environ, start_response)
<span class="w"> </span>            else:
<span class="gd">-                return [req.not_found(&#39;Sorry, that method is not supported&#39;)]</span>
<span class="gi">+                return [req.not_found(&quot;Sorry, that method is not supported&quot;)]</span>
<span class="gi">+</span>
<span class="w"> </span>        return handler(req, self.backend, mat)


<span class="gu">@@ -171,17 +460,20 @@ class GunzipFilter:</span>
<span class="w"> </span>    passing on to the underlying application.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, application) -&gt;None:</span>
<span class="gi">+    def __init__(self, application) -&gt; None:</span>
<span class="w"> </span>        self.app = application

<span class="w"> </span>    def __call__(self, environ, start_response):
<span class="w"> </span>        import gzip
<span class="gd">-        if environ.get(&#39;HTTP_CONTENT_ENCODING&#39;, &#39;&#39;) == &#39;gzip&#39;:</span>
<span class="gd">-            environ[&#39;wsgi.input&#39;] = gzip.GzipFile(filename=None, fileobj=</span>
<span class="gd">-                environ[&#39;wsgi.input&#39;], mode=&#39;rb&#39;)</span>
<span class="gd">-            del environ[&#39;HTTP_CONTENT_ENCODING&#39;]</span>
<span class="gd">-            if &#39;CONTENT_LENGTH&#39; in environ:</span>
<span class="gd">-                del environ[&#39;CONTENT_LENGTH&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if environ.get(&quot;HTTP_CONTENT_ENCODING&quot;, &quot;&quot;) == &quot;gzip&quot;:</span>
<span class="gi">+            environ[&quot;wsgi.input&quot;] = gzip.GzipFile(</span>
<span class="gi">+                filename=None, fileobj=environ[&quot;wsgi.input&quot;], mode=&quot;rb&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            del environ[&quot;HTTP_CONTENT_ENCODING&quot;]</span>
<span class="gi">+            if &quot;CONTENT_LENGTH&quot; in environ:</span>
<span class="gi">+                del environ[&quot;CONTENT_LENGTH&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>        return self.app(environ, start_response)


<span class="gu">@@ -190,14 +482,19 @@ class LimitedInputFilter:</span>
<span class="w"> </span>    specified in Content-Length.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, application) -&gt;None:</span>
<span class="gi">+    def __init__(self, application) -&gt; None:</span>
<span class="w"> </span>        self.app = application

<span class="w"> </span>    def __call__(self, environ, start_response):
<span class="gd">-        content_length = environ.get(&#39;CONTENT_LENGTH&#39;, &#39;&#39;)</span>
<span class="gi">+        # This is not necessary if this app is run from a conforming WSGI</span>
<span class="gi">+        # server. Unfortunately, there&#39;s no way to tell that at this point.</span>
<span class="gi">+        # TODO: git may used HTTP/1.1 chunked encoding instead of specifying</span>
<span class="gi">+        # content-length</span>
<span class="gi">+        content_length = environ.get(&quot;CONTENT_LENGTH&quot;, &quot;&quot;)</span>
<span class="w"> </span>        if content_length:
<span class="gd">-            environ[&#39;wsgi.input&#39;] = _LengthLimitedFile(environ[&#39;wsgi.input&#39;</span>
<span class="gd">-                ], int(content_length))</span>
<span class="gi">+            environ[&quot;wsgi.input&quot;] = _LengthLimitedFile(</span>
<span class="gi">+                environ[&quot;wsgi.input&quot;], int(content_length)</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return self.app(environ, start_response)


<span class="gu">@@ -205,32 +502,107 @@ def make_wsgi_chain(*args, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Factory function to create an instance of HTTPGitApplication,
<span class="w"> </span>    correctly wrapped with needed middleware.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = HTTPGitApplication(*args, **kwargs)</span>
<span class="gi">+    wrapped_app = LimitedInputFilter(GunzipFilter(app))</span>
<span class="gi">+    return wrapped_app</span>


<span class="w"> </span>class ServerHandlerLogger(ServerHandler):
<span class="w"> </span>    &quot;&quot;&quot;ServerHandler that uses dulwich&#39;s logger for logging exceptions.&quot;&quot;&quot;

<span class="gi">+    def log_exception(self, exc_info):</span>
<span class="gi">+        logger.exception(</span>
<span class="gi">+            &quot;Exception happened during processing of request&quot;,</span>
<span class="gi">+            exc_info=exc_info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def log_message(self, format, *args):</span>
<span class="gi">+        logger.info(format, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def log_error(self, *args):</span>
<span class="gi">+        logger.error(*args)</span>
<span class="gi">+</span>

<span class="w"> </span>class WSGIRequestHandlerLogger(WSGIRequestHandler):
<span class="w"> </span>    &quot;&quot;&quot;WSGIRequestHandler that uses dulwich&#39;s logger for logging exceptions.&quot;&quot;&quot;

<span class="gi">+    def log_exception(self, exc_info):</span>
<span class="gi">+        logger.exception(</span>
<span class="gi">+            &quot;Exception happened during processing of request&quot;,</span>
<span class="gi">+            exc_info=exc_info,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def log_message(self, format, *args):</span>
<span class="gi">+        logger.info(format, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def log_error(self, *args):</span>
<span class="gi">+        logger.error(*args)</span>
<span class="gi">+</span>
<span class="w"> </span>    def handle(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle a single HTTP request.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.raw_requestline = self.rfile.readline()</span>
<span class="gi">+        if not self.parse_request():  # An error code has been sent, just exit</span>
<span class="gi">+            return</span>

<span class="gi">+        handler = ServerHandlerLogger(</span>
<span class="gi">+            self.rfile, self.wfile, self.get_stderr(), self.get_environ()</span>
<span class="gi">+        )</span>
<span class="gi">+        handler.request_handler = self  # backpointer for logging</span>
<span class="gi">+        handler.run(self.server.get_app())</span>

<span class="gd">-class WSGIServerLogger(WSGIServer):</span>

<span class="gi">+class WSGIServerLogger(WSGIServer):</span>
<span class="w"> </span>    def handle_error(self, request, client_address):
<span class="w"> </span>        &quot;&quot;&quot;Handle an error.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.exception(</span>
<span class="gi">+            f&quot;Exception happened during processing of request from {client_address!s}&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def main(argv=sys.argv):
<span class="w"> </span>    &quot;&quot;&quot;Entry point for starting an HTTP git server.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    import optparse</span>
<span class="gi">+</span>
<span class="gi">+    parser = optparse.OptionParser()</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-l&quot;,</span>
<span class="gi">+        &quot;--listen_address&quot;,</span>
<span class="gi">+        dest=&quot;listen_address&quot;,</span>
<span class="gi">+        default=&quot;localhost&quot;,</span>
<span class="gi">+        help=&quot;Binding IP address.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_option(</span>
<span class="gi">+        &quot;-p&quot;,</span>
<span class="gi">+        &quot;--port&quot;,</span>
<span class="gi">+        dest=&quot;port&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=8000,</span>
<span class="gi">+        help=&quot;Port to listen on.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    options, args = parser.parse_args(argv)</span>
<span class="gi">+</span>
<span class="gi">+    if len(args) &gt; 1:</span>
<span class="gi">+        gitdir = args[1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        gitdir = os.getcwd()</span>
<span class="gi">+</span>
<span class="gi">+    log_utils.default_logging_config()</span>
<span class="gi">+    backend = DictBackend({&quot;/&quot;: Repo(gitdir)})</span>
<span class="gi">+    app = make_wsgi_chain(backend)</span>
<span class="gi">+    server = make_server(</span>
<span class="gi">+        options.listen_address,</span>
<span class="gi">+        options.port,</span>
<span class="gi">+        app,</span>
<span class="gi">+        handler_class=WSGIRequestHandlerLogger,</span>
<span class="gi">+        server_class=WSGIServerLogger,</span>
<span class="gi">+    )</span>
<span class="gi">+    logger.info(</span>
<span class="gi">+        &quot;Listening for HTTP connections on %s:%d&quot;,</span>
<span class="gi">+        options.listen_address,</span>
<span class="gi">+        options.port,</span>
<span class="gi">+    )</span>
<span class="gi">+    server.serve_forever()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>