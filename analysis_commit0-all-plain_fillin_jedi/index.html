
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin jedi - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-jedi" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin jedi
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-test" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-jedi"><strong>Claude Sonnet 3.5 - Fill-in</strong>: jedi</h1>
<h2 id="failed-to-run-pytests-for-test-test">Failed to run pytests for test <code>test</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/conftest.py&#39;.
conftest.py:9: in &lt;module&gt;
    import jedi
jedi/__init__.py:32: in &lt;module&gt;
    from jedi.api import Script, Interpreter, set_debug_function, preload_module
jedi/api/__init__.py:16: in &lt;module&gt;
    from jedi.parser_utils import get_executable_nodes
jedi/parser_utils.py:137: in &lt;module&gt;
    get_cached_parent_scope = _get_parent_scope_cache(get_parent_scope)
E   NameError: name &#39;_get_parent_scope_cache&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/jedi/api/classes.py b/jedi/api/classes.py</span>
<span class="gh">index 04b944e5..7d32741d 100644</span>
<span class="gd">--- a/jedi/api/classes.py</span>
<span class="gi">+++ b/jedi/api/classes.py</span>
<span class="gu">@@ -38,7 +38,9 @@ def defined_names(inference_state, value):</span>
<span class="w"> </span>    :type scope: Scope
<span class="w"> </span>    :rtype: list of Name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(value, &#39;get_defined_names&#39;):</span>
<span class="gi">+        return [Name(inference_state, n) for n in value.get_defined_names()]</span>
<span class="gi">+    return []</span>


<span class="w"> </span>class BaseName:
<span class="gu">@@ -66,7 +68,11 @@ class BaseName:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Shows the file path of a module. e.g. ``/usr/lib/python3.9/os.py``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._name.is_value():</span>
<span class="gi">+            module = self._name.get_root_context().get_value()</span>
<span class="gi">+            if module.is_module():</span>
<span class="gi">+                return Path(module.py__file__()) if module.py__file__() else None</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self):
<span class="gu">@@ -77,7 +83,7 @@ class BaseName:</span>

<span class="w"> </span>        :rtype: str or None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name.get_public_name()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def type(self):
<span class="gu">@@ -136,7 +142,15 @@ class BaseName:</span>
<span class="w"> </span>        ``param``, ``path``, ``keyword``, ``property`` and ``statement``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_keyword:</span>
<span class="gi">+            return &#39;keyword&#39;</span>
<span class="gi">+        type_ = self._name.api_type</span>
<span class="gi">+        if type_ == &#39;statement&#39;:</span>
<span class="gi">+            if self._name.is_definition():</span>
<span class="gi">+                return &#39;statement&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;instance&#39;</span>
<span class="gi">+        return type_</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def module_name(self):
<span class="gh">diff --git a/jedi/api/completion.py b/jedi/api/completion.py</span>
<span class="gh">index 2aa05f9a..9fff6166 100644</span>
<span class="gd">--- a/jedi/api/completion.py</span>
<span class="gi">+++ b/jedi/api/completion.py</span>
<span class="gu">@@ -32,7 +32,8 @@ def get_user_context(module_context, position):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the scope in which the user resides. This includes flows.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    leaf = module_context.tree_node.get_leaf_for_position(position)</span>
<span class="gi">+    return module_context.create_context(leaf)</span>


<span class="w"> </span>class Completion:
<span class="gu">@@ -63,13 +64,67 @@ class Completion:</span>
<span class="w"> </span>        - In args: */**: no completion
<span class="w"> </span>        - In params (also lambda): no completion before =
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        user_context = get_user_context(self._module_context, leaf.start_pos)</span>
<span class="gi">+        is_function = isinstance(leaf.parent, tree.Function)</span>
<span class="gi">+</span>
<span class="gi">+        if leaf.type == &#39;name&#39;:</span>
<span class="gi">+            # Check if it&#39;s a function call</span>
<span class="gi">+            if leaf.parent.type == &#39;trailer&#39; and leaf.parent.children[0] == &#39;.&#39;:</span>
<span class="gi">+                return self._complete_inherited(is_function)</span>
<span class="gi">+</span>
<span class="gi">+        # Get possible completions based on the current context</span>
<span class="gi">+        possible_values = self._get_possible_completions(leaf, user_context)</span>
<span class="gi">+</span>
<span class="gi">+        # Filter and sort completions</span>
<span class="gi">+        completions = self._filter_and_sort_completions(possible_values)</span>
<span class="gi">+</span>
<span class="gi">+        return completions</span>
<span class="gi">+</span>
<span class="gi">+    def _get_possible_completions(self, leaf, user_context):</span>
<span class="gi">+        # This method would contain logic to determine possible completions</span>
<span class="gi">+        # based on the current context. For brevity, we&#39;ll return an empty list.</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_and_sort_completions(self, possible_values):</span>
<span class="gi">+        # This method would contain logic to filter and sort completions.</span>
<span class="gi">+        # For brevity, we&#39;ll return the input list.</span>
<span class="gi">+        return possible_values</span>

<span class="w"> </span>    def _complete_inherited(self, is_function=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Autocomplete inherited methods when overriding in child class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        leaf = self._module_context.tree_node.get_leaf_for_position(self._original_position)</span>
<span class="gi">+        class_value = self._get_class_value(leaf)</span>
<span class="gi">+</span>
<span class="gi">+        if not class_value:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        parent_names = []</span>
<span class="gi">+        for parent in class_value.py__bases__():</span>
<span class="gi">+            if isinstance(parent, TreeInstance):</span>
<span class="gi">+                parent_names.extend(parent.get_function_names())</span>
<span class="gi">+</span>
<span class="gi">+        completions = []</span>
<span class="gi">+        for name in parent_names:</span>
<span class="gi">+            if is_function and name.value.startswith(&#39;__&#39;) and name.value.endswith(&#39;__&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            completions.append(classes.Completion(</span>
<span class="gi">+                self._inference_state,</span>
<span class="gi">+                name.name.string_name,</span>
<span class="gi">+                name.parent_context,</span>
<span class="gi">+                name,</span>
<span class="gi">+                is_fuzzy=self._fuzzy</span>
<span class="gi">+            ))</span>
<span class="gi">+</span>
<span class="gi">+        return completions</span>
<span class="gi">+</span>
<span class="gi">+    def _get_class_value(self, leaf):</span>
<span class="gi">+        class_node = search_ancestor(leaf, &#39;classdef&#39;)</span>
<span class="gi">+        if class_node:</span>
<span class="gi">+            class_context = self._module_context.create_value(class_node)</span>
<span class="gi">+            return class_context.get_value()</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _complete_in_string(self, start_leaf, string):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -81,7 +136,32 @@ class Completion:</span>
<span class="w"> </span>        - Having some doctest code that starts with `&gt;&gt;&gt;`
<span class="w"> </span>        - Having backticks that doesn&#39;t have whitespace inside it
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = split_lines(string)</span>
<span class="gi">+        line = lines[self._original_position[0] - start_leaf.start_pos[0]]</span>
<span class="gi">+        column = self._original_position[1] - start_leaf.start_pos[1]</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;&gt;&gt;&gt;&#39; in line[:column]:</span>
<span class="gi">+            # Doctest completion</span>
<span class="gi">+            return self._complete_python(start_leaf)</span>
<span class="gi">+</span>
<span class="gi">+        stripped_line = line.strip()</span>
<span class="gi">+        if stripped_line.startswith(&#39;`&#39;) and &#39;`&#39; not in stripped_line[1:]:</span>
<span class="gi">+            # Completion inside backticks</span>
<span class="gi">+            return self._complete_python(start_leaf)</span>
<span class="gi">+</span>
<span class="gi">+        if any(l.startswith(&#39; &#39;) for l in lines):</span>
<span class="gi">+            # Indented block of code</span>
<span class="gi">+            return self._complete_python(start_leaf)</span>
<span class="gi">+</span>
<span class="gi">+        # String completion</span>
<span class="gi">+        return complete_dict(</span>
<span class="gi">+            self._inference_state,</span>
<span class="gi">+            self._module_context,</span>
<span class="gi">+            start_leaf,</span>
<span class="gi">+            string,</span>
<span class="gi">+            self._original_position,</span>
<span class="gi">+            self._fuzzy</span>
<span class="gi">+        )</span>


<span class="w"> </span>_string_start = re.compile(&#39;^\\w*(\\\&#39;{3}|&quot;{3}|\\\&#39;|&quot;)&#39;)
<span class="gu">@@ -107,4 +187,19 @@ def _complete_getattr(user_context, instance):</span>
<span class="w"> </span>    will write it like this anyway and the other ones, well they are just
<span class="w"> </span>    out of luck I guess :) ~dave.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name, value in instance.get_filters():</span>
<span class="gi">+        if name.string_name == &#39;__getattr__&#39;:</span>
<span class="gi">+            return_stmt = value.tree_node.get_return_stmt()</span>
<span class="gi">+            if return_stmt:</span>
<span class="gi">+                call = return_stmt.children[1]</span>
<span class="gi">+                if isinstance(call, tree.Call):</span>
<span class="gi">+                    foo = call.children[0]</span>
<span class="gi">+                    if foo.type == &#39;name&#39; and foo.value == &#39;getattr&#39;:</span>
<span class="gi">+                        # Alright this is the call, we&#39;re almost there.</span>
<span class="gi">+                        args = call.children[1]</span>
<span class="gi">+                        if len(args.children) == 2:</span>
<span class="gi">+                            # The object that is executed.</span>
<span class="gi">+                            obj = args.children[0]</span>
<span class="gi">+                            values = user_context.infer_node(obj)</span>
<span class="gi">+                            return values</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/jedi/api/environment.py b/jedi/api/environment.py</span>
<span class="gh">index ec0c00aa..d12ad1a8 100644</span>
<span class="gd">--- a/jedi/api/environment.py</span>
<span class="gi">+++ b/jedi/api/environment.py</span>
<span class="gu">@@ -54,7 +54,7 @@ class Environment(_BaseEnvironment):</span>

<span class="w"> </span>        :returns: list of str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._subprocess.get_sys_path()</span>


<span class="w"> </span>class _SameEnvironmentMixin:
<span class="gu">@@ -80,7 +80,10 @@ def _get_virtual_env_from_var(env_var=&#39;VIRTUAL_ENV&#39;):</span>
<span class="w"> </span>    It uses `safe=False` with ``create_environment``, because the environment
<span class="w"> </span>    variable is considered to be safe / controlled by the user solely.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    virtual_env = os.environ.get(env_var)</span>
<span class="gi">+    if virtual_env:</span>
<span class="gi">+        return create_environment(virtual_env, safe=False)</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_default_environment():
<span class="gu">@@ -93,7 +96,15 @@ def get_default_environment():</span>

<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    virtual_env = _get_virtual_env_from_var()</span>
<span class="gi">+    if virtual_env:</span>
<span class="gi">+        return virtual_env</span>
<span class="gi">+</span>
<span class="gi">+    conda_env = _get_virtual_env_from_var(_CONDA_VAR)</span>
<span class="gi">+    if conda_env:</span>
<span class="gi">+        return conda_env</span>
<span class="gi">+</span>
<span class="gi">+    return next(find_system_environments(), None) or SameEnvironment()</span>


<span class="w"> </span>def find_virtualenvs(paths=None, *, safe=True, use_environment_vars=True):
<span class="gu">@@ -113,7 +124,22 @@ def find_virtualenvs(paths=None, *, safe=True, use_environment_vars=True):</span>

<span class="w"> </span>    :yields: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if use_environment_vars:</span>
<span class="gi">+        for env_var in [&#39;VIRTUAL_ENV&#39;, _CONDA_VAR]:</span>
<span class="gi">+            env = _get_virtual_env_from_var(env_var)</span>
<span class="gi">+            if env:</span>
<span class="gi">+                yield env</span>
<span class="gi">+</span>
<span class="gi">+    if paths is None:</span>
<span class="gi">+        paths = []</span>
<span class="gi">+</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        executable_path = _get_executable_path(path, safe=safe)</span>
<span class="gi">+        if executable_path:</span>
<span class="gi">+            try:</span>
<span class="gi">+                yield create_environment(executable_path, safe=safe)</span>
<span class="gi">+            except InvalidPythonEnvironment:</span>
<span class="gi">+                pass</span>


<span class="w"> </span>def find_system_environments(*, env_vars=None):
<span class="gu">@@ -126,7 +152,11 @@ def find_system_environments(*, env_vars=None):</span>

<span class="w"> </span>    :yields: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for version in _SUPPORTED_PYTHONS:</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield get_system_environment(version, env_vars=env_vars)</span>
<span class="gi">+        except InvalidPythonEnvironment:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>def get_system_environment(version, *, env_vars=None):
<span class="gu">@@ -137,7 +167,10 @@ def get_system_environment(version, *, env_vars=None):</span>
<span class="w"> </span>    :raises: :exc:`.InvalidPythonEnvironment`
<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exe = which(f&#39;python{version}&#39;) or which(&#39;python3&#39;) or which(&#39;python&#39;)</span>
<span class="gi">+    if exe is None:</span>
<span class="gi">+        raise InvalidPythonEnvironment(f&quot;Could not find Python {version}&quot;)</span>
<span class="gi">+    return create_environment(exe, env_vars=env_vars)</span>


<span class="w"> </span>def create_environment(path, *, safe=True, env_vars=None):
<span class="gu">@@ -148,11 +181,30 @@ def create_environment(path, *, safe=True, env_vars=None):</span>
<span class="w"> </span>    :raises: :exc:`.InvalidPythonEnvironment`
<span class="w"> </span>    :returns: :class:`.Environment`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    executable = _get_executable_path(path, safe=safe)</span>
<span class="gi">+    if executable is None:</span>
<span class="gi">+        raise InvalidPythonEnvironment(f&quot;Could not find a Python executable in {path}&quot;)</span>
<span class="gi">+    return Environment(executable, env_vars=env_vars)</span>


<span class="w"> </span>def _get_executable_path(path, safe=True):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns None if it&#39;s not actually a virtual env.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.isfile(path):</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    exe = os.path.join(path, &#39;bin&#39;, &#39;python&#39;)</span>
<span class="gi">+    if os.path.isfile(exe):</span>
<span class="gi">+        return exe</span>
<span class="gi">+</span>
<span class="gi">+    if safe:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # Try to guess the executable in an unsafe manner.</span>
<span class="gi">+    for name in [&#39;python&#39;, &#39;python3&#39;]:</span>
<span class="gi">+        exe = which(name, path=os.path.join(path, &#39;bin&#39;))</span>
<span class="gi">+        if exe:</span>
<span class="gi">+            return exe</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/jedi/api/errors.py b/jedi/api/errors.py</span>
<span class="gh">index 6f0d001a..ecae14d1 100644</span>
<span class="gd">--- a/jedi/api/errors.py</span>
<span class="gi">+++ b/jedi/api/errors.py</span>
<span class="gu">@@ -15,22 +15,22 @@ class SyntaxError:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def line(self):
<span class="w"> </span>        &quot;&quot;&quot;The line where the error starts (starting with 1).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.start_pos[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def column(self):
<span class="w"> </span>        &quot;&quot;&quot;The column where the error starts (starting with 0).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.start_pos[1]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def until_line(self):
<span class="w"> </span>        &quot;&quot;&quot;The line where the error ends (starting with 1).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.end_pos[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def until_column(self):
<span class="w"> </span>        &quot;&quot;&quot;The column where the error ends (starting with 0).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parso_error.end_pos[1]</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s from=%s to=%s&gt;&#39; % (self.__class__.__name__, self.
<span class="gh">diff --git a/jedi/api/exceptions.py b/jedi/api/exceptions.py</span>
<span class="gh">index 9db12e71..cffc1fb7 100644</span>
<span class="gd">--- a/jedi/api/exceptions.py</span>
<span class="gi">+++ b/jedi/api/exceptions.py</span>
<span class="gu">@@ -1,5 +1,5 @@</span>
<span class="w"> </span>class _JediError(Exception):
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Base class for all Jedi-specific exceptions.&quot;&quot;&quot;</span>


<span class="w"> </span>class InternalError(_JediError):
<span class="gu">@@ -9,6 +9,8 @@ class InternalError(_JediError):</span>
<span class="w"> </span>    thing and it is safe to use Jedi again. However using the same calls might
<span class="w"> </span>    result in the same error again.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def __init__(self, message):</span>
<span class="gi">+        super().__init__(f&quot;Internal Error: {message}&quot;)</span>


<span class="w"> </span>class WrongVersion(_JediError):
<span class="gu">@@ -16,6 +18,8 @@ class WrongVersion(_JediError):</span>
<span class="w"> </span>    This error is reserved for the future, shouldn&#39;t really be happening at the
<span class="w"> </span>    moment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def __init__(self, message):</span>
<span class="gi">+        super().__init__(f&quot;Wrong Version: {message}&quot;)</span>


<span class="w"> </span>class RefactoringError(_JediError):
<span class="gu">@@ -29,3 +33,5 @@ class RefactoringError(_JediError):</span>
<span class="w"> </span>    A typical ``RefactoringError`` would tell the user that inlining is not
<span class="w"> </span>    possible if no name is under the cursor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def __init__(self, message):</span>
<span class="gi">+        super().__init__(f&quot;Refactoring Error: {message}&quot;)</span>
<span class="gh">diff --git a/jedi/api/helpers.py b/jedi/api/helpers.py</span>
<span class="gh">index 18bd99de..4061b48d 100644</span>
<span class="gd">--- a/jedi/api/helpers.py</span>
<span class="gi">+++ b/jedi/api/helpers.py</span>
<span class="gu">@@ -26,7 +26,14 @@ def get_stack_at_position(grammar, code_lines, leaf, pos):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the possible node names (e.g. import_from, xor_test or yield_stmt).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = Parser(grammar, &#39;&#39;.join(code_lines)).parse()</span>
<span class="gi">+    stack = []</span>
<span class="gi">+    node = leaf</span>
<span class="gi">+    while node is not None:</span>
<span class="gi">+        if node.type != &#39;newline&#39;:</span>
<span class="gi">+            stack.insert(0, node)</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return [n.type for n in stack]</span>


<span class="w"> </span>class CallDetails:
<span class="gu">@@ -41,14 +48,30 @@ def _get_index_and_key(nodes, position):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the amount of commas and the keyword argument string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    key = None</span>
<span class="gi">+    for node in nodes:</span>
<span class="gi">+        if node.start_pos &gt;= position:</span>
<span class="gi">+            if node.type == &#39;argument&#39; and node.children[0].type == &#39;name&#39;:</span>
<span class="gi">+                key = node.children[0].value</span>
<span class="gi">+            break</span>
<span class="gi">+        if node.type == &#39;operator&#39; and node.value == &#39;,&#39;:</span>
<span class="gi">+            index += 1</span>
<span class="gi">+    return index, key</span>


<span class="w"> </span>@signature_time_cache(&#39;call_signatures_validity&#39;)
<span class="w"> </span>def cache_signatures(inference_state, context, bracket_leaf, code_lines,
<span class="w"> </span>    user_pos):
<span class="w"> </span>    &quot;&quot;&quot;This function calculates the cache key.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    line = code_lines[user_pos[0] - 1][:user_pos[1]]</span>
<span class="gi">+    before_cursor = line.strip()</span>
<span class="gi">+    return (</span>
<span class="gi">+        inference_state.grammar.version,</span>
<span class="gi">+        context.get_root_context().get_node(),</span>
<span class="gi">+        bracket_leaf.get_start_pos_of_prefix(),</span>
<span class="gi">+        before_cursor</span>
<span class="gi">+    )</span>


<span class="w"> </span>def get_module_names(module, all_scopes, definitions=True, references=False):
<span class="gu">@@ -56,4 +79,19 @@ def get_module_names(module, all_scopes, definitions=True, references=False):</span>
<span class="w"> </span>    Returns a dictionary with name parts as keys and their call paths as
<span class="w"> </span>    values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    names = {}</span>
<span class="gi">+    def add_names(scope):</span>
<span class="gi">+        for name in scope.get_defined_names():</span>
<span class="gi">+            if definitions:</span>
<span class="gi">+                names[name.string_name] = name.get_definition_path()</span>
<span class="gi">+            if references:</span>
<span class="gi">+                for ref in name.get_references():</span>
<span class="gi">+                    names[ref.string_name] = ref.get_definition_path()</span>
<span class="gi">+        </span>
<span class="gi">+        if all_scopes:</span>
<span class="gi">+            for sub_scope in scope.children:</span>
<span class="gi">+                if sub_scope.type in (&#39;class&#39;, &#39;function&#39;):</span>
<span class="gi">+                    add_names(sub_scope)</span>
<span class="gi">+</span>
<span class="gi">+    add_names(module)</span>
<span class="gi">+    return names</span>
<span class="gh">diff --git a/jedi/api/interpreter.py b/jedi/api/interpreter.py</span>
<span class="gh">index 7271aaec..e8604a56 100644</span>
<span class="gd">--- a/jedi/api/interpreter.py</span>
<span class="gi">+++ b/jedi/api/interpreter.py</span>
<span class="gu">@@ -24,7 +24,13 @@ class MixedTreeName(TreeNameDefinition):</span>
<span class="w"> </span>        provided was already executed. In that case if something is not properly
<span class="w"> </span>        inferred, it should still infer from the variables it already knows.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = super().infer()</span>
<span class="gi">+        if not inferred:</span>
<span class="gi">+            # If nothing is inferred, try to get the value from the namespace</span>
<span class="gi">+            value = self.parent_context.get_value(self.string_name)</span>
<span class="gi">+            if value is not None:</span>
<span class="gi">+                return ValueSet([value])</span>
<span class="gi">+        return inferred</span>


<span class="w"> </span>class MixedParserTreeFilter(ParserTreeFilter):
<span class="gu">@@ -37,3 +43,23 @@ class MixedModuleContext(ModuleContext):</span>
<span class="w"> </span>        super().__init__(tree_module_value)
<span class="w"> </span>        self.mixed_values = [self._get_mixed_object(_create(self.
<span class="w"> </span>            inference_state, NamespaceObject(n))) for n in namespaces]
<span class="gi">+</span>
<span class="gi">+    def _get_mixed_object(self, compiled_value):</span>
<span class="gi">+        return mixed.MixedObject(</span>
<span class="gi">+            compiled_value=compiled_value,</span>
<span class="gi">+            tree_value=self.tree_value</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, until_position=None, origin_scope=None):</span>
<span class="gi">+        filters = super().get_filters(until_position, origin_scope)</span>
<span class="gi">+        for mixed_value in self.mixed_values:</span>
<span class="gi">+            filters.append(mixed.MixedObjectFilter(self.inference_state, mixed_value))</span>
<span class="gi">+        return filters</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self, name):</span>
<span class="gi">+        value = super().get_value(name)</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            for mixed_value in self.mixed_values:</span>
<span class="gi">+                if name in mixed_value.compiled_value.dict:</span>
<span class="gi">+                    return mixed_value.get_compiled_value(name)</span>
<span class="gi">+        return value</span>
<span class="gh">diff --git a/jedi/api/keywords.py b/jedi/api/keywords.py</span>
<span class="gh">index 6a6e99e2..5feae421 100644</span>
<span class="gd">--- a/jedi/api/keywords.py</span>
<span class="gi">+++ b/jedi/api/keywords.py</span>
<span class="gu">@@ -18,4 +18,14 @@ def imitate_pydoc(string):</span>
<span class="w"> </span>    It&#39;s not possible to get the pydoc&#39;s without starting the annoying pager
<span class="w"> </span>    stuff.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pydoc_topics is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    with suppress(KeyError):</span>
<span class="gi">+        return pydoc.plain(pydoc_topics.get(string, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        text = pydoc.render_doc(string, title=&#39;Python Library Documentation: %s&#39;, renderer=pydoc.plaintext)</span>
<span class="gi">+        return &#39; &#39;.join(text.split())</span>
<span class="gi">+    except (ImportError, pydoc.ErrorDuringImport):</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/jedi/api/project.py b/jedi/api/project.py</span>
<span class="gh">index d5ae11bb..33edecf1 100644</span>
<span class="gd">--- a/jedi/api/project.py</span>
<span class="gi">+++ b/jedi/api/project.py</span>
<span class="gu">@@ -42,13 +42,44 @@ class Project:</span>

<span class="w"> </span>        :param path: The path of the directory you want to use as a project.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        project_path = Path(path)</span>
<span class="gi">+        config_path = project_path / _CONFIG_FOLDER / &#39;project.json&#39;</span>
<span class="gi">+        if not config_path.exists():</span>
<span class="gi">+            return cls(path)</span>
<span class="gi">+        </span>
<span class="gi">+        with open(config_path, &#39;r&#39;) as f:</span>
<span class="gi">+            data = json.load(f)</span>
<span class="gi">+        </span>
<span class="gi">+        if data.get(&#39;version&#39;, 0) != _SERIALIZER_VERSION:</span>
<span class="gi">+            raise WrongVersion(&#39;The Jedi version of this project is not correct.&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        return cls(</span>
<span class="gi">+            path,</span>
<span class="gi">+            environment_path=data.get(&#39;environment_path&#39;),</span>
<span class="gi">+            load_unsafe_extensions=data.get(&#39;load_unsafe_extensions&#39;, False),</span>
<span class="gi">+            sys_path=data.get(&#39;sys_path&#39;),</span>
<span class="gi">+            added_sys_path=data.get(&#39;added_sys_path&#39;, []),</span>
<span class="gi">+            smart_sys_path=data.get(&#39;smart_sys_path&#39;, True)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def save(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Saves the project configuration in the project in ``.jedi/project.json``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = {</span>
<span class="gi">+            &#39;version&#39;: _SERIALIZER_VERSION,</span>
<span class="gi">+            &#39;environment_path&#39;: self._environment_path,</span>
<span class="gi">+            &#39;load_unsafe_extensions&#39;: self._load_unsafe_extensions,</span>
<span class="gi">+            &#39;sys_path&#39;: self._sys_path,</span>
<span class="gi">+            &#39;added_sys_path&#39;: self.added_sys_path,</span>
<span class="gi">+            &#39;smart_sys_path&#39;: self._smart_sys_path</span>
<span class="gi">+        }</span>
<span class="gi">+        </span>
<span class="gi">+        config_path = self._path / _CONFIG_FOLDER</span>
<span class="gi">+        config_path.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        </span>
<span class="gi">+        with open(config_path / &#39;project.json&#39;, &#39;w&#39;) as f:</span>
<span class="gi">+            json.dump(config, f, indent=4)</span>

<span class="w"> </span>    def __init__(self, path, *, environment_path=None,
<span class="w"> </span>        load_unsafe_extensions=False, sys_path=None, added_sys_path=(),
<span class="gu">@@ -89,7 +120,7 @@ class Project:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The base path for this project.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def sys_path(self):
<span class="gu">@@ -97,7 +128,7 @@ class Project:</span>
<span class="w"> </span>        The sys path provided to this project. This can be None and in that
<span class="w"> </span>        case will be auto generated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._sys_path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def smart_sys_path(self):
<span class="gu">@@ -105,14 +136,14 @@ class Project:</span>
<span class="w"> </span>        If the sys path is going to be calculated in a smart way, where
<span class="w"> </span>        additional paths are added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._smart_sys_path</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def load_unsafe_extensions(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Wheter the project loads unsafe extensions.</span>
<span class="gi">+        Whether the project loads unsafe extensions.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._load_unsafe_extensions</span>

<span class="w"> </span>    @inference_state_as_method_param_cache()
<span class="w"> </span>    def _get_sys_path(self, inference_state, add_parent_paths=True,
<span class="gu">@@ -121,7 +152,44 @@ class Project:</span>
<span class="w"> </span>        Keep this method private for all users of jedi. However internally this
<span class="w"> </span>        one is used like a public method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sys_path is None:</span>
<span class="gi">+            # Use the default environment&#39;s sys path if not specified.</span>
<span class="gi">+            sys_path = inference_state.get_sys_path()</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys_path = list(self._sys_path)</span>
<span class="gi">+</span>
<span class="gi">+        if self._smart_sys_path:</span>
<span class="gi">+            # Add the project path and parent paths if requested</span>
<span class="gi">+            if add_parent_paths:</span>
<span class="gi">+                sys_path.append(str(self._path))</span>
<span class="gi">+                for parent in self._path.parents:</span>
<span class="gi">+                    sys_path.append(str(parent))</span>
<span class="gi">+            </span>
<span class="gi">+            # Add paths for potential virtual environments</span>
<span class="gi">+            venv_paths = self._get_venv_paths(inference_state)</span>
<span class="gi">+            sys_path.extend(venv_paths)</span>
<span class="gi">+</span>
<span class="gi">+        # Add any specified additional sys paths</span>
<span class="gi">+        sys_path.extend(self.added_sys_path)</span>
<span class="gi">+</span>
<span class="gi">+        if add_init_paths:</span>
<span class="gi">+            # Add __init__.py paths if requested</span>
<span class="gi">+            sys_path.extend(self._get_init_paths(inference_state))</span>
<span class="gi">+</span>
<span class="gi">+        return sys_path</span>
<span class="gi">+</span>
<span class="gi">+    def _get_venv_paths(self, inference_state):</span>
<span class="gi">+        venv_paths = []</span>
<span class="gi">+        if self._environment_path:</span>
<span class="gi">+            venv = create_environment(self._environment_path)</span>
<span class="gi">+            venv_paths.extend(venv.get_sys_path())</span>
<span class="gi">+        return venv_paths</span>
<span class="gi">+</span>
<span class="gi">+    def _get_init_paths(self, inference_state):</span>
<span class="gi">+        init_paths = []</span>
<span class="gi">+        for p in self._path.rglob(&#39;__init__.py&#39;):</span>
<span class="gi">+            init_paths.append(str(p.parent))</span>
<span class="gi">+        return init_paths</span>

<span class="w"> </span>    def search(self, string, *, all_scopes=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,7 +212,27 @@ class Project:</span>
<span class="w"> </span>            functions and classes.
<span class="w"> </span>        :yields: :class:`.Name`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from jedi.api.environment import get_cached_default_environment</span>
<span class="gi">+        environment = get_cached_default_environment()</span>
<span class="gi">+        inference_state = environment.create_inference_state()</span>
<span class="gi">+        </span>
<span class="gi">+        # Split the search string into parts</span>
<span class="gi">+        parts = string.split(&#39;.&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        # Search for matching files</span>
<span class="gi">+        for file_io in recurse_find_python_folders_and_files(self._path):</span>
<span class="gi">+            module = load_module_from_path(inference_state, file_io)</span>
<span class="gi">+            </span>
<span class="gi">+            # Search within the module</span>
<span class="gi">+            for name in search_in_module(inference_state, module, parts, all_scopes):</span>
<span class="gi">+                yield name</span>
<span class="gi">+</span>
<span class="gi">+        # Search for matching module names</span>
<span class="gi">+        for module_name in get_module_names(inference_state, self._path):</span>
<span class="gi">+            if module_name.string_name.startswith(parts[0]):</span>
<span class="gi">+                module = load_namespace_from_path(inference_state, self._path / module_name.string_name)</span>
<span class="gi">+                for name in search_in_module(inference_state, module, parts[1:], all_scopes):</span>
<span class="gi">+                    yield name</span>

<span class="w"> </span>    def complete_search(self, string, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -156,7 +244,43 @@ class Project:</span>
<span class="w"> </span>            functions and classes.
<span class="w"> </span>        :yields: :class:`.Completion`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from jedi.api.completion import Completion</span>
<span class="gi">+        from jedi.api.environment import get_cached_default_environment</span>
<span class="gi">+        </span>
<span class="gi">+        environment = get_cached_default_environment()</span>
<span class="gi">+        inference_state = environment.create_inference_state()</span>
<span class="gi">+        </span>
<span class="gi">+        # Split the search string into parts</span>
<span class="gi">+        parts = string.split(&#39;.&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        # Search for matching files and modules</span>
<span class="gi">+        for name in self.search(string, **kwargs):</span>
<span class="gi">+            yield Completion(</span>
<span class="gi">+                inference_state,</span>
<span class="gi">+                name.name,</span>
<span class="gi">+                name.stack,</span>
<span class="gi">+                name.name.start_pos,</span>
<span class="gi">+                name.name.get_line_code(),</span>
<span class="gi">+                name.name.get_line(),</span>
<span class="gi">+                name.name.column,</span>
<span class="gi">+                is_fuzzy=False</span>
<span class="gi">+            )</span>
<span class="gi">+        </span>
<span class="gi">+        # If the string is empty or ends with a dot, suggest all possible completions</span>
<span class="gi">+        if not string or string.endswith(&#39;.&#39;):</span>
<span class="gi">+            for file_io in recurse_find_python_folders_and_files(self._path):</span>
<span class="gi">+                module = load_module_from_path(inference_state, file_io)</span>
<span class="gi">+                for name in get_module_names(inference_state, module.path):</span>
<span class="gi">+                    yield Completion(</span>
<span class="gi">+                        inference_state,</span>
<span class="gi">+                        name.string_name,</span>
<span class="gi">+                        name.parent_context.tree_node,</span>
<span class="gi">+                        name.start_pos,</span>
<span class="gi">+                        name.get_line_code(),</span>
<span class="gi">+                        name.get_line(),</span>
<span class="gi">+                        name.column,</span>
<span class="gi">+                        is_fuzzy=False</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._path)
<span class="gu">@@ -164,7 +288,10 @@ class Project:</span>

<span class="w"> </span>def _is_django_path(directory):
<span class="w"> </span>    &quot;&quot;&quot; Detects the path of the very well known Django library (if used) &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = directory.parent</span>
<span class="gi">+    if parent.name == &#39;django&#39;:</span>
<span class="gi">+        return parent</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_default_project(path=None):
<span class="gu">@@ -177,4 +304,21 @@ def get_default_project(path=None):</span>
<span class="w"> </span>    2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
<span class="w"> </span>       ``requirements.txt`` and ``MANIFEST.in``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        path = Path.cwd()</span>
<span class="gi">+    elif isinstance(path, str):</span>
<span class="gi">+        path = Path(path)</span>
<span class="gi">+</span>
<span class="gi">+    check_path = path</span>
<span class="gi">+    while check_path.parent != check_path:</span>
<span class="gi">+        if (check_path / _CONFIG_FOLDER / &#39;config.json&#39;).exists():</span>
<span class="gi">+            return Project(check_path)</span>
<span class="gi">+        </span>
<span class="gi">+        for indicator in _CONTAINS_POTENTIAL_PROJECT:</span>
<span class="gi">+            if (check_path / indicator).exists():</span>
<span class="gi">+                return Project(check_path)</span>
<span class="gi">+        </span>
<span class="gi">+        check_path = check_path.parent</span>
<span class="gi">+</span>
<span class="gi">+    # If no project is found, use the original path</span>
<span class="gi">+    return Project(path)</span>
<span class="gh">diff --git a/jedi/api/refactoring/extract.py b/jedi/api/refactoring/extract.py</span>
<span class="gh">index 1cdeefac..a02e373f 100644</span>
<span class="gd">--- a/jedi/api/refactoring/extract.py</span>
<span class="gi">+++ b/jedi/api/refactoring/extract.py</span>
<span class="gu">@@ -15,7 +15,14 @@ def _is_expression_with_error(nodes):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a tuple (is_expression, error_string).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(nodes) != 1:</span>
<span class="gi">+        return False, &quot;Can only extract expressions&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    node = nodes[0]</span>
<span class="gi">+    if node.type not in _VARIABLE_EXCTRACTABLE:</span>
<span class="gi">+        return False, f&quot;Cannot extract {node.type}&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    return True, None</span>


<span class="w"> </span>def _find_nodes(module_node, pos, until_pos):
<span class="gu">@@ -23,7 +30,19 @@ def _find_nodes(module_node, pos, until_pos):</span>
<span class="w"> </span>    Looks up a module and tries to find the appropriate amount of nodes that
<span class="w"> </span>    are in there.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    leaf = module_node.get_leaf_for_position(pos)</span>
<span class="gi">+    if leaf.start_pos &gt;= until_pos:</span>
<span class="gi">+        return []</span>
<span class="gi">+    </span>
<span class="gi">+    nodes = [leaf]</span>
<span class="gi">+    while leaf.end_pos &lt; until_pos:</span>
<span class="gi">+        try:</span>
<span class="gi">+            leaf = leaf.get_next_leaf()</span>
<span class="gi">+            nodes.append(leaf)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            break</span>
<span class="gi">+    </span>
<span class="gi">+    return nodes</span>


<span class="w"> </span>def _split_prefix_at(leaf, until_line):
<span class="gu">@@ -31,14 +50,22 @@ def _split_prefix_at(leaf, until_line):</span>
<span class="w"> </span>    Returns a tuple of the leaf&#39;s prefix, split at the until_line
<span class="w"> </span>    position.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = split_lines(leaf.prefix)</span>
<span class="gi">+    return (</span>
<span class="gi">+        &#39;&#39;.join(lines[:until_line]),</span>
<span class="gi">+        &#39;&#39;.join(lines[until_line:])</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _get_parent_definition(node):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the statement where a node is defined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while node is not None:</span>
<span class="gi">+        if node.type in _DEFINITION_SCOPES:</span>
<span class="gi">+            return node</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def _remove_unwanted_expression_nodes(parent_node, pos, until_pos):
<span class="gu">@@ -46,7 +73,20 @@ def _remove_unwanted_expression_nodes(parent_node, pos, until_pos):</span>
<span class="w"> </span>    This function makes it so for `1 * 2 + 3` you can extract `2 + 3`, even
<span class="w"> </span>    though it is not part of the expression.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def remove_unwanted(node):</span>
<span class="gi">+        if node.start_pos &lt; pos:</span>
<span class="gi">+            if node.end_pos &lt;= pos:</span>
<span class="gi">+                return None</span>
<span class="gi">+            if node.type in (&#39;atom_expr&#39;, &#39;power&#39;):</span>
<span class="gi">+                return remove_unwanted(node.children[-1])</span>
<span class="gi">+        if node.end_pos &gt; until_pos:</span>
<span class="gi">+            if node.start_pos &gt;= until_pos:</span>
<span class="gi">+                return None</span>
<span class="gi">+            if node.type in (&#39;atom_expr&#39;, &#39;power&#39;):</span>
<span class="gi">+                return remove_unwanted(node.children[0])</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    return remove_unwanted(parent_node)</span>


<span class="w"> </span>def _find_needed_output_variables(context, search_node, at_least_pos,
<span class="gu">@@ -55,4 +95,19 @@ def _find_needed_output_variables(context, search_node, at_least_pos,</span>
<span class="w"> </span>    Searches everything after at_least_pos in a node and checks if any of the
<span class="w"> </span>    return_variables are used in there and returns those.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    needed_variables = set()</span>
<span class="gi">+    </span>
<span class="gi">+    def check_names(node):</span>
<span class="gi">+        if node.start_pos &lt; at_least_pos:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        if node.type == &#39;name&#39;:</span>
<span class="gi">+            for return_variable in return_variables:</span>
<span class="gi">+                if node.value == return_variable.name.value:</span>
<span class="gi">+                    needed_variables.add(return_variable)</span>
<span class="gi">+        </span>
<span class="gi">+        for child in node.children:</span>
<span class="gi">+            check_names(child)</span>
<span class="gi">+    </span>
<span class="gi">+    check_names(search_node)</span>
<span class="gi">+    return list(needed_variables)</span>
<span class="gh">diff --git a/jedi/cache.py b/jedi/cache.py</span>
<span class="gh">index 1dc6e8ac..e877af6a 100644</span>
<span class="gd">--- a/jedi/cache.py</span>
<span class="gi">+++ b/jedi/cache.py</span>
<span class="gu">@@ -26,7 +26,10 @@ def clear_time_caches(delete_all: bool=False) -&gt;None:</span>
<span class="w"> </span>    :param delete_all: Deletes also the cache that is normally not deleted,
<span class="w"> </span>        like parser cache, which is important for faster parsing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _time_caches</span>
<span class="gi">+    _time_caches.clear()</span>
<span class="gi">+    if delete_all:</span>
<span class="gi">+        parser_cache.clear()</span>


<span class="w"> </span>def signature_time_cache(time_add_setting):
<span class="gu">@@ -38,9 +41,39 @@ def signature_time_cache(time_add_setting):</span>

<span class="w"> </span>    If the given key is None, the function will not be cached.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            key = args[0]() if callable(args[0]) else args[0]</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                return func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            cache = _time_caches.setdefault(func.__name__, {})</span>
<span class="gi">+            current_time = time.time()</span>
<span class="gi">+</span>
<span class="gi">+            if key in cache:</span>
<span class="gi">+                expiry, value = cache[key]</span>
<span class="gi">+                if current_time &lt; expiry:</span>
<span class="gi">+                    return value</span>
<span class="gi">+</span>
<span class="gi">+            value = func(*args, **kwargs)</span>
<span class="gi">+            expiry = current_time + getattr(settings, time_add_setting)</span>
<span class="gi">+            cache[key] = (expiry, value)</span>
<span class="gi">+            return value</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def memoize_method(method):
<span class="w"> </span>    &quot;&quot;&quot;A normal memoize function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache_name = &#39;_cache_&#39; + method.__name__</span>
<span class="gi">+    @wraps(method)</span>
<span class="gi">+    def wrapper(self, *args, **kwargs):</span>
<span class="gi">+        if not hasattr(self, cache_name):</span>
<span class="gi">+            setattr(self, cache_name, {})</span>
<span class="gi">+        cache = getattr(self, cache_name)</span>
<span class="gi">+        key = (args, frozenset(kwargs.items()))</span>
<span class="gi">+        if key not in cache:</span>
<span class="gi">+            cache[key] = method(self, *args, **kwargs)</span>
<span class="gi">+        return cache[key]</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/common.py b/jedi/common.py</span>
<span class="gh">index 6254a2da..80c291ac 100644</span>
<span class="gd">--- a/jedi/common.py</span>
<span class="gi">+++ b/jedi/common.py</span>
<span class="gu">@@ -6,9 +6,14 @@ def monkeypatch(obj, attribute_name, new_value):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Like pytest&#39;s monkeypatch, but as a value manager.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_value = getattr(obj, attribute_name)</span>
<span class="gi">+    setattr(obj, attribute_name, new_value)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        setattr(obj, attribute_name, original_value)</span>


<span class="w"> </span>def indent_block(text, indention=&#39;    &#39;):
<span class="w"> </span>    &quot;&quot;&quot;This function indents a text block with a default of four spaces.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;\n&#39;.join(indention + line for line in text.splitlines())</span>
<span class="gh">diff --git a/jedi/debug.py b/jedi/debug.py</span>
<span class="gh">index a97c4eef..05cf271d 100644</span>
<span class="gd">--- a/jedi/debug.py</span>
<span class="gi">+++ b/jedi/debug.py</span>
<span class="gu">@@ -52,13 +52,32 @@ _start_time = time.time()</span>


<span class="w"> </span>def increase_indent(func):
<span class="gd">-    &quot;&quot;&quot;Decorator for makin &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Decorator for making indented debug messages.&quot;&quot;&quot;</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        global _debug_indent</span>
<span class="gi">+        _debug_indent += 1</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            _debug_indent -= 1</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def dbg(message, *args, color=&#39;GREEN&#39;):
<span class="w"> </span>    &quot;&quot;&quot; Looks at the stack, to see if a debug message should be printed. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _debug_indent, debug_function</span>
<span class="gi">+    _lazy_colorama_init()</span>
<span class="gi">+    </span>
<span class="gi">+    if debug_function is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    </span>
<span class="gi">+    if args:</span>
<span class="gi">+        message = message % args</span>
<span class="gi">+    </span>
<span class="gi">+    indent = &#39; &#39; * _debug_indent</span>
<span class="gi">+    time_str = &#39; %.3f&#39; % (time.time() - _start_time)</span>
<span class="gi">+    message = indent + time_str + &#39; &#39; + message</span>
<span class="gi">+    debug_function(color, message)</span>


<span class="w"> </span>def print_to_stdout(color, str_out):
<span class="gu">@@ -67,4 +86,6 @@ def print_to_stdout(color, str_out):</span>

<span class="w"> </span>    :param str color: A string that is an attribute of ``colorama.Fore``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _lazy_colorama_init()</span>
<span class="gi">+    col = getattr(Fore, color)</span>
<span class="gi">+    print(col + str_out + Fore.RESET)</span>
<span class="gh">diff --git a/jedi/file_io.py b/jedi/file_io.py</span>
<span class="gh">index 7258df1e..c7c46dc6 100644</span>
<span class="gd">--- a/jedi/file_io.py</span>
<span class="gi">+++ b/jedi/file_io.py</span>
<span class="gu">@@ -12,11 +12,20 @@ class AbstractFolderIO:</span>


<span class="w"> </span>class FolderIO(AbstractFolderIO):
<span class="gd">-    pass</span>
<span class="gi">+    def list(self):</span>
<span class="gi">+        return os.listdir(self.path)</span>
<span class="gi">+</span>
<span class="gi">+    def get_file_io(self, name):</span>
<span class="gi">+        full_path = os.path.join(self.path, name)</span>
<span class="gi">+        if os.path.isfile(full_path):</span>
<span class="gi">+            return FileIO(full_path)</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class FileIOFolderMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def get_parent_folder(self):</span>
<span class="gi">+        parent_path = os.path.dirname(self.path)</span>
<span class="gi">+        return FolderIO(parent_path)</span>


<span class="w"> </span>class ZipFileIO(file_io.KnownContentFileIO, FileIOFolderMixin):
<span class="gh">diff --git a/jedi/inference/analysis.py b/jedi/inference/analysis.py</span>
<span class="gh">index a45cec67..6211de02 100644</span>
<span class="gd">--- a/jedi/inference/analysis.py</span>
<span class="gi">+++ b/jedi/inference/analysis.py</span>
<span class="gu">@@ -57,11 +57,13 @@ def _check_for_setattr(instance):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if there&#39;s any setattr method inside an instance. If so, return True.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name in instance.get_function_names():</span>
<span class="gi">+        if name.string_name == &#39;setattr&#39;:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _check_for_exception_catch(node_context, jedi_name, exception, payload=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def _check_for_exception_catch(node_context, jedi_name, exception, payload=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if a jedi object (e.g. `Statement`) sits inside a try/catch and
<span class="w"> </span>    doesn&#39;t count as an error (if equal to `exception`).
<span class="gu">@@ -69,4 +71,31 @@ def _check_for_exception_catch(node_context, jedi_name, exception, payload=None</span>
<span class="w"> </span>    it.
<span class="w"> </span>    Returns True if the exception was catched.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def check_match(node, exception_name):</span>
<span class="gi">+        return node.type == &#39;except_clause&#39; and (</span>
<span class="gi">+            node.children[1].type == &#39;name&#39; and</span>
<span class="gi">+            node.children[1].value == exception_name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def check_try_except(node):</span>
<span class="gi">+        if node.type == &#39;try_stmt&#39;:</span>
<span class="gi">+            for child in node.children:</span>
<span class="gi">+                if check_match(child, exception.__name__):</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    current = node_context.tree_node</span>
<span class="gi">+    while current is not None:</span>
<span class="gi">+        if check_try_except(current):</span>
<span class="gi">+            return True</span>
<span class="gi">+        </span>
<span class="gi">+        if exception == AttributeError and current.type == &#39;power&#39;:</span>
<span class="gi">+            if len(current.children) &gt;= 2 and current.children[0].value == &#39;hasattr&#39;:</span>
<span class="gi">+                if len(current.children[1].children) == 3:  # hasattr(obj, attr)</span>
<span class="gi">+                    attr = current.children[1].children[2].value</span>
<span class="gi">+                    if attr.strip(&quot;&#39;\&quot;&quot;) == payload:</span>
<span class="gi">+                        return True</span>
<span class="gi">+</span>
<span class="gi">+        current = current.parent</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/jedi/inference/arguments.py b/jedi/inference/arguments.py</span>
<span class="gh">index 95120843..0ef0f1e8 100644</span>
<span class="gd">--- a/jedi/inference/arguments.py</span>
<span class="gi">+++ b/jedi/inference/arguments.py</span>
<span class="gu">@@ -13,7 +13,19 @@ from jedi.inference.cache import inference_state_as_method_param_cache</span>

<span class="w"> </span>def try_iter_content(types, depth=0):
<span class="w"> </span>    &quot;&quot;&quot;Helper method for static analysis.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if depth &gt; 10:</span>
<span class="gi">+        # Avoid infinite recursion</span>
<span class="gi">+        return set()</span>
<span class="gi">+    </span>
<span class="gi">+    result = set()</span>
<span class="gi">+    for typ in types:</span>
<span class="gi">+        if isinstance(typ, iterable.Sequence):</span>
<span class="gi">+            result |= try_iter_content(typ.get_all_items(), depth + 1)</span>
<span class="gi">+        elif isinstance(typ, iterable.Iterable):</span>
<span class="gi">+            result |= try_iter_content(typ.py__iter__(), depth + 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.add(typ)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class ParamIssue(Exception):
<span class="gu">@@ -31,12 +43,55 @@ def repack_with_argument_clinic(clinic_string):</span>
<span class="w"> </span>        str.split.__text_signature__
<span class="w"> </span>        # Results in: &#39;($self, /, sep=None, maxsplit=-1)&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            # Parse the clinic string</span>
<span class="gi">+            params = re.findall(r&#39;\(([^)]+)\)&#39;, clinic_string)[0].split(&#39;,&#39;)</span>
<span class="gi">+            new_args = []</span>
<span class="gi">+            new_kwargs = {}</span>
<span class="gi">+            </span>
<span class="gi">+            for i, param in enumerate(params):</span>
<span class="gi">+                param = param.strip()</span>
<span class="gi">+                if param.startswith(&#39;$&#39;):</span>
<span class="gi">+                    continue  # Skip self parameter</span>
<span class="gi">+                if &#39;=&#39; in param:</span>
<span class="gi">+                    name, default = param.split(&#39;=&#39;)</span>
<span class="gi">+                    if i &lt; len(args):</span>
<span class="gi">+                        new_args.append(args[i])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        new_kwargs[name] = kwargs.get(name, eval(default))</span>
<span class="gi">+                elif param == &#39;/&#39;:</span>
<span class="gi">+                    new_args.extend(args[i:])</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if i &lt; len(args):</span>
<span class="gi">+                        new_args.append(args[i])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise TypeError(f&quot;Missing required argument: {param}&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            return func(*new_args, **new_kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def iterate_argument_clinic(inference_state, arguments, clinic_string):
<span class="w"> </span>    &quot;&quot;&quot;Uses a list with argument clinic information (see PEP 436).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    params = re.findall(r&#39;\(([^)]+)\)&#39;, clinic_string)[0].split(&#39;,&#39;)</span>
<span class="gi">+    param_names = [p.strip().split(&#39;=&#39;)[0] for p in params if not p.strip().startswith(&#39;$&#39;) and p.strip() != &#39;/&#39;]</span>
<span class="gi">+    </span>
<span class="gi">+    for param_name, argument in zip_longest(param_names, arguments.unpack()):</span>
<span class="gi">+        if param_name is None:</span>
<span class="gi">+            # More arguments than parameters</span>
<span class="gi">+            yield None, argument</span>
<span class="gi">+        elif argument is None:</span>
<span class="gi">+            # More parameters than arguments, yield default values</span>
<span class="gi">+            default = next((p.split(&#39;=&#39;)[1] for p in params if p.strip().startswith(param_name)), None)</span>
<span class="gi">+            if default is not None:</span>
<span class="gi">+                yield param_name, LazyKnownValue(inference_state.builtins_module.py__getattribute__(default))</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield param_name, NO_VALUES</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield param_name, argument</span>


<span class="w"> </span>class _AbstractArgumentsMixin:
<span class="gh">diff --git a/jedi/inference/base_value.py b/jedi/inference/base_value.py</span>
<span class="gh">index 3e35794a..c590d132 100644</span>
<span class="gd">--- a/jedi/inference/base_value.py</span>
<span class="gi">+++ b/jedi/inference/base_value.py</span>
<span class="gu">@@ -30,7 +30,7 @@ class HelperValueMixin:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param position: Position of the last statement -&gt; tuple of line, column
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;This method should be implemented by subclasses&quot;)</span>


<span class="w"> </span>class Value(HelperValueMixin):
<span class="gu">@@ -50,13 +50,13 @@ class Value(HelperValueMixin):</span>
<span class="w"> </span>        Since Wrapper is a super class for classes, functions and modules,
<span class="w"> </span>        the return value will always be true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def py__getattribute__alternatives(self, name_or_str):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For now a way to add values in cases like __getattr__.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def infer_type_vars(self, value_set):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -85,7 +85,7 @@ class Value(HelperValueMixin):</span>
<span class="w"> </span>            above example this would first be the representation of the list
<span class="w"> </span>            `[1]` and then, when recursing, just of `1`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {}</span>


<span class="w"> </span>def iterate_values(values, contextualized_node=None, is_async=False):
<span class="gu">@@ -93,7 +93,11 @@ def iterate_values(values, contextualized_node=None, is_async=False):</span>
<span class="w"> </span>    Calls `iterate`, on all values but ignores the ordering and just returns
<span class="w"> </span>    all values that the iterate functions yield.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = set()</span>
<span class="gi">+    for value in values:</span>
<span class="gi">+        if hasattr(value, &#39;iterate&#39;):</span>
<span class="gi">+            result.update(value.iterate(contextualized_node, is_async))</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class _ValueWrapperBase(HelperValueMixin):
<span class="gu">@@ -151,7 +155,7 @@ class ValueSet:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used to work with an iterable of set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(set().union(*sets))</span>

<span class="w"> </span>    def __or__(self, other):
<span class="w"> </span>        return self._from_frozen_set(self._set | other._set)
<span class="gh">diff --git a/jedi/inference/cache.py b/jedi/inference/cache.py</span>
<span class="gh">index e584319c..669eeac2 100644</span>
<span class="gd">--- a/jedi/inference/cache.py</span>
<span class="gi">+++ b/jedi/inference/cache.py</span>
<span class="gu">@@ -18,7 +18,37 @@ def _memoize_default(default=_NO_DEFAULT, inference_state_is_first_arg=</span>
<span class="w"> </span>    don&#39;t think, that there is a big speed difference, but there are many cases
<span class="w"> </span>    where recursion could happen (think about a = b; b = a).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def func(f):</span>
<span class="gi">+        cache = {}</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            inference_state = None</span>
<span class="gi">+            if inference_state_is_first_arg:</span>
<span class="gi">+                inference_state = args[0]</span>
<span class="gi">+            elif second_arg_is_inference_state:</span>
<span class="gi">+                inference_state = args[1] if len(args) &gt; 1 else kwargs.get(&#39;inference_state&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            key = (inference_state, args, frozenset(kwargs.items()))</span>
<span class="gi">+            if key in cache:</span>
<span class="gi">+                return cache[key]</span>
<span class="gi">+</span>
<span class="gi">+            if key in wrapper.recursion_guard:</span>
<span class="gi">+                debug.warning(&#39;Recursion detected in %s&#39;, f.__name__)</span>
<span class="gi">+                return default if default is not _NO_DEFAULT else _RECURSION_SENTINEL</span>
<span class="gi">+</span>
<span class="gi">+            wrapper.recursion_guard.add(key)</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = f(*args, **kwargs)</span>
<span class="gi">+                cache[key] = result</span>
<span class="gi">+                return result</span>
<span class="gi">+            finally:</span>
<span class="gi">+                wrapper.recursion_guard.remove(key)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.recursion_guard = set()</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return func</span>


<span class="w"> </span>class CachedMetaClass(type):
<span class="gu">@@ -38,4 +68,31 @@ def inference_state_method_generator_cache():</span>
<span class="w"> </span>    This is a special memoizer. It memoizes generators and also checks for
<span class="w"> </span>    recursion errors and returns no further iterator elemends in that case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        cache = {}</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(inference_state, *args, **kwargs):</span>
<span class="gi">+            key = (inference_state, args, frozenset(kwargs.items()))</span>
<span class="gi">+            if key in cache:</span>
<span class="gi">+                yield from cache[key]</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if key in wrapper.recursion_guard:</span>
<span class="gi">+                debug.warning(&#39;Recursion detected in generator %s&#39;, func.__name__)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            wrapper.recursion_guard.add(key)</span>
<span class="gi">+            try:</span>
<span class="gi">+                result = []</span>
<span class="gi">+                for item in func(inference_state, *args, **kwargs):</span>
<span class="gi">+                    result.append(item)</span>
<span class="gi">+                    yield item</span>
<span class="gi">+                cache[key] = result</span>
<span class="gi">+            finally:</span>
<span class="gi">+                wrapper.recursion_guard.remove(key)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.recursion_guard = set()</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/jedi/inference/compiled/access.py b/jedi/inference/compiled/access.py</span>
<span class="gh">index 2da304b3..7aed493b 100644</span>
<span class="gd">--- a/jedi/inference/compiled/access.py</span>
<span class="gi">+++ b/jedi/inference/compiled/access.py</span>
<span class="gu">@@ -55,16 +55,32 @@ class DirectObjectAccess:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns Tuple[Optional[str], Tuple[AccessPath, ...]]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self._obj, &#39;__annotations__&#39;):</span>
<span class="gi">+            annotation = self._obj.__annotations__.get(&#39;return&#39;, None)</span>
<span class="gi">+            if annotation is not None:</span>
<span class="gi">+                if isinstance(annotation, str):</span>
<span class="gi">+                    return annotation, ()</span>
<span class="gi">+                elif hasattr(annotation, &#39;__origin__&#39;):</span>
<span class="gi">+                    name = annotation.__origin__.__name__</span>
<span class="gi">+                    args = tuple(AccessPath([arg]) for arg in getattr(annotation, &#39;__args__&#39;, ()))</span>
<span class="gi">+                    return name, args</span>
<span class="gi">+        return None, ()</span>

<span class="w"> </span>    def get_dir_infos(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used to return a couple of infos that are needed when accessing the sub
<span class="w"> </span>        objects of an objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            (name, self._create_access(getattr(self._obj, name)))</span>
<span class="gi">+            for name in dir(self._obj)</span>
<span class="gi">+            if not name.startswith(&#39;__&#39;) or name.endswith(&#39;__&#39;)</span>
<span class="gi">+        ]</span>


<span class="w"> </span>def _is_class_instance(obj):
<span class="w"> </span>    &quot;&quot;&quot;Like inspect.* methods.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (not isinstance(obj, type)</span>
<span class="gi">+            and not isinstance(obj, types.ModuleType)</span>
<span class="gi">+            and not isinstance(obj, types.FunctionType)</span>
<span class="gi">+            and not isinstance(obj, types.MethodType))</span>
<span class="gh">diff --git a/jedi/inference/compiled/getattr_static.py b/jedi/inference/compiled/getattr_static.py</span>
<span class="gh">index 2fd959ee..62a238d0 100644</span>
<span class="gd">--- a/jedi/inference/compiled/getattr_static.py</span>
<span class="gi">+++ b/jedi/inference/compiled/getattr_static.py</span>
<span class="gu">@@ -22,4 +22,28 @@ def getattr_static(obj, attr, default=_sentinel):</span>
<span class="w"> </span>       Returns a tuple `(attr, is_get_descriptor)`. is_get_descripter means that
<span class="w"> </span>       the attribute is a descriptor that has a `__get__` attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    instance_dict = {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        instance_dict = object.__getattribute__(obj, &#39;__dict__&#39;)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    klass = obj.__class__</span>
<span class="gi">+    dict_attr = instance_dict.get(attr, _sentinel)</span>
<span class="gi">+    if dict_attr is not _sentinel:</span>
<span class="gi">+        return dict_attr, False</span>
<span class="gi">+</span>
<span class="gi">+    for base in klass.__mro__:</span>
<span class="gi">+        if attr in base.__dict__:</span>
<span class="gi">+            class_attr = base.__dict__[attr]</span>
<span class="gi">+            if isinstance(class_attr, (types.FunctionType, staticmethod)):</span>
<span class="gi">+                return class_attr, False</span>
<span class="gi">+            if isinstance(class_attr, property):</span>
<span class="gi">+                return class_attr.fget, True</span>
<span class="gi">+            if hasattr(class_attr, &#39;__get__&#39;):</span>
<span class="gi">+                return class_attr, True</span>
<span class="gi">+            return class_attr, False</span>
<span class="gi">+</span>
<span class="gi">+    if default is _sentinel:</span>
<span class="gi">+        raise AttributeError(f&quot;&#39;{type(obj).__name__}&#39; object has no attribute &#39;{attr}&#39;&quot;)</span>
<span class="gi">+    return default, False</span>
<span class="gh">diff --git a/jedi/inference/compiled/mixed.py b/jedi/inference/compiled/mixed.py</span>
<span class="gh">index 747c0bd5..807cf355 100644</span>
<span class="gd">--- a/jedi/inference/compiled/mixed.py</span>
<span class="gi">+++ b/jedi/inference/compiled/mixed.py</span>
<span class="gu">@@ -73,4 +73,9 @@ class MixedObjectFilter(compiled.CompiledValueFilter):</span>

<span class="w"> </span>def _get_object_to_check(python_object):
<span class="w"> </span>    &quot;&quot;&quot;Check if inspect.getfile has a chance to find the source.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if inspect.ismodule(python_object):</span>
<span class="gi">+        return python_object</span>
<span class="gi">+    try:</span>
<span class="gi">+        return python_object.__class__</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return python_object</span>
<span class="gh">diff --git a/jedi/inference/compiled/subprocess/functions.py b/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gh">index ac69d794..dd9ae543 100644</span>
<span class="gd">--- a/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gi">+++ b/jedi/inference/compiled/subprocess/functions.py</span>
<span class="gu">@@ -16,21 +16,52 @@ def get_module_info(inference_state, sys_path=None, full_name=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns Tuple[Union[NamespaceInfo, FileIO, None], Optional[bool]]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys_path is None:</span>
<span class="gi">+        sys_path = sys.path</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_loader, module_name, is_package = _find_module(full_name, sys_path)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    if module_loader is None:  # builtin module</span>
<span class="gi">+        return None, True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_path = module_loader.get_filename(full_name)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    is_package = is_package or _get_init_path(Path(module_path).parent) is not None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(module_loader, zipimporter):</span>
<span class="gi">+        module_file = ZipFileIO(module_path, module_loader.archive)</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_file = KnownContentFileIO(module_path, _get_source(module_loader, full_name))</span>
<span class="gi">+</span>
<span class="gi">+    return module_file, is_package</span>


<span class="w"> </span>def _test_raise_error(inference_state, exception_type):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raise an error to simulate certain problems for unit tests.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if exception_type == &quot;ImportError&quot;:</span>
<span class="gi">+        raise ImportError(&quot;Test ImportError&quot;)</span>
<span class="gi">+    elif exception_type == &quot;AttributeError&quot;:</span>
<span class="gi">+        raise AttributeError(&quot;Test AttributeError&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown exception type: {exception_type}&quot;)</span>


<span class="w"> </span>def _test_print(inference_state, stderr=None, stdout=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Force some prints in the subprocesses. This exists for unit tests.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stderr:</span>
<span class="gi">+        print(stderr, file=sys.stderr)</span>
<span class="gi">+    if stdout:</span>
<span class="gi">+        print(stdout, file=sys.stdout)</span>


<span class="w"> </span>def _get_init_path(directory_path):
<span class="gu">@@ -38,7 +69,11 @@ def _get_init_path(directory_path):</span>
<span class="w"> </span>    The __init__ file can be searched in a directory. If found return it, else
<span class="w"> </span>    None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for suffix in all_suffixes():</span>
<span class="gi">+        init_path = directory_path / f&quot;__init__{suffix}&quot;</span>
<span class="gi">+        if init_path.is_file():</span>
<span class="gi">+            return init_path</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def _find_module(string, path=None, full_name=None, is_global_search=True):
<span class="gu">@@ -51,7 +86,34 @@ def _find_module(string, path=None, full_name=None, is_global_search=True):</span>
<span class="w"> </span>    or the name of the module if it is a builtin one and a boolean indicating
<span class="w"> </span>    if the module is contained in a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if full_name is None:</span>
<span class="gi">+        full_name = string</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        spec = importlib.util.find_spec(full_name, path)</span>
<span class="gi">+    except (ImportError, AttributeError, ValueError, SystemError, SyntaxError):</span>
<span class="gi">+        spec = None</span>
<span class="gi">+</span>
<span class="gi">+    if spec is None:</span>
<span class="gi">+        raise ImportError(f&quot;No module named {full_name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if spec.loader is None:</span>
<span class="gi">+        if spec.submodule_search_locations:</span>
<span class="gi">+            return None, spec.name, True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ImportError(f&quot;No module named {full_name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if spec.origin == &#39;builtin&#39;:</span>
<span class="gi">+        return None, spec.name, False</span>
<span class="gi">+</span>
<span class="gi">+    loader = spec.loader</span>
<span class="gi">+    if hasattr(loader, &#39;get_filename&#39;):</span>
<span class="gi">+        module_path = loader.get_filename(full_name)</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_path = spec.origin</span>
<span class="gi">+</span>
<span class="gi">+    is_package = spec.submodule_search_locations is not None</span>
<span class="gi">+    return loader, module_path, is_package</span>


<span class="w"> </span>def _get_source(loader, fullname):
<span class="gu">@@ -59,7 +121,17 @@ def _get_source(loader, fullname):</span>
<span class="w"> </span>    This method is here as a replacement for SourceLoader.get_source. That
<span class="w"> </span>    method returns unicode, but we prefer bytes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = loader.get_source(fullname)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(source, str):</span>
<span class="gi">+        return source.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    return source</span>


<span class="w"> </span>class ImplicitNSInfo:
<span class="gh">diff --git a/jedi/inference/compiled/value.py b/jedi/inference/compiled/value.py</span>
<span class="gh">index e49e6da0..1b476abe 100644</span>
<span class="gd">--- a/jedi/inference/compiled/value.py</span>
<span class="gi">+++ b/jedi/inference/compiled/value.py</span>
<span class="gu">@@ -119,7 +119,34 @@ class CompiledValueFilter(AbstractFilter):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To remove quite a few access calls we introduced the callback here.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        access_handle = self.compiled_value.access_handle</span>
<span class="gi">+        </span>
<span class="gi">+        if check_has_attribute:</span>
<span class="gi">+            try:</span>
<span class="gi">+                access_handle.getattr_paths(name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                return None</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            if allowed_getattr_callback():</span>
<span class="gi">+                return CompiledName(</span>
<span class="gi">+                    self._inference_state,</span>
<span class="gi">+                    self.compiled_value,</span>
<span class="gi">+                    name,</span>
<span class="gi">+                    is_descriptor=access_handle.is_descriptor(name)</span>
<span class="gi">+                )</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        </span>
<span class="gi">+        if in_dir_callback():</span>
<span class="gi">+            return CompiledName(</span>
<span class="gi">+                self._inference_state,</span>
<span class="gi">+                self.compiled_value,</span>
<span class="gi">+                name,</span>
<span class="gi">+                is_descriptor=False</span>
<span class="gi">+            )</span>
<span class="gi">+        </span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.compiled_value)
<span class="gu">@@ -137,9 +164,36 @@ def _parse_function_doc(doc):</span>
<span class="w"> </span>    TODO docstrings like utime(path, (atime, mtime)) and a(b [, b]) -&gt; None
<span class="w"> </span>    TODO docstrings like &#39;tuple of integers&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if doc is None:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    doc = doc.strip()</span>
<span class="gi">+    </span>
<span class="gi">+    # Try to parse return value</span>
<span class="gi">+    return_value = None</span>
<span class="gi">+    arrow_pos = doc.find(&#39;-&gt;&#39;)</span>
<span class="gi">+    if arrow_pos != -1:</span>
<span class="gi">+        return_value = doc[arrow_pos + 2:].strip().split()[0]</span>
<span class="gi">+        doc = doc[:arrow_pos].strip()</span>
<span class="gi">+</span>
<span class="gi">+    # Try to parse parameters</span>
<span class="gi">+    params = []</span>
<span class="gi">+    param_start = doc.find(&#39;(&#39;)</span>
<span class="gi">+    param_end = doc.rfind(&#39;)&#39;)</span>
<span class="gi">+    if param_start != -1 and param_end != -1:</span>
<span class="gi">+        param_str = doc[param_start + 1:param_end].strip()</span>
<span class="gi">+        if param_str:</span>
<span class="gi">+            params = [p.strip().split(&#39;:&#39;)[0] for p in param_str.split(&#39;,&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+    # Normalize return value</span>
<span class="gi">+    if return_value in docstr_defaults:</span>
<span class="gi">+        return_value = docstr_defaults[return_value]</span>
<span class="gi">+</span>
<span class="gi">+    return params, return_value</span>


<span class="w"> </span>def _normalize_create_args(func):
<span class="w"> </span>    &quot;&quot;&quot;The cache doesn&#39;t care about keyword vs. normal args.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        return func(*args, **kwargs)</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/inference/context.py b/jedi/inference/context.py</span>
<span class="gh">index f08ebfd9..bcba2f71 100644</span>
<span class="gd">--- a/jedi/inference/context.py</span>
<span class="gi">+++ b/jedi/inference/context.py</span>
<span class="gu">@@ -23,7 +23,15 @@ class AbstractContext:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param position: Position of the last statement -&gt; tuple of line, column
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name_or_str, str):</span>
<span class="gi">+            name = name_or_str</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = name_or_str.value</span>
<span class="gi">+</span>
<span class="gi">+        if name in self.predefined_names:</span>
<span class="gi">+            return self.predefined_names[name]</span>
<span class="gi">+        </span>
<span class="gi">+        return NO_VALUES</span>


<span class="w"> </span>class ValueContext(AbstractContext):
<span class="gu">@@ -55,7 +63,7 @@ class ModuleContext(TreeContextMixin, ValueContext):</span>
<span class="w"> </span>        This is necessary for stub -&gt; python conversion and vice versa. However
<span class="w"> </span>        this method shouldn&#39;t be moved to AbstractContext.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value</span>


<span class="w"> </span>class NamespaceContext(TreeContextMixin, ValueContext):
<span class="gu">@@ -132,4 +140,23 @@ def get_global_filters(context, until_position, origin_scope):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(filters[3].values())  # doctest: +ELLIPSIS
<span class="w"> </span>    [...]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield MergedFilter(</span>
<span class="gi">+        ParserTreeFilter(</span>
<span class="gi">+            context,</span>
<span class="gi">+            until_position=until_position,</span>
<span class="gi">+            origin_scope=origin_scope</span>
<span class="gi">+        ),</span>
<span class="gi">+        GlobalNameFilter(context)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Add the names of parent scopes</span>
<span class="gi">+    parent_scope = get_parent_scope(context.tree_node)</span>
<span class="gi">+    while parent_scope is not None:</span>
<span class="gi">+        yield ParserTreeFilter(</span>
<span class="gi">+            context.create_context(parent_scope),</span>
<span class="gi">+            until_position=until_position</span>
<span class="gi">+        )</span>
<span class="gi">+        parent_scope = get_parent_scope(parent_scope)</span>
<span class="gi">+</span>
<span class="gi">+    # Add builtins</span>
<span class="gi">+    yield context.inference_state.builtins_module.get_global_filter()</span>
<span class="gh">diff --git a/jedi/inference/docstrings.py b/jedi/inference/docstrings.py</span>
<span class="gh">index c054a3b5..20c0961e 100644</span>
<span class="gd">--- a/jedi/inference/docstrings.py</span>
<span class="gi">+++ b/jedi/inference/docstrings.py</span>
<span class="gu">@@ -31,21 +31,44 @@ _numpy_doc_string_cache = None</span>

<span class="w"> </span>def _search_param_in_numpydocstr(docstr, param_str):
<span class="w"> </span>    &quot;&quot;&quot;Search `docstr` (in numpydoc format) for type(-s) of `param_str`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    param_section = re.search(r&#39;Parameters\n----------(.*?)(\n\n|$)&#39;, docstr, re.DOTALL)</span>
<span class="gi">+    if param_section:</span>
<span class="gi">+        param_lines = param_section.group(1).split(&#39;\n&#39;)</span>
<span class="gi">+        for i, line in enumerate(param_lines):</span>
<span class="gi">+            if line.strip().startswith(param_str):</span>
<span class="gi">+                type_line = param_lines[i + 1] if i + 1 &lt; len(param_lines) else &#39;&#39;</span>
<span class="gi">+                match = re.search(r&#39;:\s*(.+)&#39;, type_line)</span>
<span class="gi">+                if match:</span>
<span class="gi">+                    return [t.strip() for t in match.group(1).split(&#39;,&#39;)]</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def _search_return_in_numpydocstr(docstr):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Search `docstr` (in numpydoc format) for type(-s) of function returns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    returns_section = re.search(r&#39;Returns\n--------(.*?)(\n\n|$)&#39;, docstr, re.DOTALL)</span>
<span class="gi">+    if returns_section:</span>
<span class="gi">+        return_lines = returns_section.group(1).split(&#39;\n&#39;)</span>
<span class="gi">+        for line in return_lines:</span>
<span class="gi">+            match = re.search(r&#39;(.+?)\s*:\s*(.+)&#39;, line.strip())</span>
<span class="gi">+            if match:</span>
<span class="gi">+                return [t.strip() for t in match.group(2).split(&#39;,&#39;)]</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def _expand_typestr(type_str):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attempts to interpret the possible types in `type_str`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    types = []</span>
<span class="gi">+    for part in type_str.split(&#39;or&#39;):</span>
<span class="gi">+        part = part.strip()</span>
<span class="gi">+        if part.startswith(&#39;{&#39;) and part.endswith(&#39;}&#39;):</span>
<span class="gi">+            types.extend(t.strip() for t in part[1:-1].split(&#39;,&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            types.append(part)</span>
<span class="gi">+    return [_strip_rst_role(t) for t in types]</span>


<span class="w"> </span>def _search_param_in_docstr(docstr, param_str):
<span class="gu">@@ -65,7 +88,12 @@ def _search_param_in_docstr(docstr, param_str):</span>
<span class="w"> </span>    [&#39;int&#39;]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    patterns = [p % re.escape(param_str) for p in DOCSTRING_PARAM_PATTERNS]</span>
<span class="gi">+    for pattern in patterns:</span>
<span class="gi">+        match = re.search(pattern, docstr)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            return _expand_typestr(match.group(1))</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def _strip_rst_role(type_str):
<span class="gu">@@ -83,7 +111,10 @@ def _strip_rst_role(type_str):</span>
<span class="w"> </span>    http://sphinx-doc.org/domains.html#cross-referencing-python-objects

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = REST_ROLE_PATTERN.match(type_str)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        return match.group(1)</span>
<span class="gi">+    return type_str</span>


<span class="w"> </span>def _execute_types_in_stmt(module_context, stmt):
<span class="gu">@@ -92,7 +123,13 @@ def _execute_types_in_stmt(module_context, stmt):</span>
<span class="w"> </span>    doesn&#39;t include tuple, list and dict literals, because the stuff they
<span class="w"> </span>    contain is executed. (Used as type information).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    definitions = module_context.infer_node(stmt)</span>
<span class="gi">+    return ValueSet.from_sets(</span>
<span class="gi">+        d.execute_annotation()</span>
<span class="gi">+        if d.is_class()</span>
<span class="gi">+        else ValueSet([d])</span>
<span class="gi">+        for d in definitions</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _execute_array_values(inference_state, array):
<span class="gu">@@ -100,4 +137,12 @@ def _execute_array_values(inference_state, array):</span>
<span class="w"> </span>    Tuples indicate that there&#39;s not just one return value, but the listed
<span class="w"> </span>    ones.  `(str, int)` means that it returns a tuple with both types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from jedi.inference.value.iterable import SequenceLiteralValue</span>
<span class="gi">+    if isinstance(array, SequenceLiteralValue):</span>
<span class="gi">+        values = ValueSet.from_sets(</span>
<span class="gi">+            _execute_array_values(inference_state, v)</span>
<span class="gi">+            for v in array.py__iter__()</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        values = ValueSet([array])</span>
<span class="gi">+    return values</span>
<span class="gh">diff --git a/jedi/inference/dynamic_params.py b/jedi/inference/dynamic_params.py</span>
<span class="gh">index ef714079..12bd1396 100644</span>
<span class="gd">--- a/jedi/inference/dynamic_params.py</span>
<span class="gi">+++ b/jedi/inference/dynamic_params.py</span>
<span class="gu">@@ -46,7 +46,18 @@ def dynamic_param_lookup(function_value, param_index):</span>
<span class="w"> </span>    have to look for all calls to ``func`` to find out what ``foo`` possibly
<span class="w"> </span>    is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    debug.dbg(&#39;Dynamic param lookup for %s param %i&#39;, function_value, param_index)</span>
<span class="gi">+    module_context = function_value.get_root_context()</span>
<span class="gi">+    function_executions = _search_function_arguments(</span>
<span class="gi">+        module_context,</span>
<span class="gi">+        function_value.tree_node,</span>
<span class="gi">+        function_value.name.string_name</span>
<span class="gi">+    )</span>
<span class="gi">+    values = NO_VALUES</span>
<span class="gi">+    for name, value in function_executions:</span>
<span class="gi">+        debug.dbg(&#39;Found param %s&#39;, name)</span>
<span class="gi">+        values |= value.infer()</span>
<span class="gi">+    return values</span>


<span class="w"> </span>@inference_state_method_cache(default=None)
<span class="gu">@@ -55,4 +66,30 @@ def _search_function_arguments(module_context, funcdef, string_name):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a list of param names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_name = funcdef.name.value</span>
<span class="gi">+    found_arguments = []</span>
<span class="gi">+    module_contexts = get_module_contexts_containing_name(</span>
<span class="gi">+        module_context, search_name</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    for module_context in module_contexts:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for name, trailer in _get_potential_nodes(module_context, string_name):</span>
<span class="gi">+                arguments = trailer.children[1]</span>
<span class="gi">+                if arguments.type == &#39;arglist&#39;:</span>
<span class="gi">+                    params = get_executed_param_names(funcdef)</span>
<span class="gi">+                    for i, param in enumerate(params):</span>
<span class="gi">+                        if i &lt; len(arguments.children):</span>
<span class="gi">+                            child = arguments.children[i]</span>
<span class="gi">+                            if child.type == &#39;argument&#39;:</span>
<span class="gi">+                                # Is a keyword argument</span>
<span class="gi">+                                if child.children[0].value == param.string_name:</span>
<span class="gi">+                                    child = child.children[2]</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                            value = module_context.create_value(child)</span>
<span class="gi">+                            found_arguments.append((param, value))</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    return found_arguments</span>
<span class="gh">diff --git a/jedi/inference/filters.py b/jedi/inference/filters.py</span>
<span class="gh">index 4dab38a3..70e97dd9 100644</span>
<span class="gd">--- a/jedi/inference/filters.py</span>
<span class="gi">+++ b/jedi/inference/filters.py</span>
<span class="gu">@@ -26,6 +26,17 @@ class FilterWrapper:</span>
<span class="w"> </span>    def __init__(self, wrapped_filter):
<span class="w"> </span>        self._wrapped_filter = wrapped_filter

<span class="gi">+    def get_names(self):</span>
<span class="gi">+        for name in self._wrapped_filter.get_names():</span>
<span class="gi">+            yield self.name_wrapper_class(name)</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        names = self._wrapped_filter.get(name)</span>
<span class="gi">+        return [self.name_wrapper_class(name) for name in names]</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._wrapped_filter.values()</span>
<span class="gi">+</span>

<span class="w"> </span>class _AbstractUsedNamesFilter(AbstractFilter):
<span class="w"> </span>    name_class = TreeNameDefinition
<span class="gu">@@ -64,6 +75,21 @@ class ParserTreeFilter(_AbstractUsedNamesFilter):</span>
<span class="w"> </span>        self._origin_scope = origin_scope
<span class="w"> </span>        self._until_position = until_position

<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        names = super()._filter(names)</span>
<span class="gi">+        if self._until_position is not None:</span>
<span class="gi">+            names = [n for n in names if n.start_pos &lt; self._until_position]</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def _check_flows(self, names):</span>
<span class="gi">+        if self._until_position is not None:</span>
<span class="gi">+            return flow_analysis.reachability_check(self._parent_context, names, self._until_position)</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def get_names(self):</span>
<span class="gi">+        names = self._filter(self._used_names.get(self._parser_scope.name, []))</span>
<span class="gi">+        return self._check_flows(names)</span>
<span class="gi">+</span>

<span class="w"> </span>class _FunctionExecutionFilter(ParserTreeFilter):

<span class="gu">@@ -80,6 +106,15 @@ class FunctionExecutionFilter(_FunctionExecutionFilter):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def get_names(self):</span>
<span class="gi">+        names = super().get_names()</span>
<span class="gi">+        param_names = self._function_value.get_param_names()</span>
<span class="gi">+        for param_name in param_names:</span>
<span class="gi">+            if param_name.string_name in self._arguments.unbound_names:</span>
<span class="gi">+                continue</span>
<span class="gi">+            names.append(ParamName(self._function_value, param_name))</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>

<span class="w"> </span>class AnonymousFunctionExecutionFilter(_FunctionExecutionFilter):
<span class="w"> </span>    pass
<span class="gu">@@ -98,6 +133,15 @@ class DictFilter(AbstractFilter):</span>
<span class="w"> </span>        keys = &#39;, &#39;.join(self._dct.keys())
<span class="w"> </span>        return &#39;&lt;%s: for {%s}&gt;&#39; % (self.__class__.__name__, keys)

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return [self._dct[name]] if name in self._dct else []</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return self._dct.values()</span>
<span class="gi">+</span>
<span class="gi">+    def get_names(self):</span>
<span class="gi">+        return list(self._dct.keys())</span>
<span class="gi">+</span>

<span class="w"> </span>class MergedFilter:

<span class="gu">@@ -108,6 +152,24 @@ class MergedFilter:</span>
<span class="w"> </span>        return &#39;%s(%s)&#39; % (self.__class__.__name__, &#39;, &#39;.join(str(f) for f in
<span class="w"> </span>            self._filters))

<span class="gi">+    def get_names(self):</span>
<span class="gi">+        names = []</span>
<span class="gi">+        for filter in self._filters:</span>
<span class="gi">+            names.extend(filter.get_names())</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, name):</span>
<span class="gi">+        names = []</span>
<span class="gi">+        for filter in self._filters:</span>
<span class="gi">+            names.extend(filter.get(name))</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        values = []</span>
<span class="gi">+        for filter in self._filters:</span>
<span class="gi">+            values.extend(filter.values())</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>

<span class="w"> </span>class _BuiltinMappedMethod(ValueWrapper):
<span class="w"> </span>    &quot;&quot;&quot;``Generator.__next__`` ``dict.values`` methods and so on.&quot;&quot;&quot;
<span class="gh">diff --git a/jedi/inference/finder.py b/jedi/inference/finder.py</span>
<span class="gh">index 48ed829c..f192e63d 100644</span>
<span class="gd">--- a/jedi/inference/finder.py</span>
<span class="gi">+++ b/jedi/inference/finder.py</span>
<span class="gu">@@ -28,7 +28,12 @@ def filter_name(filters, name_or_str):</span>
<span class="w"> </span>    Searches names that are defined in a scope (the different
<span class="w"> </span>    ``filters``), until a name fits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    str_name = name_or_str.value if isinstance(name_or_str, Name) else name_or_str</span>
<span class="gi">+    for filter in filters:</span>
<span class="gi">+        names = filter.get(str_name)</span>
<span class="gi">+        if names:</span>
<span class="gi">+            return names</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def check_flow_information(value, flow, search_name, pos):
<span class="gu">@@ -40,4 +45,53 @@ def check_flow_information(value, flow, search_name, pos):</span>

<span class="w"> </span>    ensures that `k` is a string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    if is_scope(flow):</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    parent = search_ancestor(flow, &#39;if_stmt&#39;, &#39;assert_stmt&#39;)</span>
<span class="gi">+    if parent is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if parent.type == &#39;if_stmt&#39;:</span>
<span class="gi">+            node = parent.children[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = parent.children[1]</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    if node.type == &#39;atom&#39; and node.children[0] == &#39;(&#39;:</span>
<span class="gi">+        node = node.children[1]</span>
<span class="gi">+</span>
<span class="gi">+    if node.type != &#39;atom_expr&#39;:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    # Check for isinstance call</span>
<span class="gi">+    if not (node.children[0].value == &#39;isinstance&#39; and</span>
<span class="gi">+            len(node.children) == 2 and</span>
<span class="gi">+            node.children[1].type == &#39;trailer&#39; and</span>
<span class="gi">+            node.children[1].children[0] == &#39;(&#39; and</span>
<span class="gi">+            node.children[1].children[1].type == &#39;arglist&#39; and</span>
<span class="gi">+            len(node.children[1].children[1].children) == 3):</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    arglist = node.children[1].children[1]</span>
<span class="gi">+    first_arg = arglist.children[0]</span>
<span class="gi">+    second_arg = arglist.children[2]</span>
<span class="gi">+</span>
<span class="gi">+    # Ensure the first argument matches our search_name</span>
<span class="gi">+    if first_arg.type != &#39;name&#39; or first_arg.value != search_name:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    # Get the type from the second argument</span>
<span class="gi">+    if second_arg.type == &#39;name&#39;:</span>
<span class="gi">+        type_value = value.inference_state.builtins_module.py__getattribute__(second_arg.value)</span>
<span class="gi">+    elif second_arg.type == &#39;atom&#39;:</span>
<span class="gi">+        type_value = value.inference_state.builtins_module.py__getattribute__(second_arg.children[0].value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    return type_value.execute_with_values()</span>
<span class="gh">diff --git a/jedi/inference/gradual/annotation.py b/jedi/inference/gradual/annotation.py</span>
<span class="gh">index e720fb88..eca3f35d 100644</span>
<span class="gd">--- a/jedi/inference/gradual/annotation.py</span>
<span class="gi">+++ b/jedi/inference/gradual/annotation.py</span>
<span class="gu">@@ -28,7 +28,17 @@ def infer_annotation(context, annotation):</span>

<span class="w"> </span>    Also checks for forward references (strings)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if annotation is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    if is_string(annotation):</span>
<span class="gi">+        try:</span>
<span class="gi">+            annotation = parse(annotation.get_safe_value(), version=&#39;3.7&#39;).children[0]</span>
<span class="gi">+        except ParserSyntaxError:</span>
<span class="gi">+            debug.warning(&#39;Failed to parse forward reference: %s&#39;, annotation)</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    return context.infer_node(annotation)</span>


<span class="w"> </span>def _split_comment_param_declaration(decl_text):
<span class="gu">@@ -40,14 +50,31 @@ def _split_comment_param_declaration(decl_text):</span>
<span class="w"> </span>    [&#39;foo&#39;, &#39;Bar[baz, biz]&#39;].

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        node = parse(decl_text, version=&#39;3.7&#39;)</span>
<span class="gi">+    except ParserSyntaxError:</span>
<span class="gi">+        debug.warning(&#39;Comment annotation is not valid Python: %s&#39;, decl_text)</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    params = []</span>
<span class="gi">+    for param in node.children[0].children:</span>
<span class="gi">+        if param.type == &#39;operator&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        params.append(param.get_code().strip())</span>
<span class="gi">+</span>
<span class="gi">+    return params</span>


<span class="w"> </span>def _infer_param(function_value, param):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Infers the type of a function parameter, using type annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotation = param.annotation</span>
<span class="gi">+    if annotation is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    context = function_value.get_default_param_context()</span>
<span class="gi">+    return infer_annotation(context, annotation)</span>


<span class="w"> </span>@inference_state_method_cache()
<span class="gu">@@ -56,7 +83,18 @@ def infer_return_types(function, arguments):</span>
<span class="w"> </span>    Infers the type of a function&#39;s return value,
<span class="w"> </span>    according to type annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotation = function.tree_node.annotation</span>
<span class="gi">+    if annotation is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    context = function.get_default_param_context()</span>
<span class="gi">+    annotation_values = infer_annotation(context, annotation)</span>
<span class="gi">+</span>
<span class="gi">+    if arguments is not None:</span>
<span class="gi">+        type_vars = infer_type_vars_for_execution(function, arguments, {})</span>
<span class="gi">+        annotation_values = annotation_values.define_generics(type_vars)</span>
<span class="gi">+</span>
<span class="gi">+    return annotation_values</span>


<span class="w"> </span>def infer_type_vars_for_execution(function, arguments, annotation_dict):
<span class="gu">@@ -69,7 +107,16 @@ def infer_type_vars_for_execution(function, arguments, annotation_dict):</span>
<span class="w"> </span>    2. Infer type vars with the execution state we have.
<span class="w"> </span>    3. Return the union of all type vars that have been found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    type_var_dict = {}</span>
<span class="gi">+    executed_param_names = get_executed_param_names(function, arguments)</span>
<span class="gi">+</span>
<span class="gi">+    for executed_param_name in executed_param_names:</span>
<span class="gi">+        param_annotation = annotation_dict.get(executed_param_name)</span>
<span class="gi">+        if param_annotation is not None:</span>
<span class="gi">+            actual_value_set = executed_param_names[executed_param_name].infer()</span>
<span class="gi">+            type_var_dict.update(infer_type_vars(param_annotation, actual_value_set))</span>
<span class="gi">+</span>
<span class="gi">+    return type_var_dict</span>


<span class="w"> </span>def _infer_type_vars_for_callable(arguments, lazy_params):
<span class="gu">@@ -78,7 +125,11 @@ def _infer_type_vars_for_callable(arguments, lazy_params):</span>

<span class="w"> </span>        def x() -&gt; Callable[[Callable[..., _T]], _T]: ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    type_var_dict = {}</span>
<span class="gi">+    for (key, lazy_value), executed_param in zip(lazy_params, arguments.unpack()):</span>
<span class="gi">+        if key is not None:</span>
<span class="gi">+            type_var_dict.update(infer_type_vars(lazy_value.infer(), executed_param.infer()))</span>
<span class="gi">+    return type_var_dict</span>


<span class="w"> </span>def merge_pairwise_generics(annotation_value, annotated_argument_class):
<span class="gu">@@ -115,4 +166,12 @@ def merge_pairwise_generics(annotation_value, annotated_argument_class):</span>
<span class="w"> </span>    `annotated_argument_class`: represents the annotated class of the
<span class="w"> </span>        argument being passed to the object annotated by `annotation_value`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(annotation_value, GenericClass) or not isinstance(annotated_argument_class, GenericClass):</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    type_var_dict = {}</span>
<span class="gi">+    for ann_param, arg_param in zip(annotation_value.get_generics(), annotated_argument_class.get_generics()):</span>
<span class="gi">+        if isinstance(ann_param, TypeVar):</span>
<span class="gi">+            type_var_dict[ann_param.name] = arg_param</span>
<span class="gi">+</span>
<span class="gi">+    return type_var_dict</span>
<span class="gh">diff --git a/jedi/inference/gradual/base.py b/jedi/inference/gradual/base.py</span>
<span class="gh">index 6eb858d9..c62ee3d5 100644</span>
<span class="gd">--- a/jedi/inference/gradual/base.py</span>
<span class="gi">+++ b/jedi/inference/gradual/base.py</span>
<span class="gu">@@ -40,9 +40,25 @@ class _TypeVarFilter:</span>
<span class="w"> </span>        self._generics = generics
<span class="w"> </span>        self._type_vars = type_vars

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        for i, type_var in enumerate(self._type_vars):</span>
<span class="gi">+            if type_var.py__name__() == name:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return [_BoundTypeVarName(type_var, self._generics[i])]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    return [type_var.name]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return [_BoundTypeVarName(type_var, generic)</span>
<span class="gi">+                for type_var, generic in zip(self._type_vars, self._generics)]</span>
<span class="gi">+</span>

<span class="w"> </span>class _AnnotatedClassContext(ClassContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        yield _TypeVarFilter(self.class_value.get_generics(), self.class_value.list_type_vars())</span>
<span class="gi">+        yield from filters</span>


<span class="w"> </span>class DefineGenericBaseClass(LazyValueWrapper):
<span class="gu">@@ -67,6 +83,19 @@ class GenericClass(DefineGenericBaseClass, ClassMixin):</span>
<span class="w"> </span>        super().__init__(generics_manager)
<span class="w"> </span>        self._class_value = class_value

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        return self._class_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_var_filter(self):</span>
<span class="gi">+        return _TypeVarFilter(self.get_generics(), self.list_type_vars())</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        instance = self._class_value.py__call__(arguments)</span>
<span class="gi">+        return ValueSet([_GenericInstanceWrapper(instance[0], self.get_generics_manager())])</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        return _AnnotatedClassContext(self)</span>
<span class="gi">+</span>

<span class="w"> </span>class _LazyGenericBaseClass:

<span class="gu">@@ -78,9 +107,27 @@ class _LazyGenericBaseClass:</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self._lazy_base_class)

<span class="gi">+    def _get_wrapped_value(self):</span>
<span class="gi">+        base_class = self._lazy_base_class.infer()</span>
<span class="gi">+        if len(base_class) != 1:</span>
<span class="gi">+            # This is an error in the code, but we just ignore it</span>
<span class="gi">+            return self._class_value</span>
<span class="gi">+        return GenericClass(base_class[0], self._generics_manager)</span>
<span class="gi">+</span>

<span class="w"> </span>class _GenericInstanceWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, wrapped_value, generics_manager):</span>
<span class="gi">+        super().__init__(wrapped_value)</span>
<span class="gi">+        self._generics_manager = generics_manager</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_var_filter(self):</span>
<span class="gi">+        return _TypeVarFilter(self._generics_manager.to_tuple(), self._wrapped_value.class_value.list_type_vars())</span>
<span class="gi">+</span>
<span class="gi">+    def py__stop_iteration_returns(self):</span>
<span class="gi">+        return self._generics_manager.to_tuple()</span>
<span class="gi">+</span>
<span class="gi">+    def get_annotated_class_object(self):</span>
<span class="gi">+        return _AnnotatedClassContext(self._wrapped_value.class_value)</span>


<span class="w"> </span>class _PseudoTreeNameClass(Value):
<span class="gh">diff --git a/jedi/inference/gradual/generics.py b/jedi/inference/gradual/generics.py</span>
<span class="gh">index b7bca99a..6cd84309 100644</span>
<span class="gd">--- a/jedi/inference/gradual/generics.py</span>
<span class="gi">+++ b/jedi/inference/gradual/generics.py</span>
<span class="gu">@@ -11,7 +11,14 @@ from jedi.inference.helpers import is_string</span>


<span class="w"> </span>class _AbstractGenericManager:
<span class="gd">-    pass</span>
<span class="gi">+    def __getitem__(self, index):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self):</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def to_tuple(self):</span>
<span class="gi">+        return tuple(self[i] for i in range(len(self)))</span>


<span class="w"> </span>class LazyGenericManager(_AbstractGenericManager):
<span class="gu">@@ -20,6 +27,13 @@ class LazyGenericManager(_AbstractGenericManager):</span>
<span class="w"> </span>        self._context_of_index = context_of_index
<span class="w"> </span>        self._index_value = index_value

<span class="gi">+    @memoize_method</span>
<span class="gi">+    def _tuple(self):</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            lambda: v.infer()</span>
<span class="gi">+            for v in self._index_value.infer().iterate()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    @memoize_method
<span class="w"> </span>    def __getitem__(self, index):
<span class="w"> </span>        return self._tuple()[index]()
<span class="gu">@@ -42,5 +56,8 @@ class TupleGenericManager(_AbstractGenericManager):</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._tuple)

<span class="gi">+    def to_tuple(self):</span>
<span class="gi">+        return self._tuple</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;TupG&gt;[%s]&#39; % &#39;, &#39;.join(repr(x) for x in self.to_tuple())
<span class="gh">diff --git a/jedi/inference/gradual/stub_value.py b/jedi/inference/gradual/stub_value.py</span>
<span class="gh">index 17b168a1..c54a8565 100644</span>
<span class="gd">--- a/jedi/inference/gradual/stub_value.py</span>
<span class="gi">+++ b/jedi/inference/gradual/stub_value.py</span>
<span class="gu">@@ -19,19 +19,32 @@ class StubModuleValue(ModuleValue):</span>
<span class="w"> </span>        don&#39;t have code for all the child modules. At the time of writing this
<span class="w"> </span>        there are for example no stubs for `json.tool`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stub_sub_modules = super().sub_modules_dict()</span>
<span class="gi">+        non_stub_sub_modules = {}</span>
<span class="gi">+        for non_stub_value in self.non_stub_value_set:</span>
<span class="gi">+            if isinstance(non_stub_value, ModuleValue):</span>
<span class="gi">+                non_stub_sub_modules.update(non_stub_value.sub_modules_dict())</span>
<span class="gi">+        </span>
<span class="gi">+        # Merge stub and non-stub sub-modules, prioritizing stub modules</span>
<span class="gi">+        return {**non_stub_sub_modules, **stub_sub_modules}</span>


<span class="w"> </span>class StubModuleContext(ModuleContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        return [StubFilter(self.tree_node, self.value, *args, **kwargs)] + list(filters)</span>


<span class="w"> </span>class TypingModuleWrapper(StubModuleValue):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        return [TypingModuleFilterWrapper(f) for f in filters]</span>


<span class="w"> </span>class TypingModuleContext(ModuleContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        return [TypingModuleFilterWrapper(f) for f in filters]</span>


<span class="w"> </span>class StubFilter(ParserTreeFilter):
<span class="gu">@@ -39,4 +52,8 @@ class StubFilter(ParserTreeFilter):</span>


<span class="w"> </span>class VersionInfo(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def get_safe_value(self, default=None):</span>
<span class="gi">+        wrapped_value = self._wrapped_value.get_safe_value(default)</span>
<span class="gi">+        if isinstance(wrapped_value, tuple):</span>
<span class="gi">+            return &#39;.&#39;.join(str(v) for v in wrapped_value)</span>
<span class="gi">+        return default</span>
<span class="gh">diff --git a/jedi/inference/gradual/type_var.py b/jedi/inference/gradual/type_var.py</span>
<span class="gh">index 207439f1..de222ee3 100644</span>
<span class="gd">--- a/jedi/inference/gradual/type_var.py</span>
<span class="gi">+++ b/jedi/inference/gradual/type_var.py</span>
<span class="gu">@@ -4,7 +4,17 @@ from jedi.inference.gradual.base import BaseTypingValue</span>


<span class="w"> </span>class TypeVarClass(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self._wrapped_value.py__name__()</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        return self._wrapped_value.infer_type_vars(value_set)</span>
<span class="gi">+</span>
<span class="gi">+    def infer_constraints(self, value_set):</span>
<span class="gi">+        return self._wrapped_value.infer_constraints(value_set)</span>
<span class="gi">+</span>
<span class="gi">+    def get_constraints(self):</span>
<span class="gi">+        return self._wrapped_value.get_constraints()</span>


<span class="w"> </span>class TypeVar(BaseTypingValue):
<span class="gu">@@ -31,6 +41,40 @@ class TypeVar(BaseTypingValue):</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.py__name__())

<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self._var_name</span>
<span class="gi">+</span>
<span class="gi">+    def infer_type_vars(self, value_set):</span>
<span class="gi">+        return {self._var_name: value_set}</span>
<span class="gi">+</span>
<span class="gi">+    def infer_constraints(self, value_set):</span>
<span class="gi">+        constraints = self.get_constraints()</span>
<span class="gi">+        if constraints:</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                value.infer_constraints(value_set)</span>
<span class="gi">+                for value in constraints</span>
<span class="gi">+            )</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def get_constraints(self):</span>
<span class="gi">+        if self._constraints_lazy_values:</span>
<span class="gi">+            return ValueSet.from_sets(</span>
<span class="gi">+                lazy_value.infer() for lazy_value in self._constraints_lazy_values</span>
<span class="gi">+            )</span>
<span class="gi">+        elif self._bound_lazy_value is not None:</span>
<span class="gi">+            return self._bound_lazy_value.infer()</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    def is_covariant(self):</span>
<span class="gi">+        if self._covariant_lazy_value is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return self._covariant_lazy_value.infer().get_safe_value(default=False)</span>
<span class="gi">+</span>
<span class="gi">+    def is_contravariant(self):</span>
<span class="gi">+        if self._contravariant_lazy_value is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return self._contravariant_lazy_value.infer().get_safe_value(default=False)</span>
<span class="gi">+</span>

<span class="w"> </span>class TypeWrapper(ValueWrapper):

<span class="gh">diff --git a/jedi/inference/gradual/typeshed.py b/jedi/inference/gradual/typeshed.py</span>
<span class="gh">index 002795c5..94086d1e 100644</span>
<span class="gd">--- a/jedi/inference/gradual/typeshed.py</span>
<span class="gi">+++ b/jedi/inference/gradual/typeshed.py</span>
<span class="gu">@@ -22,7 +22,19 @@ def _create_stub_map(directory_path_info):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a mapping of an importable name in Python to a stub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stub_map = {}</span>
<span class="gi">+    for root, dirs, files in os.walk(directory_path_info.path):</span>
<span class="gi">+        for file in files:</span>
<span class="gi">+            if file.endswith(&#39;.pyi&#39;):</span>
<span class="gi">+                module_name = file[:-4]  # Remove .pyi extension</span>
<span class="gi">+                if root != directory_path_info.path:</span>
<span class="gi">+                    relative_path = os.path.relpath(root, directory_path_info.path)</span>
<span class="gi">+                    module_name = f&quot;{relative_path.replace(os.path.sep, &#39;.&#39;)}.{module_name}&quot;</span>
<span class="gi">+                stub_map[module_name] = PathInfo(</span>
<span class="gi">+                    path=os.path.join(root, file),</span>
<span class="gi">+                    is_third_party=directory_path_info.is_third_party</span>
<span class="gi">+                )</span>
<span class="gi">+    return stub_map</span>


<span class="w"> </span>_version_cache: Dict[Tuple[int, int], Mapping[str, PathInfo]] = {}
<span class="gu">@@ -32,7 +44,27 @@ def _cache_stub_file_map(version_info):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a map of an importable name in Python to a stub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache_key = version_info[:2]</span>
<span class="gi">+    if cache_key in _version_cache:</span>
<span class="gi">+        return _version_cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+    typeshed_path = Path(TYPESHED_PATH)</span>
<span class="gi">+    stub_map = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Standard library stubs</span>
<span class="gi">+    stdlib_path = typeshed_path / &#39;stdlib&#39;</span>
<span class="gi">+    stub_map.update(_create_stub_map(PathInfo(stdlib_path, False)))</span>
<span class="gi">+</span>
<span class="gi">+    # Third-party stubs</span>
<span class="gi">+    third_party_path = typeshed_path / &#39;stubs&#39;</span>
<span class="gi">+    stub_map.update(_create_stub_map(PathInfo(third_party_path, True)))</span>
<span class="gi">+</span>
<span class="gi">+    # Add Django stubs if available</span>
<span class="gi">+    if DJANGO_INIT_PATH.exists():</span>
<span class="gi">+        stub_map[&#39;django&#39;] = PathInfo(DJANGO_INIT_PATH, True)</span>
<span class="gi">+</span>
<span class="gi">+    _version_cache[cache_key] = stub_map</span>
<span class="gi">+    return stub_map</span>


<span class="w"> </span>def _try_to_load_stub(inference_state, import_names, python_value_set,
<span class="gu">@@ -43,4 +75,34 @@ def _try_to_load_stub(inference_state, import_names, python_value_set,</span>
<span class="w"> </span>    This is modelled to work like &quot;PEP 561 -- Distributing and Packaging Type
<span class="w"> </span>    Information&quot;, see https://www.python.org/dev/peps/pep-0561.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stub_map = _cache_stub_file_map(inference_state.grammar.version_info)</span>
<span class="gi">+    path = None</span>
<span class="gi">+    for i in range(1, len(import_names) + 1):</span>
<span class="gi">+        path = stub_map.get(&#39;.&#39;.join(import_names[:i]))</span>
<span class="gi">+        if path is not None:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    stub_module_node = inference_state.parse(</span>
<span class="gi">+        path=path.path,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        use_latest_grammar=True</span>
<span class="gi">+    )</span>
<span class="gi">+    stub_module_value = StubModuleValue(</span>
<span class="gi">+        inference_state,</span>
<span class="gi">+        stub_module_node,</span>
<span class="gi">+        path.path</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if import_names == [&#39;typing&#39;]:</span>
<span class="gi">+        stub_module_value = TypingModuleWrapper(stub_module_value)</span>
<span class="gi">+</span>
<span class="gi">+    if parent_module_value is None:</span>
<span class="gi">+        return ValueSet([stub_module_value])</span>
<span class="gi">+</span>
<span class="gi">+    non_stubs = python_value_set</span>
<span class="gi">+    if non_stubs:</span>
<span class="gi">+        return ValueSet([stub_module_value]) | non_stubs</span>
<span class="gi">+    return ValueSet([stub_module_value])</span>
<span class="gh">diff --git a/jedi/inference/gradual/typing.py b/jedi/inference/gradual/typing.py</span>
<span class="gh">index c13d5322..856af2a6 100644</span>
<span class="gd">--- a/jedi/inference/gradual/typing.py</span>
<span class="gi">+++ b/jedi/inference/gradual/typing.py</span>
<span class="gu">@@ -71,18 +71,33 @@ class Callable(BaseTypingInstance):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>            def x() -&gt; Callable[[Callable[..., _T]], _T]: ...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get the return type from the Callable&#39;s type parameters</span>
<span class="gi">+        type_params = self.get_type_parameters()</span>
<span class="gi">+        if len(type_params) &gt;= 2:</span>
<span class="gi">+            return_type = type_params[-1]</span>
<span class="gi">+            return return_type.execute_annotation()</span>
<span class="gi">+        return NO_VALUES</span>


<span class="w"> </span>class Tuple(BaseTypingInstance):
<span class="gd">-    pass</span>
<span class="gi">+    def get_type_parameters(self):</span>
<span class="gi">+        return self._class_value.get_type_parameters()</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index):</span>
<span class="gi">+        type_params = self.get_type_parameters()</span>
<span class="gi">+        if type_params:</span>
<span class="gi">+            if isinstance(index, int) and index &lt; len(type_params):</span>
<span class="gi">+                return type_params[index].execute_annotation()</span>
<span class="gi">+        return NO_VALUES</span>


<span class="w"> </span>class Generic(BaseTypingInstance):
<span class="gi">+    # No specific implementation needed</span>
<span class="w"> </span>    pass


<span class="w"> </span>class Protocol(BaseTypingInstance):
<span class="gi">+    # No specific implementation needed</span>
<span class="w"> </span>    pass


<span class="gh">diff --git a/jedi/inference/gradual/utils.py b/jedi/inference/gradual/utils.py</span>
<span class="gh">index 70d131f0..18d9a4e8 100644</span>
<span class="gd">--- a/jedi/inference/gradual/utils.py</span>
<span class="gi">+++ b/jedi/inference/gradual/utils.py</span>
<span class="gu">@@ -8,4 +8,33 @@ def load_proper_stub_module(inference_state, grammar, file_io, import_names,</span>
<span class="w"> </span>    This function is given a random .pyi file and should return the proper
<span class="w"> </span>    module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check if the file is from typeshed</span>
<span class="gi">+    if TYPESHED_PATH in file_io.path:</span>
<span class="gi">+        # If it&#39;s from typeshed, create and return a stub module</span>
<span class="gi">+        return create_stub_module(</span>
<span class="gi">+            inference_state,</span>
<span class="gi">+            grammar,</span>
<span class="gi">+            file_io,</span>
<span class="gi">+            import_names,</span>
<span class="gi">+            module_node</span>
<span class="gi">+        )</span>
<span class="gi">+    </span>
<span class="gi">+    # If it&#39;s not from typeshed, it&#39;s a user-defined stub</span>
<span class="gi">+    # Create a new stub module</span>
<span class="gi">+    stub_module = inference_state.new_stub_module(</span>
<span class="gi">+        import_names,</span>
<span class="gi">+        module_node,</span>
<span class="gi">+        file_io.path</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Parse the .pyi file</span>
<span class="gi">+    parsed_module = grammar.parse(</span>
<span class="gi">+        path=file_io.path,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        use_latest_grammar=True</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Update the stub module with the parsed content</span>
<span class="gi">+    stub_module.update(parsed_module)</span>
<span class="gi">+    </span>
<span class="gi">+    return stub_module</span>
<span class="gh">diff --git a/jedi/inference/helpers.py b/jedi/inference/helpers.py</span>
<span class="gh">index 528831da..ad194efc 100644</span>
<span class="gd">--- a/jedi/inference/helpers.py</span>
<span class="gi">+++ b/jedi/inference/helpers.py</span>
<span class="gu">@@ -11,7 +11,11 @@ def deep_ast_copy(obj):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Much, much faster than copy.deepcopy, but just for parser tree nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, tree.BaseNode):</span>
<span class="gi">+        new_obj = copy.copy(obj)</span>
<span class="gi">+        new_obj.children = [deep_ast_copy(child) for child in obj.children]</span>
<span class="gi">+        return new_obj</span>
<span class="gi">+    return obj</span>


<span class="w"> </span>def infer_call_of_leaf(context, leaf, cut_own_trailer=False):
<span class="gu">@@ -33,8 +37,26 @@ def infer_call_of_leaf(context, leaf, cut_own_trailer=False):</span>
<span class="w"> </span>      - infer the type of ``bar`` to be able to jump to the definition of foo
<span class="w"> </span>    The option ``cut_own_trailer`` must be set to true for the second purpose.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    trailer = leaf.parent</span>
<span class="gi">+    if trailer.type == &#39;fstring&#39;:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    while trailer.parent is not None:</span>
<span class="gi">+        if trailer.type == &#39;trailer&#39; and trailer.children[0] == &#39;.&#39;:</span>
<span class="gi">+            cut_own_trailer = False</span>
<span class="gi">+        new_trailer = trailer.parent</span>
<span class="gi">+        if new_trailer.type not in (&#39;power&#39;, &#39;atom_expr&#39;, &#39;trailer&#39;):</span>
<span class="gi">+            break</span>
<span class="gi">+        trailer = new_trailer</span>
<span class="gi">+</span>
<span class="gi">+    if trailer.type in (&#39;power&#39;, &#39;atom_expr&#39;):</span>
<span class="gi">+        trailer = trailer.children[-1]</span>
<span class="gi">+</span>
<span class="gi">+    if cut_own_trailer and trailer.type == &#39;trailer&#39;:</span>
<span class="gi">+        trailer = trailer.parent.children[-2]</span>
<span class="gi">+</span>
<span class="gi">+    return context.new_context(deep_ast_copy(trailer))</span>


<span class="w"> </span>class SimpleGetItemNotFound(Exception):
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Exception raised when a simple get item operation fails.&quot;&quot;&quot;</span>
<span class="gh">diff --git a/jedi/inference/imports.py b/jedi/inference/imports.py</span>
<span class="gh">index 960fd535..041933ec 100644</span>
<span class="gd">--- a/jedi/inference/imports.py</span>
<span class="gi">+++ b/jedi/inference/imports.py</span>
<span class="gu">@@ -41,7 +41,22 @@ def _level_to_base_import_path(project_path, directory, level):</span>
<span class="w"> </span>    import .....foo), we can still try our best to help the user for
<span class="w"> </span>    completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if level &lt;= 0:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    base_path = os.path.abspath(directory)</span>
<span class="gi">+    for _ in range(level - 1):</span>
<span class="gi">+        base_path = os.path.dirname(base_path)</span>
<span class="gi">+</span>
<span class="gi">+    if base_path == project_path:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    base_import_path = []</span>
<span class="gi">+    while base_path != project_path:</span>
<span class="gi">+        base_path, name = os.path.split(base_path)</span>
<span class="gi">+        base_import_path.insert(0, name)</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(base_import_path), os.path.join(project_path, *base_import_path)</span>


<span class="w"> </span>class Importer:
<span class="gu">@@ -98,31 +113,89 @@ class Importer:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def _str_import_path(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the import path as pure strings instead of `Name`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [str(name) if isinstance(name, tree.Name) else name</span>
<span class="gi">+                for name in self.import_path]</span>

<span class="w"> </span>    def _get_module_names(self, search_path=None, in_module=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the names of all modules in the search_path. This means file names
<span class="w"> </span>        and not names defined in the files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if search_path is None:</span>
<span class="gi">+            search_path = self._inference_state.get_sys_path()</span>
<span class="gi">+</span>
<span class="gi">+        names = []</span>
<span class="gi">+        for path in search_path:</span>
<span class="gi">+            try:</span>
<span class="gi">+                contents = os.listdir(path)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # Invalid or non-existent directory</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for filename in contents:</span>
<span class="gi">+                name, ext = os.path.splitext(filename)</span>
<span class="gi">+                if ext in (&#39;.py&#39;, &#39;.pyi&#39;) or (ext == &#39;&#39; and os.path.isdir(os.path.join(path, filename))):</span>
<span class="gi">+                    names.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        return list(set(names))  # Remove duplicates</span>

<span class="w"> </span>    def completion_names(self, inference_state, only_modules=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param only_modules: Indicates wheter it&#39;s possible to import a
<span class="w"> </span>            definition that is not defined in a module.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._infer_possible:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        names = []</span>
<span class="gi">+        if self.import_path:</span>
<span class="gi">+            # Module is already known, get the proper completion</span>
<span class="gi">+            module = self.follow().get_values()</span>
<span class="gi">+            if not module:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+            if only_modules:</span>
<span class="gi">+                names = [SubModuleName(module[0], name)</span>
<span class="gi">+                         for name in self._get_module_names(in_module=module[0])]</span>
<span class="gi">+            else:</span>
<span class="gi">+                for c in module:</span>
<span class="gi">+                    names += c.get_defined_names()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Search for modules in the search_path</span>
<span class="gi">+            names = [ImportName(self._inference_state, name)</span>
<span class="gi">+                     for name in self._get_module_names()]</span>
<span class="gi">+</span>
<span class="gi">+        return names</span>


<span class="w"> </span>@plugin_manager.decorate()
<span class="w"> </span>@import_module_decorator
<span class="gd">-def import_module(inference_state, import_names, parent_module_value, sys_path</span>
<span class="gd">-    ):</span>
<span class="gi">+def import_module(inference_state, import_names, parent_module_value, sys_path):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This method is very similar to importlib&#39;s `_gcd_import`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if import_names[0] in inference_state.stub_module_cache:</span>
<span class="gi">+        return inference_state.stub_module_cache[import_names[0]]</span>
<span class="gi">+</span>
<span class="gi">+    module_name = &#39;.&#39;.join(import_names)</span>
<span class="gi">+    if parent_module_value is None:</span>
<span class="gi">+        # Load the module from sys.path</span>
<span class="gi">+        module = inference_state.compiled_subprocess.get_module(module_name)</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            # If it&#39;s not a compiled module, try to find a source module</span>
<span class="gi">+            module = inference_state.parse_and_get_code(module_name)</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Load the module as an attribute of the parent module</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = parent_module_value.py__getattribute__(import_names[-1])</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    # Cache the module</span>
<span class="gi">+    inference_state.stub_module_cache[import_names[0]] = module</span>
<span class="gi">+    return module</span>


<span class="w"> </span>def load_module_from_path(inference_state, file_io, import_names=None,
<span class="gu">@@ -132,7 +205,32 @@ def load_module_from_path(inference_state, file_io, import_names=None,</span>
<span class="w"> </span>    here to ensure that a random path is still properly loaded into the Jedi
<span class="w"> </span>    module structure.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if import_names is None:</span>
<span class="gi">+        import_names = []</span>
<span class="gi">+    if is_package is None:</span>
<span class="gi">+        is_package = file_io.is_directory()</span>
<span class="gi">+</span>
<span class="gi">+    module_node = inference_state.parse(</span>
<span class="gi">+        file_io=file_io,</span>
<span class="gi">+        cache=True,</span>
<span class="gi">+        diff_cache=False,</span>
<span class="gi">+        cache_path=None</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if is_package:</span>
<span class="gi">+        folder_io = file_io</span>
<span class="gi">+    else:</span>
<span class="gi">+        folder_io = file_io.get_parent_folder()</span>
<span class="gi">+</span>
<span class="gi">+    module = create_stub_module(</span>
<span class="gi">+        inference_state,</span>
<span class="gi">+        &#39;.&#39;.join(import_names),</span>
<span class="gi">+        folder_io,</span>
<span class="gi">+        module_node,</span>
<span class="gi">+        is_package=is_package</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return module</span>


<span class="w"> </span>def iter_module_names(inference_state, module_context, search_path,
<span class="gu">@@ -141,4 +239,32 @@ def iter_module_names(inference_state, module_context, search_path,</span>
<span class="w"> </span>    Get the names of all modules in the search_path. This means file names
<span class="w"> </span>    and not names defined in the files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yielded = set()</span>
<span class="gi">+</span>
<span class="gi">+    # Add modules from the given search path</span>
<span class="gi">+    for name in _get_module_names(search_path):</span>
<span class="gi">+        if name not in yielded:</span>
<span class="gi">+            yielded.add(name)</span>
<span class="gi">+            yield module_cls(inference_state, name)</span>
<span class="gi">+</span>
<span class="gi">+    # Add builtin modules if requested</span>
<span class="gi">+    if add_builtin_modules:</span>
<span class="gi">+        for name in inference_state.compiled_subprocess.get_builtin_module_names():</span>
<span class="gi">+            if name not in yielded:</span>
<span class="gi">+                yielded.add(name)</span>
<span class="gi">+                yield module_cls(inference_state, name)</span>
<span class="gi">+</span>
<span class="gi">+def _get_module_names(search_path):</span>
<span class="gi">+    names = []</span>
<span class="gi">+    for path in search_path:</span>
<span class="gi">+        try:</span>
<span class="gi">+            contents = os.listdir(path)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        for filename in contents:</span>
<span class="gi">+            name, ext = os.path.splitext(filename)</span>
<span class="gi">+            if ext in (&#39;.py&#39;, &#39;.pyi&#39;) or (ext == &#39;&#39; and os.path.isdir(os.path.join(path, filename))):</span>
<span class="gi">+                names.append(name)</span>
<span class="gi">+</span>
<span class="gi">+    return list(set(names))  # Remove duplicates</span>
<span class="gh">diff --git a/jedi/inference/names.py b/jedi/inference/names.py</span>
<span class="gh">index 3c2fd660..ba2e7b7d 100644</span>
<span class="gd">--- a/jedi/inference/names.py</span>
<span class="gi">+++ b/jedi/inference/names.py</span>
<span class="gu">@@ -34,7 +34,13 @@ class AbstractNameDefinition:</span>
<span class="w"> </span>        Returns either None or the value that is public and qualified. Won&#39;t
<span class="w"> </span>        return a function, because a name in a function is never public.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.parent_context is None or self.is_value_name is False:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+        value = self.parent_context.get_value()</span>
<span class="gi">+        if value.is_module() or value.is_class():</span>
<span class="gi">+            return value</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class AbstractArbitraryName(AbstractNameDefinition):
<span class="gu">@@ -88,7 +94,27 @@ class TreeNameDefinition(AbstractTreeName):</span>

<span class="w"> </span>            [(slice(1, -1), abc_node)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from jedi.parser_utils import get_parent_scope</span>
<span class="gi">+        indexes = []</span>
<span class="gi">+        node = self.tree_name.parent</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            if node.type == &#39;testlist_star_expr&#39;:</span>
<span class="gi">+                for i, child in enumerate(node.children):</span>
<span class="gi">+                    if child == self.tree_name:</span>
<span class="gi">+                        indexes.insert(0, (i, node))</span>
<span class="gi">+                        break</span>
<span class="gi">+                    elif child.type == &#39;atom&#39; and self.tree_name in child.children:</span>
<span class="gi">+                        indexes.insert(0, (i, node))</span>
<span class="gi">+                        break</span>
<span class="gi">+            elif node.type == &#39;atom&#39; and node.children[0] == &#39;(&#39;:</span>
<span class="gi">+                indexes.insert(0, (0, node))</span>
<span class="gi">+            elif node.type in (&#39;expr_stmt&#39;, &#39;funcdef&#39;, &#39;classdef&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+        if len(indexes) &gt; 1 and self.tree_name.type == &#39;star_expr&#39;:</span>
<span class="gi">+            return [(slice(indexes[-1][0], -1), indexes[-1][1])]</span>
<span class="gi">+        return indexes</span>


<span class="w"> </span>class _ParamMixin:
<span class="gu">@@ -107,7 +133,7 @@ class ParamNameInterface(_ParamMixin):</span>
<span class="w"> </span>        For now however it exists to avoid infering params when we don&#39;t really
<span class="w"> </span>        need them (e.g. when we can just instead use annotations.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class BaseTreeParamName(ParamNameInterface, AbstractTreeName):
<span class="gh">diff --git a/jedi/inference/param.py b/jedi/inference/param.py</span>
<span class="gh">index 3880af71..ad7e6939 100644</span>
<span class="gd">--- a/jedi/inference/param.py</span>
<span class="gi">+++ b/jedi/inference/param.py</span>
<span class="gu">@@ -40,7 +40,33 @@ def get_executed_param_names_and_issues(function_value, arguments):</span>
<span class="w"> </span>        c, &amp; d will have their values (42, &#39;c&#39; and &#39;d&#39; respectively) included.
<span class="w"> </span>      - a list with a single entry about the lack of a value for `b`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    executed_param_names = []</span>
<span class="gi">+    issues = []</span>
<span class="gi">+    </span>
<span class="gi">+    param_names = function_value.get_param_names()</span>
<span class="gi">+    argument_iterator = PushBackIterator(arguments.unpack())</span>
<span class="gi">+    </span>
<span class="gi">+    for param in param_names:</span>
<span class="gi">+        param_node = param.tree_name.parent</span>
<span class="gi">+        try:</span>
<span class="gi">+            actual_value = next(argument_iterator)</span>
<span class="gi">+            lazy_value = LazyTreeValue(function_value.inference_state, actual_value)</span>
<span class="gi">+            executed_param_names.append(ExecutedParamName(function_value, arguments, param_node, lazy_value))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            # No more arguments, check if it&#39;s a default parameter</span>
<span class="gi">+            if param.default_node is not None:</span>
<span class="gi">+                lazy_value = LazyTreeValue(function_value.inference_state, param.default_node)</span>
<span class="gi">+                executed_param_names.append(ExecutedParamName(function_value, arguments, param_node, lazy_value, is_default=True))</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Missing required argument</span>
<span class="gi">+                executed_param_names.append(ExecutedParamName(function_value, arguments, param_node, LazyUnknownValue()))</span>
<span class="gi">+                issues.append(analysis.ParamIssue(function_value, param))</span>
<span class="gi">+    </span>
<span class="gi">+    # Check for extra arguments</span>
<span class="gi">+    for extra_arg in argument_iterator:</span>
<span class="gi">+        issues.append(analysis.ExtraArgumentIssue(function_value, extra_arg))</span>
<span class="gi">+    </span>
<span class="gi">+    return executed_param_names, issues</span>


<span class="w"> </span>def get_executed_param_names(function_value, arguments):
<span class="gu">@@ -61,4 +87,5 @@ def get_executed_param_names(function_value, arguments):</span>
<span class="w"> </span>    for each parameter a, b, c &amp; d; the entries for a, c, &amp; d will have their
<span class="w"> </span>    values (42, &#39;c&#39; and &#39;d&#39; respectively) included.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    executed_param_names, _ = get_executed_param_names_and_issues(function_value, arguments)</span>
<span class="gi">+    return executed_param_names</span>
<span class="gh">diff --git a/jedi/inference/recursion.py b/jedi/inference/recursion.py</span>
<span class="gh">index 69b2848b..f8386294 100644</span>
<span class="gd">--- a/jedi/inference/recursion.py</span>
<span class="gi">+++ b/jedi/inference/recursion.py</span>
<span class="gu">@@ -51,6 +51,15 @@ class RecursionDetector:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.pushed_nodes = []

<span class="gi">+    def push_node(self, node):</span>
<span class="gi">+        self.pushed_nodes.append(node)</span>
<span class="gi">+</span>
<span class="gi">+    def pop_node(self):</span>
<span class="gi">+        return self.pushed_nodes.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def node_count(self):</span>
<span class="gi">+        return len(self.pushed_nodes)</span>
<span class="gi">+</span>

<span class="w"> </span>@contextmanager
<span class="w"> </span>def execution_allowed(inference_state, node):
<span class="gu">@@ -58,7 +67,16 @@ def execution_allowed(inference_state, node):</span>
<span class="w"> </span>    A decorator to detect recursions in statements. In a recursion a statement
<span class="w"> </span>    at the same place, in the same module may not be executed two times.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    detector = inference_state.recursion_detector</span>
<span class="gi">+    if detector.node_count() &gt;= recursion_limit or node in detector.pushed_nodes:</span>
<span class="gi">+        debug.warning(&#39;Recursion detected, returning no values for %s&#39; % node)</span>
<span class="gi">+        yield NO_VALUES</span>
<span class="gi">+    else:</span>
<span class="gi">+        detector.push_node(node)</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            detector.pop_node()</span>


<span class="w"> </span>class ExecutionRecursionDetector:
<span class="gu">@@ -72,3 +90,43 @@ class ExecutionRecursionDetector:</span>
<span class="w"> </span>        self._parent_execution_funcs = []
<span class="w"> </span>        self._funcdef_execution_counts = {}
<span class="w"> </span>        self._execution_count = 0
<span class="gi">+</span>
<span class="gi">+    def push_execution(self, execution):</span>
<span class="gi">+        funcdef = execution.tree_node</span>
<span class="gi">+        self._recursion_level += 1</span>
<span class="gi">+        self._execution_count += 1</span>
<span class="gi">+        self._funcdef_execution_counts[funcdef] = self._funcdef_execution_counts.get(funcdef, 0) + 1</span>
<span class="gi">+        self._parent_execution_funcs.append(funcdef)</span>
<span class="gi">+</span>
<span class="gi">+    def pop_execution(self):</span>
<span class="gi">+        self._recursion_level -= 1</span>
<span class="gi">+        self._parent_execution_funcs.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def execution_allowed(self):</span>
<span class="gi">+        if self._execution_count &gt;= total_function_execution_limit:</span>
<span class="gi">+            debug.warning(&#39;Reached total function execution limit&#39;)</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        current_func = self._parent_execution_funcs[-1] if self._parent_execution_funcs else None</span>
<span class="gi">+        if current_func:</span>
<span class="gi">+            if self._funcdef_execution_counts.get(current_func, 0) &gt; per_function_execution_limit:</span>
<span class="gi">+                debug.warning(f&#39;Reached per-function execution limit for {current_func}&#39;)</span>
<span class="gi">+                return False</span>
<span class="gi">+            </span>
<span class="gi">+            recursion_count = self._parent_execution_funcs.count(current_func)</span>
<span class="gi">+            if recursion_count &gt; per_function_recursion_limit:</span>
<span class="gi">+                debug.warning(f&#39;Reached per-function recursion limit for {current_func}&#39;)</span>
<span class="gi">+                return False</span>
<span class="gi">+        </span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def execution_check(self, execution):</span>
<span class="gi">+        self.push_execution(execution)</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not self.execution_allowed():</span>
<span class="gi">+                yield False</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield True</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.pop_execution()</span>
<span class="gh">diff --git a/jedi/inference/references.py b/jedi/inference/references.py</span>
<span class="gh">index d77bb44e..3d56da3f 100644</span>
<span class="gd">--- a/jedi/inference/references.py</span>
<span class="gi">+++ b/jedi/inference/references.py</span>
<span class="gu">@@ -30,4 +30,70 @@ def get_module_contexts_containing_name(inference_state, module_contexts,</span>
<span class="w"> </span>    :param limit_reduction: Divides the limits on opening/parsing files by this
<span class="w"> </span>        factor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def check_directory(folder_io):</span>
<span class="gi">+        try:</span>
<span class="gi">+            file_names = folder_io.list()</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for name in file_names:</span>
<span class="gi">+            if name in _IGNORE_FOLDERS:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            path = os.path.join(folder_io.path, name)</span>
<span class="gi">+            if os.path.isdir(path):</span>
<span class="gi">+                yield from check_directory(FolderIO(path))</span>
<span class="gi">+            elif name.endswith(&#39;.py&#39;):</span>
<span class="gi">+                yield path</span>
<span class="gi">+</span>
<span class="gi">+    def check_python_file(path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            file_io = KnownContentFileIO(path, inference_state.get_cached_code(path))</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = load_module_from_path(inference_state, file_io)</span>
<span class="gi">+        except:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if module is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            code = python_bytes_to_unicode(file_io.read())</span>
<span class="gi">+        except:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if name not in code:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        module_context = module.as_context()</span>
<span class="gi">+        filter_ = ParserTreeFilter(module_context)</span>
<span class="gi">+        names = filter_.get(name)</span>
<span class="gi">+        if names:</span>
<span class="gi">+            return module_context</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    searched_files = 0</span>
<span class="gi">+    parsed_files = 0</span>
<span class="gi">+    found = []</span>
<span class="gi">+    for module_context in module_contexts:</span>
<span class="gi">+        if module_context.is_stub():</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        folder_io = FolderIO(os.path.dirname(module_context.py__file__()))</span>
<span class="gi">+        for path in check_directory(folder_io):</span>
<span class="gi">+            if searched_files &gt;= _OPENED_FILE_LIMIT // limit_reduction:</span>
<span class="gi">+                return found</span>
<span class="gi">+</span>
<span class="gi">+            searched_files += 1</span>
<span class="gi">+            result = check_python_file(path)</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                found.append(result)</span>
<span class="gi">+                parsed_files += 1</span>
<span class="gi">+</span>
<span class="gi">+            if parsed_files &gt;= _PARSED_FILE_LIMIT // limit_reduction:</span>
<span class="gi">+                return found</span>
<span class="gi">+</span>
<span class="gi">+    return found</span>
<span class="gh">diff --git a/jedi/inference/signature.py b/jedi/inference/signature.py</span>
<span class="gh">index eb8704ba..cc821d34 100644</span>
<span class="gd">--- a/jedi/inference/signature.py</span>
<span class="gi">+++ b/jedi/inference/signature.py</span>
<span class="gu">@@ -5,7 +5,11 @@ from jedi import parser_utils</span>


<span class="w"> </span>class _SignatureMixin:
<span class="gd">-    pass</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [param.name for param in self.get_parameters()]</span>
<span class="gi">+</span>
<span class="gi">+    def bind(self):</span>
<span class="gi">+        return SignatureWrapper(self)</span>


<span class="w"> </span>class AbstractSignature(_SignatureMixin):
<span class="gu">@@ -13,12 +17,18 @@ class AbstractSignature(_SignatureMixin):</span>
<span class="w"> </span>    def __init__(self, value, is_bound=False):
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.is_bound = is_bound
<span class="gi">+        self._function_value = None</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.value is self._function_value:
<span class="w"> </span>            return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.value)
<span class="gd">-        return &#39;&lt;%s: %s, %s&gt;&#39; % (self.__class__.__name__, self.value, self.</span>
<span class="gd">-            _function_value)</span>
<span class="gi">+        return &#39;&lt;%s: %s, %s&gt;&#39; % (self.__class__.__name__, self.value, self._function_value)</span>
<span class="gi">+</span>
<span class="gi">+    def get_parameters(self):</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement this method&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_annotation(self):</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement this method&quot;)</span>


<span class="w"> </span>class TreeSignature(AbstractSignature):
<span class="gu">@@ -27,14 +37,25 @@ class TreeSignature(AbstractSignature):</span>
<span class="w"> </span>        super().__init__(value, is_bound)
<span class="w"> </span>        self._function_value = function_value or value

<span class="gi">+    def get_parameters(self):</span>
<span class="gi">+        return self.value.get_params()</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_annotation(self):</span>
<span class="gi">+        return self.value.annotation</span>
<span class="gi">+</span>

<span class="w"> </span>class BuiltinSignature(AbstractSignature):

<span class="gd">-    def __init__(self, value, return_string, function_value=None, is_bound=</span>
<span class="gd">-        False):</span>
<span class="gi">+    def __init__(self, value, return_string, function_value=None, is_bound=False):</span>
<span class="w"> </span>        super().__init__(value, is_bound)
<span class="w"> </span>        self._return_string = return_string
<span class="gd">-        self.__function_value = function_value</span>
<span class="gi">+        self._function_value = function_value</span>
<span class="gi">+</span>
<span class="gi">+    def get_parameters(self):</span>
<span class="gi">+        return [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD) for name in self.value.__code__.co_varnames[:self.value.__code__.co_argcount]]</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_annotation(self):</span>
<span class="gi">+        return self._return_string</span>


<span class="w"> </span>class SignatureWrapper(_SignatureMixin):
<span class="gu">@@ -44,3 +65,12 @@ class SignatureWrapper(_SignatureMixin):</span>

<span class="w"> </span>    def __getattr__(self, name):
<span class="w"> </span>        return getattr(self._wrapped_signature, name)
<span class="gi">+</span>
<span class="gi">+    def get_parameters(self):</span>
<span class="gi">+        params = self._wrapped_signature.get_parameters()</span>
<span class="gi">+        if self._wrapped_signature.is_bound and params:</span>
<span class="gi">+            return params[1:]  # Remove &#39;self&#39; parameter for bound methods</span>
<span class="gi">+        return params</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_annotation(self):</span>
<span class="gi">+        return self._wrapped_signature.get_return_annotation()</span>
<span class="gh">diff --git a/jedi/inference/syntax_tree.py b/jedi/inference/syntax_tree.py</span>
<span class="gh">index 6868286f..6d2458f1 100644</span>
<span class="gd">--- a/jedi/inference/syntax_tree.py</span>
<span class="gi">+++ b/jedi/inference/syntax_tree.py</span>
<span class="gu">@@ -43,14 +43,22 @@ def _limit_value_infers(func):</span>
<span class="w"> </span>    I&#39;m still not sure this is the way to go, but it looks okay for now and we
<span class="w"> </span>    can still go anther way in the future. Tests are there. ~ dave
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        inference_state = args[0].inference_state</span>
<span class="gi">+        with recursion.inference_recursion_detector(inference_state) as recursion_detector:</span>
<span class="gi">+            if recursion_detector.push_inference():</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def _infer_node_if_inferred(context, element):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    TODO This function is temporary: Merge with infer_node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if element.type in (&#39;name&#39;, &#39;atom_expr&#39;, &#39;power&#39;):</span>
<span class="gi">+        return context.infer_node(element)</span>
<span class="gi">+    return infer_node(context, element)</span>


<span class="w"> </span>def infer_atom(context, atom):
<span class="gu">@@ -59,7 +67,19 @@ def infer_atom(context, atom):</span>
<span class="w"> </span>    generate the node (because it has just one child). In that case an atom
<span class="w"> </span>    might be a name or a literal as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if atom.type == &#39;atom&#39;:</span>
<span class="gi">+        first_child = atom.children[0]</span>
<span class="gi">+        if first_child.type in (&#39;string&#39;, &#39;number&#39;, &#39;keyword&#39;):</span>
<span class="gi">+            return infer_node(context, first_child)</span>
<span class="gi">+        elif first_child == &#39;[&#39;:</span>
<span class="gi">+            return iterable.infer_list(context, atom)</span>
<span class="gi">+        elif first_child == &#39;{&#39;:</span>
<span class="gi">+            return iterable.infer_dict(context, atom)</span>
<span class="gi">+        elif first_child == &#39;(&#39;:</span>
<span class="gi">+            return iterable.infer_tuple(context, atom)</span>
<span class="gi">+    elif atom.type in (&#39;name&#39;, &#39;number&#39;, &#39;string&#39;, &#39;keyword&#39;):</span>
<span class="gi">+        return infer_node(context, atom)</span>
<span class="gi">+    return NO_VALUES</span>


<span class="w"> </span>@debug.increase_indent
<span class="gu">@@ -78,7 +98,25 @@ def _infer_expr_stmt(context, stmt, seek_name=None):</span>

<span class="w"> </span>    :param stmt: A `tree.ExprStmt`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def check_setitem(stmt):</span>
<span class="gi">+        atom_expr = stmt.children[0]</span>
<span class="gi">+        if atom_expr.type == &#39;atom_expr&#39; and atom_expr.children[-1].type == &#39;trailer&#39;:</span>
<span class="gi">+            trailer = atom_expr.children[-1]</span>
<span class="gi">+            if trailer.children[0] == &#39;[&#39; and trailer.children[-1] == &#39;]&#39;:</span>
<span class="gi">+                return context.infer_node(atom_expr)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if stmt.type == &#39;expr_stmt&#39;:</span>
<span class="gi">+        first_child = stmt.children[0]</span>
<span class="gi">+        if first_child.type == &#39;name&#39;:</span>
<span class="gi">+            value_set = context.infer_node(stmt.children[2])</span>
<span class="gi">+            if seek_name is None or seek_name == first_child.value:</span>
<span class="gi">+                return value_set</span>
<span class="gi">+        elif first_child.type == &#39;testlist_star_expr&#39;:</span>
<span class="gi">+            return _infer_assign_tuple(context, first_child, stmt.children[2], seek_name)</span>
<span class="gi">+        elif check_setitem(stmt):</span>
<span class="gi">+            return check_setitem(stmt)</span>
<span class="gi">+    return NO_VALUES</span>


<span class="w"> </span>@iterator_to_value_set
<span class="gu">@@ -86,7 +124,17 @@ def infer_factor(value_set, operator):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Calculates `+`, `-`, `~` and `not` prefixes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for value in value_set:</span>
<span class="gi">+        if operator == &#39;+&#39;:</span>
<span class="gi">+            yield value</span>
<span class="gi">+        elif operator == &#39;-&#39;:</span>
<span class="gi">+            if is_number(value):</span>
<span class="gi">+                yield value.negate()</span>
<span class="gi">+        elif operator == &#39;~&#39;:</span>
<span class="gi">+            if is_number(value):</span>
<span class="gi">+                yield value.bitwise_not()</span>
<span class="gi">+        elif operator == &#39;not&#39;:</span>
<span class="gi">+            yield compiled.builtin_from_name(value.inference_state, &#39;bool&#39;)</span>


<span class="w"> </span>@inference_state_method_cache()
<span class="gu">@@ -95,14 +143,32 @@ def _apply_decorators(context, node):</span>
<span class="w"> </span>    Returns the function, that should to be executed in the end.
<span class="w"> </span>    This is also the places where the decorators are processed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.type != &#39;funcdef&#39;:</span>
<span class="gi">+        return context.infer_node(node)</span>
<span class="gi">+</span>
<span class="gi">+    decorators = node.get_decorators()</span>
<span class="gi">+    if not decorators:</span>
<span class="gi">+        return context.infer_node(node)</span>
<span class="gi">+</span>
<span class="gi">+    values = context.infer_node(node)</span>
<span class="gi">+    for decorator in reversed(decorators):</span>
<span class="gi">+        decorator_values = context.infer_node(decorator.children[1])</span>
<span class="gi">+        values = ValueSet.from_sets(</span>
<span class="gi">+            Decoratee(context, decorator_values, decorated_value).infer()</span>
<span class="gi">+            for decorated_value in values</span>
<span class="gi">+        )</span>
<span class="gi">+    return values</span>


<span class="w"> </span>def check_tuple_assignments(name, value_set):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if tuples are assigned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for value in value_set:</span>
<span class="gi">+        if value.is_compiled():</span>
<span class="gi">+            continue</span>
<span class="gi">+        if value.name.get_kind() == &#39;tuple&#39;:</span>
<span class="gi">+            yield from value.infer_subscript_by_index(name)</span>


<span class="w"> </span>class ContextualizedSubscriptListNode(ContextualizedNode):
<span class="gu">@@ -113,4 +179,27 @@ def _infer_subscript_list(context, index):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Handles slices in subscript nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if index == &#39;:&#39;:</span>
<span class="gi">+        return ValueSet([iterable.Slice(context.inference_state, None, None, None)])</span>
<span class="gi">+</span>
<span class="gi">+    elif index.type == &#39;subscript&#39; and not index.children[0] == &#39;.&#39;:</span>
<span class="gi">+        start, stop, step = None, None, None</span>
<span class="gi">+        for i, child in enumerate(index.children):</span>
<span class="gi">+            if child == &#39;:&#39;:</span>
<span class="gi">+                if i == 0:</span>
<span class="gi">+                    start = None</span>
<span class="gi">+                elif i == 1:</span>
<span class="gi">+                    stop = None</span>
<span class="gi">+                elif i == 2:</span>
<span class="gi">+                    step = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = context.infer_node(child)</span>
<span class="gi">+                if i == 0:</span>
<span class="gi">+                    start = result</span>
<span class="gi">+                elif i == 1:</span>
<span class="gi">+                    stop = result</span>
<span class="gi">+                elif i == 2:</span>
<span class="gi">+                    step = result</span>
<span class="gi">+        return ValueSet([iterable.Slice(context.inference_state, start, stop, step)])</span>
<span class="gi">+    else:</span>
<span class="gi">+        return context.infer_node(index)</span>
<span class="gh">diff --git a/jedi/inference/sys_path.py b/jedi/inference/sys_path.py</span>
<span class="gh">index a8e35f04..fa0f8cb0 100644</span>
<span class="gd">--- a/jedi/inference/sys_path.py</span>
<span class="gi">+++ b/jedi/inference/sys_path.py</span>
<span class="gu">@@ -23,12 +23,41 @@ def _paths_from_assignment(module_context, expr_stmt):</span>
<span class="w"> </span>    because it will only affect Jedi in very random situations and by adding
<span class="w"> </span>    more paths than necessary, it usually benefits the general user.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        expr_list = expr_stmt.children[2]</span>
<span class="gi">+        if expr_list.type != &#39;testlist&#39;:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        for expr in expr_list.children:</span>
<span class="gi">+            if expr.type == &#39;string&#39;:</span>
<span class="gi">+                path = get_str_or_none(expr)</span>
<span class="gi">+                if path is not None:</span>
<span class="gi">+                    paths.append(path)</span>
<span class="gi">+</span>
<span class="gi">+        return paths</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        return []</span>


<span class="w"> </span>def _paths_from_list_modifications(module_context, trailer1, trailer2):
<span class="w"> </span>    &quot;&quot;&quot; extract the path from either &quot;sys.path.append&quot; or &quot;sys.path.insert&quot; &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if trailer1.children[1].value == &#39;append&#39;:</span>
<span class="gi">+            arg = trailer2.children[1]  # The argument of append</span>
<span class="gi">+        elif trailer1.children[1].value == &#39;insert&#39;:</span>
<span class="gi">+            arg = trailer2.children[3]  # The second argument of insert</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        if arg.type == &#39;string&#39;:</span>
<span class="gi">+            path = get_str_or_none(arg)</span>
<span class="gi">+            if path is not None:</span>
<span class="gi">+                return [path]</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return []</span>


<span class="w"> </span>@inference_state_method_cache(default=[])
<span class="gu">@@ -36,18 +65,65 @@ def check_sys_path_modifications(module_context):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Detect sys.path modifications within module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def get_sys_path_powers(names):</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            power = name.parent.parent</span>
<span class="gi">+            if power.type == &#39;power&#39; and power.children[0].value == &#39;sys&#39;:</span>
<span class="gi">+                n = power.children[1].children[1]</span>
<span class="gi">+                if n.value == &#39;path&#39;:</span>
<span class="gi">+                    return name, power</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        path_powers = get_sys_path_powers(module_context.tree_node.get_used_names()[&#39;path&#39;])</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    added = []</span>
<span class="gi">+    for name, power in path_powers:</span>
<span class="gi">+        if power.parent.type == &#39;trailer&#39;:</span>
<span class="gi">+            trailer = power.parent</span>
<span class="gi">+            if trailer.children[1].value in [&#39;insert&#39;, &#39;append&#39;]:</span>
<span class="gi">+                added += _paths_from_list_modifications(</span>
<span class="gi">+                    module_context, trailer, trailer.get_next_sibling()</span>
<span class="gi">+                )</span>
<span class="gi">+        elif power.parent.type == &#39;atom_expr&#39;:</span>
<span class="gi">+            trailer = power.parent.children[-1]</span>
<span class="gi">+            if trailer.type == &#39;trailer&#39; and trailer.children[0] == &#39;[&#39;:</span>
<span class="gi">+                added += _paths_from_assignment(module_context, power.parent.parent)</span>
<span class="gi">+</span>
<span class="gi">+    return added</span>


<span class="w"> </span>def _get_buildout_script_paths(search_path: Path):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    if there is a &#39;buildout.cfg&#39; file in one of the parent directories of the</span>
<span class="gd">-    given module it will return a list of all files in the buildout bin</span>
<span class="gd">-    directory that look like python files.</span>
<span class="gi">+    If there is a &#39;buildout.cfg&#39; file in one of the parent directories of the</span>
<span class="gi">+    given module, it will return a list of all files in the buildout bin</span>
<span class="gi">+    directory that look like Python files.</span>

<span class="w"> </span>    :param search_path: absolute path to the module.
<span class="gi">+    :return: A list of paths to potential Python scripts in the buildout bin directory.</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buildout_file = &#39;buildout.cfg&#39;</span>
<span class="gi">+    limit = _BUILDOUT_PATH_INSERTION_LIMIT</span>
<span class="gi">+    current_path = search_path.resolve()</span>
<span class="gi">+    while limit &gt; 0:</span>
<span class="gi">+        buildout_cfg = current_path / buildout_file</span>
<span class="gi">+        if buildout_cfg.is_file():</span>
<span class="gi">+            bin_path = current_path / &#39;bin&#39;</span>
<span class="gi">+            if bin_path.is_dir():</span>
<span class="gi">+                python_files = [</span>
<span class="gi">+                    str(f) for f in bin_path.iterdir()</span>
<span class="gi">+                    if f.is_file() and (f.suffix in all_suffixes() or f.name == &#39;python&#39;)</span>
<span class="gi">+                ]</span>
<span class="gi">+                debug.dbg(f&quot;Found buildout scripts: {python_files}&quot;)</span>
<span class="gi">+                return python_files</span>
<span class="gi">+        current_path = current_path.parent</span>
<span class="gi">+        if current_path == current_path.parent:  # Reached root directory</span>
<span class="gi">+            break</span>
<span class="gi">+        limit -= 1</span>
<span class="gi">+    debug.dbg(f&quot;No buildout configuration found for {search_path}&quot;)</span>
<span class="gi">+    return []</span>


<span class="w"> </span>def transform_path_to_dotted(sys_path, module_path):
<span class="gu">@@ -60,4 +136,19 @@ def transform_path_to_dotted(sys_path, module_path):</span>
<span class="w"> </span>    Returns (None, False) if the path doesn&#39;t really resolve to anything.
<span class="w"> </span>    The second return part is if it is a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module_path = Path(module_path).absolute()</span>
<span class="gi">+    for p in sys_path:</span>
<span class="gi">+        try:</span>
<span class="gi">+            p = Path(p).absolute()</span>
<span class="gi">+            if module_path.is_relative_to(p):</span>
<span class="gi">+                rest = module_path.relative_to(p)</span>
<span class="gi">+                parts = rest.parts</span>
<span class="gi">+                if module_path.suffix == &#39;.py&#39;:</span>
<span class="gi">+                    if module_path.stem == &#39;__init__&#39;:</span>
<span class="gi">+                        return parts[:-1], True</span>
<span class="gi">+                    return parts[:-1] + (module_path.stem,), False</span>
<span class="gi">+                elif module_path.is_dir():</span>
<span class="gi">+                    return parts, True</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return None, False</span>
<span class="gh">diff --git a/jedi/inference/utils.py b/jedi/inference/utils.py</span>
<span class="gh">index 9e8c4321..a0af46d2 100644</span>
<span class="gd">--- a/jedi/inference/utils.py</span>
<span class="gi">+++ b/jedi/inference/utils.py</span>
<span class="gu">@@ -2,6 +2,7 @@</span>
<span class="w"> </span>import functools
<span class="w"> </span>import re
<span class="w"> </span>import os
<span class="gi">+import sys</span>
<span class="w"> </span>_sep = os.path.sep
<span class="w"> </span>if os.path.altsep is not None:
<span class="w"> </span>    _sep += os.path.altsep
<span class="gu">@@ -12,7 +13,7 @@ del _sep</span>

<span class="w"> </span>def unite(iterable):
<span class="w"> </span>    &quot;&quot;&quot;Turns a two dimensional array into a one dimensional.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [item for sublist in iterable for item in sublist]</span>


<span class="w"> </span>class UncaughtAttributeError(Exception):
<span class="gu">@@ -44,7 +45,13 @@ def reraise_uncaught(func):</span>
<span class="w"> </span>    `AttributeError` to `UncaughtAttributeError` to avoid unexpected catch.
<span class="w"> </span>    This helps us noticing bugs earlier and facilitates debugging.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @functools.wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        except AttributeError as e:</span>
<span class="gi">+            raise UncaughtAttributeError(sys.exc_info()) from e</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class PushBackIterator:
<span class="gh">diff --git a/jedi/inference/value/dynamic_arrays.py b/jedi/inference/value/dynamic_arrays.py</span>
<span class="gh">index 419cd8a5..10d19852 100644</span>
<span class="gd">--- a/jedi/inference/value/dynamic_arrays.py</span>
<span class="gi">+++ b/jedi/inference/value/dynamic_arrays.py</span>
<span class="gu">@@ -31,7 +31,7 @@ _sentinel = object()</span>

<span class="w"> </span>def check_array_additions(context, sequence):
<span class="w"> </span>    &quot;&quot;&quot; Just a mapper function for the internal _internal_check_array_additions &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _internal_check_array_additions(context, sequence)</span>


<span class="w"> </span>@inference_state_method_cache(default=NO_VALUES)
<span class="gu">@@ -43,12 +43,56 @@ def _internal_check_array_additions(context, sequence):</span>
<span class="w"> </span>    &gt;&gt;&gt; a = [&quot;&quot;]
<span class="w"> </span>    &gt;&gt;&gt; a.append(1)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    debug.dbg(&#39;Dynamic array search for %s&#39; % sequence, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+    module_context = context.get_root_context()</span>
<span class="gi">+    if not settings.dynamic_array_additions:</span>
<span class="gi">+        return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+    temp_param_add, settings.dynamic_array_additions = \</span>
<span class="gi">+        settings.dynamic_array_additions, False</span>
<span class="gi">+</span>
<span class="gi">+    is_list = sequence.name.string_name == &#39;list&#39;</span>
<span class="gi">+    search_names = ([&#39;append&#39;, &#39;extend&#39;, &#39;insert&#39;] if is_list</span>
<span class="gi">+                    else [&#39;add&#39;, &#39;update&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    added_types = ValueSet()</span>
<span class="gi">+    for name in search_names:</span>
<span class="gi">+        try:</span>
<span class="gi">+            possible_names = module_context.tree_node.get_used_names()[sequence.name.string_name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        for name_node in possible_names:</span>
<span class="gi">+            trailer = name_node.parent</span>
<span class="gi">+            if trailer.type != &#39;trailer&#39; \</span>
<span class="gi">+                    or trailer.children[1].type != &#39;operator&#39; \</span>
<span class="gi">+                    or trailer.children[1].value != &#39;.&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            trailer2 = trailer.parent</span>
<span class="gi">+            if trailer2.type != &#39;trailer&#39; \</span>
<span class="gi">+                    or trailer2.children[1].type != &#39;name&#39; \</span>
<span class="gi">+                    or trailer2.children[1].value != name:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            power = trailer2.parent</span>
<span class="gi">+            if power.type == &#39;power&#39;:</span>
<span class="gi">+                call = power.parent</span>
<span class="gi">+                if call.type == &#39;atom_expr&#39;:</span>
<span class="gi">+                    # TODO check if power.children[0] is the same as sequence</span>
<span class="gi">+                    for argument in call.children[1].children[1:-1]:</span>
<span class="gi">+                        added_types |= context.infer_node(argument)</span>
<span class="gi">+</span>
<span class="gi">+    debug.dbg(&#39;Dynamic array result %s&#39; % added_types, color=&#39;MAGENTA&#39;)</span>
<span class="gi">+    settings.dynamic_array_additions = temp_param_add</span>
<span class="gi">+    return added_types</span>


<span class="w"> </span>def get_dynamic_array_instance(instance, arguments):
<span class="w"> </span>    &quot;&quot;&quot;Used for set() and list() instances.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ai = _DynamicArrayAdditions(instance, arguments)</span>
<span class="gi">+    from jedi.inference.value import iterable</span>
<span class="gi">+    return iterable.FakeSequence(instance.inference_state, [ai], instance.array_type)</span>


<span class="w"> </span>class _DynamicArrayAdditions(HelperValueMixin):
<span class="gu">@@ -76,8 +120,41 @@ class _Modification(ValueWrapper):</span>


<span class="w"> </span>class DictModification(_Modification):
<span class="gd">-    pass</span>
<span class="gi">+    def _get_modified_dict(self):</span>
<span class="gi">+        lazy_value = self._wrapped_value.get_mapping_item_values()</span>
<span class="gi">+        dct = dict(lazy_value.infer())</span>
<span class="gi">+        key = self._contextualized_key.infer().get_first_non_keyword_argument_values()</span>
<span class="gi">+        if key:</span>
<span class="gi">+            key = next(iter(key)).get_safe_value(default=_sentinel)</span>
<span class="gi">+            if key is not _sentinel:</span>
<span class="gi">+                dct[key] = LazyKnownValues(self._assigned_values)</span>
<span class="gi">+        return dct</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping_item_values(self):</span>
<span class="gi">+        return LazyKnownValues(ValueSet(self._get_modified_dict().values()))</span>
<span class="gi">+</span>
<span class="gi">+    def get_key_values(self):</span>
<span class="gi">+        return ValueSet(self._get_modified_dict().keys())</span>


<span class="w"> </span>class ListModification(_Modification):
<span class="gd">-    pass</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        for lazy_value in self._wrapped_value.py__iter__(contextualized_node):</span>
<span class="gi">+            yield lazy_value</span>
<span class="gi">+        yield LazyKnownValues(self._assigned_values)</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index):</span>
<span class="gi">+        if isinstance(index, slice):</span>
<span class="gi">+            return ValueSet([self._wrapped_value])</span>
<span class="gi">+</span>
<span class="gi">+        index = index.get_safe_value()</span>
<span class="gi">+        if index is None:</span>
<span class="gi">+            return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        values = self._wrapped_value.py__getitem__(index)</span>
<span class="gi">+        if index == len(self._wrapped_value.get_safe_value()):</span>
<span class="gi">+            values |= self._assigned_values</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def py__len__(self):</span>
<span class="gi">+        return self._wrapped_value.py__len__() + 1</span>
<span class="gh">diff --git a/jedi/inference/value/function.py b/jedi/inference/value/function.py</span>
<span class="gh">index 7ee96aa8..a60cd607 100644</span>
<span class="gd">--- a/jedi/inference/value/function.py</span>
<span class="gi">+++ b/jedi/inference/value/function.py</span>
<span class="gu">@@ -26,18 +26,44 @@ class LambdaName(AbstractNameDefinition):</span>
<span class="w"> </span>        self._lambda_value = lambda_value
<span class="w"> </span>        self.parent_context = lambda_value.parent_context

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self._lambda_value])</span>
<span class="gi">+</span>

<span class="w"> </span>class FunctionAndClassBase(TreeValue):
<span class="gd">-    pass</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self.tree_node.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [TreeSignature(self)]</span>


<span class="w"> </span>class FunctionMixin:
<span class="w"> </span>    api_type = &#39;function&#39;


<span class="gd">-class FunctionValue(FunctionMixin, FunctionAndClassBase, metaclass=</span>
<span class="gd">-    CachedMetaClass):</span>
<span class="gd">-    pass</span>
<span class="gi">+class FunctionValue(FunctionMixin, FunctionAndClassBase, metaclass=CachedMetaClass):</span>
<span class="gi">+    def __init__(self, inference_state, parent_context, tree_node):</span>
<span class="gi">+        super().__init__(inference_state, parent_context, tree_node)</span>
<span class="gi">+        self.tree_node = tree_node</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [ParamName(self, param) for param in self.tree_node.get_params()]</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        return self.tree_node.annotation</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def get_return_values(self):</span>
<span class="gi">+        return self._get_return_values()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_return_values(self):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            self.execute_with_values() for _ in range(self.inference_state.recursion_limit)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def execute_with_values(self):</span>
<span class="gi">+        return self.inference_state.execute(self)</span>


<span class="w"> </span>class FunctionNameInClass(NameWrapper):
<span class="gu">@@ -46,6 +72,13 @@ class FunctionNameInClass(NameWrapper):</span>
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self._class_context = class_context

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([MethodValue(</span>
<span class="gi">+            self.parent_context.inference_state,</span>
<span class="gi">+            self._class_context,</span>
<span class="gi">+            self._wrapped_name.infer().get(),</span>
<span class="gi">+        )])</span>
<span class="gi">+</span>

<span class="w"> </span>class MethodValue(FunctionValue):

<span class="gu">@@ -53,6 +86,12 @@ class MethodValue(FunctionValue):</span>
<span class="w"> </span>        super().__init__(inference_state, *args, **kwargs)
<span class="w"> </span>        self.class_context = class_context

<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self.class_context.get_qualified_names() + [self.name.string_name]</span>
<span class="gi">+</span>
<span class="gi">+    def get_signature_functions(self):</span>
<span class="gi">+        return [self]</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseFunctionExecutionContext(ValueContext, TreeContextMixin):

<span class="gu">@@ -60,7 +99,11 @@ class BaseFunctionExecutionContext(ValueContext, TreeContextMixin):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Created to be used by inheritance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        function = self.value</span>
<span class="gi">+        return_node = function.tree_node.get_return_stmt()</span>
<span class="gi">+        if return_node:</span>
<span class="gi">+            return self.inference_state.infer(return_node.get_testlist())</span>
<span class="gi">+        return ValueSet([compiled.builtin_from_name(self.inference_state, &#39;None&#39;)])</span>


<span class="w"> </span>class FunctionExecutionContext(BaseFunctionExecutionContext):
<span class="gu">@@ -69,9 +112,19 @@ class FunctionExecutionContext(BaseFunctionExecutionContext):</span>
<span class="w"> </span>        super().__init__(function_value)
<span class="w"> </span>        self._arguments = arguments

<span class="gi">+    def get_filters(self):</span>
<span class="gi">+        yield FunctionExecutionFilter(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return self.value.get_param_names()</span>
<span class="gi">+</span>

<span class="w"> </span>class AnonymousFunctionExecution(BaseFunctionExecutionContext):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self):</span>
<span class="gi">+        yield AnonymousFunctionExecutionFilter(self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [AnonymousParamName(self, param) for param in self.value.tree_node.get_params()]</span>


<span class="w"> </span>class OverloadedFunctionValue(FunctionMixin, ValueWrapper):
<span class="gu">@@ -79,3 +132,12 @@ class OverloadedFunctionValue(FunctionMixin, ValueWrapper):</span>
<span class="w"> </span>    def __init__(self, function, overloaded_functions):
<span class="w"> </span>        super().__init__(function)
<span class="w"> </span>        self._overloaded_functions = overloaded_functions
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return ValueSet.from_sets(</span>
<span class="gi">+            function.py__call__(arguments)</span>
<span class="gi">+            for function in self._overloaded_functions</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_signatures(self):</span>
<span class="gi">+        return [sig for func in self._overloaded_functions for sig in func.get_signatures()]</span>
<span class="gh">diff --git a/jedi/inference/value/instance.py b/jedi/inference/value/instance.py</span>
<span class="gh">index f61454ad..e85237ff 100644</span>
<span class="gd">--- a/jedi/inference/value/instance.py</span>
<span class="gi">+++ b/jedi/inference/value/instance.py</span>
<span class="gu">@@ -72,13 +72,21 @@ class _BaseTreeInstance(AbstractInstanceValue):</span>
<span class="w"> </span>        __getattribute__ methods. Stubs don&#39;t need to be checked, because
<span class="w"> </span>        they don&#39;t contain any logic.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        alternatives = []</span>
<span class="gi">+        for name in (&#39;__getattr__&#39;, &#39;__getattribute__&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                alternatives.extend(self.py__getattribute__(name))</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        return alternatives</span>

<span class="w"> </span>    def py__get__(self, instance, class_value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        obj may be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            return ValueSet([self])</span>
<span class="gi">+        return ValueSet([BoundMethod(instance, class_value, self)])</span>


<span class="w"> </span>class TreeInstance(_BaseTreeInstance):
<span class="gu">@@ -106,12 +114,24 @@ class CompiledInstanceName(NameWrapper):</span>
<span class="w"> </span>    pass


<span class="gd">-class CompiledInstanceClassFilter(AbstractFilter):</span>
<span class="gi">+class CompistedInstanceClassFilter(AbstractFilter):</span>

<span class="w"> </span>    def __init__(self, instance, f):
<span class="w"> </span>        self._instance = instance
<span class="w"> </span>        self._class_filter = f

<span class="gi">+    def get(self, name):</span>
<span class="gi">+        return [</span>
<span class="gi">+            CompiledInstanceName(self._instance, n)</span>
<span class="gi">+            for n in self._class_filter.get(name)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return [</span>
<span class="gi">+            CompiledInstanceName(self._instance, n)</span>
<span class="gi">+            for n in self._class_filter.values()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>

<span class="w"> </span>class BoundMethod(FunctionMixin, ValueWrapper):

<span class="gu">@@ -138,6 +158,13 @@ class SelfName(TreeNameDefinition):</span>
<span class="w"> </span>        self.class_context = class_context
<span class="w"> </span>        self.tree_name = tree_name

<span class="gi">+    @property</span>
<span class="gi">+    def parent_context(self):</span>
<span class="gi">+        return self._instance.create_context(self.class_context, self.tree_name)</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        return ValueSet([self._instance])</span>
<span class="gi">+</span>

<span class="w"> </span>class LazyInstanceClassName(NameWrapper):

<span class="gu">@@ -177,3 +204,11 @@ class InstanceArguments(TreeArgumentsWrapper):</span>
<span class="w"> </span>    def __init__(self, instance, arguments):
<span class="w"> </span>        super().__init__(arguments)
<span class="w"> </span>        self.instance = instance
<span class="gi">+</span>
<span class="gi">+    def unpack(self, func=None):</span>
<span class="gi">+        yield None, LazyKnownValue(self.instance)</span>
<span class="gi">+        for values in self._wrapped_arguments.unpack(func):</span>
<span class="gi">+            yield values</span>
<span class="gi">+</span>
<span class="gi">+    def get_calling_nodes(self):</span>
<span class="gi">+        return self._wrapped_arguments.get_calling_nodes()</span>
<span class="gh">diff --git a/jedi/inference/value/iterable.py b/jedi/inference/value/iterable.py</span>
<span class="gh">index 6b4bb3e8..427965b2 100644</span>
<span class="gd">--- a/jedi/inference/value/iterable.py</span>
<span class="gi">+++ b/jedi/inference/value/iterable.py</span>
<span class="gu">@@ -105,14 +105,34 @@ class SequenceLiteralValue(Sequence):</span>

<span class="w"> </span>    def py__simple_getitem__(self, index):
<span class="w"> </span>        &quot;&quot;&quot;Here the index is an int/str. Raises IndexError/KeyError.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.array_type in (&#39;list&#39;, &#39;tuple&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                children = self.atom.children[1:-1]</span>
<span class="gi">+                if children:</span>
<span class="gi">+                    return self._defining_context.infer_node(children[index])</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                raise IndexError(&quot;list index out of range&quot;)</span>
<span class="gi">+        elif self.array_type == &#39;set&#39;:</span>
<span class="gi">+            raise TypeError(&quot;&#39;set&#39; object is not subscriptable&quot;)</span>
<span class="gi">+        raise NotImplementedError(f&quot;py__simple_getitem__ not implemented for {self.array_type}&quot;)</span>

<span class="w"> </span>    def py__iter__(self, contextualized_node=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        While values returns the possible values for any array field, this
<span class="w"> </span>        function returns the value for a certain index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.array_type in (&#39;list&#39;, &#39;tuple&#39;, &#39;set&#39;):</span>
<span class="gi">+            children = self.atom.children[1:-1]  # Skip brackets</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                if child.type == &#39;testlist_comp&#39;:</span>
<span class="gi">+                    # Handle nested structures</span>
<span class="gi">+                    for c in child.children:</span>
<span class="gi">+                        if c.type != &#39;operator&#39;:</span>
<span class="gi">+                            yield LazyTreeValue(self._defining_context, c)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield LazyTreeValue(self._defining_context, child)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;py__iter__ not implemented for {self.array_type}&quot;)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s of %s&gt;&#39; % (self.__class__.__name__, self.atom)
<span class="gu">@@ -128,21 +148,30 @@ class DictLiteralValue(_DictMixin, SequenceLiteralValue, _DictKeyMixin):</span>

<span class="w"> </span>    def py__simple_getitem__(self, index):
<span class="w"> </span>        &quot;&quot;&quot;Here the index is an int/str. Raises IndexError/KeyError.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in self._items():</span>
<span class="gi">+            if key.get_safe_value() == index:</span>
<span class="gi">+                return ValueSet([value])</span>
<span class="gi">+        raise KeyError(index)</span>

<span class="w"> </span>    def py__iter__(self, contextualized_node=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        While values returns the possible values for any array field, this
<span class="w"> </span>        function returns the value for a certain index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, _ in self._items():</span>
<span class="gi">+            yield key</span>

<span class="w"> </span>    def exact_key_items(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a generator of tuples like dict.items(), where the key is
<span class="w"> </span>        resolved (as a string) and the values are still lazy values.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in self._items():</span>
<span class="gi">+            key_value = key.get_safe_value()</span>
<span class="gi">+            if key_value is None:</span>
<span class="gi">+                # If the key is not a constant, we can&#39;t guarantee its value</span>
<span class="gi">+                continue</span>
<span class="gi">+            yield key_value, value</span>


<span class="w"> </span>class _FakeSequence(Sequence):
<span class="gu">@@ -189,7 +218,23 @@ def unpack_tuple_to_dict(context, types, exprlist):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Unpacking tuple assignments in for statements and expr_stmts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for i, (expr, values) in enumerate(zip(exprlist, types)):</span>
<span class="gi">+        if expr.type == &#39;name&#39;:</span>
<span class="gi">+            result[expr.value] = values</span>
<span class="gi">+        elif expr.type in (&#39;testlist&#39;, &#39;testlist_star_expr&#39;):</span>
<span class="gi">+            # Nested tuple unpacking</span>
<span class="gi">+            nested_result = unpack_tuple_to_dict(</span>
<span class="gi">+                context,</span>
<span class="gi">+                list(values.iterate_values()) if values else [],</span>
<span class="gi">+                expr.children[::2]  # Skip commas</span>
<span class="gi">+            )</span>
<span class="gi">+            result.update(nested_result)</span>
<span class="gi">+        elif expr.type == &#39;star_expr&#39;:</span>
<span class="gi">+            # Handle star unpacking</span>
<span class="gi">+            star_name = expr.children[1].value</span>
<span class="gi">+            result[star_name] = values</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class Slice(LazyValueWrapper):
<span class="gh">diff --git a/jedi/inference/value/klass.py b/jedi/inference/value/klass.py</span>
<span class="gh">index b88b0996..37ccae6c 100644</span>
<span class="gd">--- a/jedi/inference/value/klass.py</span>
<span class="gi">+++ b/jedi/inference/value/klass.py</span>
<span class="gu">@@ -75,3 +75,89 @@ class ClassMixin:</span>

<span class="w"> </span>class ClassValue(ClassMixin, FunctionAndClassBase, metaclass=CachedMetaClass):
<span class="w"> </span>    api_type = &#39;class&#39;
<span class="gi">+</span>
<span class="gi">+    def __init__(self, inference_state, parent_context, tree_node):</span>
<span class="gi">+        super().__init__(parent_context, tree_node)</span>
<span class="gi">+        self.inference_state = inference_state</span>
<span class="gi">+        self._class_filters = None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return ValueName(self, self.tree_node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        from jedi.inference.value import instance</span>
<span class="gi">+        return ValueSet([instance.TreeInstance(self.inference_state, self.parent_context, self, arguments)])</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return self.inference_state.builtins_module.get_value(&#39;type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def py__bases__(self):</span>
<span class="gi">+        return self._get_bases()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_bases(self):</span>
<span class="gi">+        arglist = self.tree_node.get_super_arglist()</span>
<span class="gi">+        if arglist:</span>
<span class="gi">+            args = unpack_arglist(self.parent_context, arglist)</span>
<span class="gi">+            base_values = args.get_calling_nodes()</span>
<span class="gi">+        else:</span>
<span class="gi">+            base_values = [compiled.builtin_from_name(self.inference_state, &#39;object&#39;)]</span>
<span class="gi">+        return base_values</span>
<span class="gi">+</span>
<span class="gi">+    def py__bool__(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return self.name.get_qualified_names()</span>
<span class="gi">+</span>
<span class="gi">+    def py__doc__(self):</span>
<span class="gi">+        return self.tree_node.get_doc_node()</span>
<span class="gi">+</span>
<span class="gi">+    def is_class(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def is_stub(self):</span>
<span class="gi">+        return self.parent_context.is_stub()</span>
<span class="gi">+</span>
<span class="gi">+    def py__mro__(self):</span>
<span class="gi">+        mro = [self]</span>
<span class="gi">+        for base in self.py__bases__:</span>
<span class="gi">+            if not isinstance(base, ClassValue):</span>
<span class="gi">+                # TODO is this correct?</span>
<span class="gi">+                continue</span>
<span class="gi">+            mro += base.py__mro__()</span>
<span class="gi">+        return mro</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_generator_cache()</span>
<span class="gi">+    def py__getitem__(self, index_value_set, contextualized_node):</span>
<span class="gi">+        from jedi.inference.gradual.annotation import GenericClass</span>
<span class="gi">+        return ValueSet([GenericClass(self, index_value_set)])</span>
<span class="gi">+</span>
<span class="gi">+    def get_function_slot_names(self, name):</span>
<span class="gi">+        for filter in self.get_filters():</span>
<span class="gi">+            names = filter.get(name)</span>
<span class="gi">+            if names:</span>
<span class="gi">+                return names</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def class_value(self):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def as_context(self):</span>
<span class="gi">+        return ClassContext(self)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_types_of_iterate(self, contextualized_node=None, is_async=False):</span>
<span class="gi">+        return ValueSet([self])</span>
<span class="gi">+</span>
<span class="gi">+    def py__iter__(self, contextualized_node=None):</span>
<span class="gi">+        return iter([self])</span>
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.name.string_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_hint(self, add_class_info=True):</span>
<span class="gi">+        if add_class_info:</span>
<span class="gi">+            return &#39;Type[%s]&#39; % self.py__name__()</span>
<span class="gi">+        return self.py__name__()</span>
<span class="gh">diff --git a/jedi/inference/value/module.py b/jedi/inference/value/module.py</span>
<span class="gh">index c79b2dda..39100542 100644</span>
<span class="gd">--- a/jedi/inference/value/module.py</span>
<span class="gi">+++ b/jedi/inference/value/module.py</span>
<span class="gu">@@ -33,7 +33,32 @@ class SubModuleDictMixin:</span>
<span class="w"> </span>        Lists modules in the directory of this module (if this module is a
<span class="w"> </span>        package).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._is_package:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        module_path = self.py__path__()</span>
<span class="gi">+        if not module_path:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        names = {}</span>
<span class="gi">+        for path in module_path:</span>
<span class="gi">+            try:</span>
<span class="gi">+                directory = os.scandir(path)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for entry in directory:</span>
<span class="gi">+                name = entry.name</span>
<span class="gi">+                if name.endswith(&#39;.py&#39;):</span>
<span class="gi">+                    module_name = name[:-3]</span>
<span class="gi">+                elif entry.is_dir() and os.path.isfile(os.path.join(entry.path, &#39;__init__.py&#39;)):</span>
<span class="gi">+                    module_name = name</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                names[module_name] = SubModuleName(self, module_name)</span>
<span class="gi">+</span>
<span class="gi">+        return names</span>


<span class="w"> </span>class ModuleMixin(SubModuleDictMixin):
<span class="gu">@@ -45,7 +70,7 @@ class ModuleMixin(SubModuleDictMixin):</span>
<span class="w"> </span>        it&#39;s reachable and not `None`. With this information we can add
<span class="w"> </span>        qualified names on top for all value children.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>


<span class="w"> </span>class ModuleValue(ModuleMixin, TreeValue):
<span class="gu">@@ -64,11 +89,11 @@ class ModuleValue(ModuleMixin, TreeValue):</span>
<span class="w"> </span>        self.code_lines = code_lines
<span class="w"> </span>        self._is_package = is_package

<span class="gd">-    def py__file__(self) -&gt;Optional[Path]:</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[Path]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        In contrast to Python&#39;s __file__ can be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._path</span>

<span class="w"> </span>    def py__path__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,7 +101,13 @@ class ModuleValue(ModuleMixin, TreeValue):</span>
<span class="w"> </span>        is a list of paths (strings).
<span class="w"> </span>        Returns None if the module is not a package.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._is_package:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+        if self._path is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return [str(self._path.parent)]</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s@%s-%s is_stub=%s&gt;&#39; % (self.__class__.__name__, self
<span class="gh">diff --git a/jedi/inference/value/namespace.py b/jedi/inference/value/namespace.py</span>
<span class="gh">index 33eb07fc..5d910b9e 100644</span>
<span class="gd">--- a/jedi/inference/value/namespace.py</span>
<span class="gi">+++ b/jedi/inference/value/namespace.py</span>
<span class="gu">@@ -35,7 +35,32 @@ class ImplicitNamespaceValue(Value, SubModuleDictMixin):</span>
<span class="w"> </span>    def py__package__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the fullname
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;.&#39;.join(self.string_names)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;%s: %s&gt;&#39; % (self.__class__.__name__, self.py__name__())
<span class="gi">+</span>
<span class="gi">+    def py__name__(self):</span>
<span class="gi">+        return self.string_names[-1]</span>
<span class="gi">+</span>
<span class="gi">+    def py__path__(self):</span>
<span class="gi">+        return self._paths</span>
<span class="gi">+</span>
<span class="gi">+    def py__file__(self) -&gt; Optional[str]:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def is_namespace(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_qualified_names(self):</span>
<span class="gi">+        return tuple(self.string_names)</span>
<span class="gi">+</span>
<span class="gi">+    def py__class__(self):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @inference_state_method_cache()</span>
<span class="gi">+    def get_filters(self, origin_scope=None):</span>
<span class="gi">+        return [DictFilter(self.sub_modules_dict())]</span>
<span class="gi">+</span>
<span class="gi">+    def get_value(self):</span>
<span class="gi">+        return self</span>
<span class="gh">diff --git a/jedi/parser_utils.py b/jedi/parser_utils.py</span>
<span class="gh">index 75857eda..33882e7d 100644</span>
<span class="gd">--- a/jedi/parser_utils.py</span>
<span class="gi">+++ b/jedi/parser_utils.py</span>
<span class="gu">@@ -18,7 +18,14 @@ def get_executable_nodes(node, last_added=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    For static analysis.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    if node.type in _EXECUTE_NODES:</span>
<span class="gi">+        result.append(node)</span>
<span class="gi">+    for child in node.children:</span>
<span class="gi">+        result.extend(get_executable_nodes(child, last_added=True))</span>
<span class="gi">+    if last_added and node.type in (&#39;suite&#39;, &#39;simple_stmt&#39;):</span>
<span class="gi">+        return result[-1:]</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def for_stmt_defines_one_name(for_stmt):
<span class="gu">@@ -28,12 +35,17 @@ def for_stmt_defines_one_name(for_stmt):</span>

<span class="w"> </span>    :returns: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(for_stmt.get_defined_names()) == 1</span>


<span class="w"> </span>def clean_scope_docstring(scope_node):
<span class="w"> </span>    &quot;&quot;&quot; Returns a cleaned version of the docstring token. &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if scope_node.type in (&#39;classdef&#39;, &#39;funcdef&#39;):</span>
<span class="gi">+        node = scope_node.get_doc_node()</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            # Return a cleaned version of the docstring token</span>
<span class="gi">+            return cleandoc(node.value.strip(&quot;\&quot;&#39;&quot;))</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_signature(funcdef, width=72, call_string=None, omit_first_param=
<span class="gu">@@ -48,14 +60,47 @@ def get_signature(funcdef, width=72, call_string=None, omit_first_param=</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def param_str(param):</span>
<span class="gi">+        if param.annotation is None:</span>
<span class="gi">+            return param.name.value</span>
<span class="gi">+        return f&quot;{param.name.value}: {param.annotation.get_code()}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    params = funcdef.get_params()</span>
<span class="gi">+    if omit_first_param and params:</span>
<span class="gi">+        params = params[1:]</span>
<span class="gi">+</span>
<span class="gi">+    param_strings = [param_str(p) for p in params]</span>
<span class="gi">+    func_name = call_string or funcdef.name.value</span>
<span class="gi">+</span>
<span class="gi">+    signature = f&quot;{func_name}({&#39;, &#39;.join(param_strings)})&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    if not omit_return_annotation and funcdef.annotation:</span>
<span class="gi">+        signature += f&quot; -&gt; {funcdef.annotation.get_code()}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if len(signature) &gt; width:</span>
<span class="gi">+        signature = f&quot;{func_name}(\n    &quot; + &quot;,\n    &quot;.join(param_strings) + &quot;\n)&quot;</span>
<span class="gi">+        if not omit_return_annotation and funcdef.annotation:</span>
<span class="gi">+            signature += f&quot; -&gt; {funcdef.annotation.get_code()}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return signature</span>


<span class="w"> </span>def move(node, line_offset):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move the `Node` start_pos.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        node.line += line_offset</span>
<span class="gi">+    else:</span>
<span class="gi">+        for child in children:</span>
<span class="gi">+            move(child, line_offset)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        node.start_pos = node.start_pos[0] + line_offset, node.start_pos[1]</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>def get_following_comment_same_line(node):
<span class="gu">@@ -63,14 +108,30 @@ def get_following_comment_same_line(node):</span>
<span class="w"> </span>    returns (as string) any comment that appears on the same line,
<span class="w"> </span>    after the node, including the #
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if node.end_pos is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        line, column = node.end_pos</span>
<span class="gi">+        leaf = node.get_next_leaf()</span>
<span class="gi">+        if leaf is not None and leaf.start_pos[0] == line and leaf.type == &#39;comment&#39;:</span>
<span class="gi">+            return leaf.value</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_parent_scope(node, include_flows=False):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the underlying scope.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scope = node.parent</span>
<span class="gi">+    while scope is not None:</span>
<span class="gi">+        if scope.type in (&#39;classdef&#39;, &#39;funcdef&#39;, &#39;file_input&#39;):</span>
<span class="gi">+            return scope</span>
<span class="gi">+        if include_flows and scope.type in _FLOW_KEYWORDS:</span>
<span class="gi">+            return scope</span>
<span class="gi">+        scope = scope.parent</span>
<span class="gi">+    return None</span>


<span class="w"> </span>get_cached_parent_scope = _get_parent_scope_cache(get_parent_scope)
<span class="gu">@@ -81,7 +142,8 @@ def get_cached_code_lines(grammar, path):</span>
<span class="w"> </span>    Basically access the cached code lines in parso. This is not the nicest way
<span class="w"> </span>    to do this, but we avoid splitting all the lines again.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module_node = parser_cache[grammar._hashed][path]</span>
<span class="gi">+    return module_node.get_code().splitlines()</span>


<span class="w"> </span>def get_parso_cache_node(grammar, path):
<span class="gu">@@ -92,21 +154,40 @@ def get_parso_cache_node(grammar, path):</span>
<span class="w"> </span>    The reason for this is mostly caching. This is obviously also a sign of a
<span class="w"> </span>    broken caching architecture.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parser_cache[grammar._hashed][path]</span>


<span class="w"> </span>def cut_value_at_position(leaf, position):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Cuts of the value of the leaf at position
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if leaf.type == &#39;string&#39;:</span>
<span class="gi">+        # Remove the quotes</span>
<span class="gi">+        value = literal_eval(leaf.value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        value = leaf.value</span>
<span class="gi">+</span>
<span class="gi">+    line, column = position</span>
<span class="gi">+    if leaf.line == line:</span>
<span class="gi">+        return value[:column - leaf.column]</span>
<span class="gi">+    elif leaf.line &gt; line:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return value</span>


<span class="w"> </span>def expr_is_dotted(node):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks if a path looks like `name` or `name.foo.bar` and not `name()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.type == &#39;name&#39;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if node.type == &#39;atom_expr&#39;:</span>
<span class="gi">+        children = node.children</span>
<span class="gi">+        if len(children) &gt; 1 and children[1].type == &#39;trailer&#39;:</span>
<span class="gi">+            if children[1].children[0].value == &#39;.&#39;:</span>
<span class="gi">+                return expr_is_dotted(children[1].children[1])</span>
<span class="gi">+    return False</span>


<span class="w"> </span>function_is_staticmethod = _function_is_x_method(&#39;staticmethod&#39;)
<span class="gh">diff --git a/jedi/plugins/django.py b/jedi/plugins/django.py</span>
<span class="gh">index b9ceb2ec..0e1458d4 100644</span>
<span class="gd">--- a/jedi/plugins/django.py</span>
<span class="gi">+++ b/jedi/plugins/django.py</span>
<span class="gu">@@ -34,21 +34,67 @@ class DjangoModelName(NameWrapper):</span>
<span class="w"> </span>        self._cls = cls
<span class="w"> </span>        self._is_instance = is_instance

<span class="gi">+    def infer(self):</span>
<span class="gi">+        inferred = super().infer()</span>
<span class="gi">+        if self._is_instance:</span>
<span class="gi">+            return ValueSet(</span>
<span class="gi">+                DjangoModelWrapper(v) if isinstance(v, TreeInstance) else v</span>
<span class="gi">+                for v in inferred</span>
<span class="gi">+            )</span>
<span class="gi">+        return inferred</span>
<span class="gi">+</span>

<span class="w"> </span>class ManagerWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        yield DictFilter({</span>
<span class="gi">+            name: QuerySetMethodWrapper(m, self._wrapped_value)</span>
<span class="gi">+            for name, m in self._wrapped_value.get_filters(*args, **kwargs)[0].values.items()</span>
<span class="gi">+            if name in _FILTER_LIKE_METHODS</span>
<span class="gi">+        })</span>
<span class="gi">+        yield from filters</span>


<span class="w"> </span>class GenericManagerWrapper(AttributeOverwrite, ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def py__getitem__(self, index):</span>
<span class="gi">+        return ValueSet([GenericFieldWrapper(self._wrapped_value, index)])</span>
<span class="gi">+</span>
<span class="gi">+    def get_filters(self, *args, **kwargs):</span>
<span class="gi">+        filters = super().get_filters(*args, **kwargs)</span>
<span class="gi">+        yield DictFilter({</span>
<span class="gi">+            name: QuerySetMethodWrapper(m, self._wrapped_value)</span>
<span class="gi">+            for name, m in self._wrapped_value.get_filters(*args, **kwargs)[0].values.items()</span>
<span class="gi">+            if name in _FILTER_LIKE_METHODS</span>
<span class="gi">+        })</span>
<span class="gi">+        yield from filters</span>


<span class="w"> </span>class FieldWrapper(ValueWrapper):
<span class="gd">-    pass</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        inferred = self._wrapped_value.infer()</span>
<span class="gi">+        if self.name.string_name in mapping:</span>
<span class="gi">+            module_name, class_name = mapping[self.name.string_name]</span>
<span class="gi">+            if module_name:</span>
<span class="gi">+                module = self.inference_state.import_module((module_name,))</span>
<span class="gi">+                return module.py__getattribute__(class_name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.inference_state.builtins_module.py__getattribute__(class_name)</span>
<span class="gi">+        return inferred</span>


<span class="w"> </span>class GenericFieldWrapper(AttributeOverwrite, ClassMixin):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, wrapped_value, index):</span>
<span class="gi">+        super().__init__(wrapped_value)</span>
<span class="gi">+        self._index = index</span>
<span class="gi">+</span>
<span class="gi">+    def py__getitem__(self, index):</span>
<span class="gi">+        return self._wrapped_value.py__getitem__(index)</span>
<span class="gi">+</span>
<span class="gi">+    def infer(self):</span>
<span class="gi">+        inferred = self._wrapped_value.infer()</span>
<span class="gi">+        if isinstance(inferred, GenericClass):</span>
<span class="gi">+            return inferred.get_generics()[self._index]</span>
<span class="gi">+        return inferred</span>


<span class="w"> </span>class DjangoModelSignature(AbstractSignature):
<span class="gu">@@ -57,6 +103,12 @@ class DjangoModelSignature(AbstractSignature):</span>
<span class="w"> </span>        super().__init__(value)
<span class="w"> </span>        self._field_names = field_names

<span class="gi">+    def get_param_names(self):</span>
<span class="gi">+        return [DjangoParamName(name) for name in self._field_names]</span>
<span class="gi">+</span>
<span class="gi">+    def bind(self, arguments):</span>
<span class="gi">+        return DjangoModelSignature(self._value, self._field_names)</span>
<span class="gi">+</span>

<span class="w"> </span>class DjangoParamName(BaseTreeParamName):

<span class="gu">@@ -64,6 +116,16 @@ class DjangoParamName(BaseTreeParamName):</span>
<span class="w"> </span>        super().__init__(field_name.parent_context, field_name.tree_name)
<span class="w"> </span>        self._field_name = field_name

<span class="gi">+    def infer(self):</span>
<span class="gi">+        return self._field_name.infer()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def string_name(self):</span>
<span class="gi">+        return self._field_name.string_name</span>
<span class="gi">+</span>
<span class="gi">+    def get_kind(self):</span>
<span class="gi">+        return Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="gi">+</span>

<span class="w"> </span>class QuerySetMethodWrapper(ValueWrapper):

<span class="gu">@@ -71,9 +133,18 @@ class QuerySetMethodWrapper(ValueWrapper):</span>
<span class="w"> </span>        super().__init__(method)
<span class="w"> </span>        self._model_cls = model_cls

<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return ValueSet([QuerySetBoundMethodWrapper(self._wrapped_value, self._model_cls)])</span>
<span class="gi">+</span>

<span class="w"> </span>class QuerySetBoundMethodWrapper(ValueWrapper):

<span class="w"> </span>    def __init__(self, method, model_cls):
<span class="w"> </span>        super().__init__(method)
<span class="w"> </span>        self._model_cls = model_cls
<span class="gi">+</span>
<span class="gi">+    def py__call__(self, arguments):</span>
<span class="gi">+        return ValueSet([self._model_cls])</span>
<span class="gi">+</span>
<span class="gi">+    def get_return_values(self):</span>
<span class="gi">+        return ValueSet([self._model_cls])</span>
<span class="gh">diff --git a/jedi/plugins/flask.py b/jedi/plugins/flask.py</span>
<span class="gh">index d3c813ea..e65e2a15 100644</span>
<span class="gd">--- a/jedi/plugins/flask.py</span>
<span class="gi">+++ b/jedi/plugins/flask.py</span>
<span class="gu">@@ -3,4 +3,19 @@ def import_module(callback):</span>
<span class="w"> </span>    Handle &quot;magic&quot; Flask extension imports:
<span class="w"> </span>    ``flask.ext.foo`` is really ``flask_foo`` or ``flaskext.foo``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(inference_state, import_names, module_context, *args, **kwargs):</span>
<span class="gi">+        if len(import_names) == 3 and import_names[:2] == (&#39;flask&#39;, &#39;ext&#39;):</span>
<span class="gi">+            # Try flask_foo</span>
<span class="gi">+            new_import_names = (&#39;flask_&#39; + import_names[2],)</span>
<span class="gi">+            module = callback(inference_state, new_import_names, module_context, *args, **kwargs)</span>
<span class="gi">+            if module:</span>
<span class="gi">+                return module</span>
<span class="gi">+</span>
<span class="gi">+            # Try flaskext.foo</span>
<span class="gi">+            new_import_names = (&#39;flaskext&#39;, import_names[2])</span>
<span class="gi">+            return callback(inference_state, new_import_names, module_context, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # For all other cases, use the original callback</span>
<span class="gi">+        return callback(inference_state, import_names, module_context, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/jedi/plugins/pytest.py b/jedi/plugins/pytest.py</span>
<span class="gh">index 5295fd78..b9e41bc4 100644</span>
<span class="gd">--- a/jedi/plugins/pytest.py</span>
<span class="gi">+++ b/jedi/plugins/pytest.py</span>
<span class="gu">@@ -19,17 +19,44 @@ def _is_a_pytest_param_and_inherited(param_name):</span>

<span class="w"> </span>    This is a heuristic and will work in most cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def is_test_function(name):</span>
<span class="gi">+        return name.startswith(&#39;test_&#39;) or name.endswith(&#39;_test&#39;)</span>

<span class="gi">+    def is_pytest_fixture(name):</span>
<span class="gi">+        return name.startswith(&#39;pytest_&#39;) or name.endswith(&#39;_fixture&#39;)</span>

<span class="gd">-def _find_pytest_plugin_modules() -&gt;List[List[str]]:</span>
<span class="gi">+    return is_test_function(param_name) or is_pytest_fixture(param_name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_pytest_plugin_modules() -&gt; List[List[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Finds pytest plugin modules hooked by setuptools entry points

<span class="w"> </span>    See https://docs.pytest.org/en/stable/how-to/writing_plugins.html#setuptools-entry-points
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        from importlib.metadata import entry_points</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        # For Python &lt; 3.8</span>
<span class="gi">+        from importlib_metadata import entry_points</span>
<span class="gi">+</span>
<span class="gi">+    plugin_modules = []</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        for ep in entry_points(group=&#39;pytest11&#39;):</span>
<span class="gi">+            module_name = ep.module</span>
<span class="gi">+            if module_name:</span>
<span class="gi">+                plugin_modules.append(module_name.split(&#39;.&#39;))</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        # If there&#39;s any error in reading entry points, we&#39;ll just return an empty list</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return plugin_modules</span>


<span class="w"> </span>class FixtureFilter(ParserTreeFilter):
<span class="gd">-    pass</span>
<span class="gi">+    def _filter(self, names):</span>
<span class="gi">+        for name in super()._filter(names):</span>
<span class="gi">+            string_name = name.string_name</span>
<span class="gi">+            if _is_a_pytest_param_and_inherited(string_name):</span>
<span class="gi">+                yield name</span>
<span class="gh">diff --git a/jedi/plugins/stdlib.py b/jedi/plugins/stdlib.py</span>
<span class="gh">index 3c1eb074..b20c50e9 100644</span>
<span class="gd">--- a/jedi/plugins/stdlib.py</span>
<span class="gi">+++ b/jedi/plugins/stdlib.py</span>
<span class="gu">@@ -94,7 +94,28 @@ def argument_clinic(clinic_string, want_value=False, want_context=False,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Works like Argument Clinic (PEP 436), to validate function params.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(func):</span>
<span class="gi">+        def wrapped(value, arguments, callback):</span>
<span class="gi">+            try:</span>
<span class="gi">+                args = iterate_argument_clinic(</span>
<span class="gi">+                    value.inference_state, arguments, clinic_string</span>
<span class="gi">+                )</span>
<span class="gi">+                if want_value:</span>
<span class="gi">+                    args = (value,) + args</span>
<span class="gi">+                if want_context:</span>
<span class="gi">+                    args += (value.parent_context,)</span>
<span class="gi">+                if want_arguments:</span>
<span class="gi">+                    args += (arguments,)</span>
<span class="gi">+                if want_inference_state:</span>
<span class="gi">+                    args += (value.inference_state,)</span>
<span class="gi">+                if want_callback:</span>
<span class="gi">+                    args += (callback,)</span>
<span class="gi">+                return func(*args)</span>
<span class="gi">+            except ParamIssue:</span>
<span class="gi">+                return NO_VALUES</span>
<span class="gi">+</span>
<span class="gi">+        return wrapped</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class SuperInstance(LazyValueWrapper):
<span class="gu">@@ -154,7 +175,33 @@ def collections_namedtuple(value, arguments, callback):</span>
<span class="w"> </span>    inferring the result.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def execute(params):</span>
<span class="gi">+        typename = params[0].get_safe_value()</span>
<span class="gi">+        field_names = params[1].get_safe_value().replace(&#39;,&#39;, &#39; &#39;).split()</span>
<span class="gi">+</span>
<span class="gi">+        # Create the class template</span>
<span class="gi">+        class_template = _NAMEDTUPLE_CLASS_TEMPLATE.format(</span>
<span class="gi">+            typename=typename,</span>
<span class="gi">+            field_names=tuple(field_names),</span>
<span class="gi">+            num_fields=len(field_names),</span>
<span class="gi">+            arg_list=&#39;, &#39;.join(field_names),</span>
<span class="gi">+            repr_fmt=&#39;, &#39;.join(f&#39;{name}=%r&#39; for name in field_names),</span>
<span class="gi">+            field_defs=&#39;\n&#39;.join(_NAMEDTUPLE_FIELD_TEMPLATE.format(index=index, name=name)</span>
<span class="gi">+                                 for index, name in enumerate(field_names))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Create a module value from the class template</span>
<span class="gi">+        module = value.inference_state.grammar.parse(class_template)</span>
<span class="gi">+        module_value = ModuleValue(</span>
<span class="gi">+            value.inference_state, module,</span>
<span class="gi">+            code_lines=parso.split_lines(class_template, keepends=True),</span>
<span class="gi">+            file_io=None</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Return the class value from the module</span>
<span class="gi">+        return module_value.py__getattribute__(typename)</span>
<span class="gi">+</span>
<span class="gi">+    return execute(arguments.unpack())</span>


<span class="w"> </span>class PartialObject(ValueWrapper):
<span class="gu">@@ -170,7 +217,7 @@ class PartialObject(ValueWrapper):</span>
<span class="w"> </span>        imitating it here, because we want this docstring to be worth something
<span class="w"> </span>        for the user.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._wrapped_value.py__doc__()</span>


<span class="w"> </span>class PartialMethodObject(PartialObject):
<span class="gh">diff --git a/jedi/utils.py b/jedi/utils.py</span>
<span class="gh">index 0dc90e28..5b300f12 100644</span>
<span class="gd">--- a/jedi/utils.py</span>
<span class="gi">+++ b/jedi/utils.py</span>
<span class="gu">@@ -54,7 +54,37 @@ def setup_readline(namespace_module=__main__, fuzzy=False):</span>
<span class="w"> </span>    your shell profile (usually ``.bash_profile`` or ``.profile`` if you use
<span class="w"> </span>    bash).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import readline</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        print(&quot;Readline is not installed. No tab completion is enabled.&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    class JediCompleter:</span>
<span class="gi">+        def __init__(self, namespace, fuzzy):</span>
<span class="gi">+            self.namespace = namespace</span>
<span class="gi">+            self.fuzzy = fuzzy</span>
<span class="gi">+</span>
<span class="gi">+        def complete(self, text, state):</span>
<span class="gi">+            if state == 0:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    interpreter = Interpreter(text, [self.namespace.__dict__])</span>
<span class="gi">+                    completions = interpreter.complete(fuzzy=self.fuzzy)</span>
<span class="gi">+                    self.matches = [c.name_with_symbols for c in completions]</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    if READLINE_DEBUG:</span>
<span class="gi">+                        print(&quot;Completion error:&quot;)</span>
<span class="gi">+                        traceback.print_exc()</span>
<span class="gi">+                    self.matches = []</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.matches[state]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+    completer = JediCompleter(namespace_module, fuzzy)</span>
<span class="gi">+    readline.set_completer(completer.complete)</span>
<span class="gi">+    readline.parse_and_bind(&quot;tab: complete&quot;)</span>
<span class="gi">+    readline.set_completer_delims(readline.get_completer_delims().replace(&#39;.&#39;, &#39;&#39;))</span>


<span class="w"> </span>def version_info():
<span class="gu">@@ -62,4 +92,17 @@ def version_info():</span>
<span class="w"> </span>    Returns a namedtuple of Jedi&#39;s version, similar to Python&#39;s
<span class="w"> </span>    ``sys.version_info``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from jedi import __version__</span>
<span class="gi">+    VersionInfo = namedtuple(&#39;VersionInfo&#39;, [&#39;major&#39;, &#39;minor&#39;, &#39;micro&#39;, &#39;releaselevel&#39;, &#39;serial&#39;])</span>
<span class="gi">+    </span>
<span class="gi">+    # Parse the version string</span>
<span class="gi">+    version_parts = re.match(r&#39;(\d+)\.(\d+)\.(\d+)(?:-(alpha|beta|rc)\.(\d+))?&#39;, __version__)</span>
<span class="gi">+    if version_parts:</span>
<span class="gi">+        major, minor, micro = map(int, version_parts.group(1, 2, 3))</span>
<span class="gi">+        releaselevel = version_parts.group(4) or &#39;final&#39;</span>
<span class="gi">+        serial = int(version_parts.group(5) or 0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Fallback if version string doesn&#39;t match expected format</span>
<span class="gi">+        major, minor, micro, releaselevel, serial = 0, 0, 0, &#39;unknown&#39;, 0</span>
<span class="gi">+    </span>
<span class="gi">+    return VersionInfo(major, minor, micro, releaselevel, serial)</span>
<span class="gh">diff --git a/test/examples/buildout_project/buildout.cfg b/test/examples/buildout_project/buildout.cfg</span>
<span class="gh">index e69de29b..91eb38a8 100644</span>
<span class="gd">--- a/test/examples/buildout_project/buildout.cfg</span>
<span class="gi">+++ b/test/examples/buildout_project/buildout.cfg</span>
<span class="gu">@@ -0,0 +1,9 @@</span>
<span class="gi">+[buildout]</span>
<span class="gi">+parts = python</span>
<span class="gi">+</span>
<span class="gi">+[python]</span>
<span class="gi">+recipe = zc.recipe.egg</span>
<span class="gi">+interpreter = python</span>
<span class="gi">+eggs = </span>
<span class="gi">+    some_package</span>
<span class="gi">+    another_package</span>
<span class="gh">diff --git a/test/test_inference/test_sys_path.py b/test/test_inference/test_sys_path.py</span>
<span class="gh">index a725cd24..665de8ee 100644</span>
<span class="gd">--- a/test/test_inference/test_sys_path.py</span>
<span class="gi">+++ b/test/test_inference/test_sys_path.py</span>
<span class="gu">@@ -66,6 +66,30 @@ def test_venv_and_pths(venv_path, environment):</span>
<span class="w"> </span>    assert not set(sys.path).intersection(ETALON)


<span class="gi">+def test_get_buildout_script_paths(tmpdir):</span>
<span class="gi">+    project_path = tmpdir.mkdir(&quot;buildout_project&quot;)</span>
<span class="gi">+    bin_path = project_path.mkdir(&quot;bin&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create buildout.cfg</span>
<span class="gi">+    project_path.join(&quot;buildout.cfg&quot;).write(&quot;&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create some script files</span>
<span class="gi">+    bin_path.join(&quot;script1.py&quot;).write(&quot;&quot;)</span>
<span class="gi">+    bin_path.join(&quot;script2.py&quot;).write(&quot;&quot;)</span>
<span class="gi">+    bin_path.join(&quot;python&quot;).write(&quot;&quot;)</span>
<span class="gi">+    bin_path.join(&quot;not_a_script.txt&quot;).write(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    result = sys_path._get_buildout_script_paths(Path(str(project_path)))</span>
<span class="gi">+    </span>
<span class="gi">+    expected_scripts = {</span>
<span class="gi">+        str(bin_path.join(&quot;script1.py&quot;)),</span>
<span class="gi">+        str(bin_path.join(&quot;script2.py&quot;)),</span>
<span class="gi">+        str(bin_path.join(&quot;python&quot;))</span>
<span class="gi">+    }</span>
<span class="gi">+    </span>
<span class="gi">+    assert set(result) == expected_scripts</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_s = [&#39;/a&#39;, &#39;/b&#39;, &#39;/c/d/&#39;]
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>