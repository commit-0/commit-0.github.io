
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis test save commit0 baseline marshmallow - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-base-baseline" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis test save commit0 baseline marshmallow
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and_blocked" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and_blocked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_nested_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_nested_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_uncaught_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_uncaught_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_immutable_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_immutable_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_and_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_and_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_or_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_or_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_condition_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_condition_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_event_queue_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_event_queue_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_negative_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_negative_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_resume" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_resume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_until_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_until_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_processed_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_processed_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_succeed" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_succeed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_unavailable_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_unavailable_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_triggered" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_triggered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_nested_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_nested_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_error_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_error_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_no_parent_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_no_parent_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_crashing_child_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_crashing_child_traceback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_invalid_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_invalid_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_callback_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_callback_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_sys_excepthook" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_sys_excepthook
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interruption" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interruption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts_and_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts_and_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_init_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_init_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_terminated_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_terminated_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_multiple_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_multiple_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_self" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_self
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_immediate_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_immediate_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_behaviour" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_behaviour
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_get_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_get_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_target" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_target
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_wait_for_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_wait_for_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_return_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_return_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_child_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_child_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join_and_rejoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join_and_rejoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_continue_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_continue_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_release_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_release_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_immediate_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_immediate_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_cm_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_cm_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_priority_queue" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_priority_queue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_sorted_queue_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_sorted_queue_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_get_users" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_get_users
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource_timeout_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource_timeout_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_mixed_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_mixed_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_nested_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_nested_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container_get_queued" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container_get_queued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_capacity" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_capacity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_cancel" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_cancel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_item_priority" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_item_priority
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_stable_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_stable_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store_get_after_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store_get_after_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_best_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_best_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_worst_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_worst_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_put_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_put_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_get_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_get_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt01" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt005" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.05]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt015" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_multiple_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_multiple_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_default_behavior" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_default_behavior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_illegal_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_illegal_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_sync" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_sync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_discrete_time_steps" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_discrete_time_steps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_negative_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_negative_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_timeout_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_timeout_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_shared_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_shared_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_triggered_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_triggered_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_start_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_start_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_terminated_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_terminated_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_with_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_with_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout_with_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout_with_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_wait_for_all_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_wait_for_all_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining_intermediate_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining_intermediate_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_expansion
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_test-save-commit0_baseline">back to Claude Sonnet 3.5 - Base summary</a></p>
<h1 id="claude-sonnet-35-base-baseline"><strong>Claude Sonnet 3.5 - Base</strong>: baseline</h1>
<h2 id="pytest-summary">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">120</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest">Failed pytest:</h2>
<h3 id="test_conditionpytest_operator_and">test_condition.py::test_operator_and</h3>
<details><summary> <pre>test_condition.py::test_operator_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d900>

    def test_operator_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] & timeout[1] & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d900>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_and_blocked">test_condition.py::test_operator_and_blocked</h3>
<details><summary> <pre>test_condition.py::test_operator_and_blocked</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa432a40>

    def test_operator_and_blocked(env):
        def process(env):
            timeout = env.timeout(1)
            event = env.event()
            yield env.timeout(1)

            condition = timeout & event
            assert not condition.triggered

        env.process(process(env))
>       env.run()

tests/test_condition.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa432a40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_or">test_condition.py::test_operator_or</h3>
<details><summary> <pre>test_condition.py::test_operator_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb340>

    def test_operator_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] | timeout[1] | timeout[2]

            assert results == {
                timeout[0]: 0,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb340>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_and">test_condition.py::test_operator_nested_and</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6697e0>

    def test_operator_nested_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] & timeout[2]) | timeout[1]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
            }
            assert env.now == 1

        env.process(process(env))
>       env.run()

tests/test_condition.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6697e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_or">test_condition.py::test_operator_nested_or</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9913cd0>

    def test_operator_nested_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] | timeout[1]) & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }
            assert env.now == 2

        env.process(process(env))
>       env.run()

tests/test_condition.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9913cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_cond_with_error">test_condition.py::test_nested_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_nested_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345960>

    def test_nested_cond_with_error(env):
        def explode(env):
            yield env.timeout(1)
            raise ValueError('Onoes!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(explode(env)) & env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345960>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_error">test_condition.py::test_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9966800>

    def test_cond_with_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9966800>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_nested_error">test_condition.py::test_cond_with_nested_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_nested_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98ec20>

    def test_cond_with_nested_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) & env.timeout(1) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98ec20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_uncaught_error">test_condition.py::test_cond_with_uncaught_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_uncaught_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa420a60>

    def test_cond_with_uncaught_error(env):
        """Errors that happen after the condition has been triggered will not be
        handled by the condition and cause the simulation to crash."""

        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            yield env.timeout(1) | env.process(explode(env, 2))

        env.process(process(env))
        with pytest.raises(ValueError, match='Onoes, failed after'):
>           env.run()

tests/test_condition.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa420a60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_and_cond">test_condition.py::test_iand_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912dd0>

    def test_iand_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 2, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912dd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_or_cond">test_condition.py::test_iand_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def test_iand_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_or_cond">test_condition.py::test_ior_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4307f0>

    def test_ior_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4307f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_and_cond">test_condition.py::test_ior_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def test_ior_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_immutable_results">test_condition.py::test_immutable_results</h3>
<details><summary> <pre>test_condition.py::test_immutable_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4214b0>

    def test_immutable_results(env):
        """Results of conditions should not change after they have been
        triggered."""

        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            # The or condition in this expression will trigger immediately. The and
            # condition will trigger later on.
            condition = timeout[0] | (timeout[1] & timeout[2])

            results = yield condition
            assert results == {timeout[0]: 0}

            # Make sure that the results of condition were frozen. The results of
            # the nested and condition do not become visible afterwards.
            yield env.timeout(2)
            assert results == {timeout[0]: 0}

        env.process(process(env))
>       env.run()

tests/test_condition.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4214b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_and_condition">test_condition.py::test_shared_and_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_and_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66b640>

    def test_shared_and_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] & timeout[1]
        c2 = c1 & timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1, timeout[2]: 2}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66b640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_or_condition">test_condition.py::test_shared_or_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_or_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30cc70>

    def test_shared_or_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] | timeout[1]
        c2 = c1 | timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30cc70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_condition_value">test_condition.py::test_condition_value</h3>
<details><summary> <pre>test_condition.py::test_condition_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa431510>

    def test_condition_value(env):
        """The value of a condition behaves like a readonly dictionary."""
        timeouts = [env.timeout(delay, value=delay) for delay in range(3)]

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results) == timeouts
            assert list(results.keys()) == timeouts
            assert list(results.values()) == [0, 1, 2]
            assert list(results.items()) == list(zip(timeouts, [0, 1, 2]))
            assert timeouts[0] in results
            assert results[timeouts[0]] == 0
            assert results == results  # noqa: PLR0124
            assert results == results.todict()

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa431510>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_result_order">test_condition.py::test_result_order</h3>
<details><summary> <pre>test_condition.py::test_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d750>

    def test_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified."""
        timeouts = list(reversed([env.timeout(delay) for delay in range(3)]))

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d750>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_result_order">test_condition.py::test_nested_result_order</h3>
<details><summary> <pre>test_condition.py::test_nested_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d030>

    def test_nested_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified (even if nested)."""
        timeouts = [env.timeout(delay) for delay in range(3)]
        condition = (timeouts[0] | timeouts[1]) & timeouts[2]

        def p(_, timeouts):
            results = yield condition
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d030>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_event_queue_empty">test_environment.py::test_event_queue_empty</h3>
<details><summary> <pre>test_environment.py::test_event_queue_empty</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbaf0>, log = []

    def test_event_queue_empty(env, log):
        """The simulation should stop if there are no more events, that means, no
        more active process."""

        def pem(env, log):
            while env.now < 2:
                log.append(env.now)
                yield env.timeout(1)

        env.process(pem(env, log))
>       env.run(10)

tests/test_environment.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbaf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_negative_until">test_environment.py::test_run_negative_until</h3>
<details><summary> <pre>test_environment.py::test_run_negative_until</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e650>

    def test_run_negative_until(env):
        """Test passing a negative time to run."""
>       with pytest.raises(
            ValueError, match='must be greater than the current simulation time'
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_environment.py:26: Failed
</pre>
</details>
<h3 id="test_environmentpytest_run_resume">test_environment.py::test_run_resume</h3>
<details><summary> <pre>test_environment.py::test_run_resume</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98e080>

    def test_run_resume(env):
        """Stopped simulation can be resumed."""
        events = [env.timeout(t) for t in (5, 10, 15)]

        assert env.now == 0
        assert not any(event.processed for event in events)

>       env.run(until=10)

tests/test_environment.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98e080>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_until_value">test_environment.py::test_run_until_value</h3>
<details><summary> <pre>test_environment.py::test_run_until_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f0460>

    def test_run_until_value(env):
        """Anything that can be converted to a float is a valid until value."""
>       env.run(until='3.141592')

tests/test_environment.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f0460>, until = '3.141592'

    def run(self, until: Optional[Union[SimTime, Event]]=None) ->Optional[Any]:
        """Executes :meth:`step()` until the given criterion *until* is met.

        - If it is ``None`` (which is the default), this method will return
          when there are no further events to be processed.

        - If it is an :class:`~simpy.events.Event`, the method will continue
          stepping until this event has been triggered and will return its
          value.  Raises a :exc:`RuntimeError` if there are no further events
          to be processed and the *until* event was not triggered.

        - If it is a number, the method will continue stepping
          until the environment's time reaches *until*.

        """
        if until is None:
            while True:
                try:
                    self.step()
                except EmptySchedule:
                    return None
        elif isinstance(until, Event):
            until.callbacks.append(StopSimulation.callback)
            try:
                while not until.triggered:
                    self.step()
            except StopSimulation:
                return until.value
            except EmptySchedule:
                if not until.triggered:
                    raise RuntimeError('No scheduled events left but "until" event was not triggered')
        elif isinstance(until, (int, float)):
            try:
                while self._now < until:
                    self.step()
            except EmptySchedule:
                return None
        else:
>           raise ValueError('Invalid until parameter type')
E           ValueError: Invalid until parameter type

src/simpy/core.py:196: ValueError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_processed_event">test_environment.py::test_run_with_processed_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_processed_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987430>

    def test_run_with_processed_event(env):
        """An already processed event may also be passed as until value."""
        timeout = env.timeout(1, value='spam')
>       assert env.run(until=timeout) == 'spam'
E       AssertionError: assert None == 'spam'
E        +  where None = run(until=<Timeout(1, value='spam') object at 0x7f67a9984d90>)
E        +    where run = <simpy.core.Environment object at 0x7f67a9987430>.run

tests/test_environment.py:63: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_untriggered_event">test_environment.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d420>

    def test_run_with_untriggered_event(env):
        excinfo = pytest.raises(RuntimeError, env.run, until=env.event())
>       assert str(excinfo.value).startswith(
            'No scheduled events left but "until" event was not triggered:'
        )
E       assert False
E        +  where False = <built-in method startswith of str object at 0x7f67a99d3d70>('No scheduled events left but "until" event was not triggered:')
E        +    where <built-in method startswith of str object at 0x7f67a99d3d70> = 'No scheduled events left but "until" event was not triggered'.startswith
E        +      where 'No scheduled events left but "until" event was not triggered' = str(RuntimeError('No scheduled events left but "until" event was not triggered'))
E        +        where RuntimeError('No scheduled events left but "until" event was not triggered') = <ExceptionInfo RuntimeError('No scheduled events left but "until" event was not triggered') tblen=2>.value

tests/test_environment.py:75: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_succeed">test_event.py::test_succeed</h3>
<details><summary> <pre>test_event.py::test_succeed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985720>

    def test_succeed(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            value = yield event
            assert value == 'ohai'
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.succeed('ohai')

        env.process(parent(env))
>       env.run()

tests/test_event.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985720>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_fail">test_event.py::test_fail</h3>
<details><summary> <pre>test_event.py::test_fail</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def test_fail(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            with pytest.raises(ValueError, match='ohai'):
                yield event
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.fail(ValueError('ohai'))

        env.process(parent(env))
>       env.run()

tests/test_event.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_value">test_event.py::test_value</h3>
<details><summary> <pre>test_event.py::test_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f2830>

    def test_value(env):
        """After an event has been triggered, its value becomes accessible."""
        event = env.timeout(0, 'I am the value')

>       env.run()

tests/test_event.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f2830>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_unavailable_value">test_event.py::test_unavailable_value</h3>
<details><summary> <pre>test_event.py::test_unavailable_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

        with pytest.raises(AttributeError, match='.* is not yet available$'):
>           _ = event.value

tests/test_event.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Event() object at 0x7f67a9984d90>

    @property
    def value(self) ->Optional[Any]:
        """The value of the event if it is available.

        The value is available when the event has been triggered.

        Raises :exc:`AttributeError` if the value is not yet available.

        """
        if self._value is PENDING:
>           raise AttributeError('Value not yet available')
E           AttributeError: Value not yet available. Did you mean: '_value'?

src/simpy/events.py:132: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

>       with pytest.raises(AttributeError, match='.* is not yet available$'):
E       AssertionError: Regex pattern did not match.
E        Regex: '.* is not yet available$'
E        Input: 'Value not yet available'

tests/test_event.py:82: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_triggered">test_event.py::test_triggered</h3>
<details><summary> <pre>test_event.py::test_triggered</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04ec50>

    def test_triggered(env):
        def pem(env, event):
            value = yield event
            return value

        event = env.event()
        event.succeed('i was already done')

>       result = env.run(env.process(pem(env, event)))

tests/test_event.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04ec50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_callback_removal">test_event.py::test_condition_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667430>

    def test_condition_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events."""
        a, b = env.event(), env.event()
        a.succeed()
>       env.run(until=a | b)

tests/test_event.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_nested_callback_removal">test_event.py::test_condition_nested_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_nested_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99874c0>

    def test_condition_nested_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events (even
        if nested)."""
        a, b, c = env.event(), env.event(), env.event()
        b_and_c = b & c
        a_or_b_and_c = a | b_and_c
        a.succeed()
>       env.run(until=a_or_b_and_c)

tests/test_event.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99874c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_error_forwarding">test_exceptions.py::test_error_forwarding</h3>
<details><summary> <pre>test_exceptions.py::test_error_forwarding</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def test_error_forwarding(env):
        """Exceptions are forwarded from child to parent processes if there
        are any.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(child(env))

        env.process(parent(env))
>       env.run()

tests/test_exceptions.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_no_parent_process">test_exceptions.py::test_no_parent_process</h3>
<details><summary> <pre>test_exceptions.py::test_no_parent_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98cca0>

    def test_no_parent_process(env):
        """Exceptions should be normally raised if there are no processes waiting
        for the one that raises something.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            try:
                env.process(child(env))
                yield env.timeout(1)
            except Exception as err:
                pytest.fail(f'There should be no error ({err}).')

        env.process(parent(env))
        with pytest.raises(ValueError, match='Onoes!'):
>           env.run()

tests/test_exceptions.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98cca0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_crashing_child_traceback">test_exceptions.py::test_crashing_child_traceback</h3>
<details><summary> <pre>test_exceptions.py::test_crashing_child_traceback</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_crashing_child_traceback(env):
        def panic(env):
            yield env.timeout(1)
            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')

        def root(env):
            try:
                yield env.process(panic(env))
                pytest.fail("Hey, where's the roflcopter?")
            except RuntimeError:
                # The current frame must be visible in the stacktrace.
                stacktrace = traceback.format_exc()
                assert 'yield env.process(panic(env))' in stacktrace
                assert "raise RuntimeError('Oh noes," in stacktrace

        env.process(root(env))
>       env.run()

tests/test_exceptions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_chaining">test_exceptions.py::test_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c640>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
>           env.run()

tests/test_exceptions.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_invalid_event">test_exceptions.py::test_invalid_event</h3>
<details><summary> <pre>test_exceptions.py::test_invalid_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940d8a0>

    def test_invalid_event(env):
        """Invalid yield values will cause the simulation to fail."""

        def root(_):
            yield None

        env.process(root(env))
        with pytest.raises(RuntimeError, match='Invalid yield value "None"'):
>           env.run()

tests/test_exceptions.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940d8a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_handling">test_exceptions.py::test_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5240>

    def test_exception_handling(env):
        """If failed events are not defused (which is the default) the simulation
        crashes."""

        event = env.event()
        event.fail(RuntimeError())
        with pytest.raises(RuntimeError):
>           env.run(until=1)

tests/test_exceptions.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_callback_exception_handling">test_exceptions.py::test_callback_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_callback_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98d540>

    def test_callback_exception_handling(env):
        """Callbacks of events may handle exception by setting the ``defused``
        attribute of ``event`` to ``True``."""

        def callback(event):
            event.defused = True

        event = env.event()
        event.callbacks.append(callback)
        event.fail(RuntimeError())
        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98d540>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_handling">test_exceptions.py::test_process_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912ef0>

    def test_process_exception_handling(env):
        """Processes can't ignore failed events and auto-handle exceptions."""

        def pem(_, event):
            try:
                yield event
                pytest.fail('Hey, the event should fail!')
            except RuntimeError:
                pass

        event = env.event()
        env.process(pem(env, event))
        event.fail(RuntimeError())

        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912ef0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_chaining">test_exceptions.py::test_process_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5c60>

    def test_process_exception_chaining(env):
        """Because multiple processes can be waiting for an event, exceptions of
        failed events are copied before being thrown into a process. Otherwise, the
        traceback of the exception gets modified by a process.

        See https://bitbucket.org/simpy/simpy/issue/60 for more details."""
        import traceback

        def process_a(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_b' not in stacktrace

        def process_b(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_a' not in stacktrace

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_a(event))
        env.process(process_b(event))

>       env.run()

tests/test_exceptions.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_sys_excepthook">test_exceptions.py::test_sys_excepthook</h3>
<details><summary> <pre>test_exceptions.py::test_sys_excepthook</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
>           env.run()

tests/test_exceptions.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bab90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
            env.run()
        except BaseException:
            # Let the default exception hook print the traceback to the redirected
            # standard error channel.
            import sys
            from io import StringIO

            stderr, sys.stderr = sys.stderr, StringIO()

            typ, e, tb = sys.exc_info()
            assert typ is not None
            assert e is not None
            sys.excepthook(typ, e, tb)

            traceback = sys.stderr.getvalue()

            sys.stderr = stderr

            # Check if frames of process_a and process_b are visible in the
            # traceback.
>           assert 'process_a' in traceback
E           assert 'process_a' in 'Traceback (most recent call last):\n  File "/testbed/tests/test_exceptions.py", line 244, in test_sys_excepthook\n   ..._callback(event)\nAttributeError: \'Initialize\' object has no attribute \'_callback\'. Did you mean: \'callbacks\'?\n'

tests/test_exceptions.py:264: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_interruption">test_interrupts.py::test_interruption</h3>
<details><summary> <pre>test_interrupts.py::test_interruption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_interruption(env):
        """Processes can be interrupted while waiting for other events."""

        def interruptee(env):
            with pytest.raises(simpy.Interrupt, match='interrupt!'):
                yield env.timeout(10)

        def interruptor(env):
            child_process = env.process(interruptee(env))
            yield env.timeout(5)
            child_process.interrupt('interrupt!')

        env.process(interruptor(env))
>       env.run()

tests/test_interrupts.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts">test_interrupts.py::test_concurrent_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d13c0>, log = []

    def test_concurrent_interrupts(env, log):
        """Concurrent interrupts are scheduled in the order in which they
        occurred.

        """

        def fox(env, log):
            while True:
                try:
                    yield env.timeout(10)
                except simpy.Interrupt as interrupt:
                    log.append((env.now, interrupt.cause))

        def farmer(env, name, fox):
            fox.interrupt(name)
            yield env.timeout(1)

        fantastic_mr_fox = env.process(fox(env, log))
        for name in ('boggis', 'bunce', 'beans'):
            env.process(farmer(env, name, fantastic_mr_fox))

>       env.run(20)

tests/test_interrupts.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d13c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts_and_events">test_interrupts.py::test_concurrent_interrupts_and_events</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts_and_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb400>, log = []

    def test_concurrent_interrupts_and_events(env, log):
        """Interrupts interrupt a process while waiting for an event. Even if the
        event has happened concurrently with the interrupt."""

        def fox(env, coup, log):
            while True:
                try:
                    yield coup
                    log.append(f'coup completed at {env.now}')
                except simpy.Interrupt:
                    log.append(f'coup interrupted at {env.now}')
                else:
                    return

        def master_plan(env, fox, coup):
            yield env.timeout(1)
            # Succeed and interrupt concurrently.
            coup.succeed()
            fox.interrupt()

        coup = env.event()
        fantastic_mr_fox = env.process(fox(env, coup, log))
        env.process(master_plan(env, fantastic_mr_fox, coup))

>       env.run(5)

tests/test_interrupts.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_init_interrupt">test_interrupts.py::test_init_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_init_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def test_init_interrupt(env):
        """An interrupt should always be executed after the Initialize event at the
        same time."""

        def child(env):
            try:
                yield env.timeout(10)
                pytest.fail('Should have been interrupted.')
            except simpy.Interrupt:
                assert env.now == 0

        def root(env):
            child_proc = env.process(child(env))
            child_proc.interrupt()

            yield env.timeout(1)

        env.process(root(env))
>       env.run()

tests/test_interrupts.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_terminated_process">test_interrupts.py::test_interrupt_terminated_process</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_terminated_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def test_interrupt_terminated_process(env):
        """Dead processes cannot be interrupted."""

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))

            # Wait long enough so that child_proc terminates.
            yield env.timeout(2)
            ei = pytest.raises(RuntimeError, child_proc.interrupt)
            assert re.match(
                r'<Process\(child\) object at 0x.*> has terminated '
                r'and cannot be interrupted.',
                ei.value.args[0],
            )

            yield env.timeout(1)

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_multiple_interrupts">test_interrupts.py::test_multiple_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_multiple_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa109bd0>

    def test_multiple_interrupts(env):
        """Interrupts on dead processes are discarded. If there are multiple
        concurrent interrupts on a process and the latter dies after
        handling the first interrupt, the remaining ones are silently
        ignored.

        """

        def child(env):
            try:
                yield env.timeout(1)
            except simpy.Interrupt as i:
                return i.cause

        def parent(env):
            c = env.process(child(env))
            yield env.timeout(0)
            c.interrupt(1)
            c.interrupt(2)
            result = yield c
            assert result == 1

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa109bd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_self">test_interrupts.py::test_interrupt_self</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_self</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66bee0>

    def test_interrupt_self(env):
        """A process should not be able to interrupt itself."""

        def pem(env):
            pytest.raises(RuntimeError, env.active_process.interrupt)
            yield env.timeout(0)

        env.process(pem(env))
>       env.run()

tests/test_interrupts.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66bee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_immediate_interrupt">test_interrupts.py::test_immediate_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_immediate_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4223b0>, log = []

    def test_immediate_interrupt(env, log):
        """Processes are immediately interruptable."""

        def child(env, log):
            try:
                yield env.event()
            except simpy.Interrupt:
                log.append(env.now)

        def parent(env, log):
            child_proc = env.process(child(env, log))
            child_proc.interrupt()
            return
            yield

        env.process(parent(env, log))
>       env.run()

tests/test_interrupts.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4223b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_event">test_interrupts.py::test_interrupt_event</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940cac0>

    def test_interrupt_event(env):
        """A process should be interruptable while waiting for an Event."""

        def child(env):
            try:
                yield env.event()
            except simpy.Interrupt:
                assert env.now == 5

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(5)
            child_proc.interrupt()

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940cac0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_behaviour">test_interrupts.py::test_concurrent_behaviour</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_behaviour</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108280>

    def test_concurrent_behaviour(env):
        def proc_a(env):
            timeouts = [env.timeout(0) for i in range(2)]
            while timeouts:
                with pytest.raises(simpy.Interrupt):
                    yield timeouts.pop(0)

        def proc_b(_, proc_a):
            for _ in range(2):
                proc_a.interrupt()
            return
            yield

        proc_a = env.process(proc_a(env))
        env.process(proc_b(env, proc_a))

>       env.run()

tests/test_interrupts.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_get_state">test_process.py::test_get_state</h3>
<details><summary> <pre>test_process.py::test_get_state</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa423430>

    def test_get_state(env):
        """A process is alive until it's generator has not terminated."""

        def pem_a(env):
            yield env.timeout(3)

        def pem_b(env, pem_a):
            yield env.timeout(1)
            assert pem_a.is_alive

            yield env.timeout(3)
            assert not pem_a.is_alive

        proc_a = env.process(pem_a(env))
        env.process(pem_b(env, proc_a))
>       env.run()

tests/test_process.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa423430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_target">test_process.py::test_target</h3>
<details><summary> <pre>test_process.py::test_target</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3459c0>

    def test_target(env):
        def pem(env, event):
            yield event

        event = env.timeout(5)
        proc = env.process(pem(env, event))

        # Wait until "proc" is initialized and yielded the event
        while env.peek() < 5:
>           env.step()

tests/test_process.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3459c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_wait_for_proc">test_process.py::test_wait_for_proc</h3>
<details><summary> <pre>test_process.py::test_wait_for_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa9803a0>

    def test_wait_for_proc(env):
        """A process can wait until another process finishes."""

        def finisher(env):
            yield env.timeout(5)

        def waiter(env, finisher):
            proc = env.process(finisher(env))
            yield proc  # Waits until "proc" finishes

            assert env.now == 5

        env.process(waiter(env, finisher))
>       env.run()

tests/test_process.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa9803a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_return_value">test_process.py::test_return_value</h3>
<details><summary> <pre>test_process.py::test_return_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def test_return_value(env):
        """Processes can set a return value."""

        def child(env):
            yield env.timeout(1)
            return env.now

        def parent(env):
            result1 = yield env.process(child(env))
            result2 = yield env.process(child(env))

            assert [result1, result2] == [1, 2]

        env.process(parent(env))
>       env.run()

tests/test_process.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_child_exception">test_process.py::test_child_exception</h3>
<details><summary> <pre>test_process.py::test_child_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5690>

    def test_child_exception(env):
        """A child catches an exception and sends it to its parent."""

        def child(env):
            yield env.timeout(1)
            return RuntimeError('Onoes!')

        def parent(env):
            result = yield env.process(child(env))
            assert isinstance(result, Exception)

        env.process(parent(env))
>       env.run()

tests/test_process.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5690>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join">test_process.py::test_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94e95a0>

    def test_interrupted_join(env):
        """Interrupts remove a process from the callbacks of its target."""

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                # We should not get resumed when child terminates.
                yield env.timeout(5)
                assert env.now == 6

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94e95a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join_and_rejoin">test_process.py::test_interrupted_join_and_rejoin</h3>
<details><summary> <pre>test_process.py::test_interrupted_join_and_rejoin</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def test_interrupted_join_and_rejoin(env):
        """Tests that interrupts are raised while the victim is waiting for
        another process. The victim tries to join again.

        """

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                yield child_proc
                assert env.now == 2

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource">test_resources.py::test_resource</h3>
<details><summary> <pre>test_resources.py::test_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa664df0>, log = []

    def test_resource(env, log):
        """A *resource* is something with a limited numer of slots that need
        to be requested before and released after the usage (e.g., gas pumps
        at a gas station).

        """

        def pem(env, name, resource, log):
            req = resource.request()
            yield req
            assert resource.count == 1

            yield env.timeout(1)
            resource.release(req)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        assert resource.capacity == 1
        assert resource.count == 0
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa664df0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_context_manager">test_resources.py::test_resource_context_manager</h3>
<details><summary> <pre>test_resources.py::test_resource_context_manager</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e500>, log = []

    def test_resource_context_manager(env, log):
        """The event that ``Resource.request()`` returns can be used as
        Context Manager."""

        def pem(env, name, resource, log):
            with resource.request() as request:
                yield request
                yield env.timeout(1)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940e500>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_slots">test_resources.py::test_resource_slots</h3>
<details><summary> <pre>test_resources.py::test_resource_slots</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa665f30>, log = []

    def test_resource_slots(env, log):
        def pem(env, name, resource, log):
            with resource.request() as req:
                yield req
                log.append((name, env.now))
                yield env.timeout(1)

        resource = simpy.Resource(env, capacity=3)
        for i in range(9):
            env.process(pem(env, str(i), resource, log))
>       env.run()

tests/test_resources.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa665f30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_continue_after_interrupt">test_resources.py::test_resource_continue_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_continue_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def test_resource_continue_after_interrupt(env):
        """A process may be interrupted while waiting for a resource but
        should be able to continue waiting afterwards."""

        def pem(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                yield evt
                res.release(evt)
                assert env.now == 1

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(pem(env, res))
        proc = env.process(victim(env, res))
        env.process(interruptor(proc))
>       env.run()

tests/test_resources.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_release_after_interrupt">test_resources.py::test_resource_release_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_release_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667850>

    def test_resource_release_after_interrupt(env):
        """A process needs to release a resource, even if it was interrupted
        and does not continue to wait for it."""

        def blocker(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                # Don't wait for the resource
                res.release(evt)
                assert env.now == 0

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(blocker(env, res))
        victim_proc = env.process(victim(env, res))
        env.process(interruptor(victim_proc))
>       env.run()

tests/test_resources.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667850>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_immediate_requests">test_resources.py::test_resource_immediate_requests</h3>
<details><summary> <pre>test_resources.py::test_resource_immediate_requests</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945e3b0>

    def test_resource_immediate_requests(env):
        """A process must not acquire a resource if it releases it and immediately
        requests it again while there are already other requesting processes."""

        def child(env, res):
            result = []
            for _ in range(3):
                with res.request() as req:
                    yield req
                    result.append(env.now)
                    yield env.timeout(1)
            return result

        def parent(env):
            res = simpy.Resource(env, 1)
            child_a = env.process(child(env, res))
            child_b = env.process(child(env, res))

            a_acquire_times = yield child_a
            b_acquire_times = yield child_b

            assert a_acquire_times == [0, 2, 4]
            assert b_acquire_times == [1, 3, 5]

        env.process(parent(env))
>       env.run()

tests/test_resources.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945e3b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_cm_exception">test_resources.py::test_resource_cm_exception</h3>
<details><summary> <pre>test_resources.py::test_resource_cm_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345a20>, log = []

    def test_resource_cm_exception(env, log):
        """Resource with context manager receives an exception."""

        def process(env, resource, log, raise_):
            with resource.request() as req:
                yield req
                yield env.timeout(1)
                log.append(env.now)
                if raise_:
                    with pytest.raises(ValueError, match='Foo'):
                        raise ValueError('Foo')

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource, log, True))
        # The second process is used to check if it was able to access the
        # resource:
        env.process(process(env, resource, log, False))
>       env.run()

tests/test_resources.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345a20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_condition">test_resources.py::test_resource_with_condition</h3>
<details><summary> <pre>test_resources.py::test_resource_with_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945dc60>

    def test_resource_with_condition(env):
        def process(env, resource):
            with resource.request() as res_event:
                result = yield res_event | env.timeout(1)
                assert res_event in result

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945dc60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_priority_queue">test_resources.py::test_resource_with_priority_queue</h3>
<details><summary> <pre>test_resources.py::test_resource_with_priority_queue</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d0460>

    def test_resource_with_priority_queue(env):
        def process(env, delay, resource, priority, res_time):
            yield env.timeout(delay)
            req = resource.request(priority=priority)
            yield req
            assert env.now == res_time
            yield env.timeout(5)
            resource.release(req)

        resource = simpy.PriorityResource(env, capacity=1)
        env.process(process(env, 0, resource, 2, 0))
        env.process(process(env, 2, resource, 3, 10))
        env.process(process(env, 2, resource, 3, 15))  # Test equal priority
        env.process(process(env, 4, resource, 1, 5))
>       env.run()

tests/test_resources.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d0460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_sorted_queue_maxlen">test_resources.py::test_sorted_queue_maxlen</h3>
<details><summary> <pre>test_resources.py::test_sorted_queue_maxlen</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945c100>

    def test_sorted_queue_maxlen(env):
        """Requests must fail if more than *maxlen* requests happen
        concurrently."""
        resource = simpy.PriorityResource(env, capacity=1)
        resource.put_queue.maxlen = 1  # pyright: ignore

        def process(env, resource):
            # The first request immediately triggered and does not enter the queue.
            resource.request(priority=1)
            # The second request is enqueued.
            resource.request(priority=1)
            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):
                # The third request will now fail.
                resource.request(priority=1)
            yield env.timeout(0)

        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945c100>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_get_users">test_resources.py::test_get_users</h3>
<details><summary> <pre>test_resources.py::test_get_users</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa666d10>

    def test_get_users(env):
        def process(env, resource):
            with resource.request() as req:
                yield req
                yield env.timeout(1)

        resource = simpy.Resource(env, 1)
        procs = [env.process(process(env, resource)) for _ in range(3)]
>       env.run(until=1)

tests/test_resources.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa666d10>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource">test_resources.py::test_preemptive_resource</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_preemptive_resource(env):
        """Processes with a higher priority may preempt requests of lower priority
        processes. Note that higher priorities are indicated by a lower number
        value."""

        def proc_a(_, resource, prio):
            try:
                with resource.request(priority=prio) as req:
                    yield req
                    pytest.fail('Should have received an interrupt/preemption.')
            except simpy.Interrupt:
                pass

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource_timeout_0">test_resources.py::test_preemptive_resource_timeout_0</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource_timeout_0</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def test_preemptive_resource_timeout_0(env):
        def proc_a(env, resource, prio):
            with resource.request(priority=prio) as req:
                try:
                    yield req
                    yield env.timeout(1)
                    pytest.fail('Should have received an interrupt/preemption.')
                except simpy.Interrupt:
                    pass
            yield env.event()

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_mixed_preemption">test_resources.py::test_mixed_preemption</h3>
<details><summary> <pre>test_resources.py::test_mixed_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945f460>, log = []

    def test_mixed_preemption(env, log):
        def p(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(2)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert ir is not None  # noqa: PT017
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        res = simpy.PreemptiveResource(env, 1)
        # p0: First user:
        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))
        # p1: Waits (cannot preempt):
        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))
        # p2: Waits later, but has a higher prio:
        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))
        # p3: Preempt the above proc:
        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))
        # p4: Wait again:
        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))

>       env.run()

tests/test_resources.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945f460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_nested_preemption">test_resources.py::test_nested_preemption</h3>
<details><summary> <pre>test_resources.py::test_nested_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa10aec0>, log = []

    def test_nested_preemption(env, log):
        def process(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(5)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        def process2(id, env, res0, res1, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res0.request(priority=prio, preempt=preempt) as req0:
                try:
                    yield req0
                    with res1.request(priority=prio, preempt=preempt) as req1:
                        try:
                            yield req1
                            yield env.timeout(5)
                            log.append((env.now, id))
                        except simpy.Interrupt as ir:
                            assert isinstance(ir.cause, Preempted)  # noqa: PT017
                            log.append(
                                (
                                    env.now,
                                    id,
                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                                )
                            )
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append(
                        (
                            env.now,
                            id,
                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                        )
                    )

        res0 = simpy.PreemptiveResource(env, 1)
        res1 = simpy.PreemptiveResource(env, 1)

        env.process(process2(0, env, res0, res1, 0, -1, True, log))
        p1 = env.process(process(1, env, res1, 1, -2, True, log))

        env.process(process2(2, env, res0, res1, 20, -1, True, log))
        p3 = env.process(process(3, env, res0, 21, -2, True, log))

        env.process(process2(4, env, res0, res1, 21, -1, True, log))

>       env.run()

tests/test_resources.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa10aec0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container">test_resources.py::test_container</h3>
<details><summary> <pre>test_resources.py::test_container</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9178d30>, log = []

    def test_container(env, log):
        """A *container* is a resource (of optionally limited capacity) where
        you can put in our take-out a discrete or continuous amount of
        things (e.g., a box of lump sugar or a can of milk).  The *put* and
        *get* operations block if the buffer is to full or to empty. If they
        return, the process knows that the *put* or *get* operation was
        successful.

        """

        def putter(env, buf, log):
            yield env.timeout(1)
            while True:
                yield buf.put(2)
                log.append(('p', env.now))
                yield env.timeout(1)

        def getter(env, buf, log):
            yield buf.get(1)
            log.append(('g', env.now))

            yield env.timeout(1)
            yield buf.get(1)
            log.append(('g', env.now))

        buf = simpy.Container(env, init=0, capacity=2)
        env.process(putter(env, buf, log))
        env.process(getter(env, buf, log))
>       env.run(until=5)

tests/test_resources.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9178d30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container_get_queued">test_resources.py::test_container_get_queued</h3>
<details><summary> <pre>test_resources.py::test_container_get_queued</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04cf40>

    def test_container_get_queued(env):
        def proc(env, wait, container, what):
            yield env.timeout(wait)
            with getattr(container, what)(1) as req:
                yield req

        container = simpy.Container(env, 1)
        p0 = env.process(proc(env, 0, container, 'get'))
        env.process(proc(env, 1, container, 'put'))
        env.process(proc(env, 1, container, 'put'))
        p3 = env.process(proc(env, 1, container, 'put'))

>       env.run(until=1)

tests/test_resources.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04cf40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store">test_resources.py::test_store</h3>
<details><summary> <pre>test_resources.py::test_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_store(env):
        """A store models the production and consumption of concrete python
        objects (in contrast to containers, where you only now if the *put*
        or *get* operations were successful but don't get concrete
        objects).

        """

        def putter(_, store, item):
            yield store.put(item)

        def getter(_, store, orig_item):
            item = yield store.get()
            assert item is orig_item

        store = simpy.Store(env, capacity=2)
        item = object()

        # NOTE: Does the start order matter? Need to test this.
        env.process(putter(env, store, item))
        env.process(getter(env, store, item))
>       env.run()

tests/test_resources.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_capacity">test_resources.py::test_store_capacity</h3>
<details><summary> <pre>test_resources.py::test_store_capacity</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def test_store_capacity(env):
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, 0)
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, -1)

        capacity = 2
        store = simpy.Store(env, capacity)
        env.process(store.put(i) for i in range(capacity + 1))
>       env.run()

tests/test_resources.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_cancel">test_resources.py::test_store_cancel</h3>
<details><summary> <pre>test_resources.py::test_store_cancel</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940c520>

    def test_store_cancel(env):
        store = simpy.Store(env, capacity=1)

        def acquire_implicit_cancel():
            with store.get():
                yield env.timeout(1)
                # implicit cancel() when exiting with-block

        env.process(acquire_implicit_cancel())
>       env.run()

tests/test_resources.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940c520>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_item_priority">test_resources.py::test_priority_store_item_priority</h3>
<details><summary> <pre>test_resources.py::test_priority_store_item_priority</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980070>

    def test_priority_store_item_priority(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            item = yield pstore.get()
            log.append(item)

        # Do not specify priority; the items themselves will be compared to
        # determine priority.
        env.process(pstore.put(s) for s in 'bcadefg')
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980070>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_stable_order">test_resources.py::test_priority_store_stable_order</h3>
<details><summary> <pre>test_resources.py::test_priority_store_stable_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbee0>

    def test_priority_store_stable_order(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            _, item = yield pstore.get()
            log.append(item)

        items = [object() for _ in range(3)]

        # Unorderable items are inserted with same priority.
        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store">test_resources.py::test_filter_store</h3>
<details><summary> <pre>test_resources.py::test_filter_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91950c0>

    def test_filter_store(env):
        def pem(env):
            store = simpy.FilterStore(env, capacity=2)

            get_event = store.get(lambda item: item == 'b')
            yield store.put('a')
            assert not get_event.triggered
            yield store.put('b')
            assert get_event.triggered

        env.process(pem(env))
>       env.run()

tests/test_resources.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91950c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store_get_after_mismatch">test_resources.py::test_filter_store_get_after_mismatch</h3>
<details><summary> <pre>test_resources.py::test_filter_store_get_after_mismatch</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d4910>

    def test_filter_store_get_after_mismatch(env):
        """Regression test for issue #49.

        Triggering get-events after a put in FilterStore wrongly breaks after the
        first mismatch.

        """

        def putter(env, store):
            # The order of putting 'spam' before 'eggs' is important here.
            yield store.put('spam')
            yield env.timeout(1)
            yield store.put('eggs')

        def getter(store):
            # The order of requesting 'eggs' before 'spam' is important here.
            eggs = store.get(lambda i: i == 'eggs')
            spam = store.get(lambda i: i == 'spam')

            ret = yield spam | eggs
            assert spam in ret
            assert eggs not in ret
            assert env.now == 0

            yield eggs
            assert env.now == 1

        store = simpy.FilterStore(env, capacity=2)
        env.process(getter(store))
        env.process(putter(env, store))
>       env.run()

tests/test_resources.py:663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_best_case">test_resources.py::test_filter_calls_best_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_best_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980790>

    def test_filter_calls_best_case(env):
        """The filter function is called every item in the store until a match is
        found. In the best case the first item already matches."""
        log = []

        def log_filter(item):
            log.append(f'check {item}')
            return True

        store = simpy.FilterStore(env)
        store.items = [1, 2, 3]

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
>       env.run()

tests/test_resources.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980790>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_worst_case">test_resources.py::test_filter_calls_worst_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_worst_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1600>

    def test_filter_calls_worst_case(env):
        """In the worst case the filter function is being called for items multiple
        times."""

        log = []
        store = simpy.FilterStore(env)

        def putter(store):
            for i in range(4):
                log.append(f'put {i}')
                yield store.put(i)

        def log_filter(item):
            log.append(f'check {item}')
            return item >= 3

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
        env.process(putter(store))
>       env.run()

tests/test_resources.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1600>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_put_request">test_resources.py::test_immediate_put_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_put_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d4b80>

    def test_immediate_put_request(env):
        """Put requests that can be fulfilled immediately do not enter the put
        queue."""
        resource = simpy.Resource(env, capacity=1)
        assert len(resource.users) == 0
        assert len(resource.queue) == 0

        # The resource is empty, the first request will succeed immediately without
        # entering the queue.
>       request = resource.request()

tests/test_resources.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/resource.py:74: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.resource.Resource object at 0x7f67aa2d5420>
event = <Event() object at 0x7f67aa2d55d0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_get_request">test_resources.py::test_immediate_get_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_get_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9910af0>

    def test_immediate_get_request(env):
        """Get requests that can be fulfilled immediately do not enter the get
        queue."""
        container = simpy.Container(env)
        # Put something in the container, this request is triggered immediately
        # without entering the queue.
>       request = container.put(1)

tests/test_resources.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/container.py:30: in __init__
    super().__init__(container)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7f67a9912bc0>
event = <Event() object at 0x7f67a9913700>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_rtpytest_rt01">test_rt.py::test_rt[0.1]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.1]</pre></summary><pre>
log = [], factor = 0.1

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444250>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt005">test_rt.py::test_rt[0.05]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.05]</pre></summary><pre>
log = [], factor = 0.05

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9197580>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt015">test_rt.py::test_rt[0.15]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.15]</pre></summary><pre>
log = [], factor = 0.15

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a99b8190>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_multiple_call">test_rt.py::test_rt_multiple_call</h3>
<details><summary> <pre>test_rt.py::test_rt_multiple_call</pre></summary><pre>
log = []

    def test_rt_multiple_call(log):
        """Test multiple calls to run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05)

        env.process(process(env, log, 0.01, 2))
        env.process(process(env, log, 0.01, 3))

>       env.run(5)

tests/test_rt.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67aa2d7d00>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_default_behavior">test_rt.py::test_rt_slow_sim_default_behavior</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_default_behavior</pre></summary><pre>
log = []

    def test_rt_slow_sim_default_behavior(log):
        """By default, SimPy should raise an error if a simulation is too
        slow for the selected real-time factor."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.1, 1))

        err = pytest.raises(RuntimeError, env.run, 3)
>       assert 'Simulation too slow for real time' in str(err.value)
E       AssertionError: assert 'Simulation too slow for real time' in 'Simulation too slow: 0.000 seconds late'
E        +  where 'Simulation too slow: 0.000 seconds late' = str(RuntimeError('Simulation too slow: 0.000 seconds late'))
E        +    where RuntimeError('Simulation too slow: 0.000 seconds late') = <ExceptionInfo RuntimeError('Simulation too slow: 0.000 seconds late') tblen=3>.value

tests/test_rt.py:68: AssertionError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_no_error">test_rt.py::test_rt_slow_sim_no_error</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_no_error</pre></summary><pre>
log = []

    def test_rt_slow_sim_no_error(log):
        """Test ignoring slow simulations."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05, strict=False)
        env.process(process(env, log, 0.1, 1))

>       env.run(2)

tests/test_rt.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
src/simpy/rt.py:76: in step
    super().step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a94796c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_rtpytest_rt_illegal_until">test_rt.py::test_rt_illegal_until</h3>
<details><summary> <pre>test_rt.py::test_rt_illegal_until</pre></summary><pre>
def test_rt_illegal_until():
        """Test illegal value for *until*."""
        env = RealtimeEnvironment()
>       with pytest.raises(
            ValueError,
            match=r'until \(-1\) must be greater than the current simulation time',
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_rt.py:88: Failed
</pre>
</details>
<h3 id="test_rtpytest_rt_sync">test_rt.py::test_rt_sync</h3>
<details><summary> <pre>test_rt.py::test_rt_sync</pre></summary><pre>
log = []

    def test_rt_sync(log):
        """Test resetting the internal wall-clock reference time."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.01))
        sleep(0.06)  # Simulate massive workload :-)
        env.sync()
>       env.run(3)

tests/test_rt.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444b80>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_run_with_untriggered_event">test_rt.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_rt.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def test_run_with_untriggered_event(env):
        env = RealtimeEnvironment(factor=0.05)
>       excinfo = pytest.raises(RuntimeError, env.run, until=env.event())

tests/test_rt.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
>           sleep(expected_real_time - real_time)
E           OverflowError: timestamp too large to convert to C _PyTime_t

src/simpy/rt.py:72: OverflowError
</pre>
</details>
<h3 id="test_timeoutpytest_discrete_time_steps">test_timeout.py::test_discrete_time_steps</h3>
<details><summary> <pre>test_timeout.py::test_discrete_time_steps</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbfa0>, log = []

    def test_discrete_time_steps(env, log):
        """envple envulation with discrete time steps."""

        def pem(env, log):
            while True:
                log.append(env.now)
                yield env.timeout(delay=1)

        env.process(pem(env, log))
>       env.run(until=3)

tests/test_timeout.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbfa0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_negative_timeout">test_timeout.py::test_negative_timeout</h3>
<details><summary> <pre>test_timeout.py::test_negative_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91767a0>

    def test_negative_timeout(env):
        """Don't allow negative timeout times."""

        def pem(env):
            yield env.timeout(-1)

        env.process(pem(env))
        with pytest.raises(ValueError, match='Negative delay'):
>           env.run()

tests/test_timeout.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91767a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_timeout_value">test_timeout.py::test_timeout_value</h3>
<details><summary> <pre>test_timeout.py::test_timeout_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ae140>

    def test_timeout_value(env):
        """You can pass an additional *value* to *timeout* which will be
        directly yielded back into the PEM. This is useful to implement some
        kinds of resources or other additions.

        See :class:`envpy.resources.Store` for an example.

        """

        def pem(env):
            val = yield env.timeout(1, 'ohai')
            assert val == 'ohai'

        env.process(pem(env))
>       env.run()

tests/test_timeout.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ae140>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_shared_timeout">test_timeout.py::test_shared_timeout</h3>
<details><summary> <pre>test_timeout.py::test_shared_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9174130>, log = []

    def test_shared_timeout(env, log):
        def child(env, timeout, id, log):
            yield timeout
            log.append((id, env.now))

        timeout = env.timeout(1)
        for i in range(3):
            env.process(child(env, timeout, i, log))

>       env.run()

tests/test_timeout.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9174130>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_triggered_timeout">test_timeout.py::test_triggered_timeout</h3>
<details><summary> <pre>test_timeout.py::test_triggered_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ac880>

    def test_triggered_timeout(env):
        def process(env):
            def child(env, event):
                value = yield event
                return value

            event = env.timeout(1, 'i was already done')
            # Start the child after the timeout has already happened.
            yield env.timeout(2)
            value = yield env.process(child(env, event))
            assert value == 'i was already done'

>       env.run(env.process(process(env)))

tests/test_timeout.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ac880>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_start_delayed">test_util.py::test_start_delayed</h3>
<details><summary> <pre>test_util.py::test_start_delayed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb550>

    def test_start_delayed(env):
        def pem(env):
            assert env.now == 5
            yield env.timeout(1)

        start_delayed(env, pem(env), delay=5)
>       env.run()

tests/test_util.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb550>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe">test_util.py::test_subscribe</h3>
<details><summary> <pre>test_util.py::test_subscribe</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def test_subscribe(env):
        """Check async. interrupt if a process terminates."""

        def child(env):
            yield env.timeout(3)
            return 'ohai'

        def parent(env):
            child_proc = env.process(child(env))
            subscribe_at(child_proc)

            try:
                yield env.event()
            except Interrupt as interrupt:
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc  # noqa: PT017
                assert interrupt.cause[1] == 'ohai'  # noqa: PT017
                assert env.now == 3

        env.process(parent(env))
>       env.run()

tests/test_util.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_terminated_proc">test_util.py::test_subscribe_terminated_proc</h3>
<details><summary> <pre>test_util.py::test_subscribe_terminated_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985cf0>

    def test_subscribe_terminated_proc(env):
        """subscribe() proc should send a signal immediately if
        "other" has already terminated.

        """

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(2)
            pytest.raises(RuntimeError, subscribe_at, child_proc)

        env.process(parent(env))
>       env.run()

tests/test_util.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985cf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_with_join">test_util.py::test_subscribe_with_join</h3>
<details><summary> <pre>test_util.py::test_subscribe_with_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447a90>

    def test_subscribe_with_join(env):
        """Test that subscribe() works if a process waits for another one."""

        def child(env, i):
            yield env.timeout(i)

        def parent(env):
            child_proc1 = env.process(child(env, 1))
            child_proc2 = env.process(child(env, 2))
            try:
                subscribe_at(child_proc1)
                yield child_proc2
            except Interrupt as interrupt:
                assert env.now == 1
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc1  # noqa: PT017
                assert child_proc2.is_alive

        env.process(parent(env))
>       env.run()

tests/test_util.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447a90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout">test_util.py::test_subscribe_at_timeout</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9482440>

    def test_subscribe_at_timeout(env):
        """You should be able to subscribe at arbitrary events."""

        def pem(env):
            to = env.timeout(2)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, None)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9482440>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout_with_value">test_util.py::test_subscribe_at_timeout_with_value</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout_with_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91749d0>

    def test_subscribe_at_timeout_with_value(env):
        """An event's value should be accessible via the interrupt cause."""

        def pem(env):
            val = 'ohai'
            to = env.timeout(2, value=val)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, val)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91749d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of">test_util.py::test_all_of</h3>
<details><summary> <pre>test_util.py::test_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a948b6a0>

    def test_all_of(env):
        """Wait for all events to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.all_of(events)

            assert results == {events[i]: i for i in range(10)}
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a948b6a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_generator">test_util.py::test_all_of_generator</h3>
<details><summary> <pre>test_util.py::test_all_of_generator</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108670>

    def test_all_of_generator(env):
        """Conditions also work with generators."""

        def parent(env):
            # Start 10 events.
            events = (env.timeout(i, value=i) for i in range(10))
            results = yield env.all_of(events)

            assert list(results.values()) == list(range(10))
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108670>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_wait_for_all_with_errors">test_util.py::test_wait_for_all_with_errors</h3>
<details><summary> <pre>test_util.py::test_wait_for_all_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f2740>

    def test_wait_for_all_with_errors(env):
        """On default AllOf should fail immediately if one of its events
        fails."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [
                env.timeout(1, value=1),
                env.process(child_with_error(env, 2)),
                env.timeout(3, value=3),
            ]

            condition = env.all_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            # Although the condition has failed, interim values are available.
            assert condition._events[0].value == 1
            assert condition._events[1].value.args[0] == 'crashing'
            # The last child has not terminated yet.
            assert not events[2].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f2740>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining">test_util.py::test_all_of_chaining</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def test_all_of_chaining(env):
        """If a wait_for_all condition A is chained to a wait_for_all condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            condition_a &= condition_b

            results = yield condition_a
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining_intermediate_results">test_util.py::test_all_of_chaining_intermediate_results</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining_intermediate_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b4910>

    def test_all_of_chaining_intermediate_results(env):
        """If a wait_for_all condition A with intermediate results is merged into
        another wait_for_all condition B, the results are copied into condition
        A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            yield env.timeout(0)

            condition = condition_a & condition_b
            result = ConditionValue()
            condition._populate_value(result)
            assert list(result.values()) == [0, 0]

            results = yield condition
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_with_triggered_events">test_util.py::test_all_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_all_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9197490>

    def test_all_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.all_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9197490>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of">test_util.py::test_any_of</h3>
<details><summary> <pre>test_util.py::test_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447730>

    def test_any_of(env):
        """Wait for any event to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.any_of(events)

            assert results == {events[0]: 0}
            assert env.now == 0

        env.process(parent(env))
>       env.run()

tests/test_util.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447730>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_errors">test_util.py::test_any_of_with_errors</h3>
<details><summary> <pre>test_util.py::test_any_of_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f19f0>

    def test_any_of_with_errors(env):
        """On default any_of should fail if the event has failed too."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]
            condition = env.any_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            assert condition._events[0].value.args[0] == 'crashing'
            # The last event has not terminated yet.
            assert not events[1].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f19f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_chaining">test_util.py::test_any_of_chaining</h3>
<details><summary> <pre>test_util.py::test_any_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9489d50>

    def test_any_of_chaining(env):
        """If a any_of condition A is chained to a any_of condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.any_of([env.timeout(2, value='a')])
            condition_b = env.any_of([env.timeout(1, value='b')])

            condition_a |= condition_b

            results = yield condition_a
            assert list(results.values()) == ['b']

        env.process(parent(env))
>       env.run()

tests/test_util.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9489d50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_triggered_events">test_util.py::test_any_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_any_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9181d20>

    def test_any_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.any_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9181d20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_any_of">test_util.py::test_empty_any_of</h3>
<details><summary> <pre>test_util.py::test_empty_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9175de0>

    def test_empty_any_of(env):
        """AnyOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.any_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9175de0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_all_of">test_util.py::test_empty_all_of</h3>
<details><summary> <pre>test_util.py::test_empty_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b7280>

    def test_empty_all_of(env):
        """AllOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.all_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b7280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_expansion">test_util.py::test_all_of_expansion</h3>
<details><summary> <pre>test_util.py::test_all_of_expansion</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985240>

    def test_all_of_expansion(env):
        """The result of AllOf is an OrderedDict, which allows to expand its values
        directly into variables."""

        def p(env):
            timeouts = [env.timeout(d, d) for d in [3, 2, 1]]
            a, b, c = (yield env.all_of(timeouts)).values()
            assert a == 3
            assert b == 2
            assert c == 1

        env.process(p(env))
>       env.run()

tests/test_util.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>

<h2 id="failed-to-run-pytests">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:7: in &lt;module&gt;
    from tinydb.middlewares import CachingMiddleware
tinydb/__init__.py:27: in &lt;module&gt;
    from .queries import Query, where
tinydb/queries.py:21: in &lt;module&gt;
    from .utils import freeze
tinydb/utils.py:84: in &lt;module&gt;
    class FrozenDict(dict):
tinydb/utils.py:95: in FrozenDict
    __setitem__ = _immutable
E   NameError: name &#39;_immutable&#39; is not defined
</code></pre></div>
<h2 id="failed-to-run-pytests_1">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from tests.base import Blog, User, UserSchema
tests/base.py:11: in &lt;module&gt;
    from marshmallow import Schema, fields, missing, post_load, validate
src/marshmallow/__init__.py:17: in &lt;module&gt;
    from marshmallow.schema import Schema, SchemaOpts
src/marshmallow/schema.py:15: in &lt;module&gt;
    from marshmallow import fields as ma_fields
src/marshmallow/fields.py:18: in &lt;module&gt;
    from marshmallow.utils import is_aware, is_collection, resolve_field_instance
E   ImportError: cannot import name &#39;is_aware&#39; from &#39;marshmallow.utils&#39; (/testbed/src/marshmallow/utils.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/marshmallow/class_registry.py b/src/marshmallow/class_registry.py</span>
<span class="gh">index 249b898..a7b38e8 100644</span>
<span class="gd">--- a/src/marshmallow/class_registry.py</span>
<span class="gi">+++ b/src/marshmallow/class_registry.py</span>
<span class="gu">@@ -35,14 +35,29 @@ def register(classname: str, cls: SchemaType) -&gt;None:</span>
<span class="w"> </span>        # }

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _registry</span>
<span class="gi">+    _registry[classname] = [cls]</span>
<span class="gi">+    _registry[f&quot;{cls.__module__}.{cls.__name__}&quot;] = [cls]</span>


<span class="gd">-def get_class(classname: str, all: bool=False) -&gt;(list[SchemaType] | SchemaType</span>
<span class="gd">-    ):</span>
<span class="gi">+def get_class(classname: str, all: bool=False) -&gt;(list[SchemaType] | SchemaType):</span>
<span class="w"> </span>    &quot;&quot;&quot;Retrieve a class from the registry.

<span class="w"> </span>    :raises: marshmallow.exceptions.RegistryError if the class cannot be found
<span class="w"> </span>        or if there are multiple entries for the given class name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        classes = _registry[classname]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        raise RegistryError(f&quot;Class with name {classname!r} was not found.&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if all:</span>
<span class="gi">+        return classes</span>
<span class="gi">+    </span>
<span class="gi">+    if len(classes) &gt; 1:</span>
<span class="gi">+        raise RegistryError(</span>
<span class="gi">+            f&quot;Multiple classes with name {classname!r} were found. &quot;</span>
<span class="gi">+            &quot;Please use the full, module-qualified path.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    </span>
<span class="gi">+    return classes[0]</span>
<span class="gh">diff --git a/src/marshmallow/decorators.py b/src/marshmallow/decorators.py</span>
<span class="gh">index d78f5be..e2944df 100644</span>
<span class="gd">--- a/src/marshmallow/decorators.py</span>
<span class="gi">+++ b/src/marshmallow/decorators.py</span>
<span class="gu">@@ -84,7 +84,13 @@ def validates(field_name: str) -&gt;Callable[..., Any]:</span>

<span class="w"> </span>    :param str field_name: Name of the field that the method validates.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(fn):</span>
<span class="gi">+        @functools.wraps(fn)</span>
<span class="gi">+        def wrapper(self, value, **kwargs):</span>
<span class="gi">+            return fn(self, value, **kwargs)</span>
<span class="gi">+        wrapper.__marshmallow_hook__ = {VALIDATES: field_name}</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=
<span class="gu">@@ -109,7 +115,25 @@ def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fn is None:</span>
<span class="gi">+        return functools.partial(</span>
<span class="gi">+            validates_schema,</span>
<span class="gi">+            pass_many=pass_many,</span>
<span class="gi">+            pass_original=pass_original,</span>
<span class="gi">+            skip_on_field_errors=skip_on_field_errors,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @functools.wraps(fn)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        return fn(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    wrapper.__marshmallow_hook__ = {</span>
<span class="gi">+        (VALIDATES_SCHEMA, pass_many): {</span>
<span class="gi">+            &#39;pass_original&#39;: pass_original,</span>
<span class="gi">+            &#39;skip_on_field_errors&#39;: skip_on_field_errors,</span>
<span class="gi">+        }</span>
<span class="gi">+    }</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False
<span class="gu">@@ -124,7 +148,7 @@ def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        ``many`` is always passed as a keyword arguments to the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (PRE_DUMP, pass_many))</span>


<span class="w"> </span>def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,
<span class="gu">@@ -142,7 +166,7 @@ def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        ``many`` is always passed as a keyword arguments to the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (POST_DUMP, pass_many), pass_original=pass_original)</span>


<span class="w"> </span>def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False
<span class="gu">@@ -158,7 +182,7 @@ def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (PRE_LOAD, pass_many))</span>


<span class="w"> </span>def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,
<span class="gu">@@ -177,7 +201,7 @@ def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,</span>
<span class="w"> </span>        ``partial`` and ``many`` are always passed as keyword arguments to
<span class="w"> </span>        the decorated method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hook(fn, (POST_LOAD, pass_many), pass_original=pass_original)</span>


<span class="w"> </span>def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),
<span class="gu">@@ -192,4 +216,11 @@ def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),</span>
<span class="w"> </span>    :return: Decorated function if supplied, else this decorator with its args
<span class="w"> </span>        bound.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        func.__marshmallow_hook__ = {key: kwargs or True}</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    if fn is None:</span>
<span class="gi">+        return decorator</span>
<span class="gi">+    else:</span>
<span class="gi">+        return decorator(fn)</span>
<span class="gh">diff --git a/src/marshmallow/error_store.py b/src/marshmallow/error_store.py</span>
<span class="gh">index a659aaf..d5a60d5 100644</span>
<span class="gd">--- a/src/marshmallow/error_store.py</span>
<span class="gi">+++ b/src/marshmallow/error_store.py</span>
<span class="gu">@@ -13,6 +13,16 @@ class ErrorStore:</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.errors = {}

<span class="gi">+    def store_error(self, field_name, error):</span>
<span class="gi">+        &quot;&quot;&quot;Store an error message for a field.&quot;&quot;&quot;</span>
<span class="gi">+        if field_name not in self.errors:</span>
<span class="gi">+            self.errors[field_name] = []</span>
<span class="gi">+        self.errors[field_name].append(error)</span>
<span class="gi">+</span>
<span class="gi">+    def get_errors(self):</span>
<span class="gi">+        &quot;&quot;&quot;Return all stored errors.&quot;&quot;&quot;</span>
<span class="gi">+        return self.errors</span>
<span class="gi">+</span>

<span class="w"> </span>def merge_errors(errors1, errors2):
<span class="w"> </span>    &quot;&quot;&quot;Deeply merge two error messages.
<span class="gu">@@ -20,4 +30,15 @@ def merge_errors(errors1, errors2):</span>
<span class="w"> </span>    The format of ``errors1`` and ``errors2`` matches the ``message``
<span class="w"> </span>    parameter of :exc:`marshmallow.exceptions.ValidationError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    merged = errors1.copy()</span>
<span class="gi">+    for key, value in errors2.items():</span>
<span class="gi">+        if key in merged:</span>
<span class="gi">+            if isinstance(merged[key], dict) and isinstance(value, dict):</span>
<span class="gi">+                merged[key] = merge_errors(merged[key], value)</span>
<span class="gi">+            elif isinstance(merged[key], list) and isinstance(value, list):</span>
<span class="gi">+                merged[key].extend(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                merged[key] = [merged[key], value]</span>
<span class="gi">+        else:</span>
<span class="gi">+            merged[key] = value</span>
<span class="gi">+    return merged</span>
<span class="gh">diff --git a/src/marshmallow/fields.py b/src/marshmallow/fields.py</span>
<span class="gh">index 8656a56..c3a5d4a 100644</span>
<span class="gd">--- a/src/marshmallow/fields.py</span>
<span class="gi">+++ b/src/marshmallow/fields.py</span>
<span class="gu">@@ -166,19 +166,37 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param callable accessor: A callable used to retrieve the value of `attr` from
<span class="w"> </span>            the object `obj`. Defaults to `marshmallow.utils.get_value`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        accessor_func = accessor or utils.get_value</span>
<span class="gi">+        return accessor_func(obj, attr, default)</span>

<span class="w"> </span>    def _validate(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Perform validation on ``value``. Raise a :exc:`ValidationError` if validation
<span class="w"> </span>        does not succeed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        errors = []</span>
<span class="gi">+        for validator in self.validators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if validator(value) is False:</span>
<span class="gi">+                    self.fail(&#39;validator_failed&#39;)</span>
<span class="gi">+            except ValidationError as error:</span>
<span class="gi">+                errors.extend(error.messages)</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            raise ValidationError(errors)</span>

<span class="w"> </span>    def make_error(self, key: str, **kwargs) -&gt;ValidationError:
<span class="w"> </span>        &quot;&quot;&quot;Helper method to make a `ValidationError` with an error message
<span class="w"> </span>        from ``self.error_messages``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            msg = self.error_messages[key]</span>
<span class="gi">+        except KeyError as error:</span>
<span class="gi">+            class_name = self.__class__.__name__</span>
<span class="gi">+            message = (f&#39;Error key &quot;{key}&quot; does not exist for field &quot;{class_name}&quot;.&#39;</span>
<span class="gi">+                       f&#39; Available keys are {&quot;, &quot;.join(self.error_messages.keys())}.&#39;)</span>
<span class="gi">+            raise KeyError(message) from error</span>
<span class="gi">+        if isinstance(msg, str):</span>
<span class="gi">+            msg = msg.format(**kwargs)</span>
<span class="gi">+        return ValidationError(msg)</span>

<span class="w"> </span>    def fail(self, key: str, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Helper method that raises a `ValidationError` with an error message
<span class="gu">@@ -187,13 +205,23 @@ class Field(FieldABC):</span>
<span class="w"> </span>        .. deprecated:: 3.0.0
<span class="w"> </span>            Use `make_error &lt;marshmallow.fields.Field.make_error&gt;` instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Field.fail is deprecated. Use Field.make_error instead.&quot;,</span>
<span class="gi">+            RemovedInMarshmallow4Warning,</span>
<span class="gi">+            stacklevel=2</span>
<span class="gi">+        )</span>
<span class="gi">+        raise self.make_error(key, **kwargs)</span>

<span class="w"> </span>    def _validate_missing(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Validate missing values. Raise a :exc:`ValidationError` if
<span class="w"> </span>        `value` should be considered missing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is missing_:</span>
<span class="gi">+            if self.required:</span>
<span class="gi">+                raise self.make_error(&#39;required&#39;)</span>
<span class="gi">+        elif value is None:</span>
<span class="gi">+            if self.allow_none is False:</span>
<span class="gi">+                raise self.make_error(&#39;null&#39;)</span>

<span class="w"> </span>    def serialize(self, attr: str, obj: typing.Any, accessor: (typing.
<span class="w"> </span>        Callable[[typing.Any, str, typing.Any], typing.Any] | None)=None,
<span class="gu">@@ -206,7 +234,14 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param accessor: Function used to access values from ``obj``.
<span class="w"> </span>        :param kwargs: Field-specific keyword arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.dump_only:</span>
<span class="gi">+            return self.dump_default</span>
<span class="gi">+</span>
<span class="gi">+        value = self.get_value(obj, attr, accessor=accessor)</span>
<span class="gi">+        if value is missing_:</span>
<span class="gi">+            return self.dump_default</span>
<span class="gi">+</span>
<span class="gi">+        return self._serialize(value, attr, obj, **kwargs)</span>

<span class="w"> </span>    def deserialize(self, value: typing.Any, attr: (str | None)=None, data:
<span class="w"> </span>        (typing.Mapping[str, typing.Any] | None)=None, **kwargs):
<span class="gu">@@ -219,7 +254,17 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :raise ValidationError: If an invalid value is passed or if a required value
<span class="w"> </span>            is missing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.load_only:</span>
<span class="gi">+            return self.load_default</span>
<span class="gi">+</span>
<span class="gi">+        self._validate_missing(value)</span>
<span class="gi">+        if value is missing_:</span>
<span class="gi">+            return self.load_default</span>
<span class="gi">+</span>
<span class="gi">+        value = self._deserialize(value, attr, data, **kwargs)</span>
<span class="gi">+        self._validate(value)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def _bind_to_schema(self, field_name, schema):
<span class="w"> </span>        &quot;&quot;&quot;Update field with values from its parent schema. Called by
<span class="gu">@@ -228,7 +273,13 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param str field_name: Field name set in schema.
<span class="w"> </span>        :param Schema|Field schema: Parent object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.parent = self.schema = schema</span>
<span class="gi">+        self.name = field_name</span>
<span class="gi">+        self.root = schema.root</span>
<span class="gi">+        # Allow fields to override their data key</span>
<span class="gi">+        if self.data_key is None:</span>
<span class="gi">+            self.data_key = field_name</span>
<span class="gi">+        self.metadata.setdefault(&#39;name&#39;, field_name)</span>

<span class="w"> </span>    def _serialize(self, value: typing.Any, attr: (str | None), obj: typing
<span class="w"> </span>        .Any, **kwargs):
<span class="gu">@@ -249,7 +300,7 @@ class Field(FieldABC):</span>
<span class="w"> </span>        :param dict kwargs: Field-specific keyword arguments.
<span class="w"> </span>        :return: The serialized value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def _deserialize(self, value: typing.Any, attr: (str | None), data: (
<span class="w"> </span>        typing.Mapping[str, typing.Any] | None), **kwargs):
<span class="gu">@@ -268,12 +319,12 @@ class Field(FieldABC):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0
<span class="w"> </span>            Added ``**kwargs`` to signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def context(self):
<span class="w"> </span>        &quot;&quot;&quot;The context dictionary for the parent :class:`Schema`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.parent.context if self.parent else {}</span>


<span class="w"> </span>class Raw(Field):
<span class="gh">diff --git a/src/marshmallow/schema.py b/src/marshmallow/schema.py</span>
<span class="gh">index 1e6eabf..38ad968 100644</span>
<span class="gd">--- a/src/marshmallow/schema.py</span>
<span class="gi">+++ b/src/marshmallow/schema.py</span>
<span class="gu">@@ -311,7 +311,10 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>

<span class="w"> </span>        .. versionadded:: 3.0.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs = fields.copy()</span>
<span class="gi">+        attrs[&#39;Meta&#39;] = type(&#39;Meta&#39;, (), {&#39;register&#39;: False})</span>
<span class="gi">+        schema_cls = type(name, (Schema,), attrs)</span>
<span class="gi">+        return schema_cls</span>

<span class="w"> </span>    def handle_error(self, error: ValidationError, data: typing.Any, *,
<span class="w"> </span>        many: bool, **kwargs):
<span class="gu">@@ -327,7 +330,7 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0rc9
<span class="w"> </span>            Receives `many` and `partial` (on deserialization) as keyword arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pass  # Default implementation does nothing</span>

<span class="w"> </span>    def get_attribute(self, obj: typing.Any, attr: str, default: typing.Any):
<span class="w"> </span>        &quot;&quot;&quot;Defines how to pull values from an object to serialize.
<span class="gu">@@ -337,7 +340,7 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        .. versionchanged:: 3.0.0a1
<span class="w"> </span>            Changed position of ``obj`` and ``attr``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get_value(obj, attr, default)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _call_and_store(getter_func, data, *, field_name, error_store,
<span class="gu">@@ -351,7 +354,12 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):</span>
<span class="w"> </span>        :param int index: Index of the item being validated, if validating a collection,
<span class="w"> </span>            otherwise `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = getter_func(data)</span>
<span class="gi">+        except ValidationError as error:</span>
<span class="gi">+            error_store.store_error(error.messages, field_name, index=index)</span>
<span class="gi">+            return missing</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def _serialize(self, obj: (_T | typing.Iterable[_T]), *, many: bool=False):
<span class="w"> </span>        &quot;&quot;&quot;Serialize ``obj``.
<span class="gh">diff --git a/src/marshmallow/utils.py b/src/marshmallow/utils.py</span>
<span class="gh">index 1c71b57..e9ec424 100644</span>
<span class="gd">--- a/src/marshmallow/utils.py</span>
<span class="gi">+++ b/src/marshmallow/utils.py</span>
<span class="gu">@@ -40,29 +40,35 @@ missing = _Missing()</span>

<span class="w"> </span>def is_generator(obj) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is a generator&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return inspect.isgenerator(obj)</span>


<span class="w"> </span>def is_iterable_but_not_string(obj) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is an iterable object that isn&#39;t a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(obj, collections.abc.Iterable) and</span>
<span class="gi">+        not isinstance(obj, (str, bytes))</span>
<span class="gi">+    )</span>


<span class="w"> </span>def is_collection(obj) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` is a collection type, e.g list, tuple, queryset.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_iterable_but_not_string(obj) and not isinstance(obj, Mapping)</span>


<span class="w"> </span>def is_instance_or_subclass(val, class_) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``val`` is either a subclass or instance of ``class_``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return issubclass(val, class_)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return isinstance(val, class_)</span>


<span class="w"> </span>def is_keyed_tuple(obj) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if ``obj`` has keyed tuple behavior, such as
<span class="w"> </span>    namedtuples or SQLAlchemy&#39;s KeyedTuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, tuple) and hasattr(obj, &#39;_fields&#39;)</span>


<span class="w"> </span>def pprint(obj, *args, **kwargs) -&gt;None:
<span class="gu">@@ -73,7 +79,15 @@ def pprint(obj, *args, **kwargs) -&gt;None:</span>
<span class="w"> </span>    .. deprecated:: 3.7.0
<span class="w"> </span>        marshmallow.pprint will be removed in marshmallow 4.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;marshmallow.pprint is deprecated and will be removed in marshmallow 4.&quot;,</span>
<span class="gi">+        RemovedInMarshmallow4Warning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    if isinstance(obj, collections.OrderedDict):</span>
<span class="gi">+        py_pprint(dict(obj), *args, **kwargs)</span>
<span class="gi">+    else:</span>
<span class="gi">+        py_pprint(obj, *args, **kwargs)</span>


<span class="w"> </span>def from_rfc(datestring: str) -&gt;dt.datetime:
<span class="gu">@@ -81,7 +95,7 @@ def from_rfc(datestring: str) -&gt;dt.datetime:</span>

<span class="w"> </span>    https://stackoverflow.com/questions/885015/how-to-parse-a-rfc-2822-date-time-into-a-python-datetime  # noqa: B950
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return parsedate_to_datetime(datestring)</span>


<span class="w"> </span>def rfcformat(datetime: dt.datetime) -&gt;str:
<span class="gu">@@ -89,7 +103,7 @@ def rfcformat(datetime: dt.datetime) -&gt;str:</span>

<span class="w"> </span>    :param datetime datetime: The datetime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return format_datetime(datetime)</span>


<span class="w"> </span>_iso8601_datetime_re = re.compile(
<span class="gu">@@ -104,7 +118,9 @@ _iso8601_time_re = re.compile(</span>

<span class="w"> </span>def get_fixed_timezone(offset: (int | float | dt.timedelta)) -&gt;dt.timezone:
<span class="w"> </span>    &quot;&quot;&quot;Return a tzinfo instance with a fixed offset from UTC.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(offset, dt.timedelta):</span>
<span class="gi">+        offset = offset.total_seconds()</span>
<span class="gi">+    return dt.timezone(dt.timedelta(seconds=int(offset)))</span>


<span class="w"> </span>def from_iso_datetime(value):
<span class="gu">@@ -113,7 +129,32 @@ def from_iso_datetime(value):</span>
<span class="w"> </span>    This function supports time zone offsets. When the input contains one,
<span class="w"> </span>    the output uses a timezone with a fixed offset from UTC.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_datetime_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&#39;Not a valid ISO8601-formatted datetime string&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    groups = match.groupdict()</span>
<span class="gi">+</span>
<span class="gi">+    groups[&#39;year&#39;] = int(groups[&#39;year&#39;])</span>
<span class="gi">+    groups[&#39;month&#39;] = int(groups[&#39;month&#39;])</span>
<span class="gi">+    groups[&#39;day&#39;] = int(groups[&#39;day&#39;])</span>
<span class="gi">+    groups[&#39;hour&#39;] = int(groups[&#39;hour&#39;])</span>
<span class="gi">+    groups[&#39;minute&#39;] = int(groups[&#39;minute&#39;])</span>
<span class="gi">+    groups[&#39;second&#39;] = int(groups[&#39;second&#39;] or 0)</span>
<span class="gi">+    groups[&#39;microsecond&#39;] = int(groups[&#39;microsecond&#39;] or 0)</span>
<span class="gi">+</span>
<span class="gi">+    if groups[&#39;tzinfo&#39;] == &#39;Z&#39;:</span>
<span class="gi">+        tzinfo = dt.timezone.utc</span>
<span class="gi">+    elif groups[&#39;tzinfo&#39;]:</span>
<span class="gi">+        offset_mins = int(groups[&#39;tzinfo&#39;][-2:]) if len(groups[&#39;tzinfo&#39;]) &gt; 3 else 0</span>
<span class="gi">+        offset = 60 * int(groups[&#39;tzinfo&#39;][1:3]) + offset_mins</span>
<span class="gi">+        if groups[&#39;tzinfo&#39;][0] == &#39;-&#39;:</span>
<span class="gi">+            offset = -offset</span>
<span class="gi">+        tzinfo = get_fixed_timezone(offset * 60)</span>
<span class="gi">+    else:</span>
<span class="gi">+        tzinfo = None</span>
<span class="gi">+</span>
<span class="gi">+    return dt.datetime(tzinfo=tzinfo, **groups)</span>


<span class="w"> </span>def from_iso_time(value):
<span class="gu">@@ -121,12 +162,33 @@ def from_iso_time(value):</span>

<span class="w"> </span>    This function doesn&#39;t support time zone offsets.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_time_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&#39;Not a valid ISO8601-formatted time string&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    groups = match.groupdict()</span>
<span class="gi">+</span>
<span class="gi">+    groups[&#39;hour&#39;] = int(groups[&#39;hour&#39;])</span>
<span class="gi">+    groups[&#39;minute&#39;] = int(groups[&#39;minute&#39;])</span>
<span class="gi">+    groups[&#39;second&#39;] = int(groups[&#39;second&#39;] or 0)</span>
<span class="gi">+    groups[&#39;microsecond&#39;] = int(groups[&#39;microsecond&#39;] or 0)</span>
<span class="gi">+</span>
<span class="gi">+    return dt.time(**groups)</span>


<span class="w"> </span>def from_iso_date(value):
<span class="w"> </span>    &quot;&quot;&quot;Parse a string and return a datetime.date.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = _iso8601_date_re.match(value)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&#39;Not a valid ISO8601-formatted date string&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    groups = match.groupdict()</span>
<span class="gi">+</span>
<span class="gi">+    return dt.date(</span>
<span class="gi">+        int(groups[&#39;year&#39;]),</span>
<span class="gi">+        int(groups[&#39;month&#39;]),</span>
<span class="gi">+        int(groups[&#39;day&#39;])</span>
<span class="gi">+    )</span>


<span class="w"> </span>def isoformat(datetime: dt.datetime) -&gt;str:
<span class="gu">@@ -134,7 +196,7 @@ def isoformat(datetime: dt.datetime) -&gt;str:</span>

<span class="w"> </span>    :param datetime datetime: The datetime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return datetime.isoformat()</span>


<span class="w"> </span>def pluck(dictlist: list[dict[str, typing.Any]], key: str):
<span class="gu">@@ -145,7 +207,7 @@ def pluck(dictlist: list[dict[str, typing.Any]], key: str):</span>
<span class="w"> </span>        &gt;&gt;&gt; pluck(dlist, &#39;id&#39;)
<span class="w"> </span>        [1, 2]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [d.get(key) for d in dictlist]</span>


<span class="w"> </span>def get_value(obj, key: (int | str), default=missing):
<span class="gu">@@ -159,7 +221,19 @@ def get_value(obj, key: (int | str), default=missing):</span>
<span class="w"> </span>        `get_value` will never check the value `x.i`. Consider overriding
<span class="w"> </span>        `marshmallow.fields.Field.get_value` in this case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(key, int):</span>
<span class="gi">+        return obj[key] if isinstance(obj, collections.abc.Sequence) else default</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return obj[key]</span>
<span class="gi">+    except (KeyError, AttributeError, IndexError, TypeError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Fall back to getattr for dotted paths</span>
<span class="gi">+    if &#39;.&#39; in key:</span>
<span class="gi">+        return functools.reduce(lambda o, k: get_value(o, k, default), key.split(&#39;.&#39;), obj)</span>
<span class="gi">+</span>
<span class="gi">+    return getattr(obj, key, default)</span>


<span class="w"> </span>def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):
<span class="gu">@@ -173,12 +247,26 @@ def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):</span>
<span class="w"> </span>        &gt;&gt;&gt; d
<span class="w"> </span>        {&#39;foo&#39;: {&#39;bar&#39;: 42}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;.&#39; in key:</span>
<span class="gi">+        head, rest = key.split(&#39;.&#39;, 1)</span>
<span class="gi">+        target = dct.setdefault(head, {})</span>
<span class="gi">+        if not isinstance(target, dict):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Cannot set &#39;{rest}&#39; in &#39;{head}&#39; ({target}) &quot;</span>
<span class="gi">+                &quot;which is not a dict&quot;.format(</span>
<span class="gi">+                    rest=rest, head=head, target=target</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        set_value(target, rest, value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        dct[key] = value</span>


<span class="w"> </span>def callable_or_raise(obj):
<span class="w"> </span>    &quot;&quot;&quot;Check that an object is callable, else raise a :exc:`TypeError`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not callable(obj):</span>
<span class="gi">+        raise TypeError(&#39;Object {!r} is not callable.&#39;.format(obj))</span>
<span class="gi">+    return obj</span>


<span class="w"> </span>def get_func_args(func: typing.Callable) -&gt;list[str]:
<span class="gu">@@ -188,7 +276,12 @@ def get_func_args(func: typing.Callable) -&gt;list[str]:</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0a1
<span class="w"> </span>        Do not return bound arguments, eg. ``self``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(func, functools.partial):</span>
<span class="gi">+        return get_func_args(func.func)</span>
<span class="gi">+    if inspect.isfunction(func) or inspect.ismethod(func):</span>
<span class="gi">+        return list(inspect.signature(func).parameters.keys())</span>
<span class="gi">+    # Callable class</span>
<span class="gi">+    return list(inspect.signature(func.__call__).parameters.keys())[1:]</span>


<span class="w"> </span>def resolve_field_instance(cls_or_instance):
<span class="gu">@@ -196,7 +289,19 @@ def resolve_field_instance(cls_or_instance):</span>

<span class="w"> </span>    :param type|Schema cls_or_instance: Marshmallow Schema class or instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(cls_or_instance, type):</span>
<span class="gi">+        if not issubclass(cls_or_instance, FieldABC):</span>
<span class="gi">+            raise FieldInstanceResolutionError(</span>
<span class="gi">+                &#39;The class &quot;{}&quot; is not a subclass of &#39;</span>
<span class="gi">+                &#39;marshmallow.base.FieldABC&#39;.format(cls_or_instance.__name__)</span>
<span class="gi">+            )</span>
<span class="gi">+        return cls_or_instance()</span>
<span class="gi">+    if not isinstance(cls_or_instance, FieldABC):</span>
<span class="gi">+        raise FieldInstanceResolutionError(</span>
<span class="gi">+            &#39;The object &quot;{}&quot; is not an instance of &#39;</span>
<span class="gi">+            &#39;marshmallow.base.FieldABC&#39;.format(cls_or_instance)</span>
<span class="gi">+        )</span>
<span class="gi">+    return cls_or_instance</span>


<span class="w"> </span>def timedelta_to_microseconds(value: dt.timedelta) -&gt;int:
<span class="gu">@@ -204,4 +309,4 @@ def timedelta_to_microseconds(value: dt.timedelta) -&gt;int:</span>

<span class="w"> </span>    https://github.com/python/cpython/blob/bb3e0c240bc60fe08d332ff5955d54197f79751c/Lib/datetime.py#L665-L667  # noqa: B950
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (value.days * 86400 + value.seconds) * 1000000 + value.microseconds</span>
<span class="gh">diff --git a/src/marshmallow/validate.py b/src/marshmallow/validate.py</span>
<span class="gh">index 3cc3b97..928d96e 100644</span>
<span class="gd">--- a/src/marshmallow/validate.py</span>
<span class="gi">+++ b/src/marshmallow/validate.py</span>
<span class="gu">@@ -105,6 +105,20 @@ class URL(Validator):</span>
<span class="w"> </span>                self._memoized[key] = self._regex_generator(relative,
<span class="w"> </span>                    absolute, require_tld)
<span class="w"> </span>            return self._memoized[key]
<span class="gi">+</span>
<span class="gi">+        def _regex_generator(self, relative: bool, absolute: bool, require_tld: bool</span>
<span class="gi">+            ) -&gt;typing.Pattern:</span>
<span class="gi">+            return re.compile(</span>
<span class="gi">+                r&quot;&quot;.join([</span>
<span class="gi">+                    r&quot;^&quot;,</span>
<span class="gi">+                    r&quot;(&quot; if relative else r&quot;&quot;,</span>
<span class="gi">+                    r&quot;(?:[a-z0-9\.\-\+]*)://&quot; if absolute else r&quot;&quot;,</span>
<span class="gi">+                    r&quot;(?:[^/:]+)&quot; if not require_tld else r&quot;(?:[^/:]+\.)+[^/:]{2,}&quot;,</span>
<span class="gi">+                    r&quot;(?::\d+)?(?:/?|[/?]\S+)$&quot;,</span>
<span class="gi">+                    r&quot;)?&quot; if relative else r&quot;&quot;,</span>
<span class="gi">+                ]),</span>
<span class="gi">+                re.IGNORECASE</span>
<span class="gi">+            )</span>
<span class="w"> </span>    _regex = RegexMemoizer()
<span class="w"> </span>    default_message = &#39;Not a valid URL.&#39;
<span class="w"> </span>    default_schemes = {&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, &#39;ftps&#39;}
<span class="gu">@@ -419,7 +433,15 @@ class OneOf(Validator):</span>
<span class="w"> </span>            of an attribute of the choice objects. Defaults to `str()`
<span class="w"> </span>            or `str()`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if callable(valuegetter):</span>
<span class="gi">+            getter = valuegetter</span>
<span class="gi">+        elif isinstance(valuegetter, str):</span>
<span class="gi">+            getter = attrgetter(valuegetter)</span>
<span class="gi">+        else:</span>
<span class="gi">+            getter = str</span>
<span class="gi">+</span>
<span class="gi">+        for choice, label in zip_longest(self.choices, self.labels):</span>
<span class="gi">+            yield getter(choice), label or str(choice)</span>


<span class="w"> </span>class ContainsOnly(OneOf):
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>