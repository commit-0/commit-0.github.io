
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference bitstring - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-bitstring" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference bitstring
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-bitstring"><strong>Reference (Gold)</strong>: bitstring</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">834</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">835</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">835</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/bitstring/array_.py b/bitstring/array_.py</span>
<span class="gh">index 5df26f0..5aaed8b 100644</span>
<span class="gd">--- a/bitstring/array_.py</span>
<span class="gi">+++ b/bitstring/array_.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import numbers
<span class="w"> </span>from collections.abc import Sized
<span class="gu">@@ -14,7 +15,10 @@ import array</span>
<span class="w"> </span>import operator
<span class="w"> </span>import io
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+# The possible types stored in each element of the Array</span>
<span class="w"> </span>ElementType = Union[float, str, int, bytes, bool, Bits]
<span class="gi">+</span>
<span class="w"> </span>options = Options()


<span class="gu">@@ -63,24 +67,19 @@ class Array:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, dtype: Union[str, Dtype], initializer: Optional[</span>
<span class="gd">-        Union[int, Array, array.array, Iterable, Bits, bytes, bytearray,</span>
<span class="gd">-        memoryview, BinaryIO]]=None, trailing_bits: Optional[BitsType]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, dtype: Union[str, Dtype], initializer: Optional[Union[int, Array, array.array, Iterable, Bits, bytes, bytearray, memoryview, BinaryIO]] = None,</span>
<span class="gi">+                 trailing_bits: Optional[BitsType] = None) -&gt; None:</span>
<span class="w"> </span>        self.data = BitArray()
<span class="w"> </span>        if isinstance(dtype, Dtype) and dtype.scale == &#39;auto&#39;:
<span class="gd">-            if isinstance(initializer, (int, Bits, bytes, bytearray,</span>
<span class="gd">-                memoryview, BinaryIO)):</span>
<span class="gd">-                raise TypeError(</span>
<span class="gd">-                    &quot;An Array with an &#39;auto&#39; scale factor can only be created from an iterable of values.&quot;</span>
<span class="gd">-                    )</span>
<span class="gd">-            auto_scale = self._calculate_auto_scale(initializer, dtype.name,</span>
<span class="gd">-                dtype.length)</span>
<span class="gi">+            if isinstance(initializer, (int, Bits, bytes, bytearray, memoryview, BinaryIO)):</span>
<span class="gi">+                raise TypeError(&quot;An Array with an &#39;auto&#39; scale factor can only be created from an iterable of values.&quot;)</span>
<span class="gi">+            auto_scale = self._calculate_auto_scale(initializer, dtype.name, dtype.length)</span>
<span class="w"> </span>            dtype = Dtype(dtype.name, dtype.length, scale=auto_scale)
<span class="w"> </span>        try:
<span class="w"> </span>            self._set_dtype(dtype)
<span class="w"> </span>        except ValueError as e:
<span class="w"> </span>            raise CreationError(e)
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(initializer, numbers.Integral):
<span class="w"> </span>            self.data = BitArray(initializer * self._dtype.bitlength)
<span class="w"> </span>        elif isinstance(initializer, (Bits, bytes, bytearray, memoryview)):
<span class="gu">@@ -89,148 +88,256 @@ class Array:</span>
<span class="w"> </span>            self.fromfile(initializer)
<span class="w"> </span>        elif initializer is not None:
<span class="w"> </span>            self.extend(initializer)
<span class="gi">+</span>
<span class="w"> </span>        if trailing_bits is not None:
<span class="w"> </span>            self.data += BitArray._create_from_bitstype(trailing_bits)
<span class="gi">+</span>
<span class="w"> </span>    _largest_values = None

<span class="gd">-    def _create_element(self, value: ElementType) -&gt;Bits:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _calculate_auto_scale(initializer, name: str, length: Optional[int]) -&gt; float:</span>
<span class="gi">+        # Now need to find the largest power of 2 representable with this format.</span>
<span class="gi">+        if Array._largest_values is None:</span>
<span class="gi">+            Array._largest_values = {</span>
<span class="gi">+                &#39;mxint8&#39;: Bits(&#39;0b01111111&#39;).mxint8,  # 1.0 + 63.0/64.0,</span>
<span class="gi">+                &#39;e2m1mxfp4&#39;: Bits(&#39;0b0111&#39;).e2m1mxfp4,  # 6.0</span>
<span class="gi">+                &#39;e2m3mxfp6&#39;: Bits(&#39;0b011111&#39;).e2m3mxfp6,  # 7.5</span>
<span class="gi">+                &#39;e3m2mxfp6&#39;: Bits(&#39;0b011111&#39;).e3m2mxfp6,  # 28.0</span>
<span class="gi">+                &#39;e4m3mxfp8&#39;: Bits(&#39;0b01111110&#39;).e4m3mxfp8,  # 448.0</span>
<span class="gi">+                &#39;e5m2mxfp8&#39;: Bits(&#39;0b01111011&#39;).e5m2mxfp8,  # 57344.0</span>
<span class="gi">+                &#39;p4binary8&#39;: Bits(&#39;0b01111110&#39;).p4binary8,  # 224.0</span>
<span class="gi">+                &#39;p3binary8&#39;: Bits(&#39;0b01111110&#39;).p3binary8,  # 49152.0</span>
<span class="gi">+                &#39;float16&#39;: Bits(&#39;0x7bff&#39;).float16,  # 65504.0</span>
<span class="gi">+                # The bfloat range is so large the scaling algorithm doesn&#39;t work well, so I&#39;m disallowing it.</span>
<span class="gi">+                # &#39;bfloat16&#39;: Bits(&#39;0x7f7f&#39;).bfloat16,  # 3.38953139e38,</span>
<span class="gi">+            }</span>
<span class="gi">+        if f&#39;{name}{length}&#39; in Array._largest_values.keys():</span>
<span class="gi">+            float_values = Array(&#39;float64&#39;, initializer).tolist()</span>
<span class="gi">+            if not float_values:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t calculate an &#39;auto&#39; scale with an empty Array initializer.&quot;)</span>
<span class="gi">+            max_float_value = max(abs(x) for x in float_values)</span>
<span class="gi">+            if max_float_value == 0:</span>
<span class="gi">+                # This special case isn&#39;t covered in the standard. I&#39;m choosing to return no scale.</span>
<span class="gi">+                return 1.0</span>
<span class="gi">+            # We need to find the largest power of 2 that is less than the max value</span>
<span class="gi">+            log2 = math.floor(math.log2(max_float_value))</span>
<span class="gi">+            lp2 = math.floor(math.log2(Array._largest_values[f&#39;{name}{length}&#39;]))</span>
<span class="gi">+            lg_scale = log2 - lp2</span>
<span class="gi">+            # Saturate at values representable in E8M0 format.</span>
<span class="gi">+            if lg_scale &gt; 127:</span>
<span class="gi">+                lg_scale = 127</span>
<span class="gi">+            elif lg_scale &lt; -127:</span>
<span class="gi">+                lg_scale = -127</span>
<span class="gi">+            return 2 ** lg_scale</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Can&#39;t calculate auto scale for format &#39;{name}{length}&#39;. &quot;</span>
<span class="gi">+                             f&quot;This feature is only available for these formats: {list(Array._largest_values.keys())}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def itemsize(self) -&gt; int:</span>
<span class="gi">+        return self._dtype.length</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailing_bits(self) -&gt; BitArray:</span>
<span class="gi">+        trailing_bit_length = len(self.data) % self._dtype.bitlength</span>
<span class="gi">+        return BitArray() if trailing_bit_length == 0 else self.data[-trailing_bit_length:]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def dtype(self) -&gt; Dtype:</span>
<span class="gi">+        return self._dtype</span>
<span class="gi">+</span>
<span class="gi">+    @dtype.setter</span>
<span class="gi">+    def dtype(self, new_dtype: Union[str, Dtype]) -&gt; None:</span>
<span class="gi">+        self._set_dtype(new_dtype)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_dtype(self, new_dtype: Union[str, Dtype]) -&gt; None:</span>
<span class="gi">+        if isinstance(new_dtype, Dtype):</span>
<span class="gi">+            self._dtype = new_dtype</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                dtype = Dtype(new_dtype)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                name_length = utils.parse_single_struct_token(new_dtype)</span>
<span class="gi">+                if name_length is not None:</span>
<span class="gi">+                    dtype = Dtype(name_length[0], name_length[1])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(f&quot;Inappropriate Dtype for Array: &#39;{new_dtype}&#39;.&quot;)</span>
<span class="gi">+            if dtype.length is None:</span>
<span class="gi">+                raise ValueError(f&quot;A fixed length format is needed for an Array, received &#39;{new_dtype}&#39;.&quot;)</span>
<span class="gi">+            self._dtype = dtype</span>
<span class="gi">+        if self._dtype.scale == &#39;auto&#39;:</span>
<span class="gi">+            raise ValueError(&quot;A Dtype with an &#39;auto&#39; scale factor can only be used when creating a new Array.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_element(self, value: ElementType) -&gt; Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create Bits from value according to the token_name and token_length&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self._dtype.build(value)</span>
<span class="gi">+        if len(b) != self._dtype.length:</span>
<span class="gi">+            raise ValueError(f&quot;The value {value!r} has the wrong length for the format &#39;{self._dtype}&#39;.&quot;)</span>
<span class="gi">+        return b</span>

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self.data) // self._dtype.length

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self, key: slice) -&gt;Array:</span>
<span class="gi">+    def __getitem__(self, key: slice) -&gt; Array:</span>
<span class="w"> </span>        ...

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self, key: int) -&gt;ElementType:</span>
<span class="gi">+    def __getitem__(self, key: int) -&gt; ElementType:</span>
<span class="w"> </span>        ...

<span class="gd">-    def __getitem__(self, key: Union[slice, int]) -&gt;Union[Array, ElementType]:</span>
<span class="gi">+    def __getitem__(self, key: Union[slice, int]) -&gt; Union[Array, ElementType]:</span>
<span class="w"> </span>        if isinstance(key, slice):
<span class="w"> </span>            start, stop, step = key.indices(len(self))
<span class="w"> </span>            if step != 1:
<span class="w"> </span>                d = BitArray()
<span class="gd">-                for s in range(start * self._dtype.length, stop * self.</span>
<span class="gd">-                    _dtype.length, step * self._dtype.length):</span>
<span class="gd">-                    d.append(self.data[s:s + self._dtype.length])</span>
<span class="gi">+                for s in range(start * self._dtype.length, stop * self._dtype.length, step * self._dtype.length):</span>
<span class="gi">+                    d.append(self.data[s: s + self._dtype.length])</span>
<span class="w"> </span>                a = self.__class__(self._dtype)
<span class="w"> </span>                a.data = d
<span class="w"> </span>                return a
<span class="w"> </span>            else:
<span class="w"> </span>                a = self.__class__(self._dtype)
<span class="gd">-                a.data = self.data[start * self._dtype.length:stop * self.</span>
<span class="gd">-                    _dtype.length]</span>
<span class="gi">+                a.data = self.data[start * self._dtype.length: stop * self._dtype.length]</span>
<span class="w"> </span>                return a
<span class="w"> </span>        else:
<span class="w"> </span>            if key &lt; 0:
<span class="w"> </span>                key += len(self)
<span class="w"> </span>            if key &lt; 0 or key &gt;= len(self):
<span class="gd">-                raise IndexError(</span>
<span class="gd">-                    f&#39;Index {key} out of range for Array of length {len(self)}.&#39;</span>
<span class="gd">-                    )</span>
<span class="gd">-            return self._dtype.read_fn(self.data, start=self._dtype.length *</span>
<span class="gd">-                key)</span>
<span class="gi">+                raise IndexError(f&quot;Index {key} out of range for Array of length {len(self)}.&quot;)</span>
<span class="gi">+            return self._dtype.read_fn(self.data, start=self._dtype.length * key)</span>

<span class="w"> </span>    @overload
<span class="gd">-    def __setitem__(self, key: slice, value: Iterable[ElementType]) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: slice, value: Iterable[ElementType]) -&gt; None:</span>
<span class="w"> </span>        ...

<span class="w"> </span>    @overload
<span class="gd">-    def __setitem__(self, key: int, value: ElementType) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: int, value: ElementType) -&gt; None:</span>
<span class="w"> </span>        ...

<span class="gd">-    def __setitem__(self, key: Union[slice, int], value: Union[Iterable[</span>
<span class="gd">-        ElementType], ElementType]) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: Union[slice, int], value: Union[Iterable[ElementType], ElementType]) -&gt; None:</span>
<span class="w"> </span>        if isinstance(key, slice):
<span class="w"> </span>            start, stop, step = key.indices(len(self))
<span class="w"> </span>            if not isinstance(value, Iterable):
<span class="gd">-                raise TypeError(&#39;Can only assign an iterable to a slice.&#39;)</span>
<span class="gi">+                raise TypeError(&quot;Can only assign an iterable to a slice.&quot;)</span>
<span class="w"> </span>            if step == 1:
<span class="w"> </span>                new_data = BitArray()
<span class="w"> </span>                for x in value:
<span class="w"> </span>                    new_data += self._create_element(x)
<span class="gd">-                self.data[start * self._dtype.length:stop * self._dtype.length</span>
<span class="gd">-                    ] = new_data</span>
<span class="gi">+                self.data[start * self._dtype.length: stop * self._dtype.length] = new_data</span>
<span class="w"> </span>                return
<span class="w"> </span>            items_in_slice = len(range(start, stop, step))
<span class="w"> </span>            if not isinstance(value, Sized):
<span class="w"> </span>                value = list(value)
<span class="w"> </span>            if len(value) == items_in_slice:
<span class="w"> </span>                for s, v in zip(range(start, stop, step), value):
<span class="gd">-                    self.data.overwrite(self._create_element(v), s * self.</span>
<span class="gd">-                        _dtype.length)</span>
<span class="gi">+                    self.data.overwrite(self._create_element(v), s * self._dtype.length)</span>
<span class="w"> </span>            else:
<span class="gd">-                raise ValueError(</span>
<span class="gd">-                    f&quot;Can&#39;t assign {len(value)} values to an extended slice of length {items_in_slice}.&quot;</span>
<span class="gd">-                    )</span>
<span class="gi">+                raise ValueError(f&quot;Can&#39;t assign {len(value)} values to an extended slice of length {items_in_slice}.&quot;)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            if key &lt; 0:
<span class="w"> </span>                key += len(self)
<span class="w"> </span>            if key &lt; 0 or key &gt;= len(self):
<span class="gd">-                raise IndexError(</span>
<span class="gd">-                    f&#39;Index {key} out of range for Array of length {len(self)}.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                raise IndexError(f&quot;Index {key} out of range for Array of length {len(self)}.&quot;)</span>
<span class="w"> </span>            start = self._dtype.length * key
<span class="w"> </span>            self.data.overwrite(self._create_element(value), start)
<span class="w"> </span>            return

<span class="gd">-    def __delitem__(self, key: Union[slice, int]) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: Union[slice, int]) -&gt; None:</span>
<span class="w"> </span>        if isinstance(key, slice):
<span class="w"> </span>            start, stop, step = key.indices(len(self))
<span class="w"> </span>            if step == 1:
<span class="gd">-                self.data.__delitem__(slice(start * self._dtype.length, </span>
<span class="gd">-                    stop * self._dtype.length))</span>
<span class="gi">+                self.data.__delitem__(slice(start * self._dtype.length, stop * self._dtype.length))</span>
<span class="w"> </span>                return
<span class="gd">-            r = reversed(range(start, stop, step)) if step &gt; 0 else range(start</span>
<span class="gd">-                , stop, step)</span>
<span class="gi">+            # We need to delete from the end or the earlier positions will change</span>
<span class="gi">+            r = reversed(range(start, stop, step)) if step &gt; 0 else range(start, stop, step)</span>
<span class="w"> </span>            for s in r:
<span class="gd">-                self.data.__delitem__(slice(s * self._dtype.length, (s + 1) *</span>
<span class="gd">-                    self._dtype.length))</span>
<span class="gi">+                self.data.__delitem__(slice(s * self._dtype.length, (s + 1) * self._dtype.length))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            if key &lt; 0:
<span class="w"> </span>                key += len(self)
<span class="w"> </span>            if key &lt; 0 or key &gt;= len(self):
<span class="w"> </span>                raise IndexError
<span class="w"> </span>            start = self._dtype.length * key
<span class="gd">-            del self.data[start:start + self._dtype.length]</span>
<span class="gi">+            del self.data[start: start + self._dtype.length]</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        list_str = f&#39;{self.tolist()}&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        list_str = f&quot;{self.tolist()}&quot;</span>
<span class="w"> </span>        trailing_bit_length = len(self.data) % self._dtype.length
<span class="gd">-        final_str = (&#39;&#39; if trailing_bit_length == 0 else &#39;, trailing_bits=&#39; +</span>
<span class="gd">-            repr(self.data[-trailing_bit_length:]))</span>
<span class="gi">+        final_str = &quot;&quot; if trailing_bit_length == 0 else &quot;, trailing_bits=&quot; + repr(</span>
<span class="gi">+            self.data[-trailing_bit_length:])</span>
<span class="w"> </span>        return f&quot;Array(&#39;{self._dtype}&#39;, {list_str}{final_str})&quot;

<span class="gd">-    def astype(self, dtype: Union[str, Dtype]) -&gt;Array:</span>
<span class="gi">+    def astype(self, dtype: Union[str, Dtype]) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return Array with elements of new dtype, initialised from current Array.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_array = self.__class__(dtype, self.tolist())</span>
<span class="gi">+        return new_array</span>
<span class="gi">+</span>
<span class="gi">+    def tolist(self) -&gt; List[ElementType]:</span>
<span class="gi">+        return [self._dtype.read_fn(self.data, start=start)</span>
<span class="gi">+                for start in range(0, len(self.data) - self._dtype.length + 1, self._dtype.length)]</span>
<span class="gi">+</span>
<span class="gi">+    def append(self, x: ElementType) -&gt; None:</span>
<span class="gi">+        if len(self.data) % self._dtype.length != 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot append to Array as its length is not a multiple of the format length.&quot;)</span>
<span class="gi">+        self.data += self._create_element(x)</span>
<span class="gi">+</span>
<span class="gi">+    def extend(self, iterable: Union[Array, array.array, Iterable[Any]]) -&gt; None:</span>
<span class="gi">+        if len(self.data) % self._dtype.length != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Cannot extend Array as its data length ({len(self.data)} bits) is not a multiple of the format length ({self._dtype.length} bits).&quot;)</span>
<span class="gi">+        if isinstance(iterable, Array):</span>
<span class="gi">+            if self._dtype.name != iterable._dtype.name or self._dtype.length != iterable._dtype.length:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Cannot extend an Array with format &#39;{self._dtype}&#39; from an Array of format &#39;{iterable._dtype}&#39;.&quot;)</span>
<span class="gi">+            # No need to iterate over the elements, we can just append the data</span>
<span class="gi">+            self.data.append(iterable.data)</span>
<span class="gi">+        elif isinstance(iterable, array.array):</span>
<span class="gi">+            # array.array types are always native-endian, hence the &#39;=&#39;</span>
<span class="gi">+            name_value = utils.parse_single_struct_token(&#39;=&#39; + iterable.typecode)</span>
<span class="gi">+            if name_value is None:</span>
<span class="gi">+                raise ValueError(f&quot;Cannot extend from array with typecode {iterable.typecode}.&quot;)</span>
<span class="gi">+            other_dtype = dtype_register.get_dtype(*name_value, scale=None)</span>
<span class="gi">+            if self._dtype.name != other_dtype.name or self._dtype.length != other_dtype.length:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Cannot extend an Array with format &#39;{self._dtype}&#39; from an array with typecode &#39;{iterable.typecode}&#39;.&quot;)</span>
<span class="gi">+            self.data += iterable.tobytes()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(iterable, str):</span>
<span class="gi">+                raise TypeError(&quot;Can&#39;t extend an Array with a str.&quot;)</span>
<span class="gi">+            for item in iterable:</span>
<span class="gi">+                self.data += self._create_element(item)</span>

<span class="gd">-    def insert(self, i: int, x: ElementType) -&gt;None:</span>
<span class="gi">+    def insert(self, i: int, x: ElementType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Insert a new element into the Array at position i.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i = min(i, len(self))  # Inserting beyond len of array inserts at the end (copying standard behaviour)</span>
<span class="gi">+        self.data.insert(self._create_element(x), i * self._dtype.length)</span>

<span class="gd">-    def pop(self, i: int=-1) -&gt;ElementType:</span>
<span class="gi">+    def pop(self, i: int = -1) -&gt; ElementType:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return and remove an element of the Array.

<span class="w"> </span>        Default is to return and remove the final element.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            raise IndexError(&quot;Can&#39;t pop from an empty Array.&quot;)</span>
<span class="gi">+        x = self[i]</span>
<span class="gi">+        del self[i]</span>
<span class="gi">+        return x</span>

<span class="gd">-    def byteswap(self) -&gt;None:</span>
<span class="gi">+    def byteswap(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Change the endianness in-place of all items in the Array.

<span class="w"> </span>        If the Array format is not a whole number of bytes a ValueError will be raised.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._dtype.length % 8 != 0:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;byteswap can only be used for whole-byte elements. The &#39;{self._dtype}&#39; format is {self._dtype.length} bits long.&quot;)</span>
<span class="gi">+        self.data.byteswap(self.itemsize // 8)</span>

<span class="gd">-    def count(self, value: ElementType) -&gt;int:</span>
<span class="gi">+    def count(self, value: ElementType) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return count of Array items that equal value.

<span class="w"> </span>        value -- The quantity to compare each Array element to. Type should be appropriate for the Array format.
<span class="gu">@@ -238,26 +345,52 @@ class Array:</span>
<span class="w"> </span>        For floating point types using a value of float(&#39;nan&#39;) will count the number of elements that are NaN.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if math.isnan(value):</span>
<span class="gi">+            return sum(math.isnan(i) for i in self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sum(i == value for i in self)</span>

<span class="gd">-    def tobytes(self) -&gt;bytes:</span>
<span class="gi">+    def tobytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the Array data as a bytes object, padding with zero bits if needed.

<span class="w"> </span>        Up to seven zero bits will be added at the end to byte align.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.data.tobytes()</span>

<span class="gd">-    def tofile(self, f: BinaryIO) -&gt;None:</span>
<span class="gi">+    def tofile(self, f: BinaryIO) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the Array data to a file object, padding with zero bits if needed.

<span class="w"> </span>        Up to seven zero bits will be added at the end to byte align.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.data.tofile(f)</span>
<span class="gi">+</span>
<span class="gi">+    def fromfile(self, f: BinaryIO, n: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        trailing_bit_length = len(self.data) % self._dtype.bitlength</span>
<span class="gi">+        if trailing_bit_length != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Cannot extend Array as its data length ({len(self.data)} bits) is not a multiple of the format length ({self._dtype.bitlength} bits).&quot;)</span>

<span class="gd">-    def pp(self, fmt: Optional[str]=None, width: int=120, show_offset: bool</span>
<span class="gd">-        =True, stream: TextIO=sys.stdout) -&gt;None:</span>
<span class="gi">+        new_data = Bits(f)</span>
<span class="gi">+        max_items = len(new_data) // self._dtype.length</span>
<span class="gi">+        items_to_append = max_items if n is None else min(n, max_items)</span>
<span class="gi">+        self.data += new_data[0: items_to_append * self._dtype.bitlength]</span>
<span class="gi">+        if n is not None and items_to_append &lt; n:</span>
<span class="gi">+            raise EOFError(f&quot;Only {items_to_append} were appended, not the {n} items requested.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def reverse(self) -&gt; None:</span>
<span class="gi">+        trailing_bit_length = len(self.data) % self._dtype.length</span>
<span class="gi">+        if trailing_bit_length != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Cannot reverse the items in the Array as its data length ({len(self.data)} bits) is not a multiple of the format length ({self._dtype.length} bits).&quot;)</span>
<span class="gi">+        for start_bit in range(0, len(self.data) // 2, self._dtype.length):</span>
<span class="gi">+            start_swap_bit = len(self.data) - start_bit - self._dtype.length</span>
<span class="gi">+            temp = self.data[start_bit: start_bit + self._dtype.length]</span>
<span class="gi">+            self.data[start_bit: start_bit + self._dtype.length] = self.data[</span>
<span class="gi">+                                                               start_swap_bit: start_swap_bit + self._dtype.length]</span>
<span class="gi">+            self.data[start_swap_bit: start_swap_bit + self._dtype.length] = temp</span>
<span class="gi">+</span>
<span class="gi">+    def pp(self, fmt: Optional[str] = None, width: int = 120,</span>
<span class="gi">+           show_offset: bool = True, stream: TextIO = sys.stdout) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pretty-print the Array contents.

<span class="w"> </span>        fmt -- Data format string. Defaults to current Array dtype.
<span class="gu">@@ -267,44 +400,183 @@ class Array:</span>
<span class="w"> </span>        stream -- A TextIO object with a write() method. Defaults to sys.stdout.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def equals(self, other: Any) -&gt;bool:</span>
<span class="gi">+        colour = Colour(not options.no_color)</span>
<span class="gi">+        sep = &#39; &#39;</span>
<span class="gi">+        dtype2 = None</span>
<span class="gi">+        tidy_fmt = None</span>
<span class="gi">+        if fmt is None:</span>
<span class="gi">+            fmt = self.dtype</span>
<span class="gi">+            dtype1 = self.dtype</span>
<span class="gi">+            tidy_fmt = &quot;dtype=&#39;&quot; + colour.purple + str(self.dtype) + &quot;&#39;&quot; + colour.off</span>
<span class="gi">+        else:</span>
<span class="gi">+            token_list = utils.preprocess_tokens(fmt)</span>
<span class="gi">+            if len(token_list) not in [1, 2]:</span>
<span class="gi">+                raise ValueError(f&quot;Only one or two tokens can be used in an Array.pp() format - &#39;{fmt}&#39; has {len(token_list)} tokens.&quot;)</span>
<span class="gi">+            name1, length1 = utils.parse_name_length_token(token_list[0])</span>
<span class="gi">+            dtype1 = Dtype(name1, length1)</span>
<span class="gi">+            if len(token_list) == 2:</span>
<span class="gi">+                name2, length2 = utils.parse_name_length_token(token_list[1])</span>
<span class="gi">+                dtype2 = Dtype(name2, length2)</span>
<span class="gi">+</span>
<span class="gi">+        token_length = dtype1.bitlength</span>
<span class="gi">+        if dtype2 is not None:</span>
<span class="gi">+            # For two types we&#39;re OK as long as they don&#39;t have different lengths given.</span>
<span class="gi">+            if dtype1.bitlength is not None and dtype2.bitlength is not None and dtype1.bitlength != dtype2.bitlength:</span>
<span class="gi">+                raise ValueError(f&quot;Two different format lengths specified (&#39;{fmt}&#39;). Either specify just one, or two the same length.&quot;)</span>
<span class="gi">+            if token_length is None:</span>
<span class="gi">+                token_length = dtype2.bitlength</span>
<span class="gi">+        if token_length is None:</span>
<span class="gi">+            token_length = self.itemsize</span>
<span class="gi">+</span>
<span class="gi">+        trailing_bit_length = len(self.data) % token_length</span>
<span class="gi">+        format_sep = &quot; : &quot;  # String to insert on each line between multiple formats</span>
<span class="gi">+        if tidy_fmt is None:</span>
<span class="gi">+            tidy_fmt = colour.purple + str(dtype1) + colour.off</span>
<span class="gi">+            if dtype2 is not None:</span>
<span class="gi">+                tidy_fmt += &#39;, &#39; + colour.blue + str(dtype2) + colour.off</span>
<span class="gi">+            tidy_fmt = &quot;fmt=&#39;&quot; + tidy_fmt + &quot;&#39;&quot;</span>
<span class="gi">+        data = self.data if trailing_bit_length == 0 else self.data[0: -trailing_bit_length]</span>
<span class="gi">+        length = len(self.data) // token_length</span>
<span class="gi">+        len_str = colour.green + str(length) + colour.off</span>
<span class="gi">+        stream.write(f&quot;&lt;{self.__class__.__name__} {tidy_fmt}, length={len_str}, itemsize={token_length} bits, total data size={(len(self.data) + 7) // 8} bytes&gt; [\n&quot;)</span>
<span class="gi">+        data._pp(dtype1, dtype2, token_length, width, sep, format_sep, show_offset, stream, False, token_length)</span>
<span class="gi">+        stream.write(&quot;]&quot;)</span>
<span class="gi">+        if trailing_bit_length != 0:</span>
<span class="gi">+            stream.write(&quot; + trailing_bits = &quot; + str(self.data[-trailing_bit_length:]))</span>
<span class="gi">+        stream.write(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def equals(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if format and all Array items are equal.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __iter__(self) -&gt;Iterable[ElementType]:</span>
<span class="gi">+        if isinstance(other, Array):</span>
<span class="gi">+            if self._dtype.length != other._dtype.length:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if self._dtype.name != other._dtype.name:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if self.data != other.data:</span>
<span class="gi">+                return False</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif isinstance(other, array.array):</span>
<span class="gi">+            # Assume we are comparing with an array type</span>
<span class="gi">+            if self.trailing_bits:</span>
<span class="gi">+                return False</span>
<span class="gi">+            # array&#39;s itemsize is in bytes, not bits.</span>
<span class="gi">+            if self.itemsize != other.itemsize * 8:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if len(self) != len(other):</span>
<span class="gi">+                return False</span>
<span class="gi">+            if self.tolist() != other.tolist():</span>
<span class="gi">+                return False</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterable[ElementType]:</span>
<span class="w"> </span>        start = 0
<span class="w"> </span>        for _ in range(len(self)):
<span class="w"> </span>            yield self._dtype.read_fn(self.data, start=start)
<span class="w"> </span>            start += self._dtype.length

<span class="gd">-    def __copy__(self) -&gt;Array:</span>
<span class="gi">+    def __copy__(self) -&gt; Array:</span>
<span class="w"> </span>        a_copy = self.__class__(self._dtype)
<span class="w"> </span>        a_copy.data = copy.copy(self.data)
<span class="w"> </span>        return a_copy

<span class="gd">-    def _apply_op_to_all_elements(self, op, value: Union[int, float, None],</span>
<span class="gd">-        is_comparison: bool=False) -&gt;Array:</span>
<span class="gi">+    def _apply_op_to_all_elements(self, op, value: Union[int, float, None], is_comparison: bool = False) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply op with value to each element of the Array and return a new Array&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _apply_op_to_all_elements_inplace(self, op, value: Union[int, float]</span>
<span class="gd">-        ) -&gt;Array:</span>
<span class="gi">+        new_array = self.__class__(&#39;bool&#39; if is_comparison else self._dtype)</span>
<span class="gi">+        new_data = BitArray()</span>
<span class="gi">+        failures = index = 0</span>
<span class="gi">+        msg = &#39;&#39;</span>
<span class="gi">+        if value is not None:</span>
<span class="gi">+            def partial_op(a):</span>
<span class="gi">+                return op(a, value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            def partial_op(a):</span>
<span class="gi">+                return op(a)</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            v = self._dtype.read_fn(self.data, start=self._dtype.length * i)</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_data.append(new_array._create_element(partial_op(v)))</span>
<span class="gi">+            except (CreationError, ZeroDivisionError, ValueError) as e:</span>
<span class="gi">+                if failures == 0:</span>
<span class="gi">+                    msg = str(e)</span>
<span class="gi">+                    index = i</span>
<span class="gi">+                failures += 1</span>
<span class="gi">+        if failures != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Applying operator &#39;{op.__name__}&#39; to Array caused {failures} errors. &quot;</span>
<span class="gi">+                             f&#39;First error at index {index} was: &quot;{msg}&quot;&#39;)</span>
<span class="gi">+        new_array.data = new_data</span>
<span class="gi">+        return new_array</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_op_to_all_elements_inplace(self, op, value: Union[int, float]) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply op with value to each element of the Array in place.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _apply_bitwise_op_to_all_elements(self, op, value: BitsType) -&gt;Array:</span>
<span class="gi">+        # This isn&#39;t really being done in-place, but it&#39;s simpler and faster for now?</span>
<span class="gi">+        new_data = BitArray()</span>
<span class="gi">+        failures = index = 0</span>
<span class="gi">+        msg = &#39;&#39;</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            v = self._dtype.read_fn(self.data, start=self._dtype.length * i)</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_data.append(self._create_element(op(v, value)))</span>
<span class="gi">+            except (CreationError, ZeroDivisionError, ValueError) as e:</span>
<span class="gi">+                if failures == 0:</span>
<span class="gi">+                    msg = str(e)</span>
<span class="gi">+                    index = i</span>
<span class="gi">+                failures += 1</span>
<span class="gi">+        if failures != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Applying operator &#39;{op.__name__}&#39; to Array caused {failures} errors. &quot;</span>
<span class="gi">+                             f&#39;First error at index {index} was: &quot;{msg}&quot;&#39;)</span>
<span class="gi">+        self.data = new_data</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_bitwise_op_to_all_elements(self, op, value: BitsType) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply op with value to each element of the Array as an unsigned integer and return a new Array&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        a_copy = self[:]</span>
<span class="gi">+        a_copy._apply_bitwise_op_to_all_elements_inplace(op, value)</span>
<span class="gi">+        return a_copy</span>

<span class="gd">-    def _apply_bitwise_op_to_all_elements_inplace(self, op, value: BitsType</span>
<span class="gd">-        ) -&gt;Array:</span>
<span class="gi">+    def _apply_bitwise_op_to_all_elements_inplace(self, op, value: BitsType) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply op with value to each element of the Array as an unsigned integer in place.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = BitArray._create_from_bitstype(value)</span>
<span class="gi">+        if len(value) != self._dtype.length:</span>
<span class="gi">+            raise ValueError(f&quot;Bitwise op needs a bitstring of length {self._dtype.length} to match format {self._dtype}.&quot;)</span>
<span class="gi">+        for start in range(0, len(self) * self._dtype.length, self._dtype.length):</span>
<span class="gi">+            self.data[start: start + self._dtype.length] = op(self.data[start: start + self._dtype.length], value)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _apply_op_between_arrays(self, op, other: Array, is_comparison: bool = False) -&gt; Array:</span>
<span class="gi">+        if len(self) != len(other):</span>
<span class="gi">+            msg = f&quot;Cannot operate element-wise on Arrays with different lengths ({len(self)} and {len(other)}).&quot;</span>
<span class="gi">+            if op in [operator.add, operator.iadd]:</span>
<span class="gi">+                msg += &quot; Use extend() method to concatenate Arrays.&quot;</span>
<span class="gi">+            if op in [operator.eq, operator.ne]:</span>
<span class="gi">+                msg += &quot; Use equals() method to compare Arrays for a single boolean result.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        if is_comparison:</span>
<span class="gi">+            new_type = dtype_register.get_dtype(&#39;bool&#39;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_type = self._promotetype(self._dtype, other._dtype)</span>
<span class="gi">+        new_array = self.__class__(new_type)</span>
<span class="gi">+        new_data = BitArray()</span>
<span class="gi">+        failures = index = 0</span>
<span class="gi">+        msg = &#39;&#39;</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            a = self._dtype.read_fn(self.data, start=self._dtype.length * i)</span>
<span class="gi">+            b = other._dtype.read_fn(other.data, start=other._dtype.length * i)</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_data.append(new_array._create_element(op(a, b)))</span>
<span class="gi">+            except (CreationError, ValueError, ZeroDivisionError) as e:</span>
<span class="gi">+                if failures == 0:</span>
<span class="gi">+                    msg = str(e)</span>
<span class="gi">+                    index = i</span>
<span class="gi">+                failures += 1</span>
<span class="gi">+        if failures != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Applying operator &#39;{op.__name__}&#39; between Arrays caused {failures} errors. &quot;</span>
<span class="gi">+                             f&#39;First error at index {index} was: &quot;{msg}&quot;&#39;)</span>
<span class="gi">+        new_array.data = new_data</span>
<span class="gi">+        return new_array</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _promotetype(cls, type1: Dtype, type2: Dtype) -&gt;Dtype:</span>
<span class="gi">+    def _promotetype(cls, type1: Dtype, type2: Dtype) -&gt; Dtype:</span>
<span class="w"> </span>        &quot;&quot;&quot;When combining types which one wins?

<span class="w"> </span>        1. We only deal with types representing floats or integers.
<span class="gu">@@ -315,165 +587,196 @@ class Array:</span>
<span class="w"> </span>        6. In a tie the first type wins against the second type.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __add__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+        def is_float(x): return x.return_type is float</span>
<span class="gi">+        def is_int(x): return x.return_type is int or x.return_type is bool</span>
<span class="gi">+        if is_float(type1) + is_int(type1) + is_float(type2) + is_int(type2) != 2:</span>
<span class="gi">+            raise ValueError(f&quot;Only integer and floating point types can be combined - not &#39;{type1}&#39; and &#39;{type2}&#39;.&quot;)</span>
<span class="gi">+        # If same type choose the widest</span>
<span class="gi">+        if type1.name == type2.name:</span>
<span class="gi">+            return type1 if type1.length &gt; type2.length else type2</span>
<span class="gi">+        # We choose floats above integers, irrespective of the widths</span>
<span class="gi">+        if is_float(type1) and is_int(type2):</span>
<span class="gi">+            return type1</span>
<span class="gi">+        if is_int(type1) and is_float(type2):</span>
<span class="gi">+            return type2</span>
<span class="gi">+        if is_float(type1) and is_float(type2):</span>
<span class="gi">+            return type2 if type2.length &gt; type1.length else type1</span>
<span class="gi">+        assert is_int(type1) and is_int(type2)</span>
<span class="gi">+        if type1.is_signed and not type2.is_signed:</span>
<span class="gi">+            return type1</span>
<span class="gi">+        if type2.is_signed and not type1.is_signed:</span>
<span class="gi">+            return type2</span>
<span class="gi">+        return type2 if type2.length &gt; type1.length else type1</span>
<span class="gi">+</span>
<span class="gi">+    # Operators between Arrays or an Array and scalar value</span>
<span class="gi">+</span>
<span class="gi">+    def __add__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add int or float to all elements.&quot;&quot;&quot;
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.add, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.add, other)

<span class="gd">-    def __iadd__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __iadd__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.add, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.add, other)

<span class="gd">-    def __isub__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __isub__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.sub, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.sub, other)

<span class="gd">-    def __sub__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __sub__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.sub, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.sub, other)

<span class="gd">-    def __mul__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __mul__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.mul, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.mul, other)

<span class="gd">-    def __imul__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __imul__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.mul, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.mul, other)

<span class="gd">-    def __floordiv__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __floordiv__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.floordiv, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.floordiv, other)

<span class="gd">-    def __ifloordiv__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __ifloordiv__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.floordiv, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.floordiv, other)

<span class="gd">-    def __truediv__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __truediv__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.truediv, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.truediv, other)

<span class="gd">-    def __itruediv__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __itruediv__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.truediv, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.truediv, other)

<span class="gd">-    def __rshift__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __rshift__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.rshift, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.rshift, other)

<span class="gd">-    def __lshift__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __lshift__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.lshift, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.lshift, other)

<span class="gd">-    def __irshift__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __irshift__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.rshift, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.rshift, other)

<span class="gd">-    def __ilshift__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __ilshift__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.lshift, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.lshift, other)

<span class="gd">-    def __mod__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __mod__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.mod, other)
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.mod, other)

<span class="gd">-    def __imod__(self, other: Union[int, Array]) -&gt;Array:</span>
<span class="gi">+    def __imod__(self, other: Union[int, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="w"> </span>            return self._apply_op_between_arrays(operator.mod, other)
<span class="w"> </span>        return self._apply_op_to_all_elements_inplace(operator.mod, other)

<span class="gd">-    def __and__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    # Bitwise operators</span>
<span class="gi">+</span>
<span class="gi">+    def __and__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.iand, other)

<span class="gd">-    def __iand__(self, other: BitsType) -&gt;Array:</span>
<span class="gd">-        return self._apply_bitwise_op_to_all_elements_inplace(operator.iand,</span>
<span class="gd">-            other)</span>
<span class="gi">+    def __iand__(self, other: BitsType) -&gt; Array:</span>
<span class="gi">+        return self._apply_bitwise_op_to_all_elements_inplace(operator.iand, other)</span>

<span class="gd">-    def __or__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    def __or__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.ior, other)

<span class="gd">-    def __ior__(self, other: BitsType) -&gt;Array:</span>
<span class="gd">-        return self._apply_bitwise_op_to_all_elements_inplace(operator.ior,</span>
<span class="gd">-            other)</span>
<span class="gi">+    def __ior__(self, other: BitsType) -&gt; Array:</span>
<span class="gi">+        return self._apply_bitwise_op_to_all_elements_inplace(operator.ior, other)</span>

<span class="gd">-    def __xor__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    def __xor__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.ixor, other)

<span class="gd">-    def __ixor__(self, other: BitsType) -&gt;Array:</span>
<span class="gd">-        return self._apply_bitwise_op_to_all_elements_inplace(operator.ixor,</span>
<span class="gd">-            other)</span>
<span class="gi">+    def __ixor__(self, other: BitsType) -&gt; Array:</span>
<span class="gi">+        return self._apply_bitwise_op_to_all_elements_inplace(operator.ixor, other)</span>

<span class="gd">-    def __rmul__(self, other: Union[int, float]) -&gt;Array:</span>
<span class="gi">+    # Reverse operators between a scalar value and an Array</span>
<span class="gi">+</span>
<span class="gi">+    def __rmul__(self, other: Union[int, float]) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.mul, other)

<span class="gd">-    def __radd__(self, other: Union[int, float]) -&gt;Array:</span>
<span class="gi">+    def __radd__(self, other: Union[int, float]) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.add, other)

<span class="gd">-    def __rsub__(self, other: Union[int, float]) -&gt;Array:</span>
<span class="gi">+    def __rsub__(self, other: Union[int, float]) -&gt; Array:</span>
<span class="gi">+        # i - A == (-A) + i</span>
<span class="w"> </span>        neg = self._apply_op_to_all_elements(operator.neg, None)
<span class="w"> </span>        return neg._apply_op_to_all_elements(operator.add, other)

<span class="gd">-    def __rand__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    # Reverse operators between a scalar and something that can be a BitArray.</span>
<span class="gi">+</span>
<span class="gi">+    def __rand__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.iand, other)

<span class="gd">-    def __ror__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    def __ror__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.ior, other)

<span class="gd">-    def __rxor__(self, other: BitsType) -&gt;Array:</span>
<span class="gi">+    def __rxor__(self, other: BitsType) -&gt; Array:</span>
<span class="w"> </span>        return self._apply_bitwise_op_to_all_elements(operator.ixor, other)

<span class="gd">-    def __lt__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    # Comparison operators</span>
<span class="gi">+</span>
<span class="gi">+    def __lt__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="gd">-            return self._apply_op_between_arrays(operator.lt, other,</span>
<span class="gd">-                is_comparison=True)</span>
<span class="gd">-        return self._apply_op_to_all_elements(operator.lt, other,</span>
<span class="gd">-            is_comparison=True)</span>
<span class="gi">+            return self._apply_op_between_arrays(operator.lt, other, is_comparison=True)</span>
<span class="gi">+        return self._apply_op_to_all_elements(operator.lt, other, is_comparison=True)</span>

<span class="gd">-    def __gt__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __gt__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="gd">-            return self._apply_op_between_arrays(operator.gt, other,</span>
<span class="gd">-                is_comparison=True)</span>
<span class="gd">-        return self._apply_op_to_all_elements(operator.gt, other,</span>
<span class="gd">-            is_comparison=True)</span>
<span class="gi">+            return self._apply_op_between_arrays(operator.gt, other, is_comparison=True)</span>
<span class="gi">+        return self._apply_op_to_all_elements(operator.gt, other, is_comparison=True)</span>

<span class="gd">-    def __ge__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __ge__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="gd">-            return self._apply_op_between_arrays(operator.ge, other,</span>
<span class="gd">-                is_comparison=True)</span>
<span class="gd">-        return self._apply_op_to_all_elements(operator.ge, other,</span>
<span class="gd">-            is_comparison=True)</span>
<span class="gi">+            return self._apply_op_between_arrays(operator.ge, other, is_comparison=True)</span>
<span class="gi">+        return self._apply_op_to_all_elements(operator.ge, other, is_comparison=True)</span>

<span class="gd">-    def __le__(self, other: Union[int, float, Array]) -&gt;Array:</span>
<span class="gi">+    def __le__(self, other: Union[int, float, Array]) -&gt; Array:</span>
<span class="w"> </span>        if isinstance(other, Array):
<span class="gd">-            return self._apply_op_between_arrays(operator.le, other,</span>
<span class="gd">-                is_comparison=True)</span>
<span class="gd">-        return self._apply_op_to_all_elements(operator.le, other,</span>
<span class="gd">-            is_comparison=True)</span>
<span class="gi">+            return self._apply_op_between_arrays(operator.le, other, is_comparison=True)</span>
<span class="gi">+        return self._apply_op_to_all_elements(operator.le, other, is_comparison=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _eq_ne(self, op, other: Any) -&gt; Array:</span>
<span class="gi">+        if isinstance(other, (int, float, str, Bits)):</span>
<span class="gi">+            return self._apply_op_to_all_elements(op, other, is_comparison=True)</span>
<span class="gi">+        try:</span>
<span class="gi">+            other = self.__class__(self.dtype, other)</span>
<span class="gi">+        except:</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+        finally:</span>
<span class="gi">+            return self._apply_op_between_arrays(op, other, is_comparison=True)</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;Array:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; Array:</span>
<span class="w"> </span>        return self._eq_ne(operator.eq, other)

<span class="gd">-    def __ne__(self, other: Any) -&gt;Array:</span>
<span class="gi">+    def __ne__(self, other: Any) -&gt; Array:</span>
<span class="w"> </span>        return self._eq_ne(operator.ne, other)

<span class="gi">+    # Unary operators</span>
<span class="gi">+</span>
<span class="w"> </span>    def __neg__(self):
<span class="w"> </span>        return self._apply_op_to_all_elements(operator.neg, None)

<span class="w"> </span>    def __abs__(self):
<span class="gd">-        return self._apply_op_to_all_elements(operator.abs, None)</span>
<span class="gi">+        return self._apply_op_to_all_elements(operator.abs, None)</span>
\ No newline at end of file
<span class="gh">diff --git a/bitstring/bitarray_.py b/bitstring/bitarray_.py</span>
<span class="gh">index 5d6204f..4e68684 100644</span>
<span class="gd">--- a/bitstring/bitarray_.py</span>
<span class="gi">+++ b/bitstring/bitarray_.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>import numbers
<span class="w"> </span>import re
<span class="gu">@@ -7,6 +8,7 @@ from typing import Union, List, Iterable, Any, Optional</span>
<span class="w"> </span>from bitstring import utils
<span class="w"> </span>from bitstring.exceptions import CreationError, Error
<span class="w"> </span>from bitstring.bits import Bits, BitsType, TBits
<span class="gi">+</span>
<span class="w"> </span>import bitstring.dtypes


<span class="gu">@@ -64,11 +66,14 @@ class BitArray(Bits):</span>
<span class="w"> </span>    len -- Length of the bitstring in bits.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="gi">+    # As BitArray objects are mutable, we shouldn&#39;t allow them to be hashed.</span>
<span class="w"> </span>    __hash__: None = None

<span class="gd">-    def __init__(self, auto: Optional[Union[BitsType, int]]=None, /, length:</span>
<span class="gd">-        Optional[int]=None, offset: Optional[int]=None, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,</span>
<span class="gi">+                 offset: Optional[int] = None, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Either specify an &#39;auto&#39; initialiser:
<span class="w"> </span>        A string of comma separated tokens, an integer, a file object,
<span class="w"> </span>        a bytearray, a boolean iterable or another bitstring.
<span class="gu">@@ -111,29 +116,27 @@ class BitArray(Bits):</span>
<span class="w"> </span>            self._bitstore = self._bitstore._copy()
<span class="w"> </span>            self._bitstore.immutable = False

<span class="gd">-    def copy(self: TBits) -&gt;TBits:</span>
<span class="gi">+    def copy(self: TBits) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of the bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__copy__()</span>

<span class="gd">-    def __setattr__(self, attribute, value) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, attribute, value) -&gt; None:</span>
<span class="w"> </span>        try:
<span class="gi">+            # First try the ordinary attribute setter</span>
<span class="w"> </span>            super().__setattr__(attribute, value)
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            dtype = bitstring.dtypes.Dtype(attribute)
<span class="w"> </span>            x = object.__new__(Bits)
<span class="w"> </span>            if (set_fn := dtype.set_fn) is None:
<span class="gd">-                raise AttributeError(</span>
<span class="gd">-                    f&quot;Cannot set attribute &#39;{attribute}&#39; as it does not have a set_fn.&quot;</span>
<span class="gd">-                    )</span>
<span class="gi">+                raise AttributeError(f&quot;Cannot set attribute &#39;{attribute}&#39; as it does not have a set_fn.&quot;)</span>
<span class="w"> </span>            set_fn(x, value)
<span class="w"> </span>            if len(x) != dtype.bitlength:
<span class="gd">-                raise CreationError(</span>
<span class="gd">-                    f&quot;Can&#39;t initialise with value of length {len(x)} bits, as attribute has length of {dtype.bitlength} bits.&quot;</span>
<span class="gd">-                    )</span>
<span class="gi">+                raise CreationError(f&quot;Can&#39;t initialise with value of length {len(x)} bits, &quot;</span>
<span class="gi">+                                    f&quot;as attribute has length of {dtype.bitlength} bits.&quot;)</span>
<span class="w"> </span>            self._bitstore = x._bitstore
<span class="w"> </span>            return

<span class="gd">-    def __iadd__(self, bs: BitsType) -&gt;BitArray:</span>
<span class="gi">+    def __iadd__(self, bs: BitsType) -&gt; BitArray:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append bs to current bitstring. Return self.

<span class="w"> </span>        bs -- the bitstring to append.
<span class="gu">@@ -142,20 +145,62 @@ class BitArray(Bits):</span>
<span class="w"> </span>        self._append(bs)
<span class="w"> </span>        return self

<span class="gd">-    def __copy__(self) -&gt;BitArray:</span>
<span class="gi">+    def __copy__(self) -&gt; BitArray:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new copy of the BitArray.&quot;&quot;&quot;
<span class="w"> </span>        s_copy = BitArray()
<span class="w"> </span>        s_copy._bitstore = self._bitstore._copy()
<span class="w"> </span>        assert s_copy._bitstore.immutable is False
<span class="w"> </span>        return s_copy

<span class="gd">-    def __setitem__(self, key: Union[slice, int], value: BitsType) -&gt;None:</span>
<span class="gi">+    def _setitem_int(self, key: int, value: Union[BitsType, int]) -&gt; None:</span>
<span class="gi">+        if isinstance(value, numbers.Integral):</span>
<span class="gi">+            if value == 0:</span>
<span class="gi">+                self._bitstore[key] = 0</span>
<span class="gi">+                return</span>
<span class="gi">+            if value in (1, -1):</span>
<span class="gi">+                self._bitstore[key] = 1</span>
<span class="gi">+                return</span>
<span class="gi">+            raise ValueError(f&quot;Cannot set a single bit with integer {value}.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self._create_from_bitstype(value)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            raise TypeError(f&quot;Bitstring, integer or string expected. Got {type(value)}.&quot;)</span>
<span class="gi">+        positive_key = key + len(self) if key &lt; 0 else key</span>
<span class="gi">+        if positive_key &lt; 0 or positive_key &gt;= len(self._bitstore):</span>
<span class="gi">+            raise IndexError(f&quot;Bit position {key} out of range.&quot;)</span>
<span class="gi">+        self._bitstore[positive_key: positive_key + 1] = value._bitstore</span>
<span class="gi">+</span>
<span class="gi">+    def _setitem_slice(self, key: slice, value: BitsType) -&gt; None:</span>
<span class="gi">+        if isinstance(value, numbers.Integral):</span>
<span class="gi">+            value = int(value)</span>
<span class="gi">+            if key.step not in [None, -1, 1]:</span>
<span class="gi">+                if value in [0, 1]:</span>
<span class="gi">+                    self.set(value, range(*key.indices(len(self))))</span>
<span class="gi">+                    return</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&quot;Can&#39;t assign an integer except 0 or 1 to a slice with a step value.&quot;)</span>
<span class="gi">+            # To find the length we first get the slice</span>
<span class="gi">+            s = self._bitstore.getslice(key.start, key.stop)</span>
<span class="gi">+            length = len(s)</span>
<span class="gi">+            # Now create an int of the correct length</span>
<span class="gi">+            if value &gt;= 0:</span>
<span class="gi">+                value = self.__class__(uint=value, length=length)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = self.__class__(int=value, length=length)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = self._create_from_bitstype(value)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                raise TypeError(f&quot;Bitstring, integer or string expected. Got {type(value)}.&quot;)</span>
<span class="gi">+        self._bitstore.__setitem__(key, value._bitstore)</span>
<span class="gi">+</span>
<span class="gi">+    def __setitem__(self, key: Union[slice, int], value: BitsType) -&gt; None:</span>
<span class="w"> </span>        if isinstance(key, numbers.Integral):
<span class="w"> </span>            self._setitem_int(int(key), value)
<span class="w"> </span>        else:
<span class="w"> </span>            self._setitem_slice(key, value)

<span class="gd">-    def __delitem__(self, key: Union[slice, int]) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: Union[slice, int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete item or range.

<span class="w"> </span>        &gt;&gt;&gt; a = BitArray(&#39;0x001122&#39;)
<span class="gu">@@ -167,37 +212,37 @@ class BitArray(Bits):</span>
<span class="w"> </span>        self._bitstore.__delitem__(key)
<span class="w"> </span>        return

<span class="gd">-    def __ilshift__(self: TBits, n: int) -&gt;TBits:</span>
<span class="gi">+    def __ilshift__(self: TBits, n: int) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shift bits by n to the left in place. Return self.

<span class="w"> </span>        n -- the number of bits to shift. Must be &gt;= 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift by a negative amount.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift by a negative amount.&quot;)</span>
<span class="w"> </span>        if not len(self):
<span class="gd">-            raise ValueError(&#39;Cannot shift an empty bitstring.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift an empty bitstring.&quot;)</span>
<span class="w"> </span>        if not n:
<span class="w"> </span>            return self
<span class="w"> </span>        n = min(n, len(self))
<span class="w"> </span>        return self._ilshift(n)

<span class="gd">-    def __irshift__(self: TBits, n: int) -&gt;TBits:</span>
<span class="gi">+    def __irshift__(self: TBits, n: int) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shift bits by n to the right in place. Return self.

<span class="w"> </span>        n -- the number of bits to shift. Must be &gt;= 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift by a negative amount.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift by a negative amount.&quot;)</span>
<span class="w"> </span>        if not len(self):
<span class="gd">-            raise ValueError(&#39;Cannot shift an empty bitstring.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift an empty bitstring.&quot;)</span>
<span class="w"> </span>        if not n:
<span class="w"> </span>            return self
<span class="w"> </span>        n = min(n, len(self))
<span class="w"> </span>        return self._irshift(n)

<span class="gd">-    def __imul__(self: TBits, n: int) -&gt;TBits:</span>
<span class="gi">+    def __imul__(self: TBits, n: int) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Concatenate n copies of self in place. Return self.

<span class="w"> </span>        Called for expressions of the form &#39;a *= 3&#39;.
<span class="gu">@@ -205,27 +250,57 @@ class BitArray(Bits):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot multiply by a negative integer.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot multiply by a negative integer.&quot;)</span>
<span class="w"> </span>        return self._imul(n)

<span class="gd">-    def __ior__(self: TBits, bs: BitsType) -&gt;TBits:</span>
<span class="gi">+    def __ior__(self: TBits, bs: BitsType) -&gt; TBits:</span>
<span class="w"> </span>        bs = self._create_from_bitstype(bs)
<span class="w"> </span>        self._bitstore |= bs._bitstore
<span class="w"> </span>        return self

<span class="gd">-    def __iand__(self: TBits, bs: BitsType) -&gt;TBits:</span>
<span class="gi">+    def __iand__(self: TBits, bs: BitsType) -&gt; TBits:</span>
<span class="w"> </span>        bs = self._create_from_bitstype(bs)
<span class="w"> </span>        self._bitstore &amp;= bs._bitstore
<span class="w"> </span>        return self

<span class="gd">-    def __ixor__(self: TBits, bs: BitsType) -&gt;TBits:</span>
<span class="gi">+    def __ixor__(self: TBits, bs: BitsType) -&gt; TBits:</span>
<span class="w"> </span>        bs = self._create_from_bitstype(bs)
<span class="w"> </span>        self._bitstore ^= bs._bitstore
<span class="w"> </span>        return self

<span class="gd">-    def replace(self, old: BitsType, new: BitsType, start: Optional[int]=</span>
<span class="gd">-        None, end: Optional[int]=None, count: Optional[int]=None,</span>
<span class="gd">-        bytealigned: Optional[bool]=None) -&gt;int:</span>
<span class="gi">+    def _replace(self, old: Bits, new: Bits, start: int, end: int, count: int, bytealigned: Optional[bool]) -&gt; int:</span>
<span class="gi">+        if bytealigned is None:</span>
<span class="gi">+            bytealigned = bitstring.options.bytealigned</span>
<span class="gi">+        # First find all the places where we want to do the replacements</span>
<span class="gi">+        starting_points: List[int] = []</span>
<span class="gi">+        for x in self.findall(old, start, end, bytealigned=bytealigned):</span>
<span class="gi">+            if not starting_points:</span>
<span class="gi">+                starting_points.append(x)</span>
<span class="gi">+            elif x &gt;= starting_points[-1] + len(old):</span>
<span class="gi">+                # Can only replace here if it hasn&#39;t already been replaced!</span>
<span class="gi">+                starting_points.append(x)</span>
<span class="gi">+            if count != 0 and len(starting_points) == count:</span>
<span class="gi">+                break</span>
<span class="gi">+        if not starting_points:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        replacement_list = [self._bitstore.getslice(0, starting_points[0])]</span>
<span class="gi">+        for i in range(len(starting_points) - 1):</span>
<span class="gi">+            replacement_list.append(new._bitstore)</span>
<span class="gi">+            replacement_list.append(</span>
<span class="gi">+                self._bitstore.getslice(starting_points[i] + len(old), starting_points[i + 1]))</span>
<span class="gi">+        # Final replacement</span>
<span class="gi">+        replacement_list.append(new._bitstore)</span>
<span class="gi">+        replacement_list.append(self._bitstore.getslice(starting_points[-1] + len(old), None))</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            # Addition of bitarray is always on the right, so assemble from other end</span>
<span class="gi">+            replacement_list.reverse()</span>
<span class="gi">+        self._bitstore.clear()</span>
<span class="gi">+        for r in replacement_list:</span>
<span class="gi">+            self._bitstore += r</span>
<span class="gi">+        return len(starting_points)</span>
<span class="gi">+</span>
<span class="gi">+    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+                count: Optional[int] = None, bytealigned: Optional[bool] = None) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace all occurrences of old with new in place.

<span class="w"> </span>        Returns number of replacements made.
<span class="gu">@@ -245,9 +320,20 @@ class BitArray(Bits):</span>
<span class="w"> </span>        out of range.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def insert(self, bs: BitsType, pos: int) -&gt;None:</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        old = self._create_from_bitstype(old)</span>
<span class="gi">+        new = self._create_from_bitstype(new)</span>
<span class="gi">+        if len(old) == 0:</span>
<span class="gi">+            raise ValueError(&quot;Empty bitstring cannot be replaced.&quot;)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+</span>
<span class="gi">+        if new is self:</span>
<span class="gi">+            # Prevent self assignment woes</span>
<span class="gi">+            new = copy.copy(self)</span>
<span class="gi">+        return self._replace(old, new, start, end, 0 if count is None else count, bytealigned)</span>
<span class="gi">+</span>
<span class="gi">+    def insert(self, bs: BitsType, pos: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Insert bs at bit position pos.

<span class="w"> </span>        bs -- The bitstring to insert.
<span class="gu">@@ -256,9 +342,18 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises ValueError if pos &lt; 0 or pos &gt; len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def overwrite(self, bs: BitsType, pos: int) -&gt;None:</span>
<span class="gi">+        bs = self._create_from_bitstype(bs)</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        if bs is self:</span>
<span class="gi">+            bs = self._copy()</span>
<span class="gi">+        if pos &lt; 0:</span>
<span class="gi">+            pos += len(self)</span>
<span class="gi">+        if not 0 &lt;= pos &lt;= len(self):</span>
<span class="gi">+            raise ValueError(&quot;Invalid insert position.&quot;)</span>
<span class="gi">+        self._insert(bs, pos)</span>
<span class="gi">+</span>
<span class="gi">+    def overwrite(self, bs: BitsType, pos: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Overwrite with bs at bit position pos.

<span class="w"> </span>        bs -- The bitstring to overwrite with.
<span class="gu">@@ -267,26 +362,39 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises ValueError if pos &lt; 0 or pos &gt; len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bs = self._create_from_bitstype(bs)</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        if pos &lt; 0:</span>
<span class="gi">+            pos += len(self)</span>
<span class="gi">+        if pos &lt; 0 or pos &gt; len(self):</span>
<span class="gi">+            raise ValueError(&quot;Overwrite starts outside boundary of bitstring.&quot;)</span>
<span class="gi">+        self._overwrite(bs, pos)</span>

<span class="gd">-    def append(self, bs: BitsType) -&gt;None:</span>
<span class="gi">+    def append(self, bs: BitsType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append a bitstring to the current bitstring.

<span class="w"> </span>        bs -- The bitstring to append.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._append(bs)</span>

<span class="gd">-    def prepend(self, bs: BitsType) -&gt;None:</span>
<span class="gi">+    def prepend(self, bs: BitsType) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepend a bitstring to the current bitstring.

<span class="w"> </span>        bs -- The bitstring to prepend.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._prepend(bs)</span>
<span class="gi">+</span>
<span class="gi">+    def _append_msb0(self, bs: BitsType) -&gt; None:</span>
<span class="gi">+        self._addright(self._create_from_bitstype(bs))</span>

<span class="gd">-    def reverse(self, start: Optional[int]=None, end: Optional[int]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _append_lsb0(self, bs: BitsType) -&gt; None:</span>
<span class="gi">+        bs = self._create_from_bitstype(bs)</span>
<span class="gi">+        self._addleft(bs)</span>
<span class="gi">+</span>
<span class="gi">+    def reverse(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reverse bits in-place.

<span class="w"> </span>        start -- Position of first bit to reverse. Defaults to 0.
<span class="gu">@@ -298,10 +406,15 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises ValueError if start &lt; 0, end &gt; len(self) or end &lt; start.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        if start == 0 and end == len(self):</span>
<span class="gi">+            self._bitstore.reverse()</span>
<span class="gi">+            return</span>
<span class="gi">+        s = self._slice(start, end)</span>
<span class="gi">+        s._bitstore.reverse()</span>
<span class="gi">+        self[start:end] = s</span>

<span class="gd">-    def set(self, value: Any, pos: Optional[Union[int, Iterable[int]]]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def set(self, value: Any, pos: Optional[Union[int, Iterable[int]]] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set one or many bits to 1 or 0.

<span class="w"> </span>        value -- If bool(value) is True bits are set to 1, otherwise they are set to 0.
<span class="gu">@@ -312,9 +425,20 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises IndexError if pos &lt; -len(self) or pos &gt;= len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            # Set all bits to either 1 or 0</span>
<span class="gi">+            self._setint(-1 if value else 0)</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(pos, abc.Iterable):</span>
<span class="gi">+            pos = (pos,)</span>
<span class="gi">+        v = 1 if value else 0</span>
<span class="gi">+        if isinstance(pos, range):</span>
<span class="gi">+            self._bitstore.__setitem__(slice(pos.start, pos.stop, pos.step), v)</span>
<span class="gi">+            return</span>
<span class="gi">+        for p in pos:</span>
<span class="gi">+            self._bitstore[p] = v</span>

<span class="gd">-    def invert(self, pos: Optional[Union[Iterable[int], int]]=None) -&gt;None:</span>
<span class="gi">+    def invert(self, pos: Optional[Union[Iterable[int], int]] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invert one or many bits from 0 to 1 or vice versa.

<span class="w"> </span>        pos -- Either a single bit position or an iterable of bit positions.
<span class="gu">@@ -323,10 +447,21 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises IndexError if pos &lt; -len(self) or pos &gt;= len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def ror(self, bits: int, start: Optional[int]=None, end: Optional[int]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            self._invert_all()</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(pos, abc.Iterable):</span>
<span class="gi">+            pos = (pos,)</span>
<span class="gi">+        length = len(self)</span>
<span class="gi">+</span>
<span class="gi">+        for p in pos:</span>
<span class="gi">+            if p &lt; 0:</span>
<span class="gi">+                p += length</span>
<span class="gi">+            if not 0 &lt;= p &lt; length:</span>
<span class="gi">+                raise IndexError(f&quot;Bit position {p} out of range.&quot;)</span>
<span class="gi">+            self._invert(p)</span>
<span class="gi">+</span>
<span class="gi">+    def ror(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Rotate bits to the right in-place.

<span class="w"> </span>        bits -- The number of bits to rotate by.
<span class="gu">@@ -336,10 +471,22 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises ValueError if bits &lt; 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not len(self):</span>
<span class="gi">+            raise Error(&quot;Cannot rotate an empty bitstring.&quot;)</span>
<span class="gi">+        if bits &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot rotate by negative amount.&quot;)</span>
<span class="gi">+        self._ror(bits, start, end)</span>
<span class="gi">+</span>
<span class="gi">+    def _ror_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        start, end = self._validate_slice(start, end)  # the _slice deals with msb0/lsb0</span>
<span class="gi">+        bits %= (end - start)</span>
<span class="gi">+        if not bits:</span>
<span class="gi">+            return</span>
<span class="gi">+        rhs = self._slice(end - bits, end)</span>
<span class="gi">+        self._delete(bits, end - bits)</span>
<span class="gi">+        self._insert(rhs, start)</span>

<span class="gd">-    def rol(self, bits: int, start: Optional[int]=None, end: Optional[int]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def rol(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Rotate bits to the left in-place.

<span class="w"> </span>        bits -- The number of bits to rotate by.
<span class="gu">@@ -349,11 +496,23 @@ class BitArray(Bits):</span>
<span class="w"> </span>        Raises ValueError if bits &lt; 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not len(self):</span>
<span class="gi">+            raise Error(&quot;Cannot rotate an empty bitstring.&quot;)</span>
<span class="gi">+        if bits &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot rotate by negative amount.&quot;)</span>
<span class="gi">+        self._rol(bits, start, end)</span>
<span class="gi">+</span>
<span class="gi">+    def _rol_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None):</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        bits %= (end - start)</span>
<span class="gi">+        if bits == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        lhs = self._slice(start, start + bits)</span>
<span class="gi">+        self._delete(bits, start)</span>
<span class="gi">+        self._insert(lhs, end - bits)</span>

<span class="gd">-    def byteswap(self, fmt: Optional[Union[int, Iterable[int], str]]=None,</span>
<span class="gd">-        start: Optional[int]=None, end: Optional[int]=None, repeat: bool=True</span>
<span class="gd">-        ) -&gt;int:</span>
<span class="gi">+    def byteswap(self, fmt: Optional[Union[int, Iterable[int], str]] = None, start: Optional[int] = None,</span>
<span class="gi">+                 end: Optional[int] = None, repeat: bool = True) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Change the endianness in-place. Return number of repeats of fmt done.

<span class="w"> </span>        fmt -- A compact structure string, an integer number of bytes or
<span class="gu">@@ -365,8 +524,53 @@ class BitArray(Bits):</span>
<span class="w"> </span>                  as much as possible.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+        start_v, end_v = self._validate_slice(start, end)</span>
<span class="gi">+        if fmt is None or fmt == 0:</span>
<span class="gi">+            # reverse all of the whole bytes.</span>
<span class="gi">+            bytesizes = [(end_v - start_v) // 8]</span>
<span class="gi">+        elif isinstance(fmt, numbers.Integral):</span>
<span class="gi">+            if fmt &lt; 0:</span>
<span class="gi">+                raise ValueError(f&quot;Improper byte length {fmt}.&quot;)</span>
<span class="gi">+            bytesizes = [fmt]</span>
<span class="gi">+        elif isinstance(fmt, str):</span>
<span class="gi">+            if not (m := utils.BYTESWAP_STRUCT_PACK_RE.match(fmt)):</span>
<span class="gi">+                raise ValueError(f&quot;Cannot parse format string {fmt}.&quot;)</span>
<span class="gi">+            # Split the format string into a list of &#39;q&#39;, &#39;4h&#39; etc.</span>
<span class="gi">+            formatlist = re.findall(utils.STRUCT_SPLIT_RE, m.group(&#39;fmt&#39;))</span>
<span class="gi">+            # Now deal with multiplicative factors, 4h -&gt; hhhh etc.</span>
<span class="gi">+            bytesizes = []</span>
<span class="gi">+            for f in formatlist:</span>
<span class="gi">+                if len(f) == 1:</span>
<span class="gi">+                    bytesizes.append(utils.PACK_CODE_SIZE[f])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    bytesizes.extend([utils.PACK_CODE_SIZE[f[-1]]] * int(f[:-1]))</span>
<span class="gi">+        elif isinstance(fmt, abc.Iterable):</span>
<span class="gi">+            bytesizes = fmt</span>
<span class="gi">+            for bytesize in bytesizes:</span>
<span class="gi">+                if not isinstance(bytesize, numbers.Integral) or bytesize &lt; 0:</span>
<span class="gi">+                    raise ValueError(f&quot;Improper byte length {bytesize}.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;Format must be an integer, string or iterable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        repeats = 0</span>
<span class="gi">+        totalbitsize: int = 8 * sum(bytesizes)</span>
<span class="gi">+        if not totalbitsize:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if repeat:</span>
<span class="gi">+            # Try to repeat up to the end of the bitstring.</span>
<span class="gi">+            finalbit = end_v</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Just try one (set of) byteswap(s).</span>
<span class="gi">+            finalbit = start_v + totalbitsize</span>
<span class="gi">+        for patternend in range(start_v + totalbitsize, finalbit + 1, totalbitsize):</span>
<span class="gi">+            bytestart = patternend - totalbitsize</span>
<span class="gi">+            for bytesize in bytesizes:</span>
<span class="gi">+                byteend = bytestart + bytesize * 8</span>
<span class="gi">+                self._reversebytes(bytestart, byteend)</span>
<span class="gi">+                bytestart += bytesize * 8</span>
<span class="gi">+            repeats += 1</span>
<span class="gi">+        return repeats</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove all bits, reset to zero length.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._clear()</span>
<span class="gh">diff --git a/bitstring/bits.py b/bitstring/bits.py</span>
<span class="gh">index f6d7d08..6893709 100644</span>
<span class="gd">--- a/bitstring/bits.py</span>
<span class="gi">+++ b/bitstring/bits.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import numbers
<span class="w"> </span>import pathlib
<span class="w"> </span>import sys
<span class="gu">@@ -18,9 +19,13 @@ from bitstring.dtypes import Dtype, dtype_register</span>
<span class="w"> </span>from bitstring.fp8 import p4binary_fmt, p3binary_fmt
<span class="w"> </span>from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt
<span class="w"> </span>from bitstring.bitstring_options import Colour
<span class="gd">-BitsType = Union[&#39;Bits&#39;, str, Iterable[Any], bool, BinaryIO, bytearray,</span>
<span class="gd">-    bytes, memoryview, bitarray.bitarray]</span>
<span class="gd">-TBits = TypeVar(&#39;TBits&#39;, bound=&#39;Bits&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# Things that can be converted to Bits when a Bits type is needed</span>
<span class="gi">+BitsType = Union[&#39;Bits&#39;, str, Iterable[Any], bool, BinaryIO, bytearray, bytes, memoryview, bitarray.bitarray]</span>
<span class="gi">+</span>
<span class="gi">+TBits = TypeVar(&quot;TBits&quot;, bound=&#39;Bits&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# Maximum number of digits to use in __str__ and __repr__.</span>
<span class="w"> </span>MAX_CHARS: int = 250


<span class="gu">@@ -61,10 +66,10 @@ class Bits:</span>
<span class="w"> </span>    len -- Length of the bitstring in bits.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_bitstore&#39;, &#39;_filename&#39;</span>
<span class="gi">+    __slots__ = (&#39;_bitstore&#39;, &#39;_filename&#39;)</span>

<span class="gd">-    def __init__(self, auto: Optional[Union[BitsType, int]]=None, /, length:</span>
<span class="gd">-        Optional[int]=None, offset: Optional[int]=None, **kwargs) -&gt;None:</span>
<span class="gi">+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,</span>
<span class="gi">+                 offset: Optional[int] = None, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Either specify an &#39;auto&#39; initialiser:
<span class="w"> </span>        A string of comma separated tokens, an integer, a file object,
<span class="w"> </span>        a bytearray, a boolean iterable, an array or another bitstring.
<span class="gu">@@ -105,11 +110,11 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._bitstore.immutable = True

<span class="gd">-    def __new__(cls: Type[TBits], auto: Optional[Union[BitsType, int]]=None,</span>
<span class="gd">-        /, length: Optional[int]=None, offset: Optional[int]=None, pos:</span>
<span class="gd">-        Optional[int]=None, **kwargs) -&gt;TBits:</span>
<span class="gi">+    def __new__(cls: Type[TBits], auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,</span>
<span class="gi">+                offset: Optional[int] = None, pos: Optional[int] = None, **kwargs) -&gt; TBits:</span>
<span class="w"> </span>        x = super().__new__(cls)
<span class="w"> </span>        if auto is None and not kwargs:
<span class="gi">+            # No initialiser so fill with zero bits up to length</span>
<span class="w"> </span>            if length is not None:
<span class="w"> </span>                x._bitstore = BitStore(length)
<span class="w"> </span>                x._bitstore.setall(0)
<span class="gu">@@ -119,39 +124,80 @@ class Bits:</span>
<span class="w"> </span>        x._initialise(auto, length, offset, **kwargs)
<span class="w"> </span>        return x

<span class="gd">-    def __getattr__(self, attribute: str) -&gt;Any:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _create_from_bitstype(cls: Type[TBits], auto: BitsType, /) -&gt; TBits:</span>
<span class="gi">+        if isinstance(auto, cls):</span>
<span class="gi">+            return auto</span>
<span class="gi">+        b = super().__new__(cls)</span>
<span class="gi">+        b._setauto_no_length_or_offset(auto)</span>
<span class="gi">+        return b</span>
<span class="gi">+</span>
<span class="gi">+    def _initialise(self, auto: Any, /, length: Optional[int], offset: Optional[int], **kwargs) -&gt; None:</span>
<span class="gi">+        if auto is not None:</span>
<span class="gi">+            if isinstance(auto, numbers.Integral):</span>
<span class="gi">+                # Initialise with s zero bits.</span>
<span class="gi">+                if auto &lt; 0:</span>
<span class="gi">+                    raise bitstring.CreationError(f&quot;Can&#39;t create bitstring of negative length {auto}.&quot;)</span>
<span class="gi">+                self._bitstore = BitStore(int(auto))</span>
<span class="gi">+                self._bitstore.setall(0)</span>
<span class="gi">+                return</span>
<span class="gi">+            self._setauto(auto, length, offset)</span>
<span class="gi">+            return</span>
<span class="gi">+        k, v = kwargs.popitem()</span>
<span class="gi">+        if k == &#39;bytes&#39;:</span>
<span class="gi">+            # Special case for bytes as we want to allow offsets and lengths to work only on creation.</span>
<span class="gi">+            self._setbytes_with_truncation(v, length, offset)</span>
<span class="gi">+            return</span>
<span class="gi">+        if k == &#39;filename&#39;:</span>
<span class="gi">+            self._setfile(v, length, offset)</span>
<span class="gi">+            return</span>
<span class="gi">+        if k == &#39;bitarray&#39;:</span>
<span class="gi">+            self._setbitarray(v, length, offset)</span>
<span class="gi">+            return</span>
<span class="gi">+        if k == &#39;auto&#39;:</span>
<span class="gi">+            raise bitstring.CreationError(</span>
<span class="gi">+                f&quot;The &#39;auto&#39; parameter should not be given explicitly - just use the first positional argument. &quot;</span>
<span class="gi">+                f&quot;Instead of &#39;{self.__class__.__name__}(auto=x)&#39; use &#39;{self.__class__.__name__}(x)&#39;.&quot;)</span>
<span class="gi">+        if offset is not None:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;offset cannot be used when initialising with &#39;{k}&#39;.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            Dtype(k, length).set_fn(self, v)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise bitstring.CreationError(e)</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(self, attribute: str) -&gt; Any:</span>
<span class="gi">+        # Support for arbitrary attributes like u16 or f64.</span>
<span class="w"> </span>        try:
<span class="w"> </span>            d = Dtype(attribute)
<span class="w"> </span>        except ValueError:
<span class="gd">-            raise AttributeError(</span>
<span class="gd">-                f&quot;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{attribute}&#39;.&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise AttributeError(f&quot;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{attribute}&#39;.&quot;)</span>
<span class="w"> </span>        if d.bitlength is not None and len(self) != d.bitlength:
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                f&quot;bitstring length {len(self)} doesn&#39;t match length {d.bitlength} of property &#39;{attribute}&#39;.&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise ValueError(f&quot;bitstring length {len(self)} doesn&#39;t match length {d.bitlength} of property &#39;{attribute}&#39;.&quot;)</span>
<span class="w"> </span>        return d.get_fn(self)

<span class="gd">-    def __iter__(self) -&gt;Iterable[bool]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterable[bool]:</span>
<span class="w"> </span>        return iter(self._bitstore)

<span class="gd">-    def __copy__(self: TBits) -&gt;TBits:</span>
<span class="gi">+    def __copy__(self: TBits) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new copy of the Bits for the copy module.&quot;&quot;&quot;
<span class="gi">+        # Note that if you want a new copy (different ID), use _copy instead.</span>
<span class="gi">+        # The copy can return self as it&#39;s immutable.</span>
<span class="w"> </span>        return self

<span class="gd">-    def __lt__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: Any) -&gt; bool:</span>
<span class="gi">+        # bitstrings can&#39;t really be ordered.</span>
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __gt__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __le__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __ge__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __add__(self: TBits, bs: BitsType) -&gt;TBits:</span>
<span class="gi">+    def __add__(self: TBits, bs: BitsType) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Concatenate bitstrings and return new bitstring.

<span class="w"> </span>        bs -- the bitstring to append.
<span class="gu">@@ -165,7 +211,7 @@ class Bits:</span>
<span class="w"> </span>            s._addleft(self)
<span class="w"> </span>        return s

<span class="gd">-    def __radd__(self: TBits, bs: BitsType) -&gt;TBits:</span>
<span class="gi">+    def __radd__(self: TBits, bs: BitsType) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append current bitstring to bs and return new bitstring.

<span class="w"> </span>        bs -- An object that can be &#39;auto&#39; initialised as a bitstring that will be appended to.
<span class="gu">@@ -175,15 +221,14 @@ class Bits:</span>
<span class="w"> </span>        return bs.__add__(self)

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self: TBits, key: slice, /) -&gt;TBits:</span>
<span class="gi">+    def __getitem__(self: TBits, key: slice, /) -&gt; TBits:</span>
<span class="w"> </span>        ...

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self, key: int, /) -&gt;bool:</span>
<span class="gi">+    def __getitem__(self, key: int, /) -&gt; bool:</span>
<span class="w"> </span>        ...

<span class="gd">-    def __getitem__(self: TBits, key: Union[slice, int], /) -&gt;Union[TBits, bool</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def __getitem__(self: TBits, key: Union[slice, int], /) -&gt; Union[TBits, bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new bitstring representing a slice of the current bitstring.

<span class="w"> </span>        Indices are in units of the step parameter (default 1 bit).
<span class="gu">@@ -201,14 +246,14 @@ class Bits:</span>
<span class="w"> </span>        bs._bitstore = self._bitstore.getslice_withstep(key)
<span class="w"> </span>        return bs

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the length of the bitstring in bits.&quot;&quot;&quot;
<span class="w"> </span>        return self._getlength()

<span class="gd">-    def __bytes__(self) -&gt;bytes:</span>
<span class="gi">+    def __bytes__(self) -&gt; bytes:</span>
<span class="w"> </span>        return self.tobytes()

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return approximate string representation of bitstring for printing.

<span class="w"> </span>        Short strings will be given wholly in hexadecimal or binary. Longer
<span class="gu">@@ -220,16 +265,32 @@ class Bits:</span>
<span class="w"> </span>        if not length:
<span class="w"> </span>            return &#39;&#39;
<span class="w"> </span>        if length &gt; MAX_CHARS * 4:
<span class="gd">-            return &#39;&#39;.join((&#39;0x&#39;, self[0:MAX_CHARS * 4]._gethex(), &#39;...&#39;))</span>
<span class="gi">+            # Too long for hex. Truncate...</span>
<span class="gi">+            return &#39;&#39;.join((&#39;0x&#39;, self[0:MAX_CHARS*4]._gethex(), &#39;...&#39;))</span>
<span class="gi">+        # If it&#39;s quite short and we can&#39;t do hex then use bin</span>
<span class="w"> </span>        if length &lt; 32 and length % 4 != 0:
<span class="w"> </span>            return &#39;0b&#39; + self.bin
<span class="gi">+        # If we can use hex then do so</span>
<span class="w"> </span>        if not length % 4:
<span class="w"> </span>            return &#39;0x&#39; + self.hex
<span class="gi">+        # Otherwise first we do as much as we can in hex</span>
<span class="gi">+        # then add on 1, 2 or 3 bits on at the end</span>
<span class="w"> </span>        bits_at_end = length % 4
<span class="gd">-        return &#39;&#39;.join((&#39;0x&#39;, self[0:length - bits_at_end]._gethex(), &#39;, &#39;,</span>
<span class="gd">-            &#39;0b&#39;, self[length - bits_at_end:]._getbin()))</span>
<span class="gi">+        return &#39;&#39;.join((&#39;0x&#39;, self[0:length - bits_at_end]._gethex(),</span>
<span class="gi">+                        &#39;, &#39;, &#39;0b&#39;, self[length - bits_at_end:]._getbin()))</span>
<span class="gi">+</span>
<span class="gi">+    def _repr(self, classname: str, length: int, pos: int):</span>
<span class="gi">+        pos_string = f&#39;, pos={pos}&#39; if pos else &#39;&#39;</span>
<span class="gi">+        if hasattr(self, &#39;_filename&#39;) and self._filename:</span>
<span class="gi">+            return f&quot;{classname}(filename={self._filename!r}, length={length}{pos_string})&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = self.__str__()</span>
<span class="gi">+            lengthstring = &#39;&#39;</span>
<span class="gi">+            if s.endswith(&#39;...&#39;):</span>
<span class="gi">+                lengthstring = f&#39;  # length={length}&#39;</span>
<span class="gi">+            return f&quot;{classname}(&#39;{s}&#39;{pos_string}){lengthstring}&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return representation that could be used to recreate the bitstring.

<span class="w"> </span>        If the returned string is too long it will be truncated. See __str__().
<span class="gu">@@ -237,7 +298,7 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self._repr(self.__class__.__name__, len(self), 0)

<span class="gd">-    def __eq__(self, bs: Any, /) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, bs: Any, /) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if two bitstrings have the same binary representation.

<span class="w"> </span>        &gt;&gt;&gt; BitArray(&#39;0b1110&#39;) == &#39;0xe&#39;
<span class="gu">@@ -249,7 +310,7 @@ class Bits:</span>
<span class="w"> </span>        except TypeError:
<span class="w"> </span>            return False

<span class="gd">-    def __ne__(self, bs: Any, /) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, bs: Any, /) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return False if two bitstrings have the same binary representation.

<span class="w"> </span>        &gt;&gt;&gt; BitArray(&#39;0b111&#39;) == &#39;0x7&#39;
<span class="gu">@@ -258,43 +319,43 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return not self.__eq__(bs)

<span class="gd">-    def __invert__(self: TBits) -&gt;TBits:</span>
<span class="gi">+    def __invert__(self: TBits) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring with every bit inverted.

<span class="w"> </span>        Raises Error if the bitstring is empty.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if len(self) == 0:
<span class="gd">-            raise bitstring.Error(&#39;Cannot invert empty bitstring.&#39;)</span>
<span class="gi">+            raise bitstring.Error(&quot;Cannot invert empty bitstring.&quot;)</span>
<span class="w"> </span>        s = self._copy()
<span class="w"> </span>        s._invert_all()
<span class="w"> </span>        return s

<span class="gd">-    def __lshift__(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def __lshift__(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring with bits shifted by n to the left.

<span class="w"> </span>        n -- the number of bits to shift. Must be &gt;= 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift by a negative amount.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift by a negative amount.&quot;)</span>
<span class="w"> </span>        if len(self) == 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift an empty bitstring.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift an empty bitstring.&quot;)</span>
<span class="w"> </span>        n = min(n, len(self))
<span class="w"> </span>        s = self._absolute_slice(n, len(self))
<span class="w"> </span>        s._addright(Bits(n))
<span class="w"> </span>        return s

<span class="gd">-    def __rshift__(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def __rshift__(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring with bits shifted by n to the right.

<span class="w"> </span>        n -- the number of bits to shift. Must be &gt;= 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift by a negative amount.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift by a negative amount.&quot;)</span>
<span class="w"> </span>        if len(self) == 0:
<span class="gd">-            raise ValueError(&#39;Cannot shift an empty bitstring.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot shift an empty bitstring.&quot;)</span>
<span class="w"> </span>        if not n:
<span class="w"> </span>            return self._copy()
<span class="w"> </span>        s = self.__class__(length=min(n, len(self)))
<span class="gu">@@ -302,7 +363,7 @@ class Bits:</span>
<span class="w"> </span>        s._addright(self._absolute_slice(0, len(self) - n))
<span class="w"> </span>        return s

<span class="gd">-    def __mul__(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def __mul__(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring consisting of n concatenations of self.

<span class="w"> </span>        Called for expression of the form &#39;a = b*3&#39;.
<span class="gu">@@ -310,14 +371,14 @@ class Bits:</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if n &lt; 0:
<span class="gd">-            raise ValueError(&#39;Cannot multiply by a negative integer.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Cannot multiply by a negative integer.&quot;)</span>
<span class="w"> </span>        if not n:
<span class="w"> </span>            return self.__class__()
<span class="w"> </span>        s = self._copy()
<span class="w"> </span>        s._imul(n)
<span class="w"> </span>        return s

<span class="gd">-    def __rmul__(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def __rmul__(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring consisting of n concatenations of self.

<span class="w"> </span>        Called for expressions of the form &#39;a = 3*b&#39;.
<span class="gu">@@ -326,7 +387,7 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.__mul__(n)

<span class="gd">-    def __and__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __and__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;and&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;&amp;&#39; with.
<span class="gu">@@ -341,7 +402,7 @@ class Bits:</span>
<span class="w"> </span>        s._bitstore = self._bitstore &amp; bs._bitstore
<span class="w"> </span>        return s

<span class="gd">-    def __rand__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __rand__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;and&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- the bitstring to &#39;&amp;&#39; with.
<span class="gu">@@ -351,7 +412,7 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.__and__(bs)

<span class="gd">-    def __or__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __or__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;or&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;|&#39; with.
<span class="gu">@@ -366,7 +427,7 @@ class Bits:</span>
<span class="w"> </span>        s._bitstore = self._bitstore | bs._bitstore
<span class="w"> </span>        return s

<span class="gd">-    def __ror__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __ror__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;or&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;|&#39; with.
<span class="gu">@@ -376,7 +437,7 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.__or__(bs)

<span class="gd">-    def __xor__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __xor__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;xor&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;^&#39; with.
<span class="gu">@@ -389,7 +450,7 @@ class Bits:</span>
<span class="w"> </span>        s._bitstore = self._bitstore ^ bs._bitstore
<span class="w"> </span>        return s

<span class="gd">-    def __rxor__(self: TBits, bs: BitsType, /) -&gt;TBits:</span>
<span class="gi">+    def __rxor__(self: TBits, bs: BitsType, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;xor&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;^&#39; with.
<span class="gu">@@ -399,7 +460,7 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self.__xor__(bs)

<span class="gd">-    def __contains__(self, bs: BitsType, /) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, bs: BitsType, /) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether bs is contained in the current bitstring.

<span class="w"> </span>        bs -- The bitstring to search for.
<span class="gu">@@ -408,125 +469,416 @@ class Bits:</span>
<span class="w"> </span>        found = Bits.find(self, bs, bytealigned=False)
<span class="w"> </span>        return bool(found)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an integer hash of the object.&quot;&quot;&quot;
<span class="gi">+        # Only requirement is that equal bitstring should return the same hash.</span>
<span class="gi">+        # For equal bitstrings the bytes at the start/end will be the same and they will have the same length</span>
<span class="gi">+        # (need to check the length as there could be zero padding when getting the bytes). We do not check any</span>
<span class="gi">+        # bit position inside the bitstring as that does not feature in the __eq__ operation.</span>
<span class="w"> </span>        if len(self) &lt;= 2000:
<span class="gi">+            # Use the whole bitstring.</span>
<span class="w"> </span>            return hash((self.tobytes(), len(self)))
<span class="w"> </span>        else:
<span class="gi">+            # We can&#39;t in general hash the whole bitstring (it could take hours!)</span>
<span class="gi">+            # So instead take some bits from the start and end.</span>
<span class="w"> </span>            return hash(((self[:800] + self[-800:]).tobytes(), len(self)))

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return False if bitstring is empty, otherwise return True.&quot;&quot;&quot;
<span class="w"> </span>        return len(self) != 0

<span class="gd">-    def _clear(self) -&gt;None:</span>
<span class="gi">+    def _clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to an empty state.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = BitStore()</span>

<span class="gd">-    def _setauto_no_length_or_offset(self, s: BitsType, /) -&gt;None:</span>
<span class="gi">+    def _setauto_no_length_or_offset(self, s: BitsType, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set bitstring from a bitstring, file, bool, array, iterable or string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(s, str):</span>
<span class="gi">+            self._bitstore = bitstore_helpers.str_to_bitstore(s)</span>
<span class="gi">+        elif isinstance(s, Bits):</span>
<span class="gi">+            self._bitstore = s._bitstore.copy()</span>
<span class="gi">+        elif isinstance(s, (bytes, bytearray, memoryview)):</span>
<span class="gi">+            self._bitstore = BitStore.frombytes(bytearray(s))</span>
<span class="gi">+        elif isinstance(s, io.BytesIO):</span>
<span class="gi">+            self._bitstore = BitStore.frombytes(s.getvalue())</span>
<span class="gi">+        elif isinstance(s, io.BufferedReader):</span>
<span class="gi">+            self._setfile(s.name)</span>
<span class="gi">+        elif isinstance(s, bitarray.bitarray):</span>
<span class="gi">+            self._bitstore = BitStore(s)</span>
<span class="gi">+        elif isinstance(s, array.array):</span>
<span class="gi">+            self._bitstore = BitStore.frombytes(s.tobytes())</span>
<span class="gi">+        elif isinstance(s, abc.Iterable):</span>
<span class="gi">+            # Evaluate each item as True or False and set bits to 1 or 0.</span>
<span class="gi">+            self._setbin_unsafe(&#39;&#39;.join(str(int(bool(x))) for x in s))</span>
<span class="gi">+        elif isinstance(s, numbers.Integral):</span>
<span class="gi">+            raise TypeError(f&quot;It&#39;s no longer possible to auto initialise a bitstring from an integer.&quot;</span>
<span class="gi">+                            f&quot; Use &#39;{self.__class__.__name__}({s})&#39; instead of just &#39;{s}&#39; as this makes it &quot;</span>
<span class="gi">+                            f&quot;clearer that a bitstring of {int(s)} zero bits will be created.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&quot;Cannot initialise bitstring from type &#39;{type(s)}&#39;.&quot;)</span>

<span class="gd">-    def _setauto(self, s: BitsType, length: Optional[int], offset: Optional</span>
<span class="gd">-        [int], /) -&gt;None:</span>
<span class="gi">+    def _setauto(self, s: BitsType, length: Optional[int], offset: Optional[int], /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set bitstring from a bitstring, file, bool, array, iterable or string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _setfile(self, filename: str, length: Optional[int]=None, offset:</span>
<span class="gd">-        Optional[int]=None) -&gt;None:</span>
<span class="gi">+        # As s can be so many different things it&#39;s important to do the checks</span>
<span class="gi">+        # in the correct order, as some types are also other allowed types.</span>
<span class="gi">+        if offset is None and length is None:</span>
<span class="gi">+            return self._setauto_no_length_or_offset(s)</span>
<span class="gi">+        if offset is None:</span>
<span class="gi">+            offset = 0</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(s, io.BytesIO):</span>
<span class="gi">+            if length is None:</span>
<span class="gi">+                length = s.seek(0, 2) * 8 - offset</span>
<span class="gi">+            byteoffset, offset = divmod(offset, 8)</span>
<span class="gi">+            bytelength = (length + byteoffset * 8 + offset + 7) // 8 - byteoffset</span>
<span class="gi">+            if length + byteoffset * 8 + offset &gt; s.seek(0, 2) * 8:</span>
<span class="gi">+                raise bitstring.CreationError(&quot;BytesIO object is not long enough for specified length and offset.&quot;)</span>
<span class="gi">+            self._bitstore = BitStore.frombytes(s.getvalue()[byteoffset: byteoffset + bytelength]).getslice(</span>
<span class="gi">+                offset, offset + length)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(s, io.BufferedReader):</span>
<span class="gi">+            self._setfile(s.name, length, offset)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(s, (str, Bits, bytes, bytearray, memoryview, io.BytesIO, io.BufferedReader,</span>
<span class="gi">+                          bitarray.bitarray, array.array, abc.Iterable)):</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;Cannot initialise bitstring from type &#39;{type(s)}&#39; when using explicit lengths or offsets.&quot;)</span>
<span class="gi">+        raise TypeError(f&quot;Cannot initialise bitstring from type &#39;{type(s)}&#39;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setfile(self, filename: str, length: Optional[int] = None, offset: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use file as source of bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(pathlib.Path(filename), &#39;rb&#39;) as source:</span>
<span class="gi">+            if offset is None:</span>
<span class="gi">+                offset = 0</span>
<span class="gi">+            m = mmap.mmap(source.fileno(), 0, access=mmap.ACCESS_READ)</span>
<span class="gi">+            if offset == 0:</span>
<span class="gi">+                self._filename = source.name</span>
<span class="gi">+                self._bitstore = BitStore.frombuffer(m, length=length)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If offset is given then always read into memory.</span>
<span class="gi">+                temp = BitStore.frombuffer(m)</span>
<span class="gi">+                if length is None:</span>
<span class="gi">+                    if offset &gt; len(temp):</span>
<span class="gi">+                        raise bitstring.CreationError(f&quot;The offset of {offset} bits is greater than the file length ({len(temp)} bits).&quot;)</span>
<span class="gi">+                    self._bitstore = temp.getslice(offset, None)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._bitstore = temp.getslice(offset, offset + length)</span>
<span class="gi">+                    if len(self) != length:</span>
<span class="gi">+                        raise bitstring.CreationError(f&quot;Can&#39;t use a length of {length} bits and an offset of {offset} bits as file length is only {len(temp)} bits.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbitarray(self, ba: bitarray.bitarray, length: Optional[int], offset: Optional[int]) -&gt; None:</span>
<span class="gi">+        if offset is None:</span>
<span class="gi">+            offset = 0</span>
<span class="gi">+        if offset &gt; len(ba):</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;Offset of {offset} too large for bitarray of length {len(ba)}.&quot;)</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            self._bitstore = BitStore(ba[offset:])</span>
<span class="gi">+        else:</span>
<span class="gi">+            if offset + length &gt; len(ba):</span>
<span class="gi">+                raise bitstring.CreationError(</span>
<span class="gi">+                    f&quot;Offset of {offset} and length of {length} too large for bitarray of length {len(ba)}.&quot;)</span>
<span class="gi">+            self._bitstore = BitStore(ba[offset: offset + length])</span>

<span class="gd">-    def _setbytes(self, data: Union[bytearray, bytes, List], length: None=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _setbits(self, bs: BitsType, length: None = None) -&gt; None:</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        self._bitstore = bs._bitstore</span>
<span class="gi">+</span>
<span class="gi">+    def _setp3binary(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.p3binary2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _setp4binary(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.p4binary2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete4m3mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e4m3mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete5m2mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e5m2mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete3m2mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e3m2mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete2m3mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e2m3mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete2m1mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e2m1mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _sete8m0mxfp(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.e8m0mxfp2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _setmxint(self, f: float) -&gt; None:</span>
<span class="gi">+        self._bitstore = bitstore_helpers.mxint2bitstore(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbytes(self, data: Union[bytearray, bytes, List], length:None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the data from a bytes or bytearray object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = BitStore.frombytes(bytes(data))</span>

<span class="gd">-    def _setbytes_with_truncation(self, data: Union[bytearray, bytes],</span>
<span class="gd">-        length: Optional[int]=None, offset: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def _setbytes_with_truncation(self, data: Union[bytearray, bytes], length: Optional[int] = None, offset: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the data from a bytes or bytearray object, with optional offset and length truncations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if offset is None and length is None:</span>
<span class="gi">+            return self._setbytes(data)</span>
<span class="gi">+        data = bytearray(data)</span>
<span class="gi">+        if offset is None:</span>
<span class="gi">+            offset = 0</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            # Use to the end of the data</span>
<span class="gi">+            length = len(data) * 8 - offset</span>
<span class="gi">+        else:</span>
<span class="gi">+            if length + offset &gt; len(data) * 8:</span>
<span class="gi">+                raise bitstring.CreationError(f&quot;Not enough data present. Need {length + offset} bits, have {len(data) * 8}.&quot;)</span>
<span class="gi">+        self._bitstore = BitStore.frombytes(data).getslice_msb0(offset, offset + length)</span>

<span class="gd">-    def _getbytes(self) -&gt;bytes:</span>
<span class="gi">+    def _getbytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the data as an ordinary bytes object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _unprintable = list(range(0, 32))</span>
<span class="gd">-    _unprintable.extend(range(127, 255))</span>
<span class="gi">+        if len(self) % 8:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret as bytes unambiguously - not multiple of 8 bits.&quot;)</span>
<span class="gi">+        return self._bitstore.tobytes()</span>
<span class="gi">+</span>
<span class="gi">+    _unprintable = list(range(0x00, 0x20))  # ASCII control characters</span>
<span class="gi">+    _unprintable.extend(range(0x7f, 0xff))  # DEL char + non-ASCII</span>

<span class="gd">-    def _getbytes_printable(self) -&gt;str:</span>
<span class="gi">+    def _getbytes_printable(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an approximation of the data as a string of printable characters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bytes_ = self._getbytes()</span>
<span class="gi">+        # For everything that isn&#39;t printable ASCII, use value from &#39;Latin Extended-A&#39; unicode block.</span>
<span class="gi">+        string = &#39;&#39;.join(chr(0x100 + x) if x in Bits._unprintable else chr(x) for x in bytes_)</span>
<span class="gi">+        return string</span>

<span class="gd">-    def _setuint(self, uint: int, length: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def _setuint(self, uint: int, length: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to have given unsigned int interpretation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _getuint(self) -&gt;int:</span>
<span class="gi">+        # If no length given, and we&#39;ve previously been given a length, use it.</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with a uint initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.int2bitstore(uint, length, False)</span>
<span class="gi">+</span>
<span class="gi">+    def _getuint(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return data as an unsigned int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret a zero length bitstring as an integer.&quot;)</span>
<span class="gi">+        return self._bitstore.slice_to_uint()</span>

<span class="gd">-    def _setint(self, int_: int, length: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def _setint(self, int_: int, length: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to have given signed int interpretation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _getint(self) -&gt;int:</span>
<span class="gi">+        # If no length given, and we&#39;ve previously been given a length, use it.</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with an int initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.int2bitstore(int_, length, True)</span>
<span class="gi">+</span>
<span class="gi">+    def _getint(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return data as a two&#39;s complement signed int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret bitstring without a length as an integer.&quot;)</span>
<span class="gi">+        return self._bitstore.slice_to_int()</span>

<span class="gd">-    def _setuintbe(self, uintbe: int, length: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def _setuintbe(self, uintbe: int, length: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the bitstring to a big-endian unsigned int interpretation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with a uintbe initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.int2bitstore(uintbe, length, False)</span>

<span class="gd">-    def _getuintbe(self) -&gt;int:</span>
<span class="gi">+    def _getuintbe(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return data as a big-endian two&#39;s complement unsigned int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self) % 8:</span>
<span class="gi">+            raise bitstring.InterpretError(f&quot;Big-endian integers must be whole-byte. Length = {len(self)} bits.&quot;)</span>
<span class="gi">+        return self._getuint()</span>

<span class="gd">-    def _setintbe(self, intbe: int, length: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def _setintbe(self, intbe: int, length: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set bitstring to a big-endian signed int interpretation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with a intbe initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.int2bitstore(intbe, length, True)</span>

<span class="gd">-    def _getintbe(self) -&gt;int:</span>
<span class="gi">+    def _getintbe(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return data as a big-endian two&#39;s complement signed int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _getuintle(self) -&gt;int:</span>
<span class="gi">+        if len(self) % 8:</span>
<span class="gi">+            raise bitstring.InterpretError(f&quot;Big-endian integers must be whole-byte. Length = {len(self)} bits.&quot;)</span>
<span class="gi">+        return self._getint()</span>
<span class="gi">+</span>
<span class="gi">+    def _setuintle(self, uintle: int, length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with a uintle initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.intle2bitstore(uintle, length, False)</span>
<span class="gi">+</span>
<span class="gi">+    def _getuintle(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret as a little-endian unsigned int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _getintle(self) -&gt;int:</span>
<span class="gi">+        if len(self) % 8:</span>
<span class="gi">+            raise bitstring.InterpretError(f&quot;Little-endian integers must be whole-byte. Length = {len(self)} bits.&quot;)</span>
<span class="gi">+        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])</span>
<span class="gi">+        return bs.slice_to_uint()</span>
<span class="gi">+</span>
<span class="gi">+    def _setintle(self, intle: int, length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length == 0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A non-zero length must be specified with an intle initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.intle2bitstore(intle, length, True)</span>
<span class="gi">+</span>
<span class="gi">+    def _getintle(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret as a little-endian signed int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _getfloatbe(self) -&gt;float:</span>
<span class="gi">+        if len(self) % 8:</span>
<span class="gi">+            raise bitstring.InterpretError(f&quot;Little-endian integers must be whole-byte. Length = {len(self)} bits.&quot;)</span>
<span class="gi">+        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])</span>
<span class="gi">+        return bs.slice_to_int()</span>
<span class="gi">+</span>
<span class="gi">+    def _getp4binary(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return p4binary_fmt.lut_binary8_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _getp3binary(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return p3binary_fmt.lut_binary8_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete4m3mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return e4m3mxfp_saturate_fmt.lut_int_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete5m2mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return e5m2mxfp_saturate_fmt.lut_int_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete3m2mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return e3m2mxfp_fmt.lut_int_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete2m3mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return e2m3mxfp_fmt.lut_int_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete2m1mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint()</span>
<span class="gi">+        return e2m1mxfp_fmt.lut_int_to_float[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _gete8m0mxfp(self) -&gt; float:</span>
<span class="gi">+        u = self._getuint() - 127</span>
<span class="gi">+        if u == 128:</span>
<span class="gi">+            return float(&#39;nan&#39;)</span>
<span class="gi">+        return 2.0 ** u</span>
<span class="gi">+</span>
<span class="gi">+    def _getmxint(self) -&gt; float:</span>
<span class="gi">+        u = self._getint()</span>
<span class="gi">+        return float(u) * 2 ** -6</span>
<span class="gi">+</span>
<span class="gi">+    def _setfloat(self, f: float, length: Optional[int], big_endian: bool) -&gt; None:</span>
<span class="gi">+        if length is None and hasattr(self, &#39;len&#39;) and len(self) != 0:</span>
<span class="gi">+            length = len(self)</span>
<span class="gi">+        if length is None or length not in [16, 32, 64]:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;A length of 16, 32, or 64 must be specified with a float initialiser.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.float2bitstore(f, length, big_endian)</span>
<span class="gi">+</span>
<span class="gi">+    def _setfloatbe(self, f: float, length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        self._setfloat(f, length, True)</span>
<span class="gi">+</span>
<span class="gi">+    def _getfloatbe(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret the whole bitstring as a big-endian float.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fmt = {16: &#39;&gt;e&#39;, 32: &#39;&gt;f&#39;, 64: &#39;&gt;d&#39;}[len(self)]</span>
<span class="gi">+        return struct.unpack(fmt, self._bitstore.tobytes())[0]</span>

<span class="gd">-    def _getfloatle(self) -&gt;float:</span>
<span class="gi">+    def _setfloatle(self, f: float, length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        self._setfloat(f, length, False)</span>
<span class="gi">+</span>
<span class="gi">+    def _getfloatle(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret the whole bitstring as a little-endian float.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fmt = {16: &#39;&lt;e&#39;, 32: &#39;&lt;f&#39;, 64: &#39;&lt;d&#39;}[len(self)]</span>
<span class="gi">+        return struct.unpack(fmt, self._bitstore.tobytes())[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _getbfloatbe(self) -&gt; float:</span>
<span class="gi">+        zero_padded = self + Bits(16)</span>
<span class="gi">+        return zero_padded._getfloatbe()</span>
<span class="gi">+</span>
<span class="gi">+    def _setbfloatbe(self, f: Union[float, str], length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        if length is not None and length != 16:</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;bfloats must be length 16, received a length of {length} bits.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.bfloat2bitstore(f, True)</span>

<span class="gd">-    def _setue(self, i: int) -&gt;None:</span>
<span class="gi">+    def _getbfloatle(self) -&gt; float:</span>
<span class="gi">+        zero_padded = Bits(16) + self</span>
<span class="gi">+        return zero_padded._getfloatle()</span>
<span class="gi">+</span>
<span class="gi">+    def _setbfloatle(self, f: Union[float, str], length: Optional[int] = None) -&gt; None:</span>
<span class="gi">+        if length is not None and length != 16:</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;bfloats must be length 16, received a length of {length} bits.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.bfloat2bitstore(f, False)</span>
<span class="gi">+</span>
<span class="gi">+    def _setue(self, i: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise bitstring with unsigned exponential-Golomb code for integer i.

<span class="w"> </span>        Raises CreationError if i &lt; 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;Exp-Golomb codes cannot be used in lsb0 mode.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.ue2bitstore(i)</span>

<span class="gd">-    def _readue(self, pos: int) -&gt;Tuple[int, int]:</span>
<span class="gi">+    def _readue(self, pos: int) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation of next bits as unsigned exponential-Golomb code.

<span class="w"> </span>        Raises ReadError if the end of the bitstring is encountered while
<span class="w"> </span>        reading the code.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Exp-Golomb codes cannot be read in lsb0 mode.&quot;)</span>
<span class="gi">+        oldpos = pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            while not self[pos]:</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Read off end of bitstring trying to read code.&quot;)</span>
<span class="gi">+        leadingzeros = pos - oldpos</span>
<span class="gi">+        codenum = (1 &lt;&lt; leadingzeros) - 1</span>
<span class="gi">+        if leadingzeros &gt; 0:</span>
<span class="gi">+            if pos + leadingzeros + 1 &gt; len(self):</span>
<span class="gi">+                raise bitstring.ReadError(&quot;Read off end of bitstring trying to read code.&quot;)</span>
<span class="gi">+            codenum += self[pos + 1:pos + 1 + leadingzeros]._getuint()</span>
<span class="gi">+            pos += leadingzeros + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert codenum == 0</span>
<span class="gi">+            pos += 1</span>
<span class="gi">+        return codenum, pos</span>
<span class="gi">+</span>
<span class="gi">+    def _getue(self) -&gt; Tuple[int, int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._readue(0)</span>
<span class="gi">+        except bitstring.ReadError:</span>
<span class="gi">+            raise bitstring.InterpretError</span>
<span class="gi">+</span>
<span class="gi">+    def _getse(self) -&gt; Tuple[int, int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._readse(0)</span>
<span class="gi">+        except bitstring.ReadError:</span>
<span class="gi">+            raise bitstring.InterpretError</span>
<span class="gi">+</span>
<span class="gi">+    def _getuie(self) -&gt; Tuple[int, int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._readuie(0)</span>
<span class="gi">+        except bitstring.ReadError:</span>
<span class="gi">+            raise bitstring.InterpretError</span>

<span class="gd">-    def _setse(self, i: int) -&gt;None:</span>
<span class="gi">+    def _getsie(self) -&gt; Tuple[int, int]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._readsie(0)</span>
<span class="gi">+        except bitstring.ReadError:</span>
<span class="gi">+            raise bitstring.InterpretError</span>
<span class="gi">+</span>
<span class="gi">+    def _setse(self, i: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise bitstring with signed exponential-Golomb code for integer i.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;Exp-Golomb codes cannot be used in lsb0 mode.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.se2bitstore(i)</span>

<span class="gd">-    def _readse(self, pos: int) -&gt;Tuple[int, int]:</span>
<span class="gi">+    def _readse(self, pos: int) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation of next bits as a signed exponential-Golomb code.

<span class="w"> </span>        Advances position to after the read code.
<span class="gu">@@ -535,30 +887,48 @@ class Bits:</span>
<span class="w"> </span>        reading the code.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        codenum, pos = self._readue(pos)</span>
<span class="gi">+        m = (codenum + 1) // 2</span>
<span class="gi">+        return (m, pos) if codenum % 2 else (-m, pos)</span>

<span class="gd">-    def _setuie(self, i: int) -&gt;None:</span>
<span class="gi">+    def _setuie(self, i: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise bitstring with unsigned interleaved exponential-Golomb code for integer i.

<span class="w"> </span>        Raises CreationError if i &lt; 0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;Exp-Golomb codes cannot be used in lsb0 mode.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.uie2bitstore(i)</span>

<span class="gd">-    def _readuie(self, pos: int) -&gt;Tuple[int, int]:</span>
<span class="gi">+    def _readuie(self, pos: int) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation of next bits as unsigned interleaved exponential-Golomb code.

<span class="w"> </span>        Raises ReadError if the end of the bitstring is encountered while
<span class="w"> </span>        reading the code.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _setsie(self, i: int) -&gt;None:</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Exp-Golomb codes cannot be read in lsb0 mode.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            codenum: int = 1</span>
<span class="gi">+            while not self[pos]:</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+                codenum &lt;&lt;= 1</span>
<span class="gi">+                codenum += self[pos]</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+            pos += 1</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Read off end of bitstring trying to read code.&quot;)</span>
<span class="gi">+        return codenum - 1, pos</span>
<span class="gi">+</span>
<span class="gi">+    def _setsie(self, i: int, ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise bitstring with signed interleaved exponential-Golomb code for integer i.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            raise bitstring.CreationError(&quot;Exp-Golomb codes cannot be used in lsb0 mode.&quot;)</span>
<span class="gi">+        self._bitstore = bitstore_helpers.sie2bitstore(i)</span>

<span class="gd">-    def _readsie(self, pos: int) -&gt;Tuple[int, int]:</span>
<span class="gi">+    def _readsie(self, pos: int) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation of next bits as a signed interleaved exponential-Golomb code.

<span class="w"> </span>        Advances position to after the read code.
<span class="gu">@@ -567,121 +937,219 @@ class Bits:</span>
<span class="w"> </span>        reading the code.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        codenum, pos = self._readuie(pos)</span>
<span class="gi">+        if not codenum:</span>
<span class="gi">+            return 0, pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            return (-codenum, pos + 1) if self[pos] else (codenum, pos + 1)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Read off end of bitstring trying to read code.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbool(self, value: Union[bool, str]) -&gt; None:</span>
<span class="gi">+        # We deliberately don&#39;t want to have implicit conversions to bool here.</span>
<span class="gi">+        # If we did then it would be difficult to deal with the &#39;False&#39; string.</span>
<span class="gi">+        if value in (1, &#39;True&#39;, &#39;1&#39;):</span>
<span class="gi">+            self._bitstore = BitStore(&#39;1&#39;)</span>
<span class="gi">+        elif value in (0, &#39;False&#39;, &#39;0&#39;):</span>
<span class="gi">+            self._bitstore = BitStore(&#39;0&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;Cannot initialise boolean with {value}.&quot;)</span>

<span class="gd">-    def _setbin_safe(self, binstring: str, length: None=None) -&gt;None:</span>
<span class="gi">+    def _getbool(self) -&gt; bool:</span>
<span class="gi">+        return self[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _getpad(self) -&gt; None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _setpad(self, value: None, length: int) -&gt; None:</span>
<span class="gi">+        self._bitstore = BitStore(length)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbin_safe(self, binstring: str, length: None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to the value given in binstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = bitstore_helpers.bin2bitstore(binstring)</span>

<span class="gd">-    def _setbin_unsafe(self, binstring: str, length: None=None) -&gt;None:</span>
<span class="gi">+    def _setbin_unsafe(self, binstring: str, length: None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Same as _setbin_safe, but input isn&#39;t sanity checked. binstring mustn&#39;t start with &#39;0b&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = bitstore_helpers.bin2bitstore_unsafe(binstring)</span>

<span class="gd">-    def _getbin(self) -&gt;str:</span>
<span class="gi">+    def _getbin(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation as a binary string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitstore.slice_to_bin()</span>

<span class="gd">-    def _setoct(self, octstring: str, length: None=None) -&gt;None:</span>
<span class="gi">+    def _setoct(self, octstring: str, length: None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to have the value given in octstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = bitstore_helpers.oct2bitstore(octstring)</span>

<span class="gd">-    def _getoct(self) -&gt;str:</span>
<span class="gi">+    def _getoct(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return interpretation as an octal string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitstore.slice_to_oct()</span>

<span class="gd">-    def _sethex(self, hexstring: str, length: None=None) -&gt;None:</span>
<span class="gi">+    def _sethex(self, hexstring: str, length: None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to have the value given in hexstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore = bitstore_helpers.hex2bitstore(hexstring)</span>

<span class="gd">-    def _gethex(self) -&gt;str:</span>
<span class="gi">+    def _gethex(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the hexadecimal representation as a string.

<span class="w"> </span>        Raises an InterpretError if the bitstring&#39;s length is not a multiple of 4.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitstore.slice_to_hex()</span>

<span class="gd">-    def _getlength(self) -&gt;int:</span>
<span class="gi">+    def _getlength(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the length of the bitstring in bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._bitstore)</span>

<span class="gd">-    def _copy(self: TBits) -&gt;TBits:</span>
<span class="gi">+    def _copy(self: TBits) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create and return a new copy of the Bits (always in memory).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note that __copy__ may choose to return self if it&#39;s immutable. This method always makes a copy.</span>
<span class="gi">+        s_copy = self.__class__()</span>
<span class="gi">+        s_copy._bitstore = self._bitstore._copy()</span>
<span class="gi">+        return s_copy</span>

<span class="gd">-    def _slice(self: TBits, start: int, end: int) -&gt;TBits:</span>
<span class="gi">+    def _slice(self: TBits, start: int, end: int) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used internally to get a slice, without error checking.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bs = self.__class__()</span>
<span class="gi">+        bs._bitstore = self._bitstore.getslice(start, end)</span>
<span class="gi">+        return bs</span>

<span class="gd">-    def _absolute_slice(self: TBits, start: int, end: int) -&gt;TBits:</span>
<span class="gi">+    def _absolute_slice(self: TBits, start: int, end: int) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used internally to get a slice, without error checking.
<span class="w"> </span>        Uses MSB0 bit numbering even if LSB0 is set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if end == start:</span>
<span class="gi">+            return self.__class__()</span>
<span class="gi">+        assert start &lt; end, f&quot;start={start}, end={end}&quot;</span>
<span class="gi">+        bs = self.__class__()</span>
<span class="gi">+        bs._bitstore = self._bitstore.getslice_msb0(start, end)</span>
<span class="gi">+        return bs</span>

<span class="gd">-    def _readtoken(self, name: str, pos: int, length: Optional[int]) -&gt;Tuple[</span>
<span class="gd">-        Union[float, int, str, None, Bits], int]:</span>
<span class="gi">+    def _readtoken(self, name: str, pos: int, length: Optional[int]) -&gt; Tuple[Union[float, int, str, None, Bits], int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reads a token from the bitstring and returns the result.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dtype = dtype_register.get_dtype(name, length)</span>
<span class="gi">+        if dtype.bitlength is not None and dtype.bitlength &gt; len(self) - pos:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Reading off the end of the data. &quot;</span>
<span class="gi">+                            f&quot;Tried to read {dtype.bitlength} bits when only {len(self) - pos} available.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            val = dtype.read_fn(self, pos)</span>
<span class="gi">+            if isinstance(val, tuple):</span>
<span class="gi">+                return val</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert length is not None</span>
<span class="gi">+                return val, pos + dtype.bitlength</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise ValueError(f&quot;Can&#39;t parse token {name}:{length}&quot;)</span>

<span class="gd">-    def _addright(self, bs: Bits, /) -&gt;None:</span>
<span class="gi">+    def _addright(self, bs: Bits, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a bitstring to the RHS of the current bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore += bs._bitstore</span>

<span class="gd">-    def _addleft(self, bs: Bits, /) -&gt;None:</span>
<span class="gi">+    def _addleft(self, bs: Bits, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepend a bitstring to the current bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bs._bitstore.immutable:</span>
<span class="gi">+            self._bitstore = bs._bitstore._copy() + self._bitstore</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitstore = bs._bitstore + self._bitstore</span>

<span class="gd">-    def _truncateleft(self: TBits, bits: int, /) -&gt;TBits:</span>
<span class="gi">+    def _truncateleft(self: TBits, bits: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Truncate bits from the start of the bitstring. Return the truncated bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _truncateright(self: TBits, bits: int, /) -&gt;TBits:</span>
<span class="gi">+        assert 0 &lt;= bits &lt;= len(self)</span>
<span class="gi">+        if bits == 0:</span>
<span class="gi">+            return self.__class__()</span>
<span class="gi">+        truncated_bits = self._absolute_slice(0, bits)</span>
<span class="gi">+        if bits == len(self):</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            return truncated_bits</span>
<span class="gi">+        self._bitstore = self._bitstore.getslice_msb0(bits, None)</span>
<span class="gi">+        return truncated_bits</span>
<span class="gi">+</span>
<span class="gi">+    def _truncateright(self: TBits, bits: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Truncate bits from the end of the bitstring. Return the truncated bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _insert(self, bs: Bits, pos: int, /) -&gt;None:</span>
<span class="gi">+        assert 0 &lt;= bits &lt;= len(self)</span>
<span class="gi">+        if bits == 0:</span>
<span class="gi">+            return self.__class__()</span>
<span class="gi">+        truncated_bits = self._absolute_slice(len(self) - bits, len(self))</span>
<span class="gi">+        if bits == len(self):</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            return truncated_bits</span>
<span class="gi">+        self._bitstore = self._bitstore.getslice_msb0(None, -bits)</span>
<span class="gi">+        return truncated_bits</span>
<span class="gi">+</span>
<span class="gi">+    def _insert(self, bs: Bits, pos: int, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Insert bs at pos.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt;= pos &lt;= len(self)</span>
<span class="gi">+        self._bitstore[pos: pos] = bs._bitstore</span>
<span class="gi">+        return</span>

<span class="gd">-    def _overwrite(self, bs: Bits, pos: int, /) -&gt;None:</span>
<span class="gi">+    def _overwrite(self, bs: Bits, pos: int, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Overwrite with bs at pos.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt;= pos &lt;= len(self)</span>
<span class="gi">+        if bs is self:</span>
<span class="gi">+            # Just overwriting with self, so do nothing.</span>
<span class="gi">+            assert pos == 0</span>
<span class="gi">+            return</span>
<span class="gi">+        self._bitstore[pos: pos + len(bs)] = bs._bitstore</span>

<span class="gd">-    def _delete(self, bits: int, pos: int, /) -&gt;None:</span>
<span class="gi">+    def _delete(self, bits: int, pos: int, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete bits at pos.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt;= pos &lt;= len(self)</span>
<span class="gi">+        assert pos + bits &lt;= len(self), f&quot;pos={pos}, bits={bits}, len={len(self)}&quot;</span>
<span class="gi">+        del self._bitstore[pos: pos + bits]</span>
<span class="gi">+        return</span>

<span class="gd">-    def _reversebytes(self, start: int, end: int) -&gt;None:</span>
<span class="gi">+    def _reversebytes(self, start: int, end: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reverse bytes in-place.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert (end - start) % 8 == 0</span>
<span class="gi">+        self._bitstore[start:end] = BitStore.frombytes(self._bitstore.getslice(start, end).tobytes()[::-1])</span>

<span class="gd">-    def _invert(self, pos: int, /) -&gt;None:</span>
<span class="gi">+    def _invert(self, pos: int, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Flip bit at pos 1&lt;-&gt;0.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt;= pos &lt; len(self)</span>
<span class="gi">+        self._bitstore.invert(pos)</span>

<span class="gd">-    def _invert_all(self) -&gt;None:</span>
<span class="gi">+    def _invert_all(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invert every bit.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bitstore.invert()</span>

<span class="gd">-    def _ilshift(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def _ilshift(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shift bits by n to the left in place. Return self.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt; n &lt;= len(self)</span>
<span class="gi">+        self._addright(Bits(n))</span>
<span class="gi">+        self._truncateleft(n)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def _irshift(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def _irshift(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shift bits by n to the right in place. Return self.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert 0 &lt; n &lt;= len(self)</span>
<span class="gi">+        self._addleft(Bits(n))</span>
<span class="gi">+        self._truncateright(n)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def _imul(self: TBits, n: int, /) -&gt;TBits:</span>
<span class="gi">+    def _imul(self: TBits, n: int, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Concatenate n copies of self in place. Return self.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert n &gt;= 0</span>
<span class="gi">+        if n == 0:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+        else:</span>
<span class="gi">+            m = 1</span>
<span class="gi">+            old_len = len(self)</span>
<span class="gi">+            while m * 2 &lt; n:</span>
<span class="gi">+                self._addright(self)</span>
<span class="gi">+                m *= 2</span>
<span class="gi">+            self._addright(self[0:(n - m) * old_len])</span>
<span class="gi">+        return self</span>

<span class="gd">-    def _validate_slice(self, start: Optional[int], end: Optional[int]</span>
<span class="gd">-        ) -&gt;Tuple[int, int]:</span>
<span class="gi">+    def _getbits(self: TBits):</span>
<span class="gi">+        return self._copy()</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_slice(self, start: Optional[int], end: Optional[int]) -&gt; Tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate start and end and return them as positive bit positions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = 0 if start is None else (start + len(self) if start &lt; 0 else start)</span>
<span class="gi">+        end = len(self) if end is None else (end + len(self) if end &lt; 0 else end)</span>
<span class="gi">+        if not 0 &lt;= start &lt;= end &lt;= len(self):</span>
<span class="gi">+            raise ValueError(f&quot;Invalid slice positions for bitstring length {len(self)}: start={start}, end={end}.&quot;)</span>
<span class="gi">+        return start, end</span>

<span class="gd">-    def unpack(self, fmt: Union[str, List[Union[str, int]]], **kwargs) -&gt;List[</span>
<span class="gd">-        Union[int, float, str, Bits, bool, bytes, None]]:</span>
<span class="gi">+    def unpack(self, fmt: Union[str, List[Union[str, int]]], **kwargs) -&gt; List[Union[int, float, str, Bits, bool, bytes, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret the whole bitstring using fmt and return list.

<span class="w"> </span>        fmt -- A single string or a list of strings with comma separated tokens
<span class="gu">@@ -696,11 +1164,69 @@ class Bits:</span>
<span class="w"> </span>        See the docstring for &#39;read&#39; for token examples.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._readlist(fmt, 0, **kwargs)[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _readlist(self, fmt: Union[str, List[Union[str, int, Dtype]]], pos: int, **kwargs) \</span>
<span class="gi">+            -&gt; Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:</span>
<span class="gi">+        if isinstance(fmt, str):</span>
<span class="gi">+            fmt = [fmt]</span>
<span class="gi">+        # Convert to a flat list of Dtypes</span>
<span class="gi">+        dtype_list = []</span>
<span class="gi">+        for f_item in fmt:</span>
<span class="gi">+            if isinstance(f_item, numbers.Integral):</span>
<span class="gi">+                dtype_list.append(Dtype(&#39;bits&#39;, f_item))</span>
<span class="gi">+            elif isinstance(f_item, Dtype):</span>
<span class="gi">+                dtype_list.append(f_item)</span>
<span class="gi">+            else:</span>
<span class="gi">+                token_list = utils.preprocess_tokens(f_item)</span>
<span class="gi">+                for t in token_list:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        name, length = utils.parse_name_length_token(t, **kwargs)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        dtype_list.append(Dtype(&#39;bits&#39;, int(t)))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        dtype_list.append(Dtype(name, length))</span>
<span class="gi">+        return self._read_dtype_list(dtype_list, pos)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_dtype_list(self, dtypes: List[Dtype], pos: int) -&gt; Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:</span>
<span class="gi">+        has_stretchy_token = False</span>
<span class="gi">+        bits_after_stretchy_token = 0</span>
<span class="gi">+        for dtype in dtypes:</span>
<span class="gi">+            stretchy = dtype.bitlength is None and not dtype.variable_length</span>
<span class="gi">+            if stretchy:</span>
<span class="gi">+                if has_stretchy_token:</span>
<span class="gi">+                    raise bitstring.Error(&quot;It&#39;s not possible to have more than one &#39;filler&#39; token.&quot;)</span>
<span class="gi">+                has_stretchy_token = True</span>
<span class="gi">+            elif has_stretchy_token:</span>
<span class="gi">+                if dtype.variable_length:</span>
<span class="gi">+                    raise bitstring.Error(f&quot;It&#39;s not possible to parse a variable length token &#39;{dtype}&#39; after a &#39;filler&#39; token.&quot;)</span>
<span class="gi">+                bits_after_stretchy_token += dtype.bitlength</span>
<span class="gi">+</span>
<span class="gi">+        # We should have precisely zero or one stretchy token</span>
<span class="gi">+        vals = []</span>
<span class="gi">+        for dtype in dtypes:</span>
<span class="gi">+            stretchy = dtype.bitlength is None and not dtype.variable_length</span>
<span class="gi">+            if stretchy:</span>
<span class="gi">+                bits_remaining = len(self) - pos</span>
<span class="gi">+                # Set length to the remaining bits</span>
<span class="gi">+                bitlength = max(bits_remaining - bits_after_stretchy_token, 0)</span>
<span class="gi">+                items, remainder = divmod(bitlength, dtype.bits_per_item)</span>
<span class="gi">+                if remainder != 0:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        f&quot;The &#39;{dtype.name}&#39; type must have a bit length that is a multiple of {dtype.bits_per_item}&quot;</span>
<span class="gi">+                        f&quot; so cannot be created from the {bitlength} bits that are available for this stretchy token.&quot;)</span>
<span class="gi">+                dtype = Dtype(dtype.name, items)</span>
<span class="gi">+            if dtype.bitlength is not None:</span>
<span class="gi">+                val = dtype.read_fn(self, pos)</span>
<span class="gi">+                pos += dtype.bitlength</span>
<span class="gi">+            else:</span>
<span class="gi">+                val, pos = dtype.read_fn(self, pos)</span>
<span class="gi">+            if val is not None:  # Don&#39;t append pad tokens</span>
<span class="gi">+                vals.append(val)</span>
<span class="gi">+        return vals, pos</span>

<span class="gd">-    def find(self, bs: BitsType, /, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, bytealigned: Optional[bool]=None) -&gt;Union[Tuple</span>
<span class="gd">-        [int], Tuple[()]]:</span>
<span class="gi">+    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+             bytealigned: Optional[bool] = None) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find first occurrence of substring bs.

<span class="w"> </span>        Returns a single item tuple with the bit position if found, or an
<span class="gu">@@ -721,16 +1247,35 @@ class Bits:</span>
<span class="w"> </span>        (6,)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot find an empty bitstring.&quot;)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned</span>
<span class="gi">+        p = self._find(bs, start, end, ba)</span>
<span class="gi">+        return p</span>
<span class="gi">+</span>
<span class="gi">+    def _find_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="gi">+        # A forward find in lsb0 is very like a reverse find in msb0.</span>
<span class="gi">+        assert start &lt;= end</span>
<span class="gi">+        assert bitstring.options.lsb0</span>
<span class="gi">+</span>
<span class="gi">+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))</span>
<span class="gi">+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)</span>
<span class="gi">+        p = self._rfind_msb0(bs, msb0_start, msb0_end, bytealigned)</span>
<span class="gi">+</span>
<span class="gi">+        if p:</span>
<span class="gi">+            return (len(self) - p[0] - len(bs),)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ()</span>

<span class="gd">-    def _find_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool</span>
<span class="gd">-        ) -&gt;Union[Tuple[int], Tuple[()]]:</span>
<span class="gi">+    def _find_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find first occurrence of a binary string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = self._bitstore.find(bs._bitstore, start, end, bytealigned)</span>
<span class="gi">+        return () if p == -1 else (p,)</span>

<span class="gd">-    def findall(self, bs: BitsType, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, count: Optional[int]=None, bytealigned:</span>
<span class="gd">-        Optional[bool]=None) -&gt;Iterable[int]:</span>
<span class="gi">+    def findall(self, bs: BitsType, start: Optional[int] = None, end: Optional[int] = None, count: Optional[int] = None,</span>
<span class="gi">+                bytealigned: Optional[bool] = None) -&gt; Iterable[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find all occurrences of bs. Return generator of bit positions.

<span class="w"> </span>        bs -- The bitstring to find.
<span class="gu">@@ -747,11 +1292,57 @@ class Bits:</span>
<span class="w"> </span>        Note that all occurrences of bs are found, even if they overlap.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def rfind(self, bs: BitsType, /, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, bytealigned: Optional[bool]=None) -&gt;Union[Tuple</span>
<span class="gd">-        [int], Tuple[()]]:</span>
<span class="gi">+        if count is not None and count &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;In findall, count must be &gt;= 0.&quot;)</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned</span>
<span class="gi">+        return self._findall(bs, start, end, count, ba)</span>
<span class="gi">+</span>
<span class="gi">+    def _findall_msb0(self, bs: Bits, start: int, end: int, count: Optional[int],</span>
<span class="gi">+                      bytealigned: bool) -&gt; Iterable[int]:</span>
<span class="gi">+        c = 0</span>
<span class="gi">+        for i in self._bitstore.findall_msb0(bs._bitstore, start, end, bytealigned):</span>
<span class="gi">+            if count is not None and c &gt;= count:</span>
<span class="gi">+                return</span>
<span class="gi">+            c += 1</span>
<span class="gi">+            yield i</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _findall_lsb0(self, bs: Bits, start: int, end: int, count: Optional[int],</span>
<span class="gi">+                      bytealigned: bool) -&gt; Iterable[int]:</span>
<span class="gi">+        assert start &lt;= end</span>
<span class="gi">+        assert bitstring.options.lsb0</span>
<span class="gi">+</span>
<span class="gi">+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))</span>
<span class="gi">+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)</span>
<span class="gi">+</span>
<span class="gi">+        # Search chunks starting near the end and then moving back.</span>
<span class="gi">+        c = 0</span>
<span class="gi">+        increment = max(8192, len(bs) * 80)</span>
<span class="gi">+        buffersize = min(increment + len(bs), msb0_end - msb0_start)</span>
<span class="gi">+        pos = max(msb0_start, msb0_end - buffersize)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            found = list(self._findall_msb0(bs, start=pos, end=pos + buffersize, count=None, bytealigned=False))</span>
<span class="gi">+            if not found:</span>
<span class="gi">+                if pos == msb0_start:</span>
<span class="gi">+                    return</span>
<span class="gi">+                pos = max(msb0_start, pos - increment)</span>
<span class="gi">+                continue</span>
<span class="gi">+            while found:</span>
<span class="gi">+                if count is not None and c &gt;= count:</span>
<span class="gi">+                    return</span>
<span class="gi">+                c += 1</span>
<span class="gi">+                lsb0_pos = len(self) - found.pop() - len(bs)</span>
<span class="gi">+                if not bytealigned or lsb0_pos % 8 == 0:</span>
<span class="gi">+                    yield lsb0_pos</span>
<span class="gi">+</span>
<span class="gi">+            pos = max(msb0_start, pos - increment)</span>
<span class="gi">+            if pos == msb0_start:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+              bytealigned: Optional[bool] = None) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find final occurrence of substring bs.

<span class="w"> </span>        Returns a single item tuple with the bit position if found, or an
<span class="gu">@@ -769,15 +1360,34 @@ class Bits:</span>
<span class="w"> </span>        if end &lt; start.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _rfind_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool</span>
<span class="gd">-        ) -&gt;Union[Tuple[int], Tuple[()]]:</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot find an empty bitstring.&quot;)</span>
<span class="gi">+        p = self._rfind(bs, start, end, ba)</span>
<span class="gi">+        return p</span>
<span class="gi">+</span>
<span class="gi">+    def _rfind_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find final occurrence of a binary string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = self._bitstore.rfind(bs._bitstore, start, end, bytealigned)</span>
<span class="gi">+        return () if p == -1 else (p,)</span>
<span class="gi">+</span>
<span class="gi">+    def _rfind_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="gi">+        # A reverse find in lsb0 is very like a forward find in msb0.</span>
<span class="gi">+        assert start &lt;= end</span>
<span class="gi">+        assert bitstring.options.lsb0</span>
<span class="gi">+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))</span>
<span class="gi">+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)</span>
<span class="gi">+</span>
<span class="gi">+        p = self._find_msb0(bs, msb0_start, msb0_end, bytealigned)</span>
<span class="gi">+        if p:</span>
<span class="gi">+            return (len(self) - p[0] - len(bs),)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ()</span>

<span class="gd">-    def cut(self, bits: int, start: Optional[int]=None, end: Optional[int]=</span>
<span class="gd">-        None, count: Optional[int]=None) -&gt;Iterator[Bits]:</span>
<span class="gi">+    def cut(self, bits: int, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+            count: Optional[int] = None) -&gt; Iterator[Bits]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring generator by cutting into bits sized chunks.

<span class="w"> </span>        bits -- The size in bits of the bitstring chunks to generate.
<span class="gu">@@ -788,11 +1398,25 @@ class Bits:</span>
<span class="w"> </span>                 Default is to cut as many times as possible.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def split(self, delimiter: BitsType, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, count: Optional[int]=None, bytealigned:</span>
<span class="gd">-        Optional[bool]=None) -&gt;Iterable[Bits]:</span>
<span class="gi">+        start_, end_ = self._validate_slice(start, end)</span>
<span class="gi">+        if count is not None and count &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot cut - count must be &gt;= 0.&quot;)</span>
<span class="gi">+        if bits &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot cut - bits must be &gt;= 0.&quot;)</span>
<span class="gi">+        c = 0</span>
<span class="gi">+        while count is None or c &lt; count:</span>
<span class="gi">+            c += 1</span>
<span class="gi">+            nextchunk = self._slice(start_, min(start_ + bits, end_))</span>
<span class="gi">+            if len(nextchunk) == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+            yield nextchunk</span>
<span class="gi">+            if len(nextchunk) != bits:</span>
<span class="gi">+                return</span>
<span class="gi">+            start_ += bits</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, delimiter: BitsType, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+              count: Optional[int] = None, bytealigned: Optional[bool] = None) -&gt; Iterable[Bits]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return bitstring generator by splitting using a delimiter.

<span class="w"> </span>        The first item returned is the initial bitstring before the delimiter,
<span class="gu">@@ -809,38 +1433,89 @@ class Bits:</span>
<span class="w"> </span>        Raises ValueError if the delimiter is empty.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def join(self: TBits, sequence: Iterable[Any]) -&gt;TBits:</span>
<span class="gi">+        delimiter = Bits._create_from_bitstype(delimiter)</span>
<span class="gi">+        if len(delimiter) == 0:</span>
<span class="gi">+            raise ValueError(&quot;split delimiter cannot be empty.&quot;)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        bytealigned_: bool = bitstring.options.bytealigned if bytealigned is None else bytealigned</span>
<span class="gi">+        if count is not None and count &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Cannot split - count must be &gt;= 0.&quot;)</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        f = functools.partial(self._find_msb0, bs=delimiter, bytealigned=bytealigned_)</span>
<span class="gi">+        found = f(start=start, end=end)</span>
<span class="gi">+        if not found:</span>
<span class="gi">+            # Initial bits are the whole bitstring being searched</span>
<span class="gi">+            yield self._slice(start, end)</span>
<span class="gi">+            return</span>
<span class="gi">+        # yield the bytes before the first occurrence of the delimiter, even if empty</span>
<span class="gi">+        yield self._slice(start, found[0])</span>
<span class="gi">+        startpos = pos = found[0]</span>
<span class="gi">+        c = 1</span>
<span class="gi">+        while count is None or c &lt; count:</span>
<span class="gi">+            pos += len(delimiter)</span>
<span class="gi">+            found = f(start=pos, end=end)</span>
<span class="gi">+            if not found:</span>
<span class="gi">+                # No more occurrences, so return the rest of the bitstring</span>
<span class="gi">+                yield self._slice(startpos, end)</span>
<span class="gi">+                return</span>
<span class="gi">+            c += 1</span>
<span class="gi">+            yield self._slice(startpos, found[0])</span>
<span class="gi">+            startpos = pos = found[0]</span>
<span class="gi">+        # Have generated count bitstrings, so time to quit.</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def join(self: TBits, sequence: Iterable[Any]) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return concatenation of bitstrings joined by self.

<span class="w"> </span>        sequence -- A sequence of bitstrings.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tobytes(self) -&gt;bytes:</span>
<span class="gi">+        s = self.__class__()</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            # Optimised version that doesn&#39;t need to add self between every item</span>
<span class="gi">+            for item in sequence:</span>
<span class="gi">+                s._addright(Bits._create_from_bitstype(item))</span>
<span class="gi">+            return s</span>
<span class="gi">+        else:</span>
<span class="gi">+            sequence_iter = iter(sequence)</span>
<span class="gi">+            try:</span>
<span class="gi">+                s._addright(Bits._create_from_bitstype(next(sequence_iter)))</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                return s</span>
<span class="gi">+            for item in sequence_iter:</span>
<span class="gi">+                s._addright(self)</span>
<span class="gi">+                s._addright(Bits._create_from_bitstype(item))</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+    def tobytes(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the bitstring as bytes, padding with zero bits if needed.

<span class="w"> </span>        Up to seven zero bits will be added at the end to byte align.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitstore.tobytes()</span>

<span class="gd">-    def tobitarray(self) -&gt;bitarray.bitarray:</span>
<span class="gi">+    def tobitarray(self) -&gt; bitarray.bitarray:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the bitstring to a bitarray object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._bitstore.modified_length is not None:</span>
<span class="gi">+            # Removes the offset and truncates to length</span>
<span class="gi">+            return self._bitstore.getslice(0, len(self))._bitarray</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._bitstore._bitarray</span>

<span class="gd">-    def tofile(self, f: BinaryIO) -&gt;None:</span>
<span class="gi">+    def tofile(self, f: BinaryIO) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the bitstring to a file object, padding with zero bits if needed.

<span class="w"> </span>        Up to seven zero bits will be added at the end to byte align.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If the bitstring is file based then we don&#39;t want to read it all in to memory first.</span>
<span class="gi">+        chunk_size = 8 * 100 * 1024 * 1024  # 100 MiB</span>
<span class="gi">+        for chunk in self.cut(chunk_size):</span>
<span class="gi">+            f.write(chunk.tobytes())</span>

<span class="gd">-    def startswith(self, prefix: BitsType, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None) -&gt;bool:</span>
<span class="gi">+    def startswith(self, prefix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether the current bitstring starts with prefix.

<span class="w"> </span>        prefix -- The bitstring to search for.
<span class="gu">@@ -848,10 +1523,11 @@ class Bits:</span>
<span class="w"> </span>        end -- The bit position to end at. Defaults to len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix = self._create_from_bitstype(prefix)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        return self._slice(start, start + len(prefix)) == prefix if end &gt;= start + len(prefix) else False</span>

<span class="gd">-    def endswith(self, suffix: BitsType, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None) -&gt;bool:</span>
<span class="gi">+    def endswith(self, suffix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether the current bitstring ends with suffix.

<span class="w"> </span>        suffix -- The bitstring to search for.
<span class="gu">@@ -859,9 +1535,11 @@ class Bits:</span>
<span class="w"> </span>        end -- The bit position to end at. Defaults to len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        suffix = self._create_from_bitstype(suffix)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        return self._slice(end - len(suffix), end) == suffix if start + len(suffix) &lt;= end else False</span>

<span class="gd">-    def all(self, value: Any, pos: Optional[Iterable[int]]=None) -&gt;bool:</span>
<span class="gi">+    def all(self, value: Any, pos: Optional[Iterable[int]] = None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if one or many bits are all set to bool(value).

<span class="w"> </span>        value -- If value is True then checks for bits set to 1, otherwise
<span class="gu">@@ -870,9 +1548,15 @@ class Bits:</span>
<span class="w"> </span>               the same way as slice indices. Defaults to the whole bitstring.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def any(self, value: Any, pos: Optional[Iterable[int]]=None) -&gt;bool:</span>
<span class="gi">+        value = 1 if bool(value) else 0</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            return self._bitstore.all_set() if value else not self._bitstore.any_set()</span>
<span class="gi">+        for p in pos:</span>
<span class="gi">+            if self._bitstore.getindex(p) != value:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def any(self, value: Any, pos: Optional[Iterable[int]] = None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if any of one or many bits are set to bool(value).

<span class="w"> </span>        value -- If value is True then checks for bits set to 1, otherwise
<span class="gu">@@ -881,9 +1565,15 @@ class Bits:</span>
<span class="w"> </span>               the same way as slice indices. Defaults to the whole bitstring.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def count(self, value: Any) -&gt;int:</span>
<span class="gi">+        value = 1 if bool(value) else 0</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            return self._bitstore.any_set() if value else not self._bitstore.all_set()</span>
<span class="gi">+        for p in pos:</span>
<span class="gi">+            if self._bitstore.getindex(p) == value:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def count(self, value: Any) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return count of total number of either zero or one bits.

<span class="w"> </span>        value -- If bool(value) is True then bits set to 1 are counted, otherwise bits set
<span class="gu">@@ -893,26 +1583,157 @@ class Bits:</span>
<span class="w"> </span>        7

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # count the number of 1s (from which it&#39;s easy to work out the 0s).</span>
<span class="gi">+        count = self._bitstore.count(1)</span>
<span class="gi">+        return count if value else len(self) - count</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _format_bits(bits: Bits, bits_per_group: int, sep: str, dtype: Dtype,</span>
<span class="gi">+                     colour_start: str, colour_end: str, width: Optional[int]=None) -&gt; Tuple[str, int]:</span>
<span class="gi">+        get_fn = dtype.get_fn</span>
<span class="gi">+        if dtype.name == &#39;bytes&#39;:  # Special case for bytes to print one character each.</span>
<span class="gi">+            get_fn = Bits._getbytes_printable</span>
<span class="gi">+        if dtype.name == &#39;bool&#39;:  # Special case for bool to print &#39;1&#39; or &#39;0&#39; instead of `True` or `False`.</span>
<span class="gi">+            get_fn = dtype_register.get_dtype(&#39;uint&#39;, bits_per_group).get_fn</span>
<span class="gi">+        if bits_per_group == 0:</span>
<span class="gi">+            x = str(get_fn(bits))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Left-align for fixed width types when msb0, otherwise right-align.</span>
<span class="gi">+            align = &#39;&lt;&#39; if dtype.name in [&#39;bin&#39;, &#39;oct&#39;, &#39;hex&#39;, &#39;bits&#39;, &#39;bytes&#39;] and not bitstring.options.lsb0 else &#39;&gt;&#39;</span>
<span class="gi">+            chars_per_group = 0</span>
<span class="gi">+            if dtype_register[dtype.name].bitlength2chars_fn is not None:</span>
<span class="gi">+                chars_per_group = dtype_register[dtype.name].bitlength2chars_fn(bits_per_group)</span>
<span class="gi">+            x = sep.join(f&quot;{str(get_fn(b)): {align}{chars_per_group}}&quot; for b in bits.cut(bits_per_group))</span>
<span class="gi">+</span>
<span class="gi">+        chars_used = len(x)</span>
<span class="gi">+        padding_spaces = 0 if width is None else max(width - len(x), 0)</span>
<span class="gi">+        x = colour_start + x + colour_end</span>
<span class="gi">+        # Pad final line with spaces to align it</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            x = &#39; &#39; * padding_spaces + x</span>
<span class="gi">+        else:</span>
<span class="gi">+            x += &#39; &#39; * padding_spaces</span>
<span class="gi">+        return x, chars_used</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _chars_per_group(bits_per_group: int, fmt: Optional[str]):
<span class="w"> </span>        &quot;&quot;&quot;How many characters are needed to represent a number of bits with a given format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fmt is None or dtype_register[fmt].bitlength2chars_fn is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return dtype_register[fmt].bitlength2chars_fn(bits_per_group)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _bits_per_char(fmt: str):
<span class="w"> </span>        &quot;&quot;&quot;How many bits are represented by each character of a given format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fmt not in [&#39;bin&#39;, &#39;oct&#39;, &#39;hex&#39;, &#39;bytes&#39;]:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        return 24 // dtype_register[fmt].bitlength2chars_fn(24)</span>

<span class="gd">-    def _pp(self, dtype1: Dtype, dtype2: Optional[Dtype], bits_per_group:</span>
<span class="gd">-        int, width: int, sep: str, format_sep: str, show_offset: bool,</span>
<span class="gd">-        stream: TextIO, lsb0: bool, offset_factor: int) -&gt;None:</span>
<span class="gi">+    def _pp(self, dtype1: Dtype, dtype2: Optional[Dtype], bits_per_group: int, width: int, sep: str, format_sep: str,</span>
<span class="gi">+            show_offset: bool, stream: TextIO, lsb0: bool, offset_factor: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal pretty print method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        colour = Colour(not bitstring.options.no_color)</span>
<span class="gi">+        name1 = dtype1.name</span>
<span class="gi">+        name2 = dtype2.name if dtype2 is not None else None</span>
<span class="gi">+        if dtype1.variable_length:</span>
<span class="gi">+            raise ValueError(f&quot;Can&#39;t use Dtype &#39;{dtype1}&#39; in pp() as it has a variable length.&quot;)</span>
<span class="gi">+        if dtype2 is not None and dtype2.variable_length:</span>
<span class="gi">+            raise ValueError(f&quot;Can&#39;t use Dtype &#39;{dtype2}&#39; in pp() as it has a variable length.&quot;)</span>
<span class="gi">+        offset_width = 0</span>
<span class="gi">+        offset_sep = &#39; :&#39; if lsb0 else &#39;: &#39;</span>
<span class="gi">+        if show_offset:</span>
<span class="gi">+            # This could be 1 too large in some circumstances. Slightly recurrent logic needed to fix it...</span>
<span class="gi">+            offset_width = len(str(len(self))) + len(offset_sep)</span>
<span class="gi">+        if bits_per_group &gt; 0:</span>
<span class="gi">+            group_chars1 = Bits._chars_per_group(bits_per_group, name1)</span>
<span class="gi">+            group_chars2 = Bits._chars_per_group(bits_per_group, name2)</span>
<span class="gi">+            # The number of characters that get added when we add an extra group (after the first one)</span>
<span class="gi">+            total_group_chars = group_chars1 + group_chars2 + len(sep) + len(sep) * bool(group_chars2)</span>
<span class="gi">+            width_excluding_offset_and_final_group = width - offset_width - group_chars1 - group_chars2 - len(</span>
<span class="gi">+                format_sep) * bool(group_chars2)</span>
<span class="gi">+            width_excluding_offset_and_final_group = max(width_excluding_offset_and_final_group, 0)</span>
<span class="gi">+            groups_per_line = 1 + width_excluding_offset_and_final_group // total_group_chars</span>
<span class="gi">+            max_bits_per_line = groups_per_line * bits_per_group  # Number of bits represented on each line</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert bits_per_group == 0  # Don&#39;t divide into groups</span>
<span class="gi">+            width_available = width - offset_width - len(format_sep) * (name2 is not None)</span>
<span class="gi">+            width_available = max(width_available, 1)</span>
<span class="gi">+            if name2 is None:</span>
<span class="gi">+                max_bits_per_line = width_available * Bits._bits_per_char(name1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                chars_per_24_bits = dtype_register[name1].bitlength2chars_fn(24) + dtype_register[name2].bitlength2chars_fn(24)</span>
<span class="gi">+                max_bits_per_line = 24 * (width_available // chars_per_24_bits)</span>
<span class="gi">+                if max_bits_per_line == 0:</span>
<span class="gi">+                    max_bits_per_line = 24  # We can&#39;t fit into the width asked for. Show something small.</span>
<span class="gi">+        assert max_bits_per_line &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        bitpos = 0</span>
<span class="gi">+        first_fb_width = second_fb_width = None</span>
<span class="gi">+        for bits in self.cut(max_bits_per_line):</span>
<span class="gi">+            offset_str = &#39;&#39;</span>
<span class="gi">+            if show_offset:</span>
<span class="gi">+                offset = bitpos // offset_factor</span>
<span class="gi">+                bitpos += len(bits)</span>
<span class="gi">+                if bitstring.options.lsb0:</span>
<span class="gi">+                    offset_str = colour.green + offset_sep + f&#39;{offset: &lt;{offset_width - len(offset_sep)}}&#39; + colour.off</span>
<span class="gi">+                else:</span>
<span class="gi">+                    offset_str = colour.green + f&#39;{offset: &gt;{offset_width - len(offset_sep)}}&#39; + offset_sep + colour.off</span>
<span class="gi">+</span>
<span class="gi">+            fb1, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype1, colour.purple, colour.off, first_fb_width)</span>
<span class="gi">+            if first_fb_width is None:</span>
<span class="gi">+                first_fb_width = chars_used</span>
<span class="gi">+</span>
<span class="gi">+            fb2 = &#39;&#39;</span>
<span class="gi">+            if dtype2 is not None:</span>
<span class="gi">+                fb2, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype2, colour.blue, colour.off, second_fb_width)</span>
<span class="gi">+                if second_fb_width is None:</span>
<span class="gi">+                    second_fb_width = chars_used</span>
<span class="gi">+                fb2 = format_sep + fb2</span>
<span class="gi">+</span>
<span class="gi">+            if bitstring.options.lsb0 is True:</span>
<span class="gi">+                line_fmt = fb1 + fb2 + offset_str + &#39;\n&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                line_fmt = offset_str + fb1 + fb2 + &#39;\n&#39;</span>
<span class="gi">+            stream.write(line_fmt)</span>
<span class="gi">+        return</span>

<span class="gd">-    def pp(self, fmt: Optional[str]=None, width: int=120, sep: str=&#39; &#39;,</span>
<span class="gd">-        show_offset: bool=True, stream: TextIO=sys.stdout) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _process_pp_tokens(token_list, fmt):</span>
<span class="gi">+        if len(token_list) not in [1, 2]:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&quot;Only one or two tokens can be used in an pp() format - &#39;{fmt}&#39; has {len(token_list)} tokens.&quot;)</span>
<span class="gi">+        has_length_in_fmt = True</span>
<span class="gi">+        name1, length1 = utils.parse_name_length_token(token_list[0])</span>
<span class="gi">+        dtype1 = Dtype(name1, length1)</span>
<span class="gi">+        bits_per_group = dtype1.bitlength</span>
<span class="gi">+        dtype2 = None</span>
<span class="gi">+</span>
<span class="gi">+        if len(token_list) == 2:</span>
<span class="gi">+            name2, length2 = utils.parse_name_length_token(token_list[1])</span>
<span class="gi">+            dtype2 = Dtype(name2, length2)</span>
<span class="gi">+            if None not in {dtype1.bitlength, dtype2.bitlength} and dtype1.bitlength != dtype2.bitlength:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Differing bit lengths of {dtype1.bitlength} and {dtype2.bitlength} in format string &#39;{fmt}&#39;.&quot;)</span>
<span class="gi">+            if bits_per_group is None:</span>
<span class="gi">+                bits_per_group = dtype2.bitlength</span>
<span class="gi">+</span>
<span class="gi">+        if bits_per_group is None:</span>
<span class="gi">+            has_length_in_fmt = False</span>
<span class="gi">+            if len(token_list) == 1:</span>
<span class="gi">+                bits_per_group = {&#39;bin&#39;: 8, &#39;hex&#39;: 8, &#39;oct&#39;: 12, &#39;bytes&#39;: 32}.get(dtype1.name)</span>
<span class="gi">+                if bits_per_group is None:</span>
<span class="gi">+                    raise ValueError(f&quot;No length or default length available for pp() format &#39;{fmt}&#39;.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    bits_per_group = 2 * Bits._bits_per_char(dtype1.name) * Bits._bits_per_char(dtype2.name)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    raise ValueError(f&quot;Can&#39;t find a default bitlength to use for pp() format &#39;{fmt}&#39;.&quot;)</span>
<span class="gi">+                if bits_per_group &gt;= 24:</span>
<span class="gi">+                    bits_per_group //= 2</span>
<span class="gi">+        return dtype1, dtype2, bits_per_group, has_length_in_fmt</span>
<span class="gi">+</span>
<span class="gi">+    def pp(self, fmt: Optional[str] = None, width: int = 120, sep: str = &#39; &#39;,</span>
<span class="gi">+           show_offset: bool = True, stream: TextIO = sys.stdout) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pretty print the bitstring&#39;s value.

<span class="w"> </span>        fmt -- Printed data format. One or two of &#39;bin&#39;, &#39;oct&#39;, &#39;hex&#39; or &#39;bytes&#39;.
<span class="gu">@@ -929,15 +1750,42 @@ class Bits:</span>
<span class="w"> </span>        &gt;&gt;&gt; s.pp(&#39;b, h&#39;, sep=&#39;_&#39;, show_offset=False)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def copy(self: TBits) -&gt;TBits:</span>
<span class="gi">+        colour = Colour(not bitstring.options.no_color)</span>
<span class="gi">+        if fmt is None:</span>
<span class="gi">+            fmt = &#39;bin, hex&#39; if len(self) % 8 == 0 and len(self) &gt;= 8 else &#39;bin&#39;</span>
<span class="gi">+        token_list = utils.preprocess_tokens(fmt)</span>
<span class="gi">+        dtype1, dtype2, bits_per_group, has_length_in_fmt = Bits._process_pp_tokens(token_list, fmt)</span>
<span class="gi">+        trailing_bit_length = len(self) % bits_per_group if has_length_in_fmt and bits_per_group else 0</span>
<span class="gi">+        data = self if trailing_bit_length == 0 else self[0: -trailing_bit_length]</span>
<span class="gi">+        format_sep = &quot; : &quot;  # String to insert on each line between multiple formats</span>
<span class="gi">+        tidy_fmt = colour.purple + str(dtype1) + colour.off</span>
<span class="gi">+        if dtype2 is not None:</span>
<span class="gi">+            tidy_fmt += &#39;, &#39; + colour.blue + str(dtype2) + colour.off</span>
<span class="gi">+        output_stream = io.StringIO()</span>
<span class="gi">+        len_str = colour.green + str(len(self)) + colour.off</span>
<span class="gi">+        output_stream.write(f&quot;&lt;{self.__class__.__name__}, fmt=&#39;{tidy_fmt}&#39;, length={len_str} bits&gt; [\n&quot;)</span>
<span class="gi">+        data._pp(dtype1, dtype2, bits_per_group, width, sep, format_sep, show_offset,</span>
<span class="gi">+                 output_stream, bitstring.options.lsb0, 1)</span>
<span class="gi">+        output_stream.write(&quot;]&quot;)</span>
<span class="gi">+        if trailing_bit_length != 0:</span>
<span class="gi">+            output_stream.write(&quot; + trailing_bits = &quot; + str(self[-trailing_bit_length:]))</span>
<span class="gi">+        output_stream.write(&quot;\n&quot;)</span>
<span class="gi">+        stream.write(output_stream.getvalue())</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self: TBits) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of the bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note that if you want a new copy (different ID), use _copy instead.</span>
<span class="gi">+        # The copy can return self as it&#39;s immutable.</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def fromstring(cls: TBits, s: str, /) -&gt;TBits:</span>
<span class="gi">+    def fromstring(cls: TBits, s: str, /) -&gt; TBits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new bitstring from a formatted string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    len = length = property(_getlength, doc=</span>
<span class="gd">-        &#39;The length of the bitstring in bits. Read only.&#39;)</span>
<span class="gi">+        x = super().__new__(cls)</span>
<span class="gi">+        x._bitstore = bitstore_helpers.str_to_bitstore(s)</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    len = length = property(_getlength, doc=&quot;The length of the bitstring in bits. Read only.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gh">diff --git a/bitstring/bitstore.py b/bitstring/bitstore.py</span>
<span class="gh">index d01a2d3..cdb199f 100644</span>
<span class="gd">--- a/bitstring/bitstore.py</span>
<span class="gi">+++ b/bitstring/bitstore.py</span>
<span class="gu">@@ -1,63 +1,272 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import bitarray
<span class="w"> </span>from bitstring.exceptions import CreationError
<span class="w"> </span>from typing import Union, Iterable, Optional, overload, Iterator, Any


<span class="gi">+def offset_slice_indices_lsb0(key: slice, length: int) -&gt; slice:</span>
<span class="gi">+    # First convert slice to all integers</span>
<span class="gi">+    # Length already should take account of the offset</span>
<span class="gi">+    start, stop, step = key.indices(length)</span>
<span class="gi">+    new_start = length - stop</span>
<span class="gi">+    new_stop = length - start</span>
<span class="gi">+    # For negative step we sometimes get a negative stop, which can&#39;t be used correctly in a new slice</span>
<span class="gi">+    return slice(new_start, None if new_stop &lt; 0 else new_stop, step)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def offset_start_stop_lsb0(start: Optional[int], stop: Optional[int], length: int) -&gt; tuple[int, int]:</span>
<span class="gi">+    # First convert slice to all integers</span>
<span class="gi">+    # Length already should take account of the offset</span>
<span class="gi">+    start, stop, _ = slice(start, stop, None).indices(length)</span>
<span class="gi">+    new_start = length - stop</span>
<span class="gi">+    new_stop = length - start</span>
<span class="gi">+    return new_start, new_stop</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class BitStore:
<span class="w"> </span>    &quot;&quot;&quot;A light wrapper around bitarray that does the LSB0 stuff&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_bitarray&#39;, &#39;modified_length&#39;, &#39;immutable&#39;</span>

<span class="gd">-    def __init__(self, initializer: Union[int, bitarray.bitarray, str, None</span>
<span class="gd">-        ]=None, immutable: bool=False) -&gt;None:</span>
<span class="gi">+    __slots__ = (&#39;_bitarray&#39;, &#39;modified_length&#39;, &#39;immutable&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, initializer: Union[int, bitarray.bitarray, str, None] = None,</span>
<span class="gi">+                 immutable: bool = False) -&gt; None:</span>
<span class="w"> </span>        self._bitarray = bitarray.bitarray(initializer)
<span class="w"> </span>        self.immutable = immutable
<span class="w"> </span>        self.modified_length = None

<span class="gd">-    def __iadd__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def frombytes(cls, b: Union[bytes, bytearray, memoryview], /) -&gt; BitStore:</span>
<span class="gi">+        x = super().__new__(cls)</span>
<span class="gi">+        x._bitarray = bitarray.bitarray()</span>
<span class="gi">+        x._bitarray.frombytes(b)</span>
<span class="gi">+        x.immutable = False</span>
<span class="gi">+        x.modified_length = None</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def frombuffer(cls, buffer, /, length: Optional[int] = None) -&gt; BitStore:</span>
<span class="gi">+        x = super().__new__(cls)</span>
<span class="gi">+        x._bitarray = bitarray.bitarray(buffer=buffer)</span>
<span class="gi">+        x.immutable = True</span>
<span class="gi">+        x.modified_length = length</span>
<span class="gi">+        # Here &#39;modified&#39; means it shouldn&#39;t be changed further, so setting, deleting etc. are disallowed.</span>
<span class="gi">+        if x.modified_length is not None:</span>
<span class="gi">+            if x.modified_length &lt; 0:</span>
<span class="gi">+                raise CreationError(&quot;Can&#39;t create bitstring with a negative length.&quot;)</span>
<span class="gi">+            if x.modified_length &gt; len(x._bitarray):</span>
<span class="gi">+                raise CreationError(</span>
<span class="gi">+                    f&quot;Can&#39;t create bitstring with a length of {x.modified_length} from {len(x._bitarray)} bits of data.&quot;)</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    def setall(self, value: int, /) -&gt; None:</span>
<span class="gi">+        self._bitarray.setall(value)</span>
<span class="gi">+</span>
<span class="gi">+    def tobytes(self) -&gt; bytes:</span>
<span class="gi">+        if self.modified_length is not None:</span>
<span class="gi">+            return self._bitarray[:self.modified_length].tobytes()</span>
<span class="gi">+        return self._bitarray.tobytes()</span>
<span class="gi">+</span>
<span class="gi">+    def slice_to_uint(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; int:</span>
<span class="gi">+        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=False)</span>
<span class="gi">+</span>
<span class="gi">+    def slice_to_int(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; int:</span>
<span class="gi">+        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=True)</span>
<span class="gi">+</span>
<span class="gi">+    def slice_to_hex(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; str:</span>
<span class="gi">+        return bitarray.util.ba2hex(self.getslice(start, end)._bitarray)</span>
<span class="gi">+</span>
<span class="gi">+    def slice_to_bin(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; str:</span>
<span class="gi">+        return self.getslice(start, end)._bitarray.to01()</span>
<span class="gi">+</span>
<span class="gi">+    def slice_to_oct(self, start: Optional[int] = None, end: Optional[int] = None) -&gt; str:</span>
<span class="gi">+        return bitarray.util.ba2base(8, self.getslice(start, end)._bitarray)</span>
<span class="gi">+</span>
<span class="gi">+    def __iadd__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        self._bitarray += other._bitarray
<span class="w"> </span>        return self

<span class="gd">-    def __add__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __add__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        bs = self._copy()
<span class="w"> </span>        bs += other
<span class="w"> </span>        return bs

<span class="gd">-    def __eq__(self, other: Any, /) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any, /) -&gt; bool:</span>
<span class="w"> </span>        return self._bitarray == other._bitarray

<span class="gd">-    def __and__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __and__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        return BitStore(self._bitarray &amp; other._bitarray)

<span class="gd">-    def __or__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __or__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        return BitStore(self._bitarray | other._bitarray)

<span class="gd">-    def __xor__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __xor__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        return BitStore(self._bitarray ^ other._bitarray)

<span class="gd">-    def __iand__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __iand__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        self._bitarray &amp;= other._bitarray
<span class="w"> </span>        return self

<span class="gd">-    def __ior__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __ior__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        self._bitarray |= other._bitarray
<span class="w"> </span>        return self

<span class="gd">-    def __ixor__(self, other: BitStore, /) -&gt;BitStore:</span>
<span class="gi">+    def __ixor__(self, other: BitStore, /) -&gt; BitStore:</span>
<span class="w"> </span>        self._bitarray ^= other._bitarray
<span class="w"> </span>        return self

<span class="gd">-    def __iter__(self) -&gt;Iterable[bool]:</span>
<span class="gi">+    def find(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -&gt; int:</span>
<span class="gi">+        if not bytealigned:</span>
<span class="gi">+            return self._bitarray.find(bs._bitarray, start, end)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return next(self.findall_msb0(bs, start, end, bytealigned))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return -1</span>
<span class="gi">+</span>
<span class="gi">+    def rfind(self, bs: BitStore, start: int, end: int, bytealigned: bool = False):</span>
<span class="gi">+        if not bytealigned:</span>
<span class="gi">+            return self._bitarray.find(bs._bitarray, start, end, right=True)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return next(self.rfindall_msb0(bs, start, end, bytealigned))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return -1</span>
<span class="gi">+</span>
<span class="gi">+    def findall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -&gt; Iterator[int]:</span>
<span class="gi">+        if bytealigned is True and len(bs) % 8 == 0:</span>
<span class="gi">+            # Special case, looking for whole bytes on whole byte boundaries</span>
<span class="gi">+            bytes_ = bs.tobytes()</span>
<span class="gi">+            # Round up start byte to next byte, and round end byte down.</span>
<span class="gi">+            # We&#39;re only looking for whole bytes, so can ignore bits at either end.</span>
<span class="gi">+            start_byte = (start + 7) // 8</span>
<span class="gi">+            end_byte = end // 8</span>
<span class="gi">+            b = self._bitarray[start_byte * 8: end_byte * 8].tobytes()</span>
<span class="gi">+            byte_pos = 0</span>
<span class="gi">+            bytes_to_search = end_byte - start_byte</span>
<span class="gi">+            while byte_pos &lt; bytes_to_search:</span>
<span class="gi">+                byte_pos = b.find(bytes_, byte_pos)</span>
<span class="gi">+                if byte_pos == -1:</span>
<span class="gi">+                    break</span>
<span class="gi">+                yield (byte_pos + start_byte) * 8</span>
<span class="gi">+                byte_pos = byte_pos + 1</span>
<span class="gi">+            return</span>
<span class="gi">+        # General case</span>
<span class="gi">+        i = self._bitarray.itersearch(bs._bitarray, start, end)</span>
<span class="gi">+        if not bytealigned:</span>
<span class="gi">+            for p in i:</span>
<span class="gi">+                yield p</span>
<span class="gi">+        else:</span>
<span class="gi">+            for p in i:</span>
<span class="gi">+                if (p % 8) == 0:</span>
<span class="gi">+                    yield p</span>
<span class="gi">+</span>
<span class="gi">+    def rfindall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -&gt; Iterator[int]:</span>
<span class="gi">+        i = self._bitarray.itersearch(bs._bitarray, start, end, right=True)</span>
<span class="gi">+        if not bytealigned:</span>
<span class="gi">+            for p in i:</span>
<span class="gi">+                yield p</span>
<span class="gi">+        else:</span>
<span class="gi">+            for p in i:</span>
<span class="gi">+                if (p % 8) == 0:</span>
<span class="gi">+                    yield p</span>
<span class="gi">+</span>
<span class="gi">+    def count(self, value, /) -&gt; int:</span>
<span class="gi">+        return self._bitarray.count(value)</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="gi">+        self._bitarray.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def reverse(self) -&gt; None:</span>
<span class="gi">+        self._bitarray.reverse()</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterable[bool]:</span>
<span class="w"> </span>        for i in range(len(self)):
<span class="w"> </span>            yield self.getindex(i)

<span class="gd">-    def _copy(self) -&gt;BitStore:</span>
<span class="gi">+    def _copy(self) -&gt; BitStore:</span>
<span class="w"> </span>        &quot;&quot;&quot;Always creates a copy, even if instance is immutable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return BitStore(self._bitarray)</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self) -&gt; BitStore:</span>
<span class="gi">+        return self if self.immutable else self._copy()</span>

<span class="gd">-    def __getitem__(self, item: Union[int, slice], /) -&gt;Union[int, BitStore]:</span>
<span class="gi">+    def __getitem__(self, item: Union[int, slice], /) -&gt; Union[int, BitStore]:</span>
<span class="gi">+        # Use getindex or getslice instead</span>
<span class="w"> </span>        raise NotImplementedError

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gd">-        return (self.modified_length if self.modified_length is not None else</span>
<span class="gd">-            len(self._bitarray))</span>
<span class="gi">+    def getindex_msb0(self, index: int, /) -&gt; bool:</span>
<span class="gi">+        return bool(self._bitarray.__getitem__(index))</span>
<span class="gi">+</span>
<span class="gi">+    def getslice_withstep_msb0(self, key: slice, /) -&gt; BitStore:</span>
<span class="gi">+        if self.modified_length is not None:</span>
<span class="gi">+            key = slice(*key.indices(self.modified_length))</span>
<span class="gi">+        return BitStore(self._bitarray.__getitem__(key))</span>
<span class="gi">+</span>
<span class="gi">+    def getslice_withstep_lsb0(self, key: slice, /) -&gt; BitStore:</span>
<span class="gi">+        key = offset_slice_indices_lsb0(key, len(self))</span>
<span class="gi">+        return BitStore(self._bitarray.__getitem__(key))</span>
<span class="gi">+</span>
<span class="gi">+    def getslice_msb0(self, start: Optional[int], stop: Optional[int], /) -&gt; BitStore:</span>
<span class="gi">+        if self.modified_length is not None:</span>
<span class="gi">+            key = slice(*slice(start, stop, None).indices(self.modified_length))</span>
<span class="gi">+            start = key.start</span>
<span class="gi">+            stop = key.stop</span>
<span class="gi">+        return BitStore(self._bitarray[start:stop])</span>
<span class="gi">+</span>
<span class="gi">+    def getslice_lsb0(self, start: Optional[int], stop: Optional[int], /) -&gt; BitStore:</span>
<span class="gi">+        start, stop = offset_start_stop_lsb0(start, stop, len(self))</span>
<span class="gi">+        return BitStore(self._bitarray[start:stop])</span>
<span class="gi">+</span>
<span class="gi">+    def getindex_lsb0(self, index: int, /) -&gt; bool:</span>
<span class="gi">+        return bool(self._bitarray.__getitem__(-index - 1))</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def setitem_lsb0(self, key: int, value: int, /) -&gt; None:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def setitem_lsb0(self, key: slice, value: BitStore, /) -&gt; None:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def setitem_lsb0(self, key: Union[int, slice], value: Union[int, BitStore], /) -&gt; None:</span>
<span class="gi">+        if isinstance(key, slice):</span>
<span class="gi">+            new_slice = offset_slice_indices_lsb0(key, len(self))</span>
<span class="gi">+            self._bitarray.__setitem__(new_slice, value._bitarray)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitarray.__setitem__(-key - 1, value)</span>
<span class="gi">+</span>
<span class="gi">+    def delitem_lsb0(self, key: Union[int, slice], /) -&gt; None:</span>
<span class="gi">+        if isinstance(key, slice):</span>
<span class="gi">+            new_slice = offset_slice_indices_lsb0(key, len(self))</span>
<span class="gi">+            self._bitarray.__delitem__(new_slice)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitarray.__delitem__(-key - 1)</span>
<span class="gi">+</span>
<span class="gi">+    def invert_msb0(self, index: Optional[int] = None, /) -&gt; None:</span>
<span class="gi">+        if index is not None:</span>
<span class="gi">+            self._bitarray.invert(index)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitarray.invert()</span>
<span class="gi">+</span>
<span class="gi">+    def invert_lsb0(self, index: Optional[int] = None, /) -&gt; None:</span>
<span class="gi">+        if index is not None:</span>
<span class="gi">+            self._bitarray.invert(-index - 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitarray.invert()</span>
<span class="gi">+</span>
<span class="gi">+    def any_set(self) -&gt; bool:</span>
<span class="gi">+        return self._bitarray.any()</span>
<span class="gi">+</span>
<span class="gi">+    def all_set(self) -&gt; bool:</span>
<span class="gi">+        return self._bitarray.all()</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="gi">+        return self.modified_length if self.modified_length is not None else len(self._bitarray)</span>
<span class="gi">+</span>
<span class="gi">+    def setitem_msb0(self, key, value, /):</span>
<span class="gi">+        if isinstance(value, BitStore):</span>
<span class="gi">+            self._bitarray.__setitem__(key, value._bitarray)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._bitarray.__setitem__(key, value)</span>
<span class="gi">+</span>
<span class="gi">+    def delitem_msb0(self, key, /):</span>
<span class="gi">+        self._bitarray.__delitem__(key)</span>
<span class="gh">diff --git a/bitstring/bitstore_helpers.py b/bitstring/bitstore_helpers.py</span>
<span class="gh">index 87a9787..41d30d2 100644</span>
<span class="gd">--- a/bitstring/bitstore_helpers.py</span>
<span class="gi">+++ b/bitstring/bitstore_helpers.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>import math
<span class="w"> </span>import functools
<span class="gu">@@ -7,16 +8,263 @@ import bitarray</span>
<span class="w"> </span>from bitstring.bitstore import BitStore
<span class="w"> </span>import bitstring
<span class="w"> </span>from bitstring.fp8 import p4binary_fmt, p3binary_fmt
<span class="gd">-from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt, e4m3mxfp_overflow_fmt, e5m2mxfp_overflow_fmt</span>
<span class="gi">+from bitstring.mxfp import (e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt,</span>
<span class="gi">+                            e5m2mxfp_saturate_fmt, e4m3mxfp_overflow_fmt, e5m2mxfp_overflow_fmt)</span>
<span class="gi">+</span>
<span class="gi">+# The size of various caches used to improve performance</span>
<span class="w"> </span>CACHE_SIZE = 256


<span class="gd">-def tidy_input_string(s: str) -&gt;str:</span>
<span class="gi">+def tidy_input_string(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return string made lowercase and with all whitespace and underscores removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        t = s.split()</span>
<span class="gi">+    except (AttributeError, TypeError):</span>
<span class="gi">+        raise ValueError(f&quot;Expected str object but received a {type(s)} with value {s}.&quot;)</span>
<span class="gi">+    return &#39;&#39;.join(t).lower().replace(&#39;_&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+def str_to_bitstore(s: str) -&gt; BitStore:</span>
<span class="gi">+    _, tokens = bitstring.utils.tokenparser(s)</span>
<span class="gi">+    bs = BitStore()</span>
<span class="gi">+    for token in tokens:</span>
<span class="gi">+        bs += bitstore_from_token(*token)</span>
<span class="gi">+    bs.immutable = True</span>
<span class="gi">+    return bs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bin2bitstore(binstring: str) -&gt; BitStore:</span>
<span class="gi">+    binstring = tidy_input_string(binstring)</span>
<span class="gi">+    binstring = binstring.replace(&#39;0b&#39;, &#39;&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return BitStore(binstring)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise bitstring.CreationError(f&quot;Invalid character in bin initialiser {binstring}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bin2bitstore_unsafe(binstring: str) -&gt; BitStore:</span>
<span class="gi">+    return BitStore(binstring)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hex2bitstore(hexstring: str) -&gt; BitStore:</span>
<span class="gi">+    hexstring = tidy_input_string(hexstring)</span>
<span class="gi">+    hexstring = hexstring.replace(&#39;0x&#39;, &#39;&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        ba = bitarray.util.hex2ba(hexstring)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise bitstring.CreationError(&quot;Invalid symbol in hex initialiser.&quot;)</span>
<span class="gi">+    return BitStore(ba)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def oct2bitstore(octstring: str) -&gt; BitStore:</span>
<span class="gi">+    octstring = tidy_input_string(octstring)</span>
<span class="gi">+    octstring = octstring.replace(&#39;0o&#39;, &#39;&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        ba = bitarray.util.base2ba(8, octstring)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise bitstring.CreationError(&quot;Invalid symbol in oct initialiser.&quot;)</span>
<span class="gi">+    return BitStore(ba)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ue2bitstore(i: Union[str, int]) -&gt; BitStore:</span>
<span class="gi">+    i = int(i)</span>
<span class="gi">+    if i &lt; 0:</span>
<span class="gi">+        raise bitstring.CreationError(&quot;Cannot use negative initialiser for unsigned exponential-Golomb.&quot;)</span>
<span class="gi">+    if i == 0:</span>
<span class="gi">+        return BitStore(&#39;1&#39;)</span>
<span class="gi">+    tmp = i + 1</span>
<span class="gi">+    leadingzeros = -1</span>
<span class="gi">+    while tmp &gt; 0:</span>
<span class="gi">+        tmp &gt;&gt;= 1</span>
<span class="gi">+        leadingzeros += 1</span>
<span class="gi">+    remainingpart = i + 1 - (1 &lt;&lt; leadingzeros)</span>
<span class="gi">+    return BitStore(&#39;0&#39; * leadingzeros + &#39;1&#39;) + int2bitstore(remainingpart, leadingzeros, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def se2bitstore(i: Union[str, int]) -&gt; BitStore:</span>
<span class="gi">+    i = int(i)</span>
<span class="gi">+    if i &gt; 0:</span>
<span class="gi">+        u = (i * 2) - 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        u = -2 * i</span>
<span class="gi">+    return ue2bitstore(u)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def uie2bitstore(i: Union[str, int]) -&gt; BitStore:</span>
<span class="gi">+    i = int(i)</span>
<span class="gi">+    if i &lt; 0:</span>
<span class="gi">+        raise bitstring.CreationError(&quot;Cannot use negative initialiser for unsigned interleaved exponential-Golomb.&quot;)</span>
<span class="gi">+    return BitStore(&#39;1&#39; if i == 0 else &#39;0&#39; + &#39;0&#39;.join(bin(i + 1)[3:]) + &#39;1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sie2bitstore(i: Union[str, int]) -&gt; BitStore:</span>
<span class="gi">+    i = int(i)</span>
<span class="gi">+    if i == 0:</span>
<span class="gi">+        return BitStore(&#39;1&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return uie2bitstore(abs(i)) + (BitStore(&#39;1&#39;) if i &lt; 0 else BitStore(&#39;0&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bfloat2bitstore(f: Union[str, float], big_endian: bool) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    fmt = &#39;&gt;f&#39; if big_endian else &#39;&lt;f&#39;</span>
<span class="gi">+    try:</span>
<span class="gi">+        b = struct.pack(fmt, f)</span>
<span class="gi">+    except OverflowError:</span>
<span class="gi">+        # For consistency we overflow to &#39;inf&#39;.</span>
<span class="gi">+        b = struct.pack(fmt, float(&#39;inf&#39;) if f &gt; 0 else float(&#39;-inf&#39;))</span>
<span class="gi">+    return BitStore.frombytes(b[0:2]) if big_endian else BitStore.frombytes(b[2:4])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def p4binary2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    u = p4binary_fmt.float_to_int8(f)</span>
<span class="gi">+    return int2bitstore(u, 8, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def p3binary2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    u = p3binary_fmt.float_to_int8(f)</span>
<span class="gi">+    return int2bitstore(u, 8, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e4m3mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if bitstring.options.mxfp_overflow == &#39;saturate&#39;:</span>
<span class="gi">+        u = e4m3mxfp_saturate_fmt.float_to_int(f)</span>
<span class="gi">+    else:</span>
<span class="gi">+        u = e4m3mxfp_overflow_fmt.float_to_int(f)</span>
<span class="gi">+    return int2bitstore(u, 8, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e5m2mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if bitstring.options.mxfp_overflow == &#39;saturate&#39;:</span>
<span class="gi">+        u = e5m2mxfp_saturate_fmt.float_to_int(f)</span>
<span class="gi">+    else:</span>
<span class="gi">+        u = e5m2mxfp_overflow_fmt.float_to_int(f)</span>
<span class="gi">+    return int2bitstore(u, 8, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e3m2mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if math.isnan(f):</span>
<span class="gi">+        raise ValueError(&quot;Cannot convert float(&#39;nan&#39;) to e3m2mxfp format as it has no representation for it.&quot;)</span>
<span class="gi">+    u = e3m2mxfp_fmt.float_to_int(f)</span>
<span class="gi">+    return int2bitstore(u, 6, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e2m3mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if math.isnan(f):</span>
<span class="gi">+        raise ValueError(&quot;Cannot convert float(&#39;nan&#39;) to e2m3mxfp format as it has no representation for it.&quot;)</span>
<span class="gi">+    u = e2m3mxfp_fmt.float_to_int(f)</span>
<span class="gi">+    return int2bitstore(u, 6, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e2m1mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if math.isnan(f):</span>
<span class="gi">+        raise ValueError(&quot;Cannot convert float(&#39;nan&#39;) to e2m1mxfp format as it has no representation for it.&quot;)</span>
<span class="gi">+    u = e2m1mxfp_fmt.float_to_int(f)</span>
<span class="gi">+    return int2bitstore(u, 4, False)</span>


<span class="w"> </span>e8m0mxfp_allowed_values = [float(2 ** x) for x in range(-127, 128)]
<span class="gd">-literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {&#39;0x&#39;: hex2bitstore,</span>
<span class="gd">-    &#39;0X&#39;: hex2bitstore, &#39;0b&#39;: bin2bitstore, &#39;0B&#39;: bin2bitstore, &#39;0o&#39;:</span>
<span class="gd">-    oct2bitstore, &#39;0O&#39;: oct2bitstore}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def e8m0mxfp2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if math.isnan(f):</span>
<span class="gi">+        return BitStore(&#39;11111111&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        i = e8m0mxfp_allowed_values.index(f)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ValueError(f&quot;{f} is not a valid e8m0mxfp value. It must be exactly 2 ** i, for -127 &lt;= i &lt;= 127 or float(&#39;nan&#39;) as no rounding will be done.&quot;)</span>
<span class="gi">+    return int2bitstore(i, 8, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def mxint2bitstore(f: Union[str, float]) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    if math.isnan(f):</span>
<span class="gi">+        raise ValueError(&quot;Cannot convert float(&#39;nan&#39;) to mxint format as it has no representation for it.&quot;)</span>
<span class="gi">+    f *= 2 ** 6  # Remove the implicit scaling factor</span>
<span class="gi">+    if f &gt; 127:  # 1 + 63/64</span>
<span class="gi">+        return BitStore(&#39;01111111&#39;)</span>
<span class="gi">+    if f &lt;= -128:  # -2</span>
<span class="gi">+        return BitStore(&#39;10000000&#39;)</span>
<span class="gi">+    # Want to round to nearest, so move by 0.5 away from zero and round down by converting to int</span>
<span class="gi">+    if f &gt;= 0.0:</span>
<span class="gi">+        f += 0.5</span>
<span class="gi">+        i = int(f)</span>
<span class="gi">+        # For ties-round-to-even</span>
<span class="gi">+        if f - i == 0.0 and i % 2:</span>
<span class="gi">+            i -= 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        f -= 0.5</span>
<span class="gi">+        i = int(f)</span>
<span class="gi">+        if f - i == 0.0 and i % 2:</span>
<span class="gi">+            i += 1</span>
<span class="gi">+    return int2bitstore(i, 8, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def int2bitstore(i: int, length: int, signed: bool) -&gt; BitStore:</span>
<span class="gi">+    i = int(i)</span>
<span class="gi">+    try:</span>
<span class="gi">+        x = BitStore(bitarray.util.int2ba(i, length=length, endian=&#39;big&#39;, signed=signed))</span>
<span class="gi">+    except OverflowError as e:</span>
<span class="gi">+        if signed:</span>
<span class="gi">+            if i &gt;= (1 &lt;&lt; (length - 1)) or i &lt; -(1 &lt;&lt; (length - 1)):</span>
<span class="gi">+                raise bitstring.CreationError(f&quot;{i} is too large a signed integer for a bitstring of length {length}. &quot;</span>
<span class="gi">+                                    f&quot;The allowed range is [{-(1 &lt;&lt; (length - 1))}, {(1 &lt;&lt; (length - 1)) - 1}].&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if i &gt;= (1 &lt;&lt; length):</span>
<span class="gi">+                raise bitstring.CreationError(f&quot;{i} is too large an unsigned integer for a bitstring of length {length}. &quot;</span>
<span class="gi">+                                    f&quot;The allowed range is [0, {(1 &lt;&lt; length) - 1}].&quot;)</span>
<span class="gi">+            if i &lt; 0:</span>
<span class="gi">+                raise bitstring.CreationError(&quot;uint cannot be initialised with a negative number.&quot;)</span>
<span class="gi">+        raise e</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def intle2bitstore(i: int, length: int, signed: bool) -&gt; BitStore:</span>
<span class="gi">+    x = int2bitstore(i, length, signed).tobytes()</span>
<span class="gi">+    return BitStore.frombytes(x[::-1])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def float2bitstore(f: Union[str, float], length: int, big_endian: bool) -&gt; BitStore:</span>
<span class="gi">+    f = float(f)</span>
<span class="gi">+    fmt = {16: &#39;&gt;e&#39;, 32: &#39;&gt;f&#39;, 64: &#39;&gt;d&#39;}[length] if big_endian else {16: &#39;&lt;e&#39;, 32: &#39;&lt;f&#39;, 64: &#39;&lt;d&#39;}[length]</span>
<span class="gi">+    try:</span>
<span class="gi">+        b = struct.pack(fmt, f)</span>
<span class="gi">+    except OverflowError:</span>
<span class="gi">+        # If float64 doesn&#39;t fit it automatically goes to &#39;inf&#39;. This reproduces that behaviour for other types.</span>
<span class="gi">+        b = struct.pack(fmt, float(&#39;inf&#39;) if f &gt; 0 else float(&#39;-inf&#39;))</span>
<span class="gi">+    return BitStore.frombytes(b)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {</span>
<span class="gi">+    &#39;0x&#39;: hex2bitstore,</span>
<span class="gi">+    &#39;0X&#39;: hex2bitstore,</span>
<span class="gi">+    &#39;0b&#39;: bin2bitstore,</span>
<span class="gi">+    &#39;0B&#39;: bin2bitstore,</span>
<span class="gi">+    &#39;0o&#39;: oct2bitstore,</span>
<span class="gi">+    &#39;0O&#39;: oct2bitstore,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bitstore_from_token(name: str, token_length: Optional[int], value: Optional[str]) -&gt; BitStore:</span>
<span class="gi">+    if name in literal_bit_funcs:</span>
<span class="gi">+        return literal_bit_funcs[name](value)</span>
<span class="gi">+    try:</span>
<span class="gi">+        d = bitstring.dtypes.Dtype(name, token_length)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise bitstring.CreationError(f&quot;Can&#39;t parse token: {e}&quot;)</span>
<span class="gi">+    if value is None and name != &#39;pad&#39;:</span>
<span class="gi">+        raise ValueError(f&quot;Token {name} requires a value.&quot;)</span>
<span class="gi">+    bs = d.build(value)._bitstore</span>
<span class="gi">+    if token_length is not None and len(bs) != d.bitlength:</span>
<span class="gi">+        raise bitstring.CreationError(f&quot;Token with length {token_length} packed with value of length {len(bs)} &quot;</span>
<span class="gi">+                                      f&quot;({name}:{token_length}={value}).&quot;)</span>
<span class="gi">+    return bs</span>
<span class="gh">diff --git a/bitstring/bitstream.py b/bitstring/bitstream.py</span>
<span class="gh">index 9a65360..8e7c6a1 100644</span>
<span class="gd">--- a/bitstring/bitstream.py</span>
<span class="gi">+++ b/bitstring/bitstream.py</span>
<span class="gu">@@ -1,11 +1,13 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import bitstring
<span class="w"> </span>from bitstring.bits import Bits, BitsType
<span class="w"> </span>from bitstring.dtypes import Dtype
<span class="w"> </span>from typing import Union, List, Any, Optional, overload, TypeVar, Tuple
<span class="w"> </span>import copy
<span class="w"> </span>import numbers
<span class="gd">-TConstBitStream = TypeVar(&#39;TConstBitStream&#39;, bound=&#39;ConstBitStream&#39;)</span>
<span class="gi">+</span>
<span class="gi">+TConstBitStream = TypeVar(&quot;TConstBitStream&quot;, bound=&#39;ConstBitStream&#39;)</span>


<span class="w"> </span>class ConstBitStream(Bits):
<span class="gu">@@ -54,11 +56,11 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>    len -- Length of the bitstring in bits.
<span class="w"> </span>    pos -- The current bit position in the bitstring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_pos&#39;,</span>

<span class="gd">-    def __init__(self, auto: Optional[Union[BitsType, int]]=None, /, length:</span>
<span class="gd">-        Optional[int]=None, offset: Optional[int]=None, pos: int=0, **kwargs</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    __slots__ = (&#39;_pos&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,</span>
<span class="gi">+                 offset: Optional[int] = None, pos: int = 0, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Either specify an &#39;auto&#39; initialiser:
<span class="w"> </span>        A string of comma separated tokens, an integer, a file object,
<span class="w"> </span>        a bytearray, a boolean iterable or another bitstring.
<span class="gu">@@ -101,36 +103,47 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        if pos &lt; 0:
<span class="w"> </span>            pos += len(self._bitstore)
<span class="w"> </span>        if pos &lt; 0 or pos &gt; len(self._bitstore):
<span class="gd">-            raise bitstring.CreationError(</span>
<span class="gd">-                f&#39;Cannot set pos to {pos} when length is {len(self._bitstore)}.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;Cannot set pos to {pos} when length is {len(self._bitstore)}.&quot;)</span>
<span class="w"> </span>        self._pos = pos
<span class="w"> </span>        self._bitstore.immutable = True

<span class="gd">-    def _setbytepos(self, bytepos: int) -&gt;None:</span>
<span class="gi">+    def _setbytepos(self, bytepos: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Move to absolute byte-aligned position in stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._setbitpos(bytepos * 8)</span>

<span class="gd">-    def _getbytepos(self) -&gt;int:</span>
<span class="gi">+    def _getbytepos(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current position in the stream in bytes. Must be byte aligned.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._pos % 8:</span>
<span class="gi">+            raise bitstring.ByteAlignError(&quot;Not byte aligned when using bytepos property.&quot;)</span>
<span class="gi">+        return self._pos // 8</span>

<span class="gd">-    def _setbitpos(self, pos: int) -&gt;None:</span>
<span class="gi">+    def _setbitpos(self, pos: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Move to absolute position bit in bitstream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if pos &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Bit position cannot be negative.&quot;)</span>
<span class="gi">+        if pos &gt; len(self):</span>
<span class="gi">+            raise ValueError(&quot;Cannot seek past the end of the data.&quot;)</span>
<span class="gi">+        self._pos = pos</span>

<span class="gd">-    def _getbitpos(self) -&gt;int:</span>
<span class="gi">+    def _getbitpos(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current position in the stream in bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._pos</span>

<span class="gd">-    def __copy__(self: TConstBitStream) -&gt;TConstBitStream:</span>
<span class="gi">+    def _clear(self) -&gt; None:</span>
<span class="gi">+        Bits._clear(self)</span>
<span class="gi">+        self._pos = 0</span>
<span class="gi">+</span>
<span class="gi">+    def __copy__(self: TConstBitStream) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new copy of the ConstBitStream for the copy module.&quot;&quot;&quot;
<span class="gi">+        # Note that if you want a new copy (different ID), use _copy instead.</span>
<span class="gi">+        # The copy can use the same datastore as it&#39;s immutable.</span>
<span class="w"> </span>        s = self.__class__()
<span class="w"> </span>        s._bitstore = self._bitstore
<span class="gi">+        # Reset the bit position, don&#39;t copy it.</span>
<span class="w"> </span>        s._pos = 0
<span class="w"> </span>        return s

<span class="gd">-    def __and__(self: TConstBitStream, bs: BitsType, /) -&gt;TConstBitStream:</span>
<span class="gi">+    def __and__(self: TConstBitStream, bs: BitsType, /) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;and&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;&amp;&#39; with.
<span class="gu">@@ -142,7 +155,7 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        s._pos = 0
<span class="w"> </span>        return s

<span class="gd">-    def __or__(self: TConstBitStream, bs: BitsType, /) -&gt;TConstBitStream:</span>
<span class="gi">+    def __or__(self: TConstBitStream, bs: BitsType, /) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;or&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;|&#39; with.
<span class="gu">@@ -154,7 +167,7 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        s._pos = 0
<span class="w"> </span>        return s

<span class="gd">-    def __xor__(self: TConstBitStream, bs: BitsType, /) -&gt;TConstBitStream:</span>
<span class="gi">+    def __xor__(self: TConstBitStream, bs: BitsType, /) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bit-wise &#39;xor&#39; between two bitstrings. Returns new bitstring.

<span class="w"> </span>        bs -- The bitstring to &#39;^&#39; with.
<span class="gu">@@ -166,7 +179,7 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        s._pos = 0
<span class="w"> </span>        return s

<span class="gd">-    def __add__(self: TConstBitStream, bs: BitsType, /) -&gt;TConstBitStream:</span>
<span class="gi">+    def __add__(self: TConstBitStream, bs: BitsType, /) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Concatenate bitstrings and return new bitstring.

<span class="w"> </span>        bs -- the bitstring to append.
<span class="gu">@@ -176,7 +189,7 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        s._pos = 0
<span class="w"> </span>        return s

<span class="gd">-    def append(self, bs: BitsType, /) -&gt;None:</span>
<span class="gi">+    def append(self, bs: BitsType, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append a bitstring to the current bitstring.

<span class="w"> </span>        bs -- The bitstring to append.
<span class="gu">@@ -184,9 +197,10 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        The current bit position will be moved to the end of the BitStream.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._append(bs)</span>
<span class="gi">+        self._pos = len(self)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return representation that could be used to recreate the bitstring.

<span class="w"> </span>        If the returned string is too long it will be truncated. See __str__().
<span class="gu">@@ -194,7 +208,7 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return self._repr(self.__class__.__name__, len(self), self._pos)

<span class="gd">-    def overwrite(self, bs: BitsType, /, pos: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def overwrite(self, bs: BitsType, /, pos: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Overwrite with bitstring at bit position pos.

<span class="w"> </span>        bs -- The bitstring to overwrite with.
<span class="gu">@@ -204,11 +218,20 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        Raises ValueError if pos &lt; 0 or pos &gt; len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find(self, bs: BitsType, /, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, bytealigned: Optional[bool]=None) -&gt;Union[Tuple</span>
<span class="gd">-        [int], Tuple[()]]:</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            pos = self._pos</span>
<span class="gi">+        if pos &lt; 0:</span>
<span class="gi">+            pos += len(self)</span>
<span class="gi">+        if pos &lt; 0 or pos &gt; len(self):</span>
<span class="gi">+            raise ValueError(&quot;Overwrite starts outside boundary of bitstring.&quot;)</span>
<span class="gi">+        self._overwrite(bs, pos)</span>
<span class="gi">+        self._pos = pos + len(bs)</span>
<span class="gi">+</span>
<span class="gi">+    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+             bytealigned: Optional[bool] = None) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find first occurrence of substring bs.

<span class="w"> </span>        Returns a single item tuple with the bit position if found, or an
<span class="gu">@@ -229,11 +252,14 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        (6,)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def rfind(self, bs: BitsType, /, start: Optional[int]=None, end:</span>
<span class="gd">-        Optional[int]=None, bytealigned: Optional[bool]=None) -&gt;Union[Tuple</span>
<span class="gd">-        [int], Tuple[()]]:</span>
<span class="gi">+        p = super().find(bs, start, end, bytealigned)</span>
<span class="gi">+        if p:</span>
<span class="gi">+            self._pos = p[0]</span>
<span class="gi">+        return p</span>
<span class="gi">+</span>
<span class="gi">+    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+              bytealigned: Optional[bool] = None) -&gt; Union[Tuple[int], Tuple[()]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find final occurrence of substring bs.

<span class="w"> </span>        Returns a single item tuple with the bit position if found, or an
<span class="gu">@@ -251,10 +277,20 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        if end &lt; start.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = super().rfind(bs, start, end, bytealigned)</span>
<span class="gi">+        if p:</span>
<span class="gi">+            self._pos = p[0]</span>
<span class="gi">+        return p</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def read(self, fmt: int) -&gt; Bits:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def read(self, fmt: str) -&gt; Any:</span>
<span class="gi">+        ...</span>

<span class="gd">-    def read(self, fmt: Union[int, str, Dtype]) -&gt;Union[int, float, str,</span>
<span class="gd">-        Bits, bool, bytes, None]:</span>
<span class="gi">+    def read(self, fmt: Union[int, str, Dtype]) -&gt; Union[int, float, str, Bits, bool, bytes, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret next bits according to the format string and return result.

<span class="w"> </span>        fmt -- Token string describing how to interpret the next bits.
<span class="gu">@@ -290,10 +326,38 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        Raises ValueError if the format is not understood.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def readlist(self, fmt: Union[str, List[Union[int, str, Dtype]]], **kwargs</span>
<span class="gd">-        ) -&gt;List[Union[int, float, str, Bits, bool, bytes, None]]:</span>
<span class="gi">+        p = self._pos</span>
<span class="gi">+        if isinstance(fmt, numbers.Integral):</span>
<span class="gi">+            if fmt &lt; 0:</span>
<span class="gi">+                raise ValueError(&quot;Cannot read negative amount.&quot;)</span>
<span class="gi">+            if fmt &gt; len(self) - self._pos:</span>
<span class="gi">+                raise bitstring.ReadError(f&quot;Cannot read {fmt} bits, only {len(self) - self._pos} available.&quot;)</span>
<span class="gi">+            bs = self._slice(self._pos, self._pos + fmt)</span>
<span class="gi">+            self._pos += fmt</span>
<span class="gi">+            return bs</span>
<span class="gi">+        dtype = bitstring.dtypes.Dtype(fmt)</span>
<span class="gi">+        if dtype.bitlength is None and not dtype.variable_length:</span>
<span class="gi">+            # No length specified? Try again, but read to end.</span>
<span class="gi">+            bitlength = len(self) - self._pos</span>
<span class="gi">+            items, remainder = divmod(bitlength, dtype.bits_per_item)</span>
<span class="gi">+            if remainder != 0:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;The &#39;{dtype.name}&#39; type must have a bit length that is a multiple of {dtype.bits_per_item}&quot;</span>
<span class="gi">+                    f&quot; so cannot be read from the {bitlength} bits that are available.&quot;)</span>
<span class="gi">+            dtype = bitstring.dtypes.Dtype(fmt, items)</span>
<span class="gi">+        if dtype.bitlength is not None:</span>
<span class="gi">+            val = dtype.read_fn(self, self._pos)</span>
<span class="gi">+            self._pos += dtype.bitlength</span>
<span class="gi">+        else:</span>
<span class="gi">+            val, self._pos = dtype.read_fn(self, self._pos)</span>
<span class="gi">+</span>
<span class="gi">+        if self._pos &gt; len(self):</span>
<span class="gi">+            self._pos = p</span>
<span class="gi">+            raise bitstring.ReadError(f&quot;Reading off end of bitstring with fmt &#39;{fmt}&#39;. Only {len(self) - p} bits available.&quot;)</span>
<span class="gi">+        return val</span>
<span class="gi">+</span>
<span class="gi">+    def readlist(self, fmt: Union[str, List[Union[int, str, Dtype]]], **kwargs) \</span>
<span class="gi">+            -&gt; List[Union[int, float, str, Bits, bool, bytes, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret next bits according to format string(s) and return list.

<span class="w"> </span>        fmt -- A single string or list of strings with comma separated tokens
<span class="gu">@@ -314,10 +378,10 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        &gt;&gt;&gt; i, bs1, bs2 = s.readlist([&#39;uint:12&#39;, 10, 10])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value, self._pos = self._readlist(fmt, self._pos, **kwargs)</span>
<span class="gi">+        return value</span>

<span class="gd">-    def readto(self: TConstBitStream, bs: BitsType, /, bytealigned:</span>
<span class="gd">-        Optional[bool]=None) -&gt;TConstBitStream:</span>
<span class="gi">+    def readto(self: TConstBitStream, bs: BitsType, /, bytealigned: Optional[bool] = None) -&gt; TConstBitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read up to and including next occurrence of bs and return result.

<span class="w"> </span>        bs -- The bitstring to find.
<span class="gu">@@ -328,10 +392,25 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        Raises ReadError if bs is not found.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(bs, numbers.Integral):</span>
<span class="gi">+            raise ValueError(&quot;Integers cannot be searched for&quot;)</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        oldpos = self._pos</span>
<span class="gi">+        p = self.find(bs, self._pos, bytealigned=bytealigned)</span>
<span class="gi">+        if not p:</span>
<span class="gi">+            raise bitstring.ReadError(&quot;Substring not found&quot;)</span>
<span class="gi">+        self._pos += len(bs)</span>
<span class="gi">+        return self._slice(oldpos, self._pos)</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def peek(self: TConstBitStream, fmt: int) -&gt; TConstBitStream:</span>
<span class="gi">+        ...</span>

<span class="gd">-    def peek(self: TConstBitStream, fmt: Union[int, str]) -&gt;Union[int,</span>
<span class="gd">-        float, str, TConstBitStream, bool, bytes, None]:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def peek(self, fmt: str) -&gt; Union[int, float, str, TConstBitStream, bool, bytes, None]:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    def peek(self: TConstBitStream, fmt: Union[int, str]) -&gt; Union[int, float, str, TConstBitStream, bool, bytes, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret next bits according to format string and return result.

<span class="w"> </span>        fmt -- Token string describing how to interpret the next bits.
<span class="gu">@@ -345,10 +424,13 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        See the docstring for &#39;read&#39; for token examples.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pos_before = self._pos</span>
<span class="gi">+        value = self.read(fmt)</span>
<span class="gi">+        self._pos = pos_before</span>
<span class="gi">+        return value</span>

<span class="gd">-    def peeklist(self, fmt: Union[str, List[Union[int, str]]], **kwargs</span>
<span class="gd">-        ) -&gt;List[Union[int, float, str, Bits, None]]:</span>
<span class="gi">+    def peeklist(self, fmt: Union[str, List[Union[int, str]]], **kwargs) \</span>
<span class="gi">+            -&gt; List[Union[int, float, str, Bits, None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interpret next bits according to format string(s) and return list.

<span class="w"> </span>        fmt -- One or more integers or strings with comma separated tokens describing
<span class="gu">@@ -365,27 +447,38 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        See the docstring for &#39;read&#39; for token examples.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pos = self._pos</span>
<span class="gi">+        return_values = self.readlist(fmt, **kwargs)</span>
<span class="gi">+        self._pos = pos</span>
<span class="gi">+        return return_values</span>

<span class="gd">-    def bytealign(self) -&gt;int:</span>
<span class="gi">+    def bytealign(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Align to next byte and return number of skipped bits.

<span class="w"> </span>        Raises ValueError if the end of the bitstring is reached before
<span class="w"> </span>        aligning to the next byte.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        skipped = (8 - (self._pos % 8)) % 8</span>
<span class="gi">+        self.pos += skipped</span>
<span class="gi">+        return skipped</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def fromstring(cls: TBits, s: str, /) -&gt; TBits:</span>
<span class="gi">+        x = super().fromstring(s)</span>
<span class="gi">+        x._pos = 0</span>
<span class="gi">+        x._bitstore.immutable = True</span>
<span class="gi">+        return x</span>

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self: TBits, key: slice, /) -&gt;TBits:</span>
<span class="gi">+    def __getitem__(self: TBits, key: slice, /) -&gt; TBits:</span>
<span class="w"> </span>        ...

<span class="w"> </span>    @overload
<span class="gd">-    def __getitem__(self: TBits, key: int, /) -&gt;bool:</span>
<span class="gi">+    def __getitem__(self: TBits, key: int, /) -&gt; bool:</span>
<span class="w"> </span>        ...

<span class="gd">-    def __getitem__(self: TBits, key: Union[slice, int], /) -&gt;Union[TBits, bool</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def __getitem__(self: TBits, key: Union[slice, int], /) -&gt; Union[TBits, bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new bitstring representing a slice of the current bitstring.&quot;&quot;&quot;
<span class="w"> </span>        if isinstance(key, numbers.Integral):
<span class="w"> </span>            return bool(self._bitstore.getindex(key))
<span class="gu">@@ -393,18 +486,16 @@ class ConstBitStream(Bits):</span>
<span class="w"> </span>        bs._bitstore = self._bitstore.getslice_withstep(key)
<span class="w"> </span>        bs._pos = 0
<span class="w"> </span>        return bs
<span class="gd">-    pos = property(_getbitpos, _setbitpos, doc=</span>
<span class="gd">-        &quot;&quot;&quot;The position in the bitstring in bits. Read and write.</span>
<span class="gd">-                      &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gd">-    bitpos = property(_getbitpos, _setbitpos, doc=</span>
<span class="gd">-        &quot;&quot;&quot;The position in the bitstring in bits. Read and write.</span>
<span class="gd">-                      &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gd">-    bytepos = property(_getbytepos, _setbytepos, doc=</span>
<span class="gd">-        &quot;&quot;&quot;The position in the bitstring in bytes. Read and write.</span>
<span class="gd">-                      &quot;&quot;&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+</span>
<span class="gi">+    pos = property(_getbitpos, _setbitpos,</span>
<span class="gi">+                   doc=&quot;&quot;&quot;The position in the bitstring in bits. Read and write.</span>
<span class="gi">+                      &quot;&quot;&quot;)</span>
<span class="gi">+    bitpos = property(_getbitpos, _setbitpos,</span>
<span class="gi">+                      doc=&quot;&quot;&quot;The position in the bitstring in bits. Read and write.</span>
<span class="gi">+                      &quot;&quot;&quot;)</span>
<span class="gi">+    bytepos = property(_getbytepos, _setbytepos,</span>
<span class="gi">+                       doc=&quot;&quot;&quot;The position in the bitstring in bytes. Read and write.</span>
<span class="gi">+                      &quot;&quot;&quot;)</span>


<span class="w"> </span>class BitStream(ConstBitStream, bitstring.BitArray):
<span class="gu">@@ -464,11 +555,11 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>    len -- Length of the bitstring in bits.
<span class="w"> </span>    pos -- The current bit position in the bitstring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __init__(self, auto: Optional[Union[BitsType, int]]=None, /, length:</span>
<span class="gd">-        Optional[int]=None, offset: Optional[int]=None, pos: int=0, **kwargs</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,</span>
<span class="gi">+                 offset: Optional[int] = None, pos: int = 0, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Either specify an &#39;auto&#39; initialiser:
<span class="w"> </span>        A string of comma separated tokens, an integer, a file object,
<span class="w"> </span>        a bytearray, a boolean iterable or another bitstring.
<span class="gu">@@ -513,14 +604,14 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>            self._bitstore = self._bitstore._copy()
<span class="w"> </span>            self._bitstore.immutable = False

<span class="gd">-    def __copy__(self) -&gt;BitStream:</span>
<span class="gi">+    def __copy__(self) -&gt; BitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new copy of the BitStream.&quot;&quot;&quot;
<span class="w"> </span>        s_copy = object.__new__(BitStream)
<span class="w"> </span>        s_copy._pos = 0
<span class="w"> </span>        s_copy._bitstore = self._bitstore.copy()
<span class="w"> </span>        return s_copy

<span class="gd">-    def __iadd__(self, bs: BitsType, /) -&gt;BitStream:</span>
<span class="gi">+    def __iadd__(self, bs: BitsType, /) -&gt; BitStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append to current bitstring. Return self.

<span class="w"> </span>        bs -- the bitstring to append.
<span class="gu">@@ -531,22 +622,24 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>        self._pos = len(self)
<span class="w"> </span>        return self

<span class="gd">-    def prepend(self, bs: BitsType, /) -&gt;None:</span>
<span class="gi">+    def prepend(self, bs: BitsType, /) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepend a bitstring to the current bitstring.

<span class="w"> </span>        bs -- The bitstring to prepend.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        super().prepend(bs)</span>
<span class="gi">+        self._pos = 0</span>

<span class="gd">-    def __setitem__(self, /, key: Union[slice, int], value: BitsType) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, /, key: Union[slice, int], value: BitsType) -&gt; None:</span>
<span class="w"> </span>        length_before = len(self)
<span class="w"> </span>        super().__setitem__(key, value)
<span class="w"> </span>        if len(self) != length_before:
<span class="w"> </span>            self._pos = 0
<span class="w"> </span>        return

<span class="gd">-    def __delitem__(self, /, key: Union[slice, int]) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, /, key: Union[slice, int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Delete item or range.

<span class="w"> </span>        &gt;&gt;&gt; a = BitStream(&#39;0x001122&#39;)
<span class="gu">@@ -560,7 +653,7 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>        if len(self) != length_before:
<span class="w"> </span>            self._pos = 0

<span class="gd">-    def insert(self, bs: BitsType, /, pos: Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def insert(self, bs: BitsType, /, pos: Optional[int] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Insert bitstring at bit position pos.

<span class="w"> </span>        bs -- The bitstring to insert.
<span class="gu">@@ -570,11 +663,22 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>        Raises ValueError if pos &lt; 0 or pos &gt; len(self).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def replace(self, old: BitsType, new: BitsType, start: Optional[int]=</span>
<span class="gd">-        None, end: Optional[int]=None, count: Optional[int]=None,</span>
<span class="gd">-        bytealigned: Optional[bool]=None) -&gt;int:</span>
<span class="gi">+        bs = Bits._create_from_bitstype(bs)</span>
<span class="gi">+        if len(bs) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        if bs is self:</span>
<span class="gi">+            bs = self._copy()</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            pos = self._pos</span>
<span class="gi">+        if pos &lt; 0:</span>
<span class="gi">+            pos += len(self)</span>
<span class="gi">+        if not 0 &lt;= pos &lt;= len(self):</span>
<span class="gi">+            raise ValueError(&quot;Invalid insert position.&quot;)</span>
<span class="gi">+        self._insert(bs, pos)</span>
<span class="gi">+        self._pos = pos + len(bs)</span>
<span class="gi">+</span>
<span class="gi">+    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,</span>
<span class="gi">+                count: Optional[int] = None, bytealigned: Optional[bool] = None) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace all occurrences of old with new in place.

<span class="w"> </span>        Returns number of replacements made.
<span class="gu">@@ -594,4 +698,17 @@ class BitStream(ConstBitStream, bitstring.BitArray):</span>
<span class="w"> </span>        out of range.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if len(old := Bits._create_from_bitstype(old)) == 0:</span>
<span class="gi">+            raise ValueError(&quot;Empty bitstring cannot be replaced.&quot;)</span>
<span class="gi">+        start, end = self._validate_slice(start, end)</span>
<span class="gi">+        new = Bits._create_from_bitstype(new)</span>
<span class="gi">+        if new is self:</span>
<span class="gi">+            # Prevent self assignment woes</span>
<span class="gi">+            new = copy.copy(self)</span>
<span class="gi">+        length_before = len(self)</span>
<span class="gi">+        replacement_count = self._replace(old, new, start, end, 0 if count is None else count, bytealigned)</span>
<span class="gi">+        if len(self) != length_before:</span>
<span class="gi">+            self._pos = 0</span>
<span class="gi">+        return replacement_count</span>
\ No newline at end of file
<span class="gh">diff --git a/bitstring/bitstring_options.py b/bitstring/bitstring_options.py</span>
<span class="gh">index 8928d8e..de84ae5 100644</span>
<span class="gd">--- a/bitstring/bitstring_options.py</span>
<span class="gi">+++ b/bitstring/bitstring_options.py</span>
<span class="gu">@@ -1,25 +1,80 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import bitstring
<span class="w"> </span>import os


<span class="w"> </span>class Options:
<span class="w"> </span>    &quot;&quot;&quot;Internal class to create singleton module options instance.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _instance = None

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.set_lsb0(False)
<span class="w"> </span>        self._bytealigned = False
<span class="w"> </span>        self.mxfp_overflow = &#39;saturate&#39;
<span class="gi">+</span>
<span class="w"> </span>        self.no_color = False
<span class="w"> </span>        no_color = os.getenv(&#39;NO_COLOR&#39;)
<span class="w"> </span>        self.no_color = True if no_color else False

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        attributes = {attr: getattr(self, attr) for attr in dir(self) if </span>
<span class="gd">-            not attr.startswith(&#39;_&#39;) and not callable(getattr(self, attr))}</span>
<span class="gd">-        return &#39;\n&#39;.join(f&#39;{attr}: {value!r}&#39; for attr, value in attributes</span>
<span class="gd">-            .items())</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mxfp_overflow(self) -&gt; str:</span>
<span class="gi">+        return self._mxfp_overflow</span>
<span class="gi">+</span>
<span class="gi">+    @mxfp_overflow.setter</span>
<span class="gi">+    def mxfp_overflow(self, value: str) -&gt; None:</span>
<span class="gi">+        allowed_values = (&#39;saturate&#39;, &#39;overflow&#39;)</span>
<span class="gi">+        if value not in allowed_values:</span>
<span class="gi">+            raise ValueError(f&quot;mxfp_overflow must be one of {allowed_values}, not {value}.&quot;)</span>
<span class="gi">+        self._mxfp_overflow = value</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        attributes = {attr: getattr(self, attr) for attr in dir(self) if not attr.startswith(&#39;_&#39;) and not callable(getattr(self, attr))}</span>
<span class="gi">+        return &#39;\n&#39;.join(f&quot;{attr}: {value!r}&quot; for attr, value in attributes.items())</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def lsb0(self) -&gt; bool:</span>
<span class="gi">+        return self._lsb0</span>
<span class="gi">+</span>
<span class="gi">+    @lsb0.setter</span>
<span class="gi">+    def lsb0(self, value: bool) -&gt; None:</span>
<span class="gi">+        self.set_lsb0(value)</span>
<span class="gi">+</span>
<span class="gi">+    def set_lsb0(self, value: bool) -&gt; None:</span>
<span class="gi">+        self._lsb0 = bool(value)</span>
<span class="gi">+        Bits = bitstring.bits.Bits</span>
<span class="gi">+        BitArray = bitstring.bitarray_.BitArray</span>
<span class="gi">+        BitStore = bitstring.bitstore.BitStore</span>
<span class="gi">+</span>
<span class="gi">+        lsb0_methods = {</span>
<span class="gi">+            Bits: {&#39;_find&#39;: Bits._find_lsb0, &#39;_rfind&#39;: Bits._rfind_lsb0, &#39;_findall&#39;: Bits._findall_lsb0},</span>
<span class="gi">+            BitArray: {&#39;_ror&#39;: BitArray._rol_msb0, &#39;_rol&#39;: BitArray._ror_msb0, &#39;_append&#39;: BitArray._append_lsb0,</span>
<span class="gi">+                       &#39;_prepend&#39;: BitArray._append_msb0},</span>
<span class="gi">+            BitStore: {&#39;__setitem__&#39;: BitStore.setitem_lsb0, &#39;__delitem__&#39;: BitStore.delitem_lsb0,</span>
<span class="gi">+                       &#39;getindex&#39;: BitStore.getindex_lsb0, &#39;getslice&#39;: BitStore.getslice_lsb0,</span>
<span class="gi">+                       &#39;getslice_withstep&#39;: BitStore.getslice_withstep_lsb0, &#39;invert&#39;: BitStore.invert_lsb0}</span>
<span class="gi">+        }</span>
<span class="gi">+        msb0_methods = {</span>
<span class="gi">+            Bits: {&#39;_find&#39;: Bits._find_msb0, &#39;_rfind&#39;: Bits._rfind_msb0, &#39;_findall&#39;: Bits._findall_msb0},</span>
<span class="gi">+            BitArray: {&#39;_ror&#39;: BitArray._ror_msb0, &#39;_rol&#39;: BitArray._rol_msb0, &#39;_append&#39;: BitArray._append_msb0,</span>
<span class="gi">+                       &#39;_prepend&#39;: BitArray._append_lsb0},</span>
<span class="gi">+            BitStore: {&#39;__setitem__&#39;: BitStore.setitem_msb0, &#39;__delitem__&#39;: BitStore.delitem_msb0,</span>
<span class="gi">+                       &#39;getindex&#39;: BitStore.getindex_msb0, &#39;getslice&#39;: BitStore.getslice_msb0,</span>
<span class="gi">+                       &#39;getslice_withstep&#39;: BitStore.getslice_withstep_msb0, &#39;invert&#39;: BitStore.invert_msb0}</span>
<span class="gi">+        }</span>
<span class="gi">+        methods = lsb0_methods if self._lsb0 else msb0_methods</span>
<span class="gi">+        for cls, method_dict in methods.items():</span>
<span class="gi">+            for attr, method in method_dict.items():</span>
<span class="gi">+                setattr(cls, attr, method)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def bytealigned(self) -&gt; bool:</span>
<span class="gi">+        return self._bytealigned</span>
<span class="gi">+</span>
<span class="gi">+    @bytealigned.setter</span>
<span class="gi">+    def bytealigned(self, value: bool) -&gt; None:</span>
<span class="gi">+        self._bytealigned = bool(value)</span>

<span class="w"> </span>    def __new__(cls):
<span class="w"> </span>        if cls._instance is None:
<span class="gu">@@ -28,14 +83,13 @@ class Options:</span>


<span class="w"> </span>class Colour:
<span class="gd">-</span>
<span class="gd">-    def __new__(cls, use_colour: bool) -&gt;Colour:</span>
<span class="gi">+    def __new__(cls, use_colour: bool) -&gt; Colour:</span>
<span class="w"> </span>        x = super().__new__(cls)
<span class="w"> </span>        if use_colour:
<span class="gd">-            cls.blue = &#39;\x1b[34m&#39;</span>
<span class="gd">-            cls.purple = &#39;\x1b[35m&#39;</span>
<span class="gd">-            cls.green = &#39;\x1b[32m&#39;</span>
<span class="gd">-            cls.off = &#39;\x1b[0m&#39;</span>
<span class="gi">+            cls.blue = &#39;\033[34m&#39;</span>
<span class="gi">+            cls.purple = &#39;\033[35m&#39;</span>
<span class="gi">+            cls.green = &#39;\033[32m&#39;</span>
<span class="gi">+            cls.off = &#39;\033[0m&#39;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            cls.blue = cls.purple = cls.green = cls.off = &#39;&#39;
<span class="w"> </span>        return x
<span class="gh">diff --git a/bitstring/dtypes.py b/bitstring/dtypes.py</span>
<span class="gh">index 775063f..86c4ad1 100644</span>
<span class="gd">--- a/bitstring/dtypes.py</span>
<span class="gi">+++ b/bitstring/dtypes.py</span>
<span class="gu">@@ -1,12 +1,36 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from typing import Optional, Dict, Any, Union, Tuple, Callable
<span class="w"> </span>import inspect
<span class="w"> </span>import bitstring
<span class="w"> </span>from bitstring import utils
<span class="gi">+</span>
<span class="w"> </span>CACHE_SIZE = 256


<span class="gi">+def scaled_get_fn(get_fn, s: Union[int, float]):</span>
<span class="gi">+    def wrapper(*args, scale=s, **kwargs):</span>
<span class="gi">+        return get_fn(*args, **kwargs) * scale</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def scaled_set_fn(set_fn, s: Union[int, float]):</span>
<span class="gi">+    def wrapper(bs, value, *args, scale=s, **kwargs):</span>
<span class="gi">+        return set_fn(bs, value / scale, *args, **kwargs)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def scaled_read_fn(read_fn, s: Union[int, float]):</span>
<span class="gi">+    def wrapper(*args, scale=s, **kwargs):</span>
<span class="gi">+        val = read_fn(*args, **kwargs)</span>
<span class="gi">+        if isinstance(val, tuple):</span>
<span class="gi">+            val, pos = val</span>
<span class="gi">+            return val * scale, pos</span>
<span class="gi">+        return val * scale</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Dtype:
<span class="w"> </span>    &quot;&quot;&quot;A data type class, representing a concrete interpretation of binary data.

<span class="gu">@@ -17,6 +41,7 @@ class Dtype:</span>
<span class="w"> </span>    &gt;&gt;&gt; mxfp = Dtype(&#39;e3m2mxfp&#39;, scale=2 ** 6)  # dtype with scaling factor

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _name: str
<span class="w"> </span>    _read_fn: Callable
<span class="w"> </span>    _set_fn: Callable
<span class="gu">@@ -30,8 +55,7 @@ class Dtype:</span>
<span class="w"> </span>    _length: Optional[int]
<span class="w"> </span>    _scale: Union[None, float, int]

<span class="gd">-    def __new__(cls, token: Union[str, Dtype], /, length: Optional[int]=</span>
<span class="gd">-        None, scale: Union[None, float, int]=None) -&gt;Dtype:</span>
<span class="gi">+    def __new__(cls, token: Union[str, Dtype], /, length: Optional[int] = None, scale: Union[None, float, int] = None) -&gt; Dtype:</span>
<span class="w"> </span>        if isinstance(token, cls):
<span class="w"> </span>            return token
<span class="w"> </span>        if length is None:
<span class="gu">@@ -42,92 +66,144 @@ class Dtype:</span>
<span class="w"> </span>            return x

<span class="w"> </span>    @property
<span class="gd">-    def scale(self) -&gt;Union[int, float, None]:</span>
<span class="gi">+    def scale(self) -&gt; Union[int, float, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The multiplicative scale applied when interpreting the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._scale</span>

<span class="w"> </span>    @property
<span class="gd">-    def name(self) -&gt;str:</span>
<span class="gi">+    def name(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;A string giving the name of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name</span>

<span class="w"> </span>    @property
<span class="gd">-    def length(self) -&gt;int:</span>
<span class="gi">+    def length(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The length of the data type in units of bits_per_item. Set to None for variable length dtypes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._length</span>

<span class="w"> </span>    @property
<span class="gd">-    def bitlength(self) -&gt;Optional[int]:</span>
<span class="gi">+    def bitlength(self) -&gt; Optional[int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The number of bits needed to represent a single instance of the data type. Set to None for variable length dtypes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitlength</span>

<span class="w"> </span>    @property
<span class="gd">-    def bits_per_item(self) -&gt;int:</span>
<span class="gi">+    def bits_per_item(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;The number of bits for each unit of length. Usually 1, but equals 8 for bytes type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bits_per_item</span>

<span class="w"> </span>    @property
<span class="gd">-    def variable_length(self) -&gt;bool:</span>
<span class="gi">+    def variable_length(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;If True then the length of the data type depends on the data being interpreted, and must not be specified.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._variable_length</span>

<span class="w"> </span>    @property
<span class="gd">-    def return_type(self) -&gt;Any:</span>
<span class="gi">+    def return_type(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;The type of the value returned by the parse method, such as int, float or str.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._return_type</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_signed(self) -&gt;bool:</span>
<span class="gi">+    def is_signed(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;If True then the data type represents a signed quantity.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._is_signed</span>

<span class="w"> </span>    @property
<span class="gd">-    def set_fn(self) -&gt;Optional[Callable]:</span>
<span class="gi">+    def set_fn(self) -&gt; Optional[Callable]:</span>
<span class="w"> </span>        &quot;&quot;&quot;A function to set the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._set_fn</span>

<span class="w"> </span>    @property
<span class="gd">-    def get_fn(self) -&gt;Callable:</span>
<span class="gi">+    def get_fn(self) -&gt; Callable:</span>
<span class="w"> </span>        &quot;&quot;&quot;A function to get the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_fn</span>

<span class="w"> </span>    @property
<span class="gd">-    def read_fn(self) -&gt;Callable:</span>
<span class="gi">+    def read_fn(self) -&gt; Callable:</span>
<span class="w"> </span>        &quot;&quot;&quot;A function to read the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._read_fn</span>
<span class="gi">+</span>
<span class="gi">+    def _set_scale(self, value: Union[None, float, int]) -&gt; None:</span>
<span class="gi">+        self._scale = value</span>
<span class="gi">+        if self._scale is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._scale == 0:</span>
<span class="gi">+            raise ValueError(&quot;A Dtype&#39;s scale factor must not be zero.&quot;)</span>
<span class="gi">+        if not hasattr(self, &#39;unscaled_get_fn&#39;):</span>
<span class="gi">+            self.unscaled_get_fn = self._get_fn</span>
<span class="gi">+            self.unscaled_set_fn = self._set_fn</span>
<span class="gi">+            self.unscaled_read_fn = self._read_fn</span>
<span class="gi">+        self._get_fn = scaled_get_fn(self.unscaled_get_fn, self._scale)</span>
<span class="gi">+        self._set_fn = scaled_set_fn(self.unscaled_set_fn, self._scale)</span>
<span class="gi">+        self._read_fn = scaled_read_fn(self.unscaled_read_fn, self._scale)</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+    def _new_from_token(cls, token: str, scale: Union[None, float, int] = None) -&gt; Dtype:</span>
<span class="gi">+        token = &#39;&#39;.join(token.split())</span>
<span class="gi">+        return dtype_register.get_dtype(*utils.parse_name_length_token(token), scale=scale)</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self._name, self._length))

<span class="gd">-    def build(self, value: Any, /) -&gt;bitstring.Bits:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    @functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+    def _create(cls, definition: DtypeDefinition, length: Optional[int], scale: Union[None, float, int]) -&gt; Dtype:</span>
<span class="gi">+        x = super().__new__(cls)</span>
<span class="gi">+        x._name = definition.name</span>
<span class="gi">+        x._bitlength = x._length = length</span>
<span class="gi">+        x._bits_per_item = definition.multiplier</span>
<span class="gi">+        if x._bitlength is not None:</span>
<span class="gi">+            x._bitlength *= x._bits_per_item</span>
<span class="gi">+        x._set_fn_needs_length = definition.set_fn_needs_length</span>
<span class="gi">+        x._variable_length = definition.variable_length</span>
<span class="gi">+        if x._variable_length or dtype_register.names[x._name].allowed_lengths.only_one_value():</span>
<span class="gi">+            x._read_fn = definition.read_fn</span>
<span class="gi">+        else:</span>
<span class="gi">+            x._read_fn = functools.partial(definition.read_fn, length=x._bitlength)</span>
<span class="gi">+        if definition.set_fn is None:</span>
<span class="gi">+            x._set_fn = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if x._set_fn_needs_length:</span>
<span class="gi">+                x._set_fn = functools.partial(definition.set_fn, length=x._bitlength)</span>
<span class="gi">+            else:</span>
<span class="gi">+                x._set_fn = definition.set_fn</span>
<span class="gi">+        x._get_fn = definition.get_fn</span>
<span class="gi">+        x._return_type = definition.return_type</span>
<span class="gi">+        x._is_signed = definition.is_signed</span>
<span class="gi">+        x._set_scale(scale)</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    def build(self, value: Any, /) -&gt; bitstring.Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a bitstring from a value.

<span class="w"> </span>        The value parameter should be of a type appropriate to the dtype.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = bitstring.Bits()</span>
<span class="gi">+        self._set_fn(b, value)</span>
<span class="gi">+        if self.bitlength is not None and len(b) != self.bitlength:</span>
<span class="gi">+            raise ValueError(f&quot;Dtype has a length of {self.bitlength} bits, but value &#39;{value}&#39; has {len(b)} bits.&quot;)</span>
<span class="gi">+        return b</span>

<span class="gd">-    def parse(self, b: BitsType, /) -&gt;Any:</span>
<span class="gi">+    def parse(self, b: BitsType, /) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a bitstring to find its value.

<span class="w"> </span>        The b parameter should be a bitstring of the appropriate length, or an object that can be converted to a bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = bitstring.Bits._create_from_bitstype(b)</span>
<span class="gi">+        return self._get_fn(bitstring.Bits(b))</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self._scale is not None:
<span class="w"> </span>            return self.__repr__()
<span class="gd">-        hide_length = self._variable_length or dtype_register.names[self._name</span>
<span class="gd">-            ].allowed_lengths.only_one_value() or self._length is None</span>
<span class="gi">+        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None</span>
<span class="w"> </span>        length_str = &#39;&#39; if hide_length else str(self._length)
<span class="gd">-        return f&#39;{self._name}{length_str}&#39;</span>
<span class="gi">+        return f&quot;{self._name}{length_str}&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        hide_length = self._variable_length or dtype_register.names[self._name</span>
<span class="gd">-            ].allowed_lengths.only_one_value() or self._length is None</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None</span>
<span class="w"> </span>        length_str = &#39;&#39; if hide_length else &#39;, &#39; + str(self._length)
<span class="w"> </span>        if self._scale is None:
<span class="w"> </span>            scale_str = &#39;&#39;
<span class="w"> </span>        else:
<span class="w"> </span>            try:
<span class="gi">+                # This will only succeed for powers of two from -127 to 127.</span>
<span class="w"> </span>                e8m0 = bitstring.Bits(e8m0mxfp=self._scale)
<span class="w"> </span>            except ValueError:
<span class="w"> </span>                scale_str = f&#39;, scale={self._scale}&#39;
<span class="gu">@@ -137,105 +213,94 @@ class Dtype:</span>
<span class="w"> </span>                    scale_str = f&#39;, scale={self._scale}&#39;
<span class="w"> </span>                else:
<span class="w"> </span>                    scale_str = f&#39;, scale=2 ** {power_of_two}&#39;
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;{self.__class__.__name__}(&#39;{self._name}&#39;{length_str}{scale_str})&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}(&#39;{self._name}&#39;{length_str}{scale_str})&quot;</span>

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, Dtype):
<span class="w"> </span>            return self._name == other._name and self._length == other._length
<span class="w"> </span>        return False


<span class="w"> </span>class AllowedLengths:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, value: Tuple[int, ...]=tuple()) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: Tuple[int, ...] = tuple()) -&gt; None:</span>
<span class="w"> </span>        if len(value) &gt;= 3 and value[-1] is Ellipsis:
<span class="w"> </span>            step = value[1] - value[0]
<span class="w"> </span>            for i in range(1, len(value) - 1):
<span class="w"> </span>                if value[i] - value[i - 1] != step:
<span class="gd">-                    raise ValueError(</span>
<span class="gd">-                        f&#39;Allowed length tuples must be equally spaced when final element is Ellipsis, but got {value}.&#39;</span>
<span class="gd">-                        )</span>
<span class="gd">-            self.values = value[0], value[1], Ellipsis</span>
<span class="gi">+                    raise ValueError(f&quot;Allowed length tuples must be equally spaced when final element is Ellipsis, but got {value}.&quot;)</span>
<span class="gi">+            self.values = (value[0], value[1], Ellipsis)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.values = value

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self.values and self.values[-1] is Ellipsis:
<span class="gd">-            return f&#39;({self.values[0]}, {self.values[1]}, ...)&#39;</span>
<span class="gi">+            return f&quot;({self.values[0]}, {self.values[1]}, ...)&quot;</span>
<span class="w"> </span>        return str(self.values)

<span class="gd">-    def __contains__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        if not self.values:
<span class="w"> </span>            return True
<span class="w"> </span>        if self.values[-1] is Ellipsis:
<span class="gd">-            return (other - self.values[0]) % (self.values[1] - self.values[0]</span>
<span class="gd">-                ) == 0</span>
<span class="gi">+            return (other - self.values[0]) % (self.values[1] - self.values[0]) == 0</span>
<span class="w"> </span>        return other in self.values

<span class="gi">+    def only_one_value(self) -&gt; bool:</span>
<span class="gi">+        return self.values and len(self.values) == 1</span>
<span class="gi">+</span>

<span class="w"> </span>class DtypeDefinition:
<span class="w"> </span>    &quot;&quot;&quot;Represents a class of dtypes, such as uint or float, rather than a concrete dtype such as uint8.
<span class="w"> </span>    Not (yet) part of the public interface.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, set_fn, get_fn, return_type: Any=Any,</span>
<span class="gd">-        is_signed: bool=False, bitlength2chars_fn=None, variable_length:</span>
<span class="gd">-        bool=False, allowed_lengths: Tuple[int, ...]=tuple(), multiplier:</span>
<span class="gd">-        int=1, description: str=&#39;&#39;):</span>
<span class="gi">+    def __init__(self, name: str, set_fn, get_fn, return_type: Any = Any, is_signed: bool = False, bitlength2chars_fn=None,</span>
<span class="gi">+                 variable_length: bool = False, allowed_lengths: Tuple[int, ...] = tuple(), multiplier: int = 1, description: str = &#39;&#39;):</span>
<span class="gi">+</span>
<span class="gi">+        # Consistency checks</span>
<span class="w"> </span>        if int(multiplier) != multiplier or multiplier &lt;= 0:
<span class="gd">-            raise ValueError(&#39;multiplier must be an positive integer&#39;)</span>
<span class="gi">+            raise ValueError(&quot;multiplier must be an positive integer&quot;)</span>
<span class="w"> </span>        if variable_length and allowed_lengths:
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &quot;A variable length dtype can&#39;t have allowed lengths.&quot;)</span>
<span class="gd">-        if (variable_length and set_fn is not None and &#39;length&#39; in inspect.</span>
<span class="gd">-            signature(set_fn).parameters):</span>
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &quot;A variable length dtype can&#39;t have a set_fn which takes a length.&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise ValueError(&quot;A variable length dtype can&#39;t have allowed lengths.&quot;)</span>
<span class="gi">+        if variable_length and set_fn is not None and &#39;length&#39; in inspect.signature(set_fn).parameters:</span>
<span class="gi">+            raise ValueError(&quot;A variable length dtype can&#39;t have a set_fn which takes a length.&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.description = description
<span class="w"> </span>        self.return_type = return_type
<span class="w"> </span>        self.is_signed = is_signed
<span class="w"> </span>        self.variable_length = variable_length
<span class="w"> </span>        self.allowed_lengths = AllowedLengths(allowed_lengths)
<span class="gi">+</span>
<span class="w"> </span>        self.multiplier = multiplier
<span class="gd">-        self.set_fn_needs_length = (set_fn is not None and &#39;length&#39; in</span>
<span class="gd">-            inspect.signature(set_fn).parameters)</span>
<span class="gi">+</span>
<span class="gi">+        # Can work out if set_fn needs length based on its signature.</span>
<span class="gi">+        self.set_fn_needs_length = set_fn is not None and &#39;length&#39; in inspect.signature(set_fn).parameters</span>
<span class="w"> </span>        self.set_fn = set_fn
<span class="gd">-        if self.allowed_lengths.values:</span>

<span class="gi">+        if self.allowed_lengths.values:</span>
<span class="w"> </span>            def allowed_length_checked_get_fn(bs):
<span class="w"> </span>                if len(bs) not in self.allowed_lengths:
<span class="w"> </span>                    if self.allowed_lengths.only_one_value():
<span class="gd">-                        raise bitstring.InterpretError(</span>
<span class="gd">-                            f&quot;&#39;{self.name}&#39; dtypes must have a length of {self.allowed_lengths.values[0]}, but received a length of {len(bs)}.&quot;</span>
<span class="gd">-                            )</span>
<span class="gi">+                        raise bitstring.InterpretError(f&quot;&#39;{self.name}&#39; dtypes must have a length of {self.allowed_lengths.values[0]}, but received a length of {len(bs)}.&quot;)</span>
<span class="w"> </span>                    else:
<span class="gd">-                        raise bitstring.InterpretError(</span>
<span class="gd">-                            f&quot;&#39;{self.name}&#39; dtypes must have a length in {self.allowed_lengths}, but received a length of {len(bs)}.&quot;</span>
<span class="gd">-                            )</span>
<span class="gi">+                        raise bitstring.InterpretError(f&quot;&#39;{self.name}&#39; dtypes must have a length in {self.allowed_lengths}, but received a length of {len(bs)}.&quot;)</span>
<span class="w"> </span>                return get_fn(bs)
<span class="gd">-            self.get_fn = allowed_length_checked_get_fn</span>
<span class="gi">+            self.get_fn = allowed_length_checked_get_fn  # Interpret everything and check the length</span>
<span class="w"> </span>        else:
<span class="gd">-            self.get_fn = get_fn</span>
<span class="gi">+            self.get_fn = get_fn  # Interpret everything</span>
<span class="gi">+</span>
<span class="gi">+        # Create a reading function from the get_fn.</span>
<span class="w"> </span>        if not self.variable_length:
<span class="w"> </span>            if self.allowed_lengths.only_one_value():
<span class="gd">-</span>
<span class="w"> </span>                def read_fn(bs, start):
<span class="gd">-                    return self.get_fn(bs[start:start + self.</span>
<span class="gd">-                        allowed_lengths.values[0]])</span>
<span class="gi">+                    return self.get_fn(bs[start:start + self.allowed_lengths.values[0]])</span>
<span class="w"> </span>            else:
<span class="gd">-</span>
<span class="w"> </span>                def read_fn(bs, start, length):
<span class="w"> </span>                    if len(bs) &lt; start + length:
<span class="gd">-                        raise bitstring.ReadError(</span>
<span class="gd">-                            f&#39;Needed a length of at least {length} bits, but only {len(bs) - start} bits were available.&#39;</span>
<span class="gd">-                            )</span>
<span class="gi">+                        raise bitstring.ReadError(f&quot;Needed a length of at least {length} bits, but only {len(bs) - start} bits were available.&quot;)</span>
<span class="w"> </span>                    return self.get_fn(bs[start:start + length])
<span class="w"> </span>            self.read_fn = read_fn
<span class="w"> </span>        else:
<span class="gd">-</span>
<span class="gi">+            # We only find out the length when we read/get.</span>
<span class="w"> </span>            def length_checked_get_fn(bs):
<span class="w"> </span>                x, length = get_fn(bs)
<span class="w"> </span>                if length != len(bs):
<span class="gu">@@ -252,47 +317,87 @@ class DtypeDefinition:</span>
<span class="w"> </span>            self.read_fn = read_fn
<span class="w"> </span>        self.bitlength2chars_fn = bitlength2chars_fn

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        s = (</span>
<span class="gd">-            f&quot;{self.__class__.__name__}(name=&#39;{self.name}&#39;, description=&#39;{self.description}&#39;, return_type={self.return_type.__name__}, &quot;</span>
<span class="gd">-            )</span>
<span class="gd">-        s += (</span>
<span class="gd">-            f&#39;is_signed={self.is_signed}, set_fn_needs_length={self.set_fn_needs_length}, allowed_lengths={self.allowed_lengths!s}, multiplier={self.multiplier})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def get_dtype(self, length: Optional[int] = None, scale: Union[None, float, int] = None) -&gt; Dtype:</span>
<span class="gi">+        if self.allowed_lengths:</span>
<span class="gi">+            if length is None:</span>
<span class="gi">+                if self.allowed_lengths.only_one_value():</span>
<span class="gi">+                    length = self.allowed_lengths.values[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if length not in self.allowed_lengths:</span>
<span class="gi">+                    if self.allowed_lengths.only_one_value():</span>
<span class="gi">+                        raise ValueError(f&quot;A length of {length} was supplied for the &#39;{self.name}&#39; dtype, but its only allowed length is {self.allowed_lengths.values[0]}.&quot;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise ValueError(f&quot;A length of {length} was supplied for the &#39;{self.name}&#39; dtype which is not one of its possible lengths (must be one of {self.allowed_lengths}).&quot;)</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            d = Dtype._create(self, None, scale)</span>
<span class="gi">+            return d</span>
<span class="gi">+        if self.variable_length:</span>
<span class="gi">+            raise ValueError(f&quot;A length ({length}) shouldn&#39;t be supplied for the variable length dtype &#39;{self.name}&#39;.&quot;)</span>
<span class="gi">+        d = Dtype._create(self, length, scale)</span>
<span class="gi">+        return d</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        s = f&quot;{self.__class__.__name__}(name=&#39;{self.name}&#39;, description=&#39;{self.description}&#39;, return_type={self.return_type.__name__}, &quot;</span>
<span class="gi">+        s += f&quot;is_signed={self.is_signed}, set_fn_needs_length={self.set_fn_needs_length}, allowed_lengths={self.allowed_lengths!s}, multiplier={self.multiplier})&quot;</span>
<span class="w"> </span>        return s


<span class="w"> </span>class Register:
<span class="w"> </span>    &quot;&quot;&quot;A singleton class that holds all the DtypeDefinitions. Not (yet) part of the public interface.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _instance: Optional[Register] = None
<span class="w"> </span>    names: Dict[str, DtypeDefinition] = {}

<span class="gd">-    def __new__(cls) -&gt;Register:</span>
<span class="gi">+    def __new__(cls) -&gt; Register:</span>
<span class="gi">+        # Singleton. Only one Register instance can ever exist.</span>
<span class="w"> </span>        if cls._instance is None:
<span class="w"> </span>            cls._instance = super(Register, cls).__new__(cls)
<span class="w"> </span>        return cls._instance

<span class="w"> </span>    @classmethod
<span class="gd">-    def __getitem__(cls, name: str) -&gt;DtypeDefinition:</span>
<span class="gi">+    def add_dtype(cls, definition: DtypeDefinition):</span>
<span class="gi">+        cls.names[definition.name] = definition</span>
<span class="gi">+        if definition.get_fn is not None:</span>
<span class="gi">+            setattr(bitstring.bits.Bits, definition.name, property(fget=definition.get_fn, doc=f&quot;The bitstring as {definition.description}. Read only.&quot;))</span>
<span class="gi">+        if definition.set_fn is not None:</span>
<span class="gi">+            setattr(bitstring.bitarray_.BitArray, definition.name, property(fget=definition.get_fn, fset=definition.set_fn, doc=f&quot;The bitstring as {definition.description}. Read and write.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def add_dtype_alias(cls, name: str, alias: str):</span>
<span class="gi">+        cls.names[alias] = cls.names[name]</span>
<span class="gi">+        definition = cls.names[alias]</span>
<span class="gi">+        if definition.get_fn is not None:</span>
<span class="gi">+            setattr(bitstring.bits.Bits, alias, property(fget=definition.get_fn, doc=f&quot;An alias for &#39;{name}&#39;. Read only.&quot;))</span>
<span class="gi">+        if definition.set_fn is not None:</span>
<span class="gi">+            setattr(bitstring.bitarray_.BitArray, alias, property(fget=definition.get_fn, fset=definition.set_fn, doc=f&quot;An alias for &#39;{name}&#39;. Read and write.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def get_dtype(cls, name: str, length: Optional[int], scale: Union[None, float, int] = None) -&gt; Dtype:</span>
<span class="gi">+        try:</span>
<span class="gi">+            definition = cls.names[name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise ValueError(f&quot;Unknown Dtype name &#39;{name}&#39;. Names available: {list(cls.names.keys())}.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return definition.get_dtype(length, scale)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def __getitem__(cls, name: str) -&gt; DtypeDefinition:</span>
<span class="w"> </span>        return cls.names[name]

<span class="w"> </span>    @classmethod
<span class="gd">-    def __delitem__(cls, name: str) -&gt;None:</span>
<span class="gi">+    def __delitem__(cls, name: str) -&gt; None:</span>
<span class="w"> </span>        del cls.names[name]

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        s = [</span>
<span class="gd">-            f&quot;{&#39;key&#39;:&lt;12}:{&#39;name&#39;:^12}{&#39;signed&#39;:^8}{&#39;set_fn_needs_length&#39;:^23}{&#39;allowed_lengths&#39;:^16}{&#39;multiplier&#39;:^12}{&#39;return_type&#39;:&lt;13}&quot;</span>
<span class="gd">-            ]</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        s = [f&quot;{&#39;key&#39;:&lt;12}:{&#39;name&#39;:^12}{&#39;signed&#39;:^8}{&#39;set_fn_needs_length&#39;:^23}{&#39;allowed_lengths&#39;:^16}{&#39;multiplier&#39;:^12}{&#39;return_type&#39;:&lt;13}&quot;]</span>
<span class="w"> </span>        s.append(&#39;-&#39; * 85)
<span class="w"> </span>        for key in self.names:
<span class="w"> </span>            m = self.names[key]
<span class="w"> </span>            allowed = &#39;&#39; if not m.allowed_lengths else m.allowed_lengths
<span class="w"> </span>            ret = &#39;None&#39; if m.return_type is None else m.return_type.__name__
<span class="gd">-            s.append(</span>
<span class="gd">-                f&#39;{key:&lt;12}:{m.name:&gt;12}{m.is_signed:^8}{m.set_fn_needs_length:^16}{allowed!s:^16}{m.multiplier:^12}{ret:&lt;13} # {m.description}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            s.append(f&quot;{key:&lt;12}:{m.name:&gt;12}{m.is_signed:^8}{m.set_fn_needs_length:^16}{allowed!s:^16}{m.multiplier:^12}{ret:&lt;13} # {m.description}&quot;)</span>
<span class="w"> </span>        return &#39;\n&#39;.join(s)


<span class="gi">+# Create the Register singleton</span>
<span class="w"> </span>dtype_register = Register()
<span class="gh">diff --git a/bitstring/exceptions.py b/bitstring/exceptions.py</span>
<span class="gh">index 1cabe0f..374d393 100644</span>
<span class="gd">--- a/bitstring/exceptions.py</span>
<span class="gi">+++ b/bitstring/exceptions.py</span>
<span class="gu">@@ -1,7 +1,8 @@</span>
<span class="gi">+</span>
<span class="w"> </span>class Error(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Base class for errors in the bitstring module.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, *params: object) -&gt;None:</span>
<span class="gi">+    def __init__(self, *params: object) -&gt; None:</span>
<span class="w"> </span>        self.msg = params[0] if params else &#39;&#39;
<span class="w"> </span>        self.params = params[1:]

<span class="gh">diff --git a/bitstring/fp8.py b/bitstring/fp8.py</span>
<span class="gh">index 4cf9431..575dbbb 100644</span>
<span class="gd">--- a/bitstring/fp8.py</span>
<span class="gi">+++ b/bitstring/fp8.py</span>
<span class="gu">@@ -3,6 +3,7 @@ The 8-bit float formats used here are from a proposal supported by Graphcore, AM</span>
<span class="w"> </span>See https://arxiv.org/abs/2206.02915

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import struct
<span class="w"> </span>import zlib
<span class="w"> </span>import array
<span class="gu">@@ -17,20 +18,80 @@ class Binary8Format:</span>
<span class="w"> </span>    def __init__(self, exp_bits: int, bias: int):
<span class="w"> </span>        self.exp_bits = exp_bits
<span class="w"> </span>        self.bias = bias
<span class="gd">-        self.pos_clamp_value = 127</span>
<span class="gd">-        self.neg_clamp_value = 255</span>
<span class="gi">+        self.pos_clamp_value = 0b01111111</span>
<span class="gi">+        self.neg_clamp_value = 0b11111111</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return f&#39;Binary8Format(exp_bits={self.exp_bits}, bias={self.bias})&#39;</span>
<span class="gi">+        return f&quot;Binary8Format(exp_bits={self.exp_bits}, bias={self.bias})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def decompress_luts(self):</span>
<span class="gi">+        binary8_to_float_compressed, float16_to_binary8_compressed = binary8_luts_compressed[(self.exp_bits, self.bias)]</span>
<span class="gi">+        self.lut_float16_to_binary8 = zlib.decompress(float16_to_binary8_compressed)</span>
<span class="gi">+        dec = zlib.decompress(binary8_to_float_compressed)</span>
<span class="gi">+        self.lut_binary8_to_float = struct.unpack(f&#39;&lt;{len(dec) // 4}f&#39;, dec)</span>
<span class="gi">+</span>
<span class="gi">+    def create_luts(self):</span>
<span class="gi">+        self.lut_binary8_to_float = self.createLUT_for_binary8_to_float()</span>
<span class="gi">+        self.lut_float16_to_binary8 = self.createLUT_for_float16_to_binary8()</span>

<span class="gd">-    def float_to_int8(self, f: float) -&gt;int:</span>
<span class="gi">+    def float_to_int8(self, f: float) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a Python float convert to the best float8 (expressed as an integer in 0-255 range).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First convert the float to a float16, then a 16 bit uint</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = struct.pack(&#39;&gt;e&#39;, f)</span>
<span class="gi">+        except (OverflowError, struct.error):</span>
<span class="gi">+            # Return the largest representable positive or negative value</span>
<span class="gi">+            return self.pos_clamp_value if f &gt; 0 else self.neg_clamp_value</span>
<span class="gi">+        f16_int = int.from_bytes(b, byteorder=&#39;big&#39;)</span>
<span class="gi">+        # Then use this as an index to our large LUT</span>
<span class="gi">+        return self.lut_float16_to_binary8[f16_int]</span>
<span class="gi">+</span>
<span class="gi">+    def createLUT_for_float16_to_binary8(self) -&gt; bytes:</span>
<span class="gi">+        # Used to create the LUT that was compressed and stored for the fp8 code</span>
<span class="gi">+        import gfloat</span>
<span class="gi">+        fi = gfloat.formats.format_info_p3109(8 - self.exp_bits)</span>
<span class="gi">+        fp16_to_fp8 = bytearray(1 &lt;&lt; 16)</span>
<span class="gi">+        for i in range(1 &lt;&lt; 16):</span>
<span class="gi">+            b = struct.pack(&#39;&gt;H&#39;, i)</span>
<span class="gi">+            f, = struct.unpack(&#39;&gt;e&#39;, b)</span>
<span class="gi">+            fp = gfloat.round_float(fi, f)</span>
<span class="gi">+            if math.isnan(fp):</span>
<span class="gi">+                fp8_i = 0b10000000</span>
<span class="gi">+            else:</span>
<span class="gi">+                fp8_i = self.lut_binary8_to_float.index(fp)</span>
<span class="gi">+            fp16_to_fp8[i] = fp8_i</span>
<span class="gi">+        return bytes(fp16_to_fp8)</span>

<span class="w"> </span>    def createLUT_for_binary8_to_float(self):
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert an int in range 0-255 representing a float8 into a Python float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i2f = []</span>
<span class="gi">+        for i in range(256):</span>
<span class="gi">+            b = bitarray.util.int2ba(i, length=8, endian=&#39;big&#39;, signed=False)</span>
<span class="gi">+            sign = b[0]</span>
<span class="gi">+            exponent = bitarray.util.ba2int(b[1:1 + self.exp_bits])</span>
<span class="gi">+            significand = b[1 + self.exp_bits:]</span>
<span class="gi">+            if exponent == 0:</span>
<span class="gi">+                significand = bitarray.bitarray(&#39;0&#39;) + significand</span>
<span class="gi">+                exponent = -self.bias + 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                significand = bitarray.bitarray(&#39;1&#39;) + significand</span>
<span class="gi">+                exponent -= self.bias</span>
<span class="gi">+            f = float(bitarray.util.ba2int(significand)) / (2.0 ** (7 - self.exp_bits))</span>
<span class="gi">+            f *= 2 ** exponent</span>
<span class="gi">+            i2f.append(f if not sign else -f)</span>
<span class="gi">+        # One special case for minus zero</span>
<span class="gi">+        i2f[0b10000000] = float(&#39;nan&#39;)</span>
<span class="gi">+        # and for plus and minus infinity</span>
<span class="gi">+        i2f[0b01111111] = float(&#39;inf&#39;)</span>
<span class="gi">+        i2f[0b11111111] = float(&#39;-inf&#39;)</span>
<span class="gi">+        return array.array(&#39;f&#39;, i2f)</span>


<span class="gi">+# We create the 1.5.2 and 1.4.3 formats.</span>
<span class="w"> </span>p4binary_fmt = Binary8Format(exp_bits=4, bias=8)
<span class="w"> </span>p3binary_fmt = Binary8Format(exp_bits=5, bias=16)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decompress_luts():</span>
<span class="gi">+    p4binary_fmt.decompress_luts()</span>
<span class="gi">+    p3binary_fmt.decompress_luts()</span>
<span class="gh">diff --git a/bitstring/luts.py b/bitstring/luts.py</span>
<span class="gh">index 07452b3..f4ca298 100644</span>
<span class="gd">--- a/bitstring/luts.py</span>
<span class="gi">+++ b/bitstring/luts.py</span>
<span class="gu">@@ -1,38 +1,245 @@</span>
<span class="gd">-mxfp_luts_compressed = {(2, 1, 1, &#39;saturate&#39;): (</span>
<span class="gd">-    b&#39;x\x01\x1d\xc9\xc1\r\xc00\x00\xc2@o\xd6\x8c\xc6f\xf5h\xb1\x828\xf1\x00^&gt;X\x0c\xa7f1,\x7f\x13\x83\xfdY\xf4\x027\xf1\x0c\xfb&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&#39;x\x01\xed\xdd\t\r\xc00\x10\x03\xc1\xf4\xff[\xfehS\x1a\&#39;y\x96\x81\x87\x80[\x13\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02e\x05\x06\x11 @\x80@\xa2\xc0(\x02\xc9\x02\x93\x92\x05fe\x0b,J\x16X\x95-\xb0\x89\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x14\x14\xe8&quot;@ U`\x17\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02u\x05\x0e\x11 @\x80@\xa2\xc0)\x02\xc9\x02\x97\x92\x05ne\x0b&lt;J\x16x\x95-\xf0\x89\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x14\x14H=&gt;\xb7\x9b\x00\x81\xfe\x03\\M8\xf2&#39;</span>
<span class="gd">-    ), (2, 3, 1, &#39;saturate&#39;): (</span>
<span class="gd">-    b&#39;x\x01\x1d\xcdQ\r\xc30\x10\x03\xd0\x830\x08\x85P\x04[ \x14B \x0cB \x04B \x14\xc1v\x10\x02!\x10\x02aO\xb3\xf4\xe4?;\xe2\x9fgD#\x89W\xc4A\xa1\xd2\xe8\x0cn\x92\xc9b\x13%\xe2\xc1\xc1I\xe1\xa2\xf2\xa6\xd1\x19\xdc$\x93\xc5&amp;\x1a\x1fE\x12_[\x14*\x8d\xce\xe0&amp;\x99,6\x91\xfe98)\\T\xde4:\x83\x9bd\xb2\xd8\xf9\x03~S=\xdd&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&#39;x\x01\xed\xdd\x85qB\x01\x14DQ\x12\x88\x11#\xeeF\x84\xb8\xbb\xf6_\x15\xa9\x82\xd9\xf9\xf3\xce\xed`O\x03\xdbj\x89\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x81\xc6\x08\x8c\x89\x00\x01\x02\x04*\n\x8c\x8b@e\x81\xb6*\x0bt\x94\x15\x98\xa8\xddd\xf5\xa6j7\xdd\xf4f\xb2u\xd3\xcdf\x9bK7\x9fm!\xddb\xb6^\xba\xa5l\xcb\xe9V\xb2\xad\xa6[\xcb\xb6\x9en#\xdbf\xba\xadl\xdb\xe9v\xb2\xed\xa6\xdb\xcb\xb6\x9f\xee@\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10\x18\x91\xc0P\x04\x08T\x158\x14\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\xcd\x118\x12\x01\x02\x04\x08T\x14\xe8\x8b@e\x81cU\x168QV\xe0\xb4vg\xd5\x1b\xd4\xee\xbc\xe9]d\xbbLw\x95\xed:\xddM\xb6\xdbtw\xd9\xee\xd3=d{L\xf7\x94\xed9\xddK\xb6\xd7to\xd9\xde\xd3}d\xfbL\xf7\x95\xed;\xddO\xb6\xdft\x7f&quot;@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\xc0\x88\x04\xaa\x1e\x9f\xdbM\x80\xc0\xf0\x1f\x9f\x0cK\xfb&#39;</span>
<span class="gd">-    ), (3, 2, 3, &#39;saturate&#39;): (</span>
<span class="gd">-    b&#39;x\x01\x15\xcbA\x15BQ\x08\x05@\xa2XD\xc5&amp;/\nQ(\xa2\xf2\x9b\x10\xc5\x91\xc3\xc0\xe2B\xc4\xbf\xean&lt;&quot;\x92\xa2\x19\x96xF\xdcH\x0eE3,\x91r\x92C\xd1\x0cK\xbc\xe4$\x87\xa2\x19\x96(\xfd\xb6?n(\x9aa\x89\xaf\x7f\x92C\xd1\x0cK\x8c\x9c\xe4P4\xc3\x12\x97\x9c\xe4P4\xc3^?\xc7\x8a;c&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&#39;x\x01\xed\xdd\xd7U\x15\x00\x00\x04Q$\x89HV@r\x90 Q\xb2\x92\xfb\xaf\xea\xd1\x02\x7f\x1c\xce\xdc\xe9`o\x03;4$\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\xe0\xd3\t|\x11\x01\x02\x04\x08\x14\x05\x86E\xa0,0\xa2\xb2\xc0\xa8&gt;V`\xac\xddx\xbd\xaf\xed&amp;\xea}k7Y\xef{\xbb\xa9z\xd3\xedf\xea\xcd\xb6\x9b\xab7\xdfn\xa1\xde\x8fv?\xeb-\xb6[\xaa\xb7\xdc\xeeW\xbd\x95v\xab\xf5\xd6\xda\xad\xd7\xdbh\xb7YoK\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 \xf0.\x81\x81\x08\x10\xa8\nl\x8b\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10\xf8|\x02;&quot;@\x80\x00\x81\xa2\xc0\xae\x08\x94\x05~\xab,\xb0\xa7\x8f\x15\xd8owP\xef\xb0\xdd\x9fzG\xed\x8e\xeb\x9d\xb4;\xadw\xd6\xee\xbc\xde\xdfv\x17\xf5.\xdb]\xd5\xbbnwS\xef\xb6\xdd]\xbd\x7f\xed\xfe\xd7\xbbo\xf7P\xef\xb1\xddS\xbd\xe7v/\xf5^E\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\xef\x12\xa8\x1e\x9f\xdbM\x80\xc0\xe0\r\xd9\xf2;{&#39;</span>
<span class="gd">-    ), (4, 3, 7, &#39;saturate&#39;): (</span>
<span class="gd">-    b&#39;x\x01\x1d\xcd[\xb5\x90!\x10\x80Q&quot;\x18\x81\x08\xbc{C-@\x04&quot;\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj\x01&quot;\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&amp;|s\x8bL\xa53\x98,6\x87\xcbC\xf8\xee\x7f&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6\x87\xcbC\xf8\xa9\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcbC\xf8\xa5\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH&quot;S\xa84:\x83\xc9bs\xb8&lt;\x84?z&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&#39;x\x01\xed\xdd\xd5\x96\x90\x05\x00E\xe1\x01\xe9\x90n\x90\x96F\xbaE\xa4S@\xba\x15\xa4\xbbKX H*\xdd)\xa9\x12Jw*H\x08Jww\x87\xd25\\\xccC\xec5\xf3\xef\xef\r\xce~\x81\x13\x12&quot;\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX \xc2\x16\x88$\x0bX\xc0\x02\x16\x08b\x81\xc8\xb2@\x90\x0b|\xa0 \x17\x88&quot;\xb6@\xd4`\x8b\x16t\xd1\x83-Fx\x17\x93\x15\x8b\x16\x9b\x15\x87\x16\x97\xf5!-\x1e+&gt;-\x01+!-\x11+1-\t+)-\x19+9-\x05+%-\x15+5-\r\xeb#ZZV:ZzV\x06ZFV&amp;Zf\xd6\xc7\xb4,\xac\xac\xb4l\xac\xec\xb4\x1c\xac\x9c\xb4\\\xac\xdc\xb4OXyhyY\xf9h\xf9Y\x05h\x05Y\x85h\x85YEhEY\xc5h\xc5Y%h\x9f\xb2J\xd2&gt;c\x95\xa2}\xce*M+\xc3*K+\xc7*O\xab\xc0\xaaH\xab\xc4\xaaL\xab\xc2\xaaJ\xab\xc6\xfa\x82V\x9dU\x83V\x93\xf5%\xad\x16\xab6\xad\x0e\xab.\xad\x1e\xab&gt;\xad\x01\xab!\xad\x11\xab1\xad\t\xab)\xad\x19\xeb+\xda\xd7\xac\xe6\xb4\x16\xacoh-Y\xadh\xadYmhmY\xedh\xedY\x1dh\x1dY\x9dh\x9dY]h]Y\xddh\xddY=h=Y\xbdh\xbdY}h}Y\xfdh\xfdY\xdf\xd2\x06\xb0\x06\xca\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05\xc2\n\x84\xca\x02\x16\x08j\x81A\xb2\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05&quot;n\x81\xc1\xb2\x80\x05,`\x81 \x16\xf8N\x16\x08r\x81!\nr\x81\xa1b\x0b|\x1fl\xc3\x82nx\xb0\x8d\x08\xefF\xb2F\xd1F\xb3~\xa0\xfd\xc8\x1aC\x1b\xcb\x1aG\x1b\xcf\x9a@\x9b\xc8\x9aD\x9b\xcc\x9aB\x9b\xca\x9aF\x9b\xce\x9aA\x9b\xc9\x9aE\x9b\xcd\x9aC\x9b\xcb\xfa\x896\x8f5\x9f\xb6\x80\xb5\x90\xb6\x88\xb5\x98\xf63\xeb\x17\xda\xaf\xac%\xb4\xa5\xace\xb4\xe5\xac\xdfh\xbf\xb3V\xd0V\xb2V\xd1V\xb3\xd6\xd0\xd6\xb2\xd6\xd1\xd6\xb36\xd06\xb26\xd16\xb3\xb6\xd0\xb6\xb2\xb6\xd1\xb6\xb3v\xd0v\xb2\xfe\xa0\xfd\xc9\xdaE\xdb\xcd\xfa\x8b\xb6\x87\xb5\x97\xb6\x8f\xb5\x9f\xf67\xeb\x00\xed \xeb\x1f\xda\xbf\xacC\xb4\xc3\xac#\xb4\xa3\xacc\xb4\xe3\xac\x13\xb4\x93\xacS\xb4\xd3\xac3\xb4\xb3\xacs\xb4\xf3\xac\x0b\xb4\x8b\xacK\xb4\xcb\xac+\xb4\xab\xack\xb4\xeb\xac\x1b\xb4\x9b\xac[\xb4\xdb\xac;\xb4\xbb\xac{\xb4\xfb\xac\x07\xb4\x87\xacG\xb4\xc7\xac\xffh\xff\xb3\x9e\xd0\x9e\xb2\x9e\xd1\x9e\xb3^\xd0^\xb2^\xd1^\xb3\xde\xd0\xde\xb2\xde\xc9\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05\xc2\n\x04\xf5\xf8\xdc\xdd\x16\xb0@\xe8{\t?\xc8\x90&#39;</span>
<span class="gd">-    ), (5, 2, 15, &#39;saturate&#39;): (</span>
<span class="gd">-    b&quot;x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88&#39;:I\xd1\x0c\xcb\x11?\xeb$E3,G&lt;\xd5I\x8afX\x8ex\xa6\x93\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G&lt;\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c\xcb\x11\xefu\x92\xa2\x19\x96#&gt;\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y&#39;)\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K&#39;)\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f\xd2\x15\xf0\xcf&quot;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&quot;x\x01\xed\xddC\xa2\x1c\x00\x00D\xc1\xd8\xb6m\xdb\xb6m\xdb66\xb1m\xdb\xb6m\xdb\xb6m,\x92c\xfcEM\xdd\xa0\xdf\x05:X\xb0 \x16\xdc\x16B\x17\xd2\x16J\x17\xda\x16F\x17\xd6\x16N\x17\xde\x16A\x17\xd1\x16I\x17\xd9\x16E\x17\xd5\x16M\x17\xdd\x16C\x17\xd3\x16K\x17\xdb\x16G\x17\xd7\x16O\x17\xdf\x96@\x97\xd0\x96H\x97\xd8\x96D\x97\xd4\x96L\x97\xdc\x96B\x97\xd2\x96J\x97\xda\x96F\x97\xd6\x96N\x97\xde\x96A\x97\xd1\x96I\x97\xd9\x96E\x97\xd5\x96M\x97\xdd\x96C\x97\xd3\x96K\x97\xdb\x96G\x97\xd7\x96O\x97\xdfV@W\xd0VHW\xd8VDW\xd4VLW\xdcVBW\xd2VJW\xdaVFW\xd6VNW\xdeVAW\xd1VIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW\xdf\xd6@\xd7\xd0\xd6H\xd7\xd8\xd6D\xd7\xd4\xd6L\xd7\xdc\xd6B\xd7\xd2\xd6J\xd7\xda\xd6F\xd7\xd6\xd6N\xd7\xde\xd6A\xd7\xd1\xd6I\xd7\xd9\xd6E\xd7\xd5\xd6M\xd7\xdd\xd6C\xd7\xd3\xd6K\xd7\xdb\xd6G\xd7\xd7\xd6O\xd7\xdf6@70 H\x0b\xfc\x0b\x08\x14\x08\x14P\x0b\x0c\nj\x83mCtCm\xc3t\xc3m#t#m\xa3t\xa3mctcm\xe3t\xe3m\x13t\x13m\x93t\x93mStSm\xd3t\xd3m3t3m\xb3t\xb3mstsm\xf3t\xf3m\x0bt\x0bm\x8bt\x8bmKtKm\xcbt\xcbm+t+m\xabt\xabmktkm\xebt\xebm\x1bt\x1bm\x9bt\x9bm[t[m\xdbt\xdbm;t;m\xbbt\xbbm{t{m\xfbt\xfbm\x07t\x07m\x87t\x87mGtGm\xc7t\xc7m&#39;t&#39;m\xa7t\xa7mgtgm\xe7t\xe7m\x17t\x17m\x97t\x97mWtWm\xd7t\xd7m7t7m\xb7t\xb7mwtwm\xf7t\xf7m\x0ft\x0fm\x8ft\x8fmOtOm\xcft\xcfm/t/m\xaft\xafmotom\xeft\xefm\x1ft\x1fm\x9ft\x9fm_t_m\xdft\xdfm?t?m\xbft\xbfm\x7ft\x7f\x03\x82\xb4\x80z|\x1e\xd8\x1d(\x10(\xf0\xef?\xe6\xfc\r\x9b&quot;</span>
<span class="gd">-    ), (4, 3, 7, &#39;overflow&#39;): (</span>
<span class="gd">-    b&#39;x\x01\x1d\xcd[\xb5\x90!\x10\x80Q&quot;\x18\x81\x08\xbc{C-@\x04&quot;\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj\x01&quot;\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&amp;|s\x8bL\xa53\x98,6\x87\xcbC\xf8\xee\x7f&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6\x87\xcbC\xf8\xa9\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcbC\xf8\xa5\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH&quot;S\xa84:\x83\xc9bs\xb8&lt;\x84?z&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&quot;x\x01\xed\xdc\x05\xb2\x90\x05\x00E\xe1\x87\x80\xa4t\x83tw\x97Jw\x0bHKw\x83\x80\x92Cww7\x92\xd2\x1dRJww\x97\xa4\x92J\xba\x8c3\x8f\xff|\x1b\xb83g\x017$D\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\xc0g[ \x8c,`\x01\x0bX \x88\x05\xbe\x90\x05\x82\\ \xac\x82\\ \x9c\xd8\x02\xe1\x83\xed\xcb\xa0\x8b\x10l\x11C\xbbH\xac\xc8\xb4(\xac\xa8\xb4\xafX\xd1h\xd1Y1h1Y\xb1h\xb1YqhqY\xf1h\xf1Y\th\tY\x89h\x89YIh_\xb3\x92\xd2\x92\xb1\x92\xd3R\xb0R\xd2R\xb1R\xd3\xd2\xb0\xd2\xd2\xd2\xb1\xd2\xd32\xb02\xd22\xb12\xd3\xb2\xb0\xb2\xd2\xb2\xb1\xb2\xd3r\xb0r\xd2r\xb1r\xd3\xf2\xb0\xf2\xd2\xf2\xb1\xf2\xd3\n\xb0\n\xd2\xbea}K\xfb\x8eU\x88V\x98U\x84V\x94U\x8cV\x9cU\x82V\x92U\x8aV\x9aU\x86V\x96U\x8eV\x9eU\x81V\x91U\x89V\x99U\x85\xf6=\xab*\xad\x1a\xab:\xed\x07V\rZMV-ZmV\x1dZ]V=\xda\x8f\xac\xfa\xb4\x06\xac\x86\xb4F\xac\xc6\xb4&amp;\xac\xa6\xb4f\xac\xe6\xb4\x16\xac\x96\xb4V\xac\xd6\xb46\xac\xb6\xb4v\xac\xf6\xb4\x0e\xac\x8e\xb4N\xac\xce\xb4\x9fX]h]Y\xddh?\xb3~\xa1ug\xf5\xa0\xf5d\xf5\xa2\xf5f\xf5\xa1}\x92\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16`\x0b\xf4\x95\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,\xf0\xf9\x16\xe8&#39;\x0bX\xc0\x02\x16\x08b\x81\xfe\xb2@\x90\x0b\x0cP\x90\x0b\x0c\x14[`P\xb0\r\x0e\xba!\xc164\xb4\x1b\xc6\x1aN\x1b\xc1\x1aI\x1b\xc5\x1aM\x1b\xc3\x1aK\x1b\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b\xc3\x9aK\x9b\xc7\x9aO[\xc0ZH[\xc4\xfa\x95\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6\x9c\xb5\x82\xf6\x1bk%m\x15k5m\rk-m\x1dk=m\x03k#m\x13k3m\x0bk+m\x1bk;m\x07\xebw\xdaN\xd6.\xdan\xd6\x1e\xda^\xd6\x1f\xb4?Y\xfbh\xfbY\x07h\x07Y\x87h\x87YGhGY\xc7h\xc7Y&#39;h&#39;Y\xa7h\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x97h\x97YWhWY\xd7h\xd7Y7h7Y\xb7h\xb7YwhwY\xf7h\xf7Y\x0fh\x7f\xb1\x1e\xd2\x1e\xb1\x1e\xd3\x9e\xb0\x9e\xd2\x9e\xb1\xfe\xa6\xfd\xc3zN{\xc1zI{\xc5zM{\xc3\xfa\x97\xf6\x1f\xeb-\xed\x1d\xeb=\xed\x03\xeb#\x8d\xbd\xefw\xdd\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b|\xfa\x1f\xb2\xf6b\xf1&quot;</span>
<span class="gd">-    ), (5, 2, 15, &#39;overflow&#39;): (</span>
<span class="gd">-    b&quot;x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88&#39;:I\xd1\x0c\xcb\x11?\xeb$E3,G&lt;\xd5I\x8afX\x8ex\xa6\x93\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G&lt;\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c\xcb\x11\xefu\x92\xa2\x19\x96#&gt;\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y&#39;)\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K&#39;)\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f\xd2\x15\xf0\xcf&quot;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&quot;x\x01\xed\xddS\xb6\x1e\x06\x00\x85\xd1\x1b\xdb\xb6\x1b\xdb\xb6\x9b\x06\x8dm\xdbz\x88m\xabI\x1b\xa3\xb1m\xdb\xb6mg\xad\x9ba\xdc\x87\xfd\xef\x19\x9co\x02&#39;((\x84\x85\xb2\x85\xd6\x85\xb1\x85\xd5\x85\xb3\x85\xd7E\xb0E\xd4E\xb2E\xd6E\xb1E\xd5E\xb3E\xd7\xc5\xb0\xc5\xd4\xc5\xb2\xc5\xd6\xc5\xb1\xc5\xd5\xc5\xb3\xc5\xd7%\xb0%\xd4%\xb2%\xd6%\xb1%\xd5%\xb3%\xd7\xa5\xb0\xa5\xd4\xa5\xb2\xa5\xd6\xa5\xb1\xa5\xd5\xa5\xb3\xfd\xa1Ko\xcb\xa0\xcbh\xcb\xa4\xcbl\xcb\xa2\xcbj\xcb\xa6\xcbn\xcb\xa1\xcbi\xcb\xa5\xcbm\xcb\xa3\xcbk\xcb\xa7\xcbo+\xa0+h+\xa4+l+\xa2+j+\xa6+n+\xa1+i+\xa5+m+\xa3+k+\xa7+o\xab\xa0\xabh\xab\xa4\xabl\xfbSW\xc5\xf6\x97\xae\xaa\xad\x9a\xae\xba\xad\x86\xeeo[M]-[m]\x1d[]]=[}]\x03[C]#[c]\x13[S]3[s]\x0b[K]+[k]\x1b[[];[{]\x07[G]&#39;[g]\x17[W]7[w]\x0f[O]/[o]\x1f[_]?[\x7f\xdd\x00\xdb\xc0\x90\x16\x1c\x10(\x10(\xa0\x16\x18\x14\xd2\x06\xdb\x86\xe8\x86\xda\x86\xe9\x86\xdbF\xe8F\xdaF\xe9F\xdb\xc6\xe8\xc6\xda\xc6\xe9\xc6\xdb&amp;\xe8&amp;\xda&amp;\xe9&amp;\xdb\xa6\xe8\xa6\xda\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9\xfe\xb1\xcd\xd7-\xb0\xfd\xab\xfb\xcf\xb6P\xb7\xc8\xb6X\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xb7\xca\xf6\xbfn\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7m\x97n\xb7m\x8fn\xafm\x9fn\xbf\xed\x80\xee\xa0\xed\x90\xee\xb0\xed\x88\xee\xa8\xed\x98\xee\xb8\xed\x84\xee\xa4\xed\x94\xee\xb4\xed\x8c\xee\xac\xed\x9c\xee\xbc\xed\x82\xee\xa2\xed\x92\xee\xb2\xed\x8a\xee\xaa\xed\x9a\xee\xba\xed\x86\xee\xa6\xed\x96\xee\xb6\xed\x8e\xee\xae\xed\x9e\xee\xbe\xed\x81\xee\xa1\xed\x91\xee\xb1\xed\x89\xee\xa9\xed\x99\xee\xb9\xed\x85\xee\xa5\xed\x95\xee\xb5\xed\x8d\xee\xad\xed\x9d\xee\xbd\xed\x83\xee\xa3\xed\x93\xee\xb3\xed\x8b\xee\xab\xed\x9b\xee\xbb\xed\x87\xee\xa7\xedWHS\x8f\xcf\x03\xbb\x03\x05\x02\x05\x82\x7f\x03\xb3\x87\x0e\x9d&quot;</span>
<span class="gd">-    )}</span>
<span class="gd">-binary8_luts_compressed = {(4, 8): (</span>
<span class="gd">-    b&#39;x\x01\x15\xcb[\xd5P!\x10\x80Q&quot;\x18\x81\x08&lt;{E-@\x04&quot;\xd0@&quot;\x10\x81\x08&lt;{E\xff\x02\&#39;\x02\x11h\xa0\xdbYk\xcf\xcb\xcc\x17\xc2\xff\xe9\xaf\xad7!d:\x93\xcd!\xbc\r\xe1\x15\x91D\xa6Pit\x06\x93\xc5\xe6\xe1p\t\xef\xf4D\x12\x99B\xa5\xd1\x19L\x16\x9b\x87\xc3%\xbc\xd7\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0AO$\x91)T\x1a\x9d\xc1d\xb1y8\\B\xd6\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0QO$\x91)T\x1a\x9d\xc1d\xb1y8\\\xc2\&#39;=\x91D\xa6Pit\x06\x93\xc5\xe6\xe1p\t\x9f\xf5D\x12\x99B\xa5\x7f\xf1O\xff\xea\xef\x9b\x1b\x9d\xc9\xe6\x10\xbe\xeb\x89$2\x85J\xa33\x98,6\x0f\x87K\xf8\xa1\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8&lt;\x1c.\xe1\xa7\x9eH&quot;S\xa84:\x83\xc9b\xf3p\xb8\x84_z&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xc3\xe1\x12\xb6\x9eH&quot;S\xa84:\x83\xc9b\xf3p\xb8\x84\xdfz&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xc3\xe1\x12\xfe\xe8\x89$2\x85J\xa33\x98,6\x0f\x87Kx\xd1\x13Id\n\x95\xfe\xf7\x1f[)\xf3`&#39;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&quot;x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xe0\xbd/\x10A\x16\xb0\x80\x05,\x10\xc4\x02\x11e\x81 \x17\x88\xa4 \x17\x88,\xb6@\x94`\x8b\x1at\xd1\x82-zx\x17\x83\x15\x93\x16\x8b\x15\x9b\x16\x87\x15\x97\x16\x8f\x15\x9f\x96\x80\x95\x90\x96\x88\x95\x98\x96\x84\xf5\x01-)+\x19-9+\x05-%+\x15-5+\r--+\x1d-=+\x03-#+\x13\xedCVfZ\x16VVZ6VvZ\x0eVN\xdaG\xac\x8fi\xb9X\xb9i\x9f\xb0\xf2\xd0&gt;e\xe5\xa5\xe5c\xe5\xa7\x15`\x15\xa4\x15b\x15\xa6\x15a\x15\xa5\x15c\x15\xa7\x95`\x95\xa4\x95b\x95\xa6\x95a\x95\xa5\x95c\x95\xa7U`U\xa4UbU\xa6UaU\xa5UcU\xa7\xd5`\xd5\xa4\xd5b\xd5\xa6\xd5a\xd5\xa5\xd5c\xd5\xa75`5\xa45b5\xa65a}Fk\xcajFk\xcejAk\xc9jEk\xcdjCk\xcbjGk\xcf\xea@\xfb\x9c\xd5\x91\xd6\x89\xd5\x99\xd6\x85\xf5\x05\xad+\xab\x1b\xad;\xab\x07\xad&#39;\xab\x17\xad7\xab\x0f\xad/\xab\x1f\xad?k\x00m k\x10m0k\x08m\xa8,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x00\\ L\x16\xb0@P\x0b\xbc\xf7\xff\x86\x0e\xb4\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX \x14\x1a&amp;\x0bX\xc0\x02\x16\x08b\x81\xe1\xb2@\x90\x0b\x8cP\x90\x0b\x8c\x14[`T\xb0\x8d\x0e\xba1\xc166\xbc\x1b\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b\xc3\x9aK\x9b\xc7\x9aO\xfb\x92\xb5\x80\xb6\x90\xb5\x88\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6\x9c\xb5\x82\xb6\x92\xb5\x8a\xb6\x9a\xb5\x86\xb6\x96\xb5\x8e\xb6\x9e\xb5\x81\xf6\x15\xebk\xdaF\xd6&amp;\xdaf\xd6\x16\xdaV\xd66\xda7\xacoi\xdbY;h;Y\xbbh\xdf\xb1\xbe\xa7\xedf\xed\xa1\xede\xed\xa3\xfd\xc0\xfa\x91\xb6\x9fu\x80v\x90u\x88v\x98u\x84v\x94u\x8c\xf6\x13\xeb8\xedg\xd6/\xb4\x13\xac\x93\xb4S\xac\xd3\xb4_Y\xbf\xd1\xce\xb0\xce\xd2\xce\xb1\xce\xd3.\xb0.\xd2~g\xfdA\xbb\xc4\xfa\x93v\x99u\x85v\x95u\x8dv\x9du\x83\xf6\x17\xebo\xdaM\xd6-\xda?\xac\x7fi\xb7YwhwY\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xff\xb1^\xd3\xde\xb0\xde\xd2\xde\xc9\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b\xc0\x05\x82z|\xeen\x0bX \xec\x7f\xc6\xe4\x02%&quot;</span>
<span class="gd">-    ), (5, 16): (</span>
<span class="gd">-    b&quot;x\x01\x1d\xc9\x89\r\x10\x04\x0c\x86\xd1\x8e\xc2\x16 \x97\x059\xd6\xe8&amp;t\x94n\xa1\\RQ`\x8dn\x02/6yI\xf3\x7f\x11\xff\xdf\xc3\x88f\x89G\x11\x0fH\x8afX\x8e\xf8M&#39;)\x9aa9\xe2\xb1NR4\xc3r\xc4\x13\x9d\xa4h\x86\xe5\x88\xa7:I\xd1\x0c\xcb\x11\xcft\x92\xa2\x19\x96#\x9e\xeb$E3,G\xfc\xae\x93\x14\xcd\xb0\x1c\x91:I\xd1\x0c\xcb\x11/t\x92\xa2\x19\x96#^\xea$E3,G\xfc\xa1\x93\x14\xcd\xb0\x1c\xf1J&#39;)\x9aa9\xe2\xb5NR4\xc3r\xc4\x1b\x9d\xa4h\x86\xe5\x88\xb7:I\xbf\xb3\x13\x7f\xfaY\xe2/\x9d\xa4h\x86\xe5\x88\xf7:I\xd1\x0c\xcb\x11\x1ft\x92\xa2\x19\x96#&gt;\xea$E3,G|\xd2I\x8afX\x8e\xf8\xac\x93\x14\xcd\xb0\x1c\xf1\xb7NR4\xc3r\xc4\x17\x9d\xa4h\x86\xe5\x88\xd5I\x8afX\x8e\xf8G&#39;)\x9aa9\xe2\xabNR4\xc3r\xc4\xbf:I\xd1\x0c\xcb\x11\xff\xe9$E3,G|\xd3I\x8afX\x8e\xf8\xae\x93\x14\xcd\xb0\x1c\xf1C&#39;\xe9\x9f\xbf\x00Gi\xed\x02&quot;</span>
<span class="gd">-    ,</span>
<span class="gd">-    b&#39;x\x01\xed\xddU\xd6\x96\x05\x00\x85\xd1\x9f\x16\xa4\x14\x04\xe9P\xa4K\x1a\xe9\x14\x10\t\xe9\x0eQ\xba\xc1\xa0\xbb\xbb\xa5\x1b)%\xa5;%\xa5\xbb;%\x94\x8eAp\xf1.\xd6\xfe\xf6\x0c\xce3\x81\x13\x16\xf6\x8e\xc2\x05+|\xd0&quot;\x04+b\xd0&quot;\x05+r\xd0\xa2\x04\xeb\x83\xf7]T[4\xdd\x87\xb6\xe8\xba\x18\xb6\x98\xbaX\xb6\xd8\xba\x8fl\x1f\xeb\xe2\xd8\xe2\xea&gt;\xb1\xc5\xd3\xc5\xb7}\xaaK`K\xa8KdK\xacKbK\xaaKfK\xaeKaK\xa9\xfb\xcc\xf6\xb9.\x95\xed\x0b]j[\x1a]Z[:]z[\x06]F[&amp;]f[\x16]V\xdb\x97\xbal\xb6\xec\xba\x1c\xb6\x9c\xba\\\xb6\xdc\xba&lt;\xb6\xbc\xba\xafl\xf9t\xf9m\x05t\x05m\x85t\x85mEtEm\xc5t\xc5m%t%m_\xebJ\xd9J\xeb\xca\xd8\xbe\xd1\x95\xb5}\xab+g+\xaf\xab`\xab\xa8\xfb\xceVIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW\xdf\xd6@\xd7\xd0\xf6\xbd\xae\x91\xed\x07\xdd\x8f\xb6\xc6\xba&amp;\xb6\xa6\xbaf\xb6\xe6\xba\x16\xb6\x96\xbaV\xb6\xd6\xba6\xb6\xb6\xbav\xb6\xf6\xba\x0e\xb6\x8e\xba\x9fl?\xeb~\xb1\xfd\xaa\xebd\xeb\xac\xebb\xeb\xaa\xeb\x16\x12h\x81\xee!\xa1\x02\xa1\x02j\x81\xb0w\xd5#X=\x83\xd6+X\xbd\x83\xd6\&#39;X}\x83\xd6/X\xfd\xdfw\x03l\x03u\x83l\x83uClCu\xc3l\xc3u#l#u\xa3l\xa3uclcu\xe3l\xe3u\x13l\xbf\xe9&amp;\xda&amp;\xe9&amp;\xdb\xa6\xe8\xa6\xda\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9~\xb7\xcd\xd7-\xb0-\xd4-\xb2-\xd6\xfda\xfbS\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xf7\x97m\x95n\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7m\x97n\xb7\xedo\xdd\x1e\xdb^\xdd&gt;\xdb~\xdd\x01\xdbA\xdd?\xb6C\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{\xba\xfb\xb6\x7fu\x0fl\x0fu\x8fl\x8fu\xff\xd9\xfe\xd7=\xb1=\xd5=\xb3=\xd7\xbd\xb0\xbd\xd4\xbd\xb2\xbd\xd6\xbd\t\t\xb4\x80z|\x1e\xda\x1d*\x10*\xd0\xfd-\x8c\x93\xc6\x0e&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+#</span>
<span class="gi">+# This file is generated by generate_luts.py. DO NOT EDIT.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+mxfp_luts_compressed = \</span>
<span class="gi">+{(2, 1, 1, &#39;saturate&#39;): (b&#39;x\x01\x1d\xc9\xc1\r\xc00\x00\xc2@o\xd6\x8c\xc6f\xf5h\xb1\x828\xf1\x00^&gt;X\x0c\xa7f1,\x7f&#39;</span>
<span class="gi">+                         b&#39;\x13\x83\xfdY\xf4\x027\xf1\x0c\xfb&#39;,</span>
<span class="gi">+                         b&quot;x\x01\xed\xdd\t\r\xc00\x10\x03\xc1\xf4\xff[\xfehS\x1a&#39;y\x96\x81\x87\x80[\x13\x01\x02&quot;</span>
<span class="gi">+                         b&#39;\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80&#39;</span>
<span class="gi">+                         b&#39;\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10&#39;</span>
<span class="gi">+                         b&#39; @\x80\x00\x01\x02e\x05\x06\x11 @\x80@\xa2\xc0(\x02\xc9\x02\x93\x92\x05fe\x0b,J\x16X\x95-&#39;</span>
<span class="gi">+                         b&#39;\xb0\x89\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04&#39;</span>
<span class="gi">+                         b&#39;\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00&#39;</span>
<span class="gi">+                         b&#39;\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x14\x14\xe8&quot;@ U`\x17\x01\x02\x04\x08\x10 &#39;</span>
<span class="gi">+                         b&#39;@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @&#39;</span>
<span class="gi">+                         b&#39;\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02u\x05\x0e\x11 @&#39;</span>
<span class="gi">+                         b&#39;\x80@\xa2\xc0)\x02\xc9\x02\x97\x92\x05ne\x0b&lt;J\x16x\x95-\xf0\x89\x00\x01\x02\x04\x08\x10&#39;</span>
<span class="gi">+                         b&#39; @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 &#39;</span>
<span class="gi">+                         b&#39;@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04&#39;</span>
<span class="gi">+                         b&#39;\x08\x14\x14H=&gt;\xb7\x9b\x00\x81\xfe\x03\\M8\xf2&#39;),</span>
<span class="gi">+ (2, 3, 1, &#39;saturate&#39;): (b&#39;x\x01\x1d\xcdQ\r\xc30\x10\x03\xd0\x830\x08\x85P\x04[ \x14B \x0cB \x04B \x14\xc1v\x10&#39;</span>
<span class="gi">+                         b&#39;\x02!\x10\x02aO\xb3\xf4\xe4?;\xe2\x9fgD#\x89W\xc4A\xa1\xd2\xe8\x0cn\x92\xc9b\x13%\xe2\xc1&#39;</span>
<span class="gi">+                         b&#39;\xc1I\xe1\xa2\xf2\xa6\xd1\x19\xdc$\x93\xc5&amp;\x1a\x1fE\x12_[\x14*\x8d\xce\xe0&amp;\x99,6\x91\xfe98&#39;</span>
<span class="gi">+                         b&#39;)\\T\xde4:\x83\x9bd\xb2\xd8\xf9\x03~S=\xdd&#39;,</span>
<span class="gi">+                         b&#39;x\x01\xed\xdd\x85qB\x01\x14DQ\x12\x88\x11#\xeeF\x84\xb8\xbb\xf6_\x15\xa9\x82\xd9\xf9\xf3&#39;</span>
<span class="gi">+                         b&#39;\xce\xed`O\x03\xdbj\x89\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01&#39;</span>
<span class="gi">+                         b&#39;\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @&#39;</span>
<span class="gi">+                         b&#39;\x80\x00\x81\xc6\x08\x8c\x89\x00\x01\x02\x04*\n\x8c\x8b@e\x81\xb6*\x0bt\x94\x15\x98\xa8\xddd&#39;</span>
<span class="gi">+                         b&#39;\xf5\xa6j7\xdd\xf4f\xb2u\xd3\xcdf\x9bK7\x9fm!\xddb\xb6^\xba\xa5l\xcb\xe9V\xb2\xad\xa6[&#39;</span>
<span class="gi">+                         b&#39;\xcb\xb6\x9en#\xdbf\xba\xadl\xdb\xe9v\xb2\xed\xa6\xdb\xcb\xb6\x9f\xee@\x04\x08\x10 @\x80&#39;</span>
<span class="gi">+                         b&#39;\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10&#39;</span>
<span class="gi">+                         b&#39; @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02&#39;</span>
<span class="gi">+                         b&#39;\x04\x08\x10\x18\x91\xc0P\x04\x08T\x158\x14\x01\x02\x04\x08\x10 @\x80\x00\x01\x02&#39;</span>
<span class="gi">+                         b&#39;\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80&#39;</span>
<span class="gi">+                         b&#39;\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\xcd\x118\x12\x01\x02\x04\x08T\x14\xe8\x8b@e\x81c&#39;</span>
<span class="gi">+                         b&#39;U\x168QV\xe0\xb4vg\xd5\x1b\xd4\xee\xbc\xe9]d\xbbLw\x95\xed:\xddM\xb6\xdbtw\xd9\xee\xd3=d{L&#39;</span>
<span class="gi">+                         b&#39;\xf7\x94\xed9\xddK\xb6\xd7to\xd9\xde\xd3}d\xfbL\xf7\x95\xed;\xddO\xb6\xdft\x7f&quot;@\x80\x00\x01&#39;</span>
<span class="gi">+                         b&#39;\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @&#39;</span>
<span class="gi">+                         b&#39;\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08&#39;</span>
<span class="gi">+                         b&#39;\x10 @\x80\xc0\x88\x04\xaa\x1e\x9f\xdbM\x80\xc0\xf0\x1f\x9f\x0cK\xfb&#39;),</span>
<span class="gi">+ (3, 2, 3, &#39;saturate&#39;): (b&#39;x\x01\x15\xcbA\x15BQ\x08\x05@\xa2XD\xc5&amp;/\nQ(\xa2\xf2\x9b\x10\xc5\x91\xc3\xc0\xe2B\xc4\xbf&#39;</span>
<span class="gi">+                         b&#39;\xean&lt;&quot;\x92\xa2\x19\x96xF\xdcH\x0eE3,\x91r\x92C\xd1\x0cK\xbc\xe4$\x87\xa2\x19\x96(\xfd&#39;</span>
<span class="gi">+                         b&#39;\xb6?n(\x9aa\x89\xaf\x7f\x92C\xd1\x0cK\x8c\x9c\xe4P4\xc3\x12\x97\x9c\xe4P4\xc3^?\xc7\x8a;c&#39;,</span>
<span class="gi">+                         b&#39;x\x01\xed\xdd\xd7U\x15\x00\x00\x04Q$\x89HV@r\x90 Q\xb2\x92\xfb\xaf\xea\xd1\x02\x7f&#39;</span>
<span class="gi">+                         b&#39;\x1c\xce\xdc\xe9`o\x03;4$\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01&#39;</span>
<span class="gi">+                         b&#39;\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\xe0\xd3\t|&#39;</span>
<span class="gi">+                         b&#39;\x11\x01\x02\x04\x08\x14\x05\x86E\xa0,0\xa2\xb2\xc0\xa8&gt;V`\xac\xddx\xbd\xaf\xed&amp;\xea}k7Y\xef&#39;</span>
<span class="gi">+                         b&#39;{\xbb\xa9z\xd3\xedf\xea\xcd\xb6\x9b\xab7\xdfn\xa1\xde\x8fv?\xeb-\xb6[\xaa\xb7\xdc\xee&#39;</span>
<span class="gi">+                         b&#39;W\xbd\x95v\xab\xf5\xd6\xda\xad\xd7\xdbh\xb7YoK\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10&#39;</span>
<span class="gi">+                         b&#39; @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 &#39;</span>
<span class="gi">+                         b&#39;@\x80\x00\x01\x02\x04\x08\x10 \xf0.\x81\x81\x08\x10\xa8\nl\x8b\x00\x01\x02\x04\x08\x10 @\x80&#39;</span>
<span class="gi">+                         b&#39;\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10&#39;</span>
<span class="gi">+                         b&#39; @\x80\x00\x01\x02\x04\x08\x10\xf8|\x02;&quot;@\x80\x00\x81\xa2\xc0\xae\x08\x94\x05~\xab,\xb0&#39;</span>
<span class="gi">+                         b&#39;\xa7\x8f\x15\xd8owP\xef\xb0\xdd\x9fzG\xed\x8e\xeb\x9d\xb4;\xadw\xd6\xee\xbc\xde\xdfv\x17&#39;</span>
<span class="gi">+                         b&#39;\xf5.\xdb]\xd5\xbbnwS\xef\xb6\xdd]\xbd\x7f\xed\xfe\xd7\xbbo\xf7P\xef\xb1\xddS\xbd\xe7v/\xf5^&#39;</span>
<span class="gi">+                         b&#39;E\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @&#39;</span>
<span class="gi">+                         b&#39;\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\xef\x12&#39;</span>
<span class="gi">+                         b&#39;\xa8\x1e\x9f\xdbM\x80\xc0\xe0\r\xd9\xf2;{&#39;),</span>
<span class="gi">+ (4, 3, 7, &#39;saturate&#39;): (b&#39;x\x01\x1d\xcd[\xb5\x90!\x10\x80Q&quot;\x18\x81\x08\xbc{C-@\x04&quot;\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj&#39;</span>
<span class="gi">+                         b&#39;\x01&quot;\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19&#39;</span>
<span class="gi">+                         b&#39;L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99&#39;</span>
<span class="gi">+                         b&#39;B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5&#39;</span>
<span class="gi">+                         b&#39;\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19&#39;</span>
<span class="gi">+                         b&#39;\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&amp;|s\x8bL\xa53\x98,&#39;</span>
<span class="gi">+                         b&#39;6\x87\xcbC\xf8\xee\x7f&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6&#39;</span>
<span class="gi">+                         b&quot;\x87\xcbC\xf8\xa9&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb&quot;</span>
<span class="gi">+                         b&#39;C\xf8\xa5\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH&quot;S\xa84:\x83\xc9bs\xb8&lt;\x84&#39;</span>
<span class="gi">+                         b&#39;?z&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b&#39;,</span>
<span class="gi">+                         b&#39;x\x01\xed\xdd\xd5\x96\x90\x05\x00E\xe1\x01\xe9\x90n\x90\x96F\xbaE\xa4S@\xba\x15\xa4\xbbKX H*&#39;</span>
<span class="gi">+                         b&#39;\xdd)\xa9\x12Jw*H\x08Jww\x87\xd25\\\xccC\xec5\xf3\xef\xef\r\xce~\x81\x13\x12&quot;\x0bX&#39;</span>
<span class="gi">+                         b&#39;\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX \xc2\x16\x88$\x0b&#39;</span>
<span class="gi">+                         b&#39;X\xc0\x02\x16\x08b\x81\xc8\xb2@\x90\x0b|\xa0 \x17\x88&quot;\xb6@\xd4`\x8b\x16t\xd1\x83-Fx\x17\x93&#39;</span>
<span class="gi">+                         b&#39;\x15\x8b\x16\x9b\x15\x87\x16\x97\xf5!-\x1e+&gt;-\x01+!-\x11+1-\t+)-\x19+9-\x05+%-\x15+5-\r&#39;</span>
<span class="gi">+                         b&#39;\xeb#ZZV:ZzV\x06ZFV&amp;Zf\xd6\xc7\xb4,\xac\xac\xb4l\xac\xec\xb4\x1c\xac\x9c\xb4\\\xac\xdc\xb4O&#39;</span>
<span class="gi">+                         b&#39;XyhyY\xf9h\xf9Y\x05h\x05Y\x85h\x85YEhEY\xc5h\xc5Y%h\x9f\xb2J\xd2&gt;c\x95\xa2}\xce*M+\xc3*K+&#39;</span>
<span class="gi">+                         b&#39;\xc7*O\xab\xc0\xaaH\xab\xc4\xaaL\xab\xc2\xaaJ\xab\xc6\xfa\x82V\x9dU\x83V\x93\xf5%\xad&#39;</span>
<span class="gi">+                         b&#39;\x16\xab6\xad\x0e\xab.\xad\x1e\xab&gt;\xad\x01\xab!\xad\x11\xab1\xad\t\xab)\xad\x19\xeb+\xda&#39;</span>
<span class="gi">+                         b&#39;\xd7\xac\xe6\xb4\x16\xacoh-Y\xadh\xadYmhmY\xedh\xedY\x1dh\x1dY\x9dh\x9dY]h]Y\xddh\xddY=h&#39;</span>
<span class="gi">+                         b&#39;=Y\xbdh\xbdY}h}Y\xfdh\xfdY\xdf\xd2\x06\xb0\x06\xca\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02&#39;</span>
<span class="gi">+                         b&#39;\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05\xc2\n&#39;</span>
<span class="gi">+                         b&#39;\x84\xca\x02\x16\x08j\x81A\xb2\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0&#39;</span>
<span class="gi">+                         b&#39;\x02\x16\xb0\x80\x05&quot;n\x81\xc1\xb2\x80\x05,`\x81 \x16\xf8N\x16\x08r\x81!\nr\x81\xa1&#39;</span>
<span class="gi">+                         b&#39;b\x0b|\x1fl\xc3\x82nx\xb0\x8d\x08\xefF\xb2F\xd1F\xb3~\xa0\xfd\xc8\x1aC\x1b\xcb\x1a&#39;</span>
<span class="gi">+                         b&#39;G\x1b\xcf\x9a@\x9b\xc8\x9aD\x9b\xcc\x9aB\x9b\xca\x9aF\x9b\xce\x9aA\x9b\xc9\x9aE\x9b\xcd\x9a&#39;</span>
<span class="gi">+                         b&#39;C\x9b\xcb\xfa\x896\x8f5\x9f\xb6\x80\xb5\x90\xb6\x88\xb5\x98\xf63\xeb\x17\xda\xaf\xac&#39;</span>
<span class="gi">+                         b&#39;%\xb4\xa5\xace\xb4\xe5\xac\xdfh\xbf\xb3V\xd0V\xb2V\xd1V\xb3\xd6\xd0\xd6\xb2\xd6\xd1\xd6\xb3&#39;</span>
<span class="gi">+                         b&#39;6\xd06\xb26\xd16\xb3\xb6\xd0\xb6\xb2\xb6\xd1\xb6\xb3v\xd0v\xb2\xfe\xa0\xfd\xc9\xdaE\xdb\xcd&#39;</span>
<span class="gi">+                         b&#39;\xfa\x8b\xb6\x87\xb5\x97\xb6\x8f\xb5\x9f\xf67\xeb\x00\xed \xeb\x1f\xda\xbf\xacC\xb4\xc3&#39;</span>
<span class="gi">+                         b&#39;\xac#\xb4\xa3\xacc\xb4\xe3\xac\x13\xb4\x93\xacS\xb4\xd3\xac3\xb4\xb3\xacs\xb4\xf3&#39;</span>
<span class="gi">+                         b&#39;\xac\x0b\xb4\x8b\xacK\xb4\xcb\xac+\xb4\xab\xack\xb4\xeb\xac\x1b\xb4\x9b\xac[\xb4\xdb&#39;</span>
<span class="gi">+                         b&#39;\xac;\xb4\xbb\xac{\xb4\xfb\xac\x07\xb4\x87\xacG\xb4\xc7\xac\xffh\xff\xb3\x9e\xd0\x9e&#39;</span>
<span class="gi">+                         b&#39;\xb2\x9e\xd1\x9e\xb3^\xd0^\xb2^\xd1^\xb3\xde\xd0\xde\xb2\xde\xc9\x02\x16\xb0\x80\x05&#39;</span>
<span class="gi">+                         b&#39;,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0&#39;</span>
<span class="gi">+                         b&#39;\x02\x16\xb0\x80\x05\xc2\n\x04\xf5\xf8\xdc\xdd\x16\xb0@\xe8{\t?\xc8\x90&#39;),</span>
<span class="gi">+ (5, 2, 15, &#39;saturate&#39;): (b&#39;x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17&#39;</span>
<span class="gi">+                          b&#39;\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@&#39;</span>
<span class="gi">+                          b&quot;R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88&#39;:I\xd1\x0c\xcb\x11?\xeb$E3,G&lt;\xd5I\x8afX\x8ex\xa6\x93&quot;</span>
<span class="gi">+                          b&#39;\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G&lt;\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c&#39;</span>
<span class="gi">+                          b&#39;\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I&#39;</span>
<span class="gi">+                          b&#39;\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c&#39;</span>
<span class="gi">+                          b&#39;\xcb\x11\xefu\x92\xa2\x19\x96#&gt;\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y&#39;</span>
<span class="gi">+                          b&quot;&#39;)\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K&#39;)\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft&quot;</span>
<span class="gi">+                          b&#39;\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f&#39;</span>
<span class="gi">+                          b&#39;\xd2\x15\xf0\xcf&#39;,</span>
<span class="gi">+                          b&#39;x\x01\xed\xddC\xa2\x1c\x00\x00D\xc1\xd8\xb6m\xdb\xb6m\xdb66\xb1m\xdb\xb6m\xdb\xb6m&#39;</span>
<span class="gi">+                          b&#39;,\x92c\xfcEM\xdd\xa0\xdf\x05:X\xb0 \x16\xdc\x16B\x17\xd2\x16J\x17\xda\x16F\x17\xd6&#39;</span>
<span class="gi">+                          b&#39;\x16N\x17\xde\x16A\x17\xd1\x16I\x17\xd9\x16E\x17\xd5\x16M\x17\xdd\x16C\x17\xd3\x16K\x17\xdb&#39;</span>
<span class="gi">+                          b&#39;\x16G\x17\xd7\x16O\x17\xdf\x96@\x97\xd0\x96H\x97\xd8\x96D\x97\xd4\x96L\x97\xdc\x96B\x97\xd2&#39;</span>
<span class="gi">+                          b&#39;\x96J\x97\xda\x96F\x97\xd6\x96N\x97\xde\x96A\x97\xd1\x96I\x97\xd9\x96E\x97\xd5\x96M\x97\xdd&#39;</span>
<span class="gi">+                          b&#39;\x96C\x97\xd3\x96K\x97\xdb\x96G\x97\xd7\x96O\x97\xdfV@W\xd0VHW\xd8VDW\xd4VLW\xdcVBW\xd2&#39;</span>
<span class="gi">+                          b&#39;VJW\xdaVFW\xd6VNW\xdeVAW\xd1VIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW\xdf\xd6@\xd7\xd0&#39;</span>
<span class="gi">+                          b&#39;\xd6H\xd7\xd8\xd6D\xd7\xd4\xd6L\xd7\xdc\xd6B\xd7\xd2\xd6J\xd7\xda\xd6F\xd7\xd6\xd6N\xd7\xde&#39;</span>
<span class="gi">+                          b&#39;\xd6A\xd7\xd1\xd6I\xd7\xd9\xd6E\xd7\xd5\xd6M\xd7\xdd\xd6C\xd7\xd3\xd6K\xd7\xdb\xd6G\xd7\xd7&#39;</span>
<span class="gi">+                          b&#39;\xd6O\xd7\xdf6@70 H\x0b\xfc\x0b\x08\x14\x08\x14P\x0b\x0c\nj\x83mCtCm\xc3t\xc3m#t#m&#39;</span>
<span class="gi">+                          b&#39;\xa3t\xa3mctcm\xe3t\xe3m\x13t\x13m\x93t\x93mStSm\xd3t\xd3m3t3m\xb3t\xb3mstsm\xf3t\xf3m&#39;</span>
<span class="gi">+                          b&#39;\x0bt\x0bm\x8bt\x8bmKtKm\xcbt\xcbm+t+m\xabt\xabmktkm\xebt\xebm\x1bt\x1bm\x9bt\x9bm[t[m&#39;</span>
<span class="gi">+                          b&quot;\xdbt\xdbm;t;m\xbbt\xbbm{t{m\xfbt\xfbm\x07t\x07m\x87t\x87mGtGm\xc7t\xc7m&#39;t&#39;m\xa7t\xa7mgtgm&quot;</span>
<span class="gi">+                          b&#39;\xe7t\xe7m\x17t\x17m\x97t\x97mWtWm\xd7t\xd7m7t7m\xb7t\xb7mwtwm\xf7t\xf7m\x0ft\x0fm&#39;</span>
<span class="gi">+                          b&#39;\x8ft\x8fmOtOm\xcft\xcfm/t/m\xaft\xafmotom\xeft\xefm\x1ft\x1fm\x9ft\x9fm_t_m\xdft\xdfm?t?m&#39;</span>
<span class="gi">+                          b&#39;\xbft\xbfm\x7ft\x7f\x03\x82\xb4\x80z|\x1e\xd8\x1d(\x10(\xf0\xef?\xe6\xfc\r\x9b&#39;),</span>
<span class="gi">+ (4, 3, 7, &#39;overflow&#39;): (b&#39;x\x01\x1d\xcd[\xb5\x90!\x10\x80Q&quot;\x18\x81\x08\xbc{C-@\x04&quot;\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj&#39;</span>
<span class="gi">+                         b&#39;\x01&quot;\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19&#39;</span>
<span class="gi">+                         b&#39;L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99&#39;</span>
<span class="gi">+                         b&#39;B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5&#39;</span>
<span class="gi">+                         b&#39;\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19&#39;</span>
<span class="gi">+                         b&#39;\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&amp;|s\x8bL\xa53\x98,&#39;</span>
<span class="gi">+                         b&#39;6\x87\xcbC\xf8\xee\x7f&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6&#39;</span>
<span class="gi">+                         b&quot;\x87\xcbC\xf8\xa9&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb&quot;</span>
<span class="gi">+                         b&#39;C\xf8\xa5\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH&quot;S\xa84:\x83\xc9bs\xb8&lt;\x84&#39;</span>
<span class="gi">+                         b&#39;?z&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b&#39;,</span>
<span class="gi">+                         b&#39;x\x01\xed\xdc\x05\xb2\x90\x05\x00E\xe1\x87\x80\xa4t\x83tw\x97Jw\x0bHKw\x83\x80\x92Cww7&#39;</span>
<span class="gi">+                         b&#39;\x92\xd2\x1dRJww\x97\xa4\x92J\xba\x8c3\x8f\xff|\x1b\xb83g\x017$D\x16\xb0\x80\x05,`\x01&#39;</span>
<span class="gi">+                         b&#39;\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\xc0g[ \x8c,`\x01\x0bX &#39;</span>
<span class="gi">+                         b&#39;\x88\x05\xbe\x90\x05\x82\\ \xac\x82\\ \x9c\xd8\x02\xe1\x83\xed\xcb\xa0\x8b\x10l\x11&#39;</span>
<span class="gi">+                         b&#39;C\xbbH\xac\xc8\xb4(\xac\xa8\xb4\xafX\xd1h\xd1Y1h1Y\xb1h\xb1YqhqY\xf1h\xf1Y\th\tY\x89h\x89Y&#39;</span>
<span class="gi">+                         b&#39;Ih_\xb3\x92\xd2\x92\xb1\x92\xd3R\xb0R\xd2R\xb1R\xd3\xd2\xb0\xd2\xd2\xd2\xb1\xd2\xd32\xb0&#39;</span>
<span class="gi">+                         b&#39;2\xd22\xb12\xd3\xb2\xb0\xb2\xd2\xb2\xb1\xb2\xd3r\xb0r\xd2r\xb1r\xd3\xf2\xb0\xf2\xd2\xf2\xb1&#39;</span>
<span class="gi">+                         b&#39;\xf2\xd3\n\xb0\n\xd2\xbea}K\xfb\x8eU\x88V\x98U\x84V\x94U\x8cV\x9cU\x82V\x92U\x8aV\x9a&#39;</span>
<span class="gi">+                         b&#39;U\x86V\x96U\x8eV\x9eU\x81V\x91U\x89V\x99U\x85\xf6=\xab*\xad\x1a\xab:\xed\x07V\rZMV-ZmV\x1dZ]&#39;</span>
<span class="gi">+                         b&#39;V=\xda\x8f\xac\xfa\xb4\x06\xac\x86\xb4F\xac\xc6\xb4&amp;\xac\xa6\xb4f\xac\xe6\xb4\x16&#39;</span>
<span class="gi">+                         b&#39;\xac\x96\xb4V\xac\xd6\xb46\xac\xb6\xb4v\xac\xf6\xb4\x0e\xac\x8e\xb4N\xac\xce\xb4\x9fX]h]&#39;</span>
<span class="gi">+                         b&#39;Y\xddh?\xb3~\xa1ug\xf5\xa0\xf5d\xf5\xa2\xf5f\xf5\xa1}\x92\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80&#39;</span>
<span class="gi">+                         b&#39;\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX&#39;</span>
<span class="gi">+                         b&#39;\xc0\x02\x16`\x0b\xf4\x95\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0&#39;</span>
<span class="gi">+                         b&quot;\x80\x05,\xf0\xf9\x16\xe8&#39;\x0bX\xc0\x02\x16\x08b\x81\xfe\xb2@\x90\x0b\x0cP\x90\x0b\x0c\x14[&quot;</span>
<span class="gi">+                         b&#39;`P\xb0\r\x0e\xba!\xc164\xb4\x1b\xc6\x1aN\x1b\xc1\x1aI\x1b\xc5\x1aM\x1b\xc3\x1aK\x1b&#39;</span>
<span class="gi">+                         b&#39;\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b&#39;</span>
<span class="gi">+                         b&#39;\xc3\x9aK\x9b\xc7\x9aO[\xc0ZH[\xc4\xfa\x95\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6&#39;</span>
<span class="gi">+                         b&#39;\x9c\xb5\x82\xf6\x1bk%m\x15k5m\rk-m\x1dk=m\x03k#m\x13k3m\x0bk+m\x1bk;m\x07\xebw\xda&#39;</span>
<span class="gi">+                         b&quot;N\xd6.\xdan\xd6\x1e\xda^\xd6\x1f\xb4?Y\xfbh\xfbY\x07h\x07Y\x87h\x87YGhGY\xc7h\xc7Y&#39;h&#39;Y\xa7h&quot;</span>
<span class="gi">+                         b&#39;\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x97h\x97YWhWY\xd7h\xd7Y7h7Y\xb7h\xb7YwhwY\xf7h\xf7Y\x0fh&#39;</span>
<span class="gi">+                         b&#39;\x7f\xb1\x1e\xd2\x1e\xb1\x1e\xd3\x9e\xb0\x9e\xd2\x9e\xb1\xfe\xa6\xfd\xc3zN{\xc1zI{\xc5zM&#39;</span>
<span class="gi">+                         b&#39;{\xc3\xfa\x97\xf6\x1f\xeb-\xed\x1d\xeb=\xed\x03\xeb#\x8d\xbd\xefw\xdd\x02\x16\xb0\x80\x05,`&#39;</span>
<span class="gi">+                         b&#39;\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16&#39;</span>
<span class="gi">+                         b&#39;\xb0\x80\x05,`\x01\x0b|\xfa\x1f\xb2\xf6b\xf1&#39;),</span>
<span class="gi">+ (5, 2, 15, &#39;overflow&#39;): (b&#39;x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17&#39;</span>
<span class="gi">+                          b&#39;\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@&#39;</span>
<span class="gi">+                          b&quot;R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88&#39;:I\xd1\x0c\xcb\x11?\xeb$E3,G&lt;\xd5I\x8afX\x8ex\xa6\x93&quot;</span>
<span class="gi">+                          b&#39;\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G&lt;\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c&#39;</span>
<span class="gi">+                          b&#39;\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I&#39;</span>
<span class="gi">+                          b&#39;\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c&#39;</span>
<span class="gi">+                          b&#39;\xcb\x11\xefu\x92\xa2\x19\x96#&gt;\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y&#39;</span>
<span class="gi">+                          b&quot;&#39;)\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K&#39;)\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft&quot;</span>
<span class="gi">+                          b&#39;\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f&#39;</span>
<span class="gi">+                          b&#39;\xd2\x15\xf0\xcf&#39;,</span>
<span class="gi">+                          b&#39;x\x01\xed\xddS\xb6\x1e\x06\x00\x85\xd1\x1b\xdb\xb6\x1b\xdb\xb6\x9b\x06\x8dm\xdbz\x88&#39;</span>
<span class="gi">+                          b&quot;m\xabI\x1b\xa3\xb1m\xdb\xb6mg\xad\x9ba\xdc\x87\xfd\xef\x19\x9co\x02&#39;((\x84\x85\xb2&quot;</span>
<span class="gi">+                          b&#39;\x85\xd6\x85\xb1\x85\xd5\x85\xb3\x85\xd7E\xb0E\xd4E\xb2E\xd6E\xb1E\xd5E\xb3E\xd7\xc5\xb0&#39;</span>
<span class="gi">+                          b&#39;\xc5\xd4\xc5\xb2\xc5\xd6\xc5\xb1\xc5\xd5\xc5\xb3\xc5\xd7%\xb0%\xd4%\xb2%\xd6%\xb1%\xd5%\xb3&#39;</span>
<span class="gi">+                          b&#39;%\xd7\xa5\xb0\xa5\xd4\xa5\xb2\xa5\xd6\xa5\xb1\xa5\xd5\xa5\xb3\xfd\xa1Ko\xcb\xa0\xcbh&#39;</span>
<span class="gi">+                          b&#39;\xcb\xa4\xcbl\xcb\xa2\xcbj\xcb\xa6\xcbn\xcb\xa1\xcbi\xcb\xa5\xcbm\xcb\xa3\xcbk\xcb\xa7\xcbo&#39;</span>
<span class="gi">+                          b&#39;+\xa0+h+\xa4+l+\xa2+j+\xa6+n+\xa1+i+\xa5+m+\xa3+k+\xa7+o\xab\xa0\xabh\xab\xa4\xabl&#39;</span>
<span class="gi">+                          b&#39;\xfbSW\xc5\xf6\x97\xae\xaa\xad\x9a\xae\xba\xad\x86\xeeo[M]-[m]\x1d[]]=[}]\x03[C]#[c]\x13&#39;</span>
<span class="gi">+                          b&quot;[S]3[s]\x0b[K]+[k]\x1b[[];[{]\x07[G]&#39;[g]\x17[W]7[w]\x0f[O]/[o]\x1f[_]?[\x7f\xdd\x00&quot;</span>
<span class="gi">+                          b&#39;\xdb\xc0\x90\x16\x1c\x10(\x10(\xa0\x16\x18\x14\xd2\x06\xdb\x86\xe8\x86\xda\x86\xe9\x86\xdb&#39;</span>
<span class="gi">+                          b&#39;F\xe8F\xdaF\xe9F\xdb\xc6\xe8\xc6\xda\xc6\xe9\xc6\xdb&amp;\xe8&amp;\xda&amp;\xe9&amp;\xdb\xa6\xe8\xa6\xda&#39;</span>
<span class="gi">+                          b&#39;\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9\xfe\xb1\xcd\xd7-\xb0&#39;</span>
<span class="gi">+                          b&#39;\xfd\xab\xfb\xcf\xb6P\xb7\xc8\xb6X\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xb7\xca&#39;</span>
<span class="gi">+                          b&#39;\xf6\xbfn\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7&#39;</span>
<span class="gi">+                          b&#39;m\x97n\xb7m\x8fn\xafm\x9fn\xbf\xed\x80\xee\xa0\xed\x90\xee\xb0\xed\x88\xee\xa8&#39;</span>
<span class="gi">+                          b&#39;\xed\x98\xee\xb8\xed\x84\xee\xa4\xed\x94\xee\xb4\xed\x8c\xee\xac\xed\x9c\xee\xbc&#39;</span>
<span class="gi">+                          b&#39;\xed\x82\xee\xa2\xed\x92\xee\xb2\xed\x8a\xee\xaa\xed\x9a\xee\xba\xed\x86\xee\xa6&#39;</span>
<span class="gi">+                          b&#39;\xed\x96\xee\xb6\xed\x8e\xee\xae\xed\x9e\xee\xbe\xed\x81\xee\xa1\xed\x91\xee\xb1&#39;</span>
<span class="gi">+                          b&#39;\xed\x89\xee\xa9\xed\x99\xee\xb9\xed\x85\xee\xa5\xed\x95\xee\xb5\xed\x8d\xee\xad&#39;</span>
<span class="gi">+                          b&#39;\xed\x9d\xee\xbd\xed\x83\xee\xa3\xed\x93\xee\xb3\xed\x8b\xee\xab\xed\x9b\xee\xbb&#39;</span>
<span class="gi">+                          b&#39;\xed\x87\xee\xa7\xedWHS\x8f\xcf\x03\xbb\x03\x05\x02\x05\x82\x7f\x03\xb3\x87\x0e\x9d&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+binary8_luts_compressed = \</span>
<span class="gi">+{(4, 8): (b&#39;x\x01\x15\xcb[\xd5P!\x10\x80Q&quot;\x18\x81\x08&lt;{E-@\x04&quot;\xd0@&quot;\x10\x81\x08&lt;{E\xff\x02\&#39;\x02\x11h\xa0\xdbY&#39;</span>
<span class="gi">+          b&#39;k\xcf\xcb\xcc\x17\xc2\xff\xe9\xaf\xad7!d:\x93\xcd!\xbc\r\xe1\x15\x91D\xa6Pit\x06\x93\xc5\xe6\xe1p\t\xef\xf4&#39;</span>
<span class="gi">+          b&#39;D\x12\x99B\xa5\xd1\x19L\x16\x9b\x87\xc3%\xbc\xd7\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0AO$\x91)T\x1a\x9d\xc1d\xb1&#39;</span>
<span class="gi">+          b&quot;y8\\B\xd6\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0QO$\x91)T\x1a\x9d\xc1d\xb1y8\\\xc2&#39;=\x91D\xa6Pit\x06\x93&quot;</span>
<span class="gi">+          b&#39;\xc5\xe6\xe1p\t\x9f\xf5D\x12\x99B\xa5\x7f\xf1O\xff\xea\xef\x9b\x1b\x9d\xc9\xe6\x10\xbe\xeb\x89$2\x85J\xa3&#39;</span>
<span class="gi">+          b&#39;3\x98,6\x0f\x87K\xf8\xa1\&#39;\x92\xc8\x14*\x8d\xce`\xb2\xd8&lt;\x1c.\xe1\xa7\x9eH&quot;S\xa84:\x83\xc9b\xf3p\xb8\x84_z&#39;</span>
<span class="gi">+          b&#39;&quot;\x89L\xa1\xd2\xe8\x0c&amp;\x8b\xcd\xc3\xe1\x12\xb6\x9eH&quot;S\xa84:\x83\xc9b\xf3p\xb8\x84\xdfz&quot;\x89L\xa1\xd2\xe8&#39;</span>
<span class="gi">+          b&#39;\x0c&amp;\x8b\xcd\xc3\xe1\x12\xfe\xe8\x89$2\x85J\xa33\x98,6\x0f\x87Kx\xd1\x13Id\n\x95\xfe\xf7\x1f[)\xf3`&#39;,</span>
<span class="gi">+          b&#39;x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97&#39;</span>
<span class="gi">+          b&#39;\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01&#39;</span>
<span class="gi">+          b&#39;\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xe0\xbd/\x10A\x16\xb0\x80\x05,\x10\xc4\x02\x11e\x81 \x17\x88&#39;</span>
<span class="gi">+          b&#39;\xa4 \x17\x88,\xb6@\x94`\x8b\x1at\xd1\x82-zx\x17\x83\x15\x93\x16\x8b\x15\x9b\x16\x87\x15\x97\x16\x8f\x15&#39;</span>
<span class="gi">+          b&#39;\x9f\x96\x80\x95\x90\x96\x88\x95\x98\x96\x84\xf5\x01-)+\x19-9+\x05-%+\x15-5+\r--+\x1d-=+\x03-#+\x13\xedCV&#39;</span>
<span class="gi">+          b&#39;fZ\x16VVZ6VvZ\x0eVN\xdaG\xac\x8fi\xb9X\xb9i\x9f\xb0\xf2\xd0&gt;e\xe5\xa5\xe5c\xe5\xa7\x15`\x15\xa4\x15b&#39;</span>
<span class="gi">+          b&#39;\x15\xa6\x15a\x15\xa5\x15c\x15\xa7\x95`\x95\xa4\x95b\x95\xa6\x95a\x95\xa5\x95c\x95\xa7U`U\xa4UbU\xa6Ua&#39;</span>
<span class="gi">+          b&#39;U\xa5UcU\xa7\xd5`\xd5\xa4\xd5b\xd5\xa6\xd5a\xd5\xa5\xd5c\xd5\xa75`5\xa45b5\xa65a}Fk\xcajFk\xcejAk\xc9&#39;</span>
<span class="gi">+          b&quot;jEk\xcdjCk\xcbjGk\xcf\xea@\xfb\x9c\xd5\x91\xd6\x89\xd5\x99\xd6\x85\xf5\x05\xad+\xab\x1b\xad;\xab\x07\xad&#39;&quot;</span>
<span class="gi">+          b&#39;\xab\x17\xad7\xab\x0f\xad/\xab\x1f\xad?k\x00m k\x10m0k\x08m\xa8,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,&#39;</span>
<span class="gi">+          b&#39;`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x00\\&#39;</span>
<span class="gi">+          b&#39; L\x16\xb0@P\x0b\xbc\xf7\xff\x86\x0e\xb4\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX &#39;</span>
<span class="gi">+          b&#39;\x14\x1a&amp;\x0bX\xc0\x02\x16\x08b\x81\xe1\xb2@\x90\x0b\x8cP\x90\x0b\x8c\x14[`T\xb0\x8d\x0e\xba1\xc16&#39;</span>
<span class="gi">+          b&#39;6\xbc\x1b\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b\xc3&#39;</span>
<span class="gi">+          b&#39;\x9aK\x9b\xc7\x9aO\xfb\x92\xb5\x80\xb6\x90\xb5\x88\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6\x9c\xb5\x82\xb6\x92&#39;</span>
<span class="gi">+          b&#39;\xb5\x8a\xb6\x9a\xb5\x86\xb6\x96\xb5\x8e\xb6\x9e\xb5\x81\xf6\x15\xebk\xdaF\xd6&amp;\xdaf\xd6\x16\xdaV\xd66\xda7&#39;</span>
<span class="gi">+          b&#39;\xacoi\xdbY;h;Y\xbbh\xdf\xb1\xbe\xa7\xedf\xed\xa1\xede\xed\xa3\xfd\xc0\xfa\x91\xb6\x9fu\x80v\x90u\x88v&#39;</span>
<span class="gi">+          b&#39;\x98u\x84v\x94u\x8c\xf6\x13\xeb8\xedg\xd6/\xb4\x13\xac\x93\xb4S\xac\xd3\xb4_Y\xbf\xd1\xce\xb0\xce\xd2&#39;</span>
<span class="gi">+          b&#39;\xce\xb1\xce\xd3.\xb0.\xd2~g\xfdA\xbb\xc4\xfa\x93v\x99u\x85v\x95u\x8dv\x9du\x83\xf6\x17\xebo\xdaM\xd6-&#39;</span>
<span class="gi">+          b&#39;\xda?\xac\x7fi\xb7YwhwY\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xff\xb1^\xd3\xde\xb0\xde&#39;</span>
<span class="gi">+          b&#39;\xd2\xde\xc9\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`&#39;</span>
<span class="gi">+          b&#39;\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b\xc0\x05\x82z|\xeen\x0bX \xec\x7f\xc6\xe4\x02%&#39;),</span>
<span class="gi">+ (5, 16): (b&#39;x\x01\x1d\xc9\x89\r\x10\x04\x0c\x86\xd1\x8e\xc2\x16 \x97\x059\xd6\xe8&amp;t\x94n\xa1\\RQ`\x8dn\x02/6yI&#39;</span>
<span class="gi">+           b&quot;\xf3\x7f\x11\xff\xdf\xc3\x88f\x89G\x11\x0fH\x8afX\x8e\xf8M&#39;)\x9aa9\xe2\xb1NR4\xc3r\xc4\x13\x9d\xa4h&quot;</span>
<span class="gi">+           b&#39;\x86\xe5\x88\xa7:I\xd1\x0c\xcb\x11\xcft\x92\xa2\x19\x96#\x9e\xeb$E3,G\xfc\xae\x93\x14\xcd\xb0\x1c\x91&#39;</span>
<span class="gi">+           b&quot;:I\xd1\x0c\xcb\x11/t\x92\xa2\x19\x96#^\xea$E3,G\xfc\xa1\x93\x14\xcd\xb0\x1c\xf1J&#39;)\x9aa9\xe2\xb5NR4\xc3&quot;</span>
<span class="gi">+           b&#39;r\xc4\x1b\x9d\xa4h\x86\xe5\x88\xb7:I\xbf\xb3\x13\x7f\xfaY\xe2/\x9d\xa4h\x86\xe5\x88\xf7:I\xd1\x0c\xcb&#39;</span>
<span class="gi">+           b&#39;\x11\x1ft\x92\xa2\x19\x96#&gt;\xea$E3,G|\xd2I\x8afX\x8e\xf8\xac\x93\x14\xcd\xb0\x1c\xf1\xb7NR4\xc3r&#39;</span>
<span class="gi">+           b&quot;\xc4\x17\x9d\xa4h\x86\xe5\x88\xd5I\x8afX\x8e\xf8G&#39;)\x9aa9\xe2\xabNR4\xc3r\xc4\xbf:I\xd1\x0c\xcb\x11&quot;</span>
<span class="gi">+           b&quot;\xff\xe9$E3,G|\xd3I\x8afX\x8e\xf8\xae\x93\x14\xcd\xb0\x1c\xf1C&#39;\xe9\x9f\xbf\x00Gi\xed\x02&quot;,</span>
<span class="gi">+           b&#39;x\x01\xed\xddU\xd6\x96\x05\x00\x85\xd1\x9f\x16\xa4\x14\x04\xe9P\xa4K\x1a\xe9\x14\x10\t\xe9\x0eQ&#39;</span>
<span class="gi">+           b&#39;\xba\xc1\xa0\xbb\xbb\xa5\x1b)%\xa5;%\xa5\xbb;%\x94\x8eAp\xf1.\xd6\xfe\xf6\x0c\xce3\x81\x13\x16\xf6&#39;</span>
<span class="gi">+           b&#39;\x8e\xc2\x05+|\xd0&quot;\x04+b\xd0&quot;\x05+r\xd0\xa2\x04\xeb\x83\xf7]T[4\xdd\x87\xb6\xe8\xba\x18\xb6\x98\xbaX\xb6&#39;</span>
<span class="gi">+           b&#39;\xd8\xba\x8fl\x1f\xeb\xe2\xd8\xe2\xea&gt;\xb1\xc5\xd3\xc5\xb7}\xaaK`K\xa8KdK\xacKbK\xaaKfK\xaeKaK\xa9\xfb\xcc&#39;</span>
<span class="gi">+           b&#39;\xf6\xb9.\x95\xed\x0b]j[\x1a]Z[:]z[\x06]F[&amp;]f[\x16]V\xdb\x97\xbal\xb6\xec\xba\x1c\xb6\x9c\xba\\&#39;</span>
<span class="gi">+           b&#39;\xb6\xdc\xba&lt;\xb6\xbc\xba\xafl\xf9t\xf9m\x05t\x05m\x85t\x85mEtEm\xc5t\xc5m%t%m_\xebJ\xd9J\xeb\xca&#39;</span>
<span class="gi">+           b&#39;\xd8\xbe\xd1\x95\xb5}\xab+g+\xaf\xab`\xab\xa8\xfb\xceVIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW&#39;</span>
<span class="gi">+           b&#39;\xdf\xd6@\xd7\xd0\xf6\xbd\xae\x91\xed\x07\xdd\x8f\xb6\xc6\xba&amp;\xb6\xa6\xbaf\xb6\xe6\xba\x16\xb6\x96\xba&#39;</span>
<span class="gi">+           b&#39;V\xb6\xd6\xba6\xb6\xb6\xbav\xb6\xf6\xba\x0e\xb6\x8e\xba\x9fl?\xeb~\xb1\xfd\xaa\xebd\xeb\xac\xebb\xeb\xaa&#39;</span>
<span class="gi">+           b&quot;\xeb\x16\x12h\x81\xee!\xa1\x02\xa1\x02j\x81\xb0w\xd5#X=\x83\xd6+X\xbd\x83\xd6&#39;X}\x83\xd6/X\xfd\xdfw&quot;</span>
<span class="gi">+           b&#39;\x03l\x03u\x83l\x83uClCu\xc3l\xc3u#l#u\xa3l\xa3uclcu\xe3l\xe3u\x13l\xbf\xe9&amp;\xda&amp;\xe9&amp;\xdb\xa6\xe8&#39;</span>
<span class="gi">+           b&#39;\xa6\xda\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9~\xb7\xcd\xd7-\xb0-\xd4-\xb2-\xd6&#39;</span>
<span class="gi">+           b&#39;\xfda\xfbS\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xf7\x97m\x95n\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93&#39;</span>
<span class="gi">+           b&#39;n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7m\x97n\xb7\xedo\xdd\x1e\xdb^\xdd&gt;\xdb~\xdd\x01\xdbA\xdd?\xb6C&#39;</span>
<span class="gi">+           b&#39;\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b&#39;</span>
<span class="gi">+           b&#39;\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{&#39;</span>
<span class="gi">+           b&#39;\xba\xfb\xb6\x7fu\x0fl\x0fu\x8fl\x8fu\xff\xd9\xfe\xd7=\xb1=\xd5=\xb3=\xd7\xbd\xb0\xbd\xd4\xbd\xb2\xbd&#39;</span>
<span class="gi">+           b&#39;\xd6\xbd\t\t\xb4\x80z|\x1e\xda\x1d*\x10*\xd0\xfd-\x8c\x93\xc6\x0e&#39;)}</span>
<span class="gh">diff --git a/bitstring/methods.py b/bitstring/methods.py</span>
<span class="gh">index e6be89b..18d7acc 100644</span>
<span class="gd">--- a/bitstring/methods.py</span>
<span class="gi">+++ b/bitstring/methods.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import bitstring
<span class="w"> </span>from bitstring.bitstream import BitStream
<span class="w"> </span>from bitstring.utils import tokenparser
<span class="gu">@@ -8,7 +9,7 @@ from bitstring.bitstore import BitStore</span>
<span class="w"> </span>from bitstring.bitstore_helpers import bitstore_from_token


<span class="gd">-def pack(fmt: Union[str, List[str]], *values, **kwargs) -&gt;BitStream:</span>
<span class="gi">+def pack(fmt: Union[str, List[str]], *values, **kwargs) -&gt; BitStream:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pack the values according to the format string and return a new BitStream.

<span class="w"> </span>    fmt -- A single string or a list of strings with comma separated tokens
<span class="gu">@@ -43,4 +44,52 @@ def pack(fmt: Union[str, List[str]], *values, **kwargs) -&gt;BitStream:</span>
<span class="w"> </span>    &gt;&gt;&gt; u = pack(&#39;uint:8=a, uint:8=b, uint:55=a&#39;, a=6, b=44)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tokens = []</span>
<span class="gi">+    if isinstance(fmt, str):</span>
<span class="gi">+        fmt = [fmt]</span>
<span class="gi">+    try:</span>
<span class="gi">+        for f_item in fmt:</span>
<span class="gi">+            _, tkns = tokenparser(f_item, tuple(sorted(kwargs.keys())))</span>
<span class="gi">+            tokens.extend(tkns)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise CreationError(*e.args)</span>
<span class="gi">+    value_iter = iter(values)</span>
<span class="gi">+    bsl: List[BitStore] = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        for name, length, value in tokens:</span>
<span class="gi">+            # If the value is in the kwd dictionary then it takes precedence.</span>
<span class="gi">+            value = kwargs.get(value, value)</span>
<span class="gi">+            # If the length is in the kwd dictionary then use that too.</span>
<span class="gi">+            length = kwargs.get(length, length)</span>
<span class="gi">+            # Also if we just have a dictionary name then we want to use it</span>
<span class="gi">+            if name in kwargs and length is None and value is None:</span>
<span class="gi">+                bsl.append(BitStream(kwargs[name])._bitstore)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if length is not None:</span>
<span class="gi">+                length = int(length)</span>
<span class="gi">+            if value is None and name != &#39;pad&#39;:</span>
<span class="gi">+                # Take the next value from the ones provided</span>
<span class="gi">+                value = next(value_iter)</span>
<span class="gi">+            if name == &#39;bits&#39;:</span>
<span class="gi">+                value = bitstring.bits.Bits(value)</span>
<span class="gi">+                if length is not None and length != len(value):</span>
<span class="gi">+                    raise CreationError(f&quot;Token with length {length} packed with value of length {len(value)}.&quot;)</span>
<span class="gi">+                bsl.append(value._bitstore)</span>
<span class="gi">+                continue</span>
<span class="gi">+            bsl.append(bitstore_from_token(name, length, value))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        raise CreationError(f&quot;Not enough parameters present to pack according to the &quot;</span>
<span class="gi">+                            f&quot;format. {len(tokens)} values are needed.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        next(value_iter)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        # Good, we&#39;ve used up all the *values.</span>
<span class="gi">+        s = BitStream()</span>
<span class="gi">+        if bitstring.options.lsb0:</span>
<span class="gi">+            bsl.reverse()</span>
<span class="gi">+        for b in bsl:</span>
<span class="gi">+            s._bitstore += b</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    raise CreationError(f&quot;Too many parameters present to pack according to the format. Only {len(tokens)} values were expected.&quot;)</span>
<span class="gh">diff --git a/bitstring/mxfp.py b/bitstring/mxfp.py</span>
<span class="gh">index be90cd1..d675c35 100644</span>
<span class="gd">--- a/bitstring/mxfp.py</span>
<span class="gi">+++ b/bitstring/mxfp.py</span>
<span class="gu">@@ -7,63 +7,200 @@ import zlib</span>
<span class="w"> </span>from typing import Optional


<span class="gi">+def round_to_nearest_ties_to_even(lut_int_to_float, lower: int, f: float) -&gt; Optional[int]:</span>
<span class="gi">+    upper = lower + 1</span>
<span class="gi">+    # Special case for LUTs without a negative zero.</span>
<span class="gi">+    lower_float = 0.0 if lower == 128 else lut_int_to_float[lower]</span>
<span class="gi">+    upper_float = lut_int_to_float[upper]</span>
<span class="gi">+    if upper_float &lt; lower_float:</span>
<span class="gi">+        lower, upper = upper, lower</span>
<span class="gi">+        lower_float, upper_float = upper_float, lower_float</span>
<span class="gi">+    if f == lower_float:</span>
<span class="gi">+        return lower</span>
<span class="gi">+    if f == upper_float:</span>
<span class="gi">+        return upper</span>
<span class="gi">+    if lower_float &lt; f &lt; upper_float:</span>
<span class="gi">+        d1 = f - lower_float</span>
<span class="gi">+        d2 = upper_float - f</span>
<span class="gi">+        if d1 &lt; d2:</span>
<span class="gi">+            return lower</span>
<span class="gi">+        if d2 &lt; d1:</span>
<span class="gi">+            return upper</span>
<span class="gi">+        return lower if lower % 2 == 0 else upper</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class MXFPFormat:
<span class="w"> </span>    &quot;&quot;&quot;Defining an MXFP micro-scaling floating point format&quot;&quot;&quot;

<span class="gd">-    def __init__(self, exp_bits: int, mantissa_bits: int, bias: int,</span>
<span class="gd">-        mxfp_overflow: str):</span>
<span class="gi">+    def __init__(self, exp_bits: int, mantissa_bits: int, bias: int, mxfp_overflow: str):</span>
<span class="w"> </span>        self.exp_bits = exp_bits
<span class="w"> </span>        self.mantissa_bits = mantissa_bits
<span class="w"> </span>        self.bias = bias
<span class="w"> </span>        self.mxfp_overflow = mxfp_overflow
<span class="gd">-        self.pos_clamp_value = (1 &lt;&lt; self.exp_bits + self.mantissa_bits) - 1</span>
<span class="gd">-        self.neg_clamp_value = (1 &lt;&lt; 1 + self.exp_bits + self.mantissa_bits</span>
<span class="gd">-            ) - 1</span>
<span class="gi">+</span>
<span class="gi">+        self.pos_clamp_value = (1 &lt;&lt; (self.exp_bits + self.mantissa_bits)) - 1</span>
<span class="gi">+        self.neg_clamp_value = (1 &lt;&lt; (1 + self.exp_bits + self.mantissa_bits)) - 1</span>
<span class="gi">+</span>
<span class="gi">+        # Special cases for e4m3 and e5m2</span>
<span class="w"> </span>        if self.exp_bits == 4 and self.mantissa_bits == 3:
<span class="w"> </span>            if self.mxfp_overflow == &#39;saturate&#39;:
<span class="gd">-                self.pos_clamp_value = 126</span>
<span class="gd">-                self.neg_clamp_value = 254</span>
<span class="gi">+                self.pos_clamp_value = 0b01111110  # 448</span>
<span class="gi">+                self.neg_clamp_value = 0b11111110  # -448</span>
<span class="w"> </span>            else:
<span class="gd">-                self.pos_clamp_value = self.neg_clamp_value = 255</span>
<span class="gi">+                self.pos_clamp_value = self.neg_clamp_value = 0b11111111  # NaN</span>
<span class="w"> </span>        if self.exp_bits == 5 and self.mantissa_bits == 2:
<span class="w"> </span>            if self.mxfp_overflow == &#39;saturate&#39;:
<span class="gd">-                self.pos_clamp_value = 123</span>
<span class="gd">-                self.neg_clamp_value = 251</span>
<span class="gi">+                self.pos_clamp_value = 0b01111011  # 57344</span>
<span class="gi">+                self.neg_clamp_value = 0b11111011  # -57344</span>
<span class="w"> </span>            else:
<span class="gd">-                self.pos_clamp_value = 124</span>
<span class="gd">-                self.neg_clamp_value = 252</span>
<span class="gi">+                self.pos_clamp_value = 0b01111100  # +inf</span>
<span class="gi">+                self.neg_clamp_value = 0b11111100  # -inf</span>
<span class="gi">+</span>
<span class="gi">+        # If we calculate these LUTs now it creates a bootstrap problem in generate_luts.py.</span>
<span class="w"> </span>        self.lut_float16_to_mxfp = None
<span class="w"> </span>        self.lut_int_to_float = None

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return (</span>
<span class="gd">-            f&quot;MXFPFormat(exp_bits={self.exp_bits}, mantissa_bits={self.mantissa_bits}, bias={self.bias}, mxfp_overflow=&#39;{self.mxfp_overflow}&#39;)&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;MXFPFormat(exp_bits={self.exp_bits}, mantissa_bits={self.mantissa_bits}, bias={self.bias}, mxfp_overflow=&#39;{self.mxfp_overflow}&#39;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def decompress_luts(self):</span>
<span class="gi">+        int_to_float_compressed, float16_to_mxfp_compressed = mxfp_luts_compressed[(self.exp_bits, self.mantissa_bits, self.bias, self.mxfp_overflow)]</span>
<span class="gi">+        self.lut_float16_to_mxfp = zlib.decompress(float16_to_mxfp_compressed)</span>
<span class="gi">+        dec = zlib.decompress(int_to_float_compressed)</span>
<span class="gi">+        self.lut_int_to_float = struct.unpack(f&#39;&lt;{len(dec) // 4}f&#39;, dec)</span>

<span class="gd">-    def float_to_int(self, f: float) -&gt;int:</span>
<span class="gi">+    def create_luts(self):</span>
<span class="gi">+        self.lut_int_to_float = self.createLUT_for_int_to_float()</span>
<span class="gi">+        self.lut_float16_to_mxfp = self.createLUT_for_float16_to_mxfp()</span>
<span class="gi">+</span>
<span class="gi">+    def float_to_int(self, f: float) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a Python float convert to the best mxfp float (expressed as an int) that represents it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First convert the float to a float16, then a 16 bit uint</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = struct.pack(&#39;&gt;e&#39;, f)</span>
<span class="gi">+        except (OverflowError, struct.error):</span>
<span class="gi">+            # Return the largest representable positive or negative value</span>
<span class="gi">+            return self.pos_clamp_value if f &gt; 0 else self.neg_clamp_value</span>
<span class="gi">+</span>
<span class="gi">+        f16_int = int.from_bytes(b, byteorder=&#39;big&#39;)</span>
<span class="gi">+        # Then use this as an index to our large LUT</span>
<span class="gi">+        return self.lut_float16_to_mxfp[f16_int]</span>

<span class="gd">-    def createLUT_for_int_to_float(self) -&gt;array.array:</span>
<span class="gi">+    def slow_float_to_int(self, f: float) -&gt; int:</span>
<span class="gi">+        # Slow, but easier to follow than the faster version.</span>
<span class="gi">+        # The output int has the binary sequence needed for the float.</span>
<span class="gi">+        length = 1 + self.exp_bits + self.mantissa_bits</span>
<span class="gi">+        values = 1 &lt;&lt; length</span>
<span class="gi">+        # First get the NaN case out of the way</span>
<span class="gi">+        if math.isnan(f):</span>
<span class="gi">+            if length == 8:</span>
<span class="gi">+                return 0xff  # Works for both e5m2 and e4m3</span>
<span class="gi">+            # For smaller lengths, NaN isn&#39;t supported so we instead return an invalid value to detect later</span>
<span class="gi">+            return 0xff</span>
<span class="gi">+        # This is so we can distinguish between 0.0 and -0.0</span>
<span class="gi">+        is_positive = math.copysign(1.0, f) == 1.0</span>
<span class="gi">+        if is_positive:</span>
<span class="gi">+            # Positive, so top bit is not set</span>
<span class="gi">+            for i in range(values // 2 - 1):</span>
<span class="gi">+                upper = self.lut_int_to_float[i + 1]</span>
<span class="gi">+                if upper == float(&#39;inf&#39;):</span>
<span class="gi">+                    break</span>
<span class="gi">+                x = round_to_nearest_ties_to_even(self.lut_int_to_float, i, f)</span>
<span class="gi">+                if x is not None:</span>
<span class="gi">+                    return x</span>
<span class="gi">+            return self.pos_clamp_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Negative, so top bit is set</span>
<span class="gi">+            for i in range(values // 2, values - 1):</span>
<span class="gi">+                lower = self.lut_int_to_float[i + 1]</span>
<span class="gi">+                if lower == float(&#39;-inf&#39;):</span>
<span class="gi">+                    break</span>
<span class="gi">+                x = round_to_nearest_ties_to_even(self.lut_int_to_float, i, f)</span>
<span class="gi">+                if x is not None:</span>
<span class="gi">+                    return x</span>
<span class="gi">+            # Clip to negative max</span>
<span class="gi">+            return self.neg_clamp_value</span>
<span class="gi">+</span>
<span class="gi">+    def createLUT_for_int_to_float(self) -&gt; array.array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert an int in representing a MXFP float into a Python float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i2f = []</span>
<span class="gi">+        length = 1 + self.exp_bits + self.mantissa_bits</span>
<span class="gi">+        for i in range(1 &lt;&lt; length):</span>
<span class="gi">+            b = bitarray.util.int2ba(i, length=length, endian=&#39;big&#39;, signed=False)</span>
<span class="gi">+            sign = b[0]</span>
<span class="gi">+            exponent = bitarray.util.ba2int(b[1:1 + self.exp_bits])</span>
<span class="gi">+            significand = b[1 + self.exp_bits:]</span>
<span class="gi">+            if exponent == 0:</span>
<span class="gi">+                significand = bitarray.bitarray(&#39;0&#39;) + significand</span>
<span class="gi">+                exponent = -self.bias + 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                significand = bitarray.bitarray(&#39;1&#39;) + significand</span>
<span class="gi">+                exponent -= self.bias</span>
<span class="gi">+            f = float(bitarray.util.ba2int(significand)) / (2.0 ** self.mantissa_bits)</span>
<span class="gi">+            f *= 2 ** exponent</span>
<span class="gi">+            if length == 8:</span>
<span class="gi">+                # Some special cases</span>
<span class="gi">+                if self.exp_bits == 5:</span>
<span class="gi">+                    if i in [0b01111100, 0b11111100]:</span>
<span class="gi">+                        f = float(&#39;inf&#39;)</span>
<span class="gi">+                    if i in [0b01111101, 0b11111101, 0b01111110, 0b11111110, 0b01111111, 0b11111111]:</span>
<span class="gi">+                        f = float(&#39;nan&#39;)</span>
<span class="gi">+                if self.exp_bits == 4:</span>
<span class="gi">+                    if i in [0b01111111, 0b11111111]:</span>
<span class="gi">+                        f = float(&#39;nan&#39;)</span>
<span class="gi">+            i2f.append(f if not sign else -f)</span>
<span class="gi">+        return array.array(&#39;f&#39;, i2f)</span>

<span class="gd">-    def createLUT_for_float16_to_mxfp(self) -&gt;bytes:</span>
<span class="gi">+    def createLUT_for_float16_to_mxfp(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert a float16 into a MXFP format&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-e2m1mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=1, bias=1,</span>
<span class="gd">-    mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gd">-e2m3mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=3, bias=1,</span>
<span class="gd">-    mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gd">-e3m2mxfp_fmt = MXFPFormat(exp_bits=3, mantissa_bits=2, bias=3,</span>
<span class="gd">-    mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gd">-e4m3mxfp_saturate_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7,</span>
<span class="gd">-    mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gd">-e5m2mxfp_saturate_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15,</span>
<span class="gd">-    mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gd">-e4m3mxfp_overflow_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7,</span>
<span class="gd">-    mxfp_overflow=&#39;overflow&#39;)</span>
<span class="gd">-e5m2mxfp_overflow_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15,</span>
<span class="gd">-    mxfp_overflow=&#39;overflow&#39;)</span>
<span class="gi">+        # Used to create the LUT that was compressed and stored for the fp8 code</span>
<span class="gi">+        length = 1 + self.exp_bits + self.mantissa_bits</span>
<span class="gi">+        if length == 8:</span>
<span class="gi">+            import gfloat</span>
<span class="gi">+            from gfloat.formats import format_info_ocp_e5m2, format_info_ocp_e4m3</span>
<span class="gi">+            fi = format_info_ocp_e5m2 if self.exp_bits == 5 else format_info_ocp_e4m3</span>
<span class="gi">+</span>
<span class="gi">+            fp16_to_fp8 = bytearray(1 &lt;&lt; 16)</span>
<span class="gi">+            for i in range(1 &lt;&lt; 16):</span>
<span class="gi">+                b = struct.pack(&#39;&gt;H&#39;, i)</span>
<span class="gi">+                f, = struct.unpack(&#39;&gt;e&#39;, b)</span>
<span class="gi">+                fp = gfloat.round_float(fi, f, sat=self.mxfp_overflow == &#39;saturate&#39;)</span>
<span class="gi">+                if math.isnan(fp):</span>
<span class="gi">+                    fp8_i = 0b11111111</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Special case for negative zero</span>
<span class="gi">+                    if fp == 0.0 and math.copysign(1.0, fp) == -1.0:</span>
<span class="gi">+                        fp8_i = 0b10000000</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        fp8_i = self.lut_int_to_float.index(fp)</span>
<span class="gi">+                fp16_to_fp8[i] = fp8_i</span>
<span class="gi">+            return bytes(fp16_to_fp8)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert length in [4, 6]</span>
<span class="gi">+            fp16_to_fp8 = bytearray(1 &lt;&lt; 16)</span>
<span class="gi">+            for i in range(1 &lt;&lt; 16):</span>
<span class="gi">+                b = struct.pack(&#39;&gt;H&#39;, i)</span>
<span class="gi">+                f, = struct.unpack(&#39;&gt;e&#39;, b)</span>
<span class="gi">+                fp8_i = self.slow_float_to_int(f)</span>
<span class="gi">+                fp16_to_fp8[i] = fp8_i</span>
<span class="gi">+            return bytes(fp16_to_fp8)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+e2m1mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=1, bias=1, mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gi">+e2m3mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=3, bias=1, mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gi">+e3m2mxfp_fmt = MXFPFormat(exp_bits=3, mantissa_bits=2, bias=3, mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gi">+e4m3mxfp_saturate_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7, mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gi">+e5m2mxfp_saturate_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15, mxfp_overflow=&#39;saturate&#39;)</span>
<span class="gi">+e4m3mxfp_overflow_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7, mxfp_overflow=&#39;overflow&#39;)</span>
<span class="gi">+e5m2mxfp_overflow_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15, mxfp_overflow=&#39;overflow&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decompress_luts():</span>
<span class="gi">+    e2m1mxfp_fmt.decompress_luts()</span>
<span class="gi">+    e2m3mxfp_fmt.decompress_luts()</span>
<span class="gi">+    e3m2mxfp_fmt.decompress_luts()</span>
<span class="gi">+    e4m3mxfp_saturate_fmt.decompress_luts()</span>
<span class="gi">+    e5m2mxfp_saturate_fmt.decompress_luts()</span>
<span class="gi">+    e4m3mxfp_overflow_fmt.decompress_luts()</span>
<span class="gi">+    e5m2mxfp_overflow_fmt.decompress_luts()</span>
<span class="gh">diff --git a/bitstring/utils.py b/bitstring/utils.py</span>
<span class="gh">index 623d69b..4dae4d9 100644</span>
<span class="gd">--- a/bitstring/utils.py</span>
<span class="gi">+++ b/bitstring/utils.py</span>
<span class="gu">@@ -1,47 +1,171 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import re
<span class="w"> </span>from typing import Tuple, List, Optional, Pattern, Dict, Union, Match
<span class="gd">-NAME_INT_RE: Pattern[str] = re.compile(&#39;^([a-zA-Z][a-zA-Z0-9_]*?):?(\\d*)$&#39;)</span>
<span class="gd">-NAME_KWARG_RE: Pattern[str] = re.compile(</span>
<span class="gd">-    &#39;^([a-zA-Z][a-zA-Z0-9_]*?):?([a-zA-Z0-9_]+)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# A token name followed by optional : then an integer number</span>
<span class="gi">+NAME_INT_RE: Pattern[str] = re.compile(r&#39;^([a-zA-Z][a-zA-Z0-9_]*?):?(\d*)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# A token name followed by optional : then an arbitrary keyword</span>
<span class="gi">+NAME_KWARG_RE: Pattern[str] = re.compile(r&#39;^([a-zA-Z][a-zA-Z0-9_]*?):?([a-zA-Z0-9_]+)$&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>CACHE_SIZE = 256
<span class="gd">-DEFAULT_BITS: Pattern[str] = re.compile(&#39;^(?P&lt;len&gt;[^=]+)?(=(?P&lt;value&gt;.*))?$&#39;,</span>
<span class="gd">-    re.IGNORECASE)</span>
<span class="gd">-MULTIPLICATIVE_RE: Pattern[str] = re.compile(&#39;^(?P&lt;factor&gt;.*)\\*(?P&lt;token&gt;.+)&#39;)</span>
<span class="gd">-LITERAL_RE: Pattern[str] = re.compile(&#39;^(?P&lt;name&gt;0([xob]))(?P&lt;value&gt;.+)&#39;,</span>
<span class="gd">-    re.IGNORECASE)</span>
<span class="gd">-STRUCT_PACK_RE: Pattern[str] = re.compile(</span>
<span class="gd">-    &#39;^(?P&lt;endian&gt;[&lt;&gt;@=])(?P&lt;fmt&gt;(?:\\d*[bBhHlLqQefd])+)$&#39;)</span>
<span class="gd">-BYTESWAP_STRUCT_PACK_RE: Pattern[str] = re.compile(</span>
<span class="gd">-    &#39;^(?P&lt;endian&gt;[&lt;&gt;@=])?(?P&lt;fmt&gt;(?:\\d*[bBhHlLqQefd])+)$&#39;)</span>
<span class="gd">-SINGLE_STRUCT_PACK_RE: Pattern[str] = re.compile(</span>
<span class="gd">-    &#39;^(?P&lt;endian&gt;[&lt;&gt;@=])(?P&lt;fmt&gt;[bBhHlLqQefd])$&#39;)</span>
<span class="gd">-STRUCT_SPLIT_RE: Pattern[str] = re.compile(&#39;\\d*[bBhHlLqQefd]&#39;)</span>
<span class="gd">-REPLACEMENTS_BE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;, &#39;h&#39;:</span>
<span class="gd">-    &#39;intbe16&#39;, &#39;H&#39;: &#39;uintbe16&#39;, &#39;l&#39;: &#39;intbe32&#39;, &#39;L&#39;: &#39;uintbe32&#39;, &#39;q&#39;:</span>
<span class="gd">-    &#39;intbe64&#39;, &#39;Q&#39;: &#39;uintbe64&#39;, &#39;e&#39;: &#39;floatbe16&#39;, &#39;f&#39;: &#39;floatbe32&#39;, &#39;d&#39;:</span>
<span class="gd">-    &#39;floatbe64&#39;}</span>
<span class="gd">-REPLACEMENTS_LE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;, &#39;h&#39;:</span>
<span class="gd">-    &#39;intle16&#39;, &#39;H&#39;: &#39;uintle16&#39;, &#39;l&#39;: &#39;intle32&#39;, &#39;L&#39;: &#39;uintle32&#39;, &#39;q&#39;:</span>
<span class="gd">-    &#39;intle64&#39;, &#39;Q&#39;: &#39;uintle64&#39;, &#39;e&#39;: &#39;floatle16&#39;, &#39;f&#39;: &#39;floatle32&#39;, &#39;d&#39;:</span>
<span class="gd">-    &#39;floatle64&#39;}</span>
<span class="gd">-REPLACEMENTS_NE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;, &#39;h&#39;:</span>
<span class="gd">-    &#39;intne16&#39;, &#39;H&#39;: &#39;uintne16&#39;, &#39;l&#39;: &#39;intne32&#39;, &#39;L&#39;: &#39;uintne32&#39;, &#39;q&#39;:</span>
<span class="gd">-    &#39;intne64&#39;, &#39;Q&#39;: &#39;uintne64&#39;, &#39;e&#39;: &#39;floatne16&#39;, &#39;f&#39;: &#39;floatne32&#39;, &#39;d&#39;:</span>
<span class="gd">-    &#39;floatne64&#39;}</span>
<span class="gd">-PACK_CODE_SIZE: Dict[str, int] = {&#39;b&#39;: 1, &#39;B&#39;: 1, &#39;h&#39;: 2, &#39;H&#39;: 2, &#39;l&#39;: 4,</span>
<span class="gd">-    &#39;L&#39;: 4, &#39;q&#39;: 8, &#39;Q&#39;: 8, &#39;e&#39;: 2, &#39;f&#39;: 4, &#39;d&#39;: 8}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def structparser(m: Match[str]) -&gt;List[str]:</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_BITS: Pattern[str] = re.compile(r&#39;^(?P&lt;len&gt;[^=]+)?(=(?P&lt;value&gt;.*))?$&#39;, re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+MULTIPLICATIVE_RE: Pattern[str] = re.compile(r&#39;^(?P&lt;factor&gt;.*)\*(?P&lt;token&gt;.+)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# Hex, oct or binary literals</span>
<span class="gi">+LITERAL_RE: Pattern[str] = re.compile(r&#39;^(?P&lt;name&gt;0([xob]))(?P&lt;value&gt;.+)&#39;, re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+# An endianness indicator followed by one or more struct.pack codes</span>
<span class="gi">+STRUCT_PACK_RE: Pattern[str] = re.compile(r&#39;^(?P&lt;endian&gt;[&lt;&gt;@=])(?P&lt;fmt&gt;(?:\d*[bBhHlLqQefd])+)$&#39;)</span>
<span class="gi">+# The same as above, but it doesn&#39;t insist on an endianness as it&#39;s byteswapping anyway.</span>
<span class="gi">+BYTESWAP_STRUCT_PACK_RE: Pattern[str] = re.compile(r&#39;^(?P&lt;endian&gt;[&lt;&gt;@=])?(?P&lt;fmt&gt;(?:\d*[bBhHlLqQefd])+)$&#39;)</span>
<span class="gi">+# An endianness indicator followed by exactly one struct.pack codes</span>
<span class="gi">+SINGLE_STRUCT_PACK_RE: Pattern[str] = re.compile(r&#39;^(?P&lt;endian&gt;[&lt;&gt;@=])(?P&lt;fmt&gt;[bBhHlLqQefd])$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# A number followed by a single character struct.pack code</span>
<span class="gi">+STRUCT_SPLIT_RE: Pattern[str] = re.compile(r&#39;\d*[bBhHlLqQefd]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# These replicate the struct.pack codes</span>
<span class="gi">+# Big-endian</span>
<span class="gi">+REPLACEMENTS_BE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;,</span>
<span class="gi">+                                   &#39;h&#39;: &#39;intbe16&#39;, &#39;H&#39;: &#39;uintbe16&#39;,</span>
<span class="gi">+                                   &#39;l&#39;: &#39;intbe32&#39;, &#39;L&#39;: &#39;uintbe32&#39;,</span>
<span class="gi">+                                   &#39;q&#39;: &#39;intbe64&#39;, &#39;Q&#39;: &#39;uintbe64&#39;,</span>
<span class="gi">+                                   &#39;e&#39;: &#39;floatbe16&#39;, &#39;f&#39;: &#39;floatbe32&#39;, &#39;d&#39;: &#39;floatbe64&#39;}</span>
<span class="gi">+# Little-endian</span>
<span class="gi">+REPLACEMENTS_LE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;,</span>
<span class="gi">+                                   &#39;h&#39;: &#39;intle16&#39;, &#39;H&#39;: &#39;uintle16&#39;,</span>
<span class="gi">+                                   &#39;l&#39;: &#39;intle32&#39;, &#39;L&#39;: &#39;uintle32&#39;,</span>
<span class="gi">+                                   &#39;q&#39;: &#39;intle64&#39;, &#39;Q&#39;: &#39;uintle64&#39;,</span>
<span class="gi">+                                   &#39;e&#39;: &#39;floatle16&#39;, &#39;f&#39;: &#39;floatle32&#39;, &#39;d&#39;: &#39;floatle64&#39;}</span>
<span class="gi">+</span>
<span class="gi">+# Native-endian</span>
<span class="gi">+REPLACEMENTS_NE: Dict[str, str] = {&#39;b&#39;: &#39;int8&#39;, &#39;B&#39;: &#39;uint8&#39;,</span>
<span class="gi">+                                   &#39;h&#39;: &#39;intne16&#39;, &#39;H&#39;: &#39;uintne16&#39;,</span>
<span class="gi">+                                   &#39;l&#39;: &#39;intne32&#39;, &#39;L&#39;: &#39;uintne32&#39;,</span>
<span class="gi">+                                   &#39;q&#39;: &#39;intne64&#39;, &#39;Q&#39;: &#39;uintne64&#39;,</span>
<span class="gi">+                                   &#39;e&#39;: &#39;floatne16&#39;, &#39;f&#39;: &#39;floatne32&#39;, &#39;d&#39;: &#39;floatne64&#39;}</span>
<span class="gi">+</span>
<span class="gi">+# Size in bytes of all the pack codes.</span>
<span class="gi">+PACK_CODE_SIZE: Dict[str, int] = {&#39;b&#39;: 1, &#39;B&#39;: 1, &#39;h&#39;: 2, &#39;H&#39;: 2, &#39;l&#39;: 4, &#39;L&#39;: 4,</span>
<span class="gi">+                                  &#39;q&#39;: 8, &#39;Q&#39;: 8, &#39;e&#39;: 2, &#39;f&#39;: 4, &#39;d&#39;: 8}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def structparser(m: Match[str]) -&gt; List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse struct-like format string token into sub-token list.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    endian = m.group(&#39;endian&#39;)</span>
<span class="gi">+    # Split the format string into a list of &#39;q&#39;, &#39;4h&#39; etc.</span>
<span class="gi">+    formatlist = re.findall(STRUCT_SPLIT_RE, m.group(&#39;fmt&#39;))</span>
<span class="gi">+    # Now deal with multiplicative factors, 4h -&gt; hhhh etc.</span>
<span class="gi">+    fmt = &#39;&#39;.join([f[-1] * int(f[:-1]) if len(f) != 1 else</span>
<span class="gi">+                   f for f in formatlist])</span>
<span class="gi">+    if endian in &#39;@=&#39;:</span>
<span class="gi">+        # Native endianness</span>
<span class="gi">+        tokens = [REPLACEMENTS_NE[c] for c in fmt]</span>
<span class="gi">+    elif endian == &#39;&lt;&#39;:</span>
<span class="gi">+        tokens = [REPLACEMENTS_LE[c] for c in fmt]</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert endian == &#39;&gt;&#39;</span>
<span class="gi">+        tokens = [REPLACEMENTS_BE[c] for c in fmt]</span>
<span class="gi">+    return tokens</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+def parse_name_length_token(fmt: str, **kwargs) -&gt; Tuple[str, Optional[int]]:</span>
<span class="gi">+    # Any single token with just a name and length</span>
<span class="gi">+    if m2 := NAME_INT_RE.match(fmt):</span>
<span class="gi">+        name = m2.group(1)</span>
<span class="gi">+        length_str = m2.group(2)</span>
<span class="gi">+        length = None if length_str == &#39;&#39; else int(length_str)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Maybe the length is in the kwargs?</span>
<span class="gi">+        if m := NAME_KWARG_RE.match(fmt):</span>
<span class="gi">+            name = m.group(1)</span>
<span class="gi">+            try:</span>
<span class="gi">+                length_str = kwargs[m.group(2)]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise ValueError(f&quot;Can&#39;t parse &#39;name[:]length&#39; token &#39;{fmt}&#39;.&quot;)</span>
<span class="gi">+            length = int(length_str)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Can&#39;t parse &#39;name[:]length&#39; token &#39;{fmt}&#39;.&quot;)</span>
<span class="gi">+    return name, length</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+def parse_single_struct_token(fmt: str) -&gt; Optional[Tuple[str, Optional[int]]]:</span>
<span class="gi">+    if m := SINGLE_STRUCT_PACK_RE.match(fmt):</span>
<span class="gi">+        endian = m.group(&#39;endian&#39;)</span>
<span class="gi">+        f = m.group(&#39;fmt&#39;)</span>
<span class="gi">+        if endian == &#39;&gt;&#39;:</span>
<span class="gi">+            fmt = REPLACEMENTS_BE[f]</span>
<span class="gi">+        elif endian == &#39;&lt;&#39;:</span>
<span class="gi">+            fmt = REPLACEMENTS_LE[f]</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert endian in &#39;=@&#39;</span>
<span class="gi">+            fmt = REPLACEMENTS_NE[f]</span>
<span class="gi">+        return parse_name_length_token(fmt)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+def parse_single_token(token: str) -&gt; Tuple[str, str, Optional[str]]:</span>
<span class="gi">+    if (equals_pos := token.find(&#39;=&#39;)) == -1:</span>
<span class="gi">+        value = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        value = token[equals_pos + 1:]</span>
<span class="gi">+        token = token[:equals_pos]</span>
<span class="gi">+</span>
<span class="gi">+    if m2 := NAME_INT_RE.match(token):</span>
<span class="gi">+        name = m2.group(1)</span>
<span class="gi">+        length_str = m2.group(2)</span>
<span class="gi">+        length = None if length_str == &#39;&#39; else length_str</span>
<span class="gi">+    elif m3 := NAME_KWARG_RE.match(token):</span>
<span class="gi">+        # name then a keyword for a length</span>
<span class="gi">+        name = m3.group(1)</span>
<span class="gi">+        length = m3.group(2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If you don&#39;t specify a &#39;name&#39; then the default is &#39;bits&#39;</span>
<span class="gi">+        name = &#39;bits&#39;</span>
<span class="gi">+        length = token</span>
<span class="gi">+    return name, length, value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@functools.lru_cache(CACHE_SIZE)</span>
<span class="gi">+def preprocess_tokens(fmt: str) -&gt; List[str]:</span>
<span class="gi">+    # Remove whitespace and expand brackets</span>
<span class="gi">+    fmt = expand_brackets(&#39;&#39;.join(fmt.split()))</span>
<span class="gi">+</span>
<span class="gi">+    # Split tokens by &#39;,&#39; and remove whitespace</span>
<span class="gi">+    # The meta_tokens can either be ordinary single tokens or multiple struct-format token strings.</span>
<span class="gi">+    meta_tokens = [f.strip() for f in fmt.split(&#39;,&#39;)]</span>
<span class="gi">+    final_tokens = []</span>
<span class="gi">+</span>
<span class="gi">+    for meta_token in meta_tokens:</span>
<span class="gi">+        if meta_token == &#39;&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        # Extract factor and actual token if a multiplicative factor exists</span>
<span class="gi">+        factor = 1</span>
<span class="gi">+        if m := MULTIPLICATIVE_RE.match(meta_token):</span>
<span class="gi">+            factor = int(m.group(&#39;factor&#39;))</span>
<span class="gi">+            meta_token = m.group(&#39;token&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Parse struct-like format into sub-tokens or treat as single token</span>
<span class="gi">+        tokens = structparser(m) if (m := STRUCT_PACK_RE.match(meta_token)) else [meta_token]</span>
<span class="gi">+</span>
<span class="gi">+        # Extend final tokens list with parsed tokens, repeated by the factor</span>
<span class="gi">+        final_tokens.extend(tokens * factor)</span>
<span class="gi">+    return final_tokens</span>


<span class="w"> </span>@functools.lru_cache(CACHE_SIZE)
<span class="gd">-def tokenparser(fmt: str, keys: Tuple[str, ...]=()) -&gt;Tuple[bool, List[</span>
<span class="gd">-    Tuple[str, Union[int, str, None], Optional[str]]]]:</span>
<span class="gi">+def tokenparser(fmt: str, keys: Tuple[str, ...] = ()) -&gt; \</span>
<span class="gi">+        Tuple[bool, List[Tuple[str, Union[int, str, None], Optional[str]]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Divide the format string into tokens and parse them.

<span class="w"> </span>    Return stretchy token and list of [initialiser, length, value]
<span class="gu">@@ -54,12 +178,61 @@ def tokenparser(fmt: str, keys: Tuple[str, ...]=()) -&gt;Tuple[bool, List[</span>
<span class="w"> </span>    tokens must be of the form: [factor*][initialiser][:][length][=value]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tokens = preprocess_tokens(fmt)</span>
<span class="gi">+    stretchy_token = False</span>
<span class="gi">+    ret_vals: List[Tuple[str, Union[str, int, None], Optional[str]]] = []</span>
<span class="gi">+    for token in tokens:</span>
<span class="gi">+        if keys and token in keys:</span>
<span class="gi">+            # Don&#39;t bother parsing it, it&#39;s a keyword argument</span>
<span class="gi">+            ret_vals.append((token, None, None))</span>
<span class="gi">+            continue</span>
<span class="gi">+        if token == &#39;&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        # Match literal tokens of the form 0x... 0o... and 0b...</span>
<span class="gi">+        if m := LITERAL_RE.match(token):</span>
<span class="gi">+            ret_vals.append((m.group(&#39;name&#39;), None, m.group(&#39;value&#39;)))</span>
<span class="gi">+            continue</span>
<span class="gi">+        name, length, value = parse_single_token(token)</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            stretchy_token = True</span>
<span class="gi">+        if length is not None:</span>
<span class="gi">+            # Try converting length to int, otherwise check it&#39;s a key.</span>
<span class="gi">+            try:</span>
<span class="gi">+                length = int(length)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                if not keys or length not in keys:</span>
<span class="gi">+                    raise ValueError(f&quot;Don&#39;t understand length &#39;{length}&#39; of token.&quot;)</span>
<span class="gi">+        ret_vals.append((name, length, value))</span>
<span class="gi">+    return stretchy_token, ret_vals</span>


<span class="gd">-BRACKET_RE = re.compile(&#39;(?P&lt;factor&gt;\\d+)\\*\\(&#39;)</span>
<span class="gi">+BRACKET_RE = re.compile(r&#39;(?P&lt;factor&gt;\d+)\*\(&#39;)</span>


<span class="gd">-def expand_brackets(s: str) -&gt;str:</span>
<span class="gi">+def expand_brackets(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Expand all brackets.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        start = s.find(&#39;(&#39;)</span>
<span class="gi">+        if start == -1:</span>
<span class="gi">+            break</span>
<span class="gi">+        count = 1  # Number of hanging open brackets</span>
<span class="gi">+        p = start + 1</span>
<span class="gi">+        while p &lt; len(s):</span>
<span class="gi">+            count += (s[p] == &#39;(&#39;) - (s[p] == &#39;)&#39;)</span>
<span class="gi">+            if count == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            p += 1</span>
<span class="gi">+        if count != 0:</span>
<span class="gi">+            raise ValueError(f&quot;Unbalanced parenthesis in &#39;{s}&#39;.&quot;)</span>
<span class="gi">+        if start == 0 or s[start - 1] != &#39;*&#39;:</span>
<span class="gi">+            s = s[0:start] + s[start + 1:p] + s[p + 1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Looks for first number*(</span>
<span class="gi">+            m = BRACKET_RE.search(s)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                factor = int(m.group(&#39;factor&#39;))</span>
<span class="gi">+                matchstart = m.start(&#39;factor&#39;)</span>
<span class="gi">+                s = s[0:matchstart] + (factor - 1) * (s[start + 1:p] + &#39;,&#39;) + s[start + 1:p] + s[p + 1:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Failed to parse &#39;{s}&#39;.&quot;)</span>
<span class="gi">+    return s</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>