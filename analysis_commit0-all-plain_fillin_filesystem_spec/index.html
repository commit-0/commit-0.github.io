
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin filesystem spec - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-filesystem_spec" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin filesystem spec
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-filesystem_spec"><strong>Claude Sonnet 3.5 - Fill-in</strong>: filesystem_spec</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/fsspec/conftest.py&#39;.
fsspec/__init__.py:6: in &lt;module&gt;
    from .compression import available_compressions
fsspec/compression.py:4: in &lt;module&gt;
    from fsspec.spec import AbstractBufferedFile
fsspec/spec.py:17: in &lt;module&gt;
    from .utils import _unstrip_protocol, glob_translate, isfilelike, other_paths, read_block, stringify_path, tokenize
E   ImportError: cannot import name &#39;_unstrip_protocol&#39; from &#39;fsspec.utils&#39; (/testbed/fsspec/utils.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/fsspec/archive.py b/fsspec/archive.py</span>
<span class="gh">index 1a4570f..7ae4806 100644</span>
<span class="gd">--- a/fsspec/archive.py</span>
<span class="gi">+++ b/fsspec/archive.py</span>
<span class="gu">@@ -23,5 +23,15 @@ class AbstractArchiveFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        Parameters
<span class="w"> </span>        ----------
<span class="w"> </span>        paths: Iterable of path strings
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        set</span>
<span class="gi">+            A set of all unique directory names</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dirnames = set()</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            parts = path.split(&#39;/&#39;)</span>
<span class="gi">+            for i in range(1, len(parts)):</span>
<span class="gi">+                dirnames.add(&#39;/&#39;.join(parts[:i]))</span>
<span class="gi">+        return dirnames</span>
<span class="gh">diff --git a/fsspec/asyn.py b/fsspec/asyn.py</span>
<span class="gh">index 551290c..1f44155 100644</span>
<span class="gd">--- a/fsspec/asyn.py</span>
<span class="gi">+++ b/fsspec/asyn.py</span>
<span class="gu">@@ -27,7 +27,10 @@ def get_lock():</span>

<span class="w"> </span>    The lock is allocated on first use to allow setting one lock per forked process.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _lock</span>
<span class="gi">+    if _lock is None:</span>
<span class="gi">+        _lock = threading.Lock()</span>
<span class="gi">+    return _lock</span>


<span class="w"> </span>def reset_lock():
<span class="gu">@@ -36,7 +39,8 @@ def reset_lock():</span>
<span class="w"> </span>    This should be called only on the init of a forked process to reset the lock to
<span class="w"> </span>    None, enabling the new forked process to get a new lock.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _lock</span>
<span class="gi">+    _lock = None</span>


<span class="w"> </span>def sync(loop, func, *args, timeout=None, **kwargs):
<span class="gu">@@ -48,7 +52,29 @@ def sync(loop, func, *args, timeout=None, **kwargs):</span>
<span class="w"> </span>    &gt;&gt;&gt; fsspec.asyn.sync(fsspec.asyn.get_loop(), func, *args,
<span class="w"> </span>                         timeout=timeout, **kwargs)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    e = threading.Event()</span>
<span class="gi">+    result = [None]</span>
<span class="gi">+    error = [False]</span>
<span class="gi">+</span>
<span class="gi">+    async def f():</span>
<span class="gi">+        try:</span>
<span class="gi">+            result[0] = await func(*args, **kwargs)</span>
<span class="gi">+        except Exception as ex:</span>
<span class="gi">+            result[0] = ex</span>
<span class="gi">+            error[0] = True</span>
<span class="gi">+        finally:</span>
<span class="gi">+            e.set()</span>
<span class="gi">+</span>
<span class="gi">+    asyncio.run_coroutine_threadsafe(f(), loop)</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        if not e.wait(timeout):</span>
<span class="gi">+            raise FSTimeoutError(&quot;Timed out after %s seconds&quot; % timeout)</span>
<span class="gi">+    else:</span>
<span class="gi">+        e.wait()</span>
<span class="gi">+</span>
<span class="gi">+    if error[0]:</span>
<span class="gi">+        raise result[0]</span>
<span class="gi">+    return result[0]</span>


<span class="w"> </span>def sync_wrapper(func, obj=None):
<span class="gu">@@ -57,7 +83,11 @@ def sync_wrapper(func, obj=None):</span>
<span class="w"> </span>    Leave obj=None if defining within a class. Pass the instance if attaching
<span class="w"> </span>    as an attribute of the instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @functools.wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        self = obj or args[0]</span>
<span class="gi">+        return sync(self.loop, func, *args, **kwargs)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>def get_loop():
<span class="gu">@@ -65,7 +95,14 @@ def get_loop():</span>

<span class="w"> </span>    The loop will be running on a separate thread.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if loop[0] is None:</span>
<span class="gi">+        with get_lock():</span>
<span class="gi">+            if loop[0] is None:</span>
<span class="gi">+                loop[0] = asyncio.new_event_loop()</span>
<span class="gi">+                th = threading.Thread(target=loop[0].run_forever, daemon=True)</span>
<span class="gi">+                th.start()</span>
<span class="gi">+                iothread[0] = th</span>
<span class="gi">+    return loop[0]</span>


<span class="w"> </span>if TYPE_CHECKING:
<span class="gu">@@ -83,9 +120,13 @@ _DEFAULT_BATCH_SIZE = 128</span>
<span class="w"> </span>_NOFILES_DEFAULT_BATCH_SIZE = 1280


<span class="gd">-def running_async() -&gt;bool:</span>
<span class="gi">+def running_async() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Being executed by an event loop?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        asyncio.get_running_loop()</span>
<span class="gi">+        return True</span>
<span class="gi">+    except RuntimeError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>async def _run_coros_in_chunks(coros, batch_size=None, callback=
<span class="gh">diff --git a/fsspec/caching.py b/fsspec/caching.py</span>
<span class="gh">index c4fc674..e8a7ba5 100644</span>
<span class="gd">--- a/fsspec/caching.py</span>
<span class="gi">+++ b/fsspec/caching.py</span>
<span class="gu">@@ -47,11 +47,15 @@ class BaseCache:</span>

<span class="w"> </span>    def _reset_stats(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reset hit and miss counts for a more ganular report e.g. by file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.hit_count = 0</span>
<span class="gi">+        self.miss_count = 0</span>
<span class="gi">+        self.total_requested_bytes = 0</span>

<span class="w"> </span>    def _log_stats(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a formatted string of the cache statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (f&quot;Cache hits: {self.hit_count}, &quot;</span>
<span class="gi">+                f&quot;Cache misses: {self.miss_count}, &quot;</span>
<span class="gi">+                f&quot;Total requested bytes: {self.total_requested_bytes}&quot;)</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&quot;&quot;&quot;
<span class="gu">@@ -164,7 +168,7 @@ class BlockCache(BaseCache):</span>
<span class="w"> </span>        NamedTuple
<span class="w"> </span>            Returned directly from the LRU Cache used internally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._fetch_block_cached.cache_info()</span>

<span class="w"> </span>    def __getstate__(self) -&gt;dict[str, Any]:
<span class="w"> </span>        state = self.__dict__
<span class="gu">@@ -180,7 +184,9 @@ class BlockCache(BaseCache):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch the block of data for `block_number`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = block_number * self.blocksize</span>
<span class="gi">+        end = min(start + self.blocksize, self.size)</span>
<span class="gi">+        return self.fetcher(start, end)</span>

<span class="w"> </span>    def _read_cache(self, start: int, end: int, start_block_number: int,
<span class="w"> </span>        end_block_number: int) -&gt;bytes:
<span class="gu">@@ -194,7 +200,21 @@ class BlockCache(BaseCache):</span>
<span class="w"> </span>        start_block_number, end_block_number : int
<span class="w"> </span>            The start and end block numbers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if start_block_number == end_block_number:</span>
<span class="gi">+            block = self._fetch_block_cached(start_block_number)</span>
<span class="gi">+            return block[start % self.blocksize:end % self.blocksize or None]</span>
<span class="gi">+        </span>
<span class="gi">+        parts = []</span>
<span class="gi">+        for block_number in range(start_block_number, end_block_number + 1):</span>
<span class="gi">+            block = self._fetch_block_cached(block_number)</span>
<span class="gi">+            if block_number == start_block_number:</span>
<span class="gi">+                parts.append(block[start % self.blocksize:])</span>
<span class="gi">+            elif block_number == end_block_number:</span>
<span class="gi">+                parts.append(block[:end % self.blocksize or None])</span>
<span class="gi">+            else:</span>
<span class="gi">+                parts.append(block)</span>
<span class="gi">+        </span>
<span class="gi">+        return b&#39;&#39;.join(parts)</span>


<span class="w"> </span>class BytesCache(BaseCache):
<span class="gu">@@ -369,7 +389,7 @@ class BackgroundBlockCache(BaseCache):</span>
<span class="w"> </span>        NamedTuple
<span class="w"> </span>            Returned directly from the LRU Cache used internally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._fetch_block_cached.cache_info()</span>

<span class="w"> </span>    def __getstate__(self) -&gt;dict[str, Any]:
<span class="w"> </span>        state = self.__dict__
<span class="gu">@@ -393,7 +413,25 @@ class BackgroundBlockCache(BaseCache):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch the block of data for `block_number`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = block_number * self.blocksize</span>
<span class="gi">+        end = min(start + self.blocksize, self.size)</span>
<span class="gi">+        logger.debug(f&quot;Fetching block {block_number} ({log_info})&quot;)</span>
<span class="gi">+        data = self.fetcher(start, end)</span>
<span class="gi">+        </span>
<span class="gi">+        with self._fetch_future_lock:</span>
<span class="gi">+            if (self._fetch_future_block_number is not None and </span>
<span class="gi">+                self._fetch_future_block_number != block_number + 1):</span>
<span class="gi">+                self._fetch_future.cancel()</span>
<span class="gi">+                self._fetch_future = None</span>
<span class="gi">+                self._fetch_future_block_number = None</span>
<span class="gi">+            </span>
<span class="gi">+            if self._fetch_future_block_number is None and block_number + 1 &lt; self.nblocks:</span>
<span class="gi">+                self._fetch_future_block_number = block_number + 1</span>
<span class="gi">+                self._fetch_future = self._thread_executor.submit(</span>
<span class="gi">+                    self._fetch_block, block_number + 1, &#39;async&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+        </span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def _read_cache(self, start: int, end: int, start_block_number: int,
<span class="w"> </span>        end_block_number: int) -&gt;bytes:
<span class="gu">@@ -407,7 +445,21 @@ class BackgroundBlockCache(BaseCache):</span>
<span class="w"> </span>        start_block_number, end_block_number : int
<span class="w"> </span>            The start and end block numbers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if start_block_number == end_block_number:</span>
<span class="gi">+            block = self._fetch_block_cached(start_block_number)</span>
<span class="gi">+            return block[start % self.blocksize:end % self.blocksize or None]</span>
<span class="gi">+        </span>
<span class="gi">+        parts = []</span>
<span class="gi">+        for block_number in range(start_block_number, end_block_number + 1):</span>
<span class="gi">+            block = self._fetch_block_cached(block_number)</span>
<span class="gi">+            if block_number == start_block_number:</span>
<span class="gi">+                parts.append(block[start % self.blocksize:])</span>
<span class="gi">+            elif block_number == end_block_number:</span>
<span class="gi">+                parts.append(block[:end % self.blocksize or None])</span>
<span class="gi">+            else:</span>
<span class="gi">+                parts.append(block)</span>
<span class="gi">+        </span>
<span class="gi">+        return b&#39;&#39;.join(parts)</span>


<span class="w"> </span>caches: dict[str | None, type[BaseCache]] = {None: BaseCache}
<span class="gu">@@ -426,7 +478,9 @@ def register_cache(cls: type[BaseCache], clobber: bool=False) -&gt;None:</span>
<span class="w"> </span>    ------
<span class="w"> </span>    ValueError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cls.name in caches and not clobber:</span>
<span class="gi">+        raise ValueError(f&quot;Cache {cls.name} already exists, use clobber=True to overwrite&quot;)</span>
<span class="gi">+    caches[cls.name] = cls</span>


<span class="w"> </span>for c in (BaseCache, MMapCache, BytesCache, ReadAheadCache, BlockCache,
<span class="gh">diff --git a/fsspec/callbacks.py b/fsspec/callbacks.py</span>
<span class="gh">index fd7312d..58de20f 100644</span>
<span class="gd">--- a/fsspec/callbacks.py</span>
<span class="gi">+++ b/fsspec/callbacks.py</span>
<span class="gu">@@ -36,7 +36,7 @@ class Callback:</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close callback.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.call(hook_name=&quot;close&quot;)</span>

<span class="w"> </span>    def branched(self, path_1, path_2, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -67,13 +67,20 @@ class Callback:</span>
<span class="w"> </span>        callback: Callback
<span class="w"> </span>            A callback instance to be passed to the child method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_kwargs = kwargs.copy()</span>
<span class="gi">+        self.branch(path_1, path_2, new_kwargs)</span>
<span class="gi">+        return new_kwargs.get(&#39;callback&#39;, self)</span>

<span class="w"> </span>    def branch_coro(self, fn):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wraps a coroutine, and pass a new child callback to it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        @wraps(fn)</span>
<span class="gi">+        async def wrapper(*args, **kwargs):</span>
<span class="gi">+            new_callback = self.branched(None, None)</span>
<span class="gi">+            kwargs[&#39;callback&#39;] = new_callback</span>
<span class="gi">+            return await fn(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>

<span class="w"> </span>    def set_size(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -86,7 +93,8 @@ class Callback:</span>
<span class="w"> </span>        ----------
<span class="w"> </span>        size: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.size = size</span>
<span class="gi">+        self.call()</span>

<span class="w"> </span>    def absolute_update(self, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -98,7 +106,8 @@ class Callback:</span>
<span class="w"> </span>        ----------
<span class="w"> </span>        value: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.value = value</span>
<span class="gi">+        self.call()</span>

<span class="w"> </span>    def relative_update(self, inc=1):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -110,7 +119,8 @@ class Callback:</span>
<span class="w"> </span>        ----------
<span class="w"> </span>        inc: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.value += inc</span>
<span class="gi">+        self.call()</span>

<span class="w"> </span>    def call(self, hook_name=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -124,7 +134,11 @@ class Callback:</span>
<span class="w"> </span>            If given, execute on this hook
<span class="w"> </span>        kwargs: passed on to (all) hook(s)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hook_name is not None and hook_name in self.hooks:</span>
<span class="gi">+            self.hooks[hook_name](self.size, self.value, **self.kw, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for hook in self.hooks.values():</span>
<span class="gi">+                hook(self.size, self.value, **self.kw, **kwargs)</span>

<span class="w"> </span>    def wrap(self, iterable):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -135,7 +149,9 @@ class Callback:</span>
<span class="w"> </span>        iterable: Iterable
<span class="w"> </span>            The iterable that is being wrapped
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in iterable:</span>
<span class="gi">+            yield item</span>
<span class="gi">+            self.relative_update()</span>

<span class="w"> </span>    def branch(self, path_1, path_2, kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -159,7 +175,8 @@ class Callback:</span>
<span class="w"> </span>        -------

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # By default, use the same callback instance for child transfers</span>
<span class="gi">+        kwargs[&#39;callback&#39;] = self</span>

<span class="w"> </span>    def __getattr__(self, item):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -175,7 +192,12 @@ class Callback:</span>
<span class="w"> </span>        ``NoOpCallback``. This is an alternative to including
<span class="w"> </span>        ``callback=DEFAULT_CALLBACK`` directly in a method signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if maybe_callback is None:</span>
<span class="gi">+            return DEFAULT_CALLBACK</span>
<span class="gi">+        elif isinstance(maybe_callback, Callback):</span>
<span class="gi">+            return maybe_callback</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cls(maybe_callback)</span>


<span class="w"> </span>class NoOpCallback(Callback):
<span class="gu">@@ -198,11 +220,11 @@ class DotPrinterCallback(Callback):</span>

<span class="w"> </span>    def branch(self, path_1, path_2, kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Mutate kwargs to add new instance with different print char&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs[&#39;callback&#39;] = DotPrinterCallback(chr_to_print=&#39;.&#39;)</span>

<span class="w"> </span>    def call(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Just outputs a character&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(self.chr, end=&#39;&#39;, flush=True)</span>


<span class="w"> </span>class TqdmCallback(Callback):
<span class="gu">@@ -275,7 +297,30 @@ class TqdmCallback(Callback):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="w"> </span>    def __del__(self):
<span class="gd">-        return self.close()</span>
<span class="gi">+        self.close()</span>
<span class="gi">+        </span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if self.tqdm is not None:</span>
<span class="gi">+            self.tqdm.close()</span>
<span class="gi">+            self.tqdm = None</span>
<span class="gi">+</span>
<span class="gi">+    def set_size(self, size):</span>
<span class="gi">+        self.size = size</span>
<span class="gi">+        if self.tqdm is None:</span>
<span class="gi">+            self.tqdm = self._tqdm_cls(total=size, **self._tqdm_kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.tqdm.reset(total=size)</span>
<span class="gi">+</span>
<span class="gi">+    def absolute_update(self, value):</span>
<span class="gi">+        if self.tqdm is None:</span>
<span class="gi">+            self.tqdm = self._tqdm_cls(total=self.size, **self._tqdm_kwargs)</span>
<span class="gi">+        self.tqdm.n = value</span>
<span class="gi">+        self.tqdm.refresh()</span>
<span class="gi">+</span>
<span class="gi">+    def relative_update(self, inc=1):</span>
<span class="gi">+        if self.tqdm is None:</span>
<span class="gi">+            self.tqdm = self._tqdm_cls(total=self.size, **self._tqdm_kwargs)</span>
<span class="gi">+        self.tqdm.update(inc)</span>


<span class="w"> </span>DEFAULT_CALLBACK = _DEFAULT_CALLBACK = NoOpCallback()
<span class="gh">diff --git a/fsspec/compression.py b/fsspec/compression.py</span>
<span class="gh">index 9562369..216c3f6 100644</span>
<span class="gd">--- a/fsspec/compression.py</span>
<span class="gi">+++ b/fsspec/compression.py</span>
<span class="gu">@@ -25,7 +25,20 @@ def register_compression(name, callback, extensions, force=False):</span>
<span class="w"> </span>        ValueError: If name or extensions already registered, and not force.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global compr</span>
<span class="gi">+    if name in compr and not force:</span>
<span class="gi">+        raise ValueError(f&quot;Compression {name} already registered&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(extensions, str):</span>
<span class="gi">+        extensions = [extensions]</span>
<span class="gi">+    </span>
<span class="gi">+    for ext in extensions:</span>
<span class="gi">+        if ext in fsspec.utils.compressions and not force:</span>
<span class="gi">+            raise ValueError(f&quot;Extension {ext} already registered&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    compr[name] = callback</span>
<span class="gi">+    for ext in extensions:</span>
<span class="gi">+        fsspec.utils.compressions[ext] = name</span>


<span class="w"> </span>register_compression(&#39;zip&#39;, unzip, &#39;zip&#39;)
<span class="gu">@@ -70,7 +83,21 @@ class SnappyFile(AbstractBufferedFile):</span>

<span class="w"> </span>    def _fetch_range(self, start, end):
<span class="w"> </span>        &quot;&quot;&quot;Get the specified set of bytes from remote&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if start is not None or end is not None:</span>
<span class="gi">+            raise ValueError(&quot;Range fetching not supported with Snappy compression&quot;)</span>
<span class="gi">+        return self.infile.read()</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, length=-1):</span>
<span class="gi">+        return self.codec.decompress(self.infile.read(length))</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data):</span>
<span class="gi">+        compressed = self.codec.compress(data)</span>
<span class="gi">+        return self.infile.write(compressed)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if hasattr(self.infile, &#39;close&#39;):</span>
<span class="gi">+            self.infile.close()</span>
<span class="gi">+        super().close()</span>


<span class="w"> </span>try:
<span class="gu">@@ -93,4 +120,4 @@ except ImportError:</span>

<span class="w"> </span>def available_compressions():
<span class="w"> </span>    &quot;&quot;&quot;Return a list of the implemented compressions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(compr.keys())</span>
<span class="gh">diff --git a/fsspec/config.py b/fsspec/config.py</span>
<span class="gh">index 00a7d90..6b5ec42 100644</span>
<span class="gd">--- a/fsspec/config.py</span>
<span class="gi">+++ b/fsspec/config.py</span>
<span class="gu">@@ -28,7 +28,21 @@ def set_conf_env(conf_dict, envdict=os.environ):</span>
<span class="w"> </span>    envdict : dict-like(str, str)
<span class="w"> </span>        Source for the values - usually the real environment
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for key, value in envdict.items():</span>
<span class="gi">+        if key.startswith(&quot;FSSPEC_&quot;):</span>
<span class="gi">+            parts = key.split(&quot;_&quot;)</span>
<span class="gi">+            if len(parts) == 2:</span>
<span class="gi">+                # FSSPEC_&lt;protocol&gt;</span>
<span class="gi">+                protocol = parts[1].lower()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    conf_dict.setdefault(protocol, {}).update(json.loads(value))</span>
<span class="gi">+                except json.JSONDecodeError:</span>
<span class="gi">+                    warnings.warn(f&quot;Failed to parse JSON for {key}&quot;)</span>
<span class="gi">+            elif len(parts) &gt; 2:</span>
<span class="gi">+                # FSSPEC_&lt;protocol&gt;_&lt;kwarg&gt;</span>
<span class="gi">+                protocol = parts[1].lower()</span>
<span class="gi">+                kwarg = &quot;_&quot;.join(parts[2:]).lower()</span>
<span class="gi">+                conf_dict.setdefault(protocol, {})[kwarg] = value</span>


<span class="w"> </span>def set_conf_files(cdir, conf_dict):
<span class="gu">@@ -48,7 +62,21 @@ def set_conf_files(cdir, conf_dict):</span>
<span class="w"> </span>    conf_dict : dict(str, dict)
<span class="w"> </span>        This dict will be mutated
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.exists(cdir):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for file in sorted(os.listdir(cdir)):</span>
<span class="gi">+        path = os.path.join(cdir, file)</span>
<span class="gi">+        if file.endswith(&#39;.json&#39;):</span>
<span class="gi">+            with open(path, &#39;r&#39;) as f:</span>
<span class="gi">+                data = json.load(f)</span>
<span class="gi">+                for protocol, config in data.items():</span>
<span class="gi">+                    conf_dict.setdefault(protocol, {}).update(config)</span>
<span class="gi">+        elif file.endswith(&#39;.ini&#39;):</span>
<span class="gi">+            config = configparser.ConfigParser()</span>
<span class="gi">+            config.read(path)</span>
<span class="gi">+            for section in config.sections():</span>
<span class="gi">+                conf_dict.setdefault(section, {}).update(dict(config[section]))</span>


<span class="w"> </span>def apply_config(cls, kwargs, conf_dict=None):
<span class="gu">@@ -68,7 +96,18 @@ def apply_config(cls, kwargs, conf_dict=None):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    dict : the modified set of kwargs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if conf_dict is None:</span>
<span class="gi">+        conf_dict = conf</span>
<span class="gi">+</span>
<span class="gi">+    protocols = cls.protocol if isinstance(cls.protocol, (list, tuple)) else [cls.protocol]</span>
<span class="gi">+    </span>
<span class="gi">+    for protocol in protocols:</span>
<span class="gi">+        if protocol in conf_dict:</span>
<span class="gi">+            for key, value in conf_dict[protocol].items():</span>
<span class="gi">+                if key not in kwargs:</span>
<span class="gi">+                    kwargs[key] = value</span>
<span class="gi">+</span>
<span class="gi">+    return kwargs</span>


<span class="w"> </span>set_conf_files(conf_dir, conf)
<span class="gh">diff --git a/fsspec/core.py b/fsspec/core.py</span>
<span class="gh">index 0ba5d69..561be7d 100644</span>
<span class="gd">--- a/fsspec/core.py</span>
<span class="gi">+++ b/fsspec/core.py</span>
<span class="gu">@@ -281,7 +281,7 @@ def open(urlpath, mode=&#39;rb&#39;, compression=None, encoding=&#39;utf8&#39;, errors=None,</span>
<span class="w"> </span>    newline: bytes or None
<span class="w"> </span>        Used for line terminator in text mode. If None, uses system default;
<span class="w"> </span>        if blank, uses no translation.
<span class="gd">-    expand: bool or Nonw</span>
<span class="gi">+    expand: bool or None</span>
<span class="w"> </span>        Whether to regard file paths containing special glob characters as needing
<span class="w"> </span>        expansion (finding the first match) or absolute. Setting False allows using
<span class="w"> </span>        paths which do embed such characters. If None (default), this argument
<span class="gu">@@ -316,7 +316,15 @@ def open(urlpath, mode=&#39;rb&#39;, compression=None, encoding=&#39;utf8&#39;, errors=None,</span>
<span class="w"> </span>    - For implementations in separate packages see
<span class="w"> </span>      https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if expand is None:</span>
<span class="gi">+        expand = DEFAULT_EXPAND</span>
<span class="gi">+    </span>
<span class="gi">+    fs, path = url_to_fs(urlpath, protocol=protocol, expand=expand, **kwargs)</span>
<span class="gi">+    </span>
<span class="gi">+    compression = get_compression(path, compression)</span>
<span class="gi">+    </span>
<span class="gi">+    return OpenFile(fs, path, mode=mode, compression=compression, encoding=encoding,</span>
<span class="gi">+                    errors=errors, newline=newline)</span>


<span class="w"> </span>def open_local(url: (str | list[str] | Path | list[Path]), mode: str=&#39;rb&#39;,
<span class="gu">@@ -334,17 +342,36 @@ def open_local(url: (str | list[str] | Path | list[Path]), mode: str=&#39;rb&#39;,</span>
<span class="w"> </span>    storage_options:
<span class="w"> </span>        passed on to FS for or used by open_files (e.g., compression)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;r&#39; not in mode:</span>
<span class="gi">+        raise ValueError(&quot;Only read mode is supported&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(url, (str, Path)):</span>
<span class="gi">+        urls = [url]</span>
<span class="gi">+    else:</span>
<span class="gi">+        urls = url</span>
<span class="gi">+    </span>
<span class="gi">+    fs, _ = url_to_fs(urls[0], **storage_options)</span>
<span class="gi">+    </span>
<span class="gi">+    paths = [fs._strip_protocol(u) for u in urls]</span>
<span class="gi">+    </span>
<span class="gi">+    if hasattr(fs, &#39;open_many&#39;):</span>
<span class="gi">+        return fs.open_many(paths, mode=mode)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [fs.open(path, mode=mode) for path in paths]</span>


<span class="w"> </span>def split_protocol(urlpath):
<span class="w"> </span>    &quot;&quot;&quot;Return protocol, path pair&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;://&#39; in urlpath:</span>
<span class="gi">+        protocol, path = urlpath.split(&#39;://&#39;, 1)</span>
<span class="gi">+        return protocol, path</span>
<span class="gi">+    return None, urlpath</span>


<span class="w"> </span>def strip_protocol(urlpath):
<span class="w"> </span>    &quot;&quot;&quot;Return only path part of full URL, according to appropriate backend&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    protocol, path = split_protocol(urlpath)</span>
<span class="gi">+    return path</span>


<span class="w"> </span>def expand_paths_if_needed(paths, mode, num, fs, name_function):
<span class="gu">@@ -363,7 +390,26 @@ def expand_paths_if_needed(paths, mode, num, fs, name_function):</span>
<span class="w"> </span>        ``urlpath.replace(&#39;*&#39;, name_function(partition_index))``.
<span class="w"> </span>    :return: list of paths
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expanded_paths = []</span>
<span class="gi">+    </span>
<span class="gi">+    if &#39;w&#39; in mode:</span>
<span class="gi">+        if isinstance(paths, str):</span>
<span class="gi">+            if &#39;*&#39; in paths:</span>
<span class="gi">+                expanded_paths = [paths.replace(&#39;*&#39;, name_function(i)) for i in range(num)]</span>
<span class="gi">+            else:</span>
<span class="gi">+                expanded_paths = paths if isinstance(paths, list) else [paths]</span>
<span class="gi">+        else:</span>
<span class="gi">+            expanded_paths = paths</span>
<span class="gi">+    else:  # read mode</span>
<span class="gi">+        if isinstance(paths, str):</span>
<span class="gi">+            if any(char in paths for char in &#39;*?[]&#39;):</span>
<span class="gi">+                expanded_paths = fs.glob(paths)</span>
<span class="gi">+            else:</span>
<span class="gi">+                expanded_paths = [paths]</span>
<span class="gi">+        else:</span>
<span class="gi">+            expanded_paths = paths</span>
<span class="gi">+    </span>
<span class="gi">+    return expanded_paths</span>


<span class="w"> </span>def get_fs_token_paths(urlpath, mode=&#39;rb&#39;, num=1, name_function=None,
<span class="gu">@@ -390,7 +436,21 @@ def get_fs_token_paths(urlpath, mode=&#39;rb&#39;, num=1, name_function=None,</span>
<span class="w"> </span>    expand: bool
<span class="w"> </span>        Expand string paths for writing, assuming the path is a directory
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(urlpath, (list, tuple)):</span>
<span class="gi">+        if not urlpath:</span>
<span class="gi">+            raise ValueError(&quot;Empty urlpath&quot;)</span>
<span class="gi">+        urlpath = urlpath[0]</span>
<span class="gi">+    </span>
<span class="gi">+    fs, fs_token = url_to_fs(urlpath, protocol=protocol, storage_options=storage_options)</span>
<span class="gi">+    </span>
<span class="gi">+    if &#39;w&#39; in mode:</span>
<span class="gi">+        paths = expand_paths_if_needed([urlpath], mode, num, fs, name_function)</span>
<span class="gi">+    elif expand or isinstance(urlpath, str) and has_magic(urlpath):</span>
<span class="gi">+        paths = expand_paths_if_needed([urlpath], mode, num, fs, name_function)</span>
<span class="gi">+    else:</span>
<span class="gi">+        paths = [urlpath]</span>
<span class="gi">+    </span>
<span class="gi">+    return fs, fs_token, paths</span>


<span class="w"> </span>class PickleableTextIOWrapper(io.TextIOWrapper):
<span class="gh">diff --git a/fsspec/fuse.py b/fsspec/fuse.py</span>
<span class="gh">index de1075f..36f9ea5 100644</span>
<span class="gd">--- a/fsspec/fuse.py</span>
<span class="gi">+++ b/fsspec/fuse.py</span>
<span class="gu">@@ -59,7 +59,21 @@ def run(fs, path, mount_point, foreground=True, threads=False, ready_file=</span>
<span class="w"> </span>        to file.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fuse_ops = ops_class(fs, path, ready_file)</span>
<span class="gi">+    fuse = FUSE(</span>
<span class="gi">+        fuse_ops,</span>
<span class="gi">+        mount_point,</span>
<span class="gi">+        foreground=foreground,</span>
<span class="gi">+        nothreads=not threads,</span>
<span class="gi">+        allow_other=True,</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    if ready_file:</span>
<span class="gi">+        ready_file_path = os.path.join(mount_point, &#39;.fuse_ready&#39;)</span>
<span class="gi">+        with open(ready_file_path, &#39;w&#39;) as f:</span>
<span class="gi">+            f.write(&#39;FUSE is ready&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return fuse</span>


<span class="w"> </span>def main(args):
<span class="gu">@@ -89,7 +103,44 @@ def main(args):</span>
<span class="w"> </span>            -o &#39;ftp-username=anonymous&#39; \\
<span class="w"> </span>            -o &#39;ftp-password=xieyanbo&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        description=&#39;Mount filesystem from chained URL to MOUNT_POINT&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(&#39;protocol&#39;, help=&#39;Filesystem protocol or chained URL&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;path&#39;, help=&#39;Path within the filesystem to mount&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;mount_point&#39;, help=&#39;Local directory to mount to&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-f&#39;, &#39;--foreground&#39;, action=&#39;store_true&#39;, help=&#39;Run in foreground&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-t&#39;, &#39;--threads&#39;, action=&#39;store_true&#39;, help=&#39;Enable multi-threading&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-l&#39;, &#39;--log&#39;, help=&#39;Log file path&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-o&#39;, &#39;--option&#39;, action=&#39;append&#39;, help=&#39;Additional options&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;--ready-file&#39;, action=&#39;store_true&#39;, help=&#39;Create .fuse_ready file when mounted&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    args = parser.parse_args(args)</span>
<span class="gi">+    </span>
<span class="gi">+    if args.log:</span>
<span class="gi">+        logging.basicConfig(filename=args.log, level=logging.INFO)</span>
<span class="gi">+    </span>
<span class="gi">+    options = {}</span>
<span class="gi">+    if args.option:</span>
<span class="gi">+        for opt in args.option:</span>
<span class="gi">+            key, value = opt.split(&#39;=&#39;, 1)</span>
<span class="gi">+            if value.endswith(&#39;[int]&#39;):</span>
<span class="gi">+                options[key] = int(value[:-5])</span>
<span class="gi">+            elif value.endswith(&#39;[bool]&#39;):</span>
<span class="gi">+                options[key] = value[:-6].lower() in (&#39;true&#39;, &#39;yes&#39;, &#39;1&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                options[key] = value</span>
<span class="gi">+    </span>
<span class="gi">+    fs, _ = url_to_fs(args.protocol, **options)</span>
<span class="gi">+    </span>
<span class="gi">+    run(</span>
<span class="gi">+        fs,</span>
<span class="gi">+        args.path,</span>
<span class="gi">+        args.mount_point,</span>
<span class="gi">+        foreground=args.foreground,</span>
<span class="gi">+        threads=args.threads,</span>
<span class="gi">+        ready_file=args.ready_file</span>
<span class="gi">+    )</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/fsspec/generic.py b/fsspec/generic.py</span>
<span class="gh">index 48ba37c..32ea063 100644</span>
<span class="gd">--- a/fsspec/generic.py</span>
<span class="gi">+++ b/fsspec/generic.py</span>
<span class="gu">@@ -15,7 +15,23 @@ default_method = &#39;default&#39;</span>

<span class="w"> </span>def _resolve_fs(url, method=None, protocol=None, storage_options=None):
<span class="w"> </span>    &quot;&quot;&quot;Pick instance of backend FS&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if protocol is None:</span>
<span class="gi">+        protocol, _ = split_protocol(url)</span>
<span class="gi">+    </span>
<span class="gi">+    if method is None:</span>
<span class="gi">+        method = default_method</span>
<span class="gi">+    </span>
<span class="gi">+    if method == &#39;default&#39;:</span>
<span class="gi">+        fs_class = get_filesystem_class(protocol)</span>
<span class="gi">+        return fs_class(**(storage_options or {}))</span>
<span class="gi">+    elif method == &#39;generic&#39;:</span>
<span class="gi">+        if protocol not in _generic_fs:</span>
<span class="gi">+            raise ValueError(f&quot;No generic filesystem found for protocol {protocol}&quot;)</span>
<span class="gi">+        return _generic_fs[protocol]</span>
<span class="gi">+    elif method == &#39;current&#39;:</span>
<span class="gi">+        return filesystem(protocol, **(storage_options or {}))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown method: {method}&quot;)</span>


<span class="w"> </span>def rsync(source, destination, delete_missing=False, source_field=&#39;size&#39;,
<span class="gu">@@ -62,7 +78,43 @@ def rsync(source, destination, delete_missing=False, source_field=&#39;size&#39;,</span>
<span class="w"> </span>    -------
<span class="w"> </span>    dict of the copy operations that were performed, {source: destination}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fs is None:</span>
<span class="gi">+        fs = GenericFileSystem(**(inst_kwargs or {}))</span>
<span class="gi">+    </span>
<span class="gi">+    source_fs, source_path = fs.get_fs_token_paths(source)</span>
<span class="gi">+    dest_fs, dest_path = fs.get_fs_token_paths(destination)</span>
<span class="gi">+    </span>
<span class="gi">+    source_files = source_fs.find(source_path)</span>
<span class="gi">+    dest_files = dest_fs.find(dest_path)</span>
<span class="gi">+    </span>
<span class="gi">+    operations = {}</span>
<span class="gi">+    </span>
<span class="gi">+    for src_file in source_files:</span>
<span class="gi">+        rel_path = os.path.relpath(src_file, source_path)</span>
<span class="gi">+        dest_file = os.path.join(dest_path, rel_path)</span>
<span class="gi">+        </span>
<span class="gi">+        if update_cond == &#39;always&#39; or not dest_fs.exists(dest_file):</span>
<span class="gi">+            source_fs.get(src_file, dest_file)</span>
<span class="gi">+            operations[src_file] = dest_file</span>
<span class="gi">+        elif update_cond == &#39;different&#39;:</span>
<span class="gi">+            src_info = source_fs.info(src_file)</span>
<span class="gi">+            dest_info = dest_fs.info(dest_file)</span>
<span class="gi">+            </span>
<span class="gi">+            src_value = src_info[source_field] if isinstance(source_field, str) else source_field(src_info)</span>
<span class="gi">+            dest_value = dest_info[dest_field] if isinstance(dest_field, str) else dest_field(dest_info)</span>
<span class="gi">+            </span>
<span class="gi">+            if src_value != dest_value:</span>
<span class="gi">+                source_fs.get(src_file, dest_file)</span>
<span class="gi">+                operations[src_file] = dest_file</span>
<span class="gi">+    </span>
<span class="gi">+    if delete_missing:</span>
<span class="gi">+        for dest_file in dest_files:</span>
<span class="gi">+            rel_path = os.path.relpath(dest_file, dest_path)</span>
<span class="gi">+            src_file = os.path.join(source_path, rel_path)</span>
<span class="gi">+            if not source_fs.exists(src_file):</span>
<span class="gi">+                dest_fs.rm(dest_file)</span>
<span class="gi">+    </span>
<span class="gi">+    return operations</span>


<span class="w"> </span>class GenericFileSystem(AsyncFileSystem):
<span class="gu">@@ -101,5 +153,22 @@ class GenericFileSystem(AsyncFileSystem):</span>

<span class="w"> </span>        See `func:rsync` for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return rsync(source, destination, fs=self, **kwargs)</span>
<span class="gi">+    async def _make_many_dirs(self, paths, exist_ok=False):</span>
<span class="gi">+        &quot;&quot;&quot;Make multiple directories at once</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        paths: list of str</span>
<span class="gi">+            List of paths to create</span>
<span class="gi">+        exist_ok: bool (optional)</span>
<span class="gi">+            If True, don&#39;t raise an exception if the directory already exists</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        None</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            await self._makedirs(path, exist_ok=exist_ok)</span>
<span class="gi">+</span>
<span class="w"> </span>    make_many_dirs = sync_wrapper(_make_many_dirs)
<span class="gh">diff --git a/fsspec/gui.py b/fsspec/gui.py</span>
<span class="gh">index ad74c4c..4197561 100644</span>
<span class="gd">--- a/fsspec/gui.py</span>
<span class="gi">+++ b/fsspec/gui.py</span>
<span class="gu">@@ -58,11 +58,19 @@ class SigSlot:</span>
<span class="w"> </span>            If True, automatically connects with a method in this class of the
<span class="w"> </span>            same name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if widget is not None:</span>
<span class="gi">+            self._sigs[name] = widget.param.watch(lambda event: self._signal(event), thing)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._sigs[name] = None</span>
<span class="gi">+        </span>
<span class="gi">+        self._map[name] = {&#39;widget&#39;: widget, &#39;thing&#39;: thing, &#39;log_level&#39;: log_level}</span>
<span class="gi">+        </span>
<span class="gi">+        if auto:</span>
<span class="gi">+            self.connect(name, getattr(self, name))</span>

<span class="w"> </span>    def _repr_mimebundle_(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Display in a notebook or a server&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.show()._repr_mimebundle_(*args, **kwargs)</span>

<span class="w"> </span>    def connect(self, signal, slot):
<span class="w"> </span>        &quot;&quot;&quot;Associate call back with given event
<span class="gu">@@ -74,7 +82,15 @@ class SigSlot:</span>
<span class="w"> </span>        Alternatively, the callback can be a string, in which case it means
<span class="w"> </span>        emitting the correspondingly-named event (i.e., connect to self)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if signal not in self._sigs:</span>
<span class="gi">+            raise ValueError(f&quot;Unknown signal: {signal}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(slot, str):</span>
<span class="gi">+            slot = lambda value: self._emit(slot, value)</span>
<span class="gi">+        </span>
<span class="gi">+        if signal not in self._map:</span>
<span class="gi">+            self._map[signal] = {&#39;callbacks&#39;: []}</span>
<span class="gi">+        self._map[signal][&#39;callbacks&#39;] = self._map[signal].get(&#39;callbacks&#39;, []) + [slot]</span>

<span class="w"> </span>    def _signal(self, event):
<span class="w"> </span>        &quot;&quot;&quot;This is called by a an action on a widget
<span class="gu">@@ -84,7 +100,13 @@ class SigSlot:</span>
<span class="w"> </span>        Tests can execute this method by directly changing the values of
<span class="w"> </span>        widget components.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._ignoring_events:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        name = next((k for k, v in self._map.items() if v[&#39;widget&#39;] == event.obj), None)</span>
<span class="gi">+        if name:</span>
<span class="gi">+            logger.log(self._map[name][&#39;log_level&#39;], f&quot;Signal: {name}&quot;)</span>
<span class="gi">+            self._emit(name, event.new)</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="w"> </span>    def ignore_events(self):
<span class="gu">@@ -92,7 +114,11 @@ class SigSlot:</span>

<span class="w"> </span>        (does not propagate to children)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._ignoring_events = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._ignoring_events = False</span>

<span class="w"> </span>    def _emit(self, sig, value=None):
<span class="w"> </span>        &quot;&quot;&quot;An event happened, call its callbacks
<span class="gu">@@ -102,11 +128,16 @@ class SigSlot:</span>

<span class="w"> </span>        Calling of callbacks will halt whenever one returns False.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sig not in self._map:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        for callback in self._map[sig].get(&#39;callbacks&#39;, []):</span>
<span class="gi">+            if callback(value) is False:</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def show(self, threads=False):
<span class="w"> </span>        &quot;&quot;&quot;Open a new browser tab and display this instance&#39;s interface&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return pn.panel(self).show(threaded=threads)</span>


<span class="w"> </span>class SingleSelect(SigSlot):
<span class="gu">@@ -117,6 +148,27 @@ class SingleSelect(SigSlot):</span>
<span class="w"> </span>    def __init__(self, **kwargs):
<span class="w"> </span>        self.kwargs = kwargs
<span class="w"> </span>        super().__init__()
<span class="gi">+        self.select = pn.widgets.Select(**self.kwargs)</span>
<span class="gi">+        self._register(self.select, &#39;_selected&#39;)</span>
<span class="gi">+        self.connect(&#39;_selected&#39;, self._on_selected)</span>
<span class="gi">+</span>
<span class="gi">+    def _on_selected(self, value):</span>
<span class="gi">+        self._emit(&#39;selected&#39;, value)</span>
<span class="gi">+</span>
<span class="gi">+    def set_options(self, options):</span>
<span class="gi">+        self.select.options = options</span>
<span class="gi">+</span>
<span class="gi">+    def set_selection(self, value):</span>
<span class="gi">+        self.select.value = value</span>
<span class="gi">+</span>
<span class="gi">+    def add(self, option):</span>
<span class="gi">+        self.select.options = list(self.select.options) + [option]</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        self.select.value = None</span>
<span class="gi">+</span>
<span class="gi">+    def _setup(self):</span>
<span class="gi">+        self._register(self.select, &#39;_selected&#39;)</span>


<span class="w"> </span>class FileSelector(SigSlot):
<span class="gu">@@ -161,17 +213,26 @@ class FileSelector(SigSlot):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def storage_options(self):
<span class="w"> </span>        &quot;&quot;&quot;Value of the kwargs box as a dictionary&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return ast.literal_eval(self.kwargs_box.value)</span>
<span class="gi">+        except:</span>
<span class="gi">+            return {}</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def fs(self):
<span class="w"> </span>        &quot;&quot;&quot;Current filesystem instance&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._fs is None:</span>
<span class="gi">+            protocol = self.protocol_select.value</span>
<span class="gi">+            cls = get_filesystem_class(protocol)</span>
<span class="gi">+            self._fs = cls(**self.storage_options)</span>
<span class="gi">+        return self._fs</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def urlpath(self):
<span class="w"> </span>        &quot;&quot;&quot;URL of currently selected item&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        protocol = self.protocol_select.value</span>
<span class="gi">+        path = self.path_box.value</span>
<span class="gi">+        return f&quot;{protocol}://{path}&quot;</span>

<span class="w"> </span>    def open_file(self, mode=&#39;rb&#39;, compression=None, encoding=None):
<span class="w"> </span>        &quot;&quot;&quot;Create OpenFile instance for the currently selected item
<span class="gu">@@ -197,4 +258,10 @@ class FileSelector(SigSlot):</span>
<span class="w"> </span>        encoding: str (optional)
<span class="w"> </span>            If using text mode, use this encoding; defaults to UTF8.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OpenFile(</span>
<span class="gi">+            self.fs,</span>
<span class="gi">+            self.path_box.value,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            compression=compression,</span>
<span class="gi">+            encoding=encoding</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/fsspec/implementations/cache_mapper.py b/fsspec/implementations/cache_mapper.py</span>
<span class="gh">index 3294867..9b06d15 100644</span>
<span class="gd">--- a/fsspec/implementations/cache_mapper.py</span>
<span class="gi">+++ b/fsspec/implementations/cache_mapper.py</span>
<span class="gu">@@ -63,4 +63,7 @@ def create_cache_mapper(same_names: bool) -&gt;AbstractCacheMapper:</span>
<span class="w"> </span>    &quot;&quot;&quot;Factory method to create cache mapper for backward compatibility with
<span class="w"> </span>    ``CachingFileSystem`` constructor using ``same_names`` kwarg.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if same_names:</span>
<span class="gi">+        return BasenameCacheMapper()</span>
<span class="gi">+    else:</span>
<span class="gi">+        return HashCacheMapper()</span>
<span class="gh">diff --git a/fsspec/implementations/cache_metadata.py b/fsspec/implementations/cache_metadata.py</span>
<span class="gh">index 9a2c33e..af30cc0 100644</span>
<span class="gd">--- a/fsspec/implementations/cache_metadata.py</span>
<span class="gi">+++ b/fsspec/implementations/cache_metadata.py</span>
<span class="gu">@@ -45,11 +45,25 @@ class CacheMetadata:</span>

<span class="w"> </span>    def _load(self, fn: str) -&gt;Detail:
<span class="w"> </span>        &quot;&quot;&quot;Low-level function to load metadata from specific file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(fn, &quot;rb&quot;) as f:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return json.load(f)</span>
<span class="gi">+                except json.JSONDecodeError:</span>
<span class="gi">+                    # Fallback to pickle for backward compatibility</span>
<span class="gi">+                    f.seek(0)</span>
<span class="gi">+                    return pickle.load(f)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return {}</span>

<span class="w"> </span>    def _save(self, metadata_to_save: Detail, fn: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Low-level function to save metadata to specific file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._force_save_pickle:</span>
<span class="gi">+            with atomic_write(fn, mode=&quot;wb&quot;) as f:</span>
<span class="gi">+                pickle.dump(metadata_to_save, f)</span>
<span class="gi">+        else:</span>
<span class="gi">+            with atomic_write(fn, mode=&quot;w&quot;) as f:</span>
<span class="gi">+                json.dump(metadata_to_save, f)</span>

<span class="w"> </span>    def _scan_locations(self, writable_only: bool=False) -&gt;Iterator[tuple[
<span class="w"> </span>        str, str, bool]]:
<span class="gu">@@ -65,7 +79,11 @@ class CacheMetadata:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        Yields (str, str, bool)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for storage in reversed(self._storage):</span>
<span class="gi">+            fn = os.path.join(storage, &quot;cache&quot;)</span>
<span class="gi">+            writable = os.access(storage, os.W_OK)</span>
<span class="gi">+            if not writable_only or writable:</span>
<span class="gi">+                yield storage, fn, writable</span>

<span class="w"> </span>    def check_file(self, path: str, cfs: (CachingFileSystem | None)) -&gt;(Literal
<span class="w"> </span>        [False] | tuple[Detail, str]):
<span class="gu">@@ -75,7 +93,16 @@ class CacheMetadata:</span>
<span class="w"> </span>        perform extra checks to reject possible matches, such as if they are
<span class="w"> </span>        too old.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for storage, cached_files in zip(self._storage, self.cached_files):</span>
<span class="gi">+            detail = cached_files.get(path)</span>
<span class="gi">+            if detail:</span>
<span class="gi">+                fn = os.path.join(storage, detail[&quot;fn&quot;])</span>
<span class="gi">+                if os.path.exists(fn):</span>
<span class="gi">+                    if cfs and cfs.check_file(path, detail):</span>
<span class="gi">+                        return detail, fn</span>
<span class="gi">+                    elif not cfs:</span>
<span class="gi">+                        return detail, fn</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def clear_expired(self, expiry_time: int) -&gt;tuple[list[str], bool]:
<span class="w"> </span>        &quot;&quot;&quot;Remove expired metadata from the cache.
<span class="gu">@@ -84,18 +111,32 @@ class CacheMetadata:</span>
<span class="w"> </span>        flag indicating whether the writable cache is empty. Caller is
<span class="w"> </span>        responsible for deleting the expired files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expired_files = []</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        for cached_files in self.cached_files:</span>
<span class="gi">+            for path, detail in list(cached_files.items()):</span>
<span class="gi">+                if now - detail.get(&quot;time&quot;, 0) &gt; expiry_time:</span>
<span class="gi">+                    expired_files.append(detail[&quot;fn&quot;])</span>
<span class="gi">+                    del cached_files[path]</span>
<span class="gi">+        </span>
<span class="gi">+        writable_cache_empty = len(self.cached_files[-1]) == 0</span>
<span class="gi">+        return expired_files, writable_cache_empty</span>

<span class="w"> </span>    def load(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load all metadata from disk and store in ``self.cached_files``&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cached_files = []</span>
<span class="gi">+        for _, fn, _ in self._scan_locations():</span>
<span class="gi">+            self.cached_files.append(self._load(fn))</span>

<span class="w"> </span>    def on_close_cached_file(self, f: Any, path: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Perform side-effect actions on closing a cached file.

<span class="w"> </span>        The actual closing of the file is the responsibility of the caller.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        detail = self.cached_files[-1].get(path)</span>
<span class="gi">+        if detail:</span>
<span class="gi">+            detail[&quot;size&quot;] = f.tell()</span>
<span class="gi">+            detail[&quot;time&quot;] = time.time()</span>

<span class="w"> </span>    def pop_file(self, path: str) -&gt;(str | None):
<span class="w"> </span>        &quot;&quot;&quot;Remove metadata of cached file.
<span class="gu">@@ -104,12 +145,19 @@ class CacheMetadata:</span>
<span class="w"> </span>        otherwise return ``None``.  Caller is responsible for deleting the
<span class="w"> </span>        cached file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cached_files in reversed(self.cached_files):</span>
<span class="gi">+            if path in cached_files:</span>
<span class="gi">+                detail = cached_files.pop(path)</span>
<span class="gi">+                return detail[&quot;fn&quot;]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def save(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Save metadata to disk&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for storage, fn, writable in self._scan_locations(writable_only=True):</span>
<span class="gi">+            if writable:</span>
<span class="gi">+                self._save(self.cached_files[-1], fn)</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def update_file(self, path: str, detail: Detail) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update metadata for specific file in memory, do not save&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cached_files[-1][path] = detail</span>
<span class="gh">diff --git a/fsspec/implementations/cached.py b/fsspec/implementations/cached.py</span>
<span class="gh">index bd56e3c..8db7702 100644</span>
<span class="gd">--- a/fsspec/implementations/cached.py</span>
<span class="gi">+++ b/fsspec/implementations/cached.py</span>
<span class="gu">@@ -144,23 +144,33 @@ class CachingFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        If more than one cache directory is in use, only the size of the last
<span class="w"> </span>        one (the writable cache directory) is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cache_size is None:</span>
<span class="gi">+            self._cache_size = sum(</span>
<span class="gi">+                os.path.getsize(os.path.join(self.storage[-1], f))</span>
<span class="gi">+                for f in os.listdir(self.storage[-1])</span>
<span class="gi">+                if os.path.isfile(os.path.join(self.storage[-1], f))</span>
<span class="gi">+            )</span>
<span class="gi">+        return self._cache_size</span>

<span class="w"> </span>    def load_cache(self):
<span class="w"> </span>        &quot;&quot;&quot;Read set of stored blocks from file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._metadata.load()</span>

<span class="w"> </span>    def save_cache(self):
<span class="w"> </span>        &quot;&quot;&quot;Save set of stored blocks from file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._metadata.save()</span>

<span class="w"> </span>    def _check_cache(self):
<span class="w"> </span>        &quot;&quot;&quot;Reload caches if time elapsed or any disappeared&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._metadata.check_cache(self.cache_check)</span>

<span class="w"> </span>    def _check_file(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Is path in cache and still valid&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._strip_protocol(path)</span>
<span class="gi">+        details = self._metadata.get_metadata(path)</span>
<span class="gi">+        if details:</span>
<span class="gi">+            return time.time() - details[&quot;time&quot;] &lt; self.expiry if self.expiry else True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def clear_cache(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all files and metadata from the cache
<span class="gu">@@ -168,7 +178,10 @@ class CachingFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        In the case of multiple cache locations, this clears only the last one,
<span class="w"> </span>        which is assumed to be the read/write one.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for file in os.listdir(self.storage[-1]):</span>
<span class="gi">+            os.remove(os.path.join(self.storage[-1], file))</span>
<span class="gi">+        self._metadata.clear()</span>
<span class="gi">+        self._cache_size = 0</span>

<span class="w"> </span>    def clear_expired_cache(self, expiry_time=None):
<span class="w"> </span>        &quot;&quot;&quot;Remove all expired files and metadata from the cache
<span class="gu">@@ -183,7 +196,13 @@ class CachingFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>            If not defined the default is equivalent to the attribute from the
<span class="w"> </span>            file caching instantiation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expiry_time = expiry_time or self.expiry</span>
<span class="gi">+        if not expiry_time:</span>
<span class="gi">+            return</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        for path, details in list(self._metadata.items()):</span>
<span class="gi">+            if now - details[&quot;time&quot;] &gt; expiry_time:</span>
<span class="gi">+                self.pop_from_cache(path)</span>

<span class="w"> </span>    def pop_from_cache(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Remove cached version of given file
<span class="gu">@@ -192,7 +211,16 @@ class CachingFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        location which is not the last, it is assumed to be read-only, and
<span class="w"> </span>        raises PermissionError
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._strip_protocol(path)</span>
<span class="gi">+        details = self._metadata.pop(path)</span>
<span class="gi">+        if details:</span>
<span class="gi">+            fn = self._mapper(path)</span>
<span class="gi">+            if os.path.exists(fn):</span>
<span class="gi">+                if fn.startswith(self.storage[-1]):</span>
<span class="gi">+                    os.remove(fn)</span>
<span class="gi">+                    self._cache_size = None  # Reset cache size</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise PermissionError(f&quot;Cannot delete cached file {fn}&quot;)</span>

<span class="w"> </span>    def _open(self, path, mode=&#39;rb&#39;, block_size=None, autocommit=True,
<span class="w"> </span>        cache_options=None, **kwargs):
<span class="gu">@@ -208,11 +236,31 @@ class CachingFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        We monkey-patch this file, so that when it closes, we call
<span class="w"> </span>        ``close_and_update`` to save the state of the blocks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._strip_protocol(path)</span>
<span class="gi">+        cache_path = self._mapper(path)</span>
<span class="gi">+</span>
<span class="gi">+        if self._check_file(path):</span>
<span class="gi">+            return open(cache_path, mode)</span>
<span class="gi">+</span>
<span class="gi">+        f = self.fs._open(path, mode=mode, block_size=block_size, **kwargs)</span>
<span class="gi">+        if &#39;r&#39; in mode and self.compression:</span>
<span class="gi">+            comp = self.compression</span>
<span class="gi">+            f = compr[comp](f, mode=&#39;rb&#39;)</span>
<span class="gi">+        if &#39;r&#39; in mode:</span>
<span class="gi">+            f.cache = MMapCache(f.size, cache_path)</span>
<span class="gi">+            close = f.close</span>
<span class="gi">+            f.close = lambda: self.close_and_update(f, close)</span>
<span class="gi">+</span>
<span class="gi">+        return f</span>

<span class="w"> </span>    def close_and_update(self, f, close):
<span class="w"> </span>        &quot;&quot;&quot;Called when a file is closing, so store the set of blocks&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if f.closed:</span>
<span class="gi">+            return</span>
<span class="gi">+        f.cache.close()</span>
<span class="gi">+        self._metadata.update_metadata(self._strip_protocol(f.path), {&quot;time&quot;: time.time()})</span>
<span class="gi">+        self.save_cache()</span>
<span class="gi">+        close()</span>

<span class="w"> </span>    def __getattribute__(self, item):
<span class="w"> </span>        if item in {&#39;load_cache&#39;, &#39;_open&#39;, &#39;save_cache&#39;, &#39;close_and_update&#39;,
<span class="gh">diff --git a/fsspec/implementations/dask.py b/fsspec/implementations/dask.py</span>
<span class="gh">index ead2260..b014b29 100644</span>
<span class="gd">--- a/fsspec/implementations/dask.py</span>
<span class="gi">+++ b/fsspec/implementations/dask.py</span>
<span class="gu">@@ -29,6 +29,55 @@ class DaskWorkerFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        self.fs = fs
<span class="w"> </span>        self._determine_worker()

<span class="gi">+    def _determine_worker(self):</span>
<span class="gi">+        if isinstance(dask.config.get(&quot;scheduler&quot;), Worker):</span>
<span class="gi">+            self.worker = dask.config.get(&quot;scheduler&quot;)</span>
<span class="gi">+        elif self.client is None:</span>
<span class="gi">+            self.client = _get_global_client()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_fs(self):</span>
<span class="gi">+        if self.fs is None:</span>
<span class="gi">+            if self.worker:</span>
<span class="gi">+                self.fs = filesystem(self.target_protocol, **self.target_options)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.fs = self.client.submit(</span>
<span class="gi">+                    filesystem, self.target_protocol, **self.target_options</span>
<span class="gi">+                ).result()</span>
<span class="gi">+        return self.fs</span>
<span class="gi">+</span>
<span class="gi">+    def _call_worker(self, method, *args, **kwargs):</span>
<span class="gi">+        if self.worker:</span>
<span class="gi">+            return getattr(self._get_fs(), method)(*args, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.client.submit(</span>
<span class="gi">+                getattr, self._get_fs(), method</span>
<span class="gi">+            ).result()(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def mkdir(self, path, create_parents=True, **kwargs):</span>
<span class="gi">+        return self._call_worker(&#39;mkdir&#39;, path, create_parents=create_parents, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def makedirs(self, path, exist_ok=False):</span>
<span class="gi">+        return self._call_worker(&#39;makedirs&#39;, path, exist_ok=exist_ok)</span>
<span class="gi">+</span>
<span class="gi">+    def rmdir(self, path):</span>
<span class="gi">+        return self._call_worker(&#39;rmdir&#39;, path)</span>
<span class="gi">+</span>
<span class="gi">+    def ls(self, path, detail=False, **kwargs):</span>
<span class="gi">+        return self._call_worker(&#39;ls&#39;, path, detail=detail, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def info(self, path, **kwargs):</span>
<span class="gi">+        return self._call_worker(&#39;info&#39;, path, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def cp_file(self, path1, path2, **kwargs):</span>
<span class="gi">+        return self._call_worker(&#39;cp_file&#39;, path1, path2, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _open(self, path, mode=&quot;rb&quot;, block_size=None, **kwargs):</span>
<span class="gi">+        if mode != &#39;rb&#39;:</span>
<span class="gi">+            raise NotImplementedError(&quot;Only read-only access is currently supported&quot;)</span>
<span class="gi">+        return DaskFile(</span>
<span class="gi">+            self, path, mode=mode, block_size=block_size, **kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class DaskFile(AbstractBufferedFile):

<span class="gu">@@ -40,8 +89,8 @@ class DaskFile(AbstractBufferedFile):</span>

<span class="w"> </span>    def _initiate_upload(self):
<span class="w"> </span>        &quot;&quot;&quot;Create remote file/upload&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Upload is not supported for DaskFile&quot;)</span>

<span class="w"> </span>    def _fetch_range(self, start, end):
<span class="w"> </span>        &quot;&quot;&quot;Get the specified set of bytes from remote&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.fs._call_worker(&#39;cat_file&#39;, self.path, start=start, end=end)</span>
<span class="gh">diff --git a/fsspec/implementations/data.py b/fsspec/implementations/data.py</span>
<span class="gh">index 77435f6..369f0b8 100644</span>
<span class="gd">--- a/fsspec/implementations/data.py</span>
<span class="gi">+++ b/fsspec/implementations/data.py</span>
<span class="gu">@@ -28,4 +28,6 @@ class DataFileSystem(AbstractFileSystem):</span>

<span class="w"> </span>        This version always base64 encodes, even when the data is ascii/url-safe.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encoded_data = base64.b64encode(data).decode(&#39;ascii&#39;)</span>
<span class="gi">+        mime_type = mime if mime else &#39;text/plain&#39;</span>
<span class="gi">+        return f&quot;data:{mime_type};base64,{encoded_data}&quot;</span>
<span class="gh">diff --git a/fsspec/implementations/dbfs.py b/fsspec/implementations/dbfs.py</span>
<span class="gh">index bbf4358..2849d99 100644</span>
<span class="gd">--- a/fsspec/implementations/dbfs.py</span>
<span class="gi">+++ b/fsspec/implementations/dbfs.py</span>
<span class="gu">@@ -61,7 +61,22 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>            but also additional information on file sizes
<span class="w"> </span>            and types.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_data = {&quot;path&quot;: path}</span>
<span class="gi">+        response = self._send_to_api(&quot;get&quot;, &quot;dbfs/list&quot;, json_data)</span>
<span class="gi">+        </span>
<span class="gi">+        files = response.get(&quot;files&quot;, [])</span>
<span class="gi">+        if not detail:</span>
<span class="gi">+            return [f[&quot;path&quot;] for f in files]</span>
<span class="gi">+        </span>
<span class="gi">+        return [</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;name&quot;: f[&quot;path&quot;].split(&quot;/&quot;)[-1],</span>
<span class="gi">+                &quot;size&quot;: f.get(&quot;file_size&quot;, 0),</span>
<span class="gi">+                &quot;type&quot;: &quot;directory&quot; if f[&quot;is_dir&quot;] else &quot;file&quot;,</span>
<span class="gi">+                &quot;path&quot;: f[&quot;path&quot;]</span>
<span class="gi">+            }</span>
<span class="gi">+            for f in files</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    def makedirs(self, path, exist_ok=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,7 +91,11 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>            exists before creating it (and raises an
<span class="w"> </span>            Exception if this is the case)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not exist_ok:</span>
<span class="gi">+            if self.exists(path):</span>
<span class="gi">+                raise FileExistsError(f&quot;Path already exists: {path}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        self.mkdir(path, create_parents=True)</span>

<span class="w"> </span>    def mkdir(self, path, create_parents=True, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +109,11 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>            Whether to create all parents or not.
<span class="w"> </span>            &quot;False&quot; is not implemented so far.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not create_parents:</span>
<span class="gi">+            raise NotImplementedError(&quot;create_parents=False is not implemented&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        json_data = {&quot;path&quot;: path}</span>
<span class="gi">+        self._send_to_api(&quot;post&quot;, &quot;dbfs/mkdirs&quot;, json_data)</span>

<span class="w"> </span>    def rm(self, path, recursive=False, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -103,7 +126,8 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        recursive: bool
<span class="w"> </span>            Recursively delete all files in a folder.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_data = {&quot;path&quot;: path, &quot;recursive&quot;: recursive}</span>
<span class="gi">+        self._send_to_api(&quot;post&quot;, &quot;dbfs/delete&quot;, json_data)</span>

<span class="w"> </span>    def mv(self, source_path, destination_path, recursive=False, maxdepth=
<span class="w"> </span>        None, **kwargs):
<span class="gu">@@ -125,11 +149,18 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        destination_path: str
<span class="w"> </span>            To where to move (absolute path)
<span class="w"> </span>        recursive: bool
<span class="gd">-            Not implemented to far.</span>
<span class="gi">+            Not implemented so far.</span>
<span class="w"> </span>        maxdepth:
<span class="gd">-            Not implemented to far.</span>
<span class="gi">+            Not implemented so far.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if recursive or maxdepth is not None:</span>
<span class="gi">+            raise NotImplementedError(&quot;recursive and maxdepth are not implemented&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        json_data = {</span>
<span class="gi">+            &quot;source_path&quot;: source_path,</span>
<span class="gi">+            &quot;destination_path&quot;: destination_path</span>
<span class="gi">+        }</span>
<span class="gi">+        self._send_to_api(&quot;post&quot;, &quot;dbfs/move&quot;, json_data)</span>

<span class="w"> </span>    def _open(self, path, mode=&#39;rb&#39;, block_size=&#39;default&#39;, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -138,7 +169,7 @@ class DatabricksFileSystem(AbstractFileSystem):</span>

<span class="w"> </span>        Only the default blocksize is allowed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DatabricksFile(self, path, mode=mode, block_size=block_size, **kwargs)</span>

<span class="w"> </span>    def _send_to_api(self, method, endpoint, json):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -154,7 +185,16 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        json: dict
<span class="w"> </span>            Dictionary of information to send
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;https://{self.instance}/api/2.0/{endpoint}&quot;</span>
<span class="gi">+        if method.lower() == &quot;get&quot;:</span>
<span class="gi">+            response = self.session.get(url, json=json)</span>
<span class="gi">+        elif method.lower() == &quot;post&quot;:</span>
<span class="gi">+            response = self.session.post(url, json=json)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Unsupported HTTP method: {method}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        return response.json()</span>

<span class="w"> </span>    def _create_handle(self, path, overwrite=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -174,7 +214,9 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>            If a file already exist at this location, either overwrite
<span class="w"> </span>            it or raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_data = {&quot;path&quot;: path, &quot;overwrite&quot;: overwrite}</span>
<span class="gi">+        response = self._send_to_api(&quot;post&quot;, &quot;dbfs/create&quot;, json_data)</span>
<span class="gi">+        return response[&quot;handle&quot;]</span>

<span class="w"> </span>    def _close_handle(self, handle):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -185,7 +227,8 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        handle: str
<span class="w"> </span>            Which handle to close.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_data = {&quot;handle&quot;: handle}</span>
<span class="gi">+        self._send_to_api(&quot;post&quot;, &quot;dbfs/close&quot;, json_data)</span>

<span class="w"> </span>    def _add_data(self, handle, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -202,7 +245,9 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        data: bytes
<span class="w"> </span>            Block of data to add to the handle.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encoded_data = base64.b64encode(data).decode(&#39;utf-8&#39;)</span>
<span class="gi">+        json_data = {&quot;handle&quot;: handle, &quot;data&quot;: encoded_data}</span>
<span class="gi">+        self._send_to_api(&quot;post&quot;, &quot;dbfs/add-block&quot;, json_data)</span>

<span class="w"> </span>    def _get_data(self, path, start, end):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -219,7 +264,10 @@ class DatabricksFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        end: int
<span class="w"> </span>            End position of the block
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        length = end - start</span>
<span class="gi">+        json_data = {&quot;path&quot;: path, &quot;offset&quot;: start, &quot;length&quot;: length}</span>
<span class="gi">+        response = self._send_to_api(&quot;get&quot;, &quot;dbfs/read&quot;, json_data)</span>
<span class="gi">+        return base64.b64decode(response[&quot;data&quot;])</span>


<span class="w"> </span>class DatabricksFile(AbstractBufferedFile):
<span class="gu">@@ -244,16 +292,22 @@ class DatabricksFile(AbstractBufferedFile):</span>

<span class="w"> </span>    def _initiate_upload(self):
<span class="w"> </span>        &quot;&quot;&quot;Internal function to start a file upload&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.handle = self.fs._create_handle(self.path, overwrite=self.mode == &#39;wb&#39;)</span>

<span class="w"> </span>    def _upload_chunk(self, final=False):
<span class="w"> </span>        &quot;&quot;&quot;Internal function to add a chunk of data to a started upload&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.buffer:</span>
<span class="gi">+            self.fs._add_data(self.handle, self.buffer.getvalue())</span>
<span class="gi">+            self.buffer.seek(0)</span>
<span class="gi">+            self.buffer.truncate()</span>
<span class="gi">+        if final:</span>
<span class="gi">+            self.fs._close_handle(self.handle)</span>

<span class="w"> </span>    def _fetch_range(self, start, end):
<span class="w"> </span>        &quot;&quot;&quot;Internal function to download a block of data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.fs._get_data(self.path, start, end)</span>

<span class="w"> </span>    def _to_sized_blocks(self, length, start=0):
<span class="w"> </span>        &quot;&quot;&quot;Helper function to split a range from 0 to total_length into bloksizes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for offset in range(start, start + length, self.blocksize):</span>
<span class="gi">+            yield offset, min(self.blocksize, start + length - offset)</span>
<span class="gh">diff --git a/fsspec/implementations/ftp.py b/fsspec/implementations/ftp.py</span>
<span class="gh">index 0658887..b2572ba 100644</span>
<span class="gd">--- a/fsspec/implementations/ftp.py</span>
<span class="gi">+++ b/fsspec/implementations/ftp.py</span>
<span class="gu">@@ -88,7 +88,28 @@ class FTPFile(AbstractBufferedFile):</span>
<span class="w"> </span>        Will fail if the server does not respect the REST command on
<span class="w"> </span>        retrieve requests.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = []</span>
<span class="gi">+        total = [0]</span>
<span class="gi">+</span>
<span class="gi">+        def callback(chunk):</span>
<span class="gi">+            data.append(chunk)</span>
<span class="gi">+            total[0] += len(chunk)</span>
<span class="gi">+            if total[0] &gt;= end - start:</span>
<span class="gi">+                raise TransferDone</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.fs.ftp.retrbinary(</span>
<span class="gi">+                f&quot;RETR {self.path}&quot;,</span>
<span class="gi">+                callback,</span>
<span class="gi">+                blocksize=self.blocksize,</span>
<span class="gi">+                rest=start</span>
<span class="gi">+            )</span>
<span class="gi">+        except TransferDone:</span>
<span class="gi">+            pass</span>
<span class="gi">+        except Error as e:</span>
<span class="gi">+            raise IOError(f&quot;FTP error: {str(e)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return b&quot;&quot;.join(data)[:end - start]</span>


<span class="w"> </span>def _mlsd2(ftp, path=&#39;.&#39;):
<span class="gu">@@ -104,4 +125,46 @@ def _mlsd2(ftp, path=&#39;.&#39;):</span>
<span class="w"> </span>    path: str
<span class="w"> </span>        Expects to be given path, but defaults to &quot;.&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from datetime import datetime</span>
<span class="gi">+    import re</span>
<span class="gi">+</span>
<span class="gi">+    lines = []</span>
<span class="gi">+    ftp.dir(path, lines.append)</span>
<span class="gi">+</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        parts = line.split(None, 8)</span>
<span class="gi">+        if len(parts) &lt; 9:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        perms, _, owner, group, size, month, day, year_or_time, name = parts</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;:&#39; in year_or_time:</span>
<span class="gi">+            year = datetime.now().year</span>
<span class="gi">+            time = year_or_time</span>
<span class="gi">+        else:</span>
<span class="gi">+            year = int(year_or_time)</span>
<span class="gi">+            time = &quot;00:00&quot;</span>
<span class="gi">+</span>
<span class="gi">+        date_str = f&quot;{month} {day} {year} {time}&quot;</span>
<span class="gi">+        mtime = datetime.strptime(date_str, &quot;%b %d %Y %H:%M&quot;).timestamp()</span>
<span class="gi">+</span>
<span class="gi">+        is_dir = perms.startswith(&#39;d&#39;)</span>
<span class="gi">+        is_link = perms.startswith(&#39;l&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if is_link:</span>
<span class="gi">+            name, _, link_target = name.partition(&#39; -&gt; &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            link_target = None</span>
<span class="gi">+</span>
<span class="gi">+        yield {</span>
<span class="gi">+            &#39;name&#39;: name,</span>
<span class="gi">+            &#39;size&#39;: int(size),</span>
<span class="gi">+            &#39;type&#39;: &#39;dir&#39; if is_dir else &#39;file&#39;,</span>
<span class="gi">+            &#39;modify&#39;: mtime,</span>
<span class="gi">+            &#39;unix&#39;: {</span>
<span class="gi">+                &#39;mode&#39;: perms,</span>
<span class="gi">+                &#39;owner&#39;: owner,</span>
<span class="gi">+                &#39;group&#39;: group,</span>
<span class="gi">+            },</span>
<span class="gi">+            &#39;target&#39;: link_target</span>
<span class="gi">+        }</span>
<span class="gh">diff --git a/fsspec/implementations/github.py b/fsspec/implementations/github.py</span>
<span class="gh">index 27f9ccd..831710b 100644</span>
<span class="gd">--- a/fsspec/implementations/github.py</span>
<span class="gi">+++ b/fsspec/implementations/github.py</span>
<span class="gu">@@ -72,22 +72,34 @@ class GithubFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        List of string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;https://api.github.com/{&#39;orgs&#39; if is_org else &#39;users&#39;}/{org_or_user}/repos&quot;</span>
<span class="gi">+        response = requests.get(url, timeout=cls.timeout)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        return [repo[&#39;name&#39;] for repo in response.json()]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def tags(self):
<span class="w"> </span>        &quot;&quot;&quot;Names of tags in the repo&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;https://api.github.com/repos/{self.org}/{self.repo}/tags&quot;</span>
<span class="gi">+        response = requests.get(url, timeout=self.timeout, auth=(self.username, self.token) if self.username else None)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        return [tag[&#39;name&#39;] for tag in response.json()]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def branches(self):
<span class="w"> </span>        &quot;&quot;&quot;Names of branches in the repo&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;https://api.github.com/repos/{self.org}/{self.repo}/branches&quot;</span>
<span class="gi">+        response = requests.get(url, timeout=self.timeout, auth=(self.username, self.token) if self.username else None)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        return [branch[&#39;name&#39;] for branch in response.json()]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def refs(self):
<span class="w"> </span>        &quot;&quot;&quot;Named references, tags and branches&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;tags&#39;: self.tags,</span>
<span class="gi">+            &#39;branches&#39;: self.branches</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def ls(self, path, detail=False, sha=None, _sha=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;List files at given path
<span class="gu">@@ -105,4 +117,31 @@ class GithubFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        _sha: str (optional)
<span class="w"> </span>            List this specific tree object (used internally to descend into trees)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sha = sha or self.root</span>
<span class="gi">+        if _sha is None:</span>
<span class="gi">+            url = self.url.format(org=self.org, repo=self.repo, sha=sha)</span>
<span class="gi">+            if path:</span>
<span class="gi">+                url += &#39;/&#39; + path.lstrip(&#39;/&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = f&quot;https://api.github.com/repos/{self.org}/{self.repo}/git/trees/{_sha}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        response = requests.get(url, timeout=self.timeout, auth=(self.username, self.token) if self.username else None)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        data = response.json()</span>
<span class="gi">+</span>
<span class="gi">+        out = []</span>
<span class="gi">+        for item in data.get(&#39;tree&#39;, []):</span>
<span class="gi">+            if detail:</span>
<span class="gi">+                out.append({</span>
<span class="gi">+                    &#39;name&#39;: item[&#39;path&#39;],</span>
<span class="gi">+                    &#39;size&#39;: item.get(&#39;size&#39;, 0),</span>
<span class="gi">+                    &#39;type&#39;: &#39;directory&#39; if item[&#39;type&#39;] == &#39;tree&#39; else &#39;file&#39;,</span>
<span class="gi">+                    &#39;sha&#39;: item[&#39;sha&#39;]</span>
<span class="gi">+                })</span>
<span class="gi">+            else:</span>
<span class="gi">+                out.append(item[&#39;path&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        if detail:</span>
<span class="gi">+            return out</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sorted(out)</span>
<span class="gh">diff --git a/fsspec/implementations/http.py b/fsspec/implementations/http.py</span>
<span class="gh">index 94a6f71..e137fb8 100644</span>
<span class="gd">--- a/fsspec/implementations/http.py</span>
<span class="gi">+++ b/fsspec/implementations/http.py</span>
<span class="gu">@@ -84,14 +84,16 @@ class HTTPFileSystem(AsyncFileSystem):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _strip_protocol(cls, path):
<span class="w"> </span>        &quot;&quot;&quot;For HTTP, we always want to keep the full URL&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return path</span>
<span class="w"> </span>    ls = sync_wrapper(_ls)

<span class="w"> </span>    def _raise_not_found_for_status(self, response, url):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Raises FileNotFoundError for 404s, otherwise uses raise_for_status.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if response.status == 404:</span>
<span class="gi">+            raise FileNotFoundError(f&quot;{url} not found&quot;)</span>
<span class="gi">+        response.raise_for_status()</span>

<span class="w"> </span>    def _open(self, path, mode=&#39;rb&#39;, block_size=None, autocommit=None,
<span class="w"> </span>        cache_type=None, cache_options=None, size=None, **kwargs):
<span class="gu">@@ -109,11 +111,21 @@ class HTTPFileSystem(AsyncFileSystem):</span>
<span class="w"> </span>        kwargs: key-value
<span class="w"> </span>            Any other parameters, passed to requests calls
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mode != &#39;rb&#39;:</span>
<span class="gi">+            raise NotImplementedError(&quot;Only &#39;rb&#39; mode is supported for HTTP&quot;)</span>
<span class="gi">+        block_size = block_size or self.block_size</span>
<span class="gi">+        if block_size == 0:</span>
<span class="gi">+            return HTTPStreamFile(self, path, mode=mode, loop=self.loop, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return HTTPFile(self, path, mode=mode, block_size=block_size,</span>
<span class="gi">+                            cache_type=cache_type or self.cache_type,</span>
<span class="gi">+                            cache_options=cache_options or self.cache_options,</span>
<span class="gi">+                            size=size, loop=self.loop, asynchronous=self.asynchronous,</span>
<span class="gi">+                            **kwargs)</span>

<span class="w"> </span>    def ukey(self, url):
<span class="w"> </span>        &quot;&quot;&quot;Unique identifier; assume HTTP files are static, unchanging&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tokenize(url)</span>

<span class="w"> </span>    async def _info(self, url, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Get info of URL
<span class="gu">@@ -125,17 +137,82 @@ class HTTPFileSystem(AsyncFileSystem):</span>
<span class="w"> </span>        which case size will be given as None (and certain operations on the
<span class="w"> </span>        corresponding file will not work).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        session = await self.set_session()</span>
<span class="gi">+        try:</span>
<span class="gi">+            size, name = await _file_info(url, session=session, **self.kwargs)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # If HEAD fails, try GET</span>
<span class="gi">+            r = await session.get(self.encode_url(url), **self.kwargs)</span>
<span class="gi">+            self._raise_not_found_for_status(r, url)</span>
<span class="gi">+            await r.release()</span>
<span class="gi">+            size = int(r.headers.get(&#39;Content-Length&#39;, 0)) or None</span>
<span class="gi">+            name = url.split(&#39;/&#39;)[-1]</span>
<span class="gi">+        return {&#39;name&#39;: name, &#39;size&#39;: size, &#39;type&#39;: &#39;file&#39;}</span>

<span class="w"> </span>    async def _glob(self, path, maxdepth=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find files by glob-matching.

<span class="gd">-        This implementation is idntical to the one in AbstractFileSystem,</span>
<span class="gi">+        This implementation is identical to the one in AbstractFileSystem,</span>
<span class="w"> </span>        but &quot;?&quot; is not considered as a character for globbing, because it is
<span class="w"> </span>        so common in URLs, often identifying the &quot;query&quot; part.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import posixpath</span>
<span class="gi">+        import re</span>
<span class="gi">+        from fsspec.utils import other_paths</span>
<span class="gi">+</span>
<span class="gi">+        if maxdepth is not None:</span>
<span class="gi">+            return super()._glob(path, maxdepth)</span>
<span class="gi">+</span>
<span class="gi">+        url_parts = urlparse(path)</span>
<span class="gi">+        base_path = url_parts.scheme + &#39;://&#39; + url_parts.netloc</span>
<span class="gi">+        glob_path = url_parts.path</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;?&#39; in path and &#39;*&#39; not in path:</span>
<span class="gi">+            # If there&#39;s a query string but no glob characters, treat it as a literal path</span>
<span class="gi">+            return [path] if await self._exists(path) else []</span>
<span class="gi">+</span>
<span class="gi">+        ends = glob_path.endswith(&#39;/&#39;)</span>
<span class="gi">+        sep = &#39;/&#39;</span>
<span class="gi">+        scheme = url_parts.scheme</span>
<span class="gi">+</span>
<span class="gi">+        path = self._strip_protocol(path)</span>
<span class="gi">+        indstar = path.find(&#39;*&#39;) if path.find(&#39;*&#39;) &gt;= 0 else len(path)</span>
<span class="gi">+        indques = path.find(&#39;?&#39;) if path.find(&#39;?&#39;) &gt;= 0 else len(path)</span>
<span class="gi">+        indbrace = path.find(&#39;[&#39;) if path.find(&#39;[&#39;) &gt;= 0 else len(path)</span>
<span class="gi">+</span>
<span class="gi">+        ind = min(indstar, indques, indbrace)</span>
<span class="gi">+</span>
<span class="gi">+        detail = kwargs.pop(&#39;detail&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+        if not has_magic(glob_path):</span>
<span class="gi">+            if await self._exists(path):</span>
<span class="gi">+                return [{&#39;name&#39;: path, &#39;type&#39;: &#39;file&#39;}] if detail else [path]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return []</span>
<span class="gi">+</span>
<span class="gi">+        parent = posixpath.dirname(glob_path[:ind])</span>
<span class="gi">+        fileglob = glob_path[ind:]</span>
<span class="gi">+        pattern = re.compile(glob_translate(fileglob))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            entries = await self._ls(base_path + parent)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        out = []</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            if entry[&#39;type&#39;] == &#39;file&#39;:</span>
<span class="gi">+                name = entry[&#39;name&#39;].split(&#39;/&#39;)[-1]</span>
<span class="gi">+                if pattern.match(name):</span>
<span class="gi">+                    out.append(entry if detail else base_path + entry[&#39;name&#39;])</span>
<span class="gi">+            elif entry[&#39;type&#39;] == &#39;directory&#39; and fileglob:</span>
<span class="gi">+                path = base_path + entry[&#39;name&#39;]</span>
<span class="gi">+                if ends:</span>
<span class="gi">+                    path = path + &#39;/&#39;</span>
<span class="gi">+                out.extend(await self._glob(path + fileglob, maxdepth=maxdepth, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        return out</span>


<span class="w"> </span>class HTTPFile(AbstractBufferedFile):
<span class="gu">@@ -186,7 +263,15 @@ class HTTPFile(AbstractBufferedFile):</span>
<span class="w"> </span>            file. If the server has not supplied the filesize, attempting to
<span class="w"> </span>            read only part of the data will raise a ValueError.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.mode != &#39;rb&#39;:</span>
<span class="gi">+            raise ValueError(&#39;File not in read mode&#39;)</span>
<span class="gi">+        if length &lt; 0:</span>
<span class="gi">+            length = self.size</span>
<span class="gi">+        if self.size is None:</span>
<span class="gi">+            if length &gt;= 0:</span>
<span class="gi">+                raise ValueError(&quot;Cannot read partial file of unknown size&quot;)</span>
<span class="gi">+            return self._fetch_all()</span>
<span class="gi">+        return self.cache.read(self.loc, length)</span>

<span class="w"> </span>    async def async_fetch_all(self):
<span class="w"> </span>        &quot;&quot;&quot;Read whole file in one shot, without caching
<span class="gu">@@ -194,12 +279,26 @@ class HTTPFile(AbstractBufferedFile):</span>
<span class="w"> </span>        This is only called when position is still at zero,
<span class="w"> </span>        and read() is called without a byte-count.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.size is not None:</span>
<span class="gi">+            length = self.size</span>
<span class="gi">+        else:</span>
<span class="gi">+            length = None</span>
<span class="gi">+        r = await self.session.get(self.fs.encode_url(self.url), **self.kwargs)</span>
<span class="gi">+        self.fs._raise_not_found_for_status(r, self.url)</span>
<span class="gi">+        out = await r.read()</span>
<span class="gi">+        self.size = len(out)</span>
<span class="gi">+        return out</span>
<span class="w"> </span>    _fetch_all = sync_wrapper(async_fetch_all)

<span class="w"> </span>    def _parse_content_range(self, headers):
<span class="w"> </span>        &quot;&quot;&quot;Parse the Content-Range header&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;Content-Range&#39; in headers:</span>
<span class="gi">+            content_range = headers[&#39;Content-Range&#39;]</span>
<span class="gi">+            match = re.match(r&#39;bytes (\d+)-(\d+)/(\d+|\*)&#39;, content_range)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                start, end, total = match.groups()</span>
<span class="gi">+                return int(start), int(end), int(total) if total != &#39;*&#39; else None</span>
<span class="gi">+        return None, None, None</span>

<span class="w"> </span>    async def async_fetch_range(self, start, end):
<span class="w"> </span>        &quot;&quot;&quot;Download a block of data
<span class="gu">@@ -209,7 +308,29 @@ class HTTPFile(AbstractBufferedFile):</span>
<span class="w"> </span>        and then stream the output - if the data size is bigger than we
<span class="w"> </span>        requested, an exception is raised.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = self.kwargs.copy()</span>
<span class="gi">+        headers = kwargs.pop(&#39;headers&#39;, {}).copy()</span>
<span class="gi">+        headers[&#39;Range&#39;] = f&#39;bytes={start}-{end-1}&#39;</span>
<span class="gi">+        r = await self.session.get(self.fs.encode_url(self.url), headers=headers, **kwargs)</span>
<span class="gi">+        self.fs._raise_not_found_for_status(r, self.url)</span>
<span class="gi">+        if r.status == 206:</span>
<span class="gi">+            # Partial content response, as expected</span>
<span class="gi">+            cr_start, cr_end, cr_total = self._parse_content_range(r.headers)</span>
<span class="gi">+            if cr_start is not None:</span>
<span class="gi">+                assert start == cr_start, &quot;Requested range does not match Content-Range&quot;</span>
<span class="gi">+            if cr_end is not None:</span>
<span class="gi">+                assert end == cr_end + 1, &quot;Requested range does not match Content-Range&quot;</span>
<span class="gi">+            if cr_total is not None:</span>
<span class="gi">+                self.size = cr_total</span>
<span class="gi">+        elif self.size is not None:</span>
<span class="gi">+            raise ValueError(&quot;Server ignored the range request&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No range information, have to stream all data</span>
<span class="gi">+            cl = int(r.headers.get(&#39;Content-Length&#39;, 0))</span>
<span class="gi">+            if cl and cl &gt; end - start:</span>
<span class="gi">+                raise ValueError(&quot;Got more bytes than requested&quot;)</span>
<span class="gi">+        out = await r.read()</span>
<span class="gi">+        return out[: end - start]</span>
<span class="w"> </span>    _fetch_range = sync_wrapper(async_fetch_range)

<span class="w"> </span>    def __reduce__(self):
<span class="gu">@@ -268,7 +389,39 @@ async def _file_info(url, session, size_policy=&#39;head&#39;, **kwargs):</span>
<span class="w"> </span>    Default operation is to explicitly allow redirects and use encoding
<span class="w"> </span>    &#39;identity&#39; (no compression) to get the true size of the target.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kwargs = kwargs.copy()</span>
<span class="gi">+    kwargs.pop(&#39;method&#39;, None)</span>
<span class="gi">+    head_method = kwargs.pop(&#39;head_method&#39;, &#39;head&#39;)</span>
<span class="gi">+    kwargs[&#39;allow_redirects&#39;] = True</span>
<span class="gi">+    kwargs[&#39;headers&#39;] = {&#39;Accept-Encoding&#39;: &#39;identity&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    info = {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        if head_method == &#39;head&#39;:</span>
<span class="gi">+            r = await session.head(url, **kwargs)</span>
<span class="gi">+        elif head_method == &#39;get&#39;:</span>
<span class="gi">+            r = await session.get(url, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;head_method must be &#39;head&#39; or &#39;get&#39;, got {head_method}&quot;)</span>
<span class="gi">+        r.raise_for_status()</span>
<span class="gi">+</span>
<span class="gi">+        info[&#39;name&#39;] = url.split(&#39;/&#39;)[-1]</span>
<span class="gi">+        info[&#39;size&#39;] = int(r.headers.get(&#39;Content-Length&#39;, 0)) or None</span>
<span class="gi">+        if &#39;Content-Type&#39; in r.headers:</span>
<span class="gi">+            info[&#39;type&#39;] = r.headers[&#39;Content-Type&#39;]</span>
<span class="gi">+        if &#39;Last-Modified&#39; in r.headers:</span>
<span class="gi">+            info[&#39;mtime&#39;] = r.headers[&#39;Last-Modified&#39;]</span>
<span class="gi">+        if &#39;ETag&#39; in r.headers:</span>
<span class="gi">+            info[&#39;etag&#39;] = r.headers[&#39;ETag&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        if size_policy == &#39;head&#39;:</span>
<span class="gi">+            # Try GET request if HEAD fails</span>
<span class="gi">+            return await _file_info(url, session, size_policy=&#39;get&#39;, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise exc</span>
<span class="gi">+</span>
<span class="gi">+    return info[&#39;size&#39;], info[&#39;name&#39;]</span>


<span class="w"> </span>file_size = sync_wrapper(_file_size)
<span class="gh">diff --git a/fsspec/implementations/jupyter.py b/fsspec/implementations/jupyter.py</span>
<span class="gh">index 7da1be6..03f6b38 100644</span>
<span class="gd">--- a/fsspec/implementations/jupyter.py</span>
<span class="gi">+++ b/fsspec/implementations/jupyter.py</span>
<span class="gu">@@ -34,12 +34,87 @@ class JupyterFileSystem(fsspec.AbstractFileSystem):</span>
<span class="w"> </span>            self.session.headers[&#39;Authorization&#39;] = f&#39;token {tok}&#39;
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    def ls(self, path, detail=True, **kwargs):</span>
<span class="gi">+        &quot;&quot;&quot;List contents of path.&quot;&quot;&quot;</span>
<span class="gi">+        url = f&quot;{self.url}/{path.strip(&#39;/&#39;)}&quot;</span>
<span class="gi">+        response = self.session.get(url)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        data = response.json()</span>
<span class="gi">+        </span>
<span class="gi">+        if data[&#39;type&#39;] == &#39;directory&#39;:</span>
<span class="gi">+            contents = data[&#39;content&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            contents = [data]</span>
<span class="gi">+        </span>
<span class="gi">+        if detail:</span>
<span class="gi">+            return [{</span>
<span class="gi">+                &#39;name&#39;: item[&#39;name&#39;],</span>
<span class="gi">+                &#39;size&#39;: item[&#39;size&#39;],</span>
<span class="gi">+                &#39;type&#39;: &#39;directory&#39; if item[&#39;type&#39;] == &#39;directory&#39; else &#39;file&#39;,</span>
<span class="gi">+                &#39;mtime&#39;: item[&#39;last_modified&#39;]</span>
<span class="gi">+            } for item in contents]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [item[&#39;name&#39;] for item in contents]</span>
<span class="gi">+</span>
<span class="gi">+    def _open(self, path, mode=&#39;rb&#39;, **kwargs):</span>
<span class="gi">+        &quot;&quot;&quot;Open a file.&quot;&quot;&quot;</span>
<span class="gi">+        if mode in (&#39;rb&#39;, &#39;r&#39;):</span>
<span class="gi">+            url = f&quot;{self.url}/{path.strip(&#39;/&#39;)}&quot;</span>
<span class="gi">+            response = self.session.get(url)</span>
<span class="gi">+            response.raise_for_status()</span>
<span class="gi">+            data = response.json()</span>
<span class="gi">+            content = base64.b64decode(data[&#39;content&#39;]) if data[&#39;format&#39;] == &#39;base64&#39; else data[&#39;content&#39;].encode()</span>
<span class="gi">+            return io.BytesIO(content)</span>
<span class="gi">+        elif mode in (&#39;wb&#39;, &#39;w&#39;):</span>
<span class="gi">+            return SimpleFileWriter(self, path, mode, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Unsupported mode: {mode}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _rm(self, path):</span>
<span class="gi">+        &quot;&quot;&quot;Remove a file.&quot;&quot;&quot;</span>
<span class="gi">+        url = f&quot;{self.url}/{path.strip(&#39;/&#39;)}&quot;</span>
<span class="gi">+        response = self.session.delete(url)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+</span>
<span class="gi">+    def _mkdir(self, path, create_parents=True, **kwargs):</span>
<span class="gi">+        &quot;&quot;&quot;Create a directory.&quot;&quot;&quot;</span>
<span class="gi">+        url = f&quot;{self.url}/{path.strip(&#39;/&#39;)}&quot;</span>
<span class="gi">+        data = {&#39;type&#39;: &#39;directory&#39;}</span>
<span class="gi">+        response = self.session.put(url, json=data)</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+</span>

<span class="w"> </span>class SimpleFileWriter(fsspec.spec.AbstractBufferedFile):

<span class="gi">+    def __init__(self, fs, path, mode=&#39;wb&#39;, **kwargs):</span>
<span class="gi">+        self.fs = fs</span>
<span class="gi">+        self.path = path</span>
<span class="gi">+        self.buffer = io.BytesIO()</span>
<span class="gi">+        super().__init__(fs=fs, path=path, mode=mode, **kwargs)</span>
<span class="gi">+</span>
<span class="w"> </span>    def _upload_chunk(self, final=False):
<span class="w"> </span>        &quot;&quot;&quot;Never uploads a chunk until file is done

<span class="w"> </span>        Not suitable for large files
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if final:</span>
<span class="gi">+            content = self.buffer.getvalue()</span>
<span class="gi">+            url = f&quot;{self.fs.url}/{self.path.strip(&#39;/&#39;)}&quot;</span>
<span class="gi">+            data = {</span>
<span class="gi">+                &#39;type&#39;: &#39;file&#39;,</span>
<span class="gi">+                &#39;format&#39;: &#39;base64&#39;,</span>
<span class="gi">+                &#39;content&#39;: base64.b64encode(content).decode()</span>
<span class="gi">+            }</span>
<span class="gi">+            response = self.fs.session.put(url, json=data)</span>
<span class="gi">+            response.raise_for_status()</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data):</span>
<span class="gi">+        &quot;&quot;&quot;Write data to buffer.&quot;&quot;&quot;</span>
<span class="gi">+        self.buffer.write(data)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        &quot;&quot;&quot;Close the file and upload the content.&quot;&quot;&quot;</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            self._upload_chunk(final=True)</span>
<span class="gi">+            self.buffer.close()</span>
<span class="gi">+            super().close()</span>
<span class="gh">diff --git a/fsspec/implementations/libarchive.py b/fsspec/implementations/libarchive.py</span>
<span class="gh">index c2101dc..96813ee 100644</span>
<span class="gd">--- a/fsspec/implementations/libarchive.py</span>
<span class="gi">+++ b/fsspec/implementations/libarchive.py</span>
<span class="gu">@@ -19,7 +19,28 @@ def custom_reader(file, format_name=&#39;all&#39;, filter_name=&#39;all&#39;, block_size=</span>

<span class="w"> </span>    The `file` object must support the standard `readinto` and &#39;seek&#39; methods.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def read_cb(archive, context, buffer):</span>
<span class="gi">+        size = len(buffer)</span>
<span class="gi">+        data = file.read(size)</span>
<span class="gi">+        if data:</span>
<span class="gi">+            buffer[:len(data)] = data</span>
<span class="gi">+            return len(data)</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def seek_cb(archive, context, offset, whence):</span>
<span class="gi">+        return file.seek(offset, whence)</span>
<span class="gi">+</span>
<span class="gi">+    read_func = CFUNCTYPE(c_size_t, c_void_p, c_void_p, POINTER(c_char))(read_cb)</span>
<span class="gi">+    seek_func = SEEK_CALLBACK(seek_cb)</span>
<span class="gi">+</span>
<span class="gi">+    with libarchive.read_memory(</span>
<span class="gi">+        None, block_size, format_name, filter_name</span>
<span class="gi">+    ) as archive:</span>
<span class="gi">+        libarchive.ffi.read_set_seek_callback(archive._pointer, seek_func)</span>
<span class="gi">+        libarchive.ffi.read_set_read_callback(archive._pointer, read_func)</span>
<span class="gi">+        libarchive.ffi.read_set_callback_data(archive._pointer, None)</span>
<span class="gi">+        libarchive.ffi.read_open1(archive._pointer)</span>
<span class="gi">+        yield archive</span>


<span class="w"> </span>class LibArchiveFileSystem(AbstractArchiveFileSystem):
<span class="gu">@@ -60,7 +81,7 @@ class LibArchiveFileSystem(AbstractArchiveFileSystem):</span>
<span class="w"> </span>            Kwargs passed when instantiating the target FS, if ``fo`` is
<span class="w"> </span>            a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        super().__init__(self, **kwargs)</span>
<span class="gi">+        super().__init__(**kwargs)</span>
<span class="w"> </span>        if mode != &#39;r&#39;:
<span class="w"> </span>            raise ValueError(&#39;Only read from archive files accepted&#39;)
<span class="w"> </span>        if isinstance(fo, str):
<span class="gu">@@ -75,3 +96,41 @@ class LibArchiveFileSystem(AbstractArchiveFileSystem):</span>
<span class="w"> </span>        self.fo = fo.__enter__()
<span class="w"> </span>        self.block_size = block_size
<span class="w"> </span>        self.dir_cache = None
<span class="gi">+        self._archive = None</span>
<span class="gi">+</span>
<span class="gi">+    def __exit__(self, *args, **kwargs):</span>
<span class="gi">+        self.fo.__exit__(*args, **kwargs)</span>
<span class="gi">+        self.of.__exit__(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_dirs(self):</span>
<span class="gi">+        if self.dir_cache is None:</span>
<span class="gi">+            self.dir_cache = {}</span>
<span class="gi">+            with custom_reader(self.fo) as archive:</span>
<span class="gi">+                for entry in archive:</span>
<span class="gi">+                    path = entry.pathname.lstrip(&#39;/&#39;)</span>
<span class="gi">+                    self.dir_cache[path] = dict(</span>
<span class="gi">+                        size=entry.size,</span>
<span class="gi">+                        mtime=entry.mtime</span>
<span class="gi">+                    )</span>
<span class="gi">+        return self.dir_cache</span>
<span class="gi">+</span>
<span class="gi">+    def _open(self, path, mode=&quot;rb&quot;, **kwargs):</span>
<span class="gi">+        if mode != &quot;rb&quot;:</span>
<span class="gi">+            raise NotImplementedError(&quot;Only read-binary mode is supported&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        path = path.lstrip(&#39;/&#39;)</span>
<span class="gi">+        with custom_reader(self.fo) as archive:</span>
<span class="gi">+            for entry in archive:</span>
<span class="gi">+                if entry.pathname.lstrip(&#39;/&#39;) == path:</span>
<span class="gi">+                    data = entry.read()</span>
<span class="gi">+                    return MemoryFile(data)</span>
<span class="gi">+        raise FileNotFoundError(path)</span>
<span class="gi">+</span>
<span class="gi">+    def info(self, path, **kwargs):</span>
<span class="gi">+        path = path.lstrip(&#39;/&#39;)</span>
<span class="gi">+        dirs = self._get_dirs()</span>
<span class="gi">+        if path in dirs:</span>
<span class="gi">+            return dirs[path]</span>
<span class="gi">+        elif path + &#39;/&#39; in dirs:</span>
<span class="gi">+            return {&#39;type&#39;: &#39;directory&#39;}</span>
<span class="gi">+        raise FileNotFoundError(path)</span>
<span class="gh">diff --git a/fsspec/implementations/local.py b/fsspec/implementations/local.py</span>
<span class="gh">index af01bea..f8d5c55 100644</span>
<span class="gd">--- a/fsspec/implementations/local.py</span>
<span class="gi">+++ b/fsspec/implementations/local.py</span>
<span class="gu">@@ -34,7 +34,10 @@ class LocalFileSystem(AbstractFileSystem):</span>

<span class="w"> </span>def make_path_posix(path):
<span class="w"> </span>    &quot;&quot;&quot;Make path generic and absolute for current OS&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = os.path.abspath(os.path.expanduser(path))</span>
<span class="gi">+    if os.sep == &#39;\\&#39;:</span>
<span class="gi">+        path = path.replace(&#39;\\&#39;, &#39;/&#39;)</span>
<span class="gi">+    return path</span>


<span class="w"> </span>def trailing_sep(path):
<span class="gu">@@ -43,7 +46,7 @@ def trailing_sep(path):</span>
<span class="w"> </span>    A forward slash is always considered a path separator, even on Operating
<span class="w"> </span>    Systems that normally use a backslash.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return path.endswith(&#39;/&#39;) or (os.sep != &#39;/&#39; and path.endswith(os.sep))</span>


<span class="w"> </span>class LocalFileOpener(io.IOBase):
<span class="gh">diff --git a/fsspec/implementations/memory.py b/fsspec/implementations/memory.py</span>
<span class="gh">index e1fdbd3..cef0294 100644</span>
<span class="gd">--- a/fsspec/implementations/memory.py</span>
<span class="gi">+++ b/fsspec/implementations/memory.py</span>
<span class="gu">@@ -22,12 +22,118 @@ class MemoryFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>    protocol = &#39;memory&#39;
<span class="w"> </span>    root_marker = &#39;/&#39;

<span class="gi">+    def __init__(self, *args, **storage_options):</span>
<span class="gi">+        super().__init__(*args, **storage_options)</span>
<span class="gi">+</span>
<span class="w"> </span>    def pipe_file(self, path, value, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Set the bytes of given file

<span class="w"> </span>        Avoids copies of the data if possible
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if isinstance(value, bytes):</span>
<span class="gi">+            data = value</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = value.read()</span>
<span class="gi">+        self.store[path] = MemoryFile(self, path, data)</span>
<span class="gi">+        self._add_pseudo_dirs(path)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_pseudo_dirs(self, path):</span>
<span class="gi">+        parts = path.split(&#39;/&#39;)</span>
<span class="gi">+        for i in range(1, len(parts)):</span>
<span class="gi">+            parent = &#39;/&#39;.join(parts[:i])</span>
<span class="gi">+            if parent not in self.pseudo_dirs:</span>
<span class="gi">+                self.pseudo_dirs.append(parent)</span>
<span class="gi">+</span>
<span class="gi">+    def mkdir(self, path, create_parents=True, **kwargs):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if path in self.store:</span>
<span class="gi">+            raise FileExistsError(f&quot;File or directory {path} already exists&quot;)</span>
<span class="gi">+        self._add_pseudo_dirs(path)</span>
<span class="gi">+</span>
<span class="gi">+    def rmdir(self, path):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if path not in self.pseudo_dirs:</span>
<span class="gi">+            raise FileNotFoundError(f&quot;Directory {path} does not exist&quot;)</span>
<span class="gi">+        if any(k.startswith(path + &#39;/&#39;) for k in self.store):</span>
<span class="gi">+            raise OSError(ENOTEMPTY, &quot;Directory not empty&quot;, path)</span>
<span class="gi">+        self.pseudo_dirs.remove(path)</span>
<span class="gi">+</span>
<span class="gi">+    def ls(self, path, detail=False, **kwargs):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path)).rstrip(&#39;/&#39;)</span>
<span class="gi">+        paths = set()</span>
<span class="gi">+        for p in list(self.store) + self.pseudo_dirs:</span>
<span class="gi">+            if p.startswith(path + &#39;/&#39;) or p == path:</span>
<span class="gi">+                paths.add(p.split(&#39;/&#39;, 1)[0] if path == &#39;&#39; else &#39;/&#39;.join([path, p[len(path) + 1:].split(&#39;/&#39;, 1)[0]]))</span>
<span class="gi">+        if not paths and path not in self.pseudo_dirs:</span>
<span class="gi">+            raise FileNotFoundError(path)</span>
<span class="gi">+        if detail:</span>
<span class="gi">+            return [self.info(p) for p in sorted(paths)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sorted(paths)</span>
<span class="gi">+</span>
<span class="gi">+    def info(self, path, **kwargs):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if path in self.store:</span>
<span class="gi">+            return {</span>
<span class="gi">+                &#39;name&#39;: path,</span>
<span class="gi">+                &#39;size&#39;: len(self.store[path].getvalue()),</span>
<span class="gi">+                &#39;type&#39;: &#39;file&#39;,</span>
<span class="gi">+                &#39;created&#39;: self.store[path].created.isoformat(),</span>
<span class="gi">+                &#39;modified&#39;: self.store[path].modified.isoformat(),</span>
<span class="gi">+            }</span>
<span class="gi">+        elif path in self.pseudo_dirs:</span>
<span class="gi">+            return {</span>
<span class="gi">+                &#39;name&#39;: path,</span>
<span class="gi">+                &#39;size&#39;: 0,</span>
<span class="gi">+                &#39;type&#39;: &#39;directory&#39;,</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise FileNotFoundError(path)</span>
<span class="gi">+</span>
<span class="gi">+    def _open(self, path, mode=&#39;rb&#39;, **kwargs):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if mode in (&#39;rb&#39;, &#39;r&#39;):</span>
<span class="gi">+            if path not in self.store:</span>
<span class="gi">+                raise FileNotFoundError(path)</span>
<span class="gi">+            return MemoryFile(self, path, self.store[path].getvalue())</span>
<span class="gi">+        elif mode in (&#39;wb&#39;, &#39;w&#39;):</span>
<span class="gi">+            self.store[path] = MemoryFile(self, path)</span>
<span class="gi">+            self._add_pseudo_dirs(path)</span>
<span class="gi">+            return self.store[path]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unsupported file mode&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def rm(self, path, recursive=False, maxdepth=None):</span>
<span class="gi">+        path = self._strip_protocol(stringify_path(path))</span>
<span class="gi">+        if path in self.store:</span>
<span class="gi">+            del self.store[path]</span>
<span class="gi">+        elif recursive:</span>
<span class="gi">+            for p in list(self.store):</span>
<span class="gi">+                if p.startswith(path + &#39;/&#39;):</span>
<span class="gi">+                    del self.store[p]</span>
<span class="gi">+            for p in list(self.pseudo_dirs):</span>
<span class="gi">+                if p.startswith(path + &#39;/&#39;):</span>
<span class="gi">+                    self.pseudo_dirs.remove(p)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise FileNotFoundError(path)</span>
<span class="gi">+</span>
<span class="gi">+    def mv(self, path1, path2, **kwargs):</span>
<span class="gi">+        path1 = self._strip_protocol(stringify_path(path1))</span>
<span class="gi">+        path2 = self._strip_protocol(stringify_path(path2))</span>
<span class="gi">+        if path1 not in self.store:</span>
<span class="gi">+            raise FileNotFoundError(path1)</span>
<span class="gi">+        self.store[path2] = self.store.pop(path1)</span>
<span class="gi">+        self.store[path2].path = path2</span>
<span class="gi">+        self._add_pseudo_dirs(path2)</span>
<span class="gi">+</span>
<span class="gi">+    def cp(self, path1, path2, **kwargs):</span>
<span class="gi">+        path1 = self._strip_protocol(stringify_path(path1))</span>
<span class="gi">+        path2 = self._strip_protocol(stringify_path(path2))</span>
<span class="gi">+        if path1 not in self.store:</span>
<span class="gi">+            raise FileNotFoundError(path1)</span>
<span class="gi">+        self.store[path2] = MemoryFile(self, path2, self.store[path1].getvalue())</span>
<span class="gi">+        self._add_pseudo_dirs(path2)</span>


<span class="w"> </span>class MemoryFile(BytesIO):
<span class="gu">@@ -47,6 +153,23 @@ class MemoryFile(BytesIO):</span>
<span class="w"> </span>        if data:
<span class="w"> </span>            super().__init__(data)
<span class="w"> </span>            self.seek(0)
<span class="gi">+        else:</span>
<span class="gi">+            super().__init__()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gi">+</span>
<span class="gi">+    def __exit__(self, exc_type, exc_val, exc_tb):</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self):</span>
<span class="gi">+        self.modified = datetime.now(tz=timezone.utc)</span>
<span class="gi">+        if self.fs is not None and self.path is not None:</span>
<span class="gi">+            self.fs.store[self.path] = self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, data):</span>
<span class="gi">+        self.modified = datetime.now(tz=timezone.utc)</span>
<span class="gi">+        return super().write(data)</span>
<span class="gh">diff --git a/fsspec/implementations/reference.py b/fsspec/implementations/reference.py</span>
<span class="gh">index 608bb67..a92f711 100644</span>
<span class="gd">--- a/fsspec/implementations/reference.py</span>
<span class="gi">+++ b/fsspec/implementations/reference.py</span>
<span class="gu">@@ -122,39 +122,106 @@ class LazyReferenceMapper(collections.abc.MutableMapping):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        LazyReferenceMapper instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fs is None:</span>
<span class="gi">+            fs = fsspec.filesystem(&#39;file&#39;, **(storage_options or {}))</span>
<span class="gi">+        </span>
<span class="gi">+        if fs.exists(root):</span>
<span class="gi">+            fs.rm(root, recursive=True)</span>
<span class="gi">+        fs.mkdir(root)</span>
<span class="gi">+        </span>
<span class="gi">+        mapper = LazyReferenceMapper(root, fs=fs, record_size=record_size, **kwargs)</span>
<span class="gi">+        mapper.zmetadata = {}</span>
<span class="gi">+        mapper._items = {}</span>
<span class="gi">+        mapper.record_size = record_size</span>
<span class="gi">+        return mapper</span>

<span class="w"> </span>    def listdir(self, basename=True):
<span class="w"> </span>        &quot;&quot;&quot;List top-level directories&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.dirs is None:</span>
<span class="gi">+            self.dirs = [d for d in self.fs.ls(self.root) if self.fs.isdir(d)]</span>
<span class="gi">+        if basename:</span>
<span class="gi">+            return [os.path.basename(d) for d in self.dirs]</span>
<span class="gi">+        return self.dirs</span>

<span class="w"> </span>    def ls(self, path=&#39;&#39;, detail=True):
<span class="w"> </span>        &quot;&quot;&quot;Shortcut file listings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if path:</span>
<span class="gi">+            out = self.fs.ls(os.path.join(self.root, path), detail=detail)</span>
<span class="gi">+        else:</span>
<span class="gi">+            out = self.fs.ls(self.root, detail=detail)</span>
<span class="gi">+        </span>
<span class="gi">+        if detail:</span>
<span class="gi">+            return [{**o, &#39;name&#39;: o[&#39;name&#39;].replace(self.root + &#39;/&#39;, &#39;&#39;)} for o in out]</span>
<span class="gi">+        return [o.replace(self.root + &#39;/&#39;, &#39;&#39;) for o in out]</span>

<span class="w"> </span>    def _load_one_key(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Get the reference for one key

<span class="w"> </span>        Returns bytes, one-element list or three-element list.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key in self._items:</span>
<span class="gi">+            return self._items[key]</span>
<span class="gi">+        if key in self.zmetadata:</span>
<span class="gi">+            return json.dumps(self.zmetadata[key]).encode()</span>
<span class="gi">+        if &#39;/&#39; not in key or self._is_meta(key):</span>
<span class="gi">+            raise KeyError(key)</span>
<span class="gi">+        </span>
<span class="gi">+        field, chunk = key.rsplit(&#39;/&#39;, 1)</span>
<span class="gi">+        record, i, _ = self._key_to_record(key)</span>
<span class="gi">+        df = self._generate_record(field, record)</span>
<span class="gi">+        if df is None or i &gt;= len(df):</span>
<span class="gi">+            raise KeyError(key)</span>
<span class="gi">+        row = df.iloc[i]</span>
<span class="gi">+        if isinstance(row[&#39;url&#39;], bytes):</span>
<span class="gi">+            return [row[&#39;url&#39;], row[&#39;offset&#39;], row[&#39;size&#39;]]</span>
<span class="gi">+        return row.tolist()</span>

<span class="w"> </span>    @lru_cache(4096)
<span class="w"> </span>    def _key_to_record(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Details needed to construct a reference for one key&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        field, chunk = key.rsplit(&#39;/&#39;, 1)</span>
<span class="gi">+        chunk_sizes = self._get_chunk_sizes(field)</span>
<span class="gi">+        if not chunk_sizes:</span>
<span class="gi">+            return 0, int(chunk), None</span>
<span class="gi">+        </span>
<span class="gi">+        parts = [int(p) for p in chunk.split(&#39;.&#39;)]</span>
<span class="gi">+        record = sum(p * s for p, s in zip(parts[:-1], chunk_sizes[1:]))</span>
<span class="gi">+        i = parts[-1]</span>
<span class="gi">+        return record // self.record_size, i % self.record_size, parts</span>

<span class="w"> </span>    def _get_chunk_sizes(self, field):
<span class="w"> </span>        &quot;&quot;&quot;The number of chunks along each axis for a given field&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if field not in self.chunk_sizes:</span>
<span class="gi">+            meta = self.zmetadata.get(f&quot;{field}/.zarray&quot;)</span>
<span class="gi">+            if meta:</span>
<span class="gi">+                self.chunk_sizes[field] = meta[&#39;chunks&#39;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.chunk_sizes[field] = []</span>
<span class="gi">+        return self.chunk_sizes[field]</span>

<span class="w"> </span>    def _generate_record(self, field, record):
<span class="w"> </span>        &quot;&quot;&quot;The references for a given parquet file of a given field&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import pandas as pd</span>
<span class="gi">+        url = self.url.format(field=field, record=record)</span>
<span class="gi">+        if not self.fs.exists(url):</span>
<span class="gi">+            return None</span>
<span class="gi">+        df = pd.read_parquet(self.fs.open(url, &#39;rb&#39;), engine=&#39;pyarrow&#39;)</span>
<span class="gi">+        if self.cat_thresh:</span>
<span class="gi">+            n = len(df)</span>
<span class="gi">+            for col in [&#39;url&#39;, &#39;offset&#39;, &#39;size&#39;]:</span>
<span class="gi">+                if df[col].nunique() / n &gt;= 1 / self.cat_thresh:</span>
<span class="gi">+                    df[col] = df[col].astype(&#39;category&#39;)</span>
<span class="gi">+        return df</span>

<span class="w"> </span>    def _generate_all_records(self, field):
<span class="w"> </span>        &quot;&quot;&quot;Load all the references within a field by iterating over the parquet files&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            df = self._generate_record(field, i)</span>
<span class="gi">+            if df is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            yield from df.itertuples(index=False, name=None)</span>
<span class="gi">+            i += 1</span>

<span class="w"> </span>    def __hash__(self):
<span class="w"> </span>        return id(self)
<span class="gu">@@ -235,7 +302,14 @@ class LazyReferenceMapper(collections.abc.MutableMapping):</span>

<span class="w"> </span>        Produces strings like &quot;field/x.y&quot; appropriate from the chunking of the array
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chunk_sizes = self._get_chunk_sizes(field)</span>
<span class="gi">+        if not chunk_sizes:</span>
<span class="gi">+            yield f&quot;{field}/0&quot;</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        ranges = [range(0, s) for s in chunk_sizes]</span>
<span class="gi">+        for parts in itertools.product(*ranges):</span>
<span class="gi">+            yield f&quot;{field}/{&#39;.&#39;.join(str(p) for p in parts)}&quot;</span>


<span class="w"> </span>class ReferenceFileSystem(AsyncFileSystem):
<span class="gh">diff --git a/fsspec/implementations/sftp.py b/fsspec/implementations/sftp.py</span>
<span class="gh">index 95b7f25..7e02fda 100644</span>
<span class="gd">--- a/fsspec/implementations/sftp.py</span>
<span class="gi">+++ b/fsspec/implementations/sftp.py</span>
<span class="gu">@@ -43,10 +43,24 @@ class SFTPFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        self.ssh_kwargs = ssh_kwargs
<span class="w"> </span>        self._connect()

<span class="gi">+    def _connect(self):</span>
<span class="gi">+        self.client = paramiko.SSHClient()</span>
<span class="gi">+        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span>
<span class="gi">+        self.client.connect(self.host, **self.ssh_kwargs)</span>
<span class="gi">+        self.sftp = self.client.open_sftp()</span>
<span class="gi">+</span>
<span class="w"> </span>    def _open(self, path, mode=&#39;rb&#39;, block_size=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        block_size: int or None
<span class="w"> </span>            If 0, no buffering, if 1, line buffering, if &gt;1, buffer that many
<span class="w"> </span>            bytes, if None use default from paramiko.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mode == &#39;rb&#39;:</span>
<span class="gi">+            f = self.sftp.open(path, mode=&#39;rb&#39;)</span>
<span class="gi">+            if block_size:</span>
<span class="gi">+                f.set_pipelined(block_size)</span>
<span class="gi">+            return f</span>
<span class="gi">+        elif mode in (&#39;wb&#39;, &#39;ab&#39;):</span>
<span class="gi">+            return self.sftp.open(path, mode=mode)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(&quot;Mode {} not supported&quot;.format(mode))</span>
<span class="gh">diff --git a/fsspec/implementations/smb.py b/fsspec/implementations/smb.py</span>
<span class="gh">index a4da1d4..f1ea120 100644</span>
<span class="gd">--- a/fsspec/implementations/smb.py</span>
<span class="gi">+++ b/fsspec/implementations/smb.py</span>
<span class="gu">@@ -106,11 +106,13 @@ class SMBFileSystem(AbstractFileSystem):</span>

<span class="w"> </span>    def created(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Return the created timestamp of a file as a datetime.datetime&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with smbclient.open_file(f&quot;//{self.host}/{path}&quot;, mode=&quot;r&quot;, username=self.username, password=self.password) as file:</span>
<span class="gi">+            return datetime.datetime.fromtimestamp(file.stat().st_ctime)</span>

<span class="w"> </span>    def modified(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Return the modified timestamp of a file as a datetime.datetime&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with smbclient.open_file(f&quot;//{self.host}/{path}&quot;, mode=&quot;r&quot;, username=self.username, password=self.password) as file:</span>
<span class="gi">+            return datetime.datetime.fromtimestamp(file.stat().st_mtime)</span>

<span class="w"> </span>    def _open(self, path, mode=&#39;rb&#39;, block_size=-1, autocommit=True,
<span class="w"> </span>        cache_options=None, **kwargs):
<span class="gu">@@ -123,11 +125,29 @@ class SMBFileSystem(AbstractFileSystem):</span>
<span class="w"> </span>        By specifying &#39;share_access&#39; in &#39;kwargs&#39; it is possible to override the
<span class="w"> </span>        default shared access setting applied in the constructor of this object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        share_access = kwargs.get(&#39;share_access&#39;, self.share_access)</span>
<span class="gi">+        full_path = f&quot;//{self.host}/{path}&quot;</span>
<span class="gi">+        </span>
<span class="gi">+        if self.auto_mkdir and &#39;w&#39; in mode:</span>
<span class="gi">+            self.makedirs(self._parent(path), exist_ok=True)</span>
<span class="gi">+        </span>
<span class="gi">+        return SMBFileOpener(</span>
<span class="gi">+            full_path,</span>
<span class="gi">+            self.temppath,</span>
<span class="gi">+            mode,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+            block_size=block_size,</span>
<span class="gi">+            username=self.username,</span>
<span class="gi">+            password=self.password,</span>
<span class="gi">+            share_access=share_access,</span>
<span class="gi">+            **kwargs</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def copy(self, path1, path2, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Copy within two locations in the same filesystem&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._open(path1, &#39;rb&#39;) as source:</span>
<span class="gi">+            with self._open(path2, &#39;wb&#39;) as destination:</span>
<span class="gi">+                destination.write(source.read())</span>


<span class="w"> </span>class SMBFileOpener:
<span class="gu">@@ -146,11 +166,15 @@ class SMBFileOpener:</span>

<span class="w"> </span>    def commit(self):
<span class="w"> </span>        &quot;&quot;&quot;Move temp file to definitive on success.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.temp:</span>
<span class="gi">+            smbclient.rename(self.temp, self.path, username=self.kwargs.get(&#39;username&#39;), password=self.kwargs.get(&#39;password&#39;))</span>
<span class="gi">+        self._open()</span>

<span class="w"> </span>    def discard(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove the temp file on failure.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.temp:</span>
<span class="gi">+            smbclient.remove(self.temp, username=self.kwargs.get(&#39;username&#39;), password=self.kwargs.get(&#39;password&#39;))</span>
<span class="gi">+        self._open()</span>

<span class="w"> </span>    def __fspath__(self):
<span class="w"> </span>        return self.path
<span class="gh">diff --git a/fsspec/implementations/tests/local/local_fixtures.py b/fsspec/implementations/tests/local/local_fixtures.py</span>
<span class="gh">index a549f6d..969c50d 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/local/local_fixtures.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/local/local_fixtures.py</span>
<span class="gu">@@ -1,7 +1,94 @@</span>
<span class="w"> </span>import pytest
<span class="gi">+import os</span>
<span class="gi">+import tempfile</span>
<span class="w"> </span>from fsspec.implementations.local import LocalFileSystem, make_path_posix
<span class="w"> </span>from fsspec.tests.abstract import AbstractFixtures


<span class="w"> </span>class LocalFixtures(AbstractFixtures):
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs(self):</span>
<span class="gi">+        return LocalFileSystem()</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def root(self):</span>
<span class="gi">+        with tempfile.TemporaryDirectory() as tmpdir:</span>
<span class="gi">+            yield make_path_posix(tmpdir)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def tempdir(self):</span>
<span class="gi">+        with tempfile.TemporaryDirectory() as tmpdir:</span>
<span class="gi">+            yield make_path_posix(tmpdir)</span>
<span class="gi">+</span>
<span class="gi">+    def make_path(self, path):</span>
<span class="gi">+        return make_path_posix(os.path.join(self.root, path))</span>
<span class="gi">+</span>
<span class="gi">+    def test_simple(self, fs, root):</span>
<span class="gi">+        # Test basic file operations</span>
<span class="gi">+        test_file = os.path.join(root, &#39;test.txt&#39;)</span>
<span class="gi">+        fs.touch(test_file)</span>
<span class="gi">+        assert fs.exists(test_file)</span>
<span class="gi">+</span>
<span class="gi">+        fs.write_text(test_file, &#39;Hello, World!&#39;)</span>
<span class="gi">+        assert fs.read_text(test_file) == &#39;Hello, World!&#39;</span>
<span class="gi">+</span>
<span class="gi">+        fs.rm(test_file)</span>
<span class="gi">+        assert not fs.exists(test_file)</span>
<span class="gi">+</span>
<span class="gi">+    def test_mkdir(self, fs, root):</span>
<span class="gi">+        # Test directory creation</span>
<span class="gi">+        test_dir = os.path.join(root, &#39;test_dir&#39;)</span>
<span class="gi">+        fs.mkdir(test_dir)</span>
<span class="gi">+        assert fs.isdir(test_dir)</span>
<span class="gi">+</span>
<span class="gi">+        nested_dir = os.path.join(test_dir, &#39;nested&#39;)</span>
<span class="gi">+        fs.mkdir(nested_dir, create_parents=True)</span>
<span class="gi">+        assert fs.isdir(nested_dir)</span>
<span class="gi">+</span>
<span class="gi">+    def test_ls(self, fs, root):</span>
<span class="gi">+        # Test listing directory contents</span>
<span class="gi">+        fs.touch(os.path.join(root, &#39;file1.txt&#39;))</span>
<span class="gi">+        fs.touch(os.path.join(root, &#39;file2.txt&#39;))</span>
<span class="gi">+        fs.mkdir(os.path.join(root, &#39;subdir&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        contents = fs.ls(root)</span>
<span class="gi">+        assert len(contents) == 3</span>
<span class="gi">+        assert set(os.path.basename(item) for item in contents) == {&#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;subdir&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    def test_cp(self, fs, root):</span>
<span class="gi">+        # Test file copying</span>
<span class="gi">+        src_file = os.path.join(root, &#39;source.txt&#39;)</span>
<span class="gi">+        dst_file = os.path.join(root, &#39;destination.txt&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        fs.write_text(src_file, &#39;Test content&#39;)</span>
<span class="gi">+        fs.cp(src_file, dst_file)</span>
<span class="gi">+</span>
<span class="gi">+        assert fs.exists(dst_file)</span>
<span class="gi">+        assert fs.read_text(dst_file) == &#39;Test content&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def test_rm(self, fs, root):</span>
<span class="gi">+        # Test file and directory removal</span>
<span class="gi">+        test_file = os.path.join(root, &#39;test.txt&#39;)</span>
<span class="gi">+        test_dir = os.path.join(root, &#39;test_dir&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        fs.touch(test_file)</span>
<span class="gi">+        fs.mkdir(test_dir)</span>
<span class="gi">+        fs.touch(os.path.join(test_dir, &#39;nested.txt&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        fs.rm(test_file)</span>
<span class="gi">+        assert not fs.exists(test_file)</span>
<span class="gi">+</span>
<span class="gi">+        fs.rm(test_dir, recursive=True)</span>
<span class="gi">+        assert not fs.exists(test_dir)</span>
<span class="gi">+</span>
<span class="gi">+    def test_move(self, fs, root):</span>
<span class="gi">+        # Test moving files and directories</span>
<span class="gi">+        src_file = os.path.join(root, &#39;source.txt&#39;)</span>
<span class="gi">+        dst_file = os.path.join(root, &#39;moved.txt&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        fs.write_text(src_file, &#39;Move me&#39;)</span>
<span class="gi">+        fs.move(src_file, dst_file)</span>
<span class="gi">+</span>
<span class="gi">+        assert not fs.exists(src_file)</span>
<span class="gi">+        assert fs.exists(dst_file)</span>
<span class="gi">+        assert fs.read_text(dst_file) == &#39;Move me&#39;</span>
<span class="gh">diff --git a/fsspec/implementations/tests/local/local_test.py b/fsspec/implementations/tests/local/local_test.py</span>
<span class="gh">index 6f23e7a..a1acacb 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/local/local_test.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/local/local_test.py</span>
<span class="gu">@@ -3,12 +3,13 @@ from fsspec.implementations.tests.local.local_fixtures import LocalFixtures</span>


<span class="w"> </span>class TestLocalCopy(abstract.AbstractCopyTests, LocalFixtures):
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    def setUp(self):</span>
<span class="gi">+        super().setUp()</span>

<span class="w"> </span>class TestLocalGet(abstract.AbstractGetTests, LocalFixtures):
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    def setUp(self):</span>
<span class="gi">+        super().setUp()</span>

<span class="w"> </span>class TestLocalPut(abstract.AbstractPutTests, LocalFixtures):
<span class="gd">-    pass</span>
<span class="gi">+    def setUp(self):</span>
<span class="gi">+        super().setUp()</span>
<span class="gh">diff --git a/fsspec/implementations/tests/memory/memory_fixtures.py b/fsspec/implementations/tests/memory/memory_fixtures.py</span>
<span class="gh">index 26f59cd..0823d2b 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/memory/memory_fixtures.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/memory/memory_fixtures.py</span>
<span class="gu">@@ -3,5 +3,45 @@ from fsspec import filesystem</span>
<span class="w"> </span>from fsspec.tests.abstract import AbstractFixtures


<span class="gi">+import pytest</span>
<span class="gi">+from fsspec.implementations.memory import MemoryFileSystem</span>
<span class="gi">+from fsspec.tests.abstract import AbstractFixtures</span>
<span class="gi">+</span>
<span class="w"> </span>class MemoryFixtures(AbstractFixtures):
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs(self):</span>
<span class="gi">+        return MemoryFileSystem()</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_path(self):</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_join(self):</span>
<span class="gi">+        return lambda *args: &quot;/&quot;.join(args)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_bulk(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_supports_empty_directories(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_cleanup(self):</span>
<span class="gi">+        yield</span>
<span class="gi">+        MemoryFileSystem.store.clear()</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_create_file(self, fs):</span>
<span class="gi">+        def _create_file(path, contents=b&quot;&quot;):</span>
<span class="gi">+            with fs.open(path, &quot;wb&quot;) as f:</span>
<span class="gi">+                f.write(contents)</span>
<span class="gi">+        return _create_file</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.fixture</span>
<span class="gi">+    def fs_create_dir(self, fs):</span>
<span class="gi">+        def _create_dir(path):</span>
<span class="gi">+            fs.mkdir(path)</span>
<span class="gi">+        return _create_dir</span>
<span class="gh">diff --git a/fsspec/implementations/tests/memory/memory_test.py b/fsspec/implementations/tests/memory/memory_test.py</span>
<span class="gh">index fd0ebaa..c77c4e8 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/memory/memory_test.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/memory/memory_test.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-import fsspec.tests.abstract as abstract</span>
<span class="gi">+from fsspec.tests.abstract import AbstractCopyTests, AbstractGetTests, AbstractPutTests</span>
<span class="w"> </span>from fsspec.implementations.tests.memory.memory_fixtures import MemoryFixtures


<span class="gh">diff --git a/fsspec/implementations/tests/test_archive.py b/fsspec/implementations/tests/test_archive.py</span>
<span class="gh">index 0c8d230..6a9fd86 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_archive.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_archive.py</span>
<span class="gu">@@ -18,7 +18,16 @@ def tempzip(data=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized Zip archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        data = archive_data</span>
<span class="gi">+    with tempfile.NamedTemporaryFile(suffix=&#39;.zip&#39;, delete=False) as tmp:</span>
<span class="gi">+        with zipfile.ZipFile(tmp, mode=&#39;w&#39;) as zf:</span>
<span class="gi">+            for k, v in data.items():</span>
<span class="gi">+                zf.writestr(k, v)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield tmp.name</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.remove(tmp.name)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -26,7 +35,16 @@ def temparchive(data=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized 7-Zip archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        data = archive_data</span>
<span class="gi">+    with tempfile.NamedTemporaryFile(suffix=&#39;.7z&#39;, delete=False) as tmp:</span>
<span class="gi">+        with py7zr.SevenZipFile(tmp.name, mode=&#39;w&#39;) as archive:</span>
<span class="gi">+            for k, v in data.items():</span>
<span class="gi">+                archive.writestr(v, k)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield tmp.name</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.remove(tmp.name)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -34,7 +52,18 @@ def temptar(data=None, mode=&#39;w&#39;, suffix=&#39;.tar&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized .tar archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        data = archive_data</span>
<span class="gi">+    with tempfile.NamedTemporaryFile(suffix=suffix, delete=False) as tmp:</span>
<span class="gi">+        with tarfile.open(tmp.name, mode=mode) as tf:</span>
<span class="gi">+            for k, v in data.items():</span>
<span class="gi">+                info = tarfile.TarInfo(name=k)</span>
<span class="gi">+                info.size = len(v)</span>
<span class="gi">+                tf.addfile(info, BytesIO(v))</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield tmp.name</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.remove(tmp.name)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -42,7 +71,8 @@ def temptargz(data=None, mode=&#39;w&#39;, suffix=&#39;.tar.gz&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized .tar.gz archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with temptar(data, mode=mode + &#39;:gz&#39;, suffix=suffix) as fn:</span>
<span class="gi">+        yield fn</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -50,7 +80,8 @@ def temptarbz2(data=None, mode=&#39;w&#39;, suffix=&#39;.tar.bz2&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized .tar.bz2 archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with temptar(data, mode=mode + &#39;:bz2&#39;, suffix=suffix) as fn:</span>
<span class="gi">+        yield fn</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -58,7 +89,8 @@ def temptarxz(data=None, mode=&#39;w&#39;, suffix=&#39;.tar.xz&#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provide test cases with temporary synthesized .tar.xz archives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with temptar(data, mode=mode + &#39;:xz&#39;, suffix=suffix) as fn:</span>
<span class="gi">+        yield fn</span>


<span class="w"> </span>class ArchiveTestScenario:
<span class="gu">@@ -86,7 +118,14 @@ def pytest_generate_tests(metafunc):</span>

<span class="w"> </span>    https://docs.pytest.org/en/latest/example/parametrize.html#a-quick-port-of-testscenarios
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    idlist = []</span>
<span class="gi">+    argvalues = []</span>
<span class="gi">+    for scenario in metafunc.cls.scenarios:</span>
<span class="gi">+        idlist.append(f&quot;{scenario.protocol}&quot;)</span>
<span class="gi">+        if scenario.variant:</span>
<span class="gi">+            idlist[-1] += f&quot;-{scenario.variant}&quot;</span>
<span class="gi">+        argvalues.append(scenario)</span>
<span class="gi">+    metafunc.parametrize(&quot;scenario&quot;, argvalues, ids=idlist, scope=&quot;class&quot;)</span>


<span class="w"> </span>scenario_zip = ArchiveTestScenario(protocol=&#39;zip&#39;, provider=tempzip)
<span class="gh">diff --git a/fsspec/implementations/tests/test_cached.py b/fsspec/implementations/tests/test_cached.py</span>
<span class="gh">index 3baa269..f0e4121 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_cached.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_cached.py</span>
<span class="gu">@@ -25,9 +25,34 @@ def test_equality(tmpdir):</span>

<span class="w"> </span>    Related: GitHub#577, GitHub#578
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fs1 = fsspec.filesystem(&quot;file&quot;)</span>
<span class="gi">+    fs2 = fsspec.filesystem(&quot;file&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    cache1 = str(tmpdir.mkdir(&quot;cache1&quot;))</span>
<span class="gi">+    cache2 = str(tmpdir.mkdir(&quot;cache2&quot;))</span>
<span class="gi">+    </span>
<span class="gi">+    cfs1 = CachingFileSystem(fs=fs1, cache_storage=cache1)</span>
<span class="gi">+    cfs2 = CachingFileSystem(fs=fs2, cache_storage=cache1)</span>
<span class="gi">+    cfs3 = CachingFileSystem(fs=fs1, cache_storage=cache2)</span>
<span class="gi">+    </span>
<span class="gi">+    # Test equality</span>
<span class="gi">+    assert cfs1 == cfs2, &quot;CachingFileSystems with same fs and cache should be equal&quot;</span>
<span class="gi">+    assert cfs1 != cfs3, &quot;CachingFileSystems with different caches should not be equal&quot;</span>
<span class="gi">+    assert cfs1 != fs1, &quot;CachingFileSystem should not equal its underlying filesystem&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    # Test hashing</span>
<span class="gi">+    assert hash(cfs1) == hash(cfs2), &quot;Equal CachingFileSystems should have the same hash&quot;</span>
<span class="gi">+    assert hash(cfs1) != hash(cfs3), &quot;Different CachingFileSystems should have different hashes&quot;</span>
<span class="gi">+    assert hash(cfs1) != hash(fs1), &quot;CachingFileSystem should have a different hash from its underlying filesystem&quot;</span>


<span class="w"> </span>def test_str():
<span class="w"> </span>    &quot;&quot;&quot;Test that the str representation refers to correct class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fs = fsspec.filesystem(&quot;file&quot;)</span>
<span class="gi">+    cfs = CachingFileSystem(fs=fs, cache_storage=&quot;/tmp/cache&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    str_repr = str(cfs)</span>
<span class="gi">+    </span>
<span class="gi">+    assert &quot;CachingFileSystem&quot; in str_repr, &quot;String representation should mention CachingFileSystem&quot;</span>
<span class="gi">+    assert &quot;LocalFileSystem&quot; in str_repr, &quot;String representation should mention the underlying filesystem&quot;</span>
<span class="gi">+    assert &quot;/tmp/cache&quot; in str_repr, &quot;String representation should include the cache storage path&quot;</span>
<span class="gh">diff --git a/fsspec/implementations/tests/test_dbfs.py b/fsspec/implementations/tests/test_dbfs.py</span>
<span class="gh">index 18a8bb2..43c6394 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_dbfs.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_dbfs.py</span>
<span class="gu">@@ -45,4 +45,21 @@ def vcr_config():</span>
<span class="w"> </span>    If the DBFS_TOKEN env variable is set, we record with VCR.
<span class="w"> </span>    If not, we only replay (to not accidentally record with a wrong URL).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def before_record_request(request):</span>
<span class="gi">+        parsed = urlparse(request.uri)</span>
<span class="gi">+        request.uri = parsed._replace(netloc=DUMMY_INSTANCE).geturl()</span>
<span class="gi">+        if &#39;Authorization&#39; in request.headers:</span>
<span class="gi">+            request.headers[&#39;Authorization&#39;] = &#39;Bearer &lt;TOKEN&gt;&#39;</span>
<span class="gi">+        return request</span>
<span class="gi">+</span>
<span class="gi">+    def before_record_response(response):</span>
<span class="gi">+        if &#39;Date&#39; in response[&#39;headers&#39;]:</span>
<span class="gi">+            del response[&#39;headers&#39;][&#39;Date&#39;]</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;filter_headers&#39;: [&#39;Authorization&#39;],</span>
<span class="gi">+        &#39;before_record_request&#39;: before_record_request,</span>
<span class="gi">+        &#39;before_record_response&#39;: before_record_response,</span>
<span class="gi">+        &#39;record_mode&#39;: &#39;once&#39; if TOKEN else &#39;none&#39;</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/fsspec/implementations/tests/test_local.py b/fsspec/implementations/tests/test_local.py</span>
<span class="gh">index ccabb9c..c398ff1 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_local.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_local.py</span>
<span class="gu">@@ -37,14 +37,33 @@ def filetexts(d, open=open, mode=&#39;t&#39;):</span>
<span class="w"> </span>    automatically switch to a temporary current directory, to avoid
<span class="w"> </span>    race conditions when running tests in parallel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_dir = os.getcwd()</span>
<span class="gi">+    with tempfile.TemporaryDirectory() as dirname:</span>
<span class="gi">+        os.chdir(dirname)</span>
<span class="gi">+        for filename, text in d.items():</span>
<span class="gi">+            with open(filename, &#39;w&#39; + mode) as f:</span>
<span class="gi">+                f.write(text)</span>
<span class="gi">+        yield</span>
<span class="gi">+        os.chdir(original_dir)</span>


<span class="w"> </span>def test_urlpath_expand_read():
<span class="w"> </span>    &quot;&quot;&quot;Make sure * is expanded in file paths when reading.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with filetexts(csv_files):</span>
<span class="gi">+        fn = sorted(csv_files)[0]</span>
<span class="gi">+        data = open_files(&#39;.test.fakedata.*.csv&#39;)[0].read()</span>
<span class="gi">+        assert data == csv_files[fn]</span>
<span class="gi">+</span>
<span class="gi">+        fs = fsspec.filesystem(&#39;file&#39;)</span>
<span class="gi">+        files = fs.glob(&#39;.test.fakedata.*.csv&#39;)</span>
<span class="gi">+        assert len(files) == 2</span>


<span class="w"> </span>def test_urlpath_expand_write():
<span class="w"> </span>    &quot;&quot;&quot;Make sure * is expanded in file paths when writing.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with tempfile.TemporaryDirectory() as dirname:</span>
<span class="gi">+        fs = fsspec.filesystem(&#39;file&#39;)</span>
<span class="gi">+        fs.open(os.path.join(dirname, &#39;test_file_*.txt&#39;), &#39;w&#39;).write(&#39;test&#39;)</span>
<span class="gi">+        files = fs.glob(os.path.join(dirname, &#39;test_file_*.txt&#39;))</span>
<span class="gi">+        assert len(files) == 1</span>
<span class="gi">+        assert fs.read_text(files[0]) == &#39;test&#39;</span>
<span class="gh">diff --git a/fsspec/implementations/tests/test_sftp.py b/fsspec/implementations/tests/test_sftp.py</span>
<span class="gh">index c50f763..1caa7f8 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_sftp.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_sftp.py</span>
<span class="gu">@@ -10,4 +10,11 @@ pytest.importorskip(&#39;paramiko&#39;)</span>

<span class="w"> </span>def make_tarfile(files_to_pack, tmp_path):
<span class="w"> </span>    &quot;&quot;&quot;Create a tarfile with some files.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tar_filename = tmp_path / &quot;test.tar&quot;</span>
<span class="gi">+    with TarFile.open(tar_filename, &quot;w&quot;) as tar:</span>
<span class="gi">+        for file_name, content in files_to_pack.items():</span>
<span class="gi">+            file_path = tmp_path / file_name</span>
<span class="gi">+            with open(file_path, &quot;w&quot;) as f:</span>
<span class="gi">+                f.write(content)</span>
<span class="gi">+            tar.add(file_path, arcname=file_name)</span>
<span class="gi">+    return tar_filename</span>
<span class="gh">diff --git a/fsspec/implementations/tests/test_tar.py b/fsspec/implementations/tests/test_tar.py</span>
<span class="gh">index 754de3b..b84ac72 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_tar.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_tar.py</span>
<span class="gu">@@ -22,7 +22,16 @@ def test_compressions(recipe):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Run tests on all available tar file compression variants.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with temptar(recipe) as fn:</span>
<span class="gi">+        with open(fn, &#39;rb&#39;) as f:</span>
<span class="gi">+            assert f.read(len(recipe[&#39;magic&#39;])) == recipe[&#39;magic&#39;]</span>
<span class="gi">+        </span>
<span class="gi">+        fs = TarFileSystem(fn)</span>
<span class="gi">+        assert fs.ls(&#39;/&#39;) == [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gi">+        assert fs.ls(&#39;/a&#39;) == [&#39;a/1&#39;, &#39;a/2&#39;]</span>
<span class="gi">+        assert fs.cat(&#39;/a/1&#39;) == b&#39;one&#39;</span>
<span class="gi">+        assert fs.cat(&#39;/a/2&#39;) == b&#39;two&#39;</span>
<span class="gi">+        assert fs.cat(&#39;/b&#39;) == b&#39;three&#39;</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;recipe&#39;, [{&#39;mode&#39;: &#39;w&#39;, &#39;suffix&#39;: &#39;.tar&#39;, &#39;magic&#39;:
<span class="gu">@@ -35,7 +44,23 @@ def test_filesystem_direct(recipe, tmpdir):</span>
<span class="w"> </span>    Run tests through a real fsspec filesystem implementation.
<span class="w"> </span>    Here: `LocalFileSystem`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fn = os.path.join(tmpdir, &#39;test&#39; + recipe[&#39;suffix&#39;])</span>
<span class="gi">+    with tarfile.open(fn, recipe[&#39;mode&#39;]) as tf:</span>
<span class="gi">+        for name, data in archive_data.items():</span>
<span class="gi">+            info = tarfile.TarInfo(name=name)</span>
<span class="gi">+            info.size = len(data)</span>
<span class="gi">+            tf.addfile(info, BytesIO(data))</span>
<span class="gi">+</span>
<span class="gi">+    fs = fsspec.filesystem(&#39;file&#39;)</span>
<span class="gi">+    with fs.open(fn, &#39;rb&#39;) as f:</span>
<span class="gi">+        assert f.read(len(recipe[&#39;magic&#39;])) == recipe[&#39;magic&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    tfs = TarFileSystem(fn)</span>
<span class="gi">+    assert tfs.ls(&#39;/&#39;) == [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gi">+    assert tfs.ls(&#39;/a&#39;) == [&#39;a/1&#39;, &#39;a/2&#39;]</span>
<span class="gi">+    assert tfs.cat(&#39;/a/1&#39;) == b&#39;one&#39;</span>
<span class="gi">+    assert tfs.cat(&#39;/a/2&#39;) == b&#39;two&#39;</span>
<span class="gi">+    assert tfs.cat(&#39;/b&#39;) == b&#39;three&#39;</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;recipe&#39;, [{&#39;mode&#39;: &#39;w&#39;, &#39;suffix&#39;: &#39;.tar&#39;, &#39;magic&#39;:
<span class="gu">@@ -48,7 +73,31 @@ def test_filesystem_cached(recipe, tmpdir):</span>
<span class="w"> </span>    Run tests through a real, cached, fsspec filesystem implementation.
<span class="w"> </span>    Here: `TarFileSystem` over `WholeFileCacheFileSystem` over `LocalFileSystem`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fn = os.path.join(tmpdir, &#39;test&#39; + recipe[&#39;suffix&#39;])</span>
<span class="gi">+    with tarfile.open(fn, recipe[&#39;mode&#39;]) as tf:</span>
<span class="gi">+        for name, data in archive_data.items():</span>
<span class="gi">+            info = tarfile.TarInfo(name=name)</span>
<span class="gi">+            info.size = len(data)</span>
<span class="gi">+            tf.addfile(info, BytesIO(data))</span>
<span class="gi">+</span>
<span class="gi">+    fs = fsspec.filesystem(&#39;file&#39;)</span>
<span class="gi">+    with fs.open(fn, &#39;rb&#39;) as f:</span>
<span class="gi">+        assert f.read(len(recipe[&#39;magic&#39;])) == recipe[&#39;magic&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    cache_dir = os.path.join(tmpdir, &#39;cache&#39;)</span>
<span class="gi">+    os.mkdir(cache_dir)</span>
<span class="gi">+    </span>
<span class="gi">+    cached_fs = WholeFileCacheFileSystem(fs=fs, cache_storage=cache_dir)</span>
<span class="gi">+    tfs = TarFileSystem(OpenFile(cached_fs, fn))</span>
<span class="gi">+</span>
<span class="gi">+    assert tfs.ls(&#39;/&#39;) == [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gi">+    assert tfs.ls(&#39;/a&#39;) == [&#39;a/1&#39;, &#39;a/2&#39;]</span>
<span class="gi">+    assert tfs.cat(&#39;/a/1&#39;) == b&#39;one&#39;</span>
<span class="gi">+    assert tfs.cat(&#39;/a/2&#39;) == b&#39;two&#39;</span>
<span class="gi">+    assert tfs.cat(&#39;/b&#39;) == b&#39;three&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the file is cached</span>
<span class="gi">+    assert os.path.exists(os.path.join(cache_dir, os.path.basename(fn)))</span>


<span class="w"> </span>@pytest.mark.parametrize(&#39;compression&#39;, [&#39;&#39;, &#39;gz&#39;, &#39;bz2&#39;, &#39;xz&#39;], ids=[&#39;tar&#39;,
<span class="gu">@@ -59,4 +108,24 @@ def test_ls_with_folders(compression: str, tmp_path: Path):</span>
<span class="w"> </span>    but make sure that the reading filesystem is still able to resolve the
<span class="w"> </span>    intermediate folders, like the ZipFileSystem.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tar_path = tmp_path / f&quot;test.tar{&#39;.&#39;+compression if compression else &#39;&#39;}&quot;</span>
<span class="gi">+    mode = f&quot;w:{compression}&quot; if compression else &quot;w&quot;</span>
<span class="gi">+</span>
<span class="gi">+    with tarfile.open(tar_path, mode) as tar:</span>
<span class="gi">+        tar.add(BytesIO(b&quot;content&quot;), arcname=&quot;a/b/c/file.txt&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    fs = TarFileSystem(str(tar_path))</span>
<span class="gi">+</span>
<span class="gi">+    assert fs.ls(&quot;/&quot;) == [&quot;a&quot;]</span>
<span class="gi">+    assert fs.ls(&quot;/a&quot;) == [&quot;a/b&quot;]</span>
<span class="gi">+    assert fs.ls(&quot;/a/b&quot;) == [&quot;a/b/c&quot;]</span>
<span class="gi">+    assert fs.ls(&quot;/a/b/c&quot;) == [&quot;a/b/c/file.txt&quot;]</span>
<span class="gi">+    assert fs.cat(&quot;/a/b/c/file.txt&quot;) == b&quot;content&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Test glob</span>
<span class="gi">+    assert fs.glob(&quot;/a/*/c/*.txt&quot;) == [&quot;a/b/c/file.txt&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    # Test info</span>
<span class="gi">+    info = fs.info(&quot;a/b/c/file.txt&quot;)</span>
<span class="gi">+    assert info[&quot;type&quot;] == &quot;file&quot;</span>
<span class="gi">+    assert info[&quot;size&quot;] == 7</span>
<span class="gh">diff --git a/fsspec/implementations/tests/test_zip.py b/fsspec/implementations/tests/test_zip.py</span>
<span class="gh">index c554e22..4c9bb90 100644</span>
<span class="gd">--- a/fsspec/implementations/tests/test_zip.py</span>
<span class="gi">+++ b/fsspec/implementations/tests/test_zip.py</span>
<span class="gu">@@ -7,4 +7,17 @@ from fsspec.implementations.tests.test_archive import archive_data, tempzip</span>

<span class="w"> </span>def test_fsspec_get_mapper():
<span class="w"> </span>    &quot;&quot;&quot;Added for #788&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with tempzip(archive_data) as fn:</span>
<span class="gi">+        # Test with explicit protocol</span>
<span class="gi">+        m = fsspec.get_mapper(f&quot;zip://{fn}&quot;)</span>
<span class="gi">+        assert isinstance(m, collections.abc.MutableMapping)</span>
<span class="gi">+        assert set(m) == set(archive_data)</span>
<span class="gi">+        assert m[&quot;a&quot;] == b&quot;data1&quot;</span>
<span class="gi">+        assert m[&quot;b&quot;] == b&quot;data2&quot;</span>
<span class="gi">+        </span>
<span class="gi">+        # Test with inferred protocol</span>
<span class="gi">+        m2 = fsspec.get_mapper(fn)</span>
<span class="gi">+        assert isinstance(m2, collections.abc.MutableMapping)</span>
<span class="gi">+        assert set(m2) == set(archive_data)</span>
<span class="gi">+        assert m2[&quot;a&quot;] == b&quot;data1&quot;</span>
<span class="gi">+        assert m2[&quot;b&quot;] == b&quot;data2&quot;</span>
<span class="gh">diff --git a/fsspec/implementations/webhdfs.py b/fsspec/implementations/webhdfs.py</span>
<span class="gh">index bc3c00b..99d5d52 100644</span>
<span class="gd">--- a/fsspec/implementations/webhdfs.py</span>
<span class="gi">+++ b/fsspec/implementations/webhdfs.py</span>
<span class="gu">@@ -141,19 +141,27 @@ class WebHDFS(AbstractFileSystem):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        WebHDFile instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return WebHDFile(self, path, mode=mode, block_size=block_size,</span>
<span class="gi">+                         autocommit=autocommit, replication=replication,</span>
<span class="gi">+                         permissions=permissions, **kwargs)</span>

<span class="w"> </span>    def content_summary(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Total numbers of files, directories and bytes under path&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}{path}?op=GETCONTENTSUMMARY&quot;</span>
<span class="gi">+        resp = self._call(&#39;get&#39;, url)</span>
<span class="gi">+        return resp[&#39;ContentSummary&#39;]</span>

<span class="w"> </span>    def ukey(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Checksum info of file, giving method and result&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}{path}?op=GETFILECHECKSUM&quot;</span>
<span class="gi">+        resp = self._call(&#39;get&#39;, url)</span>
<span class="gi">+        return resp[&#39;FileChecksum&#39;]</span>

<span class="w"> </span>    def home_directory(self):
<span class="w"> </span>        &quot;&quot;&quot;Get user&#39;s home directory&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}?op=GETHOMEDIRECTORY&quot;</span>
<span class="gi">+        resp = self._call(&#39;get&#39;, url)</span>
<span class="gi">+        return resp[&#39;Path&#39;]</span>

<span class="w"> </span>    def get_delegation_token(self, renewer=None):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve token which can give the same authority to other uses
<span class="gu">@@ -163,15 +171,22 @@ class WebHDFS(AbstractFileSystem):</span>
<span class="w"> </span>        renewer: str or None
<span class="w"> </span>            User who may use this token; if None, will be current user
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}?op=GETDELEGATIONTOKEN&quot;</span>
<span class="gi">+        if renewer:</span>
<span class="gi">+            url += f&quot;&amp;renewer={renewer}&quot;</span>
<span class="gi">+        resp = self._call(&#39;get&#39;, url)</span>
<span class="gi">+        return resp[&#39;Token&#39;][&#39;urlString&#39;]</span>

<span class="w"> </span>    def renew_delegation_token(self, token):
<span class="w"> </span>        &quot;&quot;&quot;Make token live longer. Returns new expiry time&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}?op=RENEWDELEGATIONTOKEN&amp;token={token}&quot;</span>
<span class="gi">+        resp = self._call(&#39;put&#39;, url)</span>
<span class="gi">+        return resp[&#39;long&#39;]</span>

<span class="w"> </span>    def cancel_delegation_token(self, token):
<span class="w"> </span>        &quot;&quot;&quot;Stop the token from being useful&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}?op=CANCELDELEGATIONTOKEN&amp;token={token}&quot;</span>
<span class="gi">+        self._call(&#39;put&#39;, url)</span>

<span class="w"> </span>    def chmod(self, path, mod):
<span class="w"> </span>        &quot;&quot;&quot;Set the permission at path
<span class="gu">@@ -184,11 +199,19 @@ class WebHDFS(AbstractFileSystem):</span>
<span class="w"> </span>            posix epresentation or permission, give as oct string, e.g, &#39;777&#39;
<span class="w"> </span>            or 0o777
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(mod, int):</span>
<span class="gi">+            mod = oct(mod)[2:]</span>
<span class="gi">+        url = f&quot;{self.url}{path}?op=SETPERMISSION&amp;permission={mod}&quot;</span>
<span class="gi">+        self._call(&#39;put&#39;, url)</span>

<span class="w"> </span>    def chown(self, path, owner=None, group=None):
<span class="w"> </span>        &quot;&quot;&quot;Change owning user and/or group&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}{path}?op=SETOWNER&quot;</span>
<span class="gi">+        if owner:</span>
<span class="gi">+            url += f&quot;&amp;owner={owner}&quot;</span>
<span class="gi">+        if group:</span>
<span class="gi">+            url += f&quot;&amp;group={group}&quot;</span>
<span class="gi">+        self._call(&#39;put&#39;, url)</span>

<span class="w"> </span>    def set_replication(self, path, replication):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -202,7 +225,8 @@ class WebHDFS(AbstractFileSystem):</span>
<span class="w"> </span>            Number of copies of file on the cluster. Should be smaller than
<span class="w"> </span>            number of data nodes; normally 3 on most systems.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.url}{path}?op=SETREPLICATION&amp;replication={replication}&quot;</span>
<span class="gi">+        self._call(&#39;put&#39;, url)</span>


<span class="w"> </span>class WebHDFile(AbstractBufferedFile):
<span class="gu">@@ -230,8 +254,30 @@ class WebHDFile(AbstractBufferedFile):</span>
<span class="w"> </span>            This is the last block, so should complete file, if
<span class="w"> </span>            self.autocommit is True.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self.buffer.getvalue()</span>
<span class="gi">+        self.buffer.seek(0)</span>
<span class="gi">+        self.buffer.truncate()</span>
<span class="gi">+        </span>
<span class="gi">+        if not data:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.offset == 0:</span>
<span class="gi">+            self._initiate_upload()</span>
<span class="gi">+</span>
<span class="gi">+        url = f&quot;{self.fs.url}{self.path}?op=APPEND&amp;namenoderpcaddress={self.fs.host}:{self.fs.port}&amp;offset={self.offset}&quot;</span>
<span class="gi">+        self.fs._call(&#39;post&#39;, url, data=data)</span>
<span class="gi">+        self.offset += len(data)</span>
<span class="gi">+</span>
<span class="gi">+        if final and self.autocommit:</span>
<span class="gi">+            self.commit()</span>

<span class="w"> </span>    def _initiate_upload(self):
<span class="w"> </span>        &quot;&quot;&quot;Create remote file/upload&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        url = f&quot;{self.fs.url}{self.path}?op=CREATE&quot;</span>
<span class="gi">+        if self.replication:</span>
<span class="gi">+            url += f&quot;&amp;replication={self.replication}&quot;</span>
<span class="gi">+        if self.permissions:</span>
<span class="gi">+            url += f&quot;&amp;permission={self.permissions}&quot;</span>
<span class="gi">+        </span>
<span class="gi">+        redirect_url = self.fs._call(&#39;put&#39;, url, allow_redirects=False).headers[&#39;Location&#39;]</span>
<span class="gi">+        self.fs._call(&#39;put&#39;, redirect_url, data=&quot;&quot;)</span>
<span class="gh">diff --git a/fsspec/implementations/zip.py b/fsspec/implementations/zip.py</span>
<span class="gh">index b37820c..bcf9c58 100644</span>
<span class="gd">--- a/fsspec/implementations/zip.py</span>
<span class="gi">+++ b/fsspec/implementations/zip.py</span>
<span class="gu">@@ -59,4 +59,10 @@ class ZipFileSystem(AbstractArchiveFileSystem):</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Commits any write changes to the file. Done on ``del`` too.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.zip is not None:</span>
<span class="gi">+            self.zip.close()</span>
<span class="gi">+            self.zip = None</span>
<span class="gi">+        if self.of is not None:</span>
<span class="gi">+            self.of.__exit__(None, None, None)</span>
<span class="gi">+            self.of = None</span>
<span class="gi">+        self.fo = None</span>
<span class="gh">diff --git a/fsspec/json.py b/fsspec/json.py</span>
<span class="gh">index 54f0af3..1af47e3 100644</span>
<span class="gd">--- a/fsspec/json.py</span>
<span class="gi">+++ b/fsspec/json.py</span>
<span class="gu">@@ -9,13 +9,38 @@ from .spec import AbstractFileSystem</span>
<span class="w"> </span>class FilesystemJSONEncoder(json.JSONEncoder):
<span class="w"> </span>    include_password: ClassVar[bool] = True

<span class="gd">-    def make_serializable(self, obj: Any) -&gt;Any:</span>
<span class="gi">+    def make_serializable(self, obj: Any) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively converts an object so that it can be JSON serialized via
<span class="w"> </span>        :func:`json.dumps` and :func:`json.dump`, without actually calling
<span class="w"> </span>        said functions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(obj, AbstractFileSystem):</span>
<span class="gi">+            return {</span>
<span class="gi">+                &quot;__fsspec_type__&quot;: &quot;filesystem&quot;,</span>
<span class="gi">+                &quot;protocol&quot;: obj.protocol,</span>
<span class="gi">+                &quot;args&quot;: obj.storage_args,</span>
<span class="gi">+                &quot;kwargs&quot;: obj.storage_options</span>
<span class="gi">+            }</span>
<span class="gi">+        elif isinstance(obj, PurePath):</span>
<span class="gi">+            return {</span>
<span class="gi">+                &quot;__fsspec_type__&quot;: &quot;path&quot;,</span>
<span class="gi">+                &quot;path&quot;: str(obj)</span>
<span class="gi">+            }</span>
<span class="gi">+        elif isinstance(obj, (list, tuple)):</span>
<span class="gi">+            return [self.make_serializable(item) for item in obj]</span>
<span class="gi">+        elif isinstance(obj, dict):</span>
<span class="gi">+            return {key: self.make_serializable(value) for key, value in obj.items()}</span>
<span class="gi">+        elif hasattr(obj, &quot;__dict__&quot;):</span>
<span class="gi">+            return {</span>
<span class="gi">+                &quot;__fsspec_type__&quot;: &quot;object&quot;,</span>
<span class="gi">+                &quot;class&quot;: f&quot;{obj.__class__.__module__}.{obj.__class__.__name__}&quot;,</span>
<span class="gi">+                &quot;attributes&quot;: self.make_serializable(obj.__dict__)</span>
<span class="gi">+            }</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    def default(self, obj):</span>
<span class="gi">+        return self.make_serializable(obj)</span>


<span class="w"> </span>class FilesystemJSONDecoder(json.JSONDecoder):
<span class="gu">@@ -31,8 +56,29 @@ class FilesystemJSONDecoder(json.JSONDecoder):</span>
<span class="w"> </span>            parse_float, parse_int=parse_int, parse_constant=parse_constant,
<span class="w"> </span>            strict=strict, object_pairs_hook=object_pairs_hook)

<span class="gd">-    def unmake_serializable(self, obj: Any) -&gt;Any:</span>
<span class="gi">+    def unmake_serializable(self, obj: Any) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Inverse function of :meth:`FilesystemJSONEncoder.make_serializable`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(obj, dict):</span>
<span class="gi">+            if &quot;__fsspec_type__&quot; in obj:</span>
<span class="gi">+                if obj[&quot;__fsspec_type__&quot;] == &quot;filesystem&quot;:</span>
<span class="gi">+                    fs_class = get_filesystem_class(obj[&quot;protocol&quot;])</span>
<span class="gi">+                    return fs_class(*obj.get(&quot;args&quot;, []), **obj.get(&quot;kwargs&quot;, {}))</span>
<span class="gi">+                elif obj[&quot;__fsspec_type__&quot;] == &quot;path&quot;:</span>
<span class="gi">+                    return PurePath(obj[&quot;path&quot;])</span>
<span class="gi">+                elif obj[&quot;__fsspec_type__&quot;] == &quot;object&quot;:</span>
<span class="gi">+                    cls = _import_class(obj[&quot;class&quot;])</span>
<span class="gi">+                    instance = cls.__new__(cls)</span>
<span class="gi">+                    instance.__dict__.update(self.unmake_serializable(obj[&quot;attributes&quot;]))</span>
<span class="gi">+                    return instance</span>
<span class="gi">+            return {key: self.unmake_serializable(value) for key, value in obj.items()}</span>
<span class="gi">+        elif isinstance(obj, list):</span>
<span class="gi">+            return [self.unmake_serializable(item) for item in obj]</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    def custom_object_hook(self, obj):</span>
<span class="gi">+        result = self.unmake_serializable(obj)</span>
<span class="gi">+        if self.original_object_hook:</span>
<span class="gi">+            result = self.original_object_hook(result)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/fsspec/mapping.py b/fsspec/mapping.py</span>
<span class="gh">index 05bf237..6972c83 100644</span>
<span class="gd">--- a/fsspec/mapping.py</span>
<span class="gi">+++ b/fsspec/mapping.py</span>
<span class="gu">@@ -62,11 +62,13 @@ class FSMap(MutableMapping):</span>
<span class="w"> </span>    @cached_property
<span class="w"> </span>    def dirfs(self):
<span class="w"> </span>        &quot;&quot;&quot;dirfs instance that can be used with the same keys as the mapper&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from fsspec.implementations.dirfs import DirFileSystem</span>
<span class="gi">+        return DirFileSystem(self.root, fs=self.fs)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all keys below root - empties out mapping&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.fs.rm(self.root, recursive=True)</span>
<span class="gi">+        self.fs.mkdir(self.root)</span>

<span class="w"> </span>    def getitems(self, keys, on_error=&#39;raise&#39;):
<span class="w"> </span>        &quot;&quot;&quot;Fetch multiple items from the store
<span class="gu">@@ -88,7 +90,22 @@ class FSMap(MutableMapping):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        dict(key, bytes|exception)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = {}</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            try:</span>
<span class="gi">+                out[key] = self[key]</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                if on_error == &#39;raise&#39;:</span>
<span class="gi">+                    if isinstance(e, self.missing_exceptions):</span>
<span class="gi">+                        raise KeyError(key) from e</span>
<span class="gi">+                    raise</span>
<span class="gi">+                elif on_error == &#39;omit&#39;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                elif on_error == &#39;return&#39;:</span>
<span class="gi">+                    out[key] = e</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(f&quot;on_error must be &#39;raise&#39;, &#39;omit&#39;, or &#39;return&#39;, got {on_error}&quot;)</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def setitems(self, values_dict):
<span class="w"> </span>        &quot;&quot;&quot;Set the values of multiple items in the store
<span class="gu">@@ -97,19 +114,24 @@ class FSMap(MutableMapping):</span>
<span class="w"> </span>        ----------
<span class="w"> </span>        values_dict: dict(str, bytes)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in values_dict.items():</span>
<span class="gi">+            self[key] = value</span>

<span class="w"> </span>    def delitems(self, keys):
<span class="w"> </span>        &quot;&quot;&quot;Remove multiple keys from the store&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            try:</span>
<span class="gi">+                del self[key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>

<span class="w"> </span>    def _key_to_str(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Generate full path for the key&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return posixpath.join(self._root_key_to_str, key)</span>

<span class="w"> </span>    def _str_to_key(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Strip path of to leave key name&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return s[len(self._root_key_to_str) + 1:]</span>

<span class="w"> </span>    def __getitem__(self, key, default=None):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve data&quot;&quot;&quot;
<span class="gu">@@ -124,7 +146,14 @@ class FSMap(MutableMapping):</span>

<span class="w"> </span>    def pop(self, key, default=None):
<span class="w"> </span>        &quot;&quot;&quot;Pop data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self[key]</span>
<span class="gi">+            del self[key]</span>
<span class="gi">+            return value</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if default is not None:</span>
<span class="gi">+                return default</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def __setitem__(self, key, value):
<span class="w"> </span>        &quot;&quot;&quot;Store value in key&quot;&quot;&quot;
<span class="gu">@@ -187,4 +216,8 @@ def get_mapper(url=&#39;&#39;, check=False, create=False, missing_exceptions=None,</span>
<span class="w"> </span>    -------
<span class="w"> </span>    ``FSMap`` instance, the dict-like key-value store.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fs, root = url_to_fs(url, **kwargs)</span>
<span class="gi">+    if alternate_root is not None:</span>
<span class="gi">+        root = alternate_root</span>
<span class="gi">+</span>
<span class="gi">+    return FSMap(root, fs, check=check, create=create, missing_exceptions=missing_exceptions)</span>
<span class="gh">diff --git a/fsspec/parquet.py b/fsspec/parquet.py</span>
<span class="gh">index be64f8a..e85d6e5 100644</span>
<span class="gd">--- a/fsspec/parquet.py</span>
<span class="gi">+++ b/fsspec/parquet.py</span>
<span class="gu">@@ -71,7 +71,23 @@ def open_parquet_file(path, mode=&#39;rb&#39;, fs=None, metadata=None, columns=None,</span>
<span class="w"> </span>    **kwargs :
<span class="w"> </span>        Optional key-word arguments to pass to `fs.open`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fs is None:</span>
<span class="gi">+        fs, path = url_to_fs(path, **(storage_options or {}))</span>
<span class="gi">+</span>
<span class="gi">+    byte_ranges = _get_parquet_byte_ranges(</span>
<span class="gi">+        [path], fs, metadata=metadata, columns=columns,</span>
<span class="gi">+        row_groups=row_groups, max_gap=max_gap, max_block=max_block,</span>
<span class="gi">+        footer_sample_size=footer_sample_size, engine=engine</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return fs.open(</span>
<span class="gi">+        path,</span>
<span class="gi">+        mode=mode,</span>
<span class="gi">+        cache_type=&quot;parts&quot;,</span>
<span class="gi">+        cache_options={&quot;data&quot;: byte_ranges[path]},</span>
<span class="gi">+        strict=strict,</span>
<span class="gi">+        **kwargs</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _get_parquet_byte_ranges(paths, fs, metadata=None, columns=None,
<span class="gu">@@ -83,7 +99,43 @@ def _get_parquet_byte_ranges(paths, fs, metadata=None, columns=None,</span>
<span class="w"> </span>    is intended for use as the `data` argument for the
<span class="w"> </span>    `KnownPartsOfAFile` caching strategy of a single path.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if engine == &#39;auto&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            engine = FastparquetEngine()</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                engine = PyarrowEngine()</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                raise ImportError(&quot;Neither &#39;fastparquet&#39; nor &#39;pyarrow&#39; is installed&quot;)</span>
<span class="gi">+    elif engine == &#39;fastparquet&#39;:</span>
<span class="gi">+        engine = FastparquetEngine()</span>
<span class="gi">+    elif engine == &#39;pyarrow&#39;:</span>
<span class="gi">+        engine = PyarrowEngine()</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown engine: {engine}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if metadata is not None:</span>
<span class="gi">+        return _get_parquet_byte_ranges_from_metadata(</span>
<span class="gi">+            metadata, fs, engine, columns, row_groups, max_gap, max_block</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    byte_ranges = {}</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        with fs.open(path, &#39;rb&#39;) as f:</span>
<span class="gi">+            f.seek(-footer_sample_size, 2)</span>
<span class="gi">+            footer = f.read()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            metadata = engine.read_metadata(footer)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # If footer is not in the sample, read the entire file</span>
<span class="gi">+            with fs.open(path, &#39;rb&#39;) as f:</span>
<span class="gi">+                metadata = engine.read_metadata(f.read())</span>
<span class="gi">+</span>
<span class="gi">+        path_ranges = engine.get_row_group_byte_ranges(metadata, columns, row_groups)</span>
<span class="gi">+        byte_ranges[path] = merge_offset_ranges(path_ranges, max_gap, max_block)</span>
<span class="gi">+</span>
<span class="gi">+    return byte_ranges</span>


<span class="w"> </span>def _get_parquet_byte_ranges_from_metadata(metadata, fs, engine, columns=
<span class="gu">@@ -93,7 +145,11 @@ def _get_parquet_byte_ranges_from_metadata(metadata, fs, engine, columns=</span>
<span class="w"> </span>    provided, and the remote footer metadata does not need to
<span class="w"> </span>    be transferred before calculating the required byte ranges.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    byte_ranges = {}</span>
<span class="gi">+    for path in metadata.row_groups[0].columns[0].file_path:</span>
<span class="gi">+        path_ranges = engine.get_row_group_byte_ranges(metadata, columns, row_groups)</span>
<span class="gi">+        byte_ranges[path] = merge_offset_ranges(path_ranges, max_gap, max_block)</span>
<span class="gi">+    return byte_ranges</span>


<span class="w"> </span>class FastparquetEngine:
<span class="gu">@@ -102,9 +158,46 @@ class FastparquetEngine:</span>
<span class="w"> </span>        import fastparquet as fp
<span class="w"> </span>        self.fp = fp

<span class="gi">+    def read_metadata(self, data):</span>
<span class="gi">+        return self.fp.ParquetFile(io.BytesIO(data))</span>
<span class="gi">+</span>
<span class="gi">+    def get_row_group_byte_ranges(self, metadata, columns=None, row_groups=None):</span>
<span class="gi">+        if columns is None:</span>
<span class="gi">+            columns = metadata.columns</span>
<span class="gi">+</span>
<span class="gi">+        if row_groups is None:</span>
<span class="gi">+            row_groups = range(len(metadata.row_groups))</span>
<span class="gi">+</span>
<span class="gi">+        byte_ranges = []</span>
<span class="gi">+        for rg in row_groups:</span>
<span class="gi">+            for col in columns:</span>
<span class="gi">+                chunk = metadata.row_groups[rg].columns[col]</span>
<span class="gi">+                byte_ranges.append((chunk.file_offset, chunk.file_offset + chunk.total_compressed_size))</span>
<span class="gi">+</span>
<span class="gi">+        return byte_ranges</span>
<span class="gi">+</span>

<span class="w"> </span>class PyarrowEngine:

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        import pyarrow.parquet as pq
<span class="w"> </span>        self.pq = pq
<span class="gi">+</span>
<span class="gi">+    def read_metadata(self, data):</span>
<span class="gi">+        return self.pq.read_metadata(io.BytesIO(data))</span>
<span class="gi">+</span>
<span class="gi">+    def get_row_group_byte_ranges(self, metadata, columns=None, row_groups=None):</span>
<span class="gi">+        if columns is None:</span>
<span class="gi">+            columns = metadata.schema.names</span>
<span class="gi">+</span>
<span class="gi">+        if row_groups is None:</span>
<span class="gi">+            row_groups = range(metadata.num_row_groups)</span>
<span class="gi">+</span>
<span class="gi">+        byte_ranges = []</span>
<span class="gi">+        for rg in row_groups:</span>
<span class="gi">+            for col in columns:</span>
<span class="gi">+                column_index = metadata.schema.names.index(col)</span>
<span class="gi">+                chunk = metadata.row_group(rg).column(column_index)</span>
<span class="gi">+                byte_ranges.append((chunk.data_page_offset, chunk.total_compressed_size + chunk.data_page_offset))</span>
<span class="gi">+</span>
<span class="gi">+        return byte_ranges</span>
<span class="gh">diff --git a/fsspec/registry.py b/fsspec/registry.py</span>
<span class="gh">index e2de702..4579925 100644</span>
<span class="gd">--- a/fsspec/registry.py</span>
<span class="gi">+++ b/fsspec/registry.py</span>
<span class="gu">@@ -28,7 +28,15 @@ def register_implementation(name, cls, clobber=False, errtxt=None):</span>
<span class="w"> </span>        If given, then a failure to import the given class will result in this
<span class="w"> </span>        text being given.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(cls, str):</span>
<span class="gi">+        known_implementations[name] = {</span>
<span class="gi">+            &quot;class&quot;: cls,</span>
<span class="gi">+            &quot;err&quot;: errtxt or f&quot;Install package to use {name} protocol&quot;</span>
<span class="gi">+        }</span>
<span class="gi">+    elif name in _registry and not clobber:</span>
<span class="gi">+        raise ValueError(f&quot;Name {name} already in registry and clobber is False&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        _registry[name] = cls</span>


<span class="w"> </span>known_implementations = {&#39;abfs&#39;: {&#39;class&#39;: &#39;adlfs.AzureBlobFileSystem&#39;,
<span class="gu">@@ -130,7 +138,19 @@ def get_filesystem_class(protocol):</span>
<span class="w"> </span>    import may fail. In this case, the string in the &quot;err&quot; field of the
<span class="w"> </span>    ``known_implementations`` will be given as the error message.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if protocol in registry:</span>
<span class="gi">+        return registry[protocol]</span>
<span class="gi">+    </span>
<span class="gi">+    if protocol not in known_implementations:</span>
<span class="gi">+        raise ValueError(f&quot;Protocol {protocol} is not known&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    impl = known_implementations[protocol]</span>
<span class="gi">+    try:</span>
<span class="gi">+        cls = _import_class(impl[&#39;class&#39;])</span>
<span class="gi">+        register_implementation(protocol, cls)</span>
<span class="gi">+        return cls</span>
<span class="gi">+    except ImportError as e:</span>
<span class="gi">+        raise ImportError(impl.get(&#39;err&#39;, str(e)))</span>


<span class="w"> </span>s3_msg = &quot;&quot;&quot;Your installed version of s3fs is very old and known to cause
<span class="gu">@@ -152,7 +172,17 @@ def _import_class(fqp: str):</span>
<span class="w"> </span>    This can import arbitrary modules. Make sure you haven&#39;t installed any modules
<span class="w"> </span>    that may execute malicious code at import time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;:&#39; in fqp:</span>
<span class="gi">+        module, klass = fqp.split(&#39;:&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        module, klass = fqp.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    </span>
<span class="gi">+    mod = importlib.import_module(module)</span>
<span class="gi">+    </span>
<span class="gi">+    if &#39;.&#39; in klass:</span>
<span class="gi">+        return eval(f&quot;mod.{klass}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return getattr(mod, klass)</span>


<span class="w"> </span>def filesystem(protocol, **storage_options):
<span class="gu">@@ -161,7 +191,8 @@ def filesystem(protocol, **storage_options):</span>
<span class="w"> </span>    ``storage_options`` are specific to the protocol being chosen, and are
<span class="w"> </span>    passed directly to the class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cls = get_filesystem_class(protocol)</span>
<span class="gi">+    return cls(**storage_options)</span>


<span class="w"> </span>def available_protocols():
<span class="gu">@@ -169,4 +200,4 @@ def available_protocols():</span>

<span class="w"> </span>    Note that any given protocol may require extra packages to be importable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(set(list(registry) + list(known_implementations)))</span>
<span class="gh">diff --git a/fsspec/spec.py b/fsspec/spec.py</span>
<span class="gh">index 106214a..dd3eefb 100644</span>
<span class="gd">--- a/fsspec/spec.py</span>
<span class="gi">+++ b/fsspec/spec.py</span>
<span class="gu">@@ -133,7 +133,7 @@ class AbstractFileSystem(metaclass=_Cached):</span>
<span class="w"> </span>        &quot;&quot;&quot;Persistent filesystem id that can be used to compare filesystems
<span class="w"> </span>        across sessions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return hash(self.__class__.__name__ + str(self.storage_args) + str(self.storage_options))</span>

<span class="w"> </span>    def __dask_tokenize__(self):
<span class="w"> </span>        return self._fs_token
<span class="gu">@@ -155,11 +155,21 @@ class AbstractFileSystem(metaclass=_Cached):</span>

<span class="w"> </span>        May require FS-specific handling, e.g., for relative paths or links.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(cls.protocol, str):</span>
<span class="gi">+            return path[len(cls.protocol) + 3:] if path.startswith(cls.protocol + &#39;://&#39;) else path</span>
<span class="gi">+        elif isinstance(cls.protocol, tuple):</span>
<span class="gi">+            for protocol in cls.protocol:</span>
<span class="gi">+                if path.startswith(protocol + &#39;://&#39;):</span>
<span class="gi">+                    return path[len(protocol) + 3:]</span>
<span class="gi">+        return path</span>

<span class="w"> </span>    def unstrip_protocol(self, name: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Format FS-specific path to generic, including protocol&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self.protocol, str):</span>
<span class="gi">+            return f&quot;{self.protocol}://{name}&quot;</span>
<span class="gi">+        elif isinstance(self.protocol, tuple):</span>
<span class="gi">+            return f&quot;{self.protocol[0]}://{name}&quot;</span>
<span class="gi">+        return name</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_kwargs_from_urls(path):
<span class="gu">@@ -179,7 +189,9 @@ class AbstractFileSystem(metaclass=_Cached):</span>

<span class="w"> </span>        If no instance has been created, then create one with defaults
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls._latest is None:</span>
<span class="gi">+            return cls()</span>
<span class="gi">+        return cls._cache[cls._latest]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def transaction(self):
<span class="gu">@@ -208,7 +220,10 @@ class AbstractFileSystem(metaclass=_Cached):</span>
<span class="w"> </span>            If None, clear all listings cached else listings at or under given
<span class="w"> </span>            path.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if path is None:</span>
<span class="gi">+            self.dircache.clear()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.dircache.clear(path)</span>

<span class="w"> </span>    def mkdir(self, path, create_parents=True, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -226,7 +241,12 @@ class AbstractFileSystem(metaclass=_Cached):</span>
<span class="w"> </span>        kwargs:
<span class="w"> </span>            may be permissions, etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if create_parents:</span>
<span class="gi">+            self.makedirs(path, exist_ok=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.exists(path):</span>
<span class="gi">+                raise FileExistsError(f&quot;Directory {path} already exists&quot;)</span>
<span class="gi">+            self._mkdir(path, **kwargs)</span>

<span class="w"> </span>    def makedirs(self, path, exist_ok=False):
<span class="w"> </span>        &quot;&quot;&quot;Recursively make directories
<span class="gu">@@ -242,7 +262,13 @@ class AbstractFileSystem(metaclass=_Cached):</span>
<span class="w"> </span>        exist_ok: bool (False)
<span class="w"> </span>            If False, will error if the target already exists
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = path.rstrip(&#39;/&#39;).split(&#39;/&#39;)</span>
<span class="gi">+        for i in range(1, len(parts) + 1):</span>
<span class="gi">+            part = &#39;/&#39;.join(parts[:i])</span>
<span class="gi">+            if part and not self.exists(part):</span>
<span class="gi">+                self._mkdir(part)</span>
<span class="gi">+            elif not exist_ok and i == len(parts) and self.exists(part):</span>
<span class="gi">+                raise FileExistsError(f&quot;Directory {path} already exists&quot;)</span>

<span class="w"> </span>    def rmdir(self, path):
<span class="w"> </span>        &quot;&quot;&quot;Remove a directory, if empty&quot;&quot;&quot;
<span class="gh">diff --git a/fsspec/transaction.py b/fsspec/transaction.py</span>
<span class="gh">index 9a060ac..e7d27be 100644</span>
<span class="gd">--- a/fsspec/transaction.py</span>
<span class="gi">+++ b/fsspec/transaction.py</span>
<span class="gu">@@ -32,11 +32,18 @@ class Transaction:</span>

<span class="w"> </span>    def start(self):
<span class="w"> </span>        &quot;&quot;&quot;Start a transaction on this FileSystem&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.fs:</span>
<span class="gi">+            self.fs._intrans = True</span>
<span class="gi">+            self.fs._transaction = self</span>

<span class="w"> </span>    def complete(self, commit=True):
<span class="w"> </span>        &quot;&quot;&quot;Finish transaction: commit or discard all deferred files&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self.files:</span>
<span class="gi">+            f = self.files.popleft()</span>
<span class="gi">+            if commit:</span>
<span class="gi">+                f.commit()</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.discard()</span>


<span class="w"> </span>class FileActor:
<span class="gu">@@ -60,4 +67,18 @@ class DaskTransaction(Transaction):</span>

<span class="w"> </span>    def complete(self, commit=True):
<span class="w"> </span>        &quot;&quot;&quot;Finish transaction: commit or discard all deferred files&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import distributed</span>
<span class="gi">+        client = distributed.default_client()</span>
<span class="gi">+</span>
<span class="gi">+        def process_files(files, commit):</span>
<span class="gi">+            for f in files.files:</span>
<span class="gi">+                if commit:</span>
<span class="gi">+                    f.commit()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    f.discard()</span>
<span class="gi">+            return len(files.files)</span>
<span class="gi">+</span>
<span class="gi">+        future = client.submit(process_files, self.files, commit)</span>
<span class="gi">+        processed_count = future.result()</span>
<span class="gi">+        self.files = client.submit(FileActor, actor=True).result()</span>
<span class="gi">+        return processed_count</span>
<span class="gh">diff --git a/fsspec/utils.py b/fsspec/utils.py</span>
<span class="gh">index 7257878..e7a7289 100644</span>
<span class="gd">--- a/fsspec/utils.py</span>
<span class="gi">+++ b/fsspec/utils.py</span>
<span class="gu">@@ -48,7 +48,37 @@ def infer_storage_options(urlpath: str, inherit_storage_options: (dict[str,</span>
<span class="w"> </span>    &quot;host&quot;: &quot;node&quot;, &quot;port&quot;: 123, &quot;path&quot;: &quot;/mnt/datasets/test.csv&quot;,
<span class="w"> </span>    &quot;url_query&quot;: &quot;q=1&quot;, &quot;extra&quot;: &quot;value&quot;}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    if inherit_storage_options:</span>
<span class="gi">+        result.update(inherit_storage_options)</span>
<span class="gi">+</span>
<span class="gi">+    parsed_url = urlsplit(urlpath)</span>
<span class="gi">+    protocol = parsed_url.scheme or &#39;file&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if protocol == &#39;file&#39;:</span>
<span class="gi">+        result[&#39;protocol&#39;] = protocol</span>
<span class="gi">+        result[&#39;path&#39;] = urlpath</span>
<span class="gi">+    else:</span>
<span class="gi">+        result[&#39;protocol&#39;] = protocol</span>
<span class="gi">+        result[&#39;path&#39;] = parsed_url.path</span>
<span class="gi">+        if parsed_url.netloc:</span>
<span class="gi">+            if &#39;@&#39; in parsed_url.netloc:</span>
<span class="gi">+                userinfo, hostinfo = parsed_url.netloc.split(&#39;@&#39;, 1)</span>
<span class="gi">+                if &#39;:&#39; in userinfo:</span>
<span class="gi">+                    result[&#39;username&#39;], result[&#39;password&#39;] = userinfo.split(&#39;:&#39;, 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result[&#39;username&#39;] = userinfo</span>
<span class="gi">+            else:</span>
<span class="gi">+                hostinfo = parsed_url.netloc</span>
<span class="gi">+            if &#39;:&#39; in hostinfo:</span>
<span class="gi">+                result[&#39;host&#39;], port = hostinfo.split(&#39;:&#39;, 1)</span>
<span class="gi">+                result[&#39;port&#39;] = int(port)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[&#39;host&#39;] = hostinfo</span>
<span class="gi">+        if parsed_url.query:</span>
<span class="gi">+            result[&#39;url_query&#39;] = parsed_url.query</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>compressions: dict[str, str] = {}
<span class="gu">@@ -61,7 +91,10 @@ def infer_compression(filename: str) -&gt;(str | None):</span>
<span class="w"> </span>    extension. This includes builtin (gz, bz2, zip) compressions, as well as
<span class="w"> </span>    optional compressions. See fsspec.compression.register_compression.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    extension = os.path.splitext(filename)[-1].lower()</span>
<span class="gi">+    if extension.startswith(&#39;.&#39;):</span>
<span class="gi">+        extension = extension[1:]</span>
<span class="gi">+    return compressions.get(extension)</span>


<span class="w"> </span>def build_name_function(max_int: float) -&gt;Callable[[int], str]:
<span class="gu">@@ -82,7 +115,15 @@ def build_name_function(max_int: float) -&gt;Callable[[int], str]:</span>
<span class="w"> </span>    &gt;&gt;&gt; build_name_function(0)(0)
<span class="w"> </span>    &#39;0&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if max_int == 0:</span>
<span class="gi">+        return lambda x: &#39;0&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    width = int(math.log10(max_int)) + 1</span>
<span class="gi">+</span>
<span class="gi">+    def name_function(x: int) -&gt; str:</span>
<span class="gi">+        return f&#39;{x:0{width}d}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return name_function</span>


<span class="w"> </span>def seek_delimiter(file: IO[bytes], delimiter: bytes, blocksize: int) -&gt;bool:
<span class="gu">@@ -107,7 +148,22 @@ def seek_delimiter(file: IO[bytes], delimiter: bytes, blocksize: int) -&gt;bool:</span>
<span class="w"> </span>    Returns True if a delimiter was found, False if at file start or end.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if file.tell() == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    last = b&#39;&#39;</span>
<span class="gi">+    while True:</span>
<span class="gi">+        current = file.read(blocksize)</span>
<span class="gi">+        if not current:</span>
<span class="gi">+            return False</span>
<span class="gi">+        full = last + current</span>
<span class="gi">+        try:</span>
<span class="gi">+            i = full.index(delimiter)</span>
<span class="gi">+            file.seek(file.tell() - (len(full) - i) + len(delimiter))</span>
<span class="gi">+            return True</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        last = full[-len(delimiter):]</span>


<span class="w"> </span>def read_block(f: IO[bytes], offset: int, length: (int | None), delimiter:
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>