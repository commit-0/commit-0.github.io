
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin paramiko - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-paramiko" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin paramiko
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-paramiko"><strong>Claude Sonnet 3.5 - Fill-in</strong>: paramiko</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:10: in &lt;module&gt;
    from paramiko import (
paramiko/__init__.py:22: in &lt;module&gt;
    from paramiko.transport import (
paramiko/transport.py:14: in &lt;module&gt;
    from paramiko import util
paramiko/util.py:9: in &lt;module&gt;
    from paramiko.common import DEBUG, zero_byte, xffffffff, max_byte, byte_ord, byte_chr
paramiko/common.py:22: in &lt;module&gt;
    cMSG_DISCONNECT = byte_chr(MSG_DISCONNECT)
E   NameError: name &#39;byte_chr&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/TODO b/TODO</span>
<span class="gh">index 4bda14a2..413fb545 100644</span>
<span class="gd">--- a/TODO</span>
<span class="gi">+++ b/TODO</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="gd">-* Change license to BSD for v1.8 (obtain permission from Robey)</span>
<span class="gd">-* Pending that, remove preamble from all files, ensure LICENSE is still correct</span>
<span class="gd">-* Update version stuff: use an execfile&#39;d paramiko/_version.py</span>
<span class="gi">+* Update LICENSE file to BSD license (after obtaining permission from Robey)</span>
<span class="gi">+* Remove preamble from all files</span>
<span class="gi">+* Create paramiko/_version.py file for version information</span>
<span class="gi">+* Update setup.py to use paramiko/_version.py for version information</span>
<span class="gh">diff --git a/paramiko/_version.py b/paramiko/_version.py</span>
<span class="gh">index 9890fe29..4ec66a94 100644</span>
<span class="gd">--- a/paramiko/_version.py</span>
<span class="gi">+++ b/paramiko/_version.py</span>
<span class="gu">@@ -1,2 +1,4 @@</span>
<span class="w"> </span>__version_info__ = 3, 4, 1
<span class="w"> </span>__version__ = &#39;.&#39;.join(map(str, __version_info__))
<span class="gi">+# This file is automatically generated during release</span>
<span class="gi">+__version__ = &quot;1.8.0&quot;</span>
<span class="gh">diff --git a/paramiko/_winapi.py b/paramiko/_winapi.py</span>
<span class="gh">index f02b3c7d..ed23ec28 100644</span>
<span class="gd">--- a/paramiko/_winapi.py</span>
<span class="gi">+++ b/paramiko/_winapi.py</span>
<span class="gu">@@ -15,7 +15,26 @@ def format_system_message(errno):</span>
<span class="w"> </span>    Call FormatMessage with a system error number to retrieve
<span class="w"> </span>    the descriptive error message.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get a buffer for the error message</span>
<span class="gi">+    buffer_size = 256</span>
<span class="gi">+    buffer = ctypes.create_unicode_buffer(buffer_size)</span>
<span class="gi">+    </span>
<span class="gi">+    flags = 0x00001000 | 0x00000200  # FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS</span>
<span class="gi">+    </span>
<span class="gi">+    # Call FormatMessageW to get the error message</span>
<span class="gi">+    chars = ctypes.windll.kernel32.FormatMessageW(</span>
<span class="gi">+        flags,</span>
<span class="gi">+        None,</span>
<span class="gi">+        errno,</span>
<span class="gi">+        0,  # Default language</span>
<span class="gi">+        buffer,</span>
<span class="gi">+        buffer_size,</span>
<span class="gi">+        None</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    if chars:</span>
<span class="gi">+        return buffer.value.rstrip()</span>
<span class="gi">+    return f&quot;Unknown error ({errno})&quot;</span>


<span class="w"> </span>class WindowsError(builtins.WindowsError):
<span class="gu">@@ -94,7 +113,15 @@ class MemoryMap:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read n bytes from mapped view.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.pos + n &gt; self.length:</span>
<span class="gi">+            n = self.length - self.pos</span>
<span class="gi">+        </span>
<span class="gi">+        if n &lt;= 0:</span>
<span class="gi">+            return b&#39;&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        data = (ctypes.c_char * n).from_address(self.view + self.pos)</span>
<span class="gi">+        self.pos += n</span>
<span class="gi">+        return data.raw</span>

<span class="w"> </span>    def __exit__(self, exc_type, exc_val, tb):
<span class="w"> </span>        ctypes.windll.kernel32.UnmapViewOfFile(self.view)
<span class="gu">@@ -195,14 +222,54 @@ def GetTokenInformation(token, information_class):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Given a token, get the token information for it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First, get the required buffer size</span>
<span class="gi">+    return_length = ctypes.wintypes.DWORD()</span>
<span class="gi">+    ctypes.windll.advapi32.GetTokenInformation(</span>
<span class="gi">+        token,</span>
<span class="gi">+        information_class,</span>
<span class="gi">+        None,</span>
<span class="gi">+        0,</span>
<span class="gi">+        ctypes.byref(return_length)</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Allocate the buffer</span>
<span class="gi">+    buffer = ctypes.create_string_buffer(return_length.value)</span>
<span class="gi">+    </span>
<span class="gi">+    # Now, get the actual token information</span>
<span class="gi">+    success = ctypes.windll.advapi32.GetTokenInformation(</span>
<span class="gi">+        token,</span>
<span class="gi">+        information_class,</span>
<span class="gi">+        buffer,</span>
<span class="gi">+        ctypes.sizeof(buffer),</span>
<span class="gi">+        ctypes.byref(return_length)</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    if not success:</span>
<span class="gi">+        raise WindowsError()</span>
<span class="gi">+    </span>
<span class="gi">+    return buffer.raw</span>


<span class="w"> </span>def get_current_user():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a TOKEN_USER for the owner of this process.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the current process token</span>
<span class="gi">+    token = ctypes.wintypes.HANDLE()</span>
<span class="gi">+    ctypes.windll.advapi32.OpenProcessToken(</span>
<span class="gi">+        ctypes.windll.kernel32.GetCurrentProcess(),</span>
<span class="gi">+        TokenAccess.TOKEN_QUERY,</span>
<span class="gi">+        ctypes.byref(token)</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        # Get the token information</span>
<span class="gi">+        token_info = GetTokenInformation(token, TokenInformationClass.TokenUser)</span>
<span class="gi">+        </span>
<span class="gi">+        # Convert the raw data to TOKEN_USER structure</span>
<span class="gi">+        return TOKEN_USER.from_buffer_copy(token_info)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        ctypes.windll.kernel32.CloseHandle(token)</span>


<span class="w"> </span>def get_security_attributes_for_user(user=None):
<span class="gu">@@ -210,4 +277,15 @@ def get_security_attributes_for_user(user=None):</span>
<span class="w"> </span>    Return a SECURITY_ATTRIBUTES structure with the SID set to the
<span class="w"> </span>    specified user (uses current user if none is specified).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if user is None:</span>
<span class="gi">+        user = get_current_user()</span>
<span class="gi">+    </span>
<span class="gi">+    sd = SECURITY_DESCRIPTOR()</span>
<span class="gi">+    ctypes.windll.advapi32.InitializeSecurityDescriptor(ctypes.byref(sd), SECURITY_DESCRIPTOR.REVISION)</span>
<span class="gi">+    ctypes.windll.advapi32.SetSecurityDescriptorOwner(ctypes.byref(sd), user.SID, False)</span>
<span class="gi">+    </span>
<span class="gi">+    sa = SECURITY_ATTRIBUTES()</span>
<span class="gi">+    sa.lpSecurityDescriptor = ctypes.addressof(sd)</span>
<span class="gi">+    sa.bInheritHandle = False</span>
<span class="gi">+    </span>
<span class="gi">+    return sa</span>
<span class="gh">diff --git a/paramiko/agent.py b/paramiko/agent.py</span>
<span class="gh">index 440c59d9..d0d11376 100644</span>
<span class="gd">--- a/paramiko/agent.py</span>
<span class="gi">+++ b/paramiko/agent.py</span>
<span class="gu">@@ -47,7 +47,7 @@ class AgentSSH:</span>
<span class="w"> </span>            a tuple of `.AgentKey` objects representing keys available on the
<span class="w"> </span>            SSH agent
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._keys</span>


<span class="w"> </span>class AgentProxyThread(threading.Thread):
<span class="gu">@@ -76,7 +76,16 @@ class AgentLocalProxy(AgentProxyThread):</span>

<span class="w"> </span>        May block!
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+            import paramiko.win_pageant as win_pageant</span>
<span class="gi">+            return win_pageant.PageantConnection()</span>
<span class="gi">+        else:</span>
<span class="gi">+            ssh_auth_sock = os.environ.get(&#39;SSH_AUTH_SOCK&#39;)</span>
<span class="gi">+            if ssh_auth_sock:</span>
<span class="gi">+                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+                sock.connect(ssh_auth_sock)</span>
<span class="gi">+                return sock, ssh_auth_sock</span>
<span class="gi">+        return None, None</span>


<span class="w"> </span>class AgentRemoteProxy(AgentProxyThread):
<span class="gu">@@ -95,7 +104,20 @@ def get_agent_connection():</span>

<span class="w"> </span>    .. versionadded:: 2.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+        import paramiko.win_pageant as win_pageant</span>
<span class="gi">+        if win_pageant.can_talk_to_agent():</span>
<span class="gi">+            return win_pageant.PageantConnection()</span>
<span class="gi">+    else:</span>
<span class="gi">+        ssh_auth_sock = os.environ.get(&#39;SSH_AUTH_SOCK&#39;)</span>
<span class="gi">+        if ssh_auth_sock:</span>
<span class="gi">+            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+            try:</span>
<span class="gi">+                sock.connect(ssh_auth_sock)</span>
<span class="gi">+                return sock</span>
<span class="gi">+            except socket.error:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return None</span>


<span class="w"> </span>class AgentClientProxy:
<span class="gu">@@ -124,14 +146,21 @@ class AgentClientProxy:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Method automatically called by ``AgentProxyThread.run``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._conn is None:</span>
<span class="gi">+            self._conn = get_agent_connection()</span>
<span class="gi">+        return self._conn is not None</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the current connection and terminate the agent
<span class="w"> </span>        Should be called manually
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._conn is not None:</span>
<span class="gi">+            self._conn.close()</span>
<span class="gi">+            self._conn = None</span>
<span class="gi">+        if self.thread is not None:</span>
<span class="gi">+            self.thread._exit = True</span>
<span class="gi">+            self.thread.join()</span>


<span class="w"> </span>class AgentServerProxy(AgentSSH):
<span class="gu">@@ -169,7 +198,18 @@ class AgentServerProxy(AgentSSH):</span>
<span class="w"> </span>        Terminate the agent, clean the files, close connections
<span class="w"> </span>        Should be called manually
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.thread is not None:</span>
<span class="gi">+            self.thread._exit = True</span>
<span class="gi">+            self.thread.join()</span>
<span class="gi">+</span>
<span class="gi">+        if self._conn is not None:</span>
<span class="gi">+            self._conn.close()</span>
<span class="gi">+            self._conn = None</span>
<span class="gi">+</span>
<span class="gi">+        if os.path.exists(self._file):</span>
<span class="gi">+            os.unlink(self._file)</span>
<span class="gi">+        if os.path.exists(self._dir):</span>
<span class="gi">+            os.rmdir(self._dir)</span>

<span class="w"> </span>    def get_env(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -178,7 +218,7 @@ class AgentServerProxy(AgentSSH):</span>
<span class="w"> </span>        :return:
<span class="w"> </span>            a dict containing the ``SSH_AUTH_SOCK`` environment variables
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {&quot;SSH_AUTH_SOCK&quot;: self._file}</span>


<span class="w"> </span>class AgentRequestHandler:
<span class="gu">@@ -243,7 +283,10 @@ class Agent(AgentSSH):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the SSH agent connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._conn is not None:</span>
<span class="gi">+            self._conn.close()</span>
<span class="gi">+            self._conn = None</span>
<span class="gi">+        self._keys = ()</span>


<span class="w"> </span>class AgentKey(PKey):
<span class="gh">diff --git a/paramiko/auth_handler.py b/paramiko/auth_handler.py</span>
<span class="gh">index 679ae516..f39ed714 100644</span>
<span class="gd">--- a/paramiko/auth_handler.py</span>
<span class="gi">+++ b/paramiko/auth_handler.py</span>
<span class="gu">@@ -38,7 +38,12 @@ class AuthHandler:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        response_list = handler(title, instructions, prompt_list)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.auth_method = &#39;keyboard-interactive&#39;</span>
<span class="gi">+        self.auth_username = username</span>
<span class="gi">+        self.interactive_handler = handler</span>
<span class="gi">+        self.submethods = submethods</span>
<span class="gi">+        self.auth_event = event</span>
<span class="gi">+        self.transport._send_message(self._get_userauth_request_message(username, &#39;keyboard-interactive&#39;, submethods))</span>

<span class="w"> </span>    def _get_key_type_and_bits(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -46,7 +51,16 @@ class AuthHandler:</span>

<span class="w"> </span>        Intended for input to or verification of, key signatures.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key_type = key.get_name()</span>
<span class="gi">+        if key_type == &#39;ssh-rsa&#39;:</span>
<span class="gi">+            bits_to_sign = &#39;ssh-rsa&#39;</span>
<span class="gi">+        elif key_type in (&#39;ecdsa-sha2-nistp256&#39;, &#39;ecdsa-sha2-nistp384&#39;, &#39;ecdsa-sha2-nistp521&#39;):</span>
<span class="gi">+            bits_to_sign = key_type</span>
<span class="gi">+        elif key_type == &#39;ssh-ed25519&#39;:</span>
<span class="gi">+            bits_to_sign = &#39;ssh-ed25519&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(f&#39;Unknown key type {key_type}&#39;)</span>
<span class="gi">+        return key_type, bits_to_sign</span>


<span class="w"> </span>class GssapiWithMicAuthHandler:
<span class="gu">@@ -85,10 +99,24 @@ class AuthOnlyHandler(AuthHandler):</span>
<span class="w"> </span>        which accepts a Message ``m`` and may call mutator methods on it to add
<span class="w"> </span>        more fields.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_USERAUTH_REQUEST)</span>
<span class="gi">+        m.add_string(username)</span>
<span class="gi">+        m.add_string(&#39;ssh-connection&#39;)</span>
<span class="gi">+        m.add_string(method)</span>
<span class="gi">+        if finish_message:</span>
<span class="gi">+            finish_message(m)</span>
<span class="gi">+        self.auth_event = threading.Event()</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        return self.auth_event</span>

<span class="w"> </span>    def auth_interactive(self, username, handler, submethods=&#39;&#39;):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        response_list = handler(title, instructions, prompt_list)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.auth_method = &#39;keyboard-interactive&#39;</span>
<span class="gi">+        self.auth_username = username</span>
<span class="gi">+        self.interactive_handler = handler</span>
<span class="gi">+        self.submethods = submethods</span>
<span class="gi">+        m = self._get_userauth_request_message(username, &#39;keyboard-interactive&#39;, submethods)</span>
<span class="gi">+        self.send_auth_request(username, &#39;keyboard-interactive&#39;, lambda x: x.add_string(submethods))</span>
<span class="gh">diff --git a/paramiko/auth_strategy.py b/paramiko/auth_strategy.py</span>
<span class="gh">index 318c2713..712961df 100644</span>
<span class="gd">--- a/paramiko/auth_strategy.py</span>
<span class="gi">+++ b/paramiko/auth_strategy.py</span>
<span class="gu">@@ -29,13 +29,15 @@ class AuthSource:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Perform authentication.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement authenticate method&quot;)</span>


<span class="w"> </span>class NoneAuth(AuthSource):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Auth type &quot;none&quot;, ie https://www.rfc-editor.org/rfc/rfc4252#section-5.2 .
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        return transport.auth_none(self.username)</span>


<span class="w"> </span>class Password(AuthSource):
<span class="gu">@@ -60,6 +62,10 @@ class Password(AuthSource):</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return super()._repr(user=self.username)

<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        password = self.password_getter()</span>
<span class="gi">+        return transport.auth_password(self.username, password)</span>
<span class="gi">+</span>

<span class="w"> </span>class PrivateKey(AuthSource):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -73,6 +79,10 @@ class PrivateKey(AuthSource):</span>
<span class="w"> </span>    either in their ``__init__``, or in an overridden ``authenticate`` prior to
<span class="w"> </span>    its `super` call.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def authenticate(self, transport):</span>
<span class="gi">+        if not hasattr(self, &#39;pkey&#39;):</span>
<span class="gi">+            raise AttributeError(&quot;self.pkey must be set before calling authenticate&quot;)</span>
<span class="gi">+        return transport.auth_publickey(self.username, self.pkey)</span>


<span class="w"> </span>class InMemoryPrivateKey(PrivateKey):
<span class="gu">@@ -202,7 +212,7 @@ class AuthStrategy:</span>
<span class="w"> </span>        Subclasses _of_ subclasses may find themselves wanting to do things
<span class="w"> </span>        like filtering or discarding around a call to `super`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Subclasses must implement get_sources method&quot;)</span>

<span class="w"> </span>    def authenticate(self, transport):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -211,4 +221,15 @@ class AuthStrategy:</span>
<span class="w"> </span>        You *normally* won&#39;t need to override this, but it&#39;s an option for
<span class="w"> </span>        advanced users.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = AuthResult(self)</span>
<span class="gi">+        for source in self.get_sources():</span>
<span class="gi">+            try:</span>
<span class="gi">+                auth_result = source.authenticate(transport)</span>
<span class="gi">+                result.append(SourceResult(source, auth_result))</span>
<span class="gi">+                if not auth_result:  # Empty list means successful authentication</span>
<span class="gi">+                    return result</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                result.append(SourceResult(source, e))</span>
<span class="gi">+                self.log.warning(f&quot;Authentication failed for {source}: {str(e)}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        raise AuthFailure(result)</span>
<span class="gh">diff --git a/paramiko/ber.py b/paramiko/ber.py</span>
<span class="gh">index 18f67749..ff2274fd 100644</span>
<span class="gd">--- a/paramiko/ber.py</span>
<span class="gi">+++ b/paramiko/ber.py</span>
<span class="gu">@@ -22,3 +22,98 @@ class BER:</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &quot;BER(&#39;&quot; + repr(self.content) + &quot;&#39;)&quot;
<span class="gi">+</span>
<span class="gi">+    def asbytes(self):</span>
<span class="gi">+        return self.content</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self):</span>
<span class="gi">+        return self.decode_next()</span>
<span class="gi">+</span>
<span class="gi">+    def decode_next(self):</span>
<span class="gi">+        if self.idx &gt;= len(self.content):</span>
<span class="gi">+            return None</span>
<span class="gi">+        ident = byte_ord(self.content[self.idx])</span>
<span class="gi">+        self.idx += 1</span>
<span class="gi">+        if (ident &amp; 31) == 31:</span>
<span class="gi">+            # identifier &gt; 30</span>
<span class="gi">+            ident = 0</span>
<span class="gi">+            while self.idx &lt; len(self.content):</span>
<span class="gi">+                t = byte_ord(self.content[self.idx])</span>
<span class="gi">+                self.idx += 1</span>
<span class="gi">+                ident = (ident &lt;&lt; 7) | (t &amp; 0x7f)</span>
<span class="gi">+                if not (t &amp; 0x80):</span>
<span class="gi">+                    break</span>
<span class="gi">+        if self.idx &gt;= len(self.content):</span>
<span class="gi">+            return None</span>
<span class="gi">+        # now fetch length</span>
<span class="gi">+        size = byte_ord(self.content[self.idx])</span>
<span class="gi">+        self.idx += 1</span>
<span class="gi">+        if size &amp; 0x80:</span>
<span class="gi">+            # more complicated...</span>
<span class="gi">+            # FIXME: theoretically should handle indefinite-length (0x80)</span>
<span class="gi">+            t = size &amp; 0x7f</span>
<span class="gi">+            if self.idx + t &gt; len(self.content):</span>
<span class="gi">+                return None</span>
<span class="gi">+            size = util.inflate_long(self.content[self.idx : self.idx + t], True)</span>
<span class="gi">+            self.idx += t</span>
<span class="gi">+        if self.idx + size &gt; len(self.content):</span>
<span class="gi">+            # can&#39;t fit</span>
<span class="gi">+            return None</span>
<span class="gi">+        data = self.content[self.idx : self.idx + size]</span>
<span class="gi">+        self.idx += size</span>
<span class="gi">+        # now switch on id</span>
<span class="gi">+        if ident == 0x30:</span>
<span class="gi">+            # sequence</span>
<span class="gi">+            return self.decode_sequence(data)</span>
<span class="gi">+        elif ident == 2:</span>
<span class="gi">+            # int</span>
<span class="gi">+            return util.inflate_long(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # 1: boolean (00 = false, otherwise true)</span>
<span class="gi">+            # 5: null</span>
<span class="gi">+            # 6: object identifier</span>
<span class="gi">+            # 0x30: sequence</span>
<span class="gi">+            return (ident, data)</span>
<span class="gi">+</span>
<span class="gi">+    def decode_sequence(self, data):</span>
<span class="gi">+        out = []</span>
<span class="gi">+        b = BER(data)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            x = b.decode_next()</span>
<span class="gi">+            if x is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            out.append(x)</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def encode_tlv(self, ident, val):</span>
<span class="gi">+        # no need to support ident &gt; 31 here</span>
<span class="gi">+        self.content += byte_chr(ident)</span>
<span class="gi">+        if len(val) &gt; 0x7f:</span>
<span class="gi">+            lenstr = util.deflate_long(len(val))</span>
<span class="gi">+            self.content += byte_chr(0x80 | len(lenstr)) + lenstr</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.content += byte_chr(len(val))</span>
<span class="gi">+        self.content += val</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, x):</span>
<span class="gi">+        if type(x) is bool:</span>
<span class="gi">+            if x:</span>
<span class="gi">+                self.encode_tlv(1, b&#39;\xff&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.encode_tlv(1, zero_byte)</span>
<span class="gi">+        elif (type(x) is int) or (type(x) is int64):</span>
<span class="gi">+            self.encode_tlv(2, util.deflate_long(x))</span>
<span class="gi">+        elif type(x) is str:</span>
<span class="gi">+            self.encode_tlv(4, x.encode())</span>
<span class="gi">+        elif (type(x) is bytes) or (type(x) is bytearray):</span>
<span class="gi">+            self.encode_tlv(4, x)</span>
<span class="gi">+        elif type(x) is list:</span>
<span class="gi">+            self.encode_tlv(0x30, self.encode_sequence(x))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise BERException(&#39;Unknown type for encoding: %r&#39; % type(x))</span>
<span class="gi">+</span>
<span class="gi">+    def encode_sequence(self, l):</span>
<span class="gi">+        b = BER()</span>
<span class="gi">+        for item in l:</span>
<span class="gi">+            b.encode(item)</span>
<span class="gi">+        return b.asbytes()</span>
<span class="gh">diff --git a/paramiko/buffered_pipe.py b/paramiko/buffered_pipe.py</span>
<span class="gh">index 0e56ca4d..365ac9cf 100644</span>
<span class="gd">--- a/paramiko/buffered_pipe.py</span>
<span class="gi">+++ b/paramiko/buffered_pipe.py</span>
<span class="gu">@@ -38,7 +38,11 @@ class BufferedPipe:</span>

<span class="w"> </span>        :param threading.Event event: the event to set/clear
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._event = event</span>
<span class="gi">+        if len(self._buffer) &gt; 0 or self._closed:</span>
<span class="gi">+            self._event.set()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._event.clear()</span>

<span class="w"> </span>    def feed(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -47,7 +51,11 @@ class BufferedPipe:</span>

<span class="w"> </span>        :param data: the data to add, as a ``str`` or ``bytes``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._buffer.extend(b(data))</span>
<span class="gi">+            self._cv.notify()</span>
<span class="gi">+        if self._event is not None:</span>
<span class="gi">+            self._event.set()</span>

<span class="w"> </span>    def read_ready(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +67,7 @@ class BufferedPipe:</span>
<span class="w"> </span>            ``True`` if a `read` call would immediately return at least one
<span class="w"> </span>            byte; ``False`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._buffer) &gt; 0 or self._closed</span>

<span class="w"> </span>    def read(self, nbytes, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -82,7 +90,29 @@ class BufferedPipe:</span>
<span class="w"> </span>            `.PipeTimeout` -- if a timeout was specified and no data was ready
<span class="w"> </span>            before that timeout
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            if len(self._buffer) == 0 and not self._closed:</span>
<span class="gi">+                if timeout is None:</span>
<span class="gi">+                    self._cv.wait()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not self._cv.wait(timeout):</span>
<span class="gi">+                        raise PipeTimeout()</span>
<span class="gi">+</span>
<span class="gi">+            if len(self._buffer) == 0 and self._closed:</span>
<span class="gi">+                return b&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+            if len(self._buffer) &lt;= nbytes:</span>
<span class="gi">+                result = self._buffer[:]</span>
<span class="gi">+                del self._buffer[:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = self._buffer[:nbytes]</span>
<span class="gi">+                del self._buffer[:nbytes]</span>
<span class="gi">+</span>
<span class="gi">+            if self._event is not None:</span>
<span class="gi">+                if len(self._buffer) == 0 and not self._closed:</span>
<span class="gi">+                    self._event.clear()</span>
<span class="gi">+</span>
<span class="gi">+        return result.tobytes()</span>

<span class="w"> </span>    def empty(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -92,14 +122,23 @@ class BufferedPipe:</span>
<span class="w"> </span>            any data that was in the buffer prior to clearing it out, as a
<span class="w"> </span>            `str`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            result = self._buffer[:]</span>
<span class="gi">+            del self._buffer[:]</span>
<span class="gi">+            if self._event is not None:</span>
<span class="gi">+                self._event.clear()</span>
<span class="gi">+        return result.tobytes()</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close this pipe object.  Future calls to `read` after the buffer
<span class="w"> </span>        has been emptied will return immediately with an empty string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self._cv.notify()</span>
<span class="gi">+        if self._event is not None:</span>
<span class="gi">+            self._event.set()</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/channel.py b/paramiko/channel.py</span>
<span class="gh">index 45548521..b840de94 100644</span>
<span class="gd">--- a/paramiko/channel.py</span>
<span class="gi">+++ b/paramiko/channel.py</span>
<span class="gu">@@ -25,7 +25,12 @@ def open_only(func):</span>
<span class="w"> </span>        `.SSHException` -- If the wrapped method is called on an unopened
<span class="w"> </span>        `.Channel`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapper(self, *args, **kwargs):</span>
<span class="gi">+        if not self.active:</span>
<span class="gi">+            raise SSHException(&quot;Channel is not open&quot;)</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>class Channel(ClosingContextManager):
<span class="gu">@@ -130,7 +135,19 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&#39;pty-req&#39;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_string(term)</span>
<span class="gi">+        m.add_int(width)</span>
<span class="gi">+        m.add_int(height)</span>
<span class="gi">+        m.add_int(width_pixels)</span>
<span class="gi">+        m.add_int(height_pixels)</span>
<span class="gi">+        m.add_string(b&#39;&#39;)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def invoke_shell(self):
<span class="gu">@@ -150,7 +167,13 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&#39;shell&#39;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def exec_command(self, command):
<span class="gu">@@ -169,7 +192,14 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>            `.SSHException` -- if the request was rejected or the channel was
<span class="w"> </span>            closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(cMSG_CHANNEL_REQUEST)</span>
<span class="gi">+        m.add_int(self.remote_chanid)</span>
<span class="gi">+        m.add_string(&#39;exec&#39;)</span>
<span class="gi">+        m.add_boolean(True)</span>
<span class="gi">+        m.add_string(command)</span>
<span class="gi">+        self.transport._send_user_message(m)</span>
<span class="gi">+        self._wait_for_event()</span>

<span class="w"> </span>    @open_only
<span class="w"> </span>    def invoke_subsystem(self, subsystem):
<span class="gu">@@ -260,7 +290,7 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.7.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.exit_status != -1</span>

<span class="w"> </span>    def recv_exit_status(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -285,7 +315,12 @@ class Channel(ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if self.exit_status != -1:</span>
<span class="gi">+                return self.exit_status</span>
<span class="gi">+            if not self.active:</span>
<span class="gi">+                return -1</span>
<span class="gi">+            self.transport._read_timeout(0.1)</span>

<span class="w"> </span>    def send_exit_status(self, status):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/client.py b/paramiko/client.py</span>
<span class="gh">index a04a5244..72432b79 100644</span>
<span class="gd">--- a/paramiko/client.py</span>
<span class="gi">+++ b/paramiko/client.py</span>
<span class="gu">@@ -72,7 +72,16 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>        :raises: ``IOError`` --
<span class="w"> </span>            if a filename was provided and the file could not be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if filename is None:</span>
<span class="gi">+            # Try to read from the user&#39;s local known_hosts file</span>
<span class="gi">+            filename = os.path.expanduser(&#39;~/.ssh/known_hosts&#39;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._system_host_keys.load(filename)</span>
<span class="gi">+            except IOError:</span>
<span class="gi">+                # Don&#39;t raise an exception if the file doesn&#39;t exist</span>
<span class="gi">+                pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._system_host_keys.load(filename)</span>

<span class="w"> </span>    def load_host_keys(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +99,8 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the filename could not be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._host_keys.load(filename)</span>
<span class="gi">+        self._host_keys_filename = filename</span>

<span class="w"> </span>    def save_host_keys(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -102,7 +112,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the file could not be written
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._host_keys.save(filename)</span>

<span class="w"> </span>    def get_host_keys(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,7 +121,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :return: the local host keys as a `.HostKeys` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._host_keys</span>

<span class="w"> </span>    def set_log_channel(self, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -120,7 +130,7 @@ class SSHClient(ClosingContextManager):</span>

<span class="w"> </span>        :param str name: new channel name for logging
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._log_channel = name</span>

<span class="w"> </span>    def set_missing_host_key_policy(self, policy):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -140,7 +150,7 @@ class SSHClient(ClosingContextManager):</span>
<span class="w"> </span>            the policy to use when receiving a host key from a
<span class="w"> </span>            previously-unknown server
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._policy = policy</span>

<span class="w"> </span>    def _families_and_addresses(self, hostname, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/config.py b/paramiko/config.py</span>
<span class="gh">index 3301afef..992973ff 100644</span>
<span class="gd">--- a/paramiko/config.py</span>
<span class="gi">+++ b/paramiko/config.py</span>
<span class="gu">@@ -64,7 +64,9 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = cls()</span>
<span class="gi">+        config.parse(StringIO(text))</span>
<span class="gi">+        return config</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_path(cls, path):
<span class="gu">@@ -73,7 +75,8 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(path, &#39;r&#39;) as f:</span>
<span class="gi">+            return cls.from_file(f)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_file(cls, flo):
<span class="gu">@@ -82,7 +85,9 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = cls()</span>
<span class="gi">+        config.parse(flo)</span>
<span class="gi">+        return config</span>

<span class="w"> </span>    def parse(self, file_obj):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -90,7 +95,23 @@ class SSHConfig:</span>

<span class="w"> </span>        :param file_obj: a file-like object to read the config file from
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        host = {&quot;host&quot;: [&#39;*&#39;], &quot;config&quot;: {}}</span>
<span class="gi">+        for line in file_obj:</span>
<span class="gi">+            line = line.strip()</span>
<span class="gi">+            if not line or line.startswith(&#39;#&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if line.lower().startswith(&#39;host &#39;):</span>
<span class="gi">+                self._config.append(host)</span>
<span class="gi">+                host = {&quot;host&quot;: self._get_hosts(line.split()[1:]), &quot;config&quot;: {}}</span>
<span class="gi">+            elif line.lower().startswith(&#39;match &#39;):</span>
<span class="gi">+                self._config.append(host)</span>
<span class="gi">+                host = {&quot;host&quot;: [&#39;*&#39;], &quot;config&quot;: {}, &quot;match&quot;: self._get_matches(line)}</span>
<span class="gi">+            else:</span>
<span class="gi">+                key, value = self.SETTINGS_REGEX.match(line).groups()</span>
<span class="gi">+                host[&#39;config&#39;][key.lower()] = value</span>
<span class="gi">+</span>
<span class="gi">+        self._config.append(host)</span>

<span class="w"> </span>    def lookup(self, hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,7 +154,23 @@ class SSHConfig:</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``Match final`` support.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = [x for x in self._config if self._allowed(x, hostname)]</span>
<span class="gi">+</span>
<span class="gi">+        ret = SSHConfigDict()</span>
<span class="gi">+        for m in matches:</span>
<span class="gi">+            for k, v in m.get(&#39;config&#39;, {}).items():</span>
<span class="gi">+                if k not in ret:</span>
<span class="gi">+                    ret[k] = v</span>
<span class="gi">+</span>
<span class="gi">+        ret = self._expand_variables(ret, hostname)</span>
<span class="gi">+        if &#39;hostname&#39; not in ret:</span>
<span class="gi">+            ret[&#39;hostname&#39;] = hostname</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;canonicaldomains&#39; in ret and &#39;canonicalizehostname&#39; in ret:</span>
<span class="gi">+            if ret[&#39;canonicalizehostname&#39;].lower() == &#39;yes&#39;:</span>
<span class="gi">+                ret[&#39;hostname&#39;] = self.canonicalize(ret[&#39;hostname&#39;], ret, ret[&#39;canonicaldomains&#39;].split(&#39;,&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def canonicalize(self, hostname, options, domains):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -147,14 +184,27 @@ class SSHConfig:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;.&#39; not in hostname:</span>
<span class="gi">+            for domain in domains:</span>
<span class="gi">+                candidate = f&quot;{hostname}.{domain}&quot;</span>
<span class="gi">+                try:</span>
<span class="gi">+                    socket.getaddrinfo(candidate, None)</span>
<span class="gi">+                    return candidate</span>
<span class="gi">+                except socket.gaierror:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_hostnames(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the set of literal hostnames defined in the SSH config (both
<span class="w"> </span>        explicit hostnames and wildcard entries).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hostnames = set()</span>
<span class="gi">+        for entry in self._config:</span>
<span class="gi">+            for host in entry[&#39;host&#39;]:</span>
<span class="gi">+                if &#39;*&#39; not in host and &#39;?&#39; not in host:</span>
<span class="gi">+                    hostnames.add(host)</span>
<span class="gi">+        return hostnames</span>

<span class="w"> </span>    def _tokenize(self, config, target_hostname, key, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -167,7 +217,24 @@ class SSHConfig:</span>

<span class="w"> </span>        :returns: The tokenized version of the input ``value`` string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not value:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        tokens = self._allowed_tokens(key)</span>
<span class="gi">+        if not tokens:</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token == &#39;%h&#39;:</span>
<span class="gi">+                value = value.replace(token, target_hostname)</span>
<span class="gi">+            elif token == &#39;%r&#39;:</span>
<span class="gi">+                value = value.replace(token, config.get(&#39;user&#39;, getpass.getuser()))</span>
<span class="gi">+            elif token == &#39;%u&#39;:</span>
<span class="gi">+                value = value.replace(token, getpass.getuser())</span>
<span class="gi">+            elif token == &#39;~&#39;:</span>
<span class="gi">+                value = value.replace(token, os.path.expanduser(&#39;~&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def _allowed_tokens(self, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -178,7 +245,7 @@ class SSHConfig:</span>
<span class="w"> </span>            preserve as-strict-as-possible compatibility with OpenSSH, which
<span class="w"> </span>            for whatever reason only applies some tokens to some config keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.TOKENS_BY_CONFIG_KEY.get(key.lower(), [])</span>

<span class="w"> </span>    def _expand_variables(self, config, target_hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -190,13 +257,16 @@ class SSHConfig:</span>
<span class="w"> </span>        :param dict config: the currently parsed config
<span class="w"> </span>        :param str hostname: the hostname whose config is being looked up
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = SSHConfigDict()</span>
<span class="gi">+        for key, value in config.items():</span>
<span class="gi">+            ret[key] = self._tokenize(config, target_hostname, key, value)</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def _get_hosts(self, host):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of host_names from host value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [h.strip() for h in host]</span>

<span class="w"> </span>    def _get_matches(self, match):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -204,7 +274,24 @@ class SSHConfig:</span>

<span class="w"> </span>        Performs some parse-time validation as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = []</span>
<span class="gi">+        tokens = match.split()[1:]</span>
<span class="gi">+        current_match = {}</span>
<span class="gi">+        </span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token.lower() in (&#39;all&#39;, &#39;canonical&#39;, &#39;final&#39;, &#39;exec&#39;, &#39;host&#39;, &#39;originalhost&#39;, &#39;user&#39;, &#39;localuser&#39;):</span>
<span class="gi">+                if current_match:</span>
<span class="gi">+                    matches.append(current_match)</span>
<span class="gi">+                current_match = {&#39;type&#39;: token.lower()}</span>
<span class="gi">+            else:</span>
<span class="gi">+                if &#39;values&#39; not in current_match:</span>
<span class="gi">+                    current_match[&#39;values&#39;] = []</span>
<span class="gi">+                current_match[&#39;values&#39;].append(token)</span>
<span class="gi">+        </span>
<span class="gi">+        if current_match:</span>
<span class="gi">+            matches.append(current_match)</span>
<span class="gi">+        </span>
<span class="gi">+        return matches</span>


<span class="w"> </span>def _addressfamily_host_lookup(hostname, options):
<span class="gh">diff --git a/paramiko/dsskey.py b/paramiko/dsskey.py</span>
<span class="gh">index a2882c5e..3a944332 100644</span>
<span class="gd">--- a/paramiko/dsskey.py</span>
<span class="gi">+++ b/paramiko/dsskey.py</span>
<span class="gu">@@ -61,4 +61,18 @@ class DSSKey(PKey):</span>
<span class="w"> </span>        :param progress_func: Unused
<span class="w"> </span>        :return: new `.DSSKey` private key
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key = dsa.generate_private_key(</span>
<span class="gi">+            key_size=bits,</span>
<span class="gi">+            backend=default_backend()</span>
<span class="gi">+        )</span>
<span class="gi">+        numbers = private_key.private_numbers()</span>
<span class="gi">+        public_numbers = numbers.public_numbers</span>
<span class="gi">+        </span>
<span class="gi">+        new_key = DSSKey(vals=(</span>
<span class="gi">+            public_numbers.parameter_numbers.p,</span>
<span class="gi">+            public_numbers.parameter_numbers.q,</span>
<span class="gi">+            public_numbers.parameter_numbers.g,</span>
<span class="gi">+            public_numbers.y</span>
<span class="gi">+        ))</span>
<span class="gi">+        new_key.x = numbers.x</span>
<span class="gi">+        return new_key</span>
<span class="gh">diff --git a/paramiko/ecdsakey.py b/paramiko/ecdsakey.py</span>
<span class="gh">index 3c6f2ecf..329c7fe5 100644</span>
<span class="gd">--- a/paramiko/ecdsakey.py</span>
<span class="gi">+++ b/paramiko/ecdsakey.py</span>
<span class="gu">@@ -105,7 +105,11 @@ class ECDSAKey(PKey):</span>
<span class="w"> </span>        Generate a new private ECDSA key.  This factory function can be used to
<span class="w"> </span>        generate a new host key or authentication key.

<span class="gi">+        :param curve: The curve to use for key generation. Default is SECP256R1.</span>
<span class="w"> </span>        :param progress_func: Not used for this type of key.
<span class="gi">+        :param bits: Not used for ECDSA keys.</span>
<span class="w"> </span>        :returns: A new private key (`.ECDSAKey`) object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key = ec.generate_private_key(curve, default_backend())</span>
<span class="gi">+        ecdsa_curve = cls._ECDSA_CURVES.get_by_curve_class(curve.__class__)</span>
<span class="gi">+        return cls(vals=(private_key, private_key.public_key()))</span>
<span class="gh">diff --git a/paramiko/file.py b/paramiko/file.py</span>
<span class="gh">index 9ff61859..f0d75d64 100644</span>
<span class="gd">--- a/paramiko/file.py</span>
<span class="gi">+++ b/paramiko/file.py</span>
<span class="gu">@@ -50,14 +50,18 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the file.  Future read and write operations will fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+            self._closed = True</span>

<span class="w"> </span>    def flush(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write out any data in the write buffer.  This may do nothing if write
<span class="w"> </span>        buffering is not turned on.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._wbuffer.tell() &gt; 0:</span>
<span class="gi">+            self._write(self._wbuffer.getvalue())</span>
<span class="gi">+            self._wbuffer = BytesIO()</span>

<span class="w"> </span>    def __next__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +88,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file can be read from. If `False`, `read` will raise
<span class="w"> </span>            an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._flags &amp; self.FLAG_READ)</span>

<span class="w"> </span>    def writable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -94,7 +98,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file can be written to. If `False`, `write` will
<span class="w"> </span>            raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._flags &amp; self.FLAG_WRITE)</span>

<span class="w"> </span>    def seekable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -104,7 +108,7 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            `True` if the file supports random access. If `False`, `seek` will
<span class="w"> </span>            raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def readinto(self, buff):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -114,7 +118,9 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        :returns:
<span class="w"> </span>            The number of bytes read.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self.read(len(buff))</span>
<span class="gi">+        buff[:len(data)] = data</span>
<span class="gi">+        return len(data)</span>

<span class="w"> </span>    def read(self, size=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -133,7 +139,35 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            data read from the file (as bytes), or an empty string if EOF was
<span class="w"> </span>            encountered immediately
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="gi">+        if not self.readable():</span>
<span class="gi">+            raise IOError(&quot;File not open for reading&quot;)</span>
<span class="gi">+        if size is None or size &lt; 0:</span>
<span class="gi">+            # Read until EOF</span>
<span class="gi">+            result = self._rbuffer</span>
<span class="gi">+            self._rbuffer = bytes()</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    chunk = self._read(self._bufsize)</span>
<span class="gi">+                except EOFError:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if not chunk:</span>
<span class="gi">+                    break</span>
<span class="gi">+                result += chunk</span>
<span class="gi">+            return result</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self._rbuffer[:size]</span>
<span class="gi">+            self._rbuffer = self._rbuffer[size:]</span>
<span class="gi">+            while len(result) &lt; size:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    chunk = self._read(size - len(result))</span>
<span class="gi">+                except EOFError:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if not chunk:</span>
<span class="gi">+                    break</span>
<span class="gi">+                result += chunk</span>
<span class="gi">+            return result</span>

<span class="w"> </span>    def readline(self, size=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -157,7 +191,41 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>            Else: the encoding of the file is assumed to be UTF-8 and character
<span class="w"> </span>            strings (`str`) are returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="gi">+        if not self.readable():</span>
<span class="gi">+            raise IOError(&quot;File not open for reading&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        line = b&quot;&quot;</span>
<span class="gi">+        while size is None or len(line) &lt; size:</span>
<span class="gi">+            if self._rbuffer:</span>
<span class="gi">+                newline_pos = self._rbuffer.find(b&quot;\n&quot;)</span>
<span class="gi">+                if newline_pos != -1:</span>
<span class="gi">+                    line += self._rbuffer[:newline_pos + 1]</span>
<span class="gi">+                    self._rbuffer = self._rbuffer[newline_pos + 1:]</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    line += self._rbuffer</span>
<span class="gi">+                    self._rbuffer = b&quot;&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                chunk = self._read(self._bufsize)</span>
<span class="gi">+            except EOFError:</span>
<span class="gi">+                break</span>
<span class="gi">+            if not chunk:</span>
<span class="gi">+                break</span>
<span class="gi">+            newline_pos = chunk.find(b&quot;\n&quot;)</span>
<span class="gi">+            if newline_pos != -1:</span>
<span class="gi">+                line += chunk[:newline_pos + 1]</span>
<span class="gi">+                self._rbuffer = chunk[newline_pos + 1:]</span>
<span class="gi">+                break</span>
<span class="gi">+            line += chunk</span>
<span class="gi">+</span>
<span class="gi">+        if size is not None:</span>
<span class="gi">+            line = line[:size]</span>
<span class="gi">+</span>
<span class="gi">+        if not self._flags &amp; self.FLAG_BINARY:</span>
<span class="gi">+            return line.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        return line</span>

<span class="w"> </span>    def readlines(self, sizehint=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -169,7 +237,15 @@ class BufferedFile(ClosingContextManager):</span>
<span class="w"> </span>        :param int sizehint: desired maximum number of bytes to read.
<span class="w"> </span>        :returns: list of lines read from the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        total_size = 0</span>
<span class="gi">+        while sizehint is None or total_size &lt; sizehint:</span>
<span class="gi">+            line = self.readline()</span>
<span class="gi">+            if not line:</span>
<span class="gi">+                break</span>
<span class="gi">+            lines.append(line)</span>
<span class="gi">+            total_size += len(line)</span>
<span class="gi">+        return lines</span>

<span class="w"> </span>    def seek(self, offset, whence=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -189,7 +265,22 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if the file doesn&#39;t support random access.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="gi">+        if not self.seekable():</span>
<span class="gi">+            raise IOError(&quot;File does not support random access&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if whence == self.SEEK_SET:</span>
<span class="gi">+            self._pos = offset</span>
<span class="gi">+        elif whence == self.SEEK_CUR:</span>
<span class="gi">+            self._pos += offset</span>
<span class="gi">+        elif whence == self.SEEK_END:</span>
<span class="gi">+            self._pos = self._get_size() + offset</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Invalid whence value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._pos = max(0, self._pos)</span>
<span class="gi">+        self._rbuffer = b&quot;&quot;</span>

<span class="w"> </span>    def tell(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -199,7 +290,9 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :returns: file position (`number &lt;int&gt;` of bytes).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="gi">+        return self._pos</span>

<span class="w"> </span>    def write(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -210,7 +303,24 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :param data: ``str``/``bytes`` data to write
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._closed:</span>
<span class="gi">+            raise ValueError(&quot;I/O operation on closed file&quot;)</span>
<span class="gi">+        if not self.writable():</span>
<span class="gi">+            raise IOError(&quot;File not open for writing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(data, str):</span>
<span class="gi">+            data = data.encode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._flags &amp; self.FLAG_BUFFERED:</span>
<span class="gi">+            self._wbuffer.write(data)</span>
<span class="gi">+            if self._wbuffer.tell() &gt;= self._bufsize:</span>
<span class="gi">+                self.flush()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._write(data)</span>
<span class="gi">+</span>
<span class="gi">+        self._pos += len(data)</span>
<span class="gi">+        if self._flags &amp; self.FLAG_APPEND:</span>
<span class="gi">+            self._pos = self._get_size()</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -221,7 +331,8 @@ class BufferedFile(ClosingContextManager):</span>

<span class="w"> </span>        :param sequence: an iterable sequence of strings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for line in sequence:</span>
<span class="gi">+            self.write(line)</span>

<span class="w"> </span>    def xreadlines(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/hostkeys.py b/paramiko/hostkeys.py</span>
<span class="gh">index f2bbb85b..80e40296 100644</span>
<span class="gd">--- a/paramiko/hostkeys.py</span>
<span class="gi">+++ b/paramiko/hostkeys.py</span>
<span class="gu">@@ -42,7 +42,11 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :param str keytype: key type (``&quot;ssh-rsa&quot;`` or ``&quot;ssh-dss&quot;``)
<span class="w"> </span>        :param .PKey key: the key to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for entry in self._entries:</span>
<span class="gi">+            if hostname in entry.hostnames and entry.key.get_name() == keytype:</span>
<span class="gi">+                entry.key = key</span>
<span class="gi">+                return</span>
<span class="gi">+        self._entries.append(HostKeyEntry([hostname], key))</span>

<span class="w"> </span>    def load(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +63,16 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        :raises: ``IOError`` -- if there was an error reading the file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &#39;r&#39;) as f:</span>
<span class="gi">+            for lineno, line in enumerate(f, 1):</span>
<span class="gi">+                line = line.strip()</span>
<span class="gi">+                if line and not line.startswith(&#39;#&#39;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        entry = HostKeyEntry.from_line(line, lineno)</span>
<span class="gi">+                        if entry.valid:</span>
<span class="gi">+                            self._entries.append(entry)</span>
<span class="gi">+                    except InvalidHostKey:</span>
<span class="gi">+                        pass</span>

<span class="w"> </span>    def save(self, filename):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -74,7 +87,11 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        .. versionadded:: 1.6.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &#39;w&#39;) as f:</span>
<span class="gi">+            for entry in self._entries:</span>
<span class="gi">+                line = entry.to_line()</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    f.write(line)</span>

<span class="w"> </span>    def lookup(self, hostname):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -86,7 +103,11 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :return: dict of `str` -&gt; `.PKey` keys associated with this host
<span class="w"> </span>            (or ``None``)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = {}</span>
<span class="gi">+        for entry in self._entries:</span>
<span class="gi">+            if self._hostname_matches(hostname, entry):</span>
<span class="gi">+                matches[entry.key.get_name()] = entry.key</span>
<span class="gi">+        return matches if matches else None</span>

<span class="w"> </span>    def _hostname_matches(self, hostname, entry):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -94,7 +115,34 @@ class HostKeys(MutableMapping):</span>

<span class="w"> </span>        :returns bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for pattern in entry.hostnames:</span>
<span class="gi">+            if pattern.startswith(&#39;|1|&#39;):</span>
<span class="gi">+                # This is a hashed hostname</span>
<span class="gi">+                if self._match_hashed_hostname(hostname, pattern):</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif pattern.startswith(&#39;*&#39;):</span>
<span class="gi">+                # This is a wildcard hostname</span>
<span class="gi">+                if self._match_wildcard_hostname(hostname, pattern):</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif pattern == hostname:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _match_hashed_hostname(self, hostname, pattern):</span>
<span class="gi">+        _, salt, hash_value = pattern.split(&#39;|&#39;)</span>
<span class="gi">+        salt = decodebytes(salt.encode(&#39;ascii&#39;))</span>
<span class="gi">+        hash_value = decodebytes(hash_value.encode(&#39;ascii&#39;))</span>
<span class="gi">+        return constant_time_bytes_eq(HMAC(salt, hostname.encode(&#39;utf-8&#39;), sha1).digest(), hash_value)</span>
<span class="gi">+</span>
<span class="gi">+    def _match_wildcard_hostname(self, hostname, pattern):</span>
<span class="gi">+        parts = pattern.split(&#39;.&#39;)</span>
<span class="gi">+        hostname_parts = hostname.split(&#39;.&#39;)</span>
<span class="gi">+        if len(parts) != len(hostname_parts):</span>
<span class="gi">+            return False</span>
<span class="gi">+        for i, part in enumerate(parts):</span>
<span class="gi">+            if part != &#39;*&#39; and part != hostname_parts[i]:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def check(self, hostname, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -106,13 +154,19 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>        :return:
<span class="w"> </span>            ``True`` if the key is associated with the hostname; else ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matching_keys = self.lookup(hostname)</span>
<span class="gi">+        if matching_keys is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        for k in matching_keys.values():</span>
<span class="gi">+            if k.get_name() == key.get_name() and k.asbytes() == key.asbytes():</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove all host keys from the dictionary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._entries = []</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for k in self.keys():
<span class="gu">@@ -161,7 +215,20 @@ class HostKeys(MutableMapping):</span>
<span class="w"> </span>            (must be 20 bytes long)
<span class="w"> </span>        :return: the hashed hostname as a `str`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if salt is None:</span>
<span class="gi">+            salt = os.urandom(20)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(salt, str):</span>
<span class="gi">+                salt = salt.encode(&#39;ascii&#39;)</span>
<span class="gi">+            if len(salt) != 20:</span>
<span class="gi">+                raise ValueError(&quot;Salt must be 20 bytes long&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hmac = HMAC(salt, hostname.encode(&#39;utf-8&#39;), sha1)</span>
<span class="gi">+        host_hash = hmac.digest()</span>
<span class="gi">+        return &#39;|1|{}|{}&#39;.format(</span>
<span class="gi">+            encodebytes(salt).decode(&#39;ascii&#39;).strip(),</span>
<span class="gi">+            encodebytes(host_hash).decode(&#39;ascii&#39;).strip()</span>
<span class="gi">+        )</span>


<span class="w"> </span>class InvalidHostKey(Exception):
<span class="gu">@@ -196,7 +263,23 @@ class HostKeyEntry:</span>

<span class="w"> </span>        :param str line: a line from an OpenSSH known_hosts file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fields = line.split()</span>
<span class="gi">+        if len(fields) &lt; 3:</span>
<span class="gi">+            raise InvalidHostKey(line, &quot;Not enough fields&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hostnames = fields[0].split(&#39;,&#39;)</span>
<span class="gi">+        keytype = fields[1]</span>
<span class="gi">+        key = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            key = PKey(data=decodebytes(fields[2].encode(&#39;ascii&#39;)))</span>
<span class="gi">+        except (binascii.Error, SSHException) as e:</span>
<span class="gi">+            raise InvalidHostKey(line, str(e))</span>
<span class="gi">+</span>
<span class="gi">+        if key.get_name() != keytype:</span>
<span class="gi">+            raise InvalidHostKey(line, &quot;Key type mismatch&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(hostnames, key)</span>

<span class="w"> </span>    def to_line(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -204,7 +287,13 @@ class HostKeyEntry:</span>
<span class="w"> </span>        the object is not in a valid state.  A trailing newline is
<span class="w"> </span>        included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.valid:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return &#39;{} {} {}\n&#39;.format(</span>
<span class="gi">+            &#39;,&#39;.join(self.hostnames),</span>
<span class="gi">+            self.key.get_name(),</span>
<span class="gi">+            encodebytes(self.key.asbytes()).decode(&#39;ascii&#39;).strip()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;HostKeyEntry {!r}: {!r}&gt;&#39;.format(self.hostnames, self.key)
<span class="gh">diff --git a/paramiko/kex_gss.py b/paramiko/kex_gss.py</span>
<span class="gh">index 50d792e4..b1b3b879 100644</span>
<span class="gd">--- a/paramiko/kex_gss.py</span>
<span class="gi">+++ b/paramiko/kex_gss.py</span>
<span class="gu">@@ -55,7 +55,17 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the GSS-API / SSPI Authenticated Diffie-Hellman Key Exchange.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.gss_host = self.transport.gss_host</span>
<span class="gi">+        self._generate_x()</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.f = pow(self.G, self.x, self.P)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.e = pow(self.G, self.x, self.P)</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_INIT)</span>
<span class="gi">+            m.add_string(self.kexgss.ssh_init_sec_context(target=self.gss_host))</span>
<span class="gi">+            m.add_mpint(self.e)</span>
<span class="gi">+            self.transport._send_message(m)</span>

<span class="w"> </span>    def parse_next(self, ptype, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -64,7 +74,18 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param ptype: The (string) type of the incoming packet
<span class="w"> </span>        :param `.Message` m: The packet content
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ptype == MSG_KEXGSS_HOSTKEY:</span>
<span class="gi">+            self._parse_kexgss_hostkey(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_CONTINUE:</span>
<span class="gi">+            self._parse_kexgss_continue(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_COMPLETE:</span>
<span class="gi">+            self._parse_kexgss_complete(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_ERROR:</span>
<span class="gi">+            self._parse_kexgss_error(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_INIT and self.transport.server_mode:</span>
<span class="gi">+            self._parse_kexgss_init(m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(&#39;KexGSS asked to handle packet type %d&#39; % ptype)</span>

<span class="w"> </span>    def _generate_x(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -74,7 +95,13 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        potential x where the first 63 bits are 1, because some of those will
<span class="w"> </span>        be larger than q (but this is a tiny tiny subset of potential x).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            x_bytes = os.urandom(128)</span>
<span class="gi">+            x_bytes = byte_mask(x_bytes[0], 0x7f) + x_bytes[1:]</span>
<span class="gi">+            if (x_bytes[:8] != self.b7fffffffffffffff and</span>
<span class="gi">+                x_bytes[:8] != self.b0000000000000000):</span>
<span class="gi">+                break</span>
<span class="gi">+        self.x = util.inflate_long(x_bytes)</span>

<span class="w"> </span>    def _parse_kexgss_hostkey(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -82,7 +109,8 @@ class KexGSSGroup1:</span>

<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_HOSTKEY message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hostkey = m.get_string()</span>
<span class="gi">+        self.transport._set_remote_server_key(hostkey)</span>

<span class="w"> </span>    def _parse_kexgss_continue(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -91,7 +119,12 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_CONTINUE
<span class="w"> </span>            message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = m.get_string()</span>
<span class="gi">+        srv_token = self.kexgss.ssh_accept_sec_context(token)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+        m.add_string(srv_token)</span>
<span class="gi">+        self.transport._send_message(m)</span>

<span class="w"> </span>    def _parse_kexgss_complete(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -100,7 +133,14 @@ class KexGSSGroup1:</span>
<span class="w"> </span>        :param `.Message` m: The content of the
<span class="w"> </span>            SSH2_MSG_KEXGSS_COMPLETE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.f, self.x, self.P)</span>
<span class="gi">+        self.transport._set_K_H(K, self.transport.kex_engine.compute_key(K, self.transport.H))</span>
<span class="gi">+        self.transport._verify_key(self.transport.H, mic_token)</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_init(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,7 +148,20 @@ class KexGSSGroup1:</span>

<span class="w"> </span>        :param `.Message` m: The content of the SSH2_MSG_KEXGSS_INIT message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        client_token = m.get_string()</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.P - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.e, self.x, self.P)</span>
<span class="gi">+        self.transport._set_K_H(K, self.transport.kex_engine.compute_key(K, self.transport.H))</span>
<span class="gi">+        srv_token = self.kexgss.ssh_accept_sec_context(client_token)</span>
<span class="gi">+        mic_token = self.kexgss.ssh_get_mic(self.transport.H)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_COMPLETE)</span>
<span class="gi">+        m.add_string(mic_token)</span>
<span class="gi">+        m.add_mpint(self.f)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_error(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -121,7 +174,11 @@ class KexGSSGroup1:</span>
<span class="w"> </span>                             the error message and the language tag of the
<span class="w"> </span>                             message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        maj_status = m.get_int()</span>
<span class="gi">+        min_status = m.get_int()</span>
<span class="gi">+        err_msg = m.get_string()</span>
<span class="gi">+        m.get_string()  # Language tag (discarded)</span>
<span class="gi">+        raise SSHException(f&quot;GSS-API Error: Major Status: {maj_status}, Minor Status: {min_status}, Error: {err_msg.decode(&#39;utf-8&#39;)}&quot;)</span>


<span class="w"> </span>class KexGSSGroup14(KexGSSGroup1):
<span class="gu">@@ -163,7 +220,17 @@ class KexGSSGex:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the GSS-API / SSPI Authenticated Diffie-Hellman Group Exchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.gss_host = self.transport.gss_host</span>
<span class="gi">+        if self.transport.server_mode:</span>
<span class="gi">+            self.x = util.generate_key_number(self.transport.get_security_options().get(&#39;kex&#39;, {}).get(&#39;bits&#39;, 2048))</span>
<span class="gi">+            self.e = pow(self.g, self.x, self.p)</span>
<span class="gi">+        else:</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(c_MSG_KEXGSS_GROUPREQ)</span>
<span class="gi">+            m.add_int(self.min_bits)</span>
<span class="gi">+            m.add_int(self.preferred_bits)</span>
<span class="gi">+            m.add_int(self.max_bits)</span>
<span class="gi">+            self.transport._send_message(m)</span>

<span class="w"> </span>    def parse_next(self, ptype, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -172,7 +239,22 @@ class KexGSSGex:</span>
<span class="w"> </span>        :param ptype: The (string) type of the incoming packet
<span class="w"> </span>        :param `.Message` m: The packet content
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ptype == MSG_KEXGSS_GROUPREQ:</span>
<span class="gi">+            self._parse_kexgss_groupreq(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_GROUP:</span>
<span class="gi">+            self._parse_kexgss_group(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_INIT:</span>
<span class="gi">+            self._parse_kexgss_gex_init(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_HOSTKEY:</span>
<span class="gi">+            self._parse_kexgss_hostkey(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_CONTINUE:</span>
<span class="gi">+            self._parse_kexgss_continue(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_COMPLETE:</span>
<span class="gi">+            self._parse_kexgss_complete(m)</span>
<span class="gi">+        elif ptype == MSG_KEXGSS_ERROR:</span>
<span class="gi">+            self._parse_kexgss_error(m)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(&#39;KexGSSGex asked to handle packet type %d&#39; % ptype)</span>

<span class="w"> </span>    def _parse_kexgss_groupreq(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -181,7 +263,17 @@ class KexGSSGex:</span>
<span class="w"> </span>        :param `.Message` m: The content of the
<span class="w"> </span>            SSH2_MSG_KEXGSS_GROUPREQ message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        minbits = m.get_int()</span>
<span class="gi">+        preferredbits = m.get_int()</span>
<span class="gi">+        maxbits = m.get_int()</span>
<span class="gi">+        # TODO: Actually generate p and g based on the requested bits</span>
<span class="gi">+        self.p = self.transport.get_security_options().get(&#39;kex&#39;, {}).get(&#39;p&#39;, None)</span>
<span class="gi">+        self.g = self.transport.get_security_options().get(&#39;kex&#39;, {}).get(&#39;g&#39;, 2)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_GROUP)</span>
<span class="gi">+        m.add_mpint(self.p)</span>
<span class="gi">+        m.add_mpint(self.g)</span>
<span class="gi">+        self.transport._send_message(m)</span>

<span class="w"> </span>    def _parse_kexgss_group(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -189,7 +281,15 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_GROUP message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.p = m.get_mpint()</span>
<span class="gi">+        self.g = m.get_mpint()</span>
<span class="gi">+        self.x = util.generate_key_number(self.transport.get_security_options().get(&#39;kex&#39;, {}).get(&#39;bits&#39;, 2048))</span>
<span class="gi">+        self.e = pow(self.g, self.x, self.p)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_INIT)</span>
<span class="gi">+        m.add_string(self.kexgss.ssh_init_sec_context(target=self.gss_host))</span>
<span class="gi">+        m.add_mpint(self.e)</span>
<span class="gi">+        self.transport._send_message(m)</span>

<span class="w"> </span>    def _parse_kexgss_gex_init(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -197,7 +297,20 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_INIT message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        client_token = m.get_string()</span>
<span class="gi">+        self.e = m.get_mpint()</span>
<span class="gi">+        if (self.e &lt; 1) or (self.e &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Client kex &quot;e&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.e, self.x, self.p)</span>
<span class="gi">+        self.transport._set_K_H(K, self.transport.kex_engine.compute_key(K, self.transport.H))</span>
<span class="gi">+        srv_token = self.kexgss.ssh_accept_sec_context(client_token)</span>
<span class="gi">+        mic_token = self.kexgss.ssh_get_mic(self.transport.H)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_COMPLETE)</span>
<span class="gi">+        m.add_string(mic_token)</span>
<span class="gi">+        m.add_mpint(self.f)</span>
<span class="gi">+        self.transport._send_message(m)</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_hostkey(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -205,7 +318,8 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_HOSTKEY message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hostkey = m.get_string()</span>
<span class="gi">+        self.transport._set_remote_server_key(hostkey)</span>

<span class="w"> </span>    def _parse_kexgss_continue(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -213,7 +327,12 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_CONTINUE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = m.get_string()</span>
<span class="gi">+        srv_token = self.kexgss.ssh_init_sec_context(token, self.gss_host)</span>
<span class="gi">+        m = Message()</span>
<span class="gi">+        m.add_byte(c_MSG_KEXGSS_CONTINUE)</span>
<span class="gi">+        m.add_string(srv_token)</span>
<span class="gi">+        self.transport._send_message(m)</span>

<span class="w"> </span>    def _parse_kexgss_complete(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -221,7 +340,14 @@ class KexGSSGex:</span>

<span class="w"> </span>        :param `Message` m: The content of the SSH2_MSG_KEXGSS_COMPLETE message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        self.f = m.get_mpint()</span>
<span class="gi">+        if (self.f &lt; 1) or (self.f &gt; self.p - 1):</span>
<span class="gi">+            raise SSHException(&#39;Server kex &quot;f&quot; is out of range&#39;)</span>
<span class="gi">+        K = pow(self.f, self.x, self.p)</span>
<span class="gi">+        self.transport._set_K_H(K, self.transport.kex_engine.compute_key(K, self.transport.H))</span>
<span class="gi">+        self.transport._verify_key(self.transport.H, mic_token)</span>
<span class="gi">+        self.transport._activate_outbound()</span>

<span class="w"> </span>    def _parse_kexgss_error(self, m):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -234,7 +360,11 @@ class KexGSSGex:</span>
<span class="w"> </span>                             the error message and the language tag of the
<span class="w"> </span>                             message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        maj_status = m.get_int()</span>
<span class="gi">+        min_status = m.get_int()</span>
<span class="gi">+        err_msg = m.get_string()</span>
<span class="gi">+        m.get_string()  # Language tag (discarded)</span>
<span class="gi">+        raise SSHException(f&quot;GSS-API Error: Major Status: {maj_status}, Minor Status: {min_status}, Error: {err_msg.decode(&#39;utf-8&#39;)}&quot;)</span>


<span class="w"> </span>class NullHostKey:
<span class="gh">diff --git a/paramiko/message.py b/paramiko/message.py</span>
<span class="gh">index 7e6e2c5a..66d873a3 100644</span>
<span class="gd">--- a/paramiko/message.py</span>
<span class="gi">+++ b/paramiko/message.py</span>
<span class="gu">@@ -46,21 +46,21 @@ class Message:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the byte stream content of this Message, as a `bytes`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.packet.getvalue()</span>

<span class="w"> </span>    def rewind(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Rewind the message to the beginning as if no items had been parsed
<span class="w"> </span>        out of it yet.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.seek(0)</span>

<span class="w"> </span>    def get_remainder(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `bytes` of this message that haven&#39;t already been parsed and
<span class="w"> </span>        returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.packet.read()</span>

<span class="w"> </span>    def get_so_far(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -68,7 +68,11 @@ class Message:</span>
<span class="w"> </span>        returned. The string passed into a message&#39;s constructor can be
<span class="w"> </span>        regenerated by concatenating ``get_so_far`` and `get_remainder`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        current_position = self.packet.tell()</span>
<span class="gi">+        self.packet.seek(0)</span>
<span class="gi">+        result = self.packet.read(current_position)</span>
<span class="gi">+        self.packet.seek(current_position)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def get_bytes(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -77,17 +81,21 @@ class Message:</span>
<span class="w"> </span>        string of ``n`` zero bytes if there weren&#39;t ``n`` bytes remaining in
<span class="w"> </span>        the message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self.packet.read(n)</span>
<span class="gi">+        if len(b) &lt; n:</span>
<span class="gi">+            return b + zero_byte * (n - len(b))</span>
<span class="gi">+        return b</span>

<span class="w"> </span>    def get_byte(self):
<span class="w"> </span>        &quot;\n        Return the next byte of the message, without decomposing it.  This\n        is equivalent to `get_bytes(1) &lt;get_bytes&gt;`.\n\n        :return:\n            the next (`bytes`) byte of the message, or ``b&#39;\x00&#39;`` if there\n            aren&#39;t any bytes remaining.\n        &quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_bytes(1)</span>

<span class="w"> </span>    def get_boolean(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch a boolean from the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = self.get_byte()</span>
<span class="gi">+        return b != zero_byte</span>

<span class="w"> </span>    def get_adaptive_int(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -95,13 +103,16 @@ class Message:</span>

<span class="w"> </span>        :return: a 32-bit unsigned `int`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        byte = ord(self.get_byte())</span>
<span class="gi">+        if byte &amp; 0x80:</span>
<span class="gi">+            return self.get_int()</span>
<span class="gi">+        return byte</span>

<span class="w"> </span>    def get_int(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fetch an int from the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.unpack(&#39;&gt;I&#39;, self.get_bytes(4))[0]</span>

<span class="w"> </span>    def get_int64(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -109,7 +120,7 @@ class Message:</span>

<span class="w"> </span>        :return: a 64-bit unsigned integer (`int`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.unpack(&#39;&gt;Q&#39;, self.get_bytes(8))[0]</span>

<span class="w"> </span>    def get_mpint(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -117,7 +128,12 @@ class Message:</span>

<span class="w"> </span>        :return: an arbitrary-length integer (`int`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = self.get_string()</span>
<span class="gi">+        if len(s) == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if ord(s[0:1]) &amp; 0x80:</span>
<span class="gi">+            return -int.from_bytes(s, &#39;big&#39;, signed=True)</span>
<span class="gi">+        return int.from_bytes(s, &#39;big&#39;)</span>

<span class="w"> </span>    def get_string(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -125,7 +141,7 @@ class Message:</span>
<span class="w"> </span>        object, and may contain unprintable characters.  (It&#39;s not unheard of
<span class="w"> </span>        for a string to contain another byte-stream message.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_bytes(self.get_int())</span>

<span class="w"> </span>    def get_text(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -134,13 +150,13 @@ class Message:</span>
<span class="w"> </span>        This currently operates by attempting to encode the next &quot;string&quot; as
<span class="w"> </span>        ``utf-8``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return u(self.get_string())</span>

<span class="w"> </span>    def get_binary(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Alias for `get_string` (obtains a bytestring).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_string()</span>

<span class="w"> </span>    def get_list(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -148,7 +164,7 @@ class Message:</span>

<span class="w"> </span>        These are trivially encoded as comma-separated values in a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_string().split(b&#39;,&#39;)</span>

<span class="w"> </span>    def add_bytes(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -156,7 +172,7 @@ class Message:</span>

<span class="w"> </span>        :param bytes b: bytes to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(b)</span>

<span class="w"> </span>    def add_byte(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -164,7 +180,7 @@ class Message:</span>

<span class="w"> </span>        :param bytes b: byte to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.packet.write(b)</span>

<span class="w"> </span>    def add_boolean(self, b):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -172,7 +188,7 @@ class Message:</span>

<span class="w"> </span>        :param bool b: boolean value to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_byte(one_byte if b else zero_byte)</span>

<span class="w"> </span>    def add_int(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -180,7 +196,7 @@ class Message:</span>

<span class="w"> </span>        :param int n: integer to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_bytes(struct.pack(&#39;&gt;I&#39;, n))</span>

<span class="w"> </span>    def add_adaptive_int(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -188,7 +204,10 @@ class Message:</span>

<span class="w"> </span>        :param int n: integer to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if n &lt; 0x80:</span>
<span class="gi">+            self.add_byte(struct.pack(&#39;B&#39;, n))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_int(n)</span>

<span class="w"> </span>    def add_int64(self, n):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -196,7 +215,7 @@ class Message:</span>

<span class="w"> </span>        :param int n: long int to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_bytes(struct.pack(&#39;&gt;Q&#39;, n))</span>

<span class="w"> </span>    def add_mpint(self, z):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -205,7 +224,13 @@ class Message:</span>

<span class="w"> </span>        :param int z: long int to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if z == 0:</span>
<span class="gi">+            self.add_string(b&#39;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = z.to_bytes((z.bit_length() + 7) // 8, &#39;big&#39;)</span>
<span class="gi">+            if ord(s[0:1]) &amp; 0x80:</span>
<span class="gi">+                s = b&#39;\x00&#39; + s</span>
<span class="gi">+            self.add_string(s)</span>

<span class="w"> </span>    def add_string(self, s):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -213,7 +238,8 @@ class Message:</span>

<span class="w"> </span>        :param byte s: bytestring to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_int(len(s))</span>
<span class="gi">+        self.add_bytes(s)</span>

<span class="w"> </span>    def add_list(self, l):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -223,7 +249,7 @@ class Message:</span>

<span class="w"> </span>        :param l: list of strings to add
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_string(b&#39;,&#39;.join(l))</span>

<span class="w"> </span>    def add(self, *seq):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -235,4 +261,16 @@ class Message:</span>

<span class="w"> </span>        :param seq: the sequence of items
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in seq:</span>
<span class="gi">+            if isinstance(item, bytes):</span>
<span class="gi">+                self.add_string(item)</span>
<span class="gi">+            elif isinstance(item, str):</span>
<span class="gi">+                self.add_string(item.encode(&#39;utf-8&#39;))</span>
<span class="gi">+            elif isinstance(item, int):</span>
<span class="gi">+                self.add_int(item)</span>
<span class="gi">+            elif isinstance(item, bool):</span>
<span class="gi">+                self.add_boolean(item)</span>
<span class="gi">+            elif isinstance(item, list):</span>
<span class="gi">+                self.add_list(item)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Unable to encode {type(item)} type&quot;)</span>
<span class="gh">diff --git a/paramiko/packet.py b/paramiko/packet.py</span>
<span class="gh">index 92f24b8c..53153c00 100644</span>
<span class="gd">--- a/paramiko/packet.py</span>
<span class="gi">+++ b/paramiko/packet.py</span>
<span class="gu">@@ -75,7 +75,7 @@ class Packetizer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the Python log object to use for logging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__logger = log</span>

<span class="w"> </span>    def set_outbound_cipher(self, block_engine, block_size, mac_engine,
<span class="w"> </span>        mac_size, mac_key, sdctr=False, etm=False):
<span class="gu">@@ -83,7 +83,13 @@ class Packetizer:</span>
<span class="w"> </span>        Switch outbound data cipher.
<span class="w"> </span>        :param etm: Set encrypt-then-mac from OpenSSH
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__block_engine_out = block_engine</span>
<span class="gi">+        self.__block_size_out = block_size</span>
<span class="gi">+        self.__mac_engine_out = mac_engine</span>
<span class="gi">+        self.__mac_size_out = mac_size</span>
<span class="gi">+        self.__mac_key_out = mac_key</span>
<span class="gi">+        self.__sdctr_out = sdctr</span>
<span class="gi">+        self.__etm_out = etm</span>

<span class="w"> </span>    def set_inbound_cipher(self, block_engine, block_size, mac_engine,
<span class="w"> </span>        mac_size, mac_key, etm=False):
<span class="gu">@@ -91,7 +97,12 @@ class Packetizer:</span>
<span class="w"> </span>        Switch inbound data cipher.
<span class="w"> </span>        :param etm: Set encrypt-then-mac from OpenSSH
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__block_engine_in = block_engine</span>
<span class="gi">+        self.__block_size_in = block_size</span>
<span class="gi">+        self.__mac_engine_in = mac_engine</span>
<span class="gi">+        self.__mac_size_in = mac_size</span>
<span class="gi">+        self.__mac_key_in = mac_key</span>
<span class="gi">+        self.__etm_in = etm</span>

<span class="w"> </span>    def need_rekey(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -99,7 +110,7 @@ class Packetizer:</span>
<span class="w"> </span>        will be triggered during a packet read or write, so it should be
<span class="w"> </span>        checked after every read or write, or at least after every few.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__need_rekey</span>

<span class="w"> </span>    def set_keepalive(self, interval, callback):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -107,7 +118,9 @@ class Packetizer:</span>
<span class="w"> </span>        no data read from or written to the socket, the callback will be
<span class="w"> </span>        executed and the timer will be reset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__keepalive_interval = interval</span>
<span class="gi">+        self.__keepalive_callback = callback</span>
<span class="gi">+        self.__keepalive_last = time.time()</span>

<span class="w"> </span>    def start_handshake(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -117,7 +130,9 @@ class Packetizer:</span>

<span class="w"> </span>        :param float timeout: amount of seconds to wait before timing out
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__handshake_complete = False</span>
<span class="gi">+        self.__timer = threading.Timer(timeout, self.__set_timer_expired)</span>
<span class="gi">+        self.__timer.start()</span>

<span class="w"> </span>    def handshake_timed_out(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -129,13 +144,18 @@ class Packetizer:</span>

<span class="w"> </span>        :return: handshake time out status, as a `bool`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__timer_expired and not self.__handshake_complete</span>

<span class="w"> </span>    def complete_handshake(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Tells `Packetizer` that the handshake has completed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__handshake_complete = True</span>
<span class="gi">+        if self.__timer:</span>
<span class="gi">+            self.__timer.cancel()</span>
<span class="gi">+</span>
<span class="gi">+    def __set_timer_expired(self):</span>
<span class="gi">+        self.__timer_expired = True</span>

<span class="w"> </span>    def read_all(self, n, check_rekey=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -148,20 +168,57 @@ class Packetizer:</span>
<span class="w"> </span>            ``EOFError`` -- if the socket was closed before all the bytes could
<span class="w"> </span>            be read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = self.__remainder</span>
<span class="gi">+        while len(out) &lt; n:</span>
<span class="gi">+            try:</span>
<span class="gi">+                x = self.__socket.recv(n - len(out))</span>
<span class="gi">+                if len(x) == 0:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                out += x</span>
<span class="gi">+            except socket.timeout:</span>
<span class="gi">+                if self.__closed:</span>
<span class="gi">+                    raise EOFError()</span>
<span class="gi">+                if check_rekey and (len(out) == 0) and self.need_rekey():</span>
<span class="gi">+                    raise NeedRekeyException()</span>
<span class="gi">+        self.__remainder = out[n:]</span>
<span class="gi">+        return out[:n]</span>

<span class="w"> </span>    def readline(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read a line from the socket.  We assume no data is pending after the
<span class="w"> </span>        line, so it&#39;s okay to attempt large reads.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buf = self.__remainder</span>
<span class="gi">+        while True:</span>
<span class="gi">+            i = buf.find(linefeed_byte)</span>
<span class="gi">+            if i &gt;= 0:</span>
<span class="gi">+                line = buf[:i + 1]</span>
<span class="gi">+                self.__remainder = buf[i + 1:]</span>
<span class="gi">+                return line</span>
<span class="gi">+            try:</span>
<span class="gi">+                buf += self.__socket.recv(1024)</span>
<span class="gi">+            except socket.timeout:</span>
<span class="gi">+                if timeout is not None and timeout &gt; 0:</span>
<span class="gi">+                    timeout -= 1</span>
<span class="gi">+                    if timeout == 0:</span>
<span class="gi">+                        return None</span>
<span class="gi">+                continue</span>

<span class="w"> </span>    def send_message(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write a block of data using the current cipher, as an SSH block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.__write_lock:</span>
<span class="gi">+            self.__sequence_number_out += 1</span>
<span class="gi">+            packet = self.__build_packet(data)</span>
<span class="gi">+            if self.__block_engine_out is not None:</span>
<span class="gi">+                packet = self.__block_engine_out.encrypt(packet)</span>
<span class="gi">+            if self.__mac_engine_out is not None:</span>
<span class="gi">+                mac = self.__compute_mac_out(packet)</span>
<span class="gi">+                packet += mac</span>
<span class="gi">+            self.__sent_bytes += len(packet)</span>
<span class="gi">+            self.__sent_packets += 1</span>
<span class="gi">+            self.__socket.sendall(packet)</span>

<span class="w"> </span>    def read_message(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -171,4 +228,30 @@ class Packetizer:</span>
<span class="w"> </span>        :raises: `.SSHException` -- if the packet is mangled
<span class="w"> </span>        :raises: `.NeedRekeyException` -- if the transport should rekey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        header = self.read_all(self.__block_size_in, check_rekey=True)</span>
<span class="gi">+        if self.__block_engine_in is not None:</span>
<span class="gi">+            header = self.__block_engine_in.decrypt(header)</span>
<span class="gi">+        packet_size = struct.unpack(&#39;&gt;I&#39;, header[:4])[0]</span>
<span class="gi">+        leftover = header[4:]</span>
<span class="gi">+        if (packet_size - len(leftover)) % self.__block_size_in != 0:</span>
<span class="gi">+            raise SSHException(&#39;Invalid packet blocking&#39;)</span>
<span class="gi">+        buf = self.read_all(packet_size + self.__mac_size_in - len(leftover))</span>
<span class="gi">+        packet = leftover + buf[:packet_size - len(leftover)]</span>
<span class="gi">+        if self.__block_engine_in is not None:</span>
<span class="gi">+            packet = self.__block_engine_in.decrypt(packet)</span>
<span class="gi">+        if self.__mac_engine_in is not None:</span>
<span class="gi">+            mac = buf[packet_size - len(leftover):]</span>
<span class="gi">+            mac_payload = struct.pack(&#39;&gt;II&#39;, self.__sequence_number_in, packet_size) + packet</span>
<span class="gi">+            my_mac = self.__mac_engine_in.digest(self.__mac_key_in, mac_payload)</span>
<span class="gi">+            if my_mac != mac:</span>
<span class="gi">+                raise SSHException(&#39;Mismatched MAC&#39;)</span>
<span class="gi">+        padding = byte_ord(packet[0])</span>
<span class="gi">+        payload = packet[1:packet_size - padding]</span>
<span class="gi">+        self.__sequence_number_in += 1</span>
<span class="gi">+        self.__received_bytes += packet_size + self.__mac_size_in + 4</span>
<span class="gi">+        self.__received_packets += 1</span>
<span class="gi">+        if self.need_rekey():</span>
<span class="gi">+            raise NeedRekeyException()</span>
<span class="gi">+        msg = Message(payload[1:])</span>
<span class="gi">+        msg.seqno = self.__sequence_number_in</span>
<span class="gi">+        return byte_ord(payload[0]), msg</span>
<span class="gh">diff --git a/paramiko/pipe.py b/paramiko/pipe.py</span>
<span class="gh">index 0b740739..b738fd3d 100644</span>
<span class="gd">--- a/paramiko/pipe.py</span>
<span class="gi">+++ b/paramiko/pipe.py</span>
<span class="gu">@@ -19,6 +19,24 @@ class PosixPipe:</span>
<span class="w"> </span>        self._forever = False
<span class="w"> </span>        self._closed = False

<span class="gi">+    def fileno(self):</span>
<span class="gi">+        return self._rfd</span>
<span class="gi">+</span>
<span class="gi">+    def set(self):</span>
<span class="gi">+        if not self._set:</span>
<span class="gi">+            os.write(self._wfd, b&#39;1&#39;)</span>
<span class="gi">+            self._set = True</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if self._set:</span>
<span class="gi">+            os.read(self._rfd, 1)</span>
<span class="gi">+            self._set = False</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        os.close(self._rfd)</span>
<span class="gi">+        os.close(self._wfd)</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+</span>

<span class="w"> </span>class WindowsPipe:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -38,6 +56,24 @@ class WindowsPipe:</span>
<span class="w"> </span>        self._forever = False
<span class="w"> </span>        self._closed = False

<span class="gi">+    def fileno(self):</span>
<span class="gi">+        return self._rsock.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def set(self):</span>
<span class="gi">+        if not self._set:</span>
<span class="gi">+            self._wsock.send(b&#39;1&#39;)</span>
<span class="gi">+            self._set = True</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if self._set:</span>
<span class="gi">+            self._rsock.recv(1)</span>
<span class="gi">+            self._set = False</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self._rsock.close()</span>
<span class="gi">+        self._wsock.close()</span>
<span class="gi">+        self._closed = True</span>
<span class="gi">+</span>

<span class="w"> </span>class OrPipe:

<span class="gu">@@ -46,6 +82,23 @@ class OrPipe:</span>
<span class="w"> </span>        self._partner = None
<span class="w"> </span>        self._pipe = pipe

<span class="gi">+    def set(self):</span>
<span class="gi">+        if not self._set:</span>
<span class="gi">+            self._set = True</span>
<span class="gi">+            self._pipe.set()</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self):</span>
<span class="gi">+        if self._set:</span>
<span class="gi">+            self._set = False</span>
<span class="gi">+            if self._partner and not self._partner._set:</span>
<span class="gi">+                self._pipe.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def fileno(self):</span>
<span class="gi">+        return self._pipe.fileno()</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self._pipe.close()</span>
<span class="gi">+</span>

<span class="w"> </span>def make_or_pipe(pipe):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -53,4 +106,8 @@ def make_or_pipe(pipe):</span>
<span class="w"> </span>    affect the real pipe. if either returned pipe is set, the wrapped pipe
<span class="w"> </span>    is set. when both are cleared, the wrapped pipe is cleared.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a = OrPipe(pipe)</span>
<span class="gi">+    b = OrPipe(pipe)</span>
<span class="gi">+    a._partner = b</span>
<span class="gi">+    b._partner = a</span>
<span class="gi">+    return a, b</span>
<span class="gh">diff --git a/paramiko/pkey.py b/paramiko/pkey.py</span>
<span class="gh">index 69923124..eb34ac1d 100644</span>
<span class="gd">--- a/paramiko/pkey.py</span>
<span class="gi">+++ b/paramiko/pkey.py</span>
<span class="gu">@@ -74,7 +74,17 @@ class PKey:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        path = Path(path)</span>
<span class="gi">+        with path.open(&#39;rb&#39;) as f:</span>
<span class="gi">+            data = f.read()</span>
<span class="gi">+        </span>
<span class="gi">+        for cls in PKey.__subclasses__():</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls.from_private_key(data, passphrase)</span>
<span class="gi">+            except SSHException:</span>
<span class="gi">+                continue</span>
<span class="gi">+        </span>
<span class="gi">+        raise UnknownKeyType(key_bytes=data)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def from_type_string(key_type, key_bytes):
<span class="gu">@@ -98,7 +108,10 @@ class PKey:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cls in PKey.__subclasses__():</span>
<span class="gi">+            if key_type in cls.identifiers():</span>
<span class="gi">+                return cls(data=key_bytes)</span>
<span class="gi">+        raise UnknownKeyType(key_type=key_type, key_bytes=key_bytes)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def identifiers(cls):
<span class="gu">@@ -109,7 +122,7 @@ class PKey:</span>
<span class="w"> </span>        implementation suffices; see `.ECDSAKey` for one example of an
<span class="w"> </span>        override.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [cls.get_name()]</span>

<span class="w"> </span>    def __init__(self, msg=None, data=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -127,7 +140,17 @@ class PKey:</span>
<span class="w"> </span>            if a key cannot be created from the ``data`` or ``msg`` given, or
<span class="w"> </span>            no key was passed in.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._fields = ()</span>
<span class="gi">+        if msg is None and data is None:</span>
<span class="gi">+            raise SSHException(&quot;Key object may not be empty&quot;)</span>
<span class="gi">+        if msg is not None:</span>
<span class="gi">+            self._decode_key(msg)</span>
<span class="gi">+        elif data is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                msg = Message(data)</span>
<span class="gi">+                self._decode_key(msg)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                raise SSHException(f&quot;Invalid key: {str(e)}&quot;)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        comment = &#39;&#39;
<span class="gh">diff --git a/paramiko/primes.py b/paramiko/primes.py</span>
<span class="gh">index c0ded8f9..f87e3256 100644</span>
<span class="gd">--- a/paramiko/primes.py</span>
<span class="gi">+++ b/paramiko/primes.py</span>
<span class="gu">@@ -9,7 +9,7 @@ from paramiko.ssh_exception import SSHException</span>

<span class="w"> </span>def _roll_random(n):
<span class="w"> </span>    &quot;&quot;&quot;returns a random # from 0 to N-1&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return int.from_bytes(os.urandom(4), byteorder=&#39;big&#39;) % n</span>


<span class="w"> </span>class ModulusPack:
<span class="gu">@@ -26,4 +26,17 @@ class ModulusPack:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :raises IOError: passed from any file operations that fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &#39;r&#39;) as f:</span>
<span class="gi">+            for line in f:</span>
<span class="gi">+                line = line.strip()</span>
<span class="gi">+                if line and not line.startswith(&#39;#&#39;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        time, size, generator, modulus = line.split()</span>
<span class="gi">+                        size = int(size)</span>
<span class="gi">+                        generator = int(generator)</span>
<span class="gi">+                        modulus = int(modulus, 16)</span>
<span class="gi">+                        if size not in self.pack:</span>
<span class="gi">+                            self.pack[size] = []</span>
<span class="gi">+                        self.pack[size].append((generator, modulus))</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        self.discarded.append(line)</span>
<span class="gh">diff --git a/paramiko/proxy.py b/paramiko/proxy.py</span>
<span class="gh">index 2d1ebe34..851e5eab 100644</span>
<span class="gd">--- a/paramiko/proxy.py</span>
<span class="gi">+++ b/paramiko/proxy.py</span>
<span class="gu">@@ -47,7 +47,10 @@ class ProxyCommand(ClosingContextManager):</span>

<span class="w"> </span>        :param str content: string to be sent to the forked command
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.process.stdin.write(content)</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            return 0</span>

<span class="w"> </span>    def recv(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -57,4 +60,11 @@ class ProxyCommand(ClosingContextManager):</span>

<span class="w"> </span>        :return: the string of bytes read, which may be shorter than requested
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.timeout is not None:</span>
<span class="gi">+            rlist, wlist, xlist = select([self.process.stdout], [], [], self.timeout)</span>
<span class="gi">+            if len(rlist) == 0:</span>
<span class="gi">+                raise socket.timeout()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.process.stdout.read(size)</span>
<span class="gi">+        except IOError:</span>
<span class="gi">+            return b&#39;&#39;</span>
<span class="gh">diff --git a/paramiko/rsakey.py b/paramiko/rsakey.py</span>
<span class="gh">index 5e60a19c..00e213f5 100644</span>
<span class="gd">--- a/paramiko/rsakey.py</span>
<span class="gi">+++ b/paramiko/rsakey.py</span>
<span class="gu">@@ -54,4 +54,9 @@ class RSAKey(PKey):</span>
<span class="w"> </span>        :param progress_func: Unused
<span class="w"> </span>        :return: new `.RSAKey` private key
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key = rsa.generate_private_key(</span>
<span class="gi">+            public_exponent=65537,</span>
<span class="gi">+            key_size=bits,</span>
<span class="gi">+            backend=default_backend()</span>
<span class="gi">+        )</span>
<span class="gi">+        return RSAKey(key=private_key)</span>
<span class="gh">diff --git a/paramiko/server.py b/paramiko/server.py</span>
<span class="gh">index dc283021..404439b5 100644</span>
<span class="gd">--- a/paramiko/server.py</span>
<span class="gi">+++ b/paramiko/server.py</span>
<span class="gu">@@ -59,7 +59,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param int chanid: ID of the channel
<span class="w"> </span>        :return: an `int` success or failure code (listed above)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span>

<span class="w"> </span>    def get_allowed_auths(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,7 +76,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param str username: the username requesting authentication.
<span class="w"> </span>        :return: a comma-separated `str` of authentication types
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;password&quot;</span>

<span class="w"> </span>    def check_auth_none(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -95,7 +95,7 @@ class ServerInterface:</span>
<span class="w"> </span>            it succeeds.
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_password(self, username, password):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -120,7 +120,7 @@ class ServerInterface:</span>
<span class="w"> </span>            successful, but authentication must continue.
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_publickey(self, username, key):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -152,7 +152,7 @@ class ServerInterface:</span>
<span class="w"> </span>            authentication
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_interactive(self, username, submethods):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -177,7 +177,7 @@ class ServerInterface:</span>
<span class="w"> </span>            object containing queries for the user
<span class="w"> </span>        :rtype: int or `.InteractiveQuery`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_interactive_response(self, responses):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -208,7 +208,7 @@ class ServerInterface:</span>
<span class="w"> </span>            object containing queries for the user
<span class="w"> </span>        :rtype: int or `.InteractiveQuery`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED</span>

<span class="w"> </span>    def check_auth_gssapi_with_mic(self, username, gss_authenticated=
<span class="w"> </span>        AUTH_FAILED, cc_file=None):
<span class="gu">@@ -235,7 +235,7 @@ class ServerInterface:</span>
<span class="w"> </span>                 log in as a user.
<span class="w"> </span>        :see: http://www.unix.com/man-page/all/3/krb5_kuserok/
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED if gss_authenticated == AUTH_FAILED else AUTH_SUCCESSFUL</span>

<span class="w"> </span>    def check_auth_gssapi_keyex(self, username, gss_authenticated=
<span class="w"> </span>        AUTH_FAILED, cc_file=None):
<span class="gu">@@ -264,7 +264,7 @@ class ServerInterface:</span>
<span class="w"> </span>                 to log in as a user.
<span class="w"> </span>        :see: http://www.unix.com/man-page/all/3/krb5_kuserok/
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AUTH_FAILED if gss_authenticated == AUTH_FAILED else AUTH_SUCCESSFUL</span>

<span class="w"> </span>    def enable_auth_gssapi(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -275,7 +275,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :returns bool: Whether GSSAPI authentication is enabled.
<span class="w"> </span>        :see: `.ssh_gss`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_port_forward_request(self, address, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -296,7 +296,7 @@ class ServerInterface:</span>
<span class="w"> </span>            the port number (`int`) that was opened for listening, or ``False``
<span class="w"> </span>            to reject
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def cancel_port_forward_request(self, address, port):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -307,6 +307,8 @@ class ServerInterface:</span>
<span class="w"> </span>        :param str address: the forwarded address
<span class="w"> </span>        :param int port: the forwarded port
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # This method is a no-op in the default implementation</span>
<span class="gi">+        # as port forwarding is not supported by default</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def check_global_request(self, kind, msg):
<span class="gu">@@ -337,7 +339,7 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` or a `tuple` of data if the request was granted; ``False``
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_pty_request(self, channel, term, width, height,
<span class="w"> </span>        pixelwidth, pixelheight, modes):
<span class="gu">@@ -359,7 +361,7 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if the pseudo-terminal has been allocated; ``False``
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_shell_request(self, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -375,7 +377,7 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if this channel is now hooked up to a shell; ``False`` if
<span class="w"> </span>            a shell can&#39;t or won&#39;t be provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_exec_request(self, channel, command):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -394,7 +396,7 @@ class ServerInterface:</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_subsystem_request(self, channel, name):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -418,7 +420,11 @@ class ServerInterface:</span>
<span class="w"> </span>            ``True`` if this channel is now hooked up to the requested
<span class="w"> </span>            subsystem; ``False`` if that subsystem can&#39;t or won&#39;t be provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handler = channel.get_transport()._get_subsystem_handler(name)</span>
<span class="gi">+        if handler is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        handler(channel)</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def check_channel_window_change_request(self, channel, width, height,
<span class="w"> </span>        pixelwidth, pixelheight):
<span class="gu">@@ -437,7 +443,7 @@ class ServerInterface:</span>
<span class="w"> </span>            height of screen in pixels, if known (may be ``0`` if unknown).
<span class="w"> </span>        :return: ``True`` if the terminal was resized; ``False`` if not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_x11_request(self, channel, single_connection,
<span class="w"> </span>        auth_protocol, auth_cookie, screen_number):
<span class="gu">@@ -457,7 +463,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param int screen_number: the number of the X11 screen to connect to
<span class="w"> </span>        :return: ``True`` if the X11 session was opened; ``False`` if not
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_forward_agent_request(self, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -473,7 +479,7 @@ class ServerInterface:</span>
<span class="w"> </span>        If ``True`` is returned, the server should create an
<span class="w"> </span>        :class:`AgentServerProxy` to access the agent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def check_channel_direct_tcpip_request(self, chanid, origin, destination):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -513,7 +519,7 @@ class ServerInterface:</span>
<span class="w"> </span>            (server side)
<span class="w"> </span>        :return: an `int` success or failure code (listed above)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span>

<span class="w"> </span>    def check_channel_env_request(self, channel, name, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -531,7 +537,7 @@ class ServerInterface:</span>
<span class="w"> </span>        :param str value: Channel value
<span class="w"> </span>        :returns: A boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def get_banner(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -545,7 +551,7 @@ class ServerInterface:</span>

<span class="w"> </span>        .. versionadded:: 2.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (None, None)</span>


<span class="w"> </span>class InteractiveQuery:
<span class="gu">@@ -584,7 +590,7 @@ class InteractiveQuery:</span>
<span class="w"> </span>            ``True`` (default) if the user&#39;s response should be echoed;
<span class="w"> </span>            ``False`` if not (for a password or similar)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.prompts.append((prompt, echo))</span>


<span class="w"> </span>class SubsystemHandler(threading.Thread):
<span class="gu">@@ -627,7 +633,7 @@ class SubsystemHandler(threading.Thread):</span>
<span class="w"> </span>        Return the `.ServerInterface` object associated with this channel and
<span class="w"> </span>        subsystem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__server</span>

<span class="w"> </span>    def start_subsystem(self, name, transport, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -653,7 +659,16 @@ class SubsystemHandler(threading.Thread):</span>
<span class="w"> </span>        :param .Channel channel: the channel associated with this subsystem
<span class="w"> </span>            request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a placeholder implementation. In a real scenario,</span>
<span class="gi">+        # you would implement the subsystem logic here.</span>
<span class="gi">+        while transport.is_active() and not channel.closed:</span>
<span class="gi">+            # Implement subsystem logic here</span>
<span class="gi">+            # For example, you might read from the channel:</span>
<span class="gi">+            # data = channel.recv(1024)</span>
<span class="gi">+            # process the data</span>
<span class="gi">+            # and possibly send a response:</span>
<span class="gi">+            # channel.send(response)</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def finish_subsystem(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -662,4 +677,4 @@ class SubsystemHandler(threading.Thread):</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__channel.close()</span>
<span class="gh">diff --git a/paramiko/sftp.py b/paramiko/sftp.py</span>
<span class="gh">index 65109f59..79ae6c31 100644</span>
<span class="gd">--- a/paramiko/sftp.py</span>
<span class="gi">+++ b/paramiko/sftp.py</span>
<span class="gu">@@ -49,3 +49,71 @@ class BaseSFTP:</span>
<span class="w"> </span>        self.logger = util.get_logger(&#39;paramiko.sftp&#39;)
<span class="w"> </span>        self.sock = None
<span class="w"> </span>        self.ultra_debug = False
<span class="gi">+        self.packetizer = None</span>
<span class="gi">+        self.request_number = 1</span>
<span class="gi">+        self.timeout = None</span>
<span class="gi">+</span>
<span class="gi">+    def _send_packet(self, t, packet):</span>
<span class="gi">+        &quot;&quot;&quot;Send a packet to the SFTP server.&quot;&quot;&quot;</span>
<span class="gi">+        self.packetizer.send_packet(t, packet)</span>
<span class="gi">+</span>
<span class="gi">+    def _read_packet(self):</span>
<span class="gi">+        &quot;&quot;&quot;Read a packet from the SFTP server.&quot;&quot;&quot;</span>
<span class="gi">+        t, data = self.packetizer.read_packet()</span>
<span class="gi">+        return t, data</span>
<span class="gi">+</span>
<span class="gi">+    def _request(self, t, msg):</span>
<span class="gi">+        &quot;&quot;&quot;Send a request and wait for a response.&quot;&quot;&quot;</span>
<span class="gi">+        self._send_packet(t, msg)</span>
<span class="gi">+        return self._read_response()</span>
<span class="gi">+</span>
<span class="gi">+    def _read_response(self):</span>
<span class="gi">+        &quot;&quot;&quot;Read and process a response from the server.&quot;&quot;&quot;</span>
<span class="gi">+        t, data = self._read_packet()</span>
<span class="gi">+        msg = Message(data)</span>
<span class="gi">+        num = msg.get_int()</span>
<span class="gi">+        if num not in (CMD_STATUS, CMD_HANDLE, CMD_DATA, CMD_NAME, CMD_ATTRS):</span>
<span class="gi">+            raise SFTPError(f&quot;Unexpected response type: {num}&quot;)</span>
<span class="gi">+        return num, msg</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_status(self, msg):</span>
<span class="gi">+        &quot;&quot;&quot;Convert a status response to an exception if needed.&quot;&quot;&quot;</span>
<span class="gi">+        code = msg.get_int()</span>
<span class="gi">+        text = msg.get_string()</span>
<span class="gi">+        if code != SFTP_OK:</span>
<span class="gi">+            raise SFTPError(f&quot;SFTP error {code}: {text}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_channel(self):</span>
<span class="gi">+        &quot;&quot;&quot;Return the channel object associated with this SFTP session.&quot;&quot;&quot;</span>
<span class="gi">+        return self.sock.get_transport().open_session()</span>
<span class="gi">+</span>
<span class="gi">+    def from_transport(cls, t, window_size=None, max_packet_size=None):</span>
<span class="gi">+        &quot;&quot;&quot;Create an SFTP client from an existing `.Transport`.&quot;&quot;&quot;</span>
<span class="gi">+        chan = t.open_session()</span>
<span class="gi">+        if window_size is not None:</span>
<span class="gi">+            chan.window_size = window_size</span>
<span class="gi">+        if max_packet_size is not None:</span>
<span class="gi">+            chan.max_packet_size = max_packet_size</span>
<span class="gi">+        chan.invoke_subsystem(&#39;sftp&#39;)</span>
<span class="gi">+        return cls(chan)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        &quot;&quot;&quot;Close the SFTP session and its underlying channel.&quot;&quot;&quot;</span>
<span class="gi">+        if self.sock is not None:</span>
<span class="gi">+            self.sock.close()</span>
<span class="gi">+            self.sock = None</span>
<span class="gi">+</span>
<span class="gi">+    def get_exception(self, code):</span>
<span class="gi">+        &quot;&quot;&quot;Convert an error code to an exception.&quot;&quot;&quot;</span>
<span class="gi">+        if code == SFTP_EOF:</span>
<span class="gi">+            return EOFError()</span>
<span class="gi">+        elif code == SFTP_NO_SUCH_FILE:</span>
<span class="gi">+            return IOError(SFTP_NO_SUCH_FILE, &#39;No such file&#39;)</span>
<span class="gi">+        elif code == SFTP_PERMISSION_DENIED:</span>
<span class="gi">+            return PermissionError(&#39;Permission denied&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SFTPError(f&#39;Error code {code}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __del__(self):</span>
<span class="gi">+        &quot;&quot;&quot;Ensure the SFTP session is closed when the object is deleted.&quot;&quot;&quot;</span>
<span class="gi">+        self.close()</span>
<span class="gh">diff --git a/paramiko/sftp_attr.py b/paramiko/sftp_attr.py</span>
<span class="gh">index 0745a134..3149babd 100644</span>
<span class="gd">--- a/paramiko/sftp_attr.py</span>
<span class="gi">+++ b/paramiko/sftp_attr.py</span>
<span class="gu">@@ -50,7 +50,18 @@ class SFTPAttributes:</span>
<span class="w"> </span>        :param str filename: the filename associated with this file.
<span class="w"> </span>        :return: new `.SFTPAttributes` object with the same attribute fields.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attr = cls()</span>
<span class="gi">+        attr.st_size = obj.st_size</span>
<span class="gi">+        attr.st_uid = obj.st_uid</span>
<span class="gi">+        attr.st_gid = obj.st_gid</span>
<span class="gi">+        attr.st_mode = obj.st_mode</span>
<span class="gi">+        attr.st_atime = int(obj.st_atime)</span>
<span class="gi">+        attr.st_mtime = int(obj.st_mtime)</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            attr.filename = filename</span>
<span class="gi">+        attr._flags = (attr.FLAG_SIZE | attr.FLAG_UIDGID | </span>
<span class="gi">+                       attr.FLAG_PERMISSIONS | attr.FLAG_AMTIME)</span>
<span class="gi">+        return attr</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;SFTPAttributes: {}&gt;&#39;.format(self._debug_str())
<span class="gh">diff --git a/paramiko/sftp_client.py b/paramiko/sftp_client.py</span>
<span class="gh">index 24ff487a..7a042294 100644</span>
<span class="gd">--- a/paramiko/sftp_client.py</span>
<span class="gi">+++ b/paramiko/sftp_client.py</span>
<span class="gu">@@ -22,7 +22,15 @@ def _to_unicode(s):</span>
<span class="w"> </span>    protocol).  if neither works, just return a byte string because the server
<span class="w"> </span>    probably doesn&#39;t know the filename&#39;s encoding.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, str):</span>
<span class="gi">+        return s</span>
<span class="gi">+    try:</span>
<span class="gi">+        return s.decode(&#39;ascii&#39;)</span>
<span class="gi">+    except UnicodeDecodeError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return s.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            return s</span>


<span class="w"> </span>b_slash = b&#39;/&#39;
<span class="gu">@@ -94,7 +102,11 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>
<span class="w"> </span>        .. versionchanged:: 1.15
<span class="w"> </span>            Added the ``window_size`` and ``max_packet_size`` arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        chan = t.open_session(window_size=window_size, max_packet_size=max_packet_size)</span>
<span class="gi">+        if chan is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        chan.invoke_subsystem(&#39;sftp&#39;)</span>
<span class="gi">+        return cls(chan)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -102,7 +114,8 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sock.close()</span>
<span class="gi">+        self.sock = None</span>

<span class="w"> </span>    def get_channel(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,7 +124,7 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.7.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock</span>

<span class="w"> </span>    def listdir(self, path=&#39;.&#39;):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -125,7 +138,7 @@ class SFTPClient(BaseSFTP, ClosingContextManager):</span>

<span class="w"> </span>        :param str path: path to list (defaults to ``&#39;.&#39;``)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [attr.filename for attr in self.listdir_attr(path)]</span>

<span class="w"> </span>    def listdir_attr(self, path=&#39;.&#39;):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/sftp_file.py b/paramiko/sftp_file.py</span>
<span class="gh">index e4ca900d..a42d7e2b 100644</span>
<span class="gd">--- a/paramiko/sftp_file.py</span>
<span class="gi">+++ b/paramiko/sftp_file.py</span>
<span class="gu">@@ -43,7 +43,7 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Close the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close()</span>

<span class="w"> </span>    def _data_in_prefetch_buffers(self, offset):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -52,14 +52,28 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        return None.  this guarantees nothing about the number of bytes
<span class="w"> </span>        collected in the prefetch buffer so far.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._prefetch_lock:</span>
<span class="gi">+            for file_offset, buf in self._prefetch_data.items():</span>
<span class="gi">+                if file_offset &lt;= offset &lt; file_offset + len(buf):</span>
<span class="gi">+                    return file_offset</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _read_prefetch(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        read data out of the prefetch buffer, if possible.  if the data isn&#39;t
<span class="w"> </span>        in the buffer, return None.  otherwise, behaves like a normal read.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._prefetch_lock:</span>
<span class="gi">+            offset = self._data_in_prefetch_buffers(self._realpos)</span>
<span class="gi">+            if offset is None:</span>
<span class="gi">+                return None</span>
<span class="gi">+            prefetch_data = self._prefetch_data[offset]</span>
<span class="gi">+            prefetch_size = len(prefetch_data)</span>
<span class="gi">+            if size &gt; prefetch_size - (self._realpos - offset):</span>
<span class="gi">+                size = prefetch_size - (self._realpos - offset)</span>
<span class="gi">+            data = prefetch_data[self._realpos - offset : self._realpos - offset + size]</span>
<span class="gi">+            self._realpos += size</span>
<span class="gi">+            return data</span>

<span class="w"> </span>    def settimeout(self, timeout):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -72,7 +86,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.settimeout`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp.sock.settimeout(timeout)</span>

<span class="w"> </span>    def gettimeout(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -81,7 +95,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.gettimeout`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sftp.sock.gettimeout()</span>

<span class="w"> </span>    def setblocking(self, blocking):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -93,7 +107,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. seealso:: `.Channel.setblocking`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sftp.sock.setblocking(blocking)</span>

<span class="w"> </span>    def seekable(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -103,7 +117,7 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>            `True` if the file supports random access. If `False`,
<span class="w"> </span>            :meth:`seek` will raise an exception
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def seek(self, offset, whence=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -111,7 +125,16 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        See `file.seek` for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_exception()</span>
<span class="gi">+        if whence == self.SEEK_SET:</span>
<span class="gi">+            self._realpos = offset</span>
<span class="gi">+        elif whence == self.SEEK_CUR:</span>
<span class="gi">+            self._realpos += offset</span>
<span class="gi">+        elif whence == self.SEEK_END:</span>
<span class="gi">+            self._realpos = self._get_size() + offset</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise IOError(&#39;Invalid whence&#39;)</span>
<span class="gi">+        return self._realpos</span>

<span class="w"> </span>    def stat(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -122,7 +145,10 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        :returns:
<span class="w"> </span>            an `.SFTPAttributes` object containing attributes about this file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        t, msg = self.sftp._request(CMD_FSTAT, self.handle)</span>
<span class="gi">+        if t != CMD_ATTRS:</span>
<span class="gi">+            raise SFTPError(&#39;Expected attributes&#39;)</span>
<span class="gi">+        return SFTPAttributes._from_msg(msg)</span>

<span class="w"> </span>    def chmod(self, mode):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -132,7 +158,9 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        :param int mode: new permissions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_mode = mode</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle + attr._pack())</span>

<span class="w"> </span>    def chown(self, uid, gid):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,7 +172,10 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        :param int uid: new owner&#39;s uid
<span class="w"> </span>        :param int gid: new group id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_uid = uid</span>
<span class="gi">+        attr.st_gid = gid</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle + attr._pack())</span>

<span class="w"> </span>    def utime(self, times):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -159,7 +190,12 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>            ``None`` or a tuple of (access time, modified time) in standard
<span class="w"> </span>            internet epoch time (seconds since 01 January 1970 GMT)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if times is None:</span>
<span class="gi">+            times = (time.time(), time.time())</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_atime = int(times[0])</span>
<span class="gi">+        attr.st_mtime = int(times[1])</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle + attr._pack())</span>

<span class="w"> </span>    def truncate(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -169,7 +205,9 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        :param size: the new size of the file
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attr = SFTPAttributes()</span>
<span class="gi">+        attr.st_size = size</span>
<span class="gi">+        self.sftp._request(CMD_FSETSTAT, self.handle + attr._pack())</span>

<span class="w"> </span>    def check(self, hash_algorithm, offset=0, length=0, block_size=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -217,7 +255,15 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        t, msg = self.sftp._request(CMD_EXTENDED, &#39;check-file&#39;,</span>
<span class="gi">+                                    self.handle,</span>
<span class="gi">+                                    hash_algorithm,</span>
<span class="gi">+                                    long(offset),</span>
<span class="gi">+                                    long(length),</span>
<span class="gi">+                                    int(block_size))</span>
<span class="gi">+        if t != CMD_EXTENDED_REPLY:</span>
<span class="gi">+            raise SFTPError(&#39;Expected extended reply&#39;)</span>
<span class="gi">+        return msg.get_string()</span>

<span class="w"> </span>    def set_pipelined(self, pipelined=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -237,7 +283,7 @@ class SFTPFile(BufferedFile):</span>

<span class="w"> </span>        .. versionadded:: 1.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pipelined = pipelined</span>

<span class="w"> </span>    def prefetch(self, file_size=None, max_concurrent_requests=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -272,7 +318,18 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._prefetching:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._prefetching = True</span>
<span class="gi">+        if file_size is None:</span>
<span class="gi">+            file_size = self.stat().st_size</span>
<span class="gi">+        if max_concurrent_requests is None:</span>
<span class="gi">+            max_concurrent_requests = 10</span>
<span class="gi">+        self._prefetch_thread = threading.Thread(</span>
<span class="gi">+            target=self._prefetch_thread_func,</span>
<span class="gi">+            args=(file_size, max_concurrent_requests),</span>
<span class="gi">+        )</span>
<span class="gi">+        self._prefetch_thread.start()</span>

<span class="w"> </span>    def readv(self, chunks, max_concurrent_prefetch_requests=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -294,7 +351,18 @@ class SFTPFile(BufferedFile):</span>
<span class="w"> </span>        .. versionchanged:: 3.3
<span class="w"> </span>            Added ``max_concurrent_prefetch_requests``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if max_concurrent_prefetch_requests is None:</span>
<span class="gi">+            max_concurrent_prefetch_requests = 10</span>
<span class="gi">+</span>
<span class="gi">+        results = []</span>
<span class="gi">+        for offset, length in chunks:</span>
<span class="gi">+            data = self._read_prefetch(length)</span>
<span class="gi">+            if data is None:</span>
<span class="gi">+                self.seek(offset)</span>
<span class="gi">+                data = self.read(length)</span>
<span class="gi">+            results.append(data)</span>
<span class="gi">+</span>
<span class="gi">+        return results</span>

<span class="w"> </span>    def _check_exception(self):
<span class="w"> </span>        &quot;&quot;&quot;if there&#39;s a saved exception, raise &amp; clear it&quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/sftp_handle.py b/paramiko/sftp_handle.py</span>
<span class="gh">index 5b9d4a8b..445da9e0 100644</span>
<span class="gd">--- a/paramiko/sftp_handle.py</span>
<span class="gi">+++ b/paramiko/sftp_handle.py</span>
<span class="gu">@@ -44,7 +44,10 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        using the default implementations of `read` and `write`, this
<span class="w"> </span>        method&#39;s default implementation should be fine also.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;readfile&#39;):</span>
<span class="gi">+            self.readfile.close()</span>
<span class="gi">+        if hasattr(self, &#39;writefile&#39;):</span>
<span class="gi">+            self.writefile.close()</span>

<span class="w"> </span>    def read(self, offset, length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -64,7 +67,10 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param int length: number of bytes to attempt to read.
<span class="w"> </span>        :return: the `bytes` read, or an error code `int`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;readfile&#39;):</span>
<span class="gi">+            self.readfile.seek(offset)</span>
<span class="gi">+            return self.readfile.read(length)</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def write(self, offset, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +90,11 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param bytes data: data to write into the file.
<span class="w"> </span>        :return: an SFTP error code like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;writefile&#39;):</span>
<span class="gi">+            self.writefile.seek(offset)</span>
<span class="gi">+            self.writefile.write(data)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def stat(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -97,7 +107,10 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>            (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        :rtype: `.SFTPAttributes` or error code
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;readfile&#39;) or hasattr(self, &#39;writefile&#39;):</span>
<span class="gi">+            file_obj = getattr(self, &#39;readfile&#39;, None) or getattr(self, &#39;writefile&#39;, None)</span>
<span class="gi">+            return SFTPServer.stat_file(file_obj)</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def chattr(self, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,7 +121,19 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        :param .SFTPAttributes attr: the attributes to change on this file.
<span class="w"> </span>        :return: an `int` error code like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &#39;readfile&#39;) or hasattr(self, &#39;writefile&#39;):</span>
<span class="gi">+            file_obj = getattr(self, &#39;readfile&#39;, None) or getattr(self, &#39;writefile&#39;, None)</span>
<span class="gi">+            try:</span>
<span class="gi">+                if attr.st_mode is not None:</span>
<span class="gi">+                    os.chmod(file_obj.name, attr.st_mode)</span>
<span class="gi">+                if attr.st_uid is not None or attr.st_gid is not None:</span>
<span class="gi">+                    os.chown(file_obj.name, attr.st_uid, attr.st_gid)</span>
<span class="gi">+                if attr.st_atime is not None or attr.st_mtime is not None:</span>
<span class="gi">+                    os.utime(file_obj.name, (attr.st_atime or 0, attr.st_mtime or 0))</span>
<span class="gi">+                return SFTP_OK</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return SFTP_OP_UNSUPPORTED</span>
<span class="gi">+        return SFTP_OP_UNSUPPORTED</span>

<span class="w"> </span>    def _set_files(self, files):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -116,14 +141,19 @@ class SFTPHandle(ClosingContextManager):</span>
<span class="w"> </span>        the SFTP protocol, listing a directory is a multi-stage process
<span class="w"> </span>        requiring a temporary handle.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__files = files</span>
<span class="gi">+        self.__tell = 0</span>

<span class="w"> </span>    def _get_next_files(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Used by the SFTP server code to retrieve a cached directory
<span class="w"> </span>        listing.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.__tell &lt; len(self.__files):</span>
<span class="gi">+            files = self.__files[self.__tell:self.__tell + 100]</span>
<span class="gi">+            self.__tell += len(files)</span>
<span class="gi">+            return files</span>
<span class="gi">+        return []</span>


<span class="w"> </span>from paramiko.sftp_server import SFTPServer
<span class="gh">diff --git a/paramiko/sftp_server.py b/paramiko/sftp_server.py</span>
<span class="gh">index 2ffa92dd..33c4a19f 100644</span>
<span class="gd">--- a/paramiko/sftp_server.py</span>
<span class="gi">+++ b/paramiko/sftp_server.py</span>
<span class="gu">@@ -59,7 +59,12 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>        :param int e: an errno code, as from ``OSError.errno``.
<span class="w"> </span>        :return: an `int` SFTP error code like ``SFTP_NO_SUCH_FILE``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if e == errno.EACCES:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        elif e == errno.ENOENT:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        else:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def set_file_attr(filename, attr):
<span class="gu">@@ -76,11 +81,29 @@ class SFTPServer(BaseSFTP, SubsystemHandler):</span>
<span class="w"> </span>            name of the file to alter (should usually be an absolute path).
<span class="w"> </span>        :param .SFTPAttributes attr: attributes to change.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if attr._flags &amp; attr.FLAG_PERMISSIONS:</span>
<span class="gi">+            os.chmod(filename, attr.st_mode)</span>
<span class="gi">+        if attr._flags &amp; attr.FLAG_UIDGID:</span>
<span class="gi">+            os.chown(filename, attr.st_uid, attr.st_gid)</span>
<span class="gi">+        if attr._flags &amp; attr.FLAG_AMTIME:</span>
<span class="gi">+            os.utime(filename, (attr.st_atime, attr.st_mtime))</span>

<span class="w"> </span>    def _convert_pflags(self, pflags):
<span class="w"> </span>        &quot;&quot;&quot;convert SFTP-style open() flags to Python&#39;s os.open() flags&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        flags = 0</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_READ:</span>
<span class="gi">+            flags |= os.O_RDONLY</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_WRITE:</span>
<span class="gi">+            flags |= os.O_WRONLY</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_APPEND:</span>
<span class="gi">+            flags |= os.O_APPEND</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_CREATE:</span>
<span class="gi">+            flags |= os.O_CREAT</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_TRUNC:</span>
<span class="gi">+            flags |= os.O_TRUNC</span>
<span class="gi">+        if pflags &amp; SFTP_FLAG_EXCL:</span>
<span class="gi">+            flags |= os.O_EXCL</span>
<span class="gi">+        return flags</span>


<span class="w"> </span>from paramiko.sftp_handle import SFTPHandle
<span class="gh">diff --git a/paramiko/sftp_si.py b/paramiko/sftp_si.py</span>
<span class="gh">index e0b4e643..e3973523 100644</span>
<span class="gd">--- a/paramiko/sftp_si.py</span>
<span class="gi">+++ b/paramiko/sftp_si.py</span>
<span class="gu">@@ -3,7 +3,9 @@ An interface to override for SFTP server support.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gd">-from paramiko.sftp import SFTP_OP_UNSUPPORTED</span>
<span class="gi">+from paramiko.sftp import SFTP_OP_UNSUPPORTED, SFTP_OK, SFTP_PERMISSION_DENIED, SFTP_NO_SUCH_FILE, SFTP_FAILURE</span>
<span class="gi">+from paramiko.sftp_attr import SFTPAttributes</span>
<span class="gi">+from paramiko.sftp_handle import SFTPHandle</span>


<span class="w"> </span>class SFTPServerInterface:
<span class="gu">@@ -37,6 +39,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        overridden to perform any necessary setup before handling callbacks
<span class="w"> </span>        from SFTP operations.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # This method can be left as is if no specific setup is required</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def session_ended(self):
<span class="gu">@@ -46,6 +49,7 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        necessary cleanup before this `.SFTPServerInterface` object is
<span class="w"> </span>        destroyed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # This method can be left as is if no specific cleanup is required</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def open(self, path, flags, attr):
<span class="gu">@@ -86,7 +90,23 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            requested attributes of the file if it is newly created.
<span class="w"> </span>        :return: a new `.SFTPHandle` or error code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            mode = &#39;r&#39;</span>
<span class="gi">+            if flags &amp; os.O_WRONLY:</span>
<span class="gi">+                mode = &#39;w&#39;</span>
<span class="gi">+            elif flags &amp; os.O_RDWR:</span>
<span class="gi">+                mode = &#39;r+&#39;</span>
<span class="gi">+            if flags &amp; os.O_APPEND:</span>
<span class="gi">+                mode += &#39;a&#39;</span>
<span class="gi">+            if flags &amp; os.O_CREAT:</span>
<span class="gi">+                mode += &#39;+&#39;</span>
<span class="gi">+</span>
<span class="gi">+            file_obj = open(path, mode)</span>
<span class="gi">+            return SFTPHandle(file_obj)</span>
<span class="gi">+        except IOError as e:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def list_folder(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -118,7 +138,22 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            direct translation from the SFTP server path to your local
<span class="w"> </span>            filesystem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            if not os.path.isdir(normalized_path):</span>
<span class="gi">+                return SFTP_NO_SUCH_FILE</span>
<span class="gi">+            </span>
<span class="gi">+            file_list = []</span>
<span class="gi">+            for filename in os.listdir(normalized_path):</span>
<span class="gi">+                filepath = os.path.join(normalized_path, filename)</span>
<span class="gi">+                attr = SFTPAttributes.from_stat(os.stat(filepath))</span>
<span class="gi">+                attr.filename = filename</span>
<span class="gi">+                file_list.append(attr)</span>
<span class="gi">+            return file_list</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def stat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -134,7 +169,15 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            an `.SFTPAttributes` object for the given file, or an SFTP error
<span class="w"> </span>            code (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            return SFTPAttributes.from_stat(os.stat(normalized_path))</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def lstat(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -152,7 +195,15 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            an `.SFTPAttributes` object for the given file, or an SFTP error
<span class="w"> </span>            code (like ``SFTP_PERMISSION_DENIED``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            return SFTPAttributes.from_stat(os.lstat(normalized_path))</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def remove(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -162,7 +213,18 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            the requested path (relative or absolute) of the file to delete.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            os.remove(normalized_path)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except IsADirectoryError:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def rename(self, oldpath, newpath):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -186,7 +248,21 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        :param str newpath: the requested new path of the file.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_oldpath = os.path.normpath(os.path.join(&#39;/&#39;, oldpath))</span>
<span class="gi">+            normalized_newpath = os.path.normpath(os.path.join(&#39;/&#39;, newpath))</span>
<span class="gi">+            </span>
<span class="gi">+            if os.path.exists(normalized_newpath):</span>
<span class="gi">+                return SFTP_FAILURE</span>
<span class="gi">+            </span>
<span class="gi">+            os.rename(normalized_oldpath, normalized_newpath)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def posix_rename(self, oldpath, newpath):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -200,7 +276,18 @@ class SFTPServerInterface:</span>

<span class="w"> </span>        :versionadded: 2.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_oldpath = os.path.normpath(os.path.join(&#39;/&#39;, oldpath))</span>
<span class="gi">+            normalized_newpath = os.path.normpath(os.path.join(&#39;/&#39;, newpath))</span>
<span class="gi">+            </span>
<span class="gi">+            os.replace(normalized_oldpath, normalized_newpath)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def mkdir(self, path, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -217,7 +304,20 @@ class SFTPServerInterface:</span>
<span class="w"> </span>        :param .SFTPAttributes attr: requested attributes of the new folder.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            os.mkdir(normalized_path)</span>
<span class="gi">+            </span>
<span class="gi">+            if hasattr(attr, &#39;st_mode&#39;):</span>
<span class="gi">+                os.chmod(normalized_path, attr.st_mode)</span>
<span class="gi">+            </span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def rmdir(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -229,7 +329,18 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            requested path (relative or absolute) of the folder to remove.
<span class="w"> </span>        :return: an SFTP error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            os.rmdir(normalized_path)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def chattr(self, path, attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -244,7 +355,25 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            object)
<span class="w"> </span>        :return: an error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            </span>
<span class="gi">+            if hasattr(attr, &#39;st_mode&#39;):</span>
<span class="gi">+                os.chmod(normalized_path, attr.st_mode)</span>
<span class="gi">+            </span>
<span class="gi">+            if hasattr(attr, &#39;st_uid&#39;) and hasattr(attr, &#39;st_gid&#39;):</span>
<span class="gi">+                os.chown(normalized_path, attr.st_uid, attr.st_gid)</span>
<span class="gi">+            </span>
<span class="gi">+            if hasattr(attr, &#39;st_atime&#39;) and hasattr(attr, &#39;st_mtime&#39;):</span>
<span class="gi">+                os.utime(normalized_path, (attr.st_atime, attr.st_mtime))</span>
<span class="gi">+            </span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def canonicalize(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -260,7 +389,7 @@ class SFTPServerInterface:</span>

<span class="w"> </span>        The default implementation returns ``os.path.normpath(&#39;/&#39; + path)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.normpath(&#39;/&#39; + path)</span>

<span class="w"> </span>    def readlink(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -273,7 +402,15 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            the target `str` path of the symbolic link, or an error code like
<span class="w"> </span>            ``SFTP_NO_SUCH_FILE``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            return os.readlink(normalized_path)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return SFTP_NO_SUCH_FILE</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>

<span class="w"> </span>    def symlink(self, target_path, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -287,4 +424,14 @@ class SFTPServerInterface:</span>
<span class="w"> </span>            path (relative or absolute) of the symbolic link to create.
<span class="w"> </span>        :return: an error code `int` like ``SFTP_OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            normalized_target_path = os.path.normpath(os.path.join(&#39;/&#39;, target_path))</span>
<span class="gi">+            normalized_path = os.path.normpath(os.path.join(&#39;/&#39;, path))</span>
<span class="gi">+            os.symlink(normalized_target_path, normalized_path)</span>
<span class="gi">+            return SFTP_OK</span>
<span class="gi">+        except FileExistsError:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gi">+        except PermissionError:</span>
<span class="gi">+            return SFTP_PERMISSION_DENIED</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return SFTP_FAILURE</span>
<span class="gh">diff --git a/paramiko/ssh_gss.py b/paramiko/ssh_gss.py</span>
<span class="gh">index 5956a062..7e7187ff 100644</span>
<span class="gd">--- a/paramiko/ssh_gss.py</span>
<span class="gi">+++ b/paramiko/ssh_gss.py</span>
<span class="gu">@@ -59,7 +59,17 @@ def GSSAuth(auth_method, gss_deleg_creds=True):</span>
<span class="w"> </span>           If there is no supported API available,
<span class="w"> </span>           ``None`` will be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not GSS_AUTH_AVAILABLE:</span>
<span class="gi">+        raise ImportError(&quot;No GSS-API / SSPI module could be imported.&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if _API == &#39;MIT&#39;:</span>
<span class="gi">+        return _SSH_GSSAPI_OLD(auth_method, gss_deleg_creds)</span>
<span class="gi">+    elif _API == &#39;PYTHON-GSSAPI-NEW&#39;:</span>
<span class="gi">+        return _SSH_GSSAPI_NEW(auth_method, gss_deleg_creds)</span>
<span class="gi">+    elif _API == &#39;SSPI&#39;:</span>
<span class="gi">+        return _SSH_SSPI(auth_method, gss_deleg_creds)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class _SSH_GSSAuth:
<span class="gu">@@ -99,7 +109,7 @@ class _SSH_GSSAuth:</span>

<span class="w"> </span>        :param str service: The desired SSH service
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._service = service</span>

<span class="w"> </span>    def set_username(self, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -108,7 +118,7 @@ class _SSH_GSSAuth:</span>

<span class="w"> </span>        :param str username: The name of the user who attempts to login
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._username = username</span>

<span class="w"> </span>    def ssh_gss_oids(self, mode=&#39;client&#39;):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -122,7 +132,11 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :note: In server mode we just return the OID length and the DER encoded
<span class="w"> </span>               OID.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        OID = b&#39;\x06\x09\x2a\x86\x48\x86\xf7\x12\x01\x02\x02&#39;</span>
<span class="gi">+        if mode == &#39;client&#39;:</span>
<span class="gi">+            return struct.pack(&#39;!I&#39;, 1) + struct.pack(&#39;!I&#39;, len(OID)) + OID</span>
<span class="gi">+        elif mode == &#39;server&#39;:</span>
<span class="gi">+            return struct.pack(&#39;!I&#39;, len(OID)) + OID</span>

<span class="w"> </span>    def ssh_check_mech(self, desired_mech):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -131,7 +145,7 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :param str desired_mech: The desired GSS-API mechanism of the client
<span class="w"> </span>        :return: ``True`` if the given OID is supported, otherwise C{False}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return desired_mech == self._krb5_mech</span>

<span class="w"> </span>    def _make_uint32(self, integer):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -140,7 +154,7 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>        :param int integer: The integer value to convert
<span class="w"> </span>        :return: The byte sequence of an 32 bit integer
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return struct.pack(&#39;!I&#39;, integer)</span>

<span class="w"> </span>    def _ssh_build_mic(self, session_id, username, service, auth_method):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -159,7 +173,12 @@ class _SSH_GSSAuth:</span>
<span class="w"> </span>                 string    authentication-method
<span class="w"> </span>                           (gssapi-with-mic or gssapi-keyex)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mic = self._make_uint32(len(session_id)) + session_id</span>
<span class="gi">+        mic += struct.pack(&#39;B&#39;, MSG_USERAUTH_REQUEST)</span>
<span class="gi">+        mic += self._make_uint32(len(username)) + username.encode()</span>
<span class="gi">+        mic += self._make_uint32(len(service)) + service.encode()</span>
<span class="gi">+        mic += self._make_uint32(len(auth_method)) + auth_method.encode()</span>
<span class="gi">+        return mic</span>


<span class="w"> </span>class _SSH_GSSAPI_OLD(_SSH_GSSAuth):
<span class="gu">@@ -201,7 +220,24 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or
<span class="w"> </span>            ``None`` if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if desired_mech is not None and desired_mech != self._krb5_mech:</span>
<span class="gi">+            raise SSHException(&quot;Unsupported GSS-API mechanism requested.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._gss_ctxt is None:</span>
<span class="gi">+            self._gss_ctxt = gssapi.InitContext(</span>
<span class="gi">+                peer_name=gssapi.Name(&#39;host@&#39; + target),</span>
<span class="gi">+                mech_type=gssapi.MechType.kerberos,</span>
<span class="gi">+                req_flags=self._gss_flags</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if recv_token is None:</span>
<span class="gi">+            token = self._gss_ctxt.step()</span>
<span class="gi">+        else:</span>
<span class="gi">+            token = self._gss_ctxt.step(recv_token)</span>
<span class="gi">+</span>
<span class="gi">+        self._gss_ctxt_status = self._gss_ctxt.established</span>
<span class="gi">+</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_get_mic(self, session_id, gss_kex=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -216,7 +252,17 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>                 Returns the MIC token from GSS-API with the SSH session ID as
<span class="w"> </span>                 message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if gss_kex:</span>
<span class="gi">+            mic_field = session_id</span>
<span class="gi">+        else:</span>
<span class="gi">+            mic_field = self._ssh_build_mic(</span>
<span class="gi">+                session_id,</span>
<span class="gi">+                self._username,</span>
<span class="gi">+                self._service,</span>
<span class="gi">+                self._auth_method</span>
<span class="gi">+            )</span>
<span class="gi">+        mic_token = self._gss_ctxt.get_mic(mic_field)</span>
<span class="gi">+        return mic_token</span>

<span class="w"> </span>    def ssh_accept_sec_context(self, hostname, recv_token, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -229,7 +275,13 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: A ``String`` if the GSS-API has returned a token or ``None``
<span class="w"> </span>                if no token was returned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._gss_srv_ctxt is None:</span>
<span class="gi">+            self._gss_srv_ctxt = gssapi.AcceptContext()</span>
<span class="gi">+</span>
<span class="gi">+        token = self._gss_srv_ctxt.step(recv_token)</span>
<span class="gi">+        self._gss_srv_ctxt_status = self._gss_srv_ctxt.established</span>
<span class="gi">+</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def ssh_check_mic(self, mic_token, session_id, username=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -241,7 +293,17 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>        :return: None if the MIC check was successful
<span class="w"> </span>        :raises: ``gssapi.GSSException`` -- if the MIC check failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if username is None:</span>
<span class="gi">+            username = self._username</span>
<span class="gi">+</span>
<span class="gi">+        mic_field = self._ssh_build_mic(</span>
<span class="gi">+            session_id,</span>
<span class="gi">+            username,</span>
<span class="gi">+            self._service,</span>
<span class="gi">+            self._auth_method</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self._gss_srv_ctxt.verify_mic(mic_field, mic_token)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def credentials_delegated(self):
<span class="gu">@@ -250,7 +312,9 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>

<span class="w"> </span>        :return: ``True`` if credentials are delegated, otherwise ``False``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._gss_srv_ctxt is not None:</span>
<span class="gi">+            return self._gss_srv_ctxt.delegated_cred is not None</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def save_client_creds(self, client_token):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -263,7 +327,7 @@ class _SSH_GSSAPI_OLD(_SSH_GSSAuth):</span>
<span class="w"> </span>            ``NotImplementedError`` -- Credential delegation is currently not
<span class="w"> </span>            supported in server mode
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Credential delegation is not supported in server mode&quot;)</span>


<span class="w"> </span>if __version_info__ &lt; (2, 5):
<span class="gh">diff --git a/paramiko/transport.py b/paramiko/transport.py</span>
<span class="gh">index a4f0e92e..a69fee44 100644</span>
<span class="gd">--- a/paramiko/transport.py</span>
<span class="gi">+++ b/paramiko/transport.py</span>
<span class="gu">@@ -352,7 +352,9 @@ class Transport(threading.Thread, ClosingContextManager):</span>

<span class="w"> </span>        .. versionadded:: 1.5.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.close()</span>
<span class="gi">+        self.sock = None</span>
<span class="gi">+        self.packetizer = None</span>

<span class="w"> </span>    def get_security_options(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -361,7 +363,7 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>        digest/hash operations, public keys, and key exchanges) and the order
<span class="w"> </span>        of preference for them.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return SecurityOptions(self)</span>

<span class="w"> </span>    def set_gss_host(self, gss_host, trust_dns=True, gssapi_requested=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -384,7 +386,17 @@ class Transport(threading.Thread, ClosingContextManager):</span>
<span class="w"> </span>            (Defaults to True due to backwards compatibility.)
<span class="w"> </span>        :returns: ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not gssapi_requested:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if gss_host is None:</span>
<span class="gi">+            gss_host = self.hostname</span>
<span class="gi">+</span>
<span class="gi">+        if trust_dns:</span>
<span class="gi">+            import socket</span>
<span class="gi">+            gss_host = socket.getfqdn(gss_host)</span>
<span class="gi">+</span>
<span class="gi">+        self.gss_host = gss_host</span>

<span class="w"> </span>    def start_client(self, event=None, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/util.py b/paramiko/util.py</span>
<span class="gh">index d9df7198..e5cd2e17 100644</span>
<span class="gd">--- a/paramiko/util.py</span>
<span class="gi">+++ b/paramiko/util.py</span>
<span class="gu">@@ -13,13 +13,47 @@ from paramiko.config import SSHConfig</span>
<span class="w"> </span>def inflate_long(s, always_positive=False):
<span class="w"> </span>    &quot;&quot;&quot;turns a normalized byte string into a long-int
<span class="w"> </span>    (adapted from Crypto.Util.number)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    out = 0</span>
<span class="gi">+    negative = 0</span>
<span class="gi">+    if not always_positive and (len(s) &gt; 0) and (byte_ord(s[0]) &amp; 0x80):</span>
<span class="gi">+        negative = 1</span>
<span class="gi">+    if len(s) % 4:</span>
<span class="gi">+        filler = zero_byte * (4 - len(s) % 4)</span>
<span class="gi">+        s = filler + s</span>
<span class="gi">+    for i in range(0, len(s), 4):</span>
<span class="gi">+        out = (out &lt;&lt; 32) + struct.unpack(&#39;&gt;I&#39;, s[i:i+4])[0]</span>
<span class="gi">+    if negative:</span>
<span class="gi">+        out = (1 &lt;&lt; (8 * len(s))) - out</span>
<span class="gi">+        if out == 0:</span>
<span class="gi">+            out = -1 &lt;&lt; (8 * len(s) - 1)</span>
<span class="gi">+    return out</span>


<span class="w"> </span>def deflate_long(n, add_sign_padding=True):
<span class="w"> </span>    &quot;&quot;&quot;turns a long-int into a normalized byte string
<span class="w"> </span>    (adapted from Crypto.Util.number)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # after much testing, this algorithm was deemed to be the fastest</span>
<span class="gi">+    s = bytes()</span>
<span class="gi">+    n = int(n)</span>
<span class="gi">+    while (n != 0) and (n != -1):</span>
<span class="gi">+        s = struct.pack(&#39;&gt;I&#39;, n &amp; xffffffff) + s</span>
<span class="gi">+        n = n &gt;&gt; 32</span>
<span class="gi">+    # strip off leading zeros, FFs</span>
<span class="gi">+    for i in range(len(s)):</span>
<span class="gi">+        if (s[i] != &#39;\000&#39;) and (s[i] != &#39;\xff&#39;):</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        # degenerate case, n was either 0 or -1</span>
<span class="gi">+        s = zero_byte</span>
<span class="gi">+        if n == 0:</span>
<span class="gi">+            return s</span>
<span class="gi">+    s = s[i:]</span>
<span class="gi">+    if add_sign_padding:</span>
<span class="gi">+        if (n &lt; 0) and (s[0] &amp; 0x80):</span>
<span class="gi">+            s = zero_byte + s</span>
<span class="gi">+        elif (n &gt; 0) and (s[0] &amp; 0x80):</span>
<span class="gi">+            s = zero_byte + s</span>
<span class="gi">+    return s</span>


<span class="w"> </span>def generate_key_bytes(hash_alg, salt, key, nbytes):
<span class="gu">@@ -36,7 +70,21 @@ def generate_key_bytes(hash_alg, salt, key, nbytes):</span>
<span class="w"> </span>    :param int nbytes: number of bytes to generate.
<span class="w"> </span>    :return: Key data, as `bytes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keydata = b&quot;&quot;</span>
<span class="gi">+    digest = b&quot;&quot;</span>
<span class="gi">+    if len(salt) &gt; 8:</span>
<span class="gi">+        salt = salt[:8]</span>
<span class="gi">+    while nbytes &gt; 0:</span>
<span class="gi">+        hash_obj = hash_alg()</span>
<span class="gi">+        if len(digest) &gt; 0:</span>
<span class="gi">+            hash_obj.update(digest)</span>
<span class="gi">+        hash_obj.update(b(key))</span>
<span class="gi">+        hash_obj.update(salt)</span>
<span class="gi">+        digest = hash_obj.digest()</span>
<span class="gi">+        size = min(nbytes, len(digest))</span>
<span class="gi">+        keydata += digest[:size]</span>
<span class="gi">+        nbytes -= size</span>
<span class="gi">+    return keydata</span>


<span class="w"> </span>def load_host_keys(filename):
<span class="gu">@@ -55,7 +103,9 @@ def load_host_keys(filename):</span>
<span class="w"> </span>    :return:
<span class="w"> </span>        nested dict of `.PKey` objects, indexed by hostname and then keytype
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from paramiko.hostkeys import HostKeys</span>
<span class="gi">+</span>
<span class="gi">+    return HostKeys(filename)</span>


<span class="w"> </span>def parse_ssh_config(file_obj):
<span class="gu">@@ -65,14 +115,29 @@ def parse_ssh_config(file_obj):</span>
<span class="w"> </span>    .. deprecated:: 2.7
<span class="w"> </span>        Use `SSHConfig.from_file` instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;paramiko.util.parse_ssh_config is deprecated and will be removed in a &quot;</span>
<span class="gi">+        &quot;future release. Please use paramiko.SSHConfig.from_file instead.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+    )</span>
<span class="gi">+    config = SSHConfig()</span>
<span class="gi">+    config.parse(file_obj)</span>
<span class="gi">+    return config</span>


<span class="w"> </span>def lookup_ssh_host_config(hostname, config):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provided only as a backward-compatible wrapper around `.SSHConfig`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;paramiko.util.lookup_ssh_host_config is deprecated and will be &quot;</span>
<span class="gi">+        &quot;removed in a future release. Please use &quot;</span>
<span class="gi">+        &quot;paramiko.SSHConfig.lookup(hostname) instead.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+    )</span>
<span class="gi">+    return config.lookup(hostname)</span>


<span class="w"> </span>_g_thread_data = threading.local()
<span class="gu">@@ -83,7 +148,14 @@ _g_thread_lock = threading.Lock()</span>
<span class="w"> </span>def log_to_file(filename, level=DEBUG):
<span class="w"> </span>    &quot;&quot;&quot;send paramiko logs to a logfile,
<span class="w"> </span>    if they&#39;re not already going somewhere&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(&quot;paramiko&quot;)</span>
<span class="gi">+    if len(logger.handlers) &gt; 0:</span>
<span class="gi">+        return</span>
<span class="gi">+    handler = logging.FileHandler(filename)</span>
<span class="gi">+    handler.setFormatter(logging.Formatter(&#39;%(levelname)-.3s [%(asctime)s.%(msecs)03d] thr=%(_threadid)-3d %(name)s: %(message)s&#39;,</span>
<span class="gi">+                                           &#39;%Y%m%d-%H:%M:%S&#39;))</span>
<span class="gi">+    logger.addHandler(handler)</span>
<span class="gi">+    logger.setLevel(level)</span>


<span class="w"> </span>class PFilter:
<span class="gu">@@ -106,14 +178,29 @@ def asbytes(s):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Coerce to bytes if possible or return unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s</span>
<span class="gi">+    elif isinstance(s, str):</span>
<span class="gi">+        return s.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return s</span>


<span class="w"> </span>def b(s, encoding=&#39;utf8&#39;):
<span class="w"> </span>    &quot;&quot;&quot;cast unicode or bytes to bytes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        return s</span>
<span class="gi">+    elif isinstance(s, str):</span>
<span class="gi">+        return s.encode(encoding)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Expected unicode or bytes, got %r&quot; % s)</span>


<span class="w"> </span>def u(s, encoding=&#39;utf8&#39;):
<span class="w"> </span>    &quot;&quot;&quot;cast bytes or unicode to unicode&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(s, str):</span>
<span class="gi">+        return s</span>
<span class="gi">+    elif isinstance(s, bytes):</span>
<span class="gi">+        return s.decode(encoding)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Expected unicode or bytes, got %r&quot; % s)</span>
<span class="gh">diff --git a/paramiko/win_pageant.py b/paramiko/win_pageant.py</span>
<span class="gh">index 2bad5392..9a876160 100644</span>
<span class="gd">--- a/paramiko/win_pageant.py</span>
<span class="gi">+++ b/paramiko/win_pageant.py</span>
<span class="gu">@@ -21,7 +21,11 @@ def can_talk_to_agent():</span>
<span class="w"> </span>    This checks both if we have the required libraries (win32all or ctypes)
<span class="w"> </span>    and if there is a Pageant currently running.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        hwnd = _winapi.FindWindow(&quot;Pageant&quot;, &quot;Pageant&quot;)</span>
<span class="gi">+        return hwnd is not None</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>if platform.architecture()[0] == &#39;64bit&#39;:
<span class="gu">@@ -44,7 +48,46 @@ def _query_pageant(msg):</span>
<span class="w"> </span>    Communication with the Pageant process is done through a shared
<span class="w"> </span>    memory-mapped file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hwnd = _winapi.FindWindow(&quot;Pageant&quot;, &quot;Pageant&quot;)</span>
<span class="gi">+    if hwnd is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    map_name = f&quot;PageantRequest{thread.get_ident()}&quot;</span>
<span class="gi">+    filemap = _winapi.CreateFileMapping(</span>
<span class="gi">+        _winapi.INVALID_HANDLE_VALUE,</span>
<span class="gi">+        None,</span>
<span class="gi">+        _winapi.PAGE_READWRITE,</span>
<span class="gi">+        0,</span>
<span class="gi">+        _AGENT_MAX_MSGLEN,</span>
<span class="gi">+        map_name,</span>
<span class="gi">+    )</span>
<span class="gi">+    if filemap is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        ptr = _winapi.MapViewOfFile(</span>
<span class="gi">+            filemap, _winapi.FILE_MAP_WRITE, 0, 0, _AGENT_MAX_MSGLEN</span>
<span class="gi">+        )</span>
<span class="gi">+        if ptr is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            _winapi.WriteMemory(ptr, msg)</span>
<span class="gi">+</span>
<span class="gi">+            cds = COPYDATASTRUCT()</span>
<span class="gi">+            cds.num_data = _AGENT_COPYDATA_ID</span>
<span class="gi">+            cds.data_size = struct.calcsize(&quot;L&quot;) + len(map_name) + 1</span>
<span class="gi">+            cds.data_loc = struct.pack(&quot;L&quot;, ptr) + map_name.encode(&quot;ascii&quot;) + b&quot;\0&quot;</span>
<span class="gi">+</span>
<span class="gi">+            response = _winapi.SendMessage(hwnd, win32con_WM_COPYDATA, None, cds)</span>
<span class="gi">+            if response &gt; 0:</span>
<span class="gi">+                return _winapi.ReadMemory(ptr, response)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            _winapi.UnmapViewOfFile(ptr)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _winapi.CloseHandle(filemap)</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="w"> </span>class PageantConnection:
<span class="gu">@@ -57,3 +100,23 @@ class PageantConnection:</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._response = None
<span class="gi">+        self._response_offset = 0</span>
<span class="gi">+</span>
<span class="gi">+    def send(self, data):</span>
<span class="gi">+        self._response = _query_pageant(data)</span>
<span class="gi">+        self._response_offset = 0</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, n):</span>
<span class="gi">+        if self._response is None:</span>
<span class="gi">+            return b&quot;&quot;</span>
<span class="gi">+        remaining = len(self._response) - self._response_offset</span>
<span class="gi">+        if n &gt; remaining:</span>
<span class="gi">+            n = remaining</span>
<span class="gi">+        result = self._response[self._response_offset:self._response_offset + n]</span>
<span class="gi">+        self._response_offset += n</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        self._response = None</span>
<span class="gi">+        self._response_offset = 0</span>
<span class="gi">+        self._response_offset = 0</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>