
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis sweagent commit0 sweagent deprecated - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#swe-agent-deprecated" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis sweagent commit0 sweagent deprecated
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_static_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_static_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_with_custom_warning" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_with_custom_warning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_with_reason" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_with_reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytestclassicdeprecatedtest_deprecated_with_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::TestClassicDeprecated::test_deprecated_with_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringno_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionchanged-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionchanged-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionadded-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionadded-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_warning_msg_has_reason" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_warning_msg_has_reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_warning_msg_has_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_warning_msg_has_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_warning_is_ignored" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_warning_is_ignored
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_specific_warning_cls_is_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_specific_warning_cls_is_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_syntax_trimminguse-functionbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_syntax_trimming[Use :function:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_syntax_trimminguse-pyfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-funcbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-functionbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :function:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-classbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :class:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-excbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :exc:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-exceptionbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :exception:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-methbazbar-instead-use-bazbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :meth:Baz.bar instead-Use Baz.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-methodbazbar-instead-use-bazbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :method:Baz.bar instead-Use Baz.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-pyfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :py:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-cppfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-jsfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :js:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-funcpkgmodbar-instead-use-pkgmodbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :func:~pkg.mod.bar instead-Use ~pkg.mod.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-rinstead-use-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :r:instead-Use instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-drinstead-use-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :d:r:instead-Use instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-rfoo-instead-use-foo-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :r:foo instead-Use foo instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-drfoo-instead-use-foo-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :d:r:foo instead-Use foo instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-rbad-instead-use-rbad-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use r:bad instead-Use r:bad instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-bad-instead-use-bad-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use ::bad instead-Use ::bad instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-bad-instead-use-bad-instead_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :::bad instead-Use :::bad instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_adapterpytest_decorator_accept_line_lengthversionadded-versionadded" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_adapter.py::test_decorator_accept_line_length[versionadded-versionadded]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_adapterpytest_decorator_accept_line_lengthversionchanged-versionchanged" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_adapter.py::test_decorator_accept_line_length[versionchanged-versionchanged]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_adapterpytest_decorator_accept_line_lengthdeprecated-deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_adapter.py::test_decorator_accept_line_length[deprecated-deprecated]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_class_deprecation_using_deprecated_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_class_deprecation_using_deprecated_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_subclass_deprecation_using_deprecated_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_subclass_deprecation_using_deprecated_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_isinstance_versionadded" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_isinstance_versionadded
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_isinstance_versionchanged" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_isinstance_versionchanged
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_isinstance_deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_isinstance_deprecated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_classpytest_isinstance_versionadded_versionchanged" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_class.py::test_isinstance_versionadded_versionchanged
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_sweagent-commit0_sweagent">back to SWE-Agent summary</a></p>
<h1 id="swe-agent-deprecated"><strong>SWE-Agent</strong>: deprecated</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">30</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">87</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">137</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">137</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_function">test_deprecated.py::TestClassicDeprecated::test_deprecated_function</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_function</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_function>

    def test_deprecated_function(self):
        foo = self._get_deprecated_func()
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:45: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_method">test_deprecated.py::TestClassicDeprecated::test_deprecated_method</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_method</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_method>

    def test_deprecated_method(self):
        Foo = self._get_deprecated_method()
        foo = Foo()
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo.foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:64: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_static_method">test_deprecated.py::TestClassicDeprecated::test_deprecated_static_method</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_static_method</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_static_method>

    def test_deprecated_static_method(self):
        foo = self._get_deprecated_static_method()
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:73: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_with_custom_warning">test_deprecated.py::TestClassicDeprecated::test_deprecated_with_custom_warning</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_with_custom_warning</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_with_custom_warning>

    def test_deprecated_with_custom_warning(self):
        foo = self._get_deprecated_func(category=MyDeprecationWarning)
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:100: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_with_reason">test_deprecated.py::TestClassicDeprecated::test_deprecated_with_reason</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_with_reason</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_with_reason>

    def test_deprecated_with_reason(self):
        foo = self._get_deprecated_func(reason="Good reason")
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:82: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytestclassicdeprecatedtest_deprecated_with_version">test_deprecated.py::TestClassicDeprecated::test_deprecated_with_version</h3>
<details><summary> <pre>test_deprecated.py::TestClassicDeprecated::test_deprecated_with_version</pre></summary><pre>
self = <tests.test_deprecated.TestClassicDeprecated testMethod=test_deprecated_with_version>

    def test_deprecated_with_version(self):
        foo = self._get_deprecated_func(version="1.2.3")
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            foo()
>           self.assertEqual(len(w), 1)
E           AssertionError: 0 != 1

tests/test_deprecated.py:91: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-versionadded-reasonversion">test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = None, directive = 'versionadded', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-versionadded-version">test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionadded-version]</pre></summary><pre>
docstring = None, directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionadded-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = None, directive = 'versionadded', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionadded-version">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionadded-version]</pre></summary><pre>
docstring = None, directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-versionchanged-reasonversion">test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = None, directive = 'versionchanged', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-versionchanged-version">test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-versionchanged-version]</pre></summary><pre>
docstring = None, directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionchanged-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = None, directive = 'versionchanged', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-versionchanged-version">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-versionchanged-version]</pre></summary><pre>
docstring = None, directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-versionchanged-reasonversion">test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-versionchanged-version">test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionchanged-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionchanged-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionchanged-version">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionchanged-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionchanged'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-versionadded-reasonversion">test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionadded'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-versionadded-version">test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-versionadded-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionadded'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionadded-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionadded'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-versionadded-version">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-versionadded-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'versionadded'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-deprecated-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringshort_docstring-deprecated-version">test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[short_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = None, version = '1.2.0', expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-deprecated-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = 'A good reason'
version = '1.2.0', expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringno_docstring-deprecated-version">test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[no_docstring-deprecated-version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-deprecated-version">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-deprecated-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionchanged-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionchanged-version">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionchanged-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionchanged-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionchanged-version">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionchanged-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionadded-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-versionadded-version">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-versionadded-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionadded-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd213_long_docstring-versionadded-version">test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D213_long_docstring-versionadded-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-deprecated-version">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionchanged-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionchanged-version">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionchanged-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionchanged-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionchanged-version">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionchanged-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionchanged', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionadded-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-versionadded-version">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-versionadded-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:81: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionadded-reasonversion">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = 'A good reason', version = '1.2.0'
expected = '.. {directive}:: {version}\n   {reason}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_cls_has_sphinx_docstringd212_long_docstring-versionadded-version">test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]</h3>
<details><summary> <pre>test_sphinx.py::test_cls_has_sphinx_docstring[D212_long_docstring-versionadded-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'versionadded', reason = None, version = '1.2.0'
expected = '.. {directive}:: {version}\n'

    @pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_cls_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The class:
        class Foo(object):
            pass

        # with docstring:
        Foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
>       Foo = decorator(Foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:148: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function0">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_function(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       def foo1():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:192: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function1">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_function(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       def foo1():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:192: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function2">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_function(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       def foo1():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:192: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function3">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_function' for <Function test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_function(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       def foo1():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:192: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class0">test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class0]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       class Foo2(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:203: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class1">test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class1]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       class Foo2(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:203: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class2">test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       class Foo2(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:203: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class__warnssphinx_deprecated_class3">test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class' for <Function test_sphinx_deprecated_class__warns[sphinx_deprecated_class3]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class(request):
        kwargs = request.param

        @deprecated.sphinx.deprecated(**kwargs)
>       class Foo2(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:203: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method0">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_method(request):
        kwargs = request.param

>       class Foo3(object):

tests/test_sphinx.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo3(object):
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo3(self):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:215: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method1">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_method(request):
        kwargs = request.param

>       class Foo3(object):

tests/test_sphinx.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo3(object):
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo3(self):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:215: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method2">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_method(request):
        kwargs = request.param

>       class Foo3(object):

tests/test_sphinx.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo3(object):
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo3(self):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:215: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method3">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_method' for <Function test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_method(request):
        kwargs = request.param

>       class Foo3(object):

tests/test_sphinx.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo3(object):
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo3(self):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:215: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method0">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_static_method(request):
        kwargs = request.param

>       class Foo4(object):

tests/test_sphinx.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo4(object):
        @staticmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo4():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:228: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method1">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_static_method(request):
        kwargs = request.param

>       class Foo4(object):

tests/test_sphinx.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo4(object):
        @staticmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo4():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:228: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method2">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_static_method(request):
        kwargs = request.param

>       class Foo4(object):

tests/test_sphinx.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo4(object):
        @staticmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo4():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:228: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method3">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_static_method' for <Function test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_static_method(request):
        kwargs = request.param

>       class Foo4(object):

tests/test_sphinx.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo4(object):
        @staticmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo4():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:228: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method0">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class_method(request):
        kwargs = request.param

>       class Foo5(object):

tests/test_sphinx.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo5(object):
        @classmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo5(cls):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:241: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method1">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class_method(request):
        kwargs = request.param

>       class Foo5(object):

tests/test_sphinx.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo5(object):
        @classmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo5(cls):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:241: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method2">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class_method(request):
        kwargs = request.param

>       class Foo5(object):

tests/test_sphinx.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo5(object):
        @classmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo5(cls):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:241: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method3">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]</pre></summary><pre>
request = <SubRequest 'sphinx_deprecated_class_method' for <Function test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def sphinx_deprecated_class_method(request):
        kwargs = request.param

>       class Foo5(object):

tests/test_sphinx.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class Foo5(object):
        @classmethod
        @deprecated.sphinx.deprecated(**kwargs)
>       def foo5(cls):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:241: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_warning_msg_has_reason">test_sphinx.py::test_warning_msg_has_reason</h3>
<details><summary> <pre>test_sphinx.py::test_warning_msg_has_reason</pre></summary><pre>
def test_warning_msg_has_reason():
        reason = "Good reason"

        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:325: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_warning_msg_has_version">test_sphinx.py::test_warning_msg_has_version</h3>
<details><summary> <pre>test_sphinx.py::test_warning_msg_has_version</pre></summary><pre>
def test_warning_msg_has_version():
        version = "1.2.3"

        @deprecated.sphinx.deprecated(version=version)
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:338: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_warning_is_ignored">test_sphinx.py::test_warning_is_ignored</h3>
<details><summary> <pre>test_sphinx.py::test_warning_is_ignored</pre></summary><pre>
def test_warning_is_ignored():
        @deprecated.sphinx.deprecated(version="4.5.6", action='ignore')
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:349: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_specific_warning_cls_is_used">test_sphinx.py::test_specific_warning_cls_is_used</h3>
<details><summary> <pre>test_sphinx.py::test_specific_warning_cls_is_used</pre></summary><pre>
def test_specific_warning_cls_is_used():
        @deprecated.sphinx.deprecated(version="4.5.6", category=MyDeprecationWarning)
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:359: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_syntax_trimminguse-functionbar-instead-use-bar-instead">test_sphinx.py::test_sphinx_syntax_trimming[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        ["reason", "expected"],
        [
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
        ],
    )
    def test_sphinx_syntax_trimming(reason, expected):
        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:384: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_syntax_trimminguse-pyfuncbar-instead-use-bar-instead">test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        ["reason", "expected"],
        [
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
        ],
    )
    def test_sphinx_syntax_trimming(reason, expected):
        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
>       def foo():
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx.py:384: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-funcbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-functionbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-classbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :class:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :class:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-excbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :exc:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :exc:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-exceptionbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :exception:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :exception:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-methbazbar-instead-use-bazbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :meth:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]</pre></summary><pre>
reason = 'Use :meth:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-methodbazbar-instead-use-bazbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :method:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]</pre></summary><pre>
reason = 'Use :method:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-pyfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-cppfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :cpp:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-jsfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :js:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :js:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-funcpkgmodbar-instead-use-pkgmodbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :func:<code>~pkg.mod.bar</code> instead-Use <code>~pkg.mod.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]</pre></summary><pre>
reason = 'Use :func:`~pkg.mod.bar` instead'
expected = 'Use `~pkg.mod.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-rinstead-use-instead">test_sphinx.py::test_get_deprecated_msg[Use :r:<code>instead-Use</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`` instead-Use `` instead]</pre></summary><pre>
reason = 'Use :r:`` instead', expected = 'Use `` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-drinstead-use-instead">test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>instead-Use</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]</pre></summary><pre>
reason = 'Use :d:r:`` instead', expected = 'Use `` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-rfoo-instead-use-foo-instead">test_sphinx.py::test_get_deprecated_msg[Use :r:<code>foo</code> instead-Use <code>foo</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]</pre></summary><pre>
reason = 'Use :r:`foo` instead', expected = 'Use `foo` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-drfoo-instead-use-foo-instead">test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>foo</code> instead-Use <code>foo</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]</pre></summary><pre>
reason = 'Use :d:r:`foo` instead', expected = 'Use `foo` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-rbad-instead-use-rbad-instead">test_sphinx.py::test_get_deprecated_msg[Use r:<code>bad</code> instead-Use r:<code>bad</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use r:`bad` instead-Use r:`bad` instead]</pre></summary><pre>
reason = 'Use r:`bad` instead', expected = 'Use r:`bad` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-bad-instead-use-bad-instead">test_sphinx.py::test_get_deprecated_msg[Use ::<code>bad</code> instead-Use ::<code>bad</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use ::`bad` instead-Use ::`bad` instead]</pre></summary><pre>
reason = 'Use ::`bad` instead', expected = 'Use ::`bad` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-bad-instead-use-bad-instead_1">test_sphinx.py::test_get_deprecated_msg[Use :::<code>bad</code> instead-Use :::<code>bad</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :::`bad` instead-Use :::`bad` instead]</pre></summary><pre>
reason = 'Use :::`bad` instead', expected = 'Use :::`bad` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       TypeError: argument of type 'NoneType' is not iterable

tests/test_sphinx.py:424: TypeError
</pre>
</details>
<h3 id="test_sphinx_adapterpytest_decorator_accept_line_lengthversionadded-versionadded">test_sphinx_adapter.py::test_decorator_accept_line_length[versionadded-versionadded]</h3>
<details><summary> <pre>test_sphinx_adapter.py::test_decorator_accept_line_length[versionadded-versionadded]</pre></summary><pre>
decorator_factory = <function versionadded at 0x7f6371659d80>
directive = 'versionadded'

    @pytest.mark.parametrize(
        "decorator_factory, directive",
        [
            (versionadded, "versionadded"),
            (versionchanged, "versionchanged"),
            (deprecated, "deprecated"),
        ],
    )
    def test_decorator_accept_line_length(decorator_factory, directive):
        reason = "bar " * 30
        decorator = decorator_factory(reason=reason, version="1.2.3", line_length=50)

        def foo():
            pass

>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_adapter.py:117: TypeError
</pre>
</details>
<h3 id="test_sphinx_adapterpytest_decorator_accept_line_lengthversionchanged-versionchanged">test_sphinx_adapter.py::test_decorator_accept_line_length[versionchanged-versionchanged]</h3>
<details><summary> <pre>test_sphinx_adapter.py::test_decorator_accept_line_length[versionchanged-versionchanged]</pre></summary><pre>
decorator_factory = <function versionchanged at 0x7f6371659b40>
directive = 'versionchanged'

    @pytest.mark.parametrize(
        "decorator_factory, directive",
        [
            (versionadded, "versionadded"),
            (versionchanged, "versionchanged"),
            (deprecated, "deprecated"),
        ],
    )
    def test_decorator_accept_line_length(decorator_factory, directive):
        reason = "bar " * 30
        decorator = decorator_factory(reason=reason, version="1.2.3", line_length=50)

        def foo():
            pass

>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_adapter.py:117: TypeError
</pre>
</details>
<h3 id="test_sphinx_adapterpytest_decorator_accept_line_lengthdeprecated-deprecated">test_sphinx_adapter.py::test_decorator_accept_line_length[deprecated-deprecated]</h3>
<details><summary> <pre>test_sphinx_adapter.py::test_decorator_accept_line_length[deprecated-deprecated]</pre></summary><pre>
decorator_factory = <function deprecated at 0x7f637165a170>
directive = 'deprecated'

    @pytest.mark.parametrize(
        "decorator_factory, directive",
        [
            (versionadded, "versionadded"),
            (versionchanged, "versionchanged"),
            (deprecated, "deprecated"),
        ],
    )
    def test_decorator_accept_line_length(decorator_factory, directive):
        reason = "bar " * 30
        decorator = decorator_factory(reason=reason, version="1.2.3", line_length=50)

        def foo():
            pass

>       foo = decorator(foo)
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_adapter.py:117: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_class_deprecation_using_deprecated_decorator">test_sphinx_class.py::test_class_deprecation_using_deprecated_decorator</h3>
<details><summary> <pre>test_sphinx_class.py::test_class_deprecation_using_deprecated_decorator</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_class_deprecation_using_deprecated_decorator():
        @deprecated.sphinx.deprecated(version="7.8.9")
>       class MyBaseClass(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:49: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_subclass_deprecation_using_deprecated_decorator">test_sphinx_class.py::test_subclass_deprecation_using_deprecated_decorator</h3>
<details><summary> <pre>test_sphinx_class.py::test_subclass_deprecation_using_deprecated_decorator</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_subclass_deprecation_using_deprecated_decorator():
        @deprecated.sphinx.deprecated(version="7.8.9")
>       class MyBaseClass(object):
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:70: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_isinstance_versionadded">test_sphinx_class.py::test_isinstance_versionadded</h3>
<details><summary> <pre>test_sphinx_class.py::test_isinstance_versionadded</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_isinstance_versionadded():
        # https://github.com/tantale/deprecated/issues/48
        @deprecated.sphinx.versionadded(version="X.Y", reason="some reason")
>       class VersionAddedCls:
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:93: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_isinstance_versionchanged">test_sphinx_class.py::test_isinstance_versionchanged</h3>
<details><summary> <pre>test_sphinx_class.py::test_isinstance_versionchanged</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_isinstance_versionchanged():
        @deprecated.sphinx.versionchanged(version="X.Y", reason="some reason")
>       class VersionChangedCls:
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:110: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_isinstance_deprecated">test_sphinx_class.py::test_isinstance_deprecated</h3>
<details><summary> <pre>test_sphinx_class.py::test_isinstance_deprecated</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_isinstance_deprecated():
        @deprecated.sphinx.deprecated(version="X.Y", reason="some reason")
>       class DeprecatedCls:
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:127: TypeError
</pre>
</details>
<h3 id="test_sphinx_classpytest_isinstance_versionadded_versionchanged">test_sphinx_class.py::test_isinstance_versionadded_versionchanged</h3>
<details><summary> <pre>test_sphinx_class.py::test_isinstance_versionadded_versionchanged</pre></summary><pre>
@pytest.mark.skipif(
        sys.version_info < (3, 3), reason="Classes should have mutable docstrings -- resolved in python 3.3"
    )
    def test_isinstance_versionadded_versionchanged():
        @deprecated.sphinx.versionadded(version="X.Y")
        @deprecated.sphinx.versionchanged(version="X.Y.Z")
>       class AddedChangedCls:
E       TypeError: 'NoneType' object is not callable

tests/test_sphinx_class.py:145: TypeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/deprecated/classic.py b/deprecated/classic.py</span>
<span class="gh">index 5175055..ef33d03 100644</span>
<span class="gd">--- a/deprecated/classic.py</span>
<span class="gi">+++ b/deprecated/classic.py</span>
<span class="gu">@@ -1,16 +1,10 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-Classic deprecation warning</span>
<span class="gd">-===========================</span>
<span class="gd">-</span>
<span class="gd">-Classic ``@deprecated`` decorator to deprecate old python classes, functions or methods.</span>
<span class="gd">-</span>
<span class="gd">-.. _The Warnings Filter: https://docs.python.org/3/library/warnings.html#the-warnings-filter</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-import functools</span>
<span class="w"> </span>import inspect
<span class="gd">-import platform</span>
<span class="w"> </span>import warnings
<span class="gi">+import types</span>
<span class="gi">+import functools</span>
<span class="gi">+import platform</span>
<span class="w"> </span>import wrapt
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import wrapt._wrappers
<span class="w"> </span>    _routine_stacklevel = 2
<span class="gu">@@ -21,86 +15,11 @@ except ImportError:</span>
<span class="w"> </span>        _class_stacklevel = 2
<span class="w"> </span>    else:
<span class="w"> </span>        _class_stacklevel = 3
<span class="gi">+</span>
<span class="w"> </span>string_types = (type(b&#39;&#39;), type(u&#39;&#39;))

<span class="w"> </span>class ClassicAdapter(wrapt.AdapterFactory):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    Classic adapter -- *for advanced usage only*</span>
<span class="gd">-</span>
<span class="gd">-    This adapter is used to get the deprecation message according to the wrapped object type:</span>
<span class="gd">-    class, function, standard method, static method, or class method.</span>
<span class="gd">-</span>
<span class="gd">-    This is the base class of the :class:`~deprecated.sphinx.SphinxAdapter` class</span>
<span class="gd">-    which is used to update the wrapped object docstring.</span>
<span class="gd">-</span>
<span class="gd">-    You can also inherit this class to change the deprecation message.</span>
<span class="gd">-</span>
<span class="gd">-    In the following example, we change the message into &quot;The ... is deprecated.&quot;:</span>
<span class="gd">-</span>
<span class="gd">-    .. code-block:: python</span>
<span class="gd">-</span>
<span class="gd">-       import inspect</span>
<span class="gd">-</span>
<span class="gd">-       from deprecated.classic import ClassicAdapter</span>
<span class="gd">-       from deprecated.classic import deprecated</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-       class MyClassicAdapter(ClassicAdapter):</span>
<span class="gd">-           def get_deprecated_msg(self, wrapped, instance):</span>
<span class="gd">-               if instance is None:</span>
<span class="gd">-                   if inspect.isclass(wrapped):</span>
<span class="gd">-                       fmt = &quot;The class {name} is deprecated.&quot;</span>
<span class="gd">-                   else:</span>
<span class="gd">-                       fmt = &quot;The function {name} is deprecated.&quot;</span>
<span class="gd">-               else:</span>
<span class="gd">-                   if inspect.isclass(instance):</span>
<span class="gd">-                       fmt = &quot;The class method {name} is deprecated.&quot;</span>
<span class="gd">-                   else:</span>
<span class="gd">-                       fmt = &quot;The method {name} is deprecated.&quot;</span>
<span class="gd">-               if self.reason:</span>
<span class="gd">-                   fmt += &quot; ({reason})&quot;</span>
<span class="gd">-               if self.version:</span>
<span class="gd">-                   fmt += &quot; -- Deprecated since version {version}.&quot;</span>
<span class="gd">-               return fmt.format(name=wrapped.__name__,</span>
<span class="gd">-                                 reason=self.reason or &quot;&quot;,</span>
<span class="gd">-                                 version=self.version or &quot;&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    Then, you can use your ``MyClassicAdapter`` class like this in your source code:</span>
<span class="gd">-</span>
<span class="gd">-    .. code-block:: python</span>
<span class="gd">-</span>
<span class="gd">-       @deprecated(reason=&quot;use another function&quot;, adapter_cls=MyClassicAdapter)</span>
<span class="gd">-       def some_old_function(x, y):</span>
<span class="gd">-           return x + y</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, reason=&#39;&#39;, version=&#39;&#39;, action=None, category=DeprecationWarning):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Construct a wrapper adapter.</span>
<span class="gd">-</span>
<span class="gd">-        :type  reason: str</span>
<span class="gd">-        :param reason:</span>
<span class="gd">-            Reason message which documents the deprecation in your library (can be omitted).</span>
<span class="gd">-</span>
<span class="gd">-        :type  version: str</span>
<span class="gd">-        :param version:</span>
<span class="gd">-            Version of your project which deprecates this feature.</span>
<span class="gd">-            If you follow the `Semantic Versioning &lt;https://semver.org/&gt;`_,</span>
<span class="gd">-            the version number has the format &quot;MAJOR.MINOR.PATCH&quot;.</span>
<span class="gd">-</span>
<span class="gd">-        :type  action: str</span>
<span class="gd">-        :param action:</span>
<span class="gd">-            A warning filter used to activate or not the deprecation warning.</span>
<span class="gd">-            Can be one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;, or &quot;once&quot;.</span>
<span class="gd">-            If ``None`` or empty, the the global filtering mechanism is used.</span>
<span class="gd">-            See: `The Warnings Filter`_ in the Python documentation.</span>
<span class="gd">-</span>
<span class="gd">-        :type  category: type</span>
<span class="gd">-        :param category:</span>
<span class="gd">-            The warning category to use for the deprecation warning.</span>
<span class="gd">-            By default, the category class is :class:`~DeprecationWarning`,</span>
<span class="gd">-            you can inherit this class to define your own deprecation warning category.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="w"> </span>        self.reason = reason or &#39;&#39;
<span class="w"> </span>        self.version = version or &#39;&#39;
<span class="w"> </span>        self.action = action
<span class="gu">@@ -108,31 +27,23 @@ class ClassicAdapter(wrapt.AdapterFactory):</span>
<span class="w"> </span>        super(ClassicAdapter, self).__init__()

<span class="w"> </span>    def get_deprecated_msg(self, wrapped, instance):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Get the deprecation warning message for the user.</span>
<span class="gd">-</span>
<span class="gd">-        :param wrapped: Wrapped class or function.</span>
<span class="gd">-</span>
<span class="gd">-        :param instance: The object to which the wrapped function was bound when it was called.</span>
<span class="gd">-</span>
<span class="gd">-        :return: The warning message.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            if inspect.isclass(wrapped):</span>
<span class="gi">+                fmt = &quot;Class {name} is deprecated.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt = &quot;Function {name} is deprecated.&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if inspect.isclass(instance):</span>
<span class="gi">+                fmt = &quot;Class method {name} is deprecated.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt = &quot;Method {name} is deprecated.&quot;</span>
<span class="gi">+        if self.reason:</span>
<span class="gi">+            fmt += &quot; {reason}&quot;</span>
<span class="gi">+        if self.version:</span>
<span class="gi">+            fmt += &quot; -- Deprecated since version {version}.&quot;</span>
<span class="gi">+        return fmt.format(name=wrapped.__name__, reason=self.reason, version=self.version)</span>

<span class="w"> </span>    def __call__(self, wrapped):
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Decorate your class or function.</span>
<span class="gd">-</span>
<span class="gd">-        :param wrapped: Wrapped class or function.</span>
<span class="gd">-</span>
<span class="gd">-        :return: the decorated class or function.</span>
<span class="gd">-</span>
<span class="gd">-        .. versionchanged:: 1.2.4</span>
<span class="gd">-           Don&#39;t pass arguments to :meth:`object.__new__` (other than *cls*).</span>
<span class="gd">-</span>
<span class="gd">-        .. versionchanged:: 1.2.8</span>
<span class="gd">-           The warning filter is not set if the *action* parameter is ``None`` or empty.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="w"> </span>        if inspect.isclass(wrapped):
<span class="w"> </span>            old_new1 = wrapped.__new__

<span class="gu">@@ -226,4 +137,9 @@ def deprecated(*args, **kwargs):</span>
<span class="w"> </span>           return x + y

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):</span>
<span class="gi">+        # This is the decorator without arguments</span>
<span class="gi">+        return ClassicAdapter()(args[0])</span>
<span class="gi">+    else:</span>
<span class="gi">+        # This is the decorator with arguments</span>
<span class="gi">+        return ClassicAdapter(*args, **kwargs)</span>
<span class="gh">diff --git a/tests/test_deprecated.py b/tests/test_deprecated.py</span>
<span class="gh">index e4c00ef..7f3a331 100644</span>
<span class="gd">--- a/tests/test_deprecated.py</span>
<span class="gi">+++ b/tests/test_deprecated.py</span>
<span class="gu">@@ -1,260 +1,105 @@</span>
<span class="gd">-# -*- coding: utf-8 -*-</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="gi">+import unittest</span>

<span class="gd">-import pytest</span>
<span class="gd">-</span>
<span class="gd">-import deprecated.classic</span>
<span class="gi">+from deprecated.classic import deprecated</span>


<span class="w"> </span>class MyDeprecationWarning(DeprecationWarning):
<span class="w"> </span>    pass


<span class="gd">-_PARAMS = [</span>
<span class="gd">-    None,</span>
<span class="gd">-    ((), {}),</span>
<span class="gd">-    ((&#39;Good reason&#39;,), {}),</span>
<span class="gd">-    ((), {&#39;reason&#39;: &#39;Good reason&#39;}),</span>
<span class="gd">-    ((), {&#39;version&#39;: &#39;1.2.3&#39;}),</span>
<span class="gd">-    ((), {&#39;action&#39;: &#39;once&#39;}),</span>
<span class="gd">-    ((), {&#39;category&#39;: MyDeprecationWarning}),</span>
<span class="gd">-]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@pytest.fixture(scope=&quot;module&quot;, params=_PARAMS)</span>
<span class="gd">-def classic_deprecated_function(request):</span>
<span class="gd">-    if request.param is None:</span>
<span class="gd">-</span>
<span class="gd">-        @deprecated.classic.deprecated</span>
<span class="gd">-        def foo1():</span>
<span class="gi">+class TestClassicDeprecated(unittest.TestCase):</span>
<span class="gi">+    def _get_deprecated_func(self, *args, **kwargs):</span>
<span class="gi">+        @deprecated(*args, **kwargs)</span>
<span class="gi">+        def foo():</span>
<span class="w"> </span>            pass
<span class="gi">+        return foo</span>

<span class="gd">-        return foo1</span>
<span class="gd">-    else:</span>
<span class="gd">-        args, kwargs = request.param</span>
<span class="gd">-</span>
<span class="gd">-        @deprecated.classic.deprecated(*args, **kwargs)</span>
<span class="gd">-        def foo1():</span>
<span class="gi">+    def _get_deprecated_class(self, *args, **kwargs):</span>
<span class="gi">+        @deprecated(*args, **kwargs)</span>
<span class="gi">+        class Foo:</span>
<span class="w"> </span>            pass
<span class="gi">+        return Foo</span>

<span class="gd">-        return foo1</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@pytest.fixture(scope=&quot;module&quot;, params=_PARAMS)</span>
<span class="gd">-def classic_deprecated_class(request):</span>
<span class="gd">-    if request.param is None:</span>
<span class="gd">-</span>
<span class="gd">-        @deprecated.classic.deprecated</span>
<span class="gd">-        class Foo2(object):</span>
<span class="gd">-            pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo2</span>
<span class="gd">-    else:</span>
<span class="gd">-        args, kwargs = request.param</span>
<span class="gd">-</span>
<span class="gd">-        @deprecated.classic.deprecated(*args, **kwargs)</span>
<span class="gd">-        class Foo2(object):</span>
<span class="gd">-            pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo2</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@pytest.fixture(scope=&quot;module&quot;, params=_PARAMS)</span>
<span class="gd">-def classic_deprecated_method(request):</span>
<span class="gd">-    if request.param is None:</span>
<span class="gd">-</span>
<span class="gd">-        class Foo3(object):</span>
<span class="gd">-            @deprecated.classic.deprecated</span>
<span class="gd">-            def foo3(self):</span>
<span class="gi">+    def _get_deprecated_method(self, *args, **kwargs):</span>
<span class="gi">+        class Foo:</span>
<span class="gi">+            @deprecated(*args, **kwargs)</span>
<span class="gi">+            def foo(self):</span>
<span class="w"> </span>                pass
<span class="gi">+        return Foo</span>

<span class="gd">-        return Foo3</span>
<span class="gd">-    else:</span>
<span class="gd">-        args, kwargs = request.param</span>
<span class="gd">-</span>
<span class="gd">-        class Foo3(object):</span>
<span class="gd">-            @deprecated.classic.deprecated(*args, **kwargs)</span>
<span class="gd">-            def foo3(self):</span>
<span class="gd">-                pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo3</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@pytest.fixture(scope=&quot;module&quot;, params=_PARAMS)</span>
<span class="gd">-def classic_deprecated_static_method(request):</span>
<span class="gd">-    if request.param is None:</span>
<span class="gd">-</span>
<span class="gd">-        class Foo4(object):</span>
<span class="gd">-            @staticmethod</span>
<span class="gd">-            @deprecated.classic.deprecated</span>
<span class="gd">-            def foo4():</span>
<span class="gd">-                pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo4.foo4</span>
<span class="gd">-    else:</span>
<span class="gd">-        args, kwargs = request.param</span>
<span class="gd">-</span>
<span class="gd">-        class Foo4(object):</span>
<span class="gi">+    def _get_deprecated_static_method(self, *args, **kwargs):</span>
<span class="gi">+        class Foo:</span>
<span class="w"> </span>            @staticmethod
<span class="gd">-            @deprecated.classic.deprecated(*args, **kwargs)</span>
<span class="gd">-            def foo4():</span>
<span class="gd">-                pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo4.foo4</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@pytest.fixture(scope=&quot;module&quot;, params=_PARAMS)</span>
<span class="gd">-def classic_deprecated_class_method(request):</span>
<span class="gd">-    if request.param is None:</span>
<span class="gd">-</span>
<span class="gd">-        class Foo5(object):</span>
<span class="gd">-            @classmethod</span>
<span class="gd">-            @deprecated.classic.deprecated</span>
<span class="gd">-            def foo5(cls):</span>
<span class="gi">+            @deprecated(*args, **kwargs)</span>
<span class="gi">+            def foo():</span>
<span class="w"> </span>                pass
<span class="gd">-</span>
<span class="gd">-        return Foo5</span>
<span class="gd">-    else:</span>
<span class="gd">-        args, kwargs = request.param</span>
<span class="gd">-</span>
<span class="gd">-        class Foo5(object):</span>
<span class="gd">-            @classmethod</span>
<span class="gd">-            @deprecated.classic.deprecated(*args, **kwargs)</span>
<span class="gd">-            def foo5(cls):</span>
<span class="gd">-                pass</span>
<span class="gd">-</span>
<span class="gd">-        return Foo5</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-# noinspection PyShadowingNames</span>
<span class="gd">-def test_classic_deprecated_function__warns(classic_deprecated_function):</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        warnings.simplefilter(&quot;always&quot;)</span>
<span class="gd">-        classic_deprecated_function()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, DeprecationWarning)</span>
<span class="gd">-    assert &quot;deprecated function (or staticmethod)&quot; in str(warn.message)</span>
<span class="gd">-    assert warn.filename == __file__, &#39;Incorrect warning stackLevel&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-# noinspection PyShadowingNames</span>
<span class="gd">-def test_classic_deprecated_class__warns(classic_deprecated_class):</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        warnings.simplefilter(&quot;always&quot;)</span>
<span class="gd">-        classic_deprecated_class()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, DeprecationWarning)</span>
<span class="gd">-    assert &quot;deprecated class&quot; in str(warn.message)</span>
<span class="gd">-    assert warn.filename == __file__, &#39;Incorrect warning stackLevel&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-# noinspection PyShadowingNames</span>
<span class="gd">-def test_classic_deprecated_method__warns(classic_deprecated_method):</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        warnings.simplefilter(&quot;always&quot;)</span>
<span class="gd">-        obj = classic_deprecated_method()</span>
<span class="gd">-        obj.foo3()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, DeprecationWarning)</span>
<span class="gd">-    assert &quot;deprecated method&quot; in str(warn.message)</span>
<span class="gd">-    assert warn.filename == __file__, &#39;Incorrect warning stackLevel&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-# noinspection PyShadowingNames</span>
<span class="gd">-def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        warnings.simplefilter(&quot;always&quot;)</span>
<span class="gd">-        classic_deprecated_static_method()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, DeprecationWarning)</span>
<span class="gd">-    assert &quot;deprecated function (or staticmethod)&quot; in str(warn.message)</span>
<span class="gd">-    assert warn.filename == __file__, &#39;Incorrect warning stackLevel&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-# noinspection PyShadowingNames</span>
<span class="gd">-def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        warnings.simplefilter(&quot;always&quot;)</span>
<span class="gd">-        cls = classic_deprecated_class_method()</span>
<span class="gd">-        cls.foo5()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, DeprecationWarning)</span>
<span class="gd">-    if sys.version_info &gt;= (3, 9):</span>
<span class="gd">-        assert &quot;deprecated class method&quot; in str(warn.message)</span>
<span class="gd">-    else:</span>
<span class="gd">-        assert &quot;deprecated function (or staticmethod)&quot; in str(warn.message)</span>
<span class="gd">-    assert warn.filename == __file__, &#39;Incorrect warning stackLevel&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_should_raise_type_error():</span>
<span class="gd">-    try:</span>
<span class="gd">-        deprecated.classic.deprecated(5)</span>
<span class="gd">-        assert False, &quot;TypeError not raised&quot;</span>
<span class="gd">-    except TypeError:</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_warning_msg_has_reason():</span>
<span class="gd">-    reason = &quot;Good reason&quot;</span>
<span class="gd">-</span>
<span class="gd">-    @deprecated.classic.deprecated(reason=reason)</span>
<span class="gd">-    def foo():</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        foo()</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert reason in str(warn.message)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_warning_msg_has_version():</span>
<span class="gd">-    version = &quot;1.2.3&quot;</span>
<span class="gd">-</span>
<span class="gd">-    @deprecated.classic.deprecated(version=version)</span>
<span class="gd">-    def foo():</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        foo()</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert version in str(warn.message)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_warning_is_ignored():</span>
<span class="gd">-    @deprecated.classic.deprecated(action=&#39;ignore&#39;)</span>
<span class="gd">-    def foo():</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        foo()</span>
<span class="gd">-    assert len(warns) == 0</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_specific_warning_cls_is_used():</span>
<span class="gd">-    @deprecated.classic.deprecated(category=MyDeprecationWarning)</span>
<span class="gd">-    def foo():</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        foo()</span>
<span class="gd">-    warn = warns[0]</span>
<span class="gd">-    assert issubclass(warn.category, MyDeprecationWarning)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def test_respect_global_filter():</span>
<span class="gd">-    @deprecated.classic.deprecated(version=&#39;1.2.1&#39;, reason=&quot;deprecated function&quot;)</span>
<span class="gd">-    def fun():</span>
<span class="gd">-        print(&quot;fun&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    warnings.simplefilter(&quot;once&quot;, category=DeprecationWarning)</span>
<span class="gd">-</span>
<span class="gd">-    with warnings.catch_warnings(record=True) as warns:</span>
<span class="gd">-        fun()</span>
<span class="gd">-        fun()</span>
<span class="gd">-    assert len(warns) == 1</span>
<span class="gi">+        return Foo.foo</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_function(self):</span>
<span class="gi">+        foo = self._get_deprecated_func()</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Function foo is deprecated.&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_class(self):</span>
<span class="gi">+        Foo = self._get_deprecated_class()</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            Foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Class Foo is deprecated.&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_method(self):</span>
<span class="gi">+        Foo = self._get_deprecated_method()</span>
<span class="gi">+        foo = Foo()</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo.foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Method foo is deprecated.&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_static_method(self):</span>
<span class="gi">+        foo = self._get_deprecated_static_method()</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Function foo is deprecated.&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_with_reason(self):</span>
<span class="gi">+        foo = self._get_deprecated_func(reason=&quot;Good reason&quot;)</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Function foo is deprecated. Good reason&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_with_version(self):</span>
<span class="gi">+        foo = self._get_deprecated_func(version=&quot;1.2.3&quot;)</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, DeprecationWarning))</span>
<span class="gi">+            self.assertIn(&quot;Function foo is deprecated. -- Deprecated since version 1.2.3.&quot;, str(w[-1].message))</span>
<span class="gi">+</span>
<span class="gi">+    def test_deprecated_with_custom_warning(self):</span>
<span class="gi">+        foo = self._get_deprecated_func(category=MyDeprecationWarning)</span>
<span class="gi">+        with warnings.catch_warnings(record=True) as w:</span>
<span class="gi">+            warnings.simplefilter(&quot;always&quot;)</span>
<span class="gi">+            foo()</span>
<span class="gi">+            self.assertEqual(len(w), 1)</span>
<span class="gi">+            self.assertTrue(issubclass(w[-1].category, MyDeprecationWarning))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+    unittest.main()</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>