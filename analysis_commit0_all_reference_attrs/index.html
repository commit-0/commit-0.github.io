
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference attrs - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-attrs" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference attrs
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_setattrpytestsetattrtest_slotted_confused" class="md-nav__link">
    <span class="md-ellipsis">
      test_setattr.py::TestSetAttr::test_slotted_confused
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-attrs"><strong>Reference (Gold)</strong>: attrs</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1414</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1419</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1419</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_setattrpytestsetattrtest_slotted_confused">test_setattr.py::TestSetAttr::test_slotted_confused</h3>
<details><summary> <pre>test_setattr.py::TestSetAttr::test_slotted_confused</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/attr/_cmp.py b/src/attr/_cmp.py</span>
<span class="gh">index 875bde6..f367bb3 100644</span>
<span class="gd">--- a/src/attr/_cmp.py</span>
<span class="gi">+++ b/src/attr/_cmp.py</span>
<span class="gu">@@ -1,11 +1,24 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import types
<span class="gi">+</span>
<span class="w"> </span>from ._make import _make_ne
<span class="gd">-_operation_names = {&#39;eq&#39;: &#39;==&#39;, &#39;lt&#39;: &#39;&lt;&#39;, &#39;le&#39;: &#39;&lt;=&#39;, &#39;gt&#39;: &#39;&gt;&#39;, &#39;ge&#39;: &#39;&gt;=&#39;}</span>


<span class="gd">-def cmp_using(eq=None, lt=None, le=None, gt=None, ge=None,</span>
<span class="gd">-    require_same_type=True, class_name=&#39;Comparable&#39;):</span>
<span class="gi">+_operation_names = {&quot;eq&quot;: &quot;==&quot;, &quot;lt&quot;: &quot;&lt;&quot;, &quot;le&quot;: &quot;&lt;=&quot;, &quot;gt&quot;: &quot;&gt;&quot;, &quot;ge&quot;: &quot;&gt;=&quot;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cmp_using(</span>
<span class="gi">+    eq=None,</span>
<span class="gi">+    lt=None,</span>
<span class="gi">+    le=None,</span>
<span class="gi">+    gt=None,</span>
<span class="gi">+    ge=None,</span>
<span class="gi">+    require_same_type=True,</span>
<span class="gi">+    class_name=&quot;Comparable&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a class that can be passed into `attrs.field`&#39;s ``eq``, ``order``,
<span class="w"> </span>    and ``cmp`` arguments to customize field comparison.
<span class="gu">@@ -43,32 +56,105 @@ def cmp_using(eq=None, lt=None, le=None, gt=None, ge=None,</span>

<span class="w"> </span>    .. versionadded:: 21.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    body = {</span>
<span class="gi">+        &quot;__slots__&quot;: [&quot;value&quot;],</span>
<span class="gi">+        &quot;__init__&quot;: _make_init(),</span>
<span class="gi">+        &quot;_requirements&quot;: [],</span>
<span class="gi">+        &quot;_is_comparable_to&quot;: _is_comparable_to,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Add operations.</span>
<span class="gi">+    num_order_functions = 0</span>
<span class="gi">+    has_eq_function = False</span>
<span class="gi">+</span>
<span class="gi">+    if eq is not None:</span>
<span class="gi">+        has_eq_function = True</span>
<span class="gi">+        body[&quot;__eq__&quot;] = _make_operator(&quot;eq&quot;, eq)</span>
<span class="gi">+        body[&quot;__ne__&quot;] = _make_ne()</span>
<span class="gi">+</span>
<span class="gi">+    if lt is not None:</span>
<span class="gi">+        num_order_functions += 1</span>
<span class="gi">+        body[&quot;__lt__&quot;] = _make_operator(&quot;lt&quot;, lt)</span>
<span class="gi">+</span>
<span class="gi">+    if le is not None:</span>
<span class="gi">+        num_order_functions += 1</span>
<span class="gi">+        body[&quot;__le__&quot;] = _make_operator(&quot;le&quot;, le)</span>
<span class="gi">+</span>
<span class="gi">+    if gt is not None:</span>
<span class="gi">+        num_order_functions += 1</span>
<span class="gi">+        body[&quot;__gt__&quot;] = _make_operator(&quot;gt&quot;, gt)</span>
<span class="gi">+</span>
<span class="gi">+    if ge is not None:</span>
<span class="gi">+        num_order_functions += 1</span>
<span class="gi">+        body[&quot;__ge__&quot;] = _make_operator(&quot;ge&quot;, ge)</span>
<span class="gi">+</span>
<span class="gi">+    type_ = types.new_class(</span>
<span class="gi">+        class_name, (object,), {}, lambda ns: ns.update(body)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Add same type requirement.</span>
<span class="gi">+    if require_same_type:</span>
<span class="gi">+        type_._requirements.append(_check_same_type)</span>
<span class="gi">+</span>
<span class="gi">+    # Add total ordering if at least one operation was defined.</span>
<span class="gi">+    if 0 &lt; num_order_functions &lt; 4:</span>
<span class="gi">+        if not has_eq_function:</span>
<span class="gi">+            # functools.total_ordering requires __eq__ to be defined,</span>
<span class="gi">+            # so raise early error here to keep a nice stack.</span>
<span class="gi">+            msg = &quot;eq must be define is order to complete ordering from lt, le, gt, ge.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        type_ = functools.total_ordering(type_)</span>
<span class="gi">+</span>
<span class="gi">+    return type_</span>


<span class="w"> </span>def _make_init():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create __init__ method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, value):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Initialize object with *value*.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        self.value = value</span>
<span class="gi">+</span>
<span class="gi">+    return __init__</span>


<span class="w"> </span>def _make_operator(name, func):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create operator method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def method(self, other):</span>
<span class="gi">+        if not self._is_comparable_to(other):</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        result = func(self.value, other.value)</span>
<span class="gi">+        if result is NotImplemented:</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    method.__name__ = f&quot;__{name}__&quot;</span>
<span class="gi">+    method.__doc__ = (</span>
<span class="gi">+        f&quot;Return a {_operation_names[name]} b.  Computed by attrs.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return method</span>


<span class="w"> </span>def _is_comparable_to(self, other):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether `other` is comparable to `self`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(func(self, other) for func in self._requirements)</span>


<span class="w"> </span>def _check_same_type(self, other):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return True if *self* and *other* are of the same type, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return other.value.__class__ is self.value.__class__</span>
<span class="gh">diff --git a/src/attr/_compat.py b/src/attr/_compat.py</span>
<span class="gh">index 1afacff..104eeb0 100644</span>
<span class="gd">--- a/src/attr/_compat.py</span>
<span class="gi">+++ b/src/attr/_compat.py</span>
<span class="gu">@@ -1,10 +1,15 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>import inspect
<span class="w"> </span>import platform
<span class="w"> </span>import sys
<span class="w"> </span>import threading
<span class="gd">-from collections.abc import Mapping, Sequence</span>
<span class="gi">+</span>
<span class="gi">+from collections.abc import Mapping, Sequence  # noqa: F401</span>
<span class="w"> </span>from typing import _GenericAlias
<span class="gd">-PYPY = platform.python_implementation() == &#39;PyPy&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PYPY = platform.python_implementation() == &quot;PyPy&quot;</span>
<span class="w"> </span>PY_3_8_PLUS = sys.version_info[:2] &gt;= (3, 8)
<span class="w"> </span>PY_3_9_PLUS = sys.version_info[:2] &gt;= (3, 9)
<span class="w"> </span>PY_3_10_PLUS = sys.version_info[:2] &gt;= (3, 10)
<span class="gu">@@ -12,23 +17,28 @@ PY_3_11_PLUS = sys.version_info[:2] &gt;= (3, 11)</span>
<span class="w"> </span>PY_3_12_PLUS = sys.version_info[:2] &gt;= (3, 12)
<span class="w"> </span>PY_3_13_PLUS = sys.version_info[:2] &gt;= (3, 13)
<span class="w"> </span>PY_3_14_PLUS = sys.version_info[:2] &gt;= (3, 14)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &lt; (3, 8):
<span class="w"> </span>    try:
<span class="w"> </span>        from typing_extensions import Protocol
<span class="gd">-    except ImportError:</span>
<span class="gi">+    except ImportError:  # pragma: no cover</span>
<span class="w"> </span>        Protocol = object
<span class="w"> </span>else:
<span class="gd">-    from typing import Protocol</span>
<span class="gd">-if PY_3_14_PLUS:</span>
<span class="gi">+    from typing import Protocol  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+if PY_3_14_PLUS:  # pragma: no cover</span>
<span class="w"> </span>    import annotationlib
<span class="gi">+</span>
<span class="w"> </span>    _get_annotations = annotationlib.get_annotations
<span class="gi">+</span>
<span class="w"> </span>else:

<span class="w"> </span>    def _get_annotations(cls):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get annotations for *cls*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls.__dict__.get(&quot;__annotations__&quot;, {})</span>


<span class="w"> </span>class _AnnotationExtractor:
<span class="gu">@@ -36,30 +46,58 @@ class _AnnotationExtractor:</span>
<span class="w"> </span>    Extract type annotations from a callable, returning None whenever there
<span class="w"> </span>    is none.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;sig&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;sig&quot;]</span>

<span class="w"> </span>    def __init__(self, callable):
<span class="w"> </span>        try:
<span class="w"> </span>            self.sig = inspect.signature(callable)
<span class="gd">-        except (ValueError, TypeError):</span>
<span class="gi">+        except (ValueError, TypeError):  # inspect failed</span>
<span class="w"> </span>            self.sig = None

<span class="w"> </span>    def get_first_param_type(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the type annotation of the first argument if it&#39;s not empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.sig:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        params = list(self.sig.parameters.values())</span>
<span class="gi">+        if params and params[0].annotation is not inspect.Parameter.empty:</span>
<span class="gi">+            return params[0].annotation</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_return_type(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the return type if it&#39;s not empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.sig</span>
<span class="gi">+            and self.sig.return_annotation is not inspect.Signature.empty</span>
<span class="gi">+        ):</span>
<span class="gi">+            return self.sig.return_annotation</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>


<span class="gi">+# Thread-local global to track attrs instances which are already being repr&#39;d.</span>
<span class="gi">+# This is needed because there is no other (thread-safe) way to pass info</span>
<span class="gi">+# about the instances that are already being repr&#39;d through the call stack</span>
<span class="gi">+# in order to ensure we don&#39;t perform infinite recursion.</span>
<span class="gi">+#</span>
<span class="gi">+# For instance, if an instance contains a dict which contains that instance,</span>
<span class="gi">+# we need to know that we&#39;re already repr&#39;ing the outside instance from within</span>
<span class="gi">+# the dict&#39;s repr() call.</span>
<span class="gi">+#</span>
<span class="gi">+# This lives here rather than in _make.py so that the functions in _make.py</span>
<span class="gi">+# don&#39;t have a direct reference to the thread-local in their globals dict.</span>
<span class="gi">+# If they have such a reference, it breaks cloudpickle.</span>
<span class="w"> </span>repr_context = threading.local()


<span class="w"> </span>def get_generic_base(cl):
<span class="w"> </span>    &quot;&quot;&quot;If this is a generic class (A[str]), return the generic base for it.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cl.__class__ is _GenericAlias:</span>
<span class="gi">+        return cl.__origin__</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/src/attr/_config.py b/src/attr/_config.py</span>
<span class="gh">index cfa2d9b..9c245b1 100644</span>
<span class="gd">--- a/src/attr/_config.py</span>
<span class="gi">+++ b/src/attr/_config.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gd">-__all__ = [&#39;set_run_validators&#39;, &#39;get_run_validators&#39;]</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;set_run_validators&quot;, &quot;get_run_validators&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>_run_validators = True


<span class="gu">@@ -10,7 +13,11 @@ def set_run_validators(run):</span>
<span class="w"> </span>        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`
<span class="w"> </span>        instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(run, bool):</span>
<span class="gi">+        msg = &quot;&#39;run&#39; must be bool.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+    global _run_validators</span>
<span class="gi">+    _run_validators = run</span>


<span class="w"> </span>def get_run_validators():
<span class="gu">@@ -21,4 +28,4 @@ def get_run_validators():</span>
<span class="w"> </span>        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`
<span class="w"> </span>        instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _run_validators</span>
<span class="gh">diff --git a/src/attr/_funcs.py b/src/attr/_funcs.py</span>
<span class="gh">index 4c9728a..355cef4 100644</span>
<span class="gd">--- a/src/attr/_funcs.py</span>
<span class="gi">+++ b/src/attr/_funcs.py</span>
<span class="gu">@@ -1,11 +1,21 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="gi">+</span>
<span class="w"> </span>from ._compat import PY_3_9_PLUS, get_generic_base
<span class="w"> </span>from ._make import _OBJ_SETATTR, NOTHING, fields
<span class="w"> </span>from .exceptions import AttrsAttributeNotFoundError


<span class="gd">-def asdict(inst, recurse=True, filter=None, dict_factory=dict,</span>
<span class="gd">-    retain_collection_types=False, value_serializer=None):</span>
<span class="gi">+def asdict(</span>
<span class="gi">+    inst,</span>
<span class="gi">+    recurse=True,</span>
<span class="gi">+    filter=None,</span>
<span class="gi">+    dict_factory=dict,</span>
<span class="gi">+    retain_collection_types=False,</span>
<span class="gi">+    value_serializer=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the *attrs* attribute values of *inst* as a dict.

<span class="gu">@@ -50,19 +60,157 @@ def asdict(inst, recurse=True, filter=None, dict_factory=dict,</span>
<span class="w"> </span>    ..  versionadded:: 21.3.0
<span class="w"> </span>        If a dict has a collection for a key, it is serialized as a tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _asdict_anything(val, is_key, filter, dict_factory,</span>
<span class="gd">-    retain_collection_types, value_serializer):</span>
<span class="gi">+    attrs = fields(inst.__class__)</span>
<span class="gi">+    rv = dict_factory()</span>
<span class="gi">+    for a in attrs:</span>
<span class="gi">+        v = getattr(inst, a.name)</span>
<span class="gi">+        if filter is not None and not filter(a, v):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if value_serializer is not None:</span>
<span class="gi">+            v = value_serializer(inst, a, v)</span>
<span class="gi">+</span>
<span class="gi">+        if recurse is True:</span>
<span class="gi">+            if has(v.__class__):</span>
<span class="gi">+                rv[a.name] = asdict(</span>
<span class="gi">+                    v,</span>
<span class="gi">+                    recurse=True,</span>
<span class="gi">+                    filter=filter,</span>
<span class="gi">+                    dict_factory=dict_factory,</span>
<span class="gi">+                    retain_collection_types=retain_collection_types,</span>
<span class="gi">+                    value_serializer=value_serializer,</span>
<span class="gi">+                )</span>
<span class="gi">+            elif isinstance(v, (tuple, list, set, frozenset)):</span>
<span class="gi">+                cf = v.__class__ if retain_collection_types is True else list</span>
<span class="gi">+                items = [</span>
<span class="gi">+                    _asdict_anything(</span>
<span class="gi">+                        i,</span>
<span class="gi">+                        is_key=False,</span>
<span class="gi">+                        filter=filter,</span>
<span class="gi">+                        dict_factory=dict_factory,</span>
<span class="gi">+                        retain_collection_types=retain_collection_types,</span>
<span class="gi">+                        value_serializer=value_serializer,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for i in v</span>
<span class="gi">+                ]</span>
<span class="gi">+                try:</span>
<span class="gi">+                    rv[a.name] = cf(items)</span>
<span class="gi">+                except TypeError:</span>
<span class="gi">+                    if not issubclass(cf, tuple):</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    # Workaround for TypeError: cf.__new__() missing 1 required</span>
<span class="gi">+                    # positional argument (which appears, for a namedturle)</span>
<span class="gi">+                    rv[a.name] = cf(*items)</span>
<span class="gi">+            elif isinstance(v, dict):</span>
<span class="gi">+                df = dict_factory</span>
<span class="gi">+                rv[a.name] = df(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        _asdict_anything(</span>
<span class="gi">+                            kk,</span>
<span class="gi">+                            is_key=True,</span>
<span class="gi">+                            filter=filter,</span>
<span class="gi">+                            dict_factory=df,</span>
<span class="gi">+                            retain_collection_types=retain_collection_types,</span>
<span class="gi">+                            value_serializer=value_serializer,</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        _asdict_anything(</span>
<span class="gi">+                            vv,</span>
<span class="gi">+                            is_key=False,</span>
<span class="gi">+                            filter=filter,</span>
<span class="gi">+                            dict_factory=df,</span>
<span class="gi">+                            retain_collection_types=retain_collection_types,</span>
<span class="gi">+                            value_serializer=value_serializer,</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for kk, vv in v.items()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                rv[a.name] = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            rv[a.name] = v</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _asdict_anything(</span>
<span class="gi">+    val,</span>
<span class="gi">+    is_key,</span>
<span class="gi">+    filter,</span>
<span class="gi">+    dict_factory,</span>
<span class="gi">+    retain_collection_types,</span>
<span class="gi">+    value_serializer,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    ``asdict`` only works on attrs instances, this works on anything.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def astuple(inst, recurse=True, filter=None, tuple_factory=tuple,</span>
<span class="gd">-    retain_collection_types=False):</span>
<span class="gi">+    if getattr(val.__class__, &quot;__attrs_attrs__&quot;, None) is not None:</span>
<span class="gi">+        # Attrs class.</span>
<span class="gi">+        rv = asdict(</span>
<span class="gi">+            val,</span>
<span class="gi">+            recurse=True,</span>
<span class="gi">+            filter=filter,</span>
<span class="gi">+            dict_factory=dict_factory,</span>
<span class="gi">+            retain_collection_types=retain_collection_types,</span>
<span class="gi">+            value_serializer=value_serializer,</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(val, (tuple, list, set, frozenset)):</span>
<span class="gi">+        if retain_collection_types is True:</span>
<span class="gi">+            cf = val.__class__</span>
<span class="gi">+        elif is_key:</span>
<span class="gi">+            cf = tuple</span>
<span class="gi">+        else:</span>
<span class="gi">+            cf = list</span>
<span class="gi">+</span>
<span class="gi">+        rv = cf(</span>
<span class="gi">+            [</span>
<span class="gi">+                _asdict_anything(</span>
<span class="gi">+                    i,</span>
<span class="gi">+                    is_key=False,</span>
<span class="gi">+                    filter=filter,</span>
<span class="gi">+                    dict_factory=dict_factory,</span>
<span class="gi">+                    retain_collection_types=retain_collection_types,</span>
<span class="gi">+                    value_serializer=value_serializer,</span>
<span class="gi">+                )</span>
<span class="gi">+                for i in val</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(val, dict):</span>
<span class="gi">+        df = dict_factory</span>
<span class="gi">+        rv = df(</span>
<span class="gi">+            (</span>
<span class="gi">+                _asdict_anything(</span>
<span class="gi">+                    kk,</span>
<span class="gi">+                    is_key=True,</span>
<span class="gi">+                    filter=filter,</span>
<span class="gi">+                    dict_factory=df,</span>
<span class="gi">+                    retain_collection_types=retain_collection_types,</span>
<span class="gi">+                    value_serializer=value_serializer,</span>
<span class="gi">+                ),</span>
<span class="gi">+                _asdict_anything(</span>
<span class="gi">+                    vv,</span>
<span class="gi">+                    is_key=False,</span>
<span class="gi">+                    filter=filter,</span>
<span class="gi">+                    dict_factory=df,</span>
<span class="gi">+                    retain_collection_types=retain_collection_types,</span>
<span class="gi">+                    value_serializer=value_serializer,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            for kk, vv in val.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        rv = val</span>
<span class="gi">+        if value_serializer is not None:</span>
<span class="gi">+            rv = value_serializer(None, None, rv)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def astuple(</span>
<span class="gi">+    inst,</span>
<span class="gi">+    recurse=True,</span>
<span class="gi">+    filter=None,</span>
<span class="gi">+    tuple_factory=tuple,</span>
<span class="gi">+    retain_collection_types=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the *attrs* attribute values of *inst* as a tuple.

<span class="gu">@@ -98,7 +246,81 @@ def astuple(inst, recurse=True, filter=None, tuple_factory=tuple,</span>

<span class="w"> </span>    ..  versionadded:: 16.2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs = fields(inst.__class__)</span>
<span class="gi">+    rv = []</span>
<span class="gi">+    retain = retain_collection_types  # Very long. :/</span>
<span class="gi">+    for a in attrs:</span>
<span class="gi">+        v = getattr(inst, a.name)</span>
<span class="gi">+        if filter is not None and not filter(a, v):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if recurse is True:</span>
<span class="gi">+            if has(v.__class__):</span>
<span class="gi">+                rv.append(</span>
<span class="gi">+                    astuple(</span>
<span class="gi">+                        v,</span>
<span class="gi">+                        recurse=True,</span>
<span class="gi">+                        filter=filter,</span>
<span class="gi">+                        tuple_factory=tuple_factory,</span>
<span class="gi">+                        retain_collection_types=retain,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            elif isinstance(v, (tuple, list, set, frozenset)):</span>
<span class="gi">+                cf = v.__class__ if retain is True else list</span>
<span class="gi">+                items = [</span>
<span class="gi">+                    (</span>
<span class="gi">+                        astuple(</span>
<span class="gi">+                            j,</span>
<span class="gi">+                            recurse=True,</span>
<span class="gi">+                            filter=filter,</span>
<span class="gi">+                            tuple_factory=tuple_factory,</span>
<span class="gi">+                            retain_collection_types=retain,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if has(j.__class__)</span>
<span class="gi">+                        else j</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for j in v</span>
<span class="gi">+                ]</span>
<span class="gi">+                try:</span>
<span class="gi">+                    rv.append(cf(items))</span>
<span class="gi">+                except TypeError:</span>
<span class="gi">+                    if not issubclass(cf, tuple):</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    # Workaround for TypeError: cf.__new__() missing 1 required</span>
<span class="gi">+                    # positional argument (which appears, for a namedturle)</span>
<span class="gi">+                    rv.append(cf(*items))</span>
<span class="gi">+            elif isinstance(v, dict):</span>
<span class="gi">+                df = v.__class__ if retain is True else dict</span>
<span class="gi">+                rv.append(</span>
<span class="gi">+                    df(</span>
<span class="gi">+                        (</span>
<span class="gi">+                            (</span>
<span class="gi">+                                astuple(</span>
<span class="gi">+                                    kk,</span>
<span class="gi">+                                    tuple_factory=tuple_factory,</span>
<span class="gi">+                                    retain_collection_types=retain,</span>
<span class="gi">+                                )</span>
<span class="gi">+                                if has(kk.__class__)</span>
<span class="gi">+                                else kk</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            (</span>
<span class="gi">+                                astuple(</span>
<span class="gi">+                                    vv,</span>
<span class="gi">+                                    tuple_factory=tuple_factory,</span>
<span class="gi">+                                    retain_collection_types=retain,</span>
<span class="gi">+                                )</span>
<span class="gi">+                                if has(vv.__class__)</span>
<span class="gi">+                                else vv</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        )</span>
<span class="gi">+                        for kk, vv in v.items()</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                rv.append(v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            rv.append(v)</span>
<span class="gi">+</span>
<span class="gi">+    return rv if tuple_factory is list else tuple_factory(rv)</span>


<span class="w"> </span>def has(cls):
<span class="gu">@@ -114,7 +336,19 @@ def has(cls):</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs = getattr(cls, &quot;__attrs_attrs__&quot;, None)</span>
<span class="gi">+    if attrs is not None:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # No attrs, maybe it&#39;s a specialized generic (A[str])?</span>
<span class="gi">+    generic_base = get_generic_base(cls)</span>
<span class="gi">+    if generic_base is not None:</span>
<span class="gi">+        generic_attrs = getattr(generic_base, &quot;__attrs_attrs__&quot;, None)</span>
<span class="gi">+        if generic_attrs is not None:</span>
<span class="gi">+            # Stick it on here for speed next time.</span>
<span class="gi">+            cls.__attrs_attrs__ = generic_attrs</span>
<span class="gi">+        return generic_attrs is not None</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def assoc(inst, **changes):
<span class="gu">@@ -149,7 +383,15 @@ def assoc(inst, **changes):</span>
<span class="w"> </span>        removed du to the slightly different approach compared to
<span class="w"> </span>        `attrs.evolve`, though.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new = copy.copy(inst)</span>
<span class="gi">+    attrs = fields(inst.__class__)</span>
<span class="gi">+    for k, v in changes.items():</span>
<span class="gi">+        a = getattr(attrs, k, NOTHING)</span>
<span class="gi">+        if a is NOTHING:</span>
<span class="gi">+            msg = f&quot;{k} is not an attrs attribute on {new.__class__}.&quot;</span>
<span class="gi">+            raise AttrsAttributeNotFoundError(msg)</span>
<span class="gi">+        _OBJ_SETATTR(new, k, v)</span>
<span class="gi">+    return new</span>


<span class="w"> </span>def evolve(*args, **changes):
<span class="gu">@@ -185,11 +427,30 @@ def evolve(*args, **changes):</span>
<span class="w"> </span>    .. versionchanged:: 24.1.0
<span class="w"> </span>       *inst* can&#39;t be passed as a keyword argument anymore.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def resolve_types(cls, globalns=None, localns=None, attribs=None,</span>
<span class="gd">-    include_extras=True):</span>
<span class="gi">+    try:</span>
<span class="gi">+        (inst,) = args</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            f&quot;evolve() takes 1 positional argument, but {len(args)} were given&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise TypeError(msg) from None</span>
<span class="gi">+</span>
<span class="gi">+    cls = inst.__class__</span>
<span class="gi">+    attrs = fields(cls)</span>
<span class="gi">+    for a in attrs:</span>
<span class="gi">+        if not a.init:</span>
<span class="gi">+            continue</span>
<span class="gi">+        attr_name = a.name  # To deal with private attributes.</span>
<span class="gi">+        init_name = a.alias</span>
<span class="gi">+        if init_name not in changes:</span>
<span class="gi">+            changes[init_name] = getattr(inst, attr_name)</span>
<span class="gi">+</span>
<span class="gi">+    return cls(**changes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_types(</span>
<span class="gi">+    cls, globalns=None, localns=None, attribs=None, include_extras=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Resolve any strings and forward annotations in type annotations.

<span class="gu">@@ -238,4 +499,24 @@ def resolve_types(cls, globalns=None, localns=None, attribs=None,</span>
<span class="w"> </span>    ..  versionadded:: 21.1.0 *attribs*
<span class="w"> </span>    ..  versionadded:: 23.1.0 *include_extras*
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Since calling get_type_hints is expensive we cache whether we&#39;ve</span>
<span class="gi">+    # done it already.</span>
<span class="gi">+    if getattr(cls, &quot;__attrs_types_resolved__&quot;, None) != cls:</span>
<span class="gi">+        import typing</span>
<span class="gi">+</span>
<span class="gi">+        kwargs = {&quot;globalns&quot;: globalns, &quot;localns&quot;: localns}</span>
<span class="gi">+</span>
<span class="gi">+        if PY_3_9_PLUS:</span>
<span class="gi">+            kwargs[&quot;include_extras&quot;] = include_extras</span>
<span class="gi">+</span>
<span class="gi">+        hints = typing.get_type_hints(cls, **kwargs)</span>
<span class="gi">+        for field in fields(cls) if attribs is None else attribs:</span>
<span class="gi">+            if field.name in hints:</span>
<span class="gi">+                # Since fields have been frozen we must work around it.</span>
<span class="gi">+                _OBJ_SETATTR(field, &quot;type&quot;, hints[field.name])</span>
<span class="gi">+        # We store the class we resolved so that subclasses know they haven&#39;t</span>
<span class="gi">+        # been resolved.</span>
<span class="gi">+        cls.__attrs_types_resolved__ = cls</span>
<span class="gi">+</span>
<span class="gi">+    # Return the class so you can use it as a decorator too.</span>
<span class="gi">+    return cls</span>
<span class="gh">diff --git a/src/attr/_make.py b/src/attr/_make.py</span>
<span class="gh">index f3ed380..bf00c5f 100644</span>
<span class="gd">--- a/src/attr/_make.py</span>
<span class="gi">+++ b/src/attr/_make.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import contextlib
<span class="w"> </span>import copy
<span class="gu">@@ -10,17 +13,47 @@ import linecache</span>
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="gi">+# We need to import _compat itself in addition to the _compat members to avoid</span>
<span class="gi">+# having the thread-local in the globals here.</span>
<span class="w"> </span>from . import _compat, _config, setters
<span class="gd">-from ._compat import PY_3_8_PLUS, PY_3_10_PLUS, PY_3_11_PLUS, _AnnotationExtractor, _get_annotations, get_generic_base</span>
<span class="gd">-from .exceptions import DefaultAlreadySetError, FrozenInstanceError, NotAnAttrsClassError, UnannotatedAttributeError</span>
<span class="gi">+from ._compat import (</span>
<span class="gi">+    PY_3_8_PLUS,</span>
<span class="gi">+    PY_3_10_PLUS,</span>
<span class="gi">+    PY_3_11_PLUS,</span>
<span class="gi">+    _AnnotationExtractor,</span>
<span class="gi">+    _get_annotations,</span>
<span class="gi">+    get_generic_base,</span>
<span class="gi">+)</span>
<span class="gi">+from .exceptions import (</span>
<span class="gi">+    DefaultAlreadySetError,</span>
<span class="gi">+    FrozenInstanceError,</span>
<span class="gi">+    NotAnAttrsClassError,</span>
<span class="gi">+    UnannotatedAttributeError,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This is used at least twice, so cache it here.</span>
<span class="w"> </span>_OBJ_SETATTR = object.__setattr__
<span class="gd">-_INIT_FACTORY_PAT = &#39;__attr_factory_%s&#39;</span>
<span class="gd">-_CLASSVAR_PREFIXES = (&#39;typing.ClassVar&#39;, &#39;t.ClassVar&#39;, &#39;ClassVar&#39;,</span>
<span class="gd">-    &#39;typing_extensions.ClassVar&#39;)</span>
<span class="gd">-_HASH_CACHE_FIELD = &#39;_attrs_cached_hash&#39;</span>
<span class="gi">+_INIT_FACTORY_PAT = &quot;__attr_factory_%s&quot;</span>
<span class="gi">+_CLASSVAR_PREFIXES = (</span>
<span class="gi">+    &quot;typing.ClassVar&quot;,</span>
<span class="gi">+    &quot;t.ClassVar&quot;,</span>
<span class="gi">+    &quot;ClassVar&quot;,</span>
<span class="gi">+    &quot;typing_extensions.ClassVar&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+# we don&#39;t use a double-underscore prefix because that triggers</span>
<span class="gi">+# name mangling when trying to create a slot for the field</span>
<span class="gi">+# (when slots=True)</span>
<span class="gi">+_HASH_CACHE_FIELD = &quot;_attrs_cached_hash&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>_EMPTY_METADATA_SINGLETON = types.MappingProxyType({})
<span class="gi">+</span>
<span class="gi">+# Unique object for unequivocal getattr() defaults.</span>
<span class="w"> </span>_SENTINEL = object()
<span class="gi">+</span>
<span class="w"> </span>_DEFAULT_ON_SETATTR = setters.pipe(setters.convert, setters.validate)


<span class="gu">@@ -34,10 +67,11 @@ class _Nothing(enum.Enum):</span>
<span class="w"> </span>    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.
<span class="w"> </span>    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    NOTHING = enum.auto()

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;NOTHING&#39;</span>
<span class="gi">+        return &quot;NOTHING&quot;</span>

<span class="w"> </span>    def __bool__(self):
<span class="w"> </span>        return False
<span class="gu">@@ -61,13 +95,27 @@ class _CacheHashWrapper(int):</span>
<span class="w"> </span>    See GH #613 for more details.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __reduce__(self, _none_constructor=type(None), _args=()):</span>
<span class="gi">+    def __reduce__(self, _none_constructor=type(None), _args=()):  # noqa: B008</span>
<span class="w"> </span>        return _none_constructor, _args


<span class="gd">-def attrib(default=NOTHING, validator=None, repr=True, cmp=None, hash=None,</span>
<span class="gd">-    init=True, metadata=None, type=None, converter=None, factory=None,</span>
<span class="gd">-    kw_only=False, eq=None, order=None, on_setattr=None, alias=None):</span>
<span class="gi">+def attrib(</span>
<span class="gi">+    default=NOTHING,</span>
<span class="gi">+    validator=None,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    cmp=None,</span>
<span class="gi">+    hash=None,</span>
<span class="gi">+    init=True,</span>
<span class="gi">+    metadata=None,</span>
<span class="gi">+    type=None,</span>
<span class="gi">+    converter=None,</span>
<span class="gi">+    factory=None,</span>
<span class="gi">+    kw_only=False,</span>
<span class="gi">+    eq=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+    on_setattr=None,</span>
<span class="gi">+    alias=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new field / attribute on a class.

<span class="gu">@@ -106,22 +154,94 @@ def attrib(default=NOTHING, validator=None, repr=True, cmp=None, hash=None,</span>
<span class="w"> </span>    .. versionchanged:: 21.1.0 *cmp* undeprecated
<span class="w"> </span>    .. versionadded:: 22.2.0 *alias*
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _compile_and_eval(script, globs, locs=None, filename=&#39;&#39;):</span>
<span class="gi">+    eq, eq_key, order, order_key = _determine_attrib_eq_order(</span>
<span class="gi">+        cmp, eq, order, True</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if hash is not None and hash is not True and hash is not False:</span>
<span class="gi">+        msg = &quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if factory is not None:</span>
<span class="gi">+        if default is not NOTHING:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;The `default` and `factory` arguments are mutually exclusive.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        if not callable(factory):</span>
<span class="gi">+            msg = &quot;The `factory` argument must be a callable.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        default = Factory(factory)</span>
<span class="gi">+</span>
<span class="gi">+    if metadata is None:</span>
<span class="gi">+        metadata = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Apply syntactic sugar by auto-wrapping.</span>
<span class="gi">+    if isinstance(on_setattr, (list, tuple)):</span>
<span class="gi">+        on_setattr = setters.pipe(*on_setattr)</span>
<span class="gi">+</span>
<span class="gi">+    if validator and isinstance(validator, (list, tuple)):</span>
<span class="gi">+        validator = and_(*validator)</span>
<span class="gi">+</span>
<span class="gi">+    if converter and isinstance(converter, (list, tuple)):</span>
<span class="gi">+        converter = pipe(*converter)</span>
<span class="gi">+</span>
<span class="gi">+    return _CountingAttr(</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        validator=validator,</span>
<span class="gi">+        repr=repr,</span>
<span class="gi">+        cmp=None,</span>
<span class="gi">+        hash=hash,</span>
<span class="gi">+        init=init,</span>
<span class="gi">+        converter=converter,</span>
<span class="gi">+        metadata=metadata,</span>
<span class="gi">+        type=type,</span>
<span class="gi">+        kw_only=kw_only,</span>
<span class="gi">+        eq=eq,</span>
<span class="gi">+        eq_key=eq_key,</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        order_key=order_key,</span>
<span class="gi">+        on_setattr=on_setattr,</span>
<span class="gi">+        alias=alias,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _compile_and_eval(script, globs, locs=None, filename=&quot;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Evaluate the script with the given global (globs) and local (locs)
<span class="w"> </span>    variables.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bytecode = compile(script, filename, &quot;exec&quot;)</span>
<span class="gi">+    eval(bytecode, globs, locs)</span>


<span class="w"> </span>def _make_method(name, script, filename, globs, locals=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create the method with the script given and return the method object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    locs = {} if locals is None else locals</span>
<span class="gi">+</span>
<span class="gi">+    # In order of debuggers like PDB being able to step through the code,</span>
<span class="gi">+    # we add a fake linecache entry.</span>
<span class="gi">+    count = 1</span>
<span class="gi">+    base_filename = filename</span>
<span class="gi">+    while True:</span>
<span class="gi">+        linecache_tuple = (</span>
<span class="gi">+            len(script),</span>
<span class="gi">+            None,</span>
<span class="gi">+            script.splitlines(True),</span>
<span class="gi">+            filename,</span>
<span class="gi">+        )</span>
<span class="gi">+        old_val = linecache.cache.setdefault(filename, linecache_tuple)</span>
<span class="gi">+        if old_val == linecache_tuple:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        filename = f&quot;{base_filename[:-1]}-{count}&gt;&quot;</span>
<span class="gi">+        count += 1</span>
<span class="gi">+</span>
<span class="gi">+    _compile_and_eval(script, globs, locs, filename)</span>
<span class="gi">+</span>
<span class="gi">+    return locs[name]</span>


<span class="w"> </span>def _make_attr_tuple_class(cls_name, attr_names):
<span class="gu">@@ -134,11 +254,36 @@ def _make_attr_tuple_class(cls_name, attr_names):</span>
<span class="w"> </span>        __slots__ = ()
<span class="w"> </span>        x = property(itemgetter(0))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_Attributes = _make_attr_tuple_class(&#39;_Attributes&#39;, [&#39;attrs&#39;, &#39;base_attrs&#39;,</span>
<span class="gd">-    &#39;base_attrs_map&#39;])</span>
<span class="gi">+    attr_class_name = f&quot;{cls_name}Attributes&quot;</span>
<span class="gi">+    attr_class_template = [</span>
<span class="gi">+        f&quot;class {attr_class_name}(tuple):&quot;,</span>
<span class="gi">+        &quot;    __slots__ = ()&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    if attr_names:</span>
<span class="gi">+        for i, attr_name in enumerate(attr_names):</span>
<span class="gi">+            attr_class_template.append(</span>
<span class="gi">+                f&quot;    {attr_name} = _attrs_property(_attrs_itemgetter({i}))&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        attr_class_template.append(&quot;    pass&quot;)</span>
<span class="gi">+    globs = {&quot;_attrs_itemgetter&quot;: itemgetter, &quot;_attrs_property&quot;: property}</span>
<span class="gi">+    _compile_and_eval(&quot;\n&quot;.join(attr_class_template), globs)</span>
<span class="gi">+    return globs[attr_class_name]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Tuple class for extracted attributes from a class definition.</span>
<span class="gi">+# `base_attrs` is a subset of `attrs`.</span>
<span class="gi">+_Attributes = _make_attr_tuple_class(</span>
<span class="gi">+    &quot;_Attributes&quot;,</span>
<span class="gi">+    [</span>
<span class="gi">+        # all attributes to build dunder methods for</span>
<span class="gi">+        &quot;attrs&quot;,</span>
<span class="gi">+        # attributes that have been inherited</span>
<span class="gi">+        &quot;base_attrs&quot;,</span>
<span class="gi">+        # map inherited attributes to their originating classes</span>
<span class="gi">+        &quot;base_attrs_map&quot;,</span>
<span class="gi">+    ],</span>
<span class="gi">+)</span>


<span class="w"> </span>def _is_class_var(annot):
<span class="gu">@@ -149,21 +294,51 @@ def _is_class_var(annot):</span>
<span class="w"> </span>    annotations which would put attrs-based classes at a performance
<span class="w"> </span>    disadvantage compared to plain old classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annot = str(annot)</span>
<span class="gi">+</span>
<span class="gi">+    # Annotation can be quoted.</span>
<span class="gi">+    if annot.startswith((&quot;&#39;&quot;, &#39;&quot;&#39;)) and annot.endswith((&quot;&#39;&quot;, &#39;&quot;&#39;)):</span>
<span class="gi">+        annot = annot[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+    return annot.startswith(_CLASSVAR_PREFIXES)</span>


<span class="w"> </span>def _has_own_attribute(cls, attrib_name):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether *cls* defines *attrib_name* (and doesn&#39;t just inherit it).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return attrib_name in cls.__dict__</span>


<span class="w"> </span>def _collect_base_attrs(cls, taken_attr_names):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    base_attrs = []</span>
<span class="gi">+    base_attr_map = {}  # A dictionary of base attrs to their classes.</span>
<span class="gi">+</span>
<span class="gi">+    # Traverse the MRO and collect attributes.</span>
<span class="gi">+    for base_cls in reversed(cls.__mro__[1:-1]):</span>
<span class="gi">+        for a in getattr(base_cls, &quot;__attrs_attrs__&quot;, []):</span>
<span class="gi">+            if a.inherited or a.name in taken_attr_names:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            a = a.evolve(inherited=True)  # noqa: PLW2901</span>
<span class="gi">+            base_attrs.append(a)</span>
<span class="gi">+            base_attr_map[a.name] = base_cls</span>
<span class="gi">+</span>
<span class="gi">+    # For each name, only keep the freshest definition i.e. the furthest at the</span>
<span class="gi">+    # back.  base_attr_map is fine because it gets overwritten with every new</span>
<span class="gi">+    # instance.</span>
<span class="gi">+    filtered = []</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for a in reversed(base_attrs):</span>
<span class="gi">+        if a.name in seen:</span>
<span class="gi">+            continue</span>
<span class="gi">+        filtered.insert(0, a)</span>
<span class="gi">+        seen.add(a.name)</span>
<span class="gi">+</span>
<span class="gi">+    return filtered, base_attr_map</span>


<span class="w"> </span>def _collect_base_attrs_broken(cls, taken_attr_names):
<span class="gu">@@ -177,11 +352,26 @@ def _collect_base_attrs_broken(cls, taken_attr_names):</span>
<span class="w"> </span>    Notably it collects from the front and considers inherited attributes which
<span class="w"> </span>    leads to the buggy behavior reported in #428.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    base_attrs = []</span>
<span class="gi">+    base_attr_map = {}  # A dictionary of base attrs to their classes.</span>
<span class="gi">+</span>
<span class="gi">+    # Traverse the MRO and collect attributes.</span>
<span class="gi">+    for base_cls in cls.__mro__[1:-1]:</span>
<span class="gi">+        for a in getattr(base_cls, &quot;__attrs_attrs__&quot;, []):</span>
<span class="gi">+            if a.name in taken_attr_names:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            a = a.evolve(inherited=True)  # noqa: PLW2901</span>
<span class="gi">+            taken_attr_names.add(a.name)</span>
<span class="gi">+            base_attrs.append(a)</span>
<span class="gi">+            base_attr_map[a.name] = base_cls</span>

<span class="gi">+    return base_attrs, base_attr_map</span>

<span class="gd">-def _transform_attrs(cls, these, auto_attribs, kw_only, collect_by_mro,</span>
<span class="gd">-    field_transformer):</span>
<span class="gi">+</span>
<span class="gi">+def _transform_attrs(</span>
<span class="gi">+    cls, these, auto_attribs, kw_only, collect_by_mro, field_transformer</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Transform all `_CountingAttr`s on a class into `Attribute`s.

<span class="gu">@@ -192,38 +382,234 @@ def _transform_attrs(cls, these, auto_attribs, kw_only, collect_by_mro,</span>

<span class="w"> </span>    Return an `_Attributes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cd = cls.__dict__</span>
<span class="gi">+    anns = _get_annotations(cls)</span>
<span class="gi">+</span>
<span class="gi">+    if these is not None:</span>
<span class="gi">+        ca_list = list(these.items())</span>
<span class="gi">+    elif auto_attribs is True:</span>
<span class="gi">+        ca_names = {</span>
<span class="gi">+            name</span>
<span class="gi">+            for name, attr in cd.items()</span>
<span class="gi">+            if isinstance(attr, _CountingAttr)</span>
<span class="gi">+        }</span>
<span class="gi">+        ca_list = []</span>
<span class="gi">+        annot_names = set()</span>
<span class="gi">+        for attr_name, type in anns.items():</span>
<span class="gi">+            if _is_class_var(type):</span>
<span class="gi">+                continue</span>
<span class="gi">+            annot_names.add(attr_name)</span>
<span class="gi">+            a = cd.get(attr_name, NOTHING)</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(a, _CountingAttr):</span>
<span class="gi">+                a = attrib() if a is NOTHING else attrib(default=a)</span>
<span class="gi">+            ca_list.append((attr_name, a))</span>
<span class="gi">+</span>
<span class="gi">+        unannotated = ca_names - annot_names</span>
<span class="gi">+        if len(unannotated) &gt; 0:</span>
<span class="gi">+            raise UnannotatedAttributeError(</span>
<span class="gi">+                &quot;The following `attr.ib`s lack a type annotation: &quot;</span>
<span class="gi">+                + &quot;, &quot;.join(</span>
<span class="gi">+                    sorted(unannotated, key=lambda n: cd.get(n).counter)</span>
<span class="gi">+                )</span>
<span class="gi">+                + &quot;.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        ca_list = sorted(</span>
<span class="gi">+            (</span>
<span class="gi">+                (name, attr)</span>
<span class="gi">+                for name, attr in cd.items()</span>
<span class="gi">+                if isinstance(attr, _CountingAttr)</span>
<span class="gi">+            ),</span>
<span class="gi">+            key=lambda e: e[1].counter,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    own_attrs = [</span>
<span class="gi">+        Attribute.from_counting_attr(</span>
<span class="gi">+            name=attr_name, ca=ca, type=anns.get(attr_name)</span>
<span class="gi">+        )</span>
<span class="gi">+        for attr_name, ca in ca_list</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if collect_by_mro:</span>
<span class="gi">+        base_attrs, base_attr_map = _collect_base_attrs(</span>
<span class="gi">+            cls, {a.name for a in own_attrs}</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        base_attrs, base_attr_map = _collect_base_attrs_broken(</span>
<span class="gi">+            cls, {a.name for a in own_attrs}</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if kw_only:</span>
<span class="gi">+        own_attrs = [a.evolve(kw_only=True) for a in own_attrs]</span>
<span class="gi">+        base_attrs = [a.evolve(kw_only=True) for a in base_attrs]</span>
<span class="gi">+</span>
<span class="gi">+    attrs = base_attrs + own_attrs</span>
<span class="gi">+</span>
<span class="gi">+    # Mandatory vs non-mandatory attr order only matters when they are part of</span>
<span class="gi">+    # the __init__ signature and when they aren&#39;t kw_only (which are moved to</span>
<span class="gi">+    # the end and can be mandatory or non-mandatory in any order, as they will</span>
<span class="gi">+    # be specified as keyword args anyway). Check the order of those attrs:</span>
<span class="gi">+    had_default = False</span>
<span class="gi">+    for a in (a for a in attrs if a.init is not False and a.kw_only is False):</span>
<span class="gi">+        if had_default is True and a.default is NOTHING:</span>
<span class="gi">+            msg = f&quot;No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: {a!r}&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        if had_default is False and a.default is not NOTHING:</span>
<span class="gi">+            had_default = True</span>
<span class="gi">+</span>
<span class="gi">+    if field_transformer is not None:</span>
<span class="gi">+        attrs = field_transformer(cls, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    # Resolve default field alias after executing field_transformer.</span>
<span class="gi">+    # This allows field_transformer to differentiate between explicit vs</span>
<span class="gi">+    # default aliases and supply their own defaults.</span>
<span class="gi">+    attrs = [</span>
<span class="gi">+        a.evolve(alias=_default_init_alias_for(a.name)) if not a.alias else a</span>
<span class="gi">+        for a in attrs</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Create AttrsClass *after* applying the field_transformer since it may</span>
<span class="gi">+    # add or remove attributes!</span>
<span class="gi">+    attr_names = [a.name for a in attrs]</span>
<span class="gi">+    AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)</span>
<span class="gi">+</span>
<span class="gi">+    return _Attributes((AttrsClass(attrs), base_attrs, base_attr_map))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_cached_property_getattr(cached_properties, original_getattr, cls):</span>
<span class="gi">+    lines = [</span>
<span class="gi">+        # Wrapped to get `__class__` into closure cell for super()</span>
<span class="gi">+        # (It will be replaced with the newly constructed class after construction).</span>
<span class="gi">+        &quot;def wrapper(_cls):&quot;,</span>
<span class="gi">+        &quot;    __class__ = _cls&quot;,</span>
<span class="gi">+        &quot;    def __getattr__(self, item, cached_properties=cached_properties, original_getattr=original_getattr, _cached_setattr_get=_cached_setattr_get):&quot;,</span>
<span class="gi">+        &quot;         func = cached_properties.get(item)&quot;,</span>
<span class="gi">+        &quot;         if func is not None:&quot;,</span>
<span class="gi">+        &quot;              result = func(self)&quot;,</span>
<span class="gi">+        &quot;              _setter = _cached_setattr_get(self)&quot;,</span>
<span class="gi">+        &quot;              _setter(item, result)&quot;,</span>
<span class="gi">+        &quot;              return result&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    if original_getattr is not None:</span>
<span class="gi">+        lines.append(</span>
<span class="gi">+            &quot;         return original_getattr(self, item)&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        lines.extend(</span>
<span class="gi">+            [</span>
<span class="gi">+                &quot;         try:&quot;,</span>
<span class="gi">+                &quot;             return super().__getattribute__(item)&quot;,</span>
<span class="gi">+                &quot;         except AttributeError:&quot;,</span>
<span class="gi">+                &quot;             if not hasattr(super(), &#39;__getattr__&#39;):&quot;,</span>
<span class="gi">+                &quot;                 raise&quot;,</span>
<span class="gi">+                &quot;             return super().__getattr__(item)&quot;,</span>
<span class="gi">+                &quot;         original_error = f\&quot;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{item}&#39;\&quot;&quot;,</span>
<span class="gi">+                &quot;         raise AttributeError(original_error)&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    lines.extend(</span>
<span class="gi">+        [</span>
<span class="gi">+            &quot;    return __getattr__&quot;,</span>
<span class="gi">+            &quot;__getattr__ = wrapper(_cls)&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    unique_filename = _generate_unique_filename(cls, &quot;getattr&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    glob = {</span>
<span class="gi">+        &quot;cached_properties&quot;: cached_properties,</span>
<span class="gi">+        &quot;_cached_setattr_get&quot;: _OBJ_SETATTR.__get__,</span>
<span class="gi">+        &quot;original_getattr&quot;: original_getattr,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return _make_method(</span>
<span class="gi">+        &quot;__getattr__&quot;,</span>
<span class="gi">+        &quot;\n&quot;.join(lines),</span>
<span class="gi">+        unique_filename,</span>
<span class="gi">+        glob,</span>
<span class="gi">+        locals={</span>
<span class="gi">+            &quot;_cls&quot;: cls,</span>
<span class="gi">+        },</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _frozen_setattrs(self, name, value):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attached to frozen classes as __setattr__.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(self, BaseException) and name in (</span>
<span class="gi">+        &quot;__cause__&quot;,</span>
<span class="gi">+        &quot;__context__&quot;,</span>
<span class="gi">+        &quot;__traceback__&quot;,</span>
<span class="gi">+    ):</span>
<span class="gi">+        BaseException.__setattr__(self, name, value)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    raise FrozenInstanceError()</span>


<span class="w"> </span>def _frozen_delattrs(self, name):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Attached to frozen classes as __delattr__.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise FrozenInstanceError()</span>


<span class="w"> </span>class _ClassBuilder:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Iteratively build *one* class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;_attr_names&#39;, &#39;_attrs&#39;, &#39;_base_attr_map&#39;, &#39;_base_names&#39;,</span>
<span class="gd">-        &#39;_cache_hash&#39;, &#39;_cls&#39;, &#39;_cls_dict&#39;, &#39;_delete_attribs&#39;, &#39;_frozen&#39;,</span>
<span class="gd">-        &#39;_has_pre_init&#39;, &#39;_pre_init_has_args&#39;, &#39;_has_post_init&#39;, &#39;_is_exc&#39;,</span>
<span class="gd">-        &#39;_on_setattr&#39;, &#39;_slots&#39;, &#39;_weakref_slot&#39;, &#39;_wrote_own_setattr&#39;,</span>
<span class="gd">-        &#39;_has_custom_setattr&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, cls, these, slots, frozen, weakref_slot,</span>
<span class="gd">-        getstate_setstate, auto_attribs, kw_only, cache_hash, is_exc,</span>
<span class="gd">-        collect_by_mro, on_setattr, has_custom_setattr, field_transformer):</span>
<span class="gd">-        attrs, base_attrs, base_map = _transform_attrs(cls, these,</span>
<span class="gd">-            auto_attribs, kw_only, collect_by_mro, field_transformer)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;_attr_names&quot;,</span>
<span class="gi">+        &quot;_attrs&quot;,</span>
<span class="gi">+        &quot;_base_attr_map&quot;,</span>
<span class="gi">+        &quot;_base_names&quot;,</span>
<span class="gi">+        &quot;_cache_hash&quot;,</span>
<span class="gi">+        &quot;_cls&quot;,</span>
<span class="gi">+        &quot;_cls_dict&quot;,</span>
<span class="gi">+        &quot;_delete_attribs&quot;,</span>
<span class="gi">+        &quot;_frozen&quot;,</span>
<span class="gi">+        &quot;_has_pre_init&quot;,</span>
<span class="gi">+        &quot;_pre_init_has_args&quot;,</span>
<span class="gi">+        &quot;_has_post_init&quot;,</span>
<span class="gi">+        &quot;_is_exc&quot;,</span>
<span class="gi">+        &quot;_on_setattr&quot;,</span>
<span class="gi">+        &quot;_slots&quot;,</span>
<span class="gi">+        &quot;_weakref_slot&quot;,</span>
<span class="gi">+        &quot;_wrote_own_setattr&quot;,</span>
<span class="gi">+        &quot;_has_custom_setattr&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        cls,</span>
<span class="gi">+        these,</span>
<span class="gi">+        slots,</span>
<span class="gi">+        frozen,</span>
<span class="gi">+        weakref_slot,</span>
<span class="gi">+        getstate_setstate,</span>
<span class="gi">+        auto_attribs,</span>
<span class="gi">+        kw_only,</span>
<span class="gi">+        cache_hash,</span>
<span class="gi">+        is_exc,</span>
<span class="gi">+        collect_by_mro,</span>
<span class="gi">+        on_setattr,</span>
<span class="gi">+        has_custom_setattr,</span>
<span class="gi">+        field_transformer,</span>
<span class="gi">+    ):</span>
<span class="gi">+        attrs, base_attrs, base_map = _transform_attrs(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            these,</span>
<span class="gi">+            auto_attribs,</span>
<span class="gi">+            kw_only,</span>
<span class="gi">+            collect_by_mro,</span>
<span class="gi">+            field_transformer,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._cls = cls
<span class="w"> </span>        self._cls_dict = dict(cls.__dict__) if slots else {}
<span class="w"> </span>        self._attrs = attrs
<span class="gu">@@ -234,44 +620,64 @@ class _ClassBuilder:</span>
<span class="w"> </span>        self._frozen = frozen
<span class="w"> </span>        self._weakref_slot = weakref_slot
<span class="w"> </span>        self._cache_hash = cache_hash
<span class="gd">-        self._has_pre_init = bool(getattr(cls, &#39;__attrs_pre_init__&#39;, False))</span>
<span class="gi">+        self._has_pre_init = bool(getattr(cls, &quot;__attrs_pre_init__&quot;, False))</span>
<span class="w"> </span>        self._pre_init_has_args = False
<span class="w"> </span>        if self._has_pre_init:
<span class="gi">+            # Check if the pre init method has more arguments than just `self`</span>
<span class="gi">+            # We want to pass arguments if pre init expects arguments</span>
<span class="w"> </span>            pre_init_func = cls.__attrs_pre_init__
<span class="w"> </span>            pre_init_signature = inspect.signature(pre_init_func)
<span class="w"> </span>            self._pre_init_has_args = len(pre_init_signature.parameters) &gt; 1
<span class="gd">-        self._has_post_init = bool(getattr(cls, &#39;__attrs_post_init__&#39;, False))</span>
<span class="gi">+        self._has_post_init = bool(getattr(cls, &quot;__attrs_post_init__&quot;, False))</span>
<span class="w"> </span>        self._delete_attribs = not bool(these)
<span class="w"> </span>        self._is_exc = is_exc
<span class="w"> </span>        self._on_setattr = on_setattr
<span class="gi">+</span>
<span class="w"> </span>        self._has_custom_setattr = has_custom_setattr
<span class="w"> </span>        self._wrote_own_setattr = False
<span class="gd">-        self._cls_dict[&#39;__attrs_attrs__&#39;] = self._attrs</span>
<span class="gi">+</span>
<span class="gi">+        self._cls_dict[&quot;__attrs_attrs__&quot;] = self._attrs</span>
<span class="gi">+</span>
<span class="w"> </span>        if frozen:
<span class="gd">-            self._cls_dict[&#39;__setattr__&#39;] = _frozen_setattrs</span>
<span class="gd">-            self._cls_dict[&#39;__delattr__&#39;] = _frozen_delattrs</span>
<span class="gi">+            self._cls_dict[&quot;__setattr__&quot;] = _frozen_setattrs</span>
<span class="gi">+            self._cls_dict[&quot;__delattr__&quot;] = _frozen_delattrs</span>
<span class="gi">+</span>
<span class="w"> </span>            self._wrote_own_setattr = True
<span class="gd">-        elif on_setattr in (_DEFAULT_ON_SETATTR, setters.validate, setters.</span>
<span class="gd">-            convert):</span>
<span class="gi">+        elif on_setattr in (</span>
<span class="gi">+            _DEFAULT_ON_SETATTR,</span>
<span class="gi">+            setters.validate,</span>
<span class="gi">+            setters.convert,</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            has_validator = has_converter = False
<span class="w"> </span>            for a in attrs:
<span class="w"> </span>                if a.validator is not None:
<span class="w"> </span>                    has_validator = True
<span class="w"> </span>                if a.converter is not None:
<span class="w"> </span>                    has_converter = True
<span class="gi">+</span>
<span class="w"> </span>                if has_validator and has_converter:
<span class="w"> </span>                    break
<span class="gd">-            if (on_setattr == _DEFAULT_ON_SETATTR and not (has_validator or</span>
<span class="gd">-                has_converter) or on_setattr == setters.validate and not</span>
<span class="gd">-                has_validator or on_setattr == setters.convert and not</span>
<span class="gd">-                has_converter):</span>
<span class="gi">+            if (</span>
<span class="gi">+                (</span>
<span class="gi">+                    on_setattr == _DEFAULT_ON_SETATTR</span>
<span class="gi">+                    and not (has_validator or has_converter)</span>
<span class="gi">+                )</span>
<span class="gi">+                or (on_setattr == setters.validate and not has_validator)</span>
<span class="gi">+                or (on_setattr == setters.convert and not has_converter)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # If class-level on_setattr is set to convert + validate, but</span>
<span class="gi">+                # there&#39;s no field to convert or validate, pretend like there&#39;s</span>
<span class="gi">+                # no on_setattr.</span>
<span class="w"> </span>                self._on_setattr = None
<span class="gi">+</span>
<span class="w"> </span>        if getstate_setstate:
<span class="gd">-            self._cls_dict[&#39;__getstate__&#39;], self._cls_dict[&#39;__setstate__&#39;</span>
<span class="gd">-                ] = self._make_getstate_setstate()</span>
<span class="gi">+            (</span>
<span class="gi">+                self._cls_dict[&quot;__getstate__&quot;],</span>
<span class="gi">+                self._cls_dict[&quot;__setstate__&quot;],</span>
<span class="gi">+            ) = self._make_getstate_setstate()</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;_ClassBuilder(cls={self._cls.__name__})&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;_ClassBuilder(cls={self._cls.__name__})&gt;&quot;</span>

<span class="w"> </span>    def build_class(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -279,31 +685,397 @@ class _ClassBuilder:</span>

<span class="w"> </span>        Builder cannot be used after calling this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._slots is True:</span>
<span class="gi">+            cls = self._create_slots_class()</span>
<span class="gi">+        else:</span>
<span class="gi">+            cls = self._patch_original_class()</span>
<span class="gi">+            if PY_3_10_PLUS:</span>
<span class="gi">+                cls = abc.update_abstractmethods(cls)</span>
<span class="gi">+</span>
<span class="gi">+        # The method gets only called if it&#39;s not inherited from a base class.</span>
<span class="gi">+        # _has_own_attribute does NOT work properly for classmethods.</span>
<span class="gi">+        if (</span>
<span class="gi">+            getattr(cls, &quot;__attrs_init_subclass__&quot;, None)</span>
<span class="gi">+            and &quot;__attrs_init_subclass__&quot; not in cls.__dict__</span>
<span class="gi">+        ):</span>
<span class="gi">+            cls.__attrs_init_subclass__()</span>
<span class="gi">+</span>
<span class="gi">+        return cls</span>

<span class="w"> </span>    def _patch_original_class(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Apply accumulated methods and return the class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls = self._cls</span>
<span class="gi">+        base_names = self._base_names</span>
<span class="gi">+</span>
<span class="gi">+        # Clean class of attribute definitions (`attr.ib()`s).</span>
<span class="gi">+        if self._delete_attribs:</span>
<span class="gi">+            for name in self._attr_names:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    name not in base_names</span>
<span class="gi">+                    and getattr(cls, name, _SENTINEL) is not _SENTINEL</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # An AttributeError can happen if a base class defines a</span>
<span class="gi">+                    # class variable and we want to set an attribute with the</span>
<span class="gi">+                    # same name by using only a type annotation.</span>
<span class="gi">+                    with contextlib.suppress(AttributeError):</span>
<span class="gi">+                        delattr(cls, name)</span>
<span class="gi">+</span>
<span class="gi">+        # Attach our dunder methods.</span>
<span class="gi">+        for name, value in self._cls_dict.items():</span>
<span class="gi">+            setattr(cls, name, value)</span>
<span class="gi">+</span>
<span class="gi">+        # If we&#39;ve inherited an attrs __setattr__ and don&#39;t write our own,</span>
<span class="gi">+        # reset it to object&#39;s.</span>
<span class="gi">+        if not self._wrote_own_setattr and getattr(</span>
<span class="gi">+            cls, &quot;__attrs_own_setattr__&quot;, False</span>
<span class="gi">+        ):</span>
<span class="gi">+            cls.__attrs_own_setattr__ = False</span>
<span class="gi">+</span>
<span class="gi">+            if not self._has_custom_setattr:</span>
<span class="gi">+                cls.__setattr__ = _OBJ_SETATTR</span>
<span class="gi">+</span>
<span class="gi">+        return cls</span>

<span class="w"> </span>    def _create_slots_class(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build and return a new class with a `__slots__` attribute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cd = {</span>
<span class="gi">+            k: v</span>
<span class="gi">+            for k, v in self._cls_dict.items()</span>
<span class="gi">+            if k not in (*tuple(self._attr_names), &quot;__dict__&quot;, &quot;__weakref__&quot;)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # If our class doesn&#39;t have its own implementation of __setattr__</span>
<span class="gi">+        # (either from the user or by us), check the bases, if one of them has</span>
<span class="gi">+        # an attrs-made __setattr__, that needs to be reset. We don&#39;t walk the</span>
<span class="gi">+        # MRO because we only care about our immediate base classes.</span>
<span class="gi">+        # XXX: This can be confused by subclassing a slotted attrs class with</span>
<span class="gi">+        # XXX: a non-attrs class and subclass the resulting class with an attrs</span>
<span class="gi">+        # XXX: class.  See `test_slotted_confused` for details.  For now that&#39;s</span>
<span class="gi">+        # XXX: OK with us.</span>
<span class="gi">+        if not self._wrote_own_setattr:</span>
<span class="gi">+            cd[&quot;__attrs_own_setattr__&quot;] = False</span>
<span class="gi">+</span>
<span class="gi">+            if not self._has_custom_setattr:</span>
<span class="gi">+                for base_cls in self._cls.__bases__:</span>
<span class="gi">+                    if base_cls.__dict__.get(&quot;__attrs_own_setattr__&quot;, False):</span>
<span class="gi">+                        cd[&quot;__setattr__&quot;] = _OBJ_SETATTR</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+        # Traverse the MRO to collect existing slots</span>
<span class="gi">+        # and check for an existing __weakref__.</span>
<span class="gi">+        existing_slots = {}</span>
<span class="gi">+        weakref_inherited = False</span>
<span class="gi">+        for base_cls in self._cls.__mro__[1:-1]:</span>
<span class="gi">+            if base_cls.__dict__.get(&quot;__weakref__&quot;, None) is not None:</span>
<span class="gi">+                weakref_inherited = True</span>
<span class="gi">+            existing_slots.update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    name: getattr(base_cls, name)</span>
<span class="gi">+                    for name in getattr(base_cls, &quot;__slots__&quot;, [])</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        base_names = set(self._base_names)</span>
<span class="gi">+</span>
<span class="gi">+        names = self._attr_names</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._weakref_slot</span>
<span class="gi">+            and &quot;__weakref__&quot; not in getattr(self._cls, &quot;__slots__&quot;, ())</span>
<span class="gi">+            and &quot;__weakref__&quot; not in names</span>
<span class="gi">+            and not weakref_inherited</span>
<span class="gi">+        ):</span>
<span class="gi">+            names += (&quot;__weakref__&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+        if PY_3_8_PLUS:</span>
<span class="gi">+            cached_properties = {</span>
<span class="gi">+                name: cached_property.func</span>
<span class="gi">+                for name, cached_property in cd.items()</span>
<span class="gi">+                if isinstance(cached_property, functools.cached_property)</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            # `functools.cached_property` was introduced in 3.8.</span>
<span class="gi">+            # So can&#39;t be used before this.</span>
<span class="gi">+            cached_properties = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Collect methods with a `__class__` reference that are shadowed in the new class.</span>
<span class="gi">+        # To know to update them.</span>
<span class="gi">+        additional_closure_functions_to_update = []</span>
<span class="gi">+        if cached_properties:</span>
<span class="gi">+            class_annotations = _get_annotations(self._cls)</span>
<span class="gi">+            for name, func in cached_properties.items():</span>
<span class="gi">+                # Add cached properties to names for slotting.</span>
<span class="gi">+                names += (name,)</span>
<span class="gi">+                # Clear out function from class to avoid clashing.</span>
<span class="gi">+                del cd[name]</span>
<span class="gi">+                additional_closure_functions_to_update.append(func)</span>
<span class="gi">+                annotation = inspect.signature(func).return_annotation</span>
<span class="gi">+                if annotation is not inspect.Parameter.empty:</span>
<span class="gi">+                    class_annotations[name] = annotation</span>
<span class="gi">+</span>
<span class="gi">+            original_getattr = cd.get(&quot;__getattr__&quot;)</span>
<span class="gi">+            if original_getattr is not None:</span>
<span class="gi">+                additional_closure_functions_to_update.append(original_getattr)</span>
<span class="gi">+</span>
<span class="gi">+            cd[&quot;__getattr__&quot;] = _make_cached_property_getattr(</span>
<span class="gi">+                cached_properties, original_getattr, self._cls</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # We only add the names of attributes that aren&#39;t inherited.</span>
<span class="gi">+        # Setting __slots__ to inherited attributes wastes memory.</span>
<span class="gi">+        slot_names = [name for name in names if name not in base_names]</span>
<span class="gi">+</span>
<span class="gi">+        # There are slots for attributes from current class</span>
<span class="gi">+        # that are defined in parent classes.</span>
<span class="gi">+        # As their descriptors may be overridden by a child class,</span>
<span class="gi">+        # we collect them here and update the class dict</span>
<span class="gi">+        reused_slots = {</span>
<span class="gi">+            slot: slot_descriptor</span>
<span class="gi">+            for slot, slot_descriptor in existing_slots.items()</span>
<span class="gi">+            if slot in slot_names</span>
<span class="gi">+        }</span>
<span class="gi">+        slot_names = [name for name in slot_names if name not in reused_slots]</span>
<span class="gi">+        cd.update(reused_slots)</span>
<span class="gi">+        if self._cache_hash:</span>
<span class="gi">+            slot_names.append(_HASH_CACHE_FIELD)</span>
<span class="gi">+</span>
<span class="gi">+        cd[&quot;__slots__&quot;] = tuple(slot_names)</span>
<span class="gi">+</span>
<span class="gi">+        cd[&quot;__qualname__&quot;] = self._cls.__qualname__</span>
<span class="gi">+</span>
<span class="gi">+        # Create new class based on old class and our methods.</span>
<span class="gi">+        cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)</span>
<span class="gi">+</span>
<span class="gi">+        # The following is a fix for</span>
<span class="gi">+        # &lt;https://github.com/python-attrs/attrs/issues/102&gt;.</span>
<span class="gi">+        # If a method mentions `__class__` or uses the no-arg super(), the</span>
<span class="gi">+        # compiler will bake a reference to the class in the method itself</span>
<span class="gi">+        # as `method.__closure__`.  Since we replace the class with a</span>
<span class="gi">+        # clone, we rewrite these references so it keeps working.</span>
<span class="gi">+        for item in itertools.chain(</span>
<span class="gi">+            cls.__dict__.values(), additional_closure_functions_to_update</span>
<span class="gi">+        ):</span>
<span class="gi">+            if isinstance(item, (classmethod, staticmethod)):</span>
<span class="gi">+                # Class- and staticmethods hide their functions inside.</span>
<span class="gi">+                # These might need to be rewritten as well.</span>
<span class="gi">+                closure_cells = getattr(item.__func__, &quot;__closure__&quot;, None)</span>
<span class="gi">+            elif isinstance(item, property):</span>
<span class="gi">+                # Workaround for property `super()` shortcut (PY3-only).</span>
<span class="gi">+                # There is no universal way for other descriptors.</span>
<span class="gi">+                closure_cells = getattr(item.fget, &quot;__closure__&quot;, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                closure_cells = getattr(item, &quot;__closure__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            if not closure_cells:  # Catch None or the empty list.</span>
<span class="gi">+                continue</span>
<span class="gi">+            for cell in closure_cells:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    match = cell.cell_contents is self._cls</span>
<span class="gi">+                except ValueError:  # noqa: PERF203</span>
<span class="gi">+                    # ValueError: Cell is empty</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if match:</span>
<span class="gi">+                        cell.cell_contents = cls</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    def add_repr(self, ns):</span>
<span class="gi">+        self._cls_dict[&quot;__repr__&quot;] = self._add_method_dunders(</span>
<span class="gi">+            _make_repr(self._attrs, ns, self._cls)</span>
<span class="gi">+        )</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_str(self):</span>
<span class="gi">+        repr = self._cls_dict.get(&quot;__repr__&quot;)</span>
<span class="gi">+        if repr is None:</span>
<span class="gi">+            msg = &quot;__str__ can only be generated if a __repr__ exists.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        def __str__(self):</span>
<span class="gi">+            return self.__repr__()</span>
<span class="gi">+</span>
<span class="gi">+        self._cls_dict[&quot;__str__&quot;] = self._add_method_dunders(__str__)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _make_getstate_setstate(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create custom __setstate__ and __getstate__ methods.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # __weakref__ is not writable.</span>
<span class="gi">+        state_attr_names = tuple(</span>
<span class="gi">+            an for an in self._attr_names if an != &quot;__weakref__&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def slots_getstate(self):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Automatically created by attrs.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            return {name: getattr(self, name) for name in state_attr_names}</span>
<span class="gi">+</span>
<span class="gi">+        hash_caching_enabled = self._cache_hash</span>
<span class="gi">+</span>
<span class="gi">+        def slots_setstate(self, state):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Automatically created by attrs.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            __bound_setattr = _OBJ_SETATTR.__get__(self)</span>
<span class="gi">+            if isinstance(state, tuple):</span>
<span class="gi">+                # Backward compatibility with attrs instances pickled with</span>
<span class="gi">+                # attrs versions before v22.2.0 which stored tuples.</span>
<span class="gi">+                for name, value in zip(state_attr_names, state):</span>
<span class="gi">+                    __bound_setattr(name, value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for name in state_attr_names:</span>
<span class="gi">+                    if name in state:</span>
<span class="gi">+                        __bound_setattr(name, state[name])</span>
<span class="gi">+</span>
<span class="gi">+            # The hash code cache is not included when the object is</span>
<span class="gi">+            # serialized, but it still needs to be initialized to None to</span>
<span class="gi">+            # indicate that the first call to __hash__ should be a cache</span>
<span class="gi">+            # miss.</span>
<span class="gi">+            if hash_caching_enabled:</span>
<span class="gi">+                __bound_setattr(_HASH_CACHE_FIELD, None)</span>
<span class="gi">+</span>
<span class="gi">+        return slots_getstate, slots_setstate</span>
<span class="gi">+</span>
<span class="gi">+    def make_unhashable(self):</span>
<span class="gi">+        self._cls_dict[&quot;__hash__&quot;] = None</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_hash(self):</span>
<span class="gi">+        self._cls_dict[&quot;__hash__&quot;] = self._add_method_dunders(</span>
<span class="gi">+            _make_hash(</span>
<span class="gi">+                self._cls,</span>
<span class="gi">+                self._attrs,</span>
<span class="gi">+                frozen=self._frozen,</span>
<span class="gi">+                cache_hash=self._cache_hash,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_init(self):</span>
<span class="gi">+        self._cls_dict[&quot;__init__&quot;] = self._add_method_dunders(</span>
<span class="gi">+            _make_init(</span>
<span class="gi">+                self._cls,</span>
<span class="gi">+                self._attrs,</span>
<span class="gi">+                self._has_pre_init,</span>
<span class="gi">+                self._pre_init_has_args,</span>
<span class="gi">+                self._has_post_init,</span>
<span class="gi">+                self._frozen,</span>
<span class="gi">+                self._slots,</span>
<span class="gi">+                self._cache_hash,</span>
<span class="gi">+                self._base_attr_map,</span>
<span class="gi">+                self._is_exc,</span>
<span class="gi">+                self._on_setattr,</span>
<span class="gi">+                attrs_init=False,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_match_args(self):</span>
<span class="gi">+        self._cls_dict[&quot;__match_args__&quot;] = tuple(</span>
<span class="gi">+            field.name</span>
<span class="gi">+            for field in self._attrs</span>
<span class="gi">+            if field.init and not field.kw_only</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def add_attrs_init(self):</span>
<span class="gi">+        self._cls_dict[&quot;__attrs_init__&quot;] = self._add_method_dunders(</span>
<span class="gi">+            _make_init(</span>
<span class="gi">+                self._cls,</span>
<span class="gi">+                self._attrs,</span>
<span class="gi">+                self._has_pre_init,</span>
<span class="gi">+                self._pre_init_has_args,</span>
<span class="gi">+                self._has_post_init,</span>
<span class="gi">+                self._frozen,</span>
<span class="gi">+                self._slots,</span>
<span class="gi">+                self._cache_hash,</span>
<span class="gi">+                self._base_attr_map,</span>
<span class="gi">+                self._is_exc,</span>
<span class="gi">+                self._on_setattr,</span>
<span class="gi">+                attrs_init=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_eq(self):</span>
<span class="gi">+        cd = self._cls_dict</span>
<span class="gi">+</span>
<span class="gi">+        cd[&quot;__eq__&quot;] = self._add_method_dunders(</span>
<span class="gi">+            _make_eq(self._cls, self._attrs)</span>
<span class="gi">+        )</span>
<span class="gi">+        cd[&quot;__ne__&quot;] = self._add_method_dunders(_make_ne())</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_order(self):</span>
<span class="gi">+        cd = self._cls_dict</span>
<span class="gi">+</span>
<span class="gi">+        cd[&quot;__lt__&quot;], cd[&quot;__le__&quot;], cd[&quot;__gt__&quot;], cd[&quot;__ge__&quot;] = (</span>
<span class="gi">+            self._add_method_dunders(meth)</span>
<span class="gi">+            for meth in _make_order(self._cls, self._attrs)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def add_setattr(self):</span>
<span class="gi">+        if self._frozen:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        sa_attrs = {}</span>
<span class="gi">+        for a in self._attrs:</span>
<span class="gi">+            on_setattr = a.on_setattr or self._on_setattr</span>
<span class="gi">+            if on_setattr and on_setattr is not setters.NO_OP:</span>
<span class="gi">+                sa_attrs[a.name] = a, on_setattr</span>
<span class="gi">+</span>
<span class="gi">+        if not sa_attrs:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        if self._has_custom_setattr:</span>
<span class="gi">+            # We need to write a __setattr__ but there already is one!</span>
<span class="gi">+            msg = &quot;Can&#39;t combine custom __setattr__ with on_setattr hooks.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # docstring comes from _add_method_dunders</span>
<span class="gi">+        def __setattr__(self, name, val):</span>
<span class="gi">+            try:</span>
<span class="gi">+                a, hook = sa_attrs[name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                nval = val</span>
<span class="gi">+            else:</span>
<span class="gi">+                nval = hook(self, a, val)</span>
<span class="gi">+</span>
<span class="gi">+            _OBJ_SETATTR(self, name, nval)</span>
<span class="gi">+</span>
<span class="gi">+        self._cls_dict[&quot;__attrs_own_setattr__&quot;] = True</span>
<span class="gi">+        self._cls_dict[&quot;__setattr__&quot;] = self._add_method_dunders(__setattr__)</span>
<span class="gi">+        self._wrote_own_setattr = True</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _add_method_dunders(self, method):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add __module__ and __qualname__ to a *method* if possible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with contextlib.suppress(AttributeError):</span>
<span class="gi">+            method.__module__ = self._cls.__module__</span>
<span class="gi">+</span>
<span class="gi">+        with contextlib.suppress(AttributeError):</span>
<span class="gi">+            method.__qualname__ = f&quot;{self._cls.__qualname__}.{method.__name__}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        with contextlib.suppress(AttributeError):</span>
<span class="gi">+            method.__doc__ = (</span>
<span class="gi">+                &quot;Method generated by attrs for class &quot;</span>
<span class="gi">+                f&quot;{self._cls.__qualname__}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return method</span>


<span class="w"> </span>def _determine_attrs_eq_order(cmp, eq, order, default_eq):
<span class="gu">@@ -311,7 +1083,27 @@ def _determine_attrs_eq_order(cmp, eq, order, default_eq):</span>
<span class="w"> </span>    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective
<span class="w"> </span>    values of eq and order.  If *eq* is None, set it to *default_eq*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cmp is not None and any((eq is not None, order is not None)):</span>
<span class="gi">+        msg = &quot;Don&#39;t mix `cmp` with `eq&#39; and `order`.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # cmp takes precedence due to bw-compatibility.</span>
<span class="gi">+    if cmp is not None:</span>
<span class="gi">+        return cmp, cmp</span>
<span class="gi">+</span>
<span class="gi">+    # If left None, equality is set to the specified default and ordering</span>
<span class="gi">+    # mirrors equality.</span>
<span class="gi">+    if eq is None:</span>
<span class="gi">+        eq = default_eq</span>
<span class="gi">+</span>
<span class="gi">+    if order is None:</span>
<span class="gi">+        order = eq</span>
<span class="gi">+</span>
<span class="gi">+    if eq is False and order is True:</span>
<span class="gi">+        msg = &quot;`order` can only be True if `eq` is True too.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return eq, order</span>


<span class="w"> </span>def _determine_attrib_eq_order(cmp, eq, order, default_eq):
<span class="gu">@@ -319,11 +1111,47 @@ def _determine_attrib_eq_order(cmp, eq, order, default_eq):</span>
<span class="w"> </span>    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective
<span class="w"> </span>    values of eq and order.  If *eq* is None, set it to *default_eq*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cmp is not None and any((eq is not None, order is not None)):</span>
<span class="gi">+        msg = &quot;Don&#39;t mix `cmp` with `eq&#39; and `order`.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>

<span class="gi">+    def decide_callable_or_boolean(value):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Decide whether a key function is used.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if callable(value):</span>
<span class="gi">+            value, key = True, value</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = None</span>
<span class="gi">+        return value, key</span>
<span class="gi">+</span>
<span class="gi">+    # cmp takes precedence due to bw-compatibility.</span>
<span class="gi">+    if cmp is not None:</span>
<span class="gi">+        cmp, cmp_key = decide_callable_or_boolean(cmp)</span>
<span class="gi">+        return cmp, cmp_key, cmp, cmp_key</span>
<span class="gi">+</span>
<span class="gi">+    # If left None, equality is set to the specified default and ordering</span>
<span class="gi">+    # mirrors equality.</span>
<span class="gi">+    if eq is None:</span>
<span class="gi">+        eq, eq_key = default_eq, None</span>
<span class="gi">+    else:</span>
<span class="gi">+        eq, eq_key = decide_callable_or_boolean(eq)</span>
<span class="gi">+</span>
<span class="gi">+    if order is None:</span>
<span class="gi">+        order, order_key = eq, eq_key</span>
<span class="gi">+    else:</span>
<span class="gi">+        order, order_key = decide_callable_or_boolean(order)</span>
<span class="gi">+</span>
<span class="gi">+    if eq is False and order is True:</span>
<span class="gi">+        msg = &quot;`order` can only be True if `eq` is True too.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>

<span class="gd">-def _determine_whether_to_implement(cls, flag, auto_detect, dunders,</span>
<span class="gd">-    default=True):</span>
<span class="gi">+    return eq, eq_key, order, order_key</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _determine_whether_to_implement(</span>
<span class="gi">+    cls, flag, auto_detect, dunders, default=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether we should implement a set of methods for *cls*.

<span class="gu">@@ -333,16 +1161,47 @@ def _determine_whether_to_implement(cls, flag, auto_detect, dunders,</span>

<span class="w"> </span>    Return *default* if no reason for either for or against is found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def attrs(maybe_cls=None, these=None, repr_ns=None, repr=None, cmp=None,</span>
<span class="gd">-    hash=None, init=None, slots=False, frozen=False, weakref_slot=True, str</span>
<span class="gd">-    =False, auto_attribs=False, kw_only=False, cache_hash=False, auto_exc=</span>
<span class="gd">-    False, eq=None, order=None, auto_detect=False, collect_by_mro=False,</span>
<span class="gd">-    getstate_setstate=None, on_setattr=None, field_transformer=None,</span>
<span class="gd">-    match_args=True, unsafe_hash=None):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    if flag is True or flag is False:</span>
<span class="gi">+        return flag</span>
<span class="gi">+</span>
<span class="gi">+    if flag is None and auto_detect is False:</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    # Logically, flag is None and auto_detect is True here.</span>
<span class="gi">+    for dunder in dunders:</span>
<span class="gi">+        if _has_own_attribute(cls, dunder):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return default</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def attrs(</span>
<span class="gi">+    maybe_cls=None,</span>
<span class="gi">+    these=None,</span>
<span class="gi">+    repr_ns=None,</span>
<span class="gi">+    repr=None,</span>
<span class="gi">+    cmp=None,</span>
<span class="gi">+    hash=None,</span>
<span class="gi">+    init=None,</span>
<span class="gi">+    slots=False,</span>
<span class="gi">+    frozen=False,</span>
<span class="gi">+    weakref_slot=True,</span>
<span class="gi">+    str=False,</span>
<span class="gi">+    auto_attribs=False,</span>
<span class="gi">+    kw_only=False,</span>
<span class="gi">+    cache_hash=False,</span>
<span class="gi">+    auto_exc=False,</span>
<span class="gi">+    eq=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+    auto_detect=False,</span>
<span class="gi">+    collect_by_mro=False,</span>
<span class="gi">+    getstate_setstate=None,</span>
<span class="gi">+    on_setattr=None,</span>
<span class="gi">+    field_transformer=None,</span>
<span class="gi">+    match_args=True,</span>
<span class="gi">+    unsafe_hash=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    A class decorator that adds :term:`dunder methods` according to the
<span class="w"> </span>    specified attributes using `attr.ib` or the *these* argument.

<span class="gu">@@ -408,7 +1267,133 @@ def attrs(maybe_cls=None, these=None, repr_ns=None, repr=None, cmp=None,</span>
<span class="w"> </span>       ``__attrs_init_subclass__``, it is executed after the class is created.
<span class="w"> </span>    .. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if repr_ns is not None:</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            DeprecationWarning(</span>
<span class="gi">+                &quot;The `repr_ns` argument is deprecated and will be removed in or after August 2025.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    eq_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)</span>
<span class="gi">+</span>
<span class="gi">+    #  unsafe_hash takes precedence due to PEP 681.</span>
<span class="gi">+    if unsafe_hash is not None:</span>
<span class="gi">+        hash = unsafe_hash</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(on_setattr, (list, tuple)):</span>
<span class="gi">+        on_setattr = setters.pipe(*on_setattr)</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(cls):</span>
<span class="gi">+        is_frozen = frozen or _has_frozen_base_class(cls)</span>
<span class="gi">+        is_exc = auto_exc is True and issubclass(cls, BaseException)</span>
<span class="gi">+        has_own_setattr = auto_detect and _has_own_attribute(</span>
<span class="gi">+            cls, &quot;__setattr__&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if has_own_setattr and is_frozen:</span>
<span class="gi">+            msg = &quot;Can&#39;t freeze a class with a custom __setattr__.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        builder = _ClassBuilder(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            these,</span>
<span class="gi">+            slots,</span>
<span class="gi">+            is_frozen,</span>
<span class="gi">+            weakref_slot,</span>
<span class="gi">+            _determine_whether_to_implement(</span>
<span class="gi">+                cls,</span>
<span class="gi">+                getstate_setstate,</span>
<span class="gi">+                auto_detect,</span>
<span class="gi">+                (&quot;__getstate__&quot;, &quot;__setstate__&quot;),</span>
<span class="gi">+                default=slots,</span>
<span class="gi">+            ),</span>
<span class="gi">+            auto_attribs,</span>
<span class="gi">+            kw_only,</span>
<span class="gi">+            cache_hash,</span>
<span class="gi">+            is_exc,</span>
<span class="gi">+            collect_by_mro,</span>
<span class="gi">+            on_setattr,</span>
<span class="gi">+            has_own_setattr,</span>
<span class="gi">+            field_transformer,</span>
<span class="gi">+        )</span>
<span class="gi">+        if _determine_whether_to_implement(</span>
<span class="gi">+            cls, repr, auto_detect, (&quot;__repr__&quot;,)</span>
<span class="gi">+        ):</span>
<span class="gi">+            builder.add_repr(repr_ns)</span>
<span class="gi">+        if str is True:</span>
<span class="gi">+            builder.add_str()</span>
<span class="gi">+</span>
<span class="gi">+        eq = _determine_whether_to_implement(</span>
<span class="gi">+            cls, eq_, auto_detect, (&quot;__eq__&quot;, &quot;__ne__&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if not is_exc and eq is True:</span>
<span class="gi">+            builder.add_eq()</span>
<span class="gi">+        if not is_exc and _determine_whether_to_implement(</span>
<span class="gi">+            cls, order_, auto_detect, (&quot;__lt__&quot;, &quot;__le__&quot;, &quot;__gt__&quot;, &quot;__ge__&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            builder.add_order()</span>
<span class="gi">+</span>
<span class="gi">+        builder.add_setattr()</span>
<span class="gi">+</span>
<span class="gi">+        nonlocal hash</span>
<span class="gi">+        if (</span>
<span class="gi">+            hash is None</span>
<span class="gi">+            and auto_detect is True</span>
<span class="gi">+            and _has_own_attribute(cls, &quot;__hash__&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            hash = False</span>
<span class="gi">+</span>
<span class="gi">+        if hash is not True and hash is not False and hash is not None:</span>
<span class="gi">+            # Can&#39;t use `hash in` because 1 == True for example.</span>
<span class="gi">+            msg = &quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        if hash is False or (hash is None and eq is False) or is_exc:</span>
<span class="gi">+            # Don&#39;t do anything. Should fall back to __object__&#39;s __hash__</span>
<span class="gi">+            # which is by id.</span>
<span class="gi">+            if cache_hash:</span>
<span class="gi">+                msg = &quot;Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.&quot;</span>
<span class="gi">+                raise TypeError(msg)</span>
<span class="gi">+        elif hash is True or (</span>
<span class="gi">+            hash is None and eq is True and is_frozen is True</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Build a __hash__ if told so, or if it&#39;s safe.</span>
<span class="gi">+            builder.add_hash()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Raise TypeError on attempts to hash.</span>
<span class="gi">+            if cache_hash:</span>
<span class="gi">+                msg = &quot;Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.&quot;</span>
<span class="gi">+                raise TypeError(msg)</span>
<span class="gi">+            builder.make_unhashable()</span>
<span class="gi">+</span>
<span class="gi">+        if _determine_whether_to_implement(</span>
<span class="gi">+            cls, init, auto_detect, (&quot;__init__&quot;,)</span>
<span class="gi">+        ):</span>
<span class="gi">+            builder.add_init()</span>
<span class="gi">+        else:</span>
<span class="gi">+            builder.add_attrs_init()</span>
<span class="gi">+            if cache_hash:</span>
<span class="gi">+                msg = &quot;Invalid value for cache_hash.  To use hash caching, init must be True.&quot;</span>
<span class="gi">+                raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            PY_3_10_PLUS</span>
<span class="gi">+            and match_args</span>
<span class="gi">+            and not _has_own_attribute(cls, &quot;__match_args__&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            builder.add_match_args()</span>
<span class="gi">+</span>
<span class="gi">+        return builder.build_class()</span>
<span class="gi">+</span>
<span class="gi">+    # maybe_cls&#39;s type depends on the usage of the decorator.  It&#39;s a class</span>
<span class="gi">+    # if it&#39;s used as `@attrs` but `None` if used as `@attrs()`.</span>
<span class="gi">+    if maybe_cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+    return wrap(maybe_cls)</span>


<span class="w"> </span>_attrs = attrs
<span class="gu">@@ -423,56 +1408,292 @@ def _has_frozen_base_class(cls):</span>
<span class="w"> </span>    Check whether *cls* has a frozen ancestor by looking at its
<span class="w"> </span>    __setattr__.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls.__setattr__ is _frozen_setattrs</span>


<span class="w"> </span>def _generate_unique_filename(cls, func_name):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a &quot;filename&quot; suitable for a function being generated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        f&quot;&lt;attrs generated {func_name} {cls.__module__}.&quot;</span>
<span class="gi">+        f&quot;{getattr(cls, &#39;__qualname__&#39;, cls.__name__)}&gt;&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_hash(cls, attrs, frozen, cache_hash):</span>
<span class="gi">+    attrs = tuple(</span>
<span class="gi">+        a for a in attrs if a.hash is True or (a.hash is None and a.eq is True)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    tab = &quot;        &quot;</span>
<span class="gi">+</span>
<span class="gi">+    unique_filename = _generate_unique_filename(cls, &quot;hash&quot;)</span>
<span class="gi">+    type_hash = hash(unique_filename)</span>
<span class="gi">+    # If eq is custom generated, we need to include the functions in globs</span>
<span class="gi">+    globs = {}</span>
<span class="gi">+</span>
<span class="gi">+    hash_def = &quot;def __hash__(self&quot;</span>
<span class="gi">+    hash_func = &quot;hash((&quot;</span>
<span class="gi">+    closing_braces = &quot;))&quot;</span>
<span class="gi">+    if not cache_hash:</span>
<span class="gi">+        hash_def += &quot;):&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        hash_def += &quot;, *&quot;</span>
<span class="gi">+</span>
<span class="gi">+        hash_def += &quot;, _cache_wrapper=__import__(&#39;attr._make&#39;)._make._CacheHashWrapper):&quot;</span>
<span class="gi">+        hash_func = &quot;_cache_wrapper(&quot; + hash_func</span>
<span class="gi">+        closing_braces += &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    method_lines = [hash_def]</span>
<span class="gi">+</span>
<span class="gi">+    def append_hash_computation_lines(prefix, indent):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Generate the code for actually computing the hash code.</span>
<span class="gi">+        Below this will either be returned directly or used to compute</span>
<span class="gi">+        a value which is then cached, depending on the value of cache_hash</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        method_lines.extend(</span>
<span class="gi">+            [</span>
<span class="gi">+                indent + prefix + hash_func,</span>
<span class="gi">+                indent + f&quot;        {type_hash},&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for a in attrs:</span>
<span class="gi">+            if a.eq_key:</span>
<span class="gi">+                cmp_name = f&quot;_{a.name}_key&quot;</span>
<span class="gi">+                globs[cmp_name] = a.eq_key</span>
<span class="gi">+                method_lines.append(</span>
<span class="gi">+                    indent + f&quot;        {cmp_name}(self.{a.name}),&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                method_lines.append(indent + f&quot;        self.{a.name},&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        method_lines.append(indent + &quot;    &quot; + closing_braces)</span>
<span class="gi">+</span>
<span class="gi">+    if cache_hash:</span>
<span class="gi">+        method_lines.append(tab + f&quot;if self.{_HASH_CACHE_FIELD} is None:&quot;)</span>
<span class="gi">+        if frozen:</span>
<span class="gi">+            append_hash_computation_lines(</span>
<span class="gi">+                f&quot;object.__setattr__(self, &#39;{_HASH_CACHE_FIELD}&#39;, &quot;, tab * 2</span>
<span class="gi">+            )</span>
<span class="gi">+            method_lines.append(tab * 2 + &quot;)&quot;)  # close __setattr__</span>
<span class="gi">+        else:</span>
<span class="gi">+            append_hash_computation_lines(</span>
<span class="gi">+                f&quot;self.{_HASH_CACHE_FIELD} = &quot;, tab * 2</span>
<span class="gi">+            )</span>
<span class="gi">+        method_lines.append(tab + f&quot;return self.{_HASH_CACHE_FIELD}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        append_hash_computation_lines(&quot;return &quot;, tab)</span>
<span class="gi">+</span>
<span class="gi">+    script = &quot;\n&quot;.join(method_lines)</span>
<span class="gi">+    return _make_method(&quot;__hash__&quot;, script, unique_filename, globs)</span>


<span class="w"> </span>def _add_hash(cls, attrs):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Add a hash method to *cls*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cls.__hash__ = _make_hash(cls, attrs, frozen=False, cache_hash=False)</span>
<span class="gi">+    return cls</span>


<span class="w"> </span>def _make_ne():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create __ne__ method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def __ne__(self, other):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Check equality and either forward a NotImplemented or</span>
<span class="gi">+        return the result negated.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        result = self.__eq__(other)</span>
<span class="gi">+        if result is NotImplemented:</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        return not result</span>
<span class="gi">+</span>
<span class="gi">+    return __ne__</span>


<span class="w"> </span>def _make_eq(cls, attrs):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create __eq__ method for *cls* with *attrs*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs = [a for a in attrs if a.eq]</span>
<span class="gi">+</span>
<span class="gi">+    unique_filename = _generate_unique_filename(cls, &quot;eq&quot;)</span>
<span class="gi">+    lines = [</span>
<span class="gi">+        &quot;def __eq__(self, other):&quot;,</span>
<span class="gi">+        &quot;    if other.__class__ is not self.__class__:&quot;,</span>
<span class="gi">+        &quot;        return NotImplemented&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # We can&#39;t just do a big self.x = other.x and... clause due to</span>
<span class="gi">+    # irregularities like nan == nan is false but (nan,) == (nan,) is true.</span>
<span class="gi">+    globs = {}</span>
<span class="gi">+    if attrs:</span>
<span class="gi">+        lines.append(&quot;    return  (&quot;)</span>
<span class="gi">+        for a in attrs:</span>
<span class="gi">+            if a.eq_key:</span>
<span class="gi">+                cmp_name = f&quot;_{a.name}_key&quot;</span>
<span class="gi">+                # Add the key function to the global namespace</span>
<span class="gi">+                # of the evaluated function.</span>
<span class="gi">+                globs[cmp_name] = a.eq_key</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    f&quot;        {cmp_name}(self.{a.name}) == {cmp_name}(other.{a.name})&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(f&quot;        self.{a.name} == other.{a.name}&quot;)</span>
<span class="gi">+            if a is not attrs[-1]:</span>
<span class="gi">+                lines[-1] = f&quot;{lines[-1]} and&quot;</span>
<span class="gi">+        lines.append(&quot;    )&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        lines.append(&quot;    return True&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    script = &quot;\n&quot;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+    return _make_method(&quot;__eq__&quot;, script, unique_filename, globs)</span>


<span class="w"> </span>def _make_order(cls, attrs):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create ordering methods for *cls* with *attrs*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs = [a for a in attrs if a.order]</span>
<span class="gi">+</span>
<span class="gi">+    def attrs_to_tuple(obj):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Save us some typing.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            key(value) if key else value</span>
<span class="gi">+            for value, key in (</span>
<span class="gi">+                (getattr(obj, a.name), a.order_key) for a in attrs</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __lt__(self, other):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Automatically created by attrs.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if other.__class__ is self.__class__:</span>
<span class="gi">+            return attrs_to_tuple(self) &lt; attrs_to_tuple(other)</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def __le__(self, other):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Automatically created by attrs.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if other.__class__ is self.__class__:</span>
<span class="gi">+            return attrs_to_tuple(self) &lt;= attrs_to_tuple(other)</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def __gt__(self, other):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Automatically created by attrs.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if other.__class__ is self.__class__:</span>
<span class="gi">+            return attrs_to_tuple(self) &gt; attrs_to_tuple(other)</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    def __ge__(self, other):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Automatically created by attrs.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if other.__class__ is self.__class__:</span>
<span class="gi">+            return attrs_to_tuple(self) &gt;= attrs_to_tuple(other)</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    return __lt__, __le__, __gt__, __ge__</span>


<span class="w"> </span>def _add_eq(cls, attrs=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Add equality methods to *cls* with *attrs*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attrs is None:</span>
<span class="gi">+        attrs = cls.__attrs_attrs__</span>
<span class="gi">+</span>
<span class="gi">+    cls.__eq__ = _make_eq(cls, attrs)</span>
<span class="gi">+    cls.__ne__ = _make_ne()</span>
<span class="gi">+</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_repr(attrs, ns, cls):</span>
<span class="gi">+    unique_filename = _generate_unique_filename(cls, &quot;repr&quot;)</span>
<span class="gi">+    # Figure out which attributes to include, and which function to use to</span>
<span class="gi">+    # format them. The a.repr value can be either bool or a custom</span>
<span class="gi">+    # callable.</span>
<span class="gi">+    attr_names_with_reprs = tuple(</span>
<span class="gi">+        (a.name, (repr if a.repr is True else a.repr), a.init)</span>
<span class="gi">+        for a in attrs</span>
<span class="gi">+        if a.repr is not False</span>
<span class="gi">+    )</span>
<span class="gi">+    globs = {</span>
<span class="gi">+        name + &quot;_repr&quot;: r for name, r, _ in attr_names_with_reprs if r != repr</span>
<span class="gi">+    }</span>
<span class="gi">+    globs[&quot;_compat&quot;] = _compat</span>
<span class="gi">+    globs[&quot;AttributeError&quot;] = AttributeError</span>
<span class="gi">+    globs[&quot;NOTHING&quot;] = NOTHING</span>
<span class="gi">+    attribute_fragments = []</span>
<span class="gi">+    for name, r, i in attr_names_with_reprs:</span>
<span class="gi">+        accessor = (</span>
<span class="gi">+            &quot;self.&quot; + name if i else &#39;getattr(self, &quot;&#39; + name + &#39;&quot;, NOTHING)&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        fragment = (</span>
<span class="gi">+            &quot;%s={%s!r}&quot; % (name, accessor)</span>
<span class="gi">+            if r == repr</span>
<span class="gi">+            else &quot;%s={%s_repr(%s)}&quot; % (name, name, accessor)</span>
<span class="gi">+        )</span>
<span class="gi">+        attribute_fragments.append(fragment)</span>
<span class="gi">+    repr_fragment = &quot;, &quot;.join(attribute_fragments)</span>
<span class="gi">+</span>
<span class="gi">+    if ns is None:</span>
<span class="gi">+        cls_name_fragment = &#39;{self.__class__.__qualname__.rsplit(&quot;&gt;.&quot;, 1)[-1]}&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        cls_name_fragment = ns + &quot;.{self.__class__.__name__}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    lines = [</span>
<span class="gi">+        &quot;def __repr__(self):&quot;,</span>
<span class="gi">+        &quot;  try:&quot;,</span>
<span class="gi">+        &quot;    already_repring = _compat.repr_context.already_repring&quot;,</span>
<span class="gi">+        &quot;  except AttributeError:&quot;,</span>
<span class="gi">+        &quot;    already_repring = {id(self),}&quot;,</span>
<span class="gi">+        &quot;    _compat.repr_context.already_repring = already_repring&quot;,</span>
<span class="gi">+        &quot;  else:&quot;,</span>
<span class="gi">+        &quot;    if id(self) in already_repring:&quot;,</span>
<span class="gi">+        &quot;      return &#39;...&#39;&quot;,</span>
<span class="gi">+        &quot;    else:&quot;,</span>
<span class="gi">+        &quot;      already_repring.add(id(self))&quot;,</span>
<span class="gi">+        &quot;  try:&quot;,</span>
<span class="gi">+        f&quot;    return f&#39;{cls_name_fragment}({repr_fragment})&#39;&quot;,</span>
<span class="gi">+        &quot;  finally:&quot;,</span>
<span class="gi">+        &quot;    already_repring.remove(id(self))&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    return _make_method(</span>
<span class="gi">+        &quot;__repr__&quot;, &quot;\n&quot;.join(lines), unique_filename, globs=globs</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _add_repr(cls, ns=None, attrs=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Add a repr method to *cls*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attrs is None:</span>
<span class="gi">+        attrs = cls.__attrs_attrs__</span>
<span class="gi">+</span>
<span class="gi">+    cls.__repr__ = _make_repr(attrs, ns, cls)</span>
<span class="gi">+    return cls</span>


<span class="w"> </span>def fields(cls):
<span class="gu">@@ -498,7 +1719,27 @@ def fields(cls):</span>
<span class="w"> </span>       by name.
<span class="w"> </span>    .. versionchanged:: 23.1.0 Add support for generic classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    generic_base = get_generic_base(cls)</span>
<span class="gi">+</span>
<span class="gi">+    if generic_base is None and not isinstance(cls, type):</span>
<span class="gi">+        msg = &quot;Passed object must be a class.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    attrs = getattr(cls, &quot;__attrs_attrs__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if attrs is None:</span>
<span class="gi">+        if generic_base is not None:</span>
<span class="gi">+            attrs = getattr(generic_base, &quot;__attrs_attrs__&quot;, None)</span>
<span class="gi">+            if attrs is not None:</span>
<span class="gi">+                # Even though this is global state, stick it on here to speed</span>
<span class="gi">+                # it up. We rely on `cls` being cached for this to be</span>
<span class="gi">+                # efficient.</span>
<span class="gi">+                cls.__attrs_attrs__ = attrs</span>
<span class="gi">+                return attrs</span>
<span class="gi">+        msg = f&quot;{cls!r} is not an attrs-decorated class.&quot;</span>
<span class="gi">+        raise NotAnAttrsClassError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return attrs</span>


<span class="w"> </span>def fields_dict(cls):
<span class="gu">@@ -520,7 +1761,14 @@ def fields_dict(cls):</span>

<span class="w"> </span>    .. versionadded:: 18.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(cls, type):</span>
<span class="gi">+        msg = &quot;Passed object must be a class.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+    attrs = getattr(cls, &quot;__attrs_attrs__&quot;, None)</span>
<span class="gi">+    if attrs is None:</span>
<span class="gi">+        msg = f&quot;{cls!r} is not an attrs-decorated class.&quot;</span>
<span class="gi">+        raise NotAnAttrsClassError(msg)</span>
<span class="gi">+    return {a.name: a for a in attrs}</span>


<span class="w"> </span>def validate(inst):
<span class="gu">@@ -532,80 +1780,459 @@ def validate(inst):</span>
<span class="w"> </span>    Args:
<span class="w"> </span>        inst: Instance of a class with *attrs* attributes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _config._run_validators is False:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for a in fields(inst.__class__):</span>
<span class="gi">+        v = a.validator</span>
<span class="gi">+        if v is not None:</span>
<span class="gi">+            v(inst, a, getattr(inst, a.name))</span>


<span class="w"> </span>def _is_slot_attr(a_name, base_attr_map):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if the attribute name comes from a slot class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _setattr(attr_name: str, value_var: str, has_on_setattr: bool) -&gt;str:</span>
<span class="gi">+    cls = base_attr_map.get(a_name)</span>
<span class="gi">+    return cls and &quot;__slots__&quot; in cls.__dict__</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_init(</span>
<span class="gi">+    cls,</span>
<span class="gi">+    attrs,</span>
<span class="gi">+    pre_init,</span>
<span class="gi">+    pre_init_has_args,</span>
<span class="gi">+    post_init,</span>
<span class="gi">+    frozen,</span>
<span class="gi">+    slots,</span>
<span class="gi">+    cache_hash,</span>
<span class="gi">+    base_attr_map,</span>
<span class="gi">+    is_exc,</span>
<span class="gi">+    cls_on_setattr,</span>
<span class="gi">+    attrs_init,</span>
<span class="gi">+):</span>
<span class="gi">+    has_cls_on_setattr = (</span>
<span class="gi">+        cls_on_setattr is not None and cls_on_setattr is not setters.NO_OP</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if frozen and has_cls_on_setattr:</span>
<span class="gi">+        msg = &quot;Frozen classes can&#39;t use on_setattr.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    needs_cached_setattr = cache_hash or frozen</span>
<span class="gi">+    filtered_attrs = []</span>
<span class="gi">+    attr_dict = {}</span>
<span class="gi">+    for a in attrs:</span>
<span class="gi">+        if not a.init and a.default is NOTHING:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        filtered_attrs.append(a)</span>
<span class="gi">+        attr_dict[a.name] = a</span>
<span class="gi">+</span>
<span class="gi">+        if a.on_setattr is not None:</span>
<span class="gi">+            if frozen is True:</span>
<span class="gi">+                msg = &quot;Frozen classes can&#39;t use on_setattr.&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+            needs_cached_setattr = True</span>
<span class="gi">+        elif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:</span>
<span class="gi">+            needs_cached_setattr = True</span>
<span class="gi">+</span>
<span class="gi">+    unique_filename = _generate_unique_filename(cls, &quot;init&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    script, globs, annotations = _attrs_to_init_script(</span>
<span class="gi">+        filtered_attrs,</span>
<span class="gi">+        frozen,</span>
<span class="gi">+        slots,</span>
<span class="gi">+        pre_init,</span>
<span class="gi">+        pre_init_has_args,</span>
<span class="gi">+        post_init,</span>
<span class="gi">+        cache_hash,</span>
<span class="gi">+        base_attr_map,</span>
<span class="gi">+        is_exc,</span>
<span class="gi">+        needs_cached_setattr,</span>
<span class="gi">+        has_cls_on_setattr,</span>
<span class="gi">+        &quot;__attrs_init__&quot; if attrs_init else &quot;__init__&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    if cls.__module__ in sys.modules:</span>
<span class="gi">+        # This makes typing.get_type_hints(CLS.__init__) resolve string types.</span>
<span class="gi">+        globs.update(sys.modules[cls.__module__].__dict__)</span>
<span class="gi">+</span>
<span class="gi">+    globs.update({&quot;NOTHING&quot;: NOTHING, &quot;attr_dict&quot;: attr_dict})</span>
<span class="gi">+</span>
<span class="gi">+    if needs_cached_setattr:</span>
<span class="gi">+        # Save the lookup overhead in __init__ if we need to circumvent</span>
<span class="gi">+        # setattr hooks.</span>
<span class="gi">+        globs[&quot;_cached_setattr_get&quot;] = _OBJ_SETATTR.__get__</span>
<span class="gi">+</span>
<span class="gi">+    init = _make_method(</span>
<span class="gi">+        &quot;__attrs_init__&quot; if attrs_init else &quot;__init__&quot;,</span>
<span class="gi">+        script,</span>
<span class="gi">+        unique_filename,</span>
<span class="gi">+        globs,</span>
<span class="gi">+    )</span>
<span class="gi">+    init.__annotations__ = annotations</span>
<span class="gi">+</span>
<span class="gi">+    return init</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _setattr(attr_name: str, value_var: str, has_on_setattr: bool) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Use the cached object.setattr to set *attr_name* to *value_var*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&quot;_setattr(&#39;{attr_name}&#39;, {value_var})&quot;</span>


<span class="gd">-def _setattr_with_converter(attr_name: str, value_var: str, has_on_setattr:</span>
<span class="gd">-    bool, converter: Converter) -&gt;str:</span>
<span class="gi">+def _setattr_with_converter(</span>
<span class="gi">+    attr_name: str, value_var: str, has_on_setattr: bool, converter: Converter</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Use the cached object.setattr to set *attr_name* to *value_var*, but run
<span class="w"> </span>    its converter first.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&quot;_setattr(&#39;{attr_name}&#39;, {converter._fmt_converter_call(attr_name, value_var)})&quot;</span>


<span class="gd">-def _assign(attr_name: str, value: str, has_on_setattr: bool) -&gt;str:</span>
<span class="gi">+def _assign(attr_name: str, value: str, has_on_setattr: bool) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise
<span class="w"> </span>    relegate to _setattr.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if has_on_setattr:</span>
<span class="gi">+        return _setattr(attr_name, value, True)</span>
<span class="gi">+</span>
<span class="gi">+    return f&quot;self.{attr_name} = {value}&quot;</span>


<span class="gd">-def _assign_with_converter(attr_name: str, value_var: str, has_on_setattr:</span>
<span class="gd">-    bool, converter: Converter) -&gt;str:</span>
<span class="gi">+def _assign_with_converter(</span>
<span class="gi">+    attr_name: str, value_var: str, has_on_setattr: bool, converter: Converter</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Unless *attr_name* has an on_setattr hook, use normal assignment after
<span class="w"> </span>    conversion. Otherwise relegate to _setattr_with_converter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if has_on_setattr:</span>
<span class="gi">+        return _setattr_with_converter(attr_name, value_var, True, converter)</span>

<span class="gi">+    return f&quot;self.{attr_name} = {converter._fmt_converter_call(attr_name, value_var)}&quot;</span>

<span class="gd">-def _determine_setters(frozen: bool, slots: bool, base_attr_map: dict[str,</span>
<span class="gd">-    type]):</span>
<span class="gi">+</span>
<span class="gi">+def _determine_setters(</span>
<span class="gi">+    frozen: bool, slots: bool, base_attr_map: dict[str, type]</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine the correct setter functions based on whether a class is frozen
<span class="w"> </span>    and/or slotted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _attrs_to_init_script(attrs: list[Attribute], is_frozen: bool,</span>
<span class="gd">-    is_slotted: bool, call_pre_init: bool, pre_init_has_args: bool,</span>
<span class="gd">-    call_post_init: bool, does_cache_hash: bool, base_attr_map: dict[str,</span>
<span class="gd">-    type], is_exc: bool, needs_cached_setattr: bool, has_cls_on_setattr:</span>
<span class="gd">-    bool, method_name: str) -&gt;tuple[str, dict, dict]:</span>
<span class="gi">+    if frozen is True:</span>
<span class="gi">+        if slots is True:</span>
<span class="gi">+            return (), _setattr, _setattr_with_converter</span>
<span class="gi">+</span>
<span class="gi">+        # Dict frozen classes assign directly to __dict__.</span>
<span class="gi">+        # But only if the attribute doesn&#39;t come from an ancestor slot</span>
<span class="gi">+        # class.</span>
<span class="gi">+        # Note _inst_dict will be used again below if cache_hash is True</span>
<span class="gi">+</span>
<span class="gi">+        def fmt_setter(</span>
<span class="gi">+            attr_name: str, value_var: str, has_on_setattr: bool</span>
<span class="gi">+        ) -&gt; str:</span>
<span class="gi">+            if _is_slot_attr(attr_name, base_attr_map):</span>
<span class="gi">+                return _setattr(attr_name, value_var, has_on_setattr)</span>
<span class="gi">+</span>
<span class="gi">+            return f&quot;_inst_dict[&#39;{attr_name}&#39;] = {value_var}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def fmt_setter_with_converter(</span>
<span class="gi">+            attr_name: str,</span>
<span class="gi">+            value_var: str,</span>
<span class="gi">+            has_on_setattr: bool,</span>
<span class="gi">+            converter: Converter,</span>
<span class="gi">+        ) -&gt; str:</span>
<span class="gi">+            if has_on_setattr or _is_slot_attr(attr_name, base_attr_map):</span>
<span class="gi">+                return _setattr_with_converter(</span>
<span class="gi">+                    attr_name, value_var, has_on_setattr, converter</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return f&quot;_inst_dict[&#39;{attr_name}&#39;] = {converter._fmt_converter_call(attr_name, value_var)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            (&quot;_inst_dict = self.__dict__&quot;,),</span>
<span class="gi">+            fmt_setter,</span>
<span class="gi">+            fmt_setter_with_converter,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Not frozen -- we can just assign directly.</span>
<span class="gi">+    return (), _assign, _assign_with_converter</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _attrs_to_init_script(</span>
<span class="gi">+    attrs: list[Attribute],</span>
<span class="gi">+    is_frozen: bool,</span>
<span class="gi">+    is_slotted: bool,</span>
<span class="gi">+    call_pre_init: bool,</span>
<span class="gi">+    pre_init_has_args: bool,</span>
<span class="gi">+    call_post_init: bool,</span>
<span class="gi">+    does_cache_hash: bool,</span>
<span class="gi">+    base_attr_map: dict[str, type],</span>
<span class="gi">+    is_exc: bool,</span>
<span class="gi">+    needs_cached_setattr: bool,</span>
<span class="gi">+    has_cls_on_setattr: bool,</span>
<span class="gi">+    method_name: str,</span>
<span class="gi">+) -&gt; tuple[str, dict, dict]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a script of an initializer for *attrs*, a dict of globals, and
<span class="w"> </span>    annotations for the initializer.

<span class="w"> </span>    The globals are required by the generated script.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _default_init_alias_for(name: str) -&gt;str:</span>
<span class="gi">+    lines = [&quot;self.__attrs_pre_init__()&quot;] if call_pre_init else []</span>
<span class="gi">+</span>
<span class="gi">+    if needs_cached_setattr:</span>
<span class="gi">+        lines.append(</span>
<span class="gi">+            # Circumvent the __setattr__ descriptor to save one lookup per</span>
<span class="gi">+            # assignment. Note _setattr will be used again below if</span>
<span class="gi">+            # does_cache_hash is True.</span>
<span class="gi">+            &quot;_setattr = _cached_setattr_get(self)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    extra_lines, fmt_setter, fmt_setter_with_converter = _determine_setters(</span>
<span class="gi">+        is_frozen, is_slotted, base_attr_map</span>
<span class="gi">+    )</span>
<span class="gi">+    lines.extend(extra_lines)</span>
<span class="gi">+</span>
<span class="gi">+    args = []</span>
<span class="gi">+    kw_only_args = []</span>
<span class="gi">+    attrs_to_validate = []</span>
<span class="gi">+</span>
<span class="gi">+    # This is a dictionary of names to validator and converter callables.</span>
<span class="gi">+    # Injecting this into __init__ globals lets us avoid lookups.</span>
<span class="gi">+    names_for_globals = {}</span>
<span class="gi">+    annotations = {&quot;return&quot;: None}</span>
<span class="gi">+</span>
<span class="gi">+    for a in attrs:</span>
<span class="gi">+        if a.validator:</span>
<span class="gi">+            attrs_to_validate.append(a)</span>
<span class="gi">+</span>
<span class="gi">+        attr_name = a.name</span>
<span class="gi">+        has_on_setattr = a.on_setattr is not None or (</span>
<span class="gi">+            a.on_setattr is not setters.NO_OP and has_cls_on_setattr</span>
<span class="gi">+        )</span>
<span class="gi">+        # a.alias is set to maybe-mangled attr_name in _ClassBuilder if not</span>
<span class="gi">+        # explicitly provided</span>
<span class="gi">+        arg_name = a.alias</span>
<span class="gi">+</span>
<span class="gi">+        has_factory = isinstance(a.default, Factory)</span>
<span class="gi">+        maybe_self = &quot;self&quot; if has_factory and a.default.takes_self else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if a.converter and not isinstance(a.converter, Converter):</span>
<span class="gi">+            converter = Converter(a.converter)</span>
<span class="gi">+        else:</span>
<span class="gi">+            converter = a.converter</span>
<span class="gi">+</span>
<span class="gi">+        if a.init is False:</span>
<span class="gi">+            if has_factory:</span>
<span class="gi">+                init_factory_name = _INIT_FACTORY_PAT % (a.name,)</span>
<span class="gi">+                if converter is not None:</span>
<span class="gi">+                    lines.append(</span>
<span class="gi">+                        fmt_setter_with_converter(</span>
<span class="gi">+                            attr_name,</span>
<span class="gi">+                            init_factory_name + f&quot;({maybe_self})&quot;,</span>
<span class="gi">+                            has_on_setattr,</span>
<span class="gi">+                            converter,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                    names_for_globals[converter._get_global_name(a.name)] = (</span>
<span class="gi">+                        converter.converter</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines.append(</span>
<span class="gi">+                        fmt_setter(</span>
<span class="gi">+                            attr_name,</span>
<span class="gi">+                            init_factory_name + f&quot;({maybe_self})&quot;,</span>
<span class="gi">+                            has_on_setattr,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                names_for_globals[init_factory_name] = a.default.factory</span>
<span class="gi">+            elif converter is not None:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    fmt_setter_with_converter(</span>
<span class="gi">+                        attr_name,</span>
<span class="gi">+                        f&quot;attr_dict[&#39;{attr_name}&#39;].default&quot;,</span>
<span class="gi">+                        has_on_setattr,</span>
<span class="gi">+                        converter,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                names_for_globals[converter._get_global_name(a.name)] = (</span>
<span class="gi">+                    converter.converter</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    fmt_setter(</span>
<span class="gi">+                        attr_name,</span>
<span class="gi">+                        f&quot;attr_dict[&#39;{attr_name}&#39;].default&quot;,</span>
<span class="gi">+                        has_on_setattr,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+        elif a.default is not NOTHING and not has_factory:</span>
<span class="gi">+            arg = f&quot;{arg_name}=attr_dict[&#39;{attr_name}&#39;].default&quot;</span>
<span class="gi">+            if a.kw_only:</span>
<span class="gi">+                kw_only_args.append(arg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                args.append(arg)</span>
<span class="gi">+</span>
<span class="gi">+            if converter is not None:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    fmt_setter_with_converter(</span>
<span class="gi">+                        attr_name, arg_name, has_on_setattr, converter</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                names_for_globals[converter._get_global_name(a.name)] = (</span>
<span class="gi">+                    converter.converter</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))</span>
<span class="gi">+</span>
<span class="gi">+        elif has_factory:</span>
<span class="gi">+            arg = f&quot;{arg_name}=NOTHING&quot;</span>
<span class="gi">+            if a.kw_only:</span>
<span class="gi">+                kw_only_args.append(arg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                args.append(arg)</span>
<span class="gi">+            lines.append(f&quot;if {arg_name} is not NOTHING:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            init_factory_name = _INIT_FACTORY_PAT % (a.name,)</span>
<span class="gi">+            if converter is not None:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    &quot;    &quot;</span>
<span class="gi">+                    + fmt_setter_with_converter(</span>
<span class="gi">+                        attr_name, arg_name, has_on_setattr, converter</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                lines.append(&quot;else:&quot;)</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    &quot;    &quot;</span>
<span class="gi">+                    + fmt_setter_with_converter(</span>
<span class="gi">+                        attr_name,</span>
<span class="gi">+                        init_factory_name + &quot;(&quot; + maybe_self + &quot;)&quot;,</span>
<span class="gi">+                        has_on_setattr,</span>
<span class="gi">+                        converter,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                names_for_globals[converter._get_global_name(a.name)] = (</span>
<span class="gi">+                    converter.converter</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    &quot;    &quot; + fmt_setter(attr_name, arg_name, has_on_setattr)</span>
<span class="gi">+                )</span>
<span class="gi">+                lines.append(&quot;else:&quot;)</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    &quot;    &quot;</span>
<span class="gi">+                    + fmt_setter(</span>
<span class="gi">+                        attr_name,</span>
<span class="gi">+                        init_factory_name + &quot;(&quot; + maybe_self + &quot;)&quot;,</span>
<span class="gi">+                        has_on_setattr,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            names_for_globals[init_factory_name] = a.default.factory</span>
<span class="gi">+        else:</span>
<span class="gi">+            if a.kw_only:</span>
<span class="gi">+                kw_only_args.append(arg_name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                args.append(arg_name)</span>
<span class="gi">+</span>
<span class="gi">+            if converter is not None:</span>
<span class="gi">+                lines.append(</span>
<span class="gi">+                    fmt_setter_with_converter(</span>
<span class="gi">+                        attr_name, arg_name, has_on_setattr, converter</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                names_for_globals[converter._get_global_name(a.name)] = (</span>
<span class="gi">+                    converter.converter</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))</span>
<span class="gi">+</span>
<span class="gi">+        if a.init is True:</span>
<span class="gi">+            if a.type is not None and converter is None:</span>
<span class="gi">+                annotations[arg_name] = a.type</span>
<span class="gi">+            elif converter is not None and converter._first_param_type:</span>
<span class="gi">+                # Use the type from the converter if present.</span>
<span class="gi">+                annotations[arg_name] = converter._first_param_type</span>
<span class="gi">+</span>
<span class="gi">+    if attrs_to_validate:  # we can skip this if there are no validators.</span>
<span class="gi">+        names_for_globals[&quot;_config&quot;] = _config</span>
<span class="gi">+        lines.append(&quot;if _config._run_validators is True:&quot;)</span>
<span class="gi">+        for a in attrs_to_validate:</span>
<span class="gi">+            val_name = &quot;__attr_validator_&quot; + a.name</span>
<span class="gi">+            attr_name = &quot;__attr_&quot; + a.name</span>
<span class="gi">+            lines.append(f&quot;    {val_name}(self, {attr_name}, self.{a.name})&quot;)</span>
<span class="gi">+            names_for_globals[val_name] = a.validator</span>
<span class="gi">+            names_for_globals[attr_name] = a</span>
<span class="gi">+</span>
<span class="gi">+    if call_post_init:</span>
<span class="gi">+        lines.append(&quot;self.__attrs_post_init__()&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Because this is set only after __attrs_post_init__ is called, a crash</span>
<span class="gi">+    # will result if post-init tries to access the hash code.  This seemed</span>
<span class="gi">+    # preferable to setting this beforehand, in which case alteration to field</span>
<span class="gi">+    # values during post-init combined with post-init accessing the hash code</span>
<span class="gi">+    # would result in silent bugs.</span>
<span class="gi">+    if does_cache_hash:</span>
<span class="gi">+        if is_frozen:</span>
<span class="gi">+            if is_slotted:</span>
<span class="gi">+                init_hash_cache = f&quot;_setattr(&#39;{_HASH_CACHE_FIELD}&#39;, None)&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                init_hash_cache = f&quot;_inst_dict[&#39;{_HASH_CACHE_FIELD}&#39;] = None&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            init_hash_cache = f&quot;self.{_HASH_CACHE_FIELD} = None&quot;</span>
<span class="gi">+        lines.append(init_hash_cache)</span>
<span class="gi">+</span>
<span class="gi">+    # For exceptions we rely on BaseException.__init__ for proper</span>
<span class="gi">+    # initialization.</span>
<span class="gi">+    if is_exc:</span>
<span class="gi">+        vals = &quot;,&quot;.join(f&quot;self.{a.name}&quot; for a in attrs if a.init)</span>
<span class="gi">+</span>
<span class="gi">+        lines.append(f&quot;BaseException.__init__(self, {vals})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    args = &quot;, &quot;.join(args)</span>
<span class="gi">+    pre_init_args = args</span>
<span class="gi">+    if kw_only_args:</span>
<span class="gi">+        # leading comma &amp; kw_only args</span>
<span class="gi">+        args += f&quot;{&#39;, &#39; if args else &#39;&#39;}*, {&#39;, &#39;.join(kw_only_args)}&quot;</span>
<span class="gi">+        pre_init_kw_only_args = &quot;, &quot;.join(</span>
<span class="gi">+            [</span>
<span class="gi">+                f&quot;{kw_arg_name}={kw_arg_name}&quot;</span>
<span class="gi">+                # We need to remove the defaults from the kw_only_args.</span>
<span class="gi">+                for kw_arg_name in (kwa.split(&quot;=&quot;)[0] for kwa in kw_only_args)</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+        pre_init_args += &quot;, &quot; if pre_init_args else &quot;&quot;</span>
<span class="gi">+        pre_init_args += pre_init_kw_only_args</span>
<span class="gi">+</span>
<span class="gi">+    if call_pre_init and pre_init_has_args:</span>
<span class="gi">+        # If pre init method has arguments, pass same arguments as `__init__`.</span>
<span class="gi">+        lines[0] = f&quot;self.__attrs_pre_init__({pre_init_args})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Python 3.7 doesn&#39;t allow backslashes in f strings.</span>
<span class="gi">+    NL = &quot;\n    &quot;</span>
<span class="gi">+    return (</span>
<span class="gi">+        f&quot;&quot;&quot;def {method_name}(self, {args}):</span>
<span class="gi">+    {NL.join(lines) if lines else &#39;pass&#39;}</span>
<span class="gi">+&quot;&quot;&quot;,</span>
<span class="gi">+        names_for_globals,</span>
<span class="gi">+        annotations,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _default_init_alias_for(name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The default __init__ parameter name for a field.

<span class="w"> </span>    This performs private-name adjustment via leading-unscore stripping,
<span class="w"> </span>    and is the default value of Attribute.alias if not provided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return name.lstrip(&quot;_&quot;)</span>


<span class="w"> </span>class Attribute:
<span class="gu">@@ -650,39 +2277,116 @@ class Attribute:</span>

<span class="w"> </span>    For the full version history of the fields, see `attr.ib`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;name&#39;, &#39;default&#39;, &#39;validator&#39;, &#39;repr&#39;, &#39;eq&#39;, &#39;eq_key&#39;,</span>
<span class="gd">-        &#39;order&#39;, &#39;order_key&#39;, &#39;hash&#39;, &#39;init&#39;, &#39;metadata&#39;, &#39;type&#39;,</span>
<span class="gd">-        &#39;converter&#39;, &#39;kw_only&#39;, &#39;inherited&#39;, &#39;on_setattr&#39;, &#39;alias&#39;)</span>

<span class="gd">-    def __init__(self, name, default, validator, repr, cmp, hash, init,</span>
<span class="gd">-        inherited, metadata=None, type=None, converter=None, kw_only=False,</span>
<span class="gd">-        eq=None, eq_key=None, order=None, order_key=None, on_setattr=None,</span>
<span class="gd">-        alias=None):</span>
<span class="gd">-        eq, eq_key, order, order_key = _determine_attrib_eq_order(cmp, </span>
<span class="gd">-            eq_key or eq, order_key or order, True)</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;name&quot;,</span>
<span class="gi">+        &quot;default&quot;,</span>
<span class="gi">+        &quot;validator&quot;,</span>
<span class="gi">+        &quot;repr&quot;,</span>
<span class="gi">+        &quot;eq&quot;,</span>
<span class="gi">+        &quot;eq_key&quot;,</span>
<span class="gi">+        &quot;order&quot;,</span>
<span class="gi">+        &quot;order_key&quot;,</span>
<span class="gi">+        &quot;hash&quot;,</span>
<span class="gi">+        &quot;init&quot;,</span>
<span class="gi">+        &quot;metadata&quot;,</span>
<span class="gi">+        &quot;type&quot;,</span>
<span class="gi">+        &quot;converter&quot;,</span>
<span class="gi">+        &quot;kw_only&quot;,</span>
<span class="gi">+        &quot;inherited&quot;,</span>
<span class="gi">+        &quot;on_setattr&quot;,</span>
<span class="gi">+        &quot;alias&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name,</span>
<span class="gi">+        default,</span>
<span class="gi">+        validator,</span>
<span class="gi">+        repr,</span>
<span class="gi">+        cmp,  # XXX: unused, remove along with other cmp code.</span>
<span class="gi">+        hash,</span>
<span class="gi">+        init,</span>
<span class="gi">+        inherited,</span>
<span class="gi">+        metadata=None,</span>
<span class="gi">+        type=None,</span>
<span class="gi">+        converter=None,</span>
<span class="gi">+        kw_only=False,</span>
<span class="gi">+        eq=None,</span>
<span class="gi">+        eq_key=None,</span>
<span class="gi">+        order=None,</span>
<span class="gi">+        order_key=None,</span>
<span class="gi">+        on_setattr=None,</span>
<span class="gi">+        alias=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        eq, eq_key, order, order_key = _determine_attrib_eq_order(</span>
<span class="gi">+            cmp, eq_key or eq, order_key or order, True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Cache this descriptor here to speed things up later.</span>
<span class="w"> </span>        bound_setattr = _OBJ_SETATTR.__get__(self)
<span class="gd">-        bound_setattr(&#39;name&#39;, name)</span>
<span class="gd">-        bound_setattr(&#39;default&#39;, default)</span>
<span class="gd">-        bound_setattr(&#39;validator&#39;, validator)</span>
<span class="gd">-        bound_setattr(&#39;repr&#39;, repr)</span>
<span class="gd">-        bound_setattr(&#39;eq&#39;, eq)</span>
<span class="gd">-        bound_setattr(&#39;eq_key&#39;, eq_key)</span>
<span class="gd">-        bound_setattr(&#39;order&#39;, order)</span>
<span class="gd">-        bound_setattr(&#39;order_key&#39;, order_key)</span>
<span class="gd">-        bound_setattr(&#39;hash&#39;, hash)</span>
<span class="gd">-        bound_setattr(&#39;init&#39;, init)</span>
<span class="gd">-        bound_setattr(&#39;converter&#39;, converter)</span>
<span class="gd">-        bound_setattr(&#39;metadata&#39;, types.MappingProxyType(dict(metadata)) if</span>
<span class="gd">-            metadata else _EMPTY_METADATA_SINGLETON)</span>
<span class="gd">-        bound_setattr(&#39;type&#39;, type)</span>
<span class="gd">-        bound_setattr(&#39;kw_only&#39;, kw_only)</span>
<span class="gd">-        bound_setattr(&#39;inherited&#39;, inherited)</span>
<span class="gd">-        bound_setattr(&#39;on_setattr&#39;, on_setattr)</span>
<span class="gd">-        bound_setattr(&#39;alias&#39;, alias)</span>
<span class="gi">+</span>
<span class="gi">+        # Despite the big red warning, people *do* instantiate `Attribute`</span>
<span class="gi">+        # themselves.</span>
<span class="gi">+        bound_setattr(&quot;name&quot;, name)</span>
<span class="gi">+        bound_setattr(&quot;default&quot;, default)</span>
<span class="gi">+        bound_setattr(&quot;validator&quot;, validator)</span>
<span class="gi">+        bound_setattr(&quot;repr&quot;, repr)</span>
<span class="gi">+        bound_setattr(&quot;eq&quot;, eq)</span>
<span class="gi">+        bound_setattr(&quot;eq_key&quot;, eq_key)</span>
<span class="gi">+        bound_setattr(&quot;order&quot;, order)</span>
<span class="gi">+        bound_setattr(&quot;order_key&quot;, order_key)</span>
<span class="gi">+        bound_setattr(&quot;hash&quot;, hash)</span>
<span class="gi">+        bound_setattr(&quot;init&quot;, init)</span>
<span class="gi">+        bound_setattr(&quot;converter&quot;, converter)</span>
<span class="gi">+        bound_setattr(</span>
<span class="gi">+            &quot;metadata&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                types.MappingProxyType(dict(metadata))  # Shallow copy</span>
<span class="gi">+                if metadata</span>
<span class="gi">+                else _EMPTY_METADATA_SINGLETON</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        bound_setattr(&quot;type&quot;, type)</span>
<span class="gi">+        bound_setattr(&quot;kw_only&quot;, kw_only)</span>
<span class="gi">+        bound_setattr(&quot;inherited&quot;, inherited)</span>
<span class="gi">+        bound_setattr(&quot;on_setattr&quot;, on_setattr)</span>
<span class="gi">+        bound_setattr(&quot;alias&quot;, alias)</span>

<span class="w"> </span>    def __setattr__(self, name, value):
<span class="w"> </span>        raise FrozenInstanceError()

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_counting_attr(cls, name, ca, type=None):</span>
<span class="gi">+        # type holds the annotated value. deal with conflicts:</span>
<span class="gi">+        if type is None:</span>
<span class="gi">+            type = ca.type</span>
<span class="gi">+        elif ca.type is not None:</span>
<span class="gi">+            msg = &quot;Type annotation and type argument cannot both be present&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        inst_dict = {</span>
<span class="gi">+            k: getattr(ca, k)</span>
<span class="gi">+            for k in Attribute.__slots__</span>
<span class="gi">+            if k</span>
<span class="gi">+            not in (</span>
<span class="gi">+                &quot;name&quot;,</span>
<span class="gi">+                &quot;validator&quot;,</span>
<span class="gi">+                &quot;default&quot;,</span>
<span class="gi">+                &quot;type&quot;,</span>
<span class="gi">+                &quot;inherited&quot;,</span>
<span class="gi">+            )  # exclude methods and deprecated alias</span>
<span class="gi">+        }</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            name=name,</span>
<span class="gi">+            validator=ca._validator,</span>
<span class="gi">+            default=ca._default,</span>
<span class="gi">+            type=type,</span>
<span class="gi">+            cmp=None,</span>
<span class="gi">+            inherited=False,</span>
<span class="gi">+            **inst_dict,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Don&#39;t use attrs.evolve since fields(Attribute) doesn&#39;t work</span>
<span class="w"> </span>    def evolve(self, **changes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy *self* and apply *changes*.
<span class="gu">@@ -694,14 +2398,21 @@ class Attribute:</span>

<span class="w"> </span>        .. versionadded:: 20.3.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = copy.copy(self)</span>
<span class="gi">+</span>
<span class="gi">+        new._setattrs(changes.items())</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>

<span class="gi">+    # Don&#39;t use _add_pickle since fields(Attribute) doesn&#39;t work</span>
<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Play nice with pickle.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return tuple(getattr(self, name) if name != &#39;metadata&#39; else dict(</span>
<span class="gd">-            self.metadata) for name in self.__slots__)</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            getattr(self, name) if name != &quot;metadata&quot; else dict(self.metadata)</span>
<span class="gi">+            for name in self.__slots__</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -709,14 +2420,46 @@ class Attribute:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._setattrs(zip(self.__slots__, state))

<span class="gd">-</span>
<span class="gd">-_a = [Attribute(name=name, default=NOTHING, validator=None, repr=True, cmp=</span>
<span class="gd">-    None, eq=True, order=False, hash=name != &#39;metadata&#39;, init=True,</span>
<span class="gd">-    inherited=False, alias=_default_init_alias_for(name)) for name in</span>
<span class="gd">-    Attribute.__slots__]</span>
<span class="gd">-Attribute = _add_hash(_add_eq(_add_repr(Attribute, attrs=_a), attrs=[a for</span>
<span class="gd">-    a in _a if a.name != &#39;inherited&#39;]), attrs=[a for a in _a if a.hash and </span>
<span class="gd">-    a.name != &#39;inherited&#39;])</span>
<span class="gi">+    def _setattrs(self, name_values_pairs):</span>
<span class="gi">+        bound_setattr = _OBJ_SETATTR.__get__(self)</span>
<span class="gi">+        for name, value in name_values_pairs:</span>
<span class="gi">+            if name != &quot;metadata&quot;:</span>
<span class="gi">+                bound_setattr(name, value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                bound_setattr(</span>
<span class="gi">+                    name,</span>
<span class="gi">+                    (</span>
<span class="gi">+                        types.MappingProxyType(dict(value))</span>
<span class="gi">+                        if value</span>
<span class="gi">+                        else _EMPTY_METADATA_SINGLETON</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_a = [</span>
<span class="gi">+    Attribute(</span>
<span class="gi">+        name=name,</span>
<span class="gi">+        default=NOTHING,</span>
<span class="gi">+        validator=None,</span>
<span class="gi">+        repr=True,</span>
<span class="gi">+        cmp=None,</span>
<span class="gi">+        eq=True,</span>
<span class="gi">+        order=False,</span>
<span class="gi">+        hash=(name != &quot;metadata&quot;),</span>
<span class="gi">+        init=True,</span>
<span class="gi">+        inherited=False,</span>
<span class="gi">+        alias=_default_init_alias_for(name),</span>
<span class="gi">+    )</span>
<span class="gi">+    for name in Attribute.__slots__</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+Attribute = _add_hash(</span>
<span class="gi">+    _add_eq(</span>
<span class="gi">+        _add_repr(Attribute, attrs=_a),</span>
<span class="gi">+        attrs=[a for a in _a if a.name != &quot;inherited&quot;],</span>
<span class="gi">+    ),</span>
<span class="gi">+    attrs=[a for a in _a if a.hash and a.name != &quot;inherited&quot;],</span>
<span class="gi">+)</span>


<span class="w"> </span>class _CountingAttr:
<span class="gu">@@ -727,24 +2470,95 @@ class _CountingAttr:</span>
<span class="w"> </span>    *Internal* data structure of the attrs library.  Running into is most
<span class="w"> </span>    likely the result of a bug like a forgotten `@attr.s` decorator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;counter&#39;, &#39;_default&#39;, &#39;repr&#39;, &#39;eq&#39;, &#39;eq_key&#39;, &#39;order&#39;,</span>
<span class="gd">-        &#39;order_key&#39;, &#39;hash&#39;, &#39;init&#39;, &#39;metadata&#39;, &#39;_validator&#39;, &#39;converter&#39;,</span>
<span class="gd">-        &#39;type&#39;, &#39;kw_only&#39;, &#39;on_setattr&#39;, &#39;alias&#39;)</span>
<span class="gd">-    __attrs_attrs__ = *tuple(Attribute(name=name, alias=</span>
<span class="gd">-        _default_init_alias_for(name), default=NOTHING, validator=None,</span>
<span class="gd">-        repr=True, cmp=None, hash=True, init=True, kw_only=False, eq=True,</span>
<span class="gd">-        eq_key=None, order=False, order_key=None, inherited=False,</span>
<span class="gd">-        on_setattr=None) for name in (&#39;counter&#39;, &#39;_default&#39;, &#39;repr&#39;, &#39;eq&#39;,</span>
<span class="gd">-        &#39;order&#39;, &#39;hash&#39;, &#39;init&#39;, &#39;on_setattr&#39;, &#39;alias&#39;)), Attribute(name=</span>
<span class="gd">-        &#39;metadata&#39;, alias=&#39;metadata&#39;, default=None, validator=None, repr=</span>
<span class="gd">-        True, cmp=None, hash=False, init=True, kw_only=False, eq=True,</span>
<span class="gd">-        eq_key=None, order=False, order_key=None, inherited=False,</span>
<span class="gd">-        on_setattr=None)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;counter&quot;,</span>
<span class="gi">+        &quot;_default&quot;,</span>
<span class="gi">+        &quot;repr&quot;,</span>
<span class="gi">+        &quot;eq&quot;,</span>
<span class="gi">+        &quot;eq_key&quot;,</span>
<span class="gi">+        &quot;order&quot;,</span>
<span class="gi">+        &quot;order_key&quot;,</span>
<span class="gi">+        &quot;hash&quot;,</span>
<span class="gi">+        &quot;init&quot;,</span>
<span class="gi">+        &quot;metadata&quot;,</span>
<span class="gi">+        &quot;_validator&quot;,</span>
<span class="gi">+        &quot;converter&quot;,</span>
<span class="gi">+        &quot;type&quot;,</span>
<span class="gi">+        &quot;kw_only&quot;,</span>
<span class="gi">+        &quot;on_setattr&quot;,</span>
<span class="gi">+        &quot;alias&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    __attrs_attrs__ = (</span>
<span class="gi">+        *tuple(</span>
<span class="gi">+            Attribute(</span>
<span class="gi">+                name=name,</span>
<span class="gi">+                alias=_default_init_alias_for(name),</span>
<span class="gi">+                default=NOTHING,</span>
<span class="gi">+                validator=None,</span>
<span class="gi">+                repr=True,</span>
<span class="gi">+                cmp=None,</span>
<span class="gi">+                hash=True,</span>
<span class="gi">+                init=True,</span>
<span class="gi">+                kw_only=False,</span>
<span class="gi">+                eq=True,</span>
<span class="gi">+                eq_key=None,</span>
<span class="gi">+                order=False,</span>
<span class="gi">+                order_key=None,</span>
<span class="gi">+                inherited=False,</span>
<span class="gi">+                on_setattr=None,</span>
<span class="gi">+            )</span>
<span class="gi">+            for name in (</span>
<span class="gi">+                &quot;counter&quot;,</span>
<span class="gi">+                &quot;_default&quot;,</span>
<span class="gi">+                &quot;repr&quot;,</span>
<span class="gi">+                &quot;eq&quot;,</span>
<span class="gi">+                &quot;order&quot;,</span>
<span class="gi">+                &quot;hash&quot;,</span>
<span class="gi">+                &quot;init&quot;,</span>
<span class="gi">+                &quot;on_setattr&quot;,</span>
<span class="gi">+                &quot;alias&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+        ),</span>
<span class="gi">+        Attribute(</span>
<span class="gi">+            name=&quot;metadata&quot;,</span>
<span class="gi">+            alias=&quot;metadata&quot;,</span>
<span class="gi">+            default=None,</span>
<span class="gi">+            validator=None,</span>
<span class="gi">+            repr=True,</span>
<span class="gi">+            cmp=None,</span>
<span class="gi">+            hash=False,</span>
<span class="gi">+            init=True,</span>
<span class="gi">+            kw_only=False,</span>
<span class="gi">+            eq=True,</span>
<span class="gi">+            eq_key=None,</span>
<span class="gi">+            order=False,</span>
<span class="gi">+            order_key=None,</span>
<span class="gi">+            inherited=False,</span>
<span class="gi">+            on_setattr=None,</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="w"> </span>    cls_counter = 0

<span class="gd">-    def __init__(self, default, validator, repr, cmp, hash, init, converter,</span>
<span class="gd">-        metadata, type, kw_only, eq, eq_key, order, order_key, on_setattr,</span>
<span class="gd">-        alias):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        default,</span>
<span class="gi">+        validator,</span>
<span class="gi">+        repr,</span>
<span class="gi">+        cmp,</span>
<span class="gi">+        hash,</span>
<span class="gi">+        init,</span>
<span class="gi">+        converter,</span>
<span class="gi">+        metadata,</span>
<span class="gi">+        type,</span>
<span class="gi">+        kw_only,</span>
<span class="gi">+        eq,</span>
<span class="gi">+        eq_key,</span>
<span class="gi">+        order,</span>
<span class="gi">+        order_key,</span>
<span class="gi">+        on_setattr,</span>
<span class="gi">+        alias,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        _CountingAttr.cls_counter += 1
<span class="w"> </span>        self.counter = _CountingAttr.cls_counter
<span class="w"> </span>        self._default = default
<span class="gu">@@ -771,7 +2585,11 @@ class _CountingAttr:</span>

<span class="w"> </span>        .. versionadded:: 17.1.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._validator is None:</span>
<span class="gi">+            self._validator = meth</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._validator = and_(self._validator, meth)</span>
<span class="gi">+        return meth</span>

<span class="w"> </span>    def default(self, meth):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -784,7 +2602,12 @@ class _CountingAttr:</span>

<span class="w"> </span>        .. versionadded:: 17.1.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._default is not NOTHING:</span>
<span class="gi">+            raise DefaultAlreadySetError()</span>
<span class="gi">+</span>
<span class="gi">+        self._default = Factory(meth, takes_self=True)</span>
<span class="gi">+</span>
<span class="gi">+        return meth</span>


<span class="w"> </span>_CountingAttr = _add_eq(_add_repr(_CountingAttr))
<span class="gu">@@ -808,7 +2631,8 @@ class Factory:</span>

<span class="w"> </span>    .. versionadded:: 17.1.0  *takes_self*
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;factory&#39;, &#39;takes_self&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;factory&quot;, &quot;takes_self&quot;)</span>

<span class="w"> </span>    def __init__(self, factory, takes_self=False):
<span class="w"> </span>        self.factory = factory
<span class="gu">@@ -828,9 +2652,22 @@ class Factory:</span>
<span class="w"> </span>            setattr(self, name, value)


<span class="gd">-_f = [Attribute(name=name, default=NOTHING, validator=None, repr=True, cmp=</span>
<span class="gd">-    None, eq=True, order=False, hash=True, init=True, inherited=False) for</span>
<span class="gd">-    name in Factory.__slots__]</span>
<span class="gi">+_f = [</span>
<span class="gi">+    Attribute(</span>
<span class="gi">+        name=name,</span>
<span class="gi">+        default=NOTHING,</span>
<span class="gi">+        validator=None,</span>
<span class="gi">+        repr=True,</span>
<span class="gi">+        cmp=None,</span>
<span class="gi">+        eq=True,</span>
<span class="gi">+        order=False,</span>
<span class="gi">+        hash=True,</span>
<span class="gi">+        init=True,</span>
<span class="gi">+        inherited=False,</span>
<span class="gi">+    )</span>
<span class="gi">+    for name in Factory.__slots__</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)


<span class="gu">@@ -854,53 +2691,78 @@ class Converter:</span>

<span class="w"> </span>    .. versionadded:: 24.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;converter&#39;, &#39;takes_self&#39;, &#39;takes_field&#39;,</span>
<span class="gd">-        &#39;_first_param_type&#39;, &#39;_global_name&#39;, &#39;__call__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;converter&quot;,</span>
<span class="gi">+        &quot;takes_self&quot;,</span>
<span class="gi">+        &quot;takes_field&quot;,</span>
<span class="gi">+        &quot;_first_param_type&quot;,</span>
<span class="gi">+        &quot;_global_name&quot;,</span>
<span class="gi">+        &quot;__call__&quot;,</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def __init__(self, converter, *, takes_self=False, takes_field=False):
<span class="w"> </span>        self.converter = converter
<span class="w"> </span>        self.takes_self = takes_self
<span class="w"> </span>        self.takes_field = takes_field
<span class="gi">+</span>
<span class="w"> </span>        ex = _AnnotationExtractor(converter)
<span class="w"> </span>        self._first_param_type = ex.get_first_param_type()
<span class="gi">+</span>
<span class="w"> </span>        if not (self.takes_self or self.takes_field):
<span class="w"> </span>            self.__call__ = lambda value, _, __: self.converter(value)
<span class="w"> </span>        elif self.takes_self and not self.takes_field:
<span class="gd">-            self.__call__ = lambda value, instance, __: self.converter(value,</span>
<span class="gd">-                instance)</span>
<span class="gi">+            self.__call__ = lambda value, instance, __: self.converter(</span>
<span class="gi">+                value, instance</span>
<span class="gi">+            )</span>
<span class="w"> </span>        elif not self.takes_self and self.takes_field:
<span class="gd">-            self.__call__ = lambda value, __, field: self.converter(value,</span>
<span class="gd">-                field)</span>
<span class="gi">+            self.__call__ = lambda value, __, field: self.converter(</span>
<span class="gi">+                value, field</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            self.__call__ = lambda value, instance, field: self.converter(value</span>
<span class="gd">-                , instance, field)</span>
<span class="gi">+            self.__call__ = lambda value, instance, field: self.converter(</span>
<span class="gi">+                value, instance, field</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        rt = ex.get_return_type()
<span class="w"> </span>        if rt is not None:
<span class="gd">-            self.__call__.__annotations__[&#39;return&#39;] = rt</span>
<span class="gi">+            self.__call__.__annotations__[&quot;return&quot;] = rt</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_global_name(attr_name: str) -&gt;str:</span>
<span class="gi">+    def _get_global_name(attr_name: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the name that a converter for an attribute name *attr_name*
<span class="w"> </span>        would have.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;__attr_converter_{attr_name}&quot;</span>

<span class="gd">-    def _fmt_converter_call(self, attr_name: str, value_var: str) -&gt;str:</span>
<span class="gi">+    def _fmt_converter_call(self, attr_name: str, value_var: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a string that calls the converter for an attribute name
<span class="w"> </span>        *attr_name* and the value in variable named *value_var* according to
<span class="w"> </span>        `self.takes_self` and `self.takes_field`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not (self.takes_self or self.takes_field):</span>
<span class="gi">+            return f&quot;{self._get_global_name(attr_name)}({value_var})&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.takes_self and self.takes_field:</span>
<span class="gi">+            return f&quot;{self._get_global_name(attr_name)}({value_var}, self, attr_dict[&#39;{attr_name}&#39;])&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.takes_self:</span>
<span class="gi">+            return f&quot;{self._get_global_name(attr_name)}({value_var}, self)&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{self._get_global_name(attr_name)}({value_var}, attr_dict[&#39;{attr_name}&#39;])&quot;</span>

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a dict containing only converter and takes_self -- the rest gets
<span class="w"> </span>        computed when loading.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return {&#39;converter&#39;: self.converter, &#39;takes_self&#39;: self.takes_self,</span>
<span class="gd">-            &#39;takes_field&#39;: self.takes_field}</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;converter&quot;: self.converter,</span>
<span class="gi">+            &quot;takes_self&quot;: self.takes_self,</span>
<span class="gi">+            &quot;takes_field&quot;: self.takes_field,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -909,24 +2771,39 @@ class Converter:</span>
<span class="w"> </span>        self.__init__(**state)


<span class="gd">-_f = [Attribute(name=name, default=NOTHING, validator=None, repr=True, cmp=</span>
<span class="gd">-    None, eq=True, order=False, hash=True, init=True, inherited=False) for</span>
<span class="gd">-    name in (&#39;converter&#39;, &#39;takes_self&#39;, &#39;takes_field&#39;)]</span>
<span class="gd">-Converter = _add_hash(_add_eq(_add_repr(Converter, attrs=_f), attrs=_f),</span>
<span class="gd">-    attrs=_f)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def make_class(name, attrs, bases=(object,), class_body=None, **</span>
<span class="gd">-    attributes_arguments):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+_f = [</span>
<span class="gi">+    Attribute(</span>
<span class="gi">+        name=name,</span>
<span class="gi">+        default=NOTHING,</span>
<span class="gi">+        validator=None,</span>
<span class="gi">+        repr=True,</span>
<span class="gi">+        cmp=None,</span>
<span class="gi">+        eq=True,</span>
<span class="gi">+        order=False,</span>
<span class="gi">+        hash=True,</span>
<span class="gi">+        init=True,</span>
<span class="gi">+        inherited=False,</span>
<span class="gi">+    )</span>
<span class="gi">+    for name in (&quot;converter&quot;, &quot;takes_self&quot;, &quot;takes_field&quot;)</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+Converter = _add_hash(</span>
<span class="gi">+    _add_eq(_add_repr(Converter, attrs=_f), attrs=_f), attrs=_f</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_class(</span>
<span class="gi">+    name, attrs, bases=(object,), class_body=None, **attributes_arguments</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    A quick way to create a new class called *name* with *attrs*.

<span class="w"> </span>    Args:
<span class="w"> </span>        name (str): The name for the new class.

<span class="w"> </span>        attrs( list | dict):
<span class="gd">-            A list of names or a dictionary of mappings of names to `attr.ib`\\</span>
<span class="gd">-            s / `attrs.field`\\ s.</span>
<span class="gi">+            A list of names or a dictionary of mappings of names to `attr.ib`\</span>
<span class="gi">+            s / `attrs.field`\ s.</span>

<span class="w"> </span>            The order is deduced from the order of the names or attributes
<span class="w"> </span>            inside *attrs*.  Otherwise the order of the definition of the
<span class="gu">@@ -946,7 +2823,61 @@ def make_class(name, attrs, bases=(object,), class_body=None, **</span>
<span class="w"> </span>    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.
<span class="w"> </span>    .. versionchanged:: 23.2.0 *class_body*
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(attrs, dict):</span>
<span class="gi">+        cls_dict = attrs</span>
<span class="gi">+    elif isinstance(attrs, (list, tuple)):</span>
<span class="gi">+        cls_dict = {a: attrib() for a in attrs}</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = &quot;attrs argument must be a dict or a list.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    pre_init = cls_dict.pop(&quot;__attrs_pre_init__&quot;, None)</span>
<span class="gi">+    post_init = cls_dict.pop(&quot;__attrs_post_init__&quot;, None)</span>
<span class="gi">+    user_init = cls_dict.pop(&quot;__init__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    body = {}</span>
<span class="gi">+    if class_body is not None:</span>
<span class="gi">+        body.update(class_body)</span>
<span class="gi">+    if pre_init is not None:</span>
<span class="gi">+        body[&quot;__attrs_pre_init__&quot;] = pre_init</span>
<span class="gi">+    if post_init is not None:</span>
<span class="gi">+        body[&quot;__attrs_post_init__&quot;] = post_init</span>
<span class="gi">+    if user_init is not None:</span>
<span class="gi">+        body[&quot;__init__&quot;] = user_init</span>
<span class="gi">+</span>
<span class="gi">+    type_ = types.new_class(name, bases, {}, lambda ns: ns.update(body))</span>
<span class="gi">+</span>
<span class="gi">+    # For pickling to work, the __module__ variable needs to be set to the</span>
<span class="gi">+    # frame where the class is created.  Bypass this step in environments where</span>
<span class="gi">+    # sys._getframe is not defined (Jython for example) or sys._getframe is not</span>
<span class="gi">+    # defined for arguments greater than 0 (IronPython).</span>
<span class="gi">+    with contextlib.suppress(AttributeError, ValueError):</span>
<span class="gi">+        type_.__module__ = sys._getframe(1).f_globals.get(</span>
<span class="gi">+            &quot;__name__&quot;, &quot;__main__&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # We do it here for proper warnings with meaningful stacklevel.</span>
<span class="gi">+    cmp = attributes_arguments.pop(&quot;cmp&quot;, None)</span>
<span class="gi">+    (</span>
<span class="gi">+        attributes_arguments[&quot;eq&quot;],</span>
<span class="gi">+        attributes_arguments[&quot;order&quot;],</span>
<span class="gi">+    ) = _determine_attrs_eq_order(</span>
<span class="gi">+        cmp,</span>
<span class="gi">+        attributes_arguments.get(&quot;eq&quot;),</span>
<span class="gi">+        attributes_arguments.get(&quot;order&quot;),</span>
<span class="gi">+        True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    cls = _attrs(these=cls_dict, **attributes_arguments)(type_)</span>
<span class="gi">+    # Only add type annotations now or &quot;_attrs()&quot; will complain:</span>
<span class="gi">+    cls.__annotations__ = {</span>
<span class="gi">+        k: v.type for k, v in cls_dict.items() if v.type is not None</span>
<span class="gi">+    }</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# These are required by within this module so we define them here and merely</span>
<span class="gi">+# import into .validators / .converters.</span>


<span class="w"> </span>@attrs(slots=True, unsafe_hash=True)
<span class="gu">@@ -954,6 +2885,7 @@ class _AndValidator:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Compose many validators to a single one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _validators = attrib()

<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="gu">@@ -973,7 +2905,15 @@ def and_(*validators):</span>

<span class="w"> </span>    .. versionadded:: 17.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    vals = []</span>
<span class="gi">+    for validator in validators:</span>
<span class="gi">+        vals.extend(</span>
<span class="gi">+            validator._validators</span>
<span class="gi">+            if isinstance(validator, _AndValidator)</span>
<span class="gi">+            else [validator]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return _AndValidator(tuple(vals))</span>


<span class="w"> </span>def pipe(*converters):
<span class="gu">@@ -991,4 +2931,30 @@ def pipe(*converters):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def pipe_converter(val, inst, field):</span>
<span class="gi">+        for c in converters:</span>
<span class="gi">+            val = c(val, inst, field) if isinstance(c, Converter) else c(val)</span>
<span class="gi">+</span>
<span class="gi">+        return val</span>
<span class="gi">+</span>
<span class="gi">+    if not converters:</span>
<span class="gi">+        # If the converter list is empty, pipe_converter is the identity.</span>
<span class="gi">+        A = typing.TypeVar(&quot;A&quot;)</span>
<span class="gi">+        pipe_converter.__annotations__.update({&quot;val&quot;: A, &quot;return&quot;: A})</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Get parameter type from first converter.</span>
<span class="gi">+        t = _AnnotationExtractor(converters[0]).get_first_param_type()</span>
<span class="gi">+        if t:</span>
<span class="gi">+            pipe_converter.__annotations__[&quot;val&quot;] = t</span>
<span class="gi">+</span>
<span class="gi">+        last = converters[-1]</span>
<span class="gi">+        if not PY_3_11_PLUS and isinstance(last, Converter):</span>
<span class="gi">+            last = last.__call__</span>
<span class="gi">+</span>
<span class="gi">+        # Get return type from last converter.</span>
<span class="gi">+        rt = _AnnotationExtractor(last).get_return_type()</span>
<span class="gi">+        if rt:</span>
<span class="gi">+            pipe_converter.__annotations__[&quot;return&quot;] = rt</span>
<span class="gi">+</span>
<span class="gi">+    return Converter(pipe_converter, takes_self=True, takes_field=True)</span>
<span class="gh">diff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py</span>
<span class="gh">index 067dc2f..dbb65cc 100644</span>
<span class="gd">--- a/src/attr/_next_gen.py</span>
<span class="gi">+++ b/src/attr/_next_gen.py</span>
<span class="gu">@@ -1,21 +1,51 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>These are keyword-only APIs that call `attr.s` and `attr.ib` with different
<span class="w"> </span>default values.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>from . import setters
<span class="w"> </span>from ._funcs import asdict as _asdict
<span class="w"> </span>from ._funcs import astuple as _astuple
<span class="gd">-from ._make import _DEFAULT_ON_SETATTR, NOTHING, _frozen_setattrs, attrib, attrs</span>
<span class="gi">+from ._make import (</span>
<span class="gi">+    _DEFAULT_ON_SETATTR,</span>
<span class="gi">+    NOTHING,</span>
<span class="gi">+    _frozen_setattrs,</span>
<span class="gi">+    attrib,</span>
<span class="gi">+    attrs,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .exceptions import UnannotatedAttributeError


<span class="gd">-def define(maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash</span>
<span class="gd">-    =None, init=None, slots=True, frozen=False, weakref_slot=True, str=</span>
<span class="gd">-    False, auto_attribs=None, kw_only=False, cache_hash=False, auto_exc=</span>
<span class="gd">-    True, eq=None, order=False, auto_detect=True, getstate_setstate=None,</span>
<span class="gd">-    on_setattr=None, field_transformer=None, match_args=True):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+def define(</span>
<span class="gi">+    maybe_cls=None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    these=None,</span>
<span class="gi">+    repr=None,</span>
<span class="gi">+    unsafe_hash=None,</span>
<span class="gi">+    hash=None,</span>
<span class="gi">+    init=None,</span>
<span class="gi">+    slots=True,</span>
<span class="gi">+    frozen=False,</span>
<span class="gi">+    weakref_slot=True,</span>
<span class="gi">+    str=False,</span>
<span class="gi">+    auto_attribs=None,</span>
<span class="gi">+    kw_only=False,</span>
<span class="gi">+    cache_hash=False,</span>
<span class="gi">+    auto_exc=True,</span>
<span class="gi">+    eq=None,</span>
<span class="gi">+    order=False,</span>
<span class="gi">+    auto_detect=True,</span>
<span class="gi">+    getstate_setstate=None,</span>
<span class="gi">+    on_setattr=None,</span>
<span class="gi">+    field_transformer=None,</span>
<span class="gi">+    match_args=True,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    A class decorator that adds :term:`dunder methods` according to
<span class="w"> </span>    :term:`fields &lt;field&gt;` specified using :doc:`type annotations &lt;types&gt;`,
<span class="w"> </span>    `field()` calls, or the *these* argument.
<span class="gu">@@ -99,7 +129,7 @@ def define(maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash</span>

<span class="w"> </span>        str (bool):
<span class="w"> </span>            Create a ``__str__`` method that is identical to ``__repr__``. This
<span class="gd">-            is usually not necessary except for `Exception`\\ s.</span>
<span class="gi">+            is usually not necessary except for `Exception`\ s.</span>

<span class="w"> </span>        eq (bool | None):
<span class="w"> </span>            If True or None (default), add ``__eq__`` and ``__ne__`` methods
<span class="gu">@@ -149,7 +179,7 @@ def define(maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash</span>

<span class="w"> </span>                - Our documentation on `hashing`,
<span class="w"> </span>                - Python&#39;s documentation on `object.__hash__`,
<span class="gd">-                - and the `GitHub issue that led to the default \\ behavior</span>
<span class="gi">+                - and the `GitHub issue that led to the default \ behavior</span>
<span class="w"> </span>                  &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more
<span class="w"> </span>                  details.

<span class="gu">@@ -243,9 +273,9 @@ def define(maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash</span>
<span class="w"> </span>            If left None, it will guess:

<span class="w"> </span>            1. If any attributes are annotated and no unannotated
<span class="gd">-               `attrs.field`\\ s are found, it assumes *auto_attribs=True*.</span>
<span class="gi">+               `attrs.field`\ s are found, it assumes *auto_attribs=True*.</span>
<span class="w"> </span>            2. Otherwise it assumes *auto_attribs=False* and tries to collect
<span class="gd">-               `attrs.field`\\ s.</span>
<span class="gi">+               `attrs.field`\ s.</span>

<span class="w"> </span>            If *attrs* decides to look at type annotations, **all** fields
<span class="w"> </span>            **must** be annotated. If *attrs* encounters a field that is set to
<span class="gu">@@ -313,16 +343,95 @@ def define(maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash</span>
<span class="w"> </span>          for backwards-compatibility have been removed.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def do_it(cls, auto_attribs):</span>
<span class="gi">+        return attrs(</span>
<span class="gi">+            maybe_cls=cls,</span>
<span class="gi">+            these=these,</span>
<span class="gi">+            repr=repr,</span>
<span class="gi">+            hash=hash,</span>
<span class="gi">+            unsafe_hash=unsafe_hash,</span>
<span class="gi">+            init=init,</span>
<span class="gi">+            slots=slots,</span>
<span class="gi">+            frozen=frozen,</span>
<span class="gi">+            weakref_slot=weakref_slot,</span>
<span class="gi">+            str=str,</span>
<span class="gi">+            auto_attribs=auto_attribs,</span>
<span class="gi">+            kw_only=kw_only,</span>
<span class="gi">+            cache_hash=cache_hash,</span>
<span class="gi">+            auto_exc=auto_exc,</span>
<span class="gi">+            eq=eq,</span>
<span class="gi">+            order=order,</span>
<span class="gi">+            auto_detect=auto_detect,</span>
<span class="gi">+            collect_by_mro=True,</span>
<span class="gi">+            getstate_setstate=getstate_setstate,</span>
<span class="gi">+            on_setattr=on_setattr,</span>
<span class="gi">+            field_transformer=field_transformer,</span>
<span class="gi">+            match_args=match_args,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(cls):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Making this a wrapper ensures this code runs during class creation.</span>
<span class="gi">+</span>
<span class="gi">+        We also ensure that frozen-ness of classes is inherited.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        nonlocal frozen, on_setattr</span>
<span class="gi">+</span>
<span class="gi">+        had_on_setattr = on_setattr not in (None, setters.NO_OP)</span>
<span class="gi">+</span>
<span class="gi">+        # By default, mutable classes convert &amp; validate on setattr.</span>
<span class="gi">+        if frozen is False and on_setattr is None:</span>
<span class="gi">+            on_setattr = _DEFAULT_ON_SETATTR</span>
<span class="gi">+</span>
<span class="gi">+        # However, if we subclass a frozen class, we inherit the immutability</span>
<span class="gi">+        # and disable on_setattr.</span>
<span class="gi">+        for base_cls in cls.__bases__:</span>
<span class="gi">+            if base_cls.__setattr__ is _frozen_setattrs:</span>
<span class="gi">+                if had_on_setattr:</span>
<span class="gi">+                    msg = &quot;Frozen classes can&#39;t use on_setattr (frozen-ness was inherited).&quot;</span>
<span class="gi">+                    raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+                on_setattr = setters.NO_OP</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if auto_attribs is not None:</span>
<span class="gi">+            return do_it(cls, auto_attribs)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return do_it(cls, True)</span>
<span class="gi">+        except UnannotatedAttributeError:</span>
<span class="gi">+            return do_it(cls, False)</span>
<span class="gi">+</span>
<span class="gi">+    # maybe_cls&#39;s type depends on the usage of the decorator.  It&#39;s a class</span>
<span class="gi">+    # if it&#39;s used as `@attrs` but `None` if used as `@attrs()`.</span>
<span class="gi">+    if maybe_cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+    return wrap(maybe_cls)</span>


<span class="w"> </span>mutable = define
<span class="w"> </span>frozen = partial(define, frozen=True, on_setattr=None)


<span class="gd">-def field(*, default=NOTHING, validator=None, repr=True, hash=None, init=</span>
<span class="gd">-    True, metadata=None, type=None, converter=None, factory=None, kw_only=</span>
<span class="gd">-    False, eq=None, order=None, on_setattr=None, alias=None):</span>
<span class="gi">+def field(</span>
<span class="gi">+    *,</span>
<span class="gi">+    default=NOTHING,</span>
<span class="gi">+    validator=None,</span>
<span class="gi">+    repr=True,</span>
<span class="gi">+    hash=None,</span>
<span class="gi">+    init=True,</span>
<span class="gi">+    metadata=None,</span>
<span class="gi">+    type=None,</span>
<span class="gi">+    converter=None,</span>
<span class="gi">+    factory=None,</span>
<span class="gi">+    kw_only=False,</span>
<span class="gi">+    eq=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+    on_setattr=None,</span>
<span class="gi">+    alias=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new :term:`field` / :term:`attribute` on a class.

<span class="gu">@@ -476,7 +585,22 @@ def field(*, default=NOTHING, validator=None, repr=True, hash=None, init=</span>

<span class="w"> </span>       `attr.ib`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return attrib(</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        validator=validator,</span>
<span class="gi">+        repr=repr,</span>
<span class="gi">+        hash=hash,</span>
<span class="gi">+        init=init,</span>
<span class="gi">+        metadata=metadata,</span>
<span class="gi">+        type=type,</span>
<span class="gi">+        converter=converter,</span>
<span class="gi">+        factory=factory,</span>
<span class="gi">+        kw_only=kw_only,</span>
<span class="gi">+        eq=eq,</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        on_setattr=on_setattr,</span>
<span class="gi">+        alias=alias,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def asdict(inst, *, recurse=True, filter=None, value_serializer=None):
<span class="gu">@@ -486,7 +610,13 @@ def asdict(inst, *, recurse=True, filter=None, value_serializer=None):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _asdict(</span>
<span class="gi">+        inst=inst,</span>
<span class="gi">+        recurse=recurse,</span>
<span class="gi">+        filter=filter,</span>
<span class="gi">+        value_serializer=value_serializer,</span>
<span class="gi">+        retain_collection_types=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def astuple(inst, *, recurse=True, filter=None):
<span class="gu">@@ -496,4 +626,6 @@ def astuple(inst, *, recurse=True, filter=None):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _astuple(</span>
<span class="gi">+        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/src/attr/_version_info.py b/src/attr/_version_info.py</span>
<span class="gh">index 6691f84..51a1312 100644</span>
<span class="gd">--- a/src/attr/_version_info.py</span>
<span class="gi">+++ b/src/attr/_version_info.py</span>
<span class="gu">@@ -1,4 +1,8 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from functools import total_ordering
<span class="gi">+</span>
<span class="w"> </span>from ._funcs import astuple
<span class="w"> </span>from ._make import attrib, attrs

<span class="gu">@@ -25,6 +29,7 @@ class VersionInfo:</span>

<span class="w"> </span>    .. versionadded:: 19.2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    year = attrib(type=int)
<span class="w"> </span>    minor = attrib(type=int)
<span class="w"> </span>    micro = attrib(type=int)
<span class="gu">@@ -35,7 +40,13 @@ class VersionInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parse *s* and return a _VersionInfo.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        v = s.split(&quot;.&quot;)</span>
<span class="gi">+        if len(v) == 3:</span>
<span class="gi">+            v.append(&quot;final&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            year=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _ensure_tuple(self, other):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -44,13 +55,24 @@ class VersionInfo:</span>
<span class="w"> </span>        Returns a possibly transformed *other* and ourselves as a tuple of
<span class="w"> </span>        the same length as *other*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self.__class__ is other.__class__:</span>
<span class="gi">+            other = astuple(other)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(other, tuple):</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+        if not (1 &lt;= len(other) &lt;= 4):</span>
<span class="gi">+            raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+        return astuple(self)[: len(other)], other</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        try:
<span class="w"> </span>            us, them = self._ensure_tuple(other)
<span class="w"> </span>        except NotImplementedError:
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return us == them

<span class="w"> </span>    def __lt__(self, other):
<span class="gu">@@ -58,4 +80,7 @@ class VersionInfo:</span>
<span class="w"> </span>            us, them = self._ensure_tuple(other)
<span class="w"> </span>        except NotImplementedError:
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="gi">+        # Since alphabetically &quot;dev0&quot; &lt; &quot;final&quot; &lt; &quot;post1&quot; &lt; &quot;post2&quot;, we don&#39;t</span>
<span class="gi">+        # have to do anything special with releaselevel for now.</span>
<span class="w"> </span>        return us &lt; them
<span class="gh">diff --git a/src/attr/converters.py b/src/attr/converters.py</span>
<span class="gh">index df5c697..9238311 100644</span>
<span class="gd">--- a/src/attr/converters.py</span>
<span class="gi">+++ b/src/attr/converters.py</span>
<span class="gu">@@ -1,10 +1,22 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Commonly useful converters.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from ._compat import _AnnotationExtractor
<span class="w"> </span>from ._make import NOTHING, Factory, pipe
<span class="gd">-__all__ = [&#39;default_if_none&#39;, &#39;optional&#39;, &#39;pipe&#39;, &#39;to_bool&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;default_if_none&quot;,</span>
<span class="gi">+    &quot;optional&quot;,</span>
<span class="gi">+    &quot;pipe&quot;,</span>
<span class="gi">+    &quot;to_bool&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def optional(converter):
<span class="gu">@@ -21,7 +33,23 @@ def optional(converter):</span>

<span class="w"> </span>    .. versionadded:: 17.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def optional_converter(val):</span>
<span class="gi">+        if val is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return converter(val)</span>
<span class="gi">+</span>
<span class="gi">+    xtr = _AnnotationExtractor(converter)</span>
<span class="gi">+</span>
<span class="gi">+    t = xtr.get_first_param_type()</span>
<span class="gi">+    if t:</span>
<span class="gi">+        optional_converter.__annotations__[&quot;val&quot;] = typing.Optional[t]</span>
<span class="gi">+</span>
<span class="gi">+    rt = xtr.get_return_type()</span>
<span class="gi">+    if rt:</span>
<span class="gi">+        optional_converter.__annotations__[&quot;return&quot;] = typing.Optional[rt]</span>
<span class="gi">+</span>
<span class="gi">+    return optional_converter</span>


<span class="w"> </span>def default_if_none(default=NOTHING, factory=None):
<span class="gu">@@ -50,7 +78,37 @@ def default_if_none(default=NOTHING, factory=None):</span>

<span class="w"> </span>    .. versionadded:: 18.2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is NOTHING and factory is None:</span>
<span class="gi">+        msg = &quot;Must pass either `default` or `factory`.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if default is not NOTHING and factory is not None:</span>
<span class="gi">+        msg = &quot;Must pass either `default` or `factory` but not both.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if factory is not None:</span>
<span class="gi">+        default = Factory(factory)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(default, Factory):</span>
<span class="gi">+        if default.takes_self:</span>
<span class="gi">+            msg = &quot;`takes_self` is not supported by default_if_none.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        def default_if_none_converter(val):</span>
<span class="gi">+            if val is not None:</span>
<span class="gi">+                return val</span>
<span class="gi">+</span>
<span class="gi">+            return default.factory()</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def default_if_none_converter(val):</span>
<span class="gi">+            if val is not None:</span>
<span class="gi">+                return val</span>
<span class="gi">+</span>
<span class="gi">+            return default</span>
<span class="gi">+</span>
<span class="gi">+    return default_if_none_converter</span>


<span class="w"> </span>def to_bool(val):
<span class="gu">@@ -81,4 +139,13 @@ def to_bool(val):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(val, str):</span>
<span class="gi">+        val = val.lower()</span>
<span class="gi">+</span>
<span class="gi">+    if val in (True, &quot;true&quot;, &quot;t&quot;, &quot;yes&quot;, &quot;y&quot;, &quot;on&quot;, &quot;1&quot;, 1):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if val in (False, &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;off&quot;, &quot;0&quot;, 0):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    msg = f&quot;Cannot convert value to bool: {val!r}&quot;</span>
<span class="gi">+    raise ValueError(msg)</span>
<span class="gh">diff --git a/src/attr/exceptions.py b/src/attr/exceptions.py</span>
<span class="gh">index bbe9547..3b7abb8 100644</span>
<span class="gd">--- a/src/attr/exceptions.py</span>
<span class="gi">+++ b/src/attr/exceptions.py</span>
<span class="gu">@@ -1,4 +1,7 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import ClassVar


<span class="gu">@@ -12,6 +15,7 @@ class FrozenError(AttributeError):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    msg = &quot;can&#39;t set attribute&quot;
<span class="w"> </span>    args: ClassVar[tuple[str]] = [msg]

<span class="gh">diff --git a/src/attr/filters.py b/src/attr/filters.py</span>
<span class="gh">index c3c2781..689b170 100644</span>
<span class="gd">--- a/src/attr/filters.py</span>
<span class="gi">+++ b/src/attr/filters.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Commonly useful filters for `attrs.asdict` and `attrs.astuple`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ._make import Attribute


<span class="gu">@@ -8,7 +11,11 @@ def _split_what(what):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a tuple of `frozenset`s of classes and attributes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        frozenset(cls for cls in what if isinstance(cls, type)),</span>
<span class="gi">+        frozenset(cls for cls in what if isinstance(cls, str)),</span>
<span class="gi">+        frozenset(cls for cls in what if isinstance(cls, Attribute)),</span>
<span class="gi">+    )</span>


<span class="w"> </span>def include(*what):
<span class="gu">@@ -26,7 +33,16 @@ def include(*what):</span>

<span class="w"> </span>    .. versionchanged:: 23.1.0 Accept strings with field names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cls, names, attrs = _split_what(what)</span>
<span class="gi">+</span>
<span class="gi">+    def include_(attribute, value):</span>
<span class="gi">+        return (</span>
<span class="gi">+            value.__class__ in cls</span>
<span class="gi">+            or attribute.name in names</span>
<span class="gi">+            or attribute in attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return include_</span>


<span class="w"> </span>def exclude(*what):
<span class="gu">@@ -44,4 +60,13 @@ def exclude(*what):</span>

<span class="w"> </span>    .. versionchanged:: 23.3.0 Accept field name string as input argument
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cls, names, attrs = _split_what(what)</span>
<span class="gi">+</span>
<span class="gi">+    def exclude_(attribute, value):</span>
<span class="gi">+        return not (</span>
<span class="gi">+            value.__class__ in cls</span>
<span class="gi">+            or attribute.name in names</span>
<span class="gi">+            or attribute in attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return exclude_</span>
<span class="gh">diff --git a/src/attr/setters.py b/src/attr/setters.py</span>
<span class="gh">index 1bb6a12..a9ce016 100644</span>
<span class="gd">--- a/src/attr/setters.py</span>
<span class="gi">+++ b/src/attr/setters.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Commonly used hooks for on_setattr.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from . import _config
<span class="w"> </span>from .exceptions import FrozenAttributeError

<span class="gu">@@ -11,7 +14,16 @@ def pipe(*setters):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def wrapped_pipe(instance, attrib, new_value):</span>
<span class="gi">+        rv = new_value</span>
<span class="gi">+</span>
<span class="gi">+        for setter in setters:</span>
<span class="gi">+            rv = setter(instance, attrib, rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    return wrapped_pipe</span>


<span class="w"> </span>def frozen(_, __, ___):
<span class="gu">@@ -20,7 +32,7 @@ def frozen(_, __, ___):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise FrozenAttributeError()</span>


<span class="w"> </span>def validate(instance, attrib, new_value):
<span class="gu">@@ -29,7 +41,16 @@ def validate(instance, attrib, new_value):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _config._run_validators is False:</span>
<span class="gi">+        return new_value</span>
<span class="gi">+</span>
<span class="gi">+    v = attrib.validator</span>
<span class="gi">+    if not v:</span>
<span class="gi">+        return new_value</span>
<span class="gi">+</span>
<span class="gi">+    v(instance, attrib, new_value)</span>
<span class="gi">+</span>
<span class="gi">+    return new_value</span>


<span class="w"> </span>def convert(instance, attrib, new_value):
<span class="gu">@@ -39,7 +60,20 @@ def convert(instance, attrib, new_value):</span>

<span class="w"> </span>    .. versionadded:: 20.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    c = attrib.converter</span>
<span class="gi">+    if c:</span>
<span class="gi">+        # This can be removed once we drop 3.8 and use attrs.Converter instead.</span>
<span class="gi">+        from ._make import Converter</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(c, Converter):</span>
<span class="gi">+            return c(new_value)</span>
<span class="gi">+</span>
<span class="gi">+        return c(new_value, instance, attrib)</span>
<span class="gi">+</span>
<span class="gi">+    return new_value</span>


<span class="gi">+# Sentinel for disabling class-wide *on_setattr* hooks for certain attributes.</span>
<span class="gi">+# Sphinx&#39;s autodata stopped working, so the docstring is inlined in the API</span>
<span class="gi">+# docs.</span>
<span class="w"> </span>NO_OP = object()
<span class="gh">diff --git a/src/attr/validators.py b/src/attr/validators.py</span>
<span class="gh">index d98967a..8a56717 100644</span>
<span class="gd">--- a/src/attr/validators.py</span>
<span class="gi">+++ b/src/attr/validators.py</span>
<span class="gu">@@ -1,18 +1,43 @@</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Commonly useful validators.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from re import Pattern
<span class="gi">+</span>
<span class="w"> </span>from ._config import get_run_validators, set_run_validators
<span class="w"> </span>from ._make import _AndValidator, and_, attrib, attrs
<span class="w"> </span>from .converters import default_if_none
<span class="w"> </span>from .exceptions import NotCallableError
<span class="gd">-__all__ = [&#39;and_&#39;, &#39;deep_iterable&#39;, &#39;deep_mapping&#39;, &#39;disabled&#39;, &#39;ge&#39;,</span>
<span class="gd">-    &#39;get_disabled&#39;, &#39;gt&#39;, &#39;in_&#39;, &#39;instance_of&#39;, &#39;is_callable&#39;, &#39;le&#39;, &#39;lt&#39;,</span>
<span class="gd">-    &#39;matches_re&#39;, &#39;max_len&#39;, &#39;min_len&#39;, &#39;not_&#39;, &#39;optional&#39;, &#39;or_&#39;,</span>
<span class="gd">-    &#39;set_disabled&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;and_&quot;,</span>
<span class="gi">+    &quot;deep_iterable&quot;,</span>
<span class="gi">+    &quot;deep_mapping&quot;,</span>
<span class="gi">+    &quot;disabled&quot;,</span>
<span class="gi">+    &quot;ge&quot;,</span>
<span class="gi">+    &quot;get_disabled&quot;,</span>
<span class="gi">+    &quot;gt&quot;,</span>
<span class="gi">+    &quot;in_&quot;,</span>
<span class="gi">+    &quot;instance_of&quot;,</span>
<span class="gi">+    &quot;is_callable&quot;,</span>
<span class="gi">+    &quot;le&quot;,</span>
<span class="gi">+    &quot;lt&quot;,</span>
<span class="gi">+    &quot;matches_re&quot;,</span>
<span class="gi">+    &quot;max_len&quot;,</span>
<span class="gi">+    &quot;min_len&quot;,</span>
<span class="gi">+    &quot;not_&quot;,</span>
<span class="gi">+    &quot;optional&quot;,</span>
<span class="gi">+    &quot;or_&quot;,</span>
<span class="gi">+    &quot;set_disabled&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def set_disabled(disabled):
<span class="gu">@@ -30,7 +55,7 @@ def set_disabled(disabled):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_run_validators(not disabled)</span>


<span class="w"> </span>def get_disabled():
<span class="gu">@@ -42,7 +67,7 @@ def get_disabled():</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not get_run_validators()</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -56,7 +81,11 @@ def disabled():</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_run_validators(False)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        set_run_validators(True)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -68,13 +97,16 @@ class _InstanceOfValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not isinstance(value, self.type):
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;&#39;{attr.name}&#39; must be {self.type!r} (got {value!r} that is a {value.__class__!r}).&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-            raise TypeError(msg, attr, self.type, value)</span>
<span class="gi">+            msg = f&quot;&#39;{attr.name}&#39; must be {self.type!r} (got {value!r} that is a {value.__class__!r}).&quot;</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                msg,</span>
<span class="gi">+                attr,</span>
<span class="gi">+                self.type,</span>
<span class="gi">+                value,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;instance_of validator for type {self.type!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;instance_of validator for type {self.type!r}&gt;&quot;</span>


<span class="w"> </span>def instance_of(type):
<span class="gu">@@ -91,7 +123,7 @@ def instance_of(type):</span>
<span class="w"> </span>            With a human readable error message, the attribute (of type
<span class="w"> </span>            `attrs.Attribute`), the expected type, and the value it got.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _InstanceOfValidator(type)</span>


<span class="w"> </span>@attrs(repr=False, frozen=True, slots=True)
<span class="gu">@@ -104,17 +136,20 @@ class _MatchesReValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not self.match_func(value):
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;&#39;{attr.name}&#39; must match regex {self.pattern.pattern!r} ({value!r} doesn&#39;t)&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-            raise ValueError(msg, attr, self.pattern, value)</span>
<span class="gi">+            msg = f&quot;&#39;{attr.name}&#39; must match regex {self.pattern.pattern!r} ({value!r} doesn&#39;t)&quot;</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                msg,</span>
<span class="gi">+                attr,</span>
<span class="gi">+                self.pattern,</span>
<span class="gi">+                value,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;matches_re validator for pattern {self.pattern!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;matches_re validator for pattern {self.pattern!r}&gt;&quot;</span>


<span class="w"> </span>def matches_re(regex, flags=0, func=None):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    A validator that raises `ValueError` if the initializer is called with a
<span class="w"> </span>    string that doesn&#39;t match *regex*.

<span class="gu">@@ -134,7 +169,31 @@ def matches_re(regex, flags=0, func=None):</span>
<span class="w"> </span>    .. versionadded:: 19.2.0
<span class="w"> </span>    .. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    valid_funcs = (re.fullmatch, None, re.search, re.match)</span>
<span class="gi">+    if func not in valid_funcs:</span>
<span class="gi">+        msg = &quot;&#39;func&#39; must be one of {}.&quot;.format(</span>
<span class="gi">+            &quot;, &quot;.join(</span>
<span class="gi">+                sorted(e and e.__name__ or &quot;None&quot; for e in set(valid_funcs))</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(regex, Pattern):</span>
<span class="gi">+        if flags:</span>
<span class="gi">+            msg = &quot;&#39;flags&#39; can only be used with a string pattern; pass flags to re.compile() instead&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+        pattern = regex</span>
<span class="gi">+    else:</span>
<span class="gi">+        pattern = re.compile(regex, flags)</span>
<span class="gi">+</span>
<span class="gi">+    if func is re.match:</span>
<span class="gi">+        match_func = pattern.match</span>
<span class="gi">+    elif func is re.search:</span>
<span class="gi">+        match_func = pattern.search</span>
<span class="gi">+    else:</span>
<span class="gi">+        match_func = pattern.fullmatch</span>
<span class="gi">+</span>
<span class="gi">+    return _MatchesReValidator(pattern, match_func)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -144,10 +203,11 @@ class _OptionalValidator:</span>
<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="w"> </span>        if value is None:
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="w"> </span>        self.validator(inst, attr, value)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;optional validator for {self.validator!r} or None&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;optional validator for {self.validator!r} or None&gt;&quot;</span>


<span class="w"> </span>def optional(validator):
<span class="gu">@@ -165,7 +225,10 @@ def optional(validator):</span>
<span class="w"> </span>    .. versionchanged:: 17.1.0 *validator* can be a list of validators.
<span class="w"> </span>    .. versionchanged:: 23.1.0 *validator* can also be a tuple of validators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(validator, (list, tuple)):</span>
<span class="gi">+        return _OptionalValidator(_AndValidator(validator))</span>
<span class="gi">+</span>
<span class="gi">+    return _OptionalValidator(validator)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -176,16 +239,20 @@ class _InValidator:</span>
<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="w"> </span>        try:
<span class="w"> </span>            in_options = value in self.options
<span class="gd">-        except TypeError:</span>
<span class="gi">+        except TypeError:  # e.g. `1 in &quot;abc&quot;`</span>
<span class="w"> </span>            in_options = False
<span class="gi">+</span>
<span class="w"> </span>        if not in_options:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;&#39;{attr.name}&#39; must be in {self._original_options!r} (got {value!r})&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-            raise ValueError(msg, attr, self._original_options, value)</span>
<span class="gi">+            msg = f&quot;&#39;{attr.name}&#39; must be in {self._original_options!r} (got {value!r})&quot;</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                msg,</span>
<span class="gi">+                attr,</span>
<span class="gi">+                self._original_options,</span>
<span class="gi">+                value,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;in_ validator with options {self._original_options!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;in_ validator with options {self._original_options!r}&gt;&quot;</span>


<span class="w"> </span>def in_(options):
<span class="gu">@@ -216,25 +283,33 @@ def in_(options):</span>
<span class="w"> </span>       *options* that are a list, dict, or a set are now transformed into a
<span class="w"> </span>       tuple to keep the validator hashable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    repr_options = options</span>
<span class="gi">+    if isinstance(options, (list, dict, set)):</span>
<span class="gi">+        options = tuple(options)</span>
<span class="gi">+</span>
<span class="gi">+    return _InValidator(options, repr_options)</span>


<span class="w"> </span>@attrs(repr=False, slots=False, unsafe_hash=True)
<span class="w"> </span>class _IsCallableValidator:
<span class="gd">-</span>
<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not callable(value):
<span class="w"> </span>            message = (
<span class="gd">-                &quot;&#39;{name}&#39; must be callable (got {value!r} that is a {actual!r}).&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-            raise NotCallableError(msg=message.format(name=attr.name, value</span>
<span class="gd">-                =value, actual=value.__class__), value=value)</span>
<span class="gi">+                &quot;&#39;{name}&#39; must be callable &quot;</span>
<span class="gi">+                &quot;(got {value!r} that is a {actual!r}).&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise NotCallableError(</span>
<span class="gi">+                msg=message.format(</span>
<span class="gi">+                    name=attr.name, value=value, actual=value.__class__</span>
<span class="gi">+                ),</span>
<span class="gi">+                value=value,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;is_callable validator&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;is_callable validator&gt;&quot;</span>


<span class="w"> </span>def is_callable():
<span class="gu">@@ -250,14 +325,15 @@ def is_callable():</span>
<span class="w"> </span>            With a human readable error message containing the attribute
<span class="w"> </span>            (`attrs.Attribute`) name, and the value it got.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _IsCallableValidator()</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="w"> </span>class _DeepIterable:
<span class="w"> </span>    member_validator = attrib(validator=is_callable())
<span class="gd">-    iterable_validator = attrib(default=None, validator=optional(is_callable())</span>
<span class="gd">-        )</span>
<span class="gi">+    iterable_validator = attrib(</span>
<span class="gi">+        default=None, validator=optional(is_callable())</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -265,15 +341,20 @@ class _DeepIterable:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if self.iterable_validator is not None:
<span class="w"> </span>            self.iterable_validator(inst, attr, value)
<span class="gi">+</span>
<span class="w"> </span>        for member in value:
<span class="w"> </span>            self.member_validator(inst, attr, member)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        iterable_identifier = (&#39;&#39; if self.iterable_validator is None else</span>
<span class="gd">-            f&#39; {self.iterable_validator!r}&#39;)</span>
<span class="gi">+        iterable_identifier = (</span>
<span class="gi">+            &quot;&quot;</span>
<span class="gi">+            if self.iterable_validator is None</span>
<span class="gi">+            else f&quot; {self.iterable_validator!r}&quot;</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;deep_iterable validator for{iterable_identifier} iterables of {self.member_validator!r}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;deep_iterable validator for{iterable_identifier}&quot;</span>
<span class="gi">+            f&quot; iterables of {self.member_validator!r}&gt;&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def deep_iterable(member_validator, iterable_validator=None):
<span class="gu">@@ -291,7 +372,9 @@ def deep_iterable(member_validator, iterable_validator=None):</span>

<span class="w"> </span>    .. versionadded:: 19.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(member_validator, (list, tuple)):</span>
<span class="gi">+        member_validator = and_(*member_validator)</span>
<span class="gi">+    return _DeepIterable(member_validator, iterable_validator)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -306,14 +389,13 @@ class _DeepMapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if self.mapping_validator is not None:
<span class="w"> </span>            self.mapping_validator(inst, attr, value)
<span class="gi">+</span>
<span class="w"> </span>        for key in value:
<span class="w"> </span>            self.key_validator(inst, attr, key)
<span class="w"> </span>            self.value_validator(inst, attr, value[key])

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;deep_mapping validator for objects mapping {self.key_validator!r} to {self.value_validator!r}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;&lt;deep_mapping validator for objects mapping {self.key_validator!r} to {self.value_validator!r}&gt;&quot;</span>


<span class="w"> </span>def deep_mapping(key_validator, value_validator, mapping_validator=None):
<span class="gu">@@ -333,7 +415,7 @@ def deep_mapping(key_validator, value_validator, mapping_validator=None):</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: if any sub-validators fail
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _DeepMapping(key_validator, value_validator, mapping_validator)</span>


<span class="w"> </span>@attrs(repr=False, frozen=True, slots=True)
<span class="gu">@@ -347,13 +429,11 @@ class _NumberValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not self.compare_func(value, self.bound):
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;&#39;{attr.name}&#39; must be {self.compare_op} {self.bound}: {value}&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&quot;&#39;{attr.name}&#39; must be {self.compare_op} {self.bound}: {value}&quot;</span>
<span class="w"> </span>            raise ValueError(msg)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;Validator for x {self.compare_op} {self.bound}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;Validator for x {self.compare_op} {self.bound}&gt;&quot;</span>


<span class="w"> </span>def lt(val):
<span class="gu">@@ -368,7 +448,7 @@ def lt(val):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _NumberValidator(val, &quot;&lt;&quot;, operator.lt)</span>


<span class="w"> </span>def le(val):
<span class="gu">@@ -383,7 +463,7 @@ def le(val):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _NumberValidator(val, &quot;&lt;=&quot;, operator.le)</span>


<span class="w"> </span>def ge(val):
<span class="gu">@@ -398,7 +478,7 @@ def ge(val):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _NumberValidator(val, &quot;&gt;=&quot;, operator.ge)</span>


<span class="w"> </span>def gt(val):
<span class="gu">@@ -413,7 +493,7 @@ def gt(val):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _NumberValidator(val, &quot;&gt;&quot;, operator.gt)</span>


<span class="w"> </span>@attrs(repr=False, frozen=True, slots=True)
<span class="gu">@@ -425,13 +505,11 @@ class _MaxLengthValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if len(value) &gt; self.max_length:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;Length of &#39;{attr.name}&#39; must be &lt;= {self.max_length}: {len(value)}&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&quot;Length of &#39;{attr.name}&#39; must be &lt;= {self.max_length}: {len(value)}&quot;</span>
<span class="w"> </span>            raise ValueError(msg)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;max_len validator for {self.max_length}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;max_len validator for {self.max_length}&gt;&quot;</span>


<span class="w"> </span>def max_len(length):
<span class="gu">@@ -444,7 +522,7 @@ def max_len(length):</span>

<span class="w"> </span>    .. versionadded:: 21.3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MaxLengthValidator(length)</span>


<span class="w"> </span>@attrs(repr=False, frozen=True, slots=True)
<span class="gu">@@ -456,13 +534,11 @@ class _MinLengthValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if len(value) &lt; self.min_length:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;Length of &#39;{attr.name}&#39; must be &gt;= {self.min_length}: {len(value)}&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&quot;Length of &#39;{attr.name}&#39; must be &gt;= {self.min_length}: {len(value)}&quot;</span>
<span class="w"> </span>            raise ValueError(msg)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;min_len validator for {self.min_length}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;min_len validator for {self.min_length}&gt;&quot;</span>


<span class="w"> </span>def min_len(length):
<span class="gu">@@ -475,7 +551,7 @@ def min_len(length):</span>

<span class="w"> </span>    .. versionadded:: 22.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MinLengthValidator(length)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -487,13 +563,16 @@ class _SubclassOfValidator:</span>
<span class="w"> </span>        We use a callable class to be able to change the ``__repr__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not issubclass(value, self.type):
<span class="gd">-            msg = (</span>
<span class="gd">-                f&quot;&#39;{attr.name}&#39; must be a subclass of {self.type!r} (got {value!r}).&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-            raise TypeError(msg, attr, self.type, value)</span>
<span class="gi">+            msg = f&quot;&#39;{attr.name}&#39; must be a subclass of {self.type!r} (got {value!r}).&quot;</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                msg,</span>
<span class="gi">+                attr,</span>
<span class="gi">+                self.type,</span>
<span class="gi">+                value,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;subclass_of validator for type {self.type!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;subclass_of validator for type {self.type!r}&gt;&quot;</span>


<span class="w"> </span>def _subclass_of(type):
<span class="gu">@@ -510,31 +589,44 @@ def _subclass_of(type):</span>
<span class="w"> </span>            With a human readable error message, the attribute (of type
<span class="w"> </span>            `attrs.Attribute`), the expected type, and the value it got.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _SubclassOfValidator(type)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="w"> </span>class _NotValidator:
<span class="w"> </span>    validator = attrib()
<span class="gd">-    msg = attrib(converter=default_if_none(</span>
<span class="gd">-        &quot;not_ validator child &#39;{validator!r}&#39; did not raise a captured error&quot;))</span>
<span class="gd">-    exc_types = attrib(validator=deep_iterable(member_validator=</span>
<span class="gd">-        _subclass_of(Exception), iterable_validator=instance_of(tuple)))</span>
<span class="gi">+    msg = attrib(</span>
<span class="gi">+        converter=default_if_none(</span>
<span class="gi">+            &quot;not_ validator child &#39;{validator!r}&#39; &quot;</span>
<span class="gi">+            &quot;did not raise a captured error&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    exc_types = attrib(</span>
<span class="gi">+        validator=deep_iterable(</span>
<span class="gi">+            member_validator=_subclass_of(Exception),</span>
<span class="gi">+            iterable_validator=instance_of(tuple),</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def __call__(self, inst, attr, value):
<span class="w"> </span>        try:
<span class="w"> </span>            self.validator(inst, attr, value)
<span class="w"> </span>        except self.exc_types:
<span class="gd">-            pass</span>
<span class="gi">+            pass  # suppress error to invert validity</span>
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(self.msg.format(validator=self.validator,</span>
<span class="gd">-                exc_types=self.exc_types), attr, self.validator, value,</span>
<span class="gd">-                self.exc_types)</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                self.msg.format(</span>
<span class="gi">+                    validator=self.validator,</span>
<span class="gi">+                    exc_types=self.exc_types,</span>
<span class="gi">+                ),</span>
<span class="gi">+                attr,</span>
<span class="gi">+                self.validator,</span>
<span class="gi">+                value,</span>
<span class="gi">+                self.exc_types,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;not_ validator wrapping {self.validator!r}, capturing {self.exc_types!r}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        return f&quot;&lt;not_ validator wrapping {self.validator!r}, capturing {self.exc_types!r}&gt;&quot;</span>


<span class="w"> </span>def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):
<span class="gu">@@ -566,7 +658,11 @@ def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):</span>

<span class="w"> </span>    .. versionadded:: 22.2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        exc_types = tuple(exc_types)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        exc_types = (exc_types,)</span>
<span class="gi">+    return _NotValidator(validator, msg, exc_types)</span>


<span class="w"> </span>@attrs(repr=False, slots=True, unsafe_hash=True)
<span class="gu">@@ -577,15 +673,16 @@ class _OrValidator:</span>
<span class="w"> </span>        for v in self.validators:
<span class="w"> </span>            try:
<span class="w"> </span>                v(inst, attr, value)
<span class="gd">-            except Exception:</span>
<span class="gi">+            except Exception:  # noqa: BLE001, PERF203, S112</span>
<span class="w"> </span>                continue
<span class="w"> </span>            else:
<span class="w"> </span>                return
<span class="gd">-        msg = f&#39;None of {self.validators!r} satisfied for value {value!r}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        msg = f&quot;None of {self.validators!r} satisfied for value {value!r}&quot;</span>
<span class="w"> </span>        raise ValueError(msg)

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;or validator wrapping {self.validators!r}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;or validator wrapping {self.validators!r}&gt;&quot;</span>


<span class="w"> </span>def or_(*validators):
<span class="gu">@@ -607,4 +704,8 @@ def or_(*validators):</span>

<span class="w"> </span>    .. versionadded:: 24.1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    vals = []</span>
<span class="gi">+    for v in validators:</span>
<span class="gi">+        vals.extend(v.validators if isinstance(v, _OrValidator) else [v])</span>
<span class="gi">+</span>
<span class="gi">+    return _OrValidator(tuple(vals))</span>
<span class="gh">diff --git a/src/attrs/converters.py b/src/attrs/converters.py</span>
<span class="gh">index 54e74a1..7821f6c 100644</span>
<span class="gd">--- a/src/attrs/converters.py</span>
<span class="gi">+++ b/src/attrs/converters.py</span>
<span class="gu">@@ -1 +1,3 @@</span>
<span class="gd">-from attr.converters import *</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+from attr.converters import *  # noqa: F403</span>
<span class="gh">diff --git a/src/attrs/exceptions.py b/src/attrs/exceptions.py</span>
<span class="gh">index d6746ed..3323f9d 100644</span>
<span class="gd">--- a/src/attrs/exceptions.py</span>
<span class="gi">+++ b/src/attrs/exceptions.py</span>
<span class="gu">@@ -1 +1,3 @@</span>
<span class="gd">-from attr.exceptions import *</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+from attr.exceptions import *  # noqa: F403</span>
<span class="gh">diff --git a/src/attrs/filters.py b/src/attrs/filters.py</span>
<span class="gh">index 2cd93f8..3080f48 100644</span>
<span class="gd">--- a/src/attrs/filters.py</span>
<span class="gi">+++ b/src/attrs/filters.py</span>
<span class="gu">@@ -1 +1,3 @@</span>
<span class="gd">-from attr.filters import *</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+from attr.filters import *  # noqa: F403</span>
<span class="gh">diff --git a/src/attrs/setters.py b/src/attrs/setters.py</span>
<span class="gh">index 5cd6a8f..f3d73bb 100644</span>
<span class="gd">--- a/src/attrs/setters.py</span>
<span class="gi">+++ b/src/attrs/setters.py</span>
<span class="gu">@@ -1 +1,3 @@</span>
<span class="gd">-from attr.setters import *</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+from attr.setters import *  # noqa: F403</span>
<span class="gh">diff --git a/src/attrs/validators.py b/src/attrs/validators.py</span>
<span class="gh">index 07710e6..037e124 100644</span>
<span class="gd">--- a/src/attrs/validators.py</span>
<span class="gi">+++ b/src/attrs/validators.py</span>
<span class="gu">@@ -1 +1,3 @@</span>
<span class="gd">-from attr.validators import *</span>
<span class="gi">+# SPDX-License-Identifier: MIT</span>
<span class="gi">+</span>
<span class="gi">+from attr.validators import *  # noqa: F403</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>