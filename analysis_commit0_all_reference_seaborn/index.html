
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference seaborn - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-seaborn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference seaborn
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_scalespytestnominaltest_color_numeric_int_float_mix" class="md-nav__link">
    <span class="md-ellipsis">
      test_scales.py::TestNominal::test_color_numeric_int_float_mix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_plotpytestscalingtest_log_scale_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_plot.py::TestScaling::test_log_scale_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_plotpytestlayeradditiontest_stat_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_plot.py::TestLayerAddition::test_stat_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_plotpytestscalingtest_identity_mapping_color_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_plot.py::TestScaling::test_identity_mapping_color_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_plotpytestscalingtest_undefined_variable_raises" class="md-nav__link">
    <span class="md-ellipsis">
      test_plot.py::TestScaling::test_undefined_variable_raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_plotpytestscalingtest_categorical_as_datetime" class="md-nav__link">
    <span class="md-ellipsis">
      test_plot.py::TestScaling::test_categorical_as_datetime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_distributionspytestkdeplotbivariatetest_weights" class="md-nav__link">
    <span class="md-ellipsis">
      test_distributions.py::TestKDEPlotBivariate::test_weights
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-seaborn"><strong>Reference (Gold)</strong>: seaborn</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">2362</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">11</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">2380</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">2380</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_scalespytestnominaltest_color_numeric_int_float_mix">test_scales.py::TestNominal::test_color_numeric_int_float_mix</h3>
<details><summary> <pre>test_scales.py::TestNominal::test_color_numeric_int_float_mix</pre></summary><pre>
[gw4] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_plotpytestscalingtest_log_scale_name">test_plot.py::TestScaling::test_log_scale_name</h3>
<details><summary> <pre>test_plot.py::TestScaling::test_log_scale_name</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_plotpytestlayeradditiontest_stat_default">test_plot.py::TestLayerAddition::test_stat_default</h3>
<details><summary> <pre>test_plot.py::TestLayerAddition::test_stat_default</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_plotpytestscalingtest_identity_mapping_color_strings">test_plot.py::TestScaling::test_identity_mapping_color_strings</h3>
<details><summary> <pre>test_plot.py::TestScaling::test_identity_mapping_color_strings</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_plotpytestscalingtest_undefined_variable_raises">test_plot.py::TestScaling::test_undefined_variable_raises</h3>
<details><summary> <pre>test_plot.py::TestScaling::test_undefined_variable_raises</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_plotpytestscalingtest_categorical_as_datetime">test_plot.py::TestScaling::test_categorical_as_datetime</h3>
<details><summary> <pre>test_plot.py::TestScaling::test_categorical_as_datetime</pre></summary><pre>
[gw0] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>
<h3 id="test_distributionspytestkdeplotbivariatetest_weights">test_distributions.py::TestKDEPlotBivariate::test_weights</h3>
<details><summary> <pre>test_distributions.py::TestKDEPlotBivariate::test_weights</pre></summary><pre>
[gw1] linux -- Python 3.12.6 /testbed/.venv/bin/python3
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/seaborn/_base.py b/seaborn/_base.py</span>
<span class="gh">index d7a46b61..0b435231 100644</span>
<span class="gd">--- a/seaborn/_base.py</span>
<span class="gi">+++ b/seaborn/_base.py</span>
<span class="gu">@@ -6,30 +6,76 @@ from collections import UserString</span>
<span class="w"> </span>from collections.abc import Iterable, Sequence, Mapping
<span class="w"> </span>from numbers import Number
<span class="w"> </span>from datetime import datetime
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.data import PlotData
<span class="gd">-from seaborn.palettes import QUAL_PALETTES, color_palette</span>
<span class="gd">-from seaborn.utils import _check_argument, _version_predates, desaturate, locator_to_legend_entries, get_color_cycle, remove_na</span>
<span class="gi">+from seaborn.palettes import (</span>
<span class="gi">+    QUAL_PALETTES,</span>
<span class="gi">+    color_palette,</span>
<span class="gi">+)</span>
<span class="gi">+from seaborn.utils import (</span>
<span class="gi">+    _check_argument,</span>
<span class="gi">+    _version_predates,</span>
<span class="gi">+    desaturate,</span>
<span class="gi">+    locator_to_legend_entries,</span>
<span class="gi">+    get_color_cycle,</span>
<span class="gi">+    remove_na,</span>
<span class="gi">+)</span>


<span class="w"> </span>class SemanticMapping:
<span class="w"> </span>    &quot;&quot;&quot;Base class for mapping data values to plot attributes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # -- Default attributes that all SemanticMapping subclasses must set</span>
<span class="gi">+</span>
<span class="gi">+    # Whether the mapping is numeric, categorical, or datetime</span>
<span class="w"> </span>    map_type: str | None = None
<span class="gi">+</span>
<span class="gi">+    # Ordered list of unique values in the input data</span>
<span class="w"> </span>    levels = None
<span class="gi">+</span>
<span class="gi">+    # A mapping from the data values to corresponding plot attributes</span>
<span class="w"> </span>    lookup_table = None

<span class="w"> </span>    def __init__(self, plotter):
<span class="gi">+</span>
<span class="gi">+        # TODO Putting this here so we can continue to use a lot of the</span>
<span class="gi">+        # logic that&#39;s built into the library, but the idea of this class</span>
<span class="gi">+        # is to move towards semantic mappings that are agnostic about the</span>
<span class="gi">+        # kind of plot they&#39;re going to be used to draw.</span>
<span class="gi">+        # Fully achieving that is going to take some thinking.</span>
<span class="w"> </span>        self.plotter = plotter

<span class="w"> </span>    def _check_list_length(self, levels, values, variable):
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Copied from _core/properties; eventually will be replaced for that.</span>
<span class="gi">+        message = &quot;&quot;</span>
<span class="gi">+        if len(levels) &gt; len(values):</span>
<span class="gi">+            message = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;\nThe {variable} list has fewer values ({len(values)})&quot;,</span>
<span class="gi">+                f&quot;than needed ({len(levels)}) and will cycle, which may&quot;,</span>
<span class="gi">+                &quot;produce an uninterpretable plot.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            values = [x for _, x in zip(levels, itertools.cycle(values))]</span>
<span class="gi">+</span>
<span class="gi">+        elif len(values) &gt; len(levels):</span>
<span class="gi">+            message = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;The {variable} list has more values ({len(values)})&quot;,</span>
<span class="gi">+                f&quot;than needed ({len(levels)}), which may not be intended.&quot;,</span>
<span class="gi">+            ])</span>
<span class="gi">+            values = values[:len(levels)]</span>
<span class="gi">+</span>
<span class="gi">+        if message:</span>
<span class="gi">+            warnings.warn(message, UserWarning, stacklevel=6)</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>

<span class="w"> </span>    def _lookup_single(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Apply the mapping to a single data value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.lookup_table[key]</span>

<span class="w"> </span>    def __call__(self, key, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Get the attribute(s) values for the data key.&quot;&quot;&quot;
<span class="gu">@@ -41,12 +87,18 @@ class SemanticMapping:</span>

<span class="w"> </span>class HueMapping(SemanticMapping):
<span class="w"> </span>    &quot;&quot;&quot;Mapping that sets artist colors according to data values.&quot;&quot;&quot;
<span class="gi">+    # A specification of the colors that should appear in the plot</span>
<span class="w"> </span>    palette = None
<span class="gi">+</span>
<span class="gi">+    # An object that normalizes data values to [0, 1] range for color mapping</span>
<span class="w"> </span>    norm = None
<span class="gi">+</span>
<span class="gi">+    # A continuous colormap object for interpolating in a numeric context</span>
<span class="w"> </span>    cmap = None

<span class="gd">-    def __init__(self, plotter, palette=None, order=None, norm=None,</span>
<span class="gd">-        saturation=1):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, plotter, palette=None, order=None, norm=None, saturation=1,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Map the levels of the `hue` variable to distinct colors.

<span class="w"> </span>        Parameters
<span class="gu">@@ -55,34 +107,61 @@ class HueMapping(SemanticMapping):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super().__init__(plotter)
<span class="gd">-        data = plotter.plot_data.get(&#39;hue&#39;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="gi">+        data = plotter.plot_data.get(&quot;hue&quot;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(palette, np.ndarray):
<span class="w"> </span>            msg = (
<span class="gd">-                &#39;Numpy array is not a supported type for `palette`. Please convert your palette to a list. This will become an error in v0.14&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;Numpy array is not a supported type for `palette`. &quot;</span>
<span class="gi">+                &quot;Please convert your palette to a list. &quot;</span>
<span class="gi">+                &quot;This will become an error in v0.14&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>            warnings.warn(msg, stacklevel=4)
<span class="w"> </span>            palette = palette.tolist()
<span class="gi">+</span>
<span class="w"> </span>        if data.isna().all():
<span class="w"> </span>            if palette is not None:
<span class="gd">-                msg = (</span>
<span class="gd">-                    &#39;Ignoring `palette` because no `hue` variable has been assigned.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                msg = &quot;Ignoring `palette` because no `hue` variable has been assigned.&quot;</span>
<span class="w"> </span>                warnings.warn(msg, stacklevel=4)
<span class="w"> </span>        else:
<span class="gd">-            map_type = self.infer_map_type(palette, norm, plotter.</span>
<span class="gd">-                input_format, plotter.var_types[&#39;hue&#39;])</span>
<span class="gd">-            if map_type == &#39;numeric&#39;:</span>
<span class="gi">+</span>
<span class="gi">+            map_type = self.infer_map_type(</span>
<span class="gi">+                palette, norm, plotter.input_format, plotter.var_types[&quot;hue&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Our goal is to end up with a dictionary mapping every unique</span>
<span class="gi">+            # value in `data` to a color. We will also keep track of the</span>
<span class="gi">+            # metadata about this mapping we will need for, e.g., a legend</span>
<span class="gi">+</span>
<span class="gi">+            # --- Option 1: numeric mapping with a matplotlib colormap</span>
<span class="gi">+</span>
<span class="gi">+            if map_type == &quot;numeric&quot;:</span>
<span class="gi">+</span>
<span class="w"> </span>                data = pd.to_numeric(data)
<span class="gd">-                levels, lookup_table, norm, cmap = self.numeric_mapping(data,</span>
<span class="gd">-                    palette, norm)</span>
<span class="gd">-            elif map_type == &#39;categorical&#39;:</span>
<span class="gi">+                levels, lookup_table, norm, cmap = self.numeric_mapping(</span>
<span class="gi">+                    data, palette, norm,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # --- Option 2: categorical mapping using seaborn palette</span>
<span class="gi">+</span>
<span class="gi">+            elif map_type == &quot;categorical&quot;:</span>
<span class="gi">+</span>
<span class="w"> </span>                cmap = norm = None
<span class="gd">-                levels, lookup_table = self.categorical_mapping(data,</span>
<span class="gd">-                    palette, order)</span>
<span class="gi">+                levels, lookup_table = self.categorical_mapping(</span>
<span class="gi">+                    data, palette, order,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # --- Option 3: datetime mapping</span>
<span class="gi">+</span>
<span class="w"> </span>            else:
<span class="gi">+                # TODO this needs actual implementation</span>
<span class="w"> </span>                cmap = norm = None
<span class="gd">-                levels, lookup_table = self.categorical_mapping(list(data),</span>
<span class="gd">-                    palette, order)</span>
<span class="gi">+                levels, lookup_table = self.categorical_mapping(</span>
<span class="gi">+                    # Casting data to list to handle differences in the way</span>
<span class="gi">+                    # pandas and numpy represent datetime64 data</span>
<span class="gi">+                    list(data), palette, order,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>            self.saturation = saturation
<span class="w"> </span>            self.map_type = map_type
<span class="w"> </span>            self.lookup_table = lookup_table
<span class="gu">@@ -93,26 +172,137 @@ class HueMapping(SemanticMapping):</span>

<span class="w"> </span>    def _lookup_single(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Get the color for a single value, using colormap to interpolate.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Use a value that&#39;s in the original data vector</span>
<span class="gi">+            value = self.lookup_table[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+</span>
<span class="gi">+            if self.norm is None:</span>
<span class="gi">+                # Currently we only get here in scatterplot with hue_order,</span>
<span class="gi">+                # because scatterplot does not consider hue a grouping variable</span>
<span class="gi">+                # So unused hue levels are in the data, but not the lookup table</span>
<span class="gi">+                return (0, 0, 0, 0)</span>
<span class="gi">+</span>
<span class="gi">+            # Use the colormap to interpolate between existing datapoints</span>
<span class="gi">+            # (e.g. in the context of making a continuous legend)</span>
<span class="gi">+            try:</span>
<span class="gi">+                normed = self.norm(key)</span>
<span class="gi">+            except TypeError as err:</span>
<span class="gi">+                if np.isnan(key):</span>
<span class="gi">+                    value = (0, 0, 0, 0)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise err</span>
<span class="gi">+            else:</span>
<span class="gi">+                if np.ma.is_masked(normed):</span>
<span class="gi">+                    normed = np.nan</span>
<span class="gi">+                value = self.cmap(normed)</span>
<span class="gi">+</span>
<span class="gi">+        if self.saturation &lt; 1:</span>
<span class="gi">+            value = desaturate(value, self.saturation)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def infer_map_type(self, palette, norm, input_format, var_type):
<span class="w"> </span>        &quot;&quot;&quot;Determine how to implement the mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if palette in QUAL_PALETTES:</span>
<span class="gi">+            map_type = &quot;categorical&quot;</span>
<span class="gi">+        elif norm is not None:</span>
<span class="gi">+            map_type = &quot;numeric&quot;</span>
<span class="gi">+        elif isinstance(palette, (dict, list)):</span>
<span class="gi">+            map_type = &quot;categorical&quot;</span>
<span class="gi">+        elif input_format == &quot;wide&quot;:</span>
<span class="gi">+            map_type = &quot;categorical&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            map_type = var_type</span>
<span class="gi">+</span>
<span class="gi">+        return map_type</span>

<span class="w"> </span>    def categorical_mapping(self, data, palette, order):
<span class="w"> </span>        &quot;&quot;&quot;Determine colors when the hue mapping is categorical.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # -- Identify the order and name of the levels</span>
<span class="gi">+</span>
<span class="gi">+        levels = categorical_order(data, order)</span>
<span class="gi">+        n_colors = len(levels)</span>
<span class="gi">+</span>
<span class="gi">+        # -- Identify the set of colors to use</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(palette, dict):</span>
<span class="gi">+</span>
<span class="gi">+            missing = set(levels) - set(palette)</span>
<span class="gi">+            if any(missing):</span>
<span class="gi">+                err = &quot;The palette dictionary is missing keys: {}&quot;</span>
<span class="gi">+                raise ValueError(err.format(missing))</span>
<span class="gi">+</span>
<span class="gi">+            lookup_table = palette</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            if palette is None:</span>
<span class="gi">+                if n_colors &lt;= len(get_color_cycle()):</span>
<span class="gi">+                    colors = color_palette(None, n_colors)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    colors = color_palette(&quot;husl&quot;, n_colors)</span>
<span class="gi">+            elif isinstance(palette, list):</span>
<span class="gi">+                colors = self._check_list_length(levels, palette, &quot;palette&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                colors = color_palette(palette, n_colors)</span>
<span class="gi">+</span>
<span class="gi">+            lookup_table = dict(zip(levels, colors))</span>
<span class="gi">+</span>
<span class="gi">+        return levels, lookup_table</span>

<span class="w"> </span>    def numeric_mapping(self, data, palette, norm):
<span class="w"> </span>        &quot;&quot;&quot;Determine colors when the hue variable is quantitative.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(palette, dict):</span>
<span class="gi">+</span>
<span class="gi">+            # The presence of a norm object overrides a dictionary of hues</span>
<span class="gi">+            # in specifying a numeric mapping, so we need to process it here.</span>
<span class="gi">+            levels = list(sorted(palette))</span>
<span class="gi">+            colors = [palette[k] for k in sorted(palette)]</span>
<span class="gi">+            cmap = mpl.colors.ListedColormap(colors)</span>
<span class="gi">+            lookup_table = palette.copy()</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            # The levels are the sorted unique values in the data</span>
<span class="gi">+            levels = list(np.sort(remove_na(data.unique())))</span>
<span class="gi">+</span>
<span class="gi">+            # --- Sort out the colormap to use from the palette argument</span>
<span class="gi">+</span>
<span class="gi">+            # Default numeric palette is our default cubehelix palette</span>
<span class="gi">+            # TODO do we want to do something complicated to ensure contrast?</span>
<span class="gi">+            palette = &quot;ch:&quot; if palette is None else palette</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(palette, mpl.colors.Colormap):</span>
<span class="gi">+                cmap = palette</span>
<span class="gi">+            else:</span>
<span class="gi">+                cmap = color_palette(palette, as_cmap=True)</span>
<span class="gi">+</span>
<span class="gi">+            # Now sort out the data normalization</span>
<span class="gi">+            if norm is None:</span>
<span class="gi">+                norm = mpl.colors.Normalize()</span>
<span class="gi">+            elif isinstance(norm, tuple):</span>
<span class="gi">+                norm = mpl.colors.Normalize(*norm)</span>
<span class="gi">+            elif not isinstance(norm, mpl.colors.Normalize):</span>
<span class="gi">+                err = &quot;``hue_norm`` must be None, tuple, or Normalize object.&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+            if not norm.scaled():</span>
<span class="gi">+                norm(np.asarray(data.dropna()))</span>
<span class="gi">+</span>
<span class="gi">+            lookup_table = dict(zip(levels, cmap(norm(levels))))</span>
<span class="gi">+</span>
<span class="gi">+        return levels, lookup_table, norm, cmap</span>


<span class="w"> </span>class SizeMapping(SemanticMapping):
<span class="w"> </span>    &quot;&quot;&quot;Mapping that sets artist sizes according to data values.&quot;&quot;&quot;
<span class="gi">+    # An object that normalizes data values to [0, 1] range</span>
<span class="w"> </span>    norm = None

<span class="gd">-    def __init__(self, plotter, sizes=None, order=None, norm=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, plotter, sizes=None, order=None, norm=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Map the levels of the `size` variable to distinct values.

<span class="w"> </span>        Parameters
<span class="gu">@@ -121,21 +311,44 @@ class SizeMapping(SemanticMapping):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super().__init__(plotter)
<span class="gd">-        data = plotter.plot_data.get(&#39;size&#39;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="gi">+        data = plotter.plot_data.get(&quot;size&quot;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="w"> </span>        if data.notna().any():
<span class="gd">-            map_type = self.infer_map_type(norm, sizes, plotter.var_types[</span>
<span class="gd">-                &#39;size&#39;])</span>
<span class="gd">-            if map_type == &#39;numeric&#39;:</span>
<span class="gi">+</span>
<span class="gi">+            map_type = self.infer_map_type(</span>
<span class="gi">+                norm, sizes, plotter.var_types[&quot;size&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # --- Option 1: numeric mapping</span>
<span class="gi">+</span>
<span class="gi">+            if map_type == &quot;numeric&quot;:</span>
<span class="gi">+</span>
<span class="w"> </span>                levels, lookup_table, norm, size_range = self.numeric_mapping(
<span class="gd">-                    data, sizes, norm)</span>
<span class="gd">-            elif map_type == &#39;categorical&#39;:</span>
<span class="gd">-                levels, lookup_table = self.categorical_mapping(data, sizes,</span>
<span class="gd">-                    order)</span>
<span class="gi">+                    data, sizes, norm,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # --- Option 2: categorical mapping</span>
<span class="gi">+</span>
<span class="gi">+            elif map_type == &quot;categorical&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                levels, lookup_table = self.categorical_mapping(</span>
<span class="gi">+                    data, sizes, order,</span>
<span class="gi">+                )</span>
<span class="w"> </span>                size_range = None
<span class="gi">+</span>
<span class="gi">+            # --- Option 3: datetime mapping</span>
<span class="gi">+</span>
<span class="gi">+            # TODO this needs an actual implementation</span>
<span class="w"> </span>            else:
<span class="gd">-                levels, lookup_table = self.categorical_mapping(list(data),</span>
<span class="gd">-                    sizes, order)</span>
<span class="gi">+</span>
<span class="gi">+                levels, lookup_table = self.categorical_mapping(</span>
<span class="gi">+                    # Casting data to list to handle differences in the way</span>
<span class="gi">+                    # pandas and numpy represent datetime64 data</span>
<span class="gi">+                    list(data), sizes, order,</span>
<span class="gi">+                )</span>
<span class="w"> </span>                size_range = None
<span class="gi">+</span>
<span class="w"> </span>            self.map_type = map_type
<span class="w"> </span>            self.levels = levels
<span class="w"> </span>            self.norm = norm
<span class="gu">@@ -143,10 +356,171 @@ class SizeMapping(SemanticMapping):</span>
<span class="w"> </span>            self.size_range = size_range
<span class="w"> </span>            self.lookup_table = lookup_table

<span class="gi">+    def infer_map_type(self, norm, sizes, var_type):</span>
<span class="gi">+</span>
<span class="gi">+        if norm is not None:</span>
<span class="gi">+            map_type = &quot;numeric&quot;</span>
<span class="gi">+        elif isinstance(sizes, (dict, list)):</span>
<span class="gi">+            map_type = &quot;categorical&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            map_type = var_type</span>
<span class="gi">+</span>
<span class="gi">+        return map_type</span>
<span class="gi">+</span>
<span class="gi">+    def _lookup_single(self, key):</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = self.lookup_table[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            normed = self.norm(key)</span>
<span class="gi">+            if np.ma.is_masked(normed):</span>
<span class="gi">+                normed = np.nan</span>
<span class="gi">+            value = self.size_range[0] + normed * np.ptp(self.size_range)</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def categorical_mapping(self, data, sizes, order):</span>
<span class="gi">+</span>
<span class="gi">+        levels = categorical_order(data, order)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(sizes, dict):</span>
<span class="gi">+</span>
<span class="gi">+            # Dict inputs map existing data values to the size attribute</span>
<span class="gi">+            missing = set(levels) - set(sizes)</span>
<span class="gi">+            if any(missing):</span>
<span class="gi">+                err = f&quot;Missing sizes for the following levels: {missing}&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+            lookup_table = sizes.copy()</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(sizes, list):</span>
<span class="gi">+</span>
<span class="gi">+            # List inputs give size values in the same order as the levels</span>
<span class="gi">+            sizes = self._check_list_length(levels, sizes, &quot;sizes&quot;)</span>
<span class="gi">+            lookup_table = dict(zip(levels, sizes))</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(sizes, tuple):</span>
<span class="gi">+</span>
<span class="gi">+                # Tuple input sets the min, max size values</span>
<span class="gi">+                if len(sizes) != 2:</span>
<span class="gi">+                    err = &quot;A `sizes` tuple must have only 2 values&quot;</span>
<span class="gi">+                    raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+            elif sizes is not None:</span>
<span class="gi">+</span>
<span class="gi">+                err = f&quot;Value for `sizes` not understood: {sizes}&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                # Otherwise, we need to get the min, max size values from</span>
<span class="gi">+                # the plotter object we are attached to.</span>
<span class="gi">+</span>
<span class="gi">+                # TODO this is going to cause us trouble later, because we</span>
<span class="gi">+                # want to restructure things so that the plotter is generic</span>
<span class="gi">+                # across the visual representation of the data. But at this</span>
<span class="gi">+                # point, we don&#39;t know the visual representation. Likely we</span>
<span class="gi">+                # want to change the logic of this Mapping so that it gives</span>
<span class="gi">+                # points on a normalized range that then gets un-normalized</span>
<span class="gi">+                # when we know what we&#39;re drawing. But given the way the</span>
<span class="gi">+                # package works now, this way is cleanest.</span>
<span class="gi">+                sizes = self.plotter._default_size_range</span>
<span class="gi">+</span>
<span class="gi">+            # For categorical sizes, use regularly-spaced linear steps</span>
<span class="gi">+            # between the minimum and maximum sizes. Then reverse the</span>
<span class="gi">+            # ramp so that the largest value is used for the first entry</span>
<span class="gi">+            # in size_order, etc. This is because &quot;ordered&quot; categories</span>
<span class="gi">+            # are often though to go in decreasing priority.</span>
<span class="gi">+            sizes = np.linspace(*sizes, len(levels))[::-1]</span>
<span class="gi">+            lookup_table = dict(zip(levels, sizes))</span>
<span class="gi">+</span>
<span class="gi">+        return levels, lookup_table</span>
<span class="gi">+</span>
<span class="gi">+    def numeric_mapping(self, data, sizes, norm):</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(sizes, dict):</span>
<span class="gi">+            # The presence of a norm object overrides a dictionary of sizes</span>
<span class="gi">+            # in specifying a numeric mapping, so we need to process it</span>
<span class="gi">+            # dictionary here</span>
<span class="gi">+            levels = list(np.sort(list(sizes)))</span>
<span class="gi">+            size_values = sizes.values()</span>
<span class="gi">+            size_range = min(size_values), max(size_values)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            # The levels here will be the unique values in the data</span>
<span class="gi">+            levels = list(np.sort(remove_na(data.unique())))</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(sizes, tuple):</span>
<span class="gi">+</span>
<span class="gi">+                # For numeric inputs, the size can be parametrized by</span>
<span class="gi">+                # the minimum and maximum artist values to map to. The</span>
<span class="gi">+                # norm object that gets set up next specifies how to</span>
<span class="gi">+                # do the mapping.</span>
<span class="gi">+</span>
<span class="gi">+                if len(sizes) != 2:</span>
<span class="gi">+                    err = &quot;A `sizes` tuple must have only 2 values&quot;</span>
<span class="gi">+                    raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+                size_range = sizes</span>
<span class="gi">+</span>
<span class="gi">+            elif sizes is not None:</span>
<span class="gi">+</span>
<span class="gi">+                err = f&quot;Value for `sizes` not understood: {sizes}&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                # When not provided, we get the size range from the plotter</span>
<span class="gi">+                # object we are attached to. See the note in the categorical</span>
<span class="gi">+                # method about how this is suboptimal for future development.</span>
<span class="gi">+                size_range = self.plotter._default_size_range</span>
<span class="gi">+</span>
<span class="gi">+        # Now that we know the minimum and maximum sizes that will get drawn,</span>
<span class="gi">+        # we need to map the data values that we have into that range. We will</span>
<span class="gi">+        # use a matplotlib Normalize class, which is typically used for numeric</span>
<span class="gi">+        # color mapping but works fine here too. It takes data values and maps</span>
<span class="gi">+        # them into a [0, 1] interval, potentially nonlinear-ly.</span>
<span class="gi">+</span>
<span class="gi">+        if norm is None:</span>
<span class="gi">+            # Default is a linear function between the min and max data values</span>
<span class="gi">+            norm = mpl.colors.Normalize()</span>
<span class="gi">+        elif isinstance(norm, tuple):</span>
<span class="gi">+            # It is also possible to give different limits in data space</span>
<span class="gi">+            norm = mpl.colors.Normalize(*norm)</span>
<span class="gi">+        elif not isinstance(norm, mpl.colors.Normalize):</span>
<span class="gi">+            err = f&quot;Value for size `norm` parameter not understood: {norm}&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If provided with Normalize object, copy it so we can modify</span>
<span class="gi">+            norm = copy(norm)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the mapping so all output values are in [0, 1]</span>
<span class="gi">+        norm.clip = True</span>
<span class="gi">+</span>
<span class="gi">+        # If the input range is not set, use the full range of the data</span>
<span class="gi">+        if not norm.scaled():</span>
<span class="gi">+            norm(levels)</span>
<span class="gi">+</span>
<span class="gi">+        # Map from data values to [0, 1] range</span>
<span class="gi">+        sizes_scaled = norm(levels)</span>
<span class="gi">+</span>
<span class="gi">+        # Now map from the scaled range into the artist units</span>
<span class="gi">+        if isinstance(sizes, dict):</span>
<span class="gi">+            lookup_table = sizes</span>
<span class="gi">+        else:</span>
<span class="gi">+            lo, hi = size_range</span>
<span class="gi">+            sizes = lo + sizes_scaled * (hi - lo)</span>
<span class="gi">+            lookup_table = dict(zip(levels, sizes))</span>
<span class="gi">+</span>
<span class="gi">+        return levels, lookup_table, norm, size_range</span>
<span class="gi">+</span>

<span class="w"> </span>class StyleMapping(SemanticMapping):
<span class="w"> </span>    &quot;&quot;&quot;Mapping that sets artist style according to data values.&quot;&quot;&quot;
<span class="gd">-    map_type = &#39;categorical&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Style mapping is always treated as categorical</span>
<span class="gi">+    map_type = &quot;categorical&quot;</span>

<span class="w"> </span>    def __init__(self, plotter, markers=None, dashes=None, order=None):
<span class="w"> </span>        &quot;&quot;&quot;Map the levels of the `style` variable to distinct values.
<span class="gu">@@ -157,15 +531,26 @@ class StyleMapping(SemanticMapping):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super().__init__(plotter)
<span class="gd">-        data = plotter.plot_data.get(&#39;style&#39;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="gi">+        data = plotter.plot_data.get(&quot;style&quot;, pd.Series(dtype=float))</span>
<span class="gi">+</span>
<span class="w"> </span>        if data.notna().any():
<span class="gd">-            if variable_type(data) == &#39;datetime&#39;:</span>
<span class="gi">+</span>
<span class="gi">+            # Cast to list to handle numpy/pandas datetime quirks</span>
<span class="gi">+            if variable_type(data) == &quot;datetime&quot;:</span>
<span class="w"> </span>                data = list(data)
<span class="gi">+</span>
<span class="gi">+            # Find ordered unique values</span>
<span class="w"> </span>            levels = categorical_order(data, order)
<span class="gd">-            markers = self._map_attributes(markers, levels, unique_markers(</span>
<span class="gd">-                len(levels)), &#39;markers&#39;)</span>
<span class="gd">-            dashes = self._map_attributes(dashes, levels, unique_dashes(len</span>
<span class="gd">-                (levels)), &#39;dashes&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            markers = self._map_attributes(</span>
<span class="gi">+                markers, levels, unique_markers(len(levels)), &quot;markers&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            dashes = self._map_attributes(</span>
<span class="gi">+                dashes, levels, unique_dashes(len(levels)), &quot;dashes&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Build the paths matplotlib will use to draw the markers</span>
<span class="w"> </span>            paths = {}
<span class="w"> </span>            filled_markers = []
<span class="w"> </span>            for k, m in markers.items():
<span class="gu">@@ -173,48 +558,92 @@ class StyleMapping(SemanticMapping):</span>
<span class="w"> </span>                    m = mpl.markers.MarkerStyle(m)
<span class="w"> </span>                paths[k] = m.get_path().transformed(m.get_transform())
<span class="w"> </span>                filled_markers.append(m.is_filled())
<span class="gi">+</span>
<span class="gi">+            # Mixture of filled and unfilled markers will show line art markers</span>
<span class="gi">+            # in the edge color, which defaults to white. This can be handled,</span>
<span class="gi">+            # but there would be additional complexity with specifying the</span>
<span class="gi">+            # weight of the line art markers without overwhelming the filled</span>
<span class="gi">+            # ones with the edges. So for now, we will disallow mixtures.</span>
<span class="w"> </span>            if any(filled_markers) and not all(filled_markers):
<span class="gd">-                err = &#39;Filled and line art markers cannot be mixed&#39;</span>
<span class="gi">+                err = &quot;Filled and line art markers cannot be mixed&quot;</span>
<span class="w"> </span>                raise ValueError(err)
<span class="gi">+</span>
<span class="w"> </span>            lookup_table = {}
<span class="w"> </span>            for key in levels:
<span class="w"> </span>                lookup_table[key] = {}
<span class="w"> </span>                if markers:
<span class="gd">-                    lookup_table[key][&#39;marker&#39;] = markers[key]</span>
<span class="gd">-                    lookup_table[key][&#39;path&#39;] = paths[key]</span>
<span class="gi">+                    lookup_table[key][&quot;marker&quot;] = markers[key]</span>
<span class="gi">+                    lookup_table[key][&quot;path&quot;] = paths[key]</span>
<span class="w"> </span>                if dashes:
<span class="gd">-                    lookup_table[key][&#39;dashes&#39;] = dashes[key]</span>
<span class="gi">+                    lookup_table[key][&quot;dashes&quot;] = dashes[key]</span>
<span class="gi">+</span>
<span class="w"> </span>            self.levels = levels
<span class="w"> </span>            self.lookup_table = lookup_table

<span class="w"> </span>    def _lookup_single(self, key, attr=None):
<span class="w"> </span>        &quot;&quot;&quot;Get attribute(s) for a given data point.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if attr is None:</span>
<span class="gi">+            value = self.lookup_table[key]</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = self.lookup_table[key][attr]</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def _map_attributes(self, arg, levels, defaults, attr):
<span class="w"> </span>        &quot;&quot;&quot;Handle the specification for a given style attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if arg is True:</span>
<span class="gi">+            lookup_table = dict(zip(levels, defaults))</span>
<span class="gi">+        elif isinstance(arg, dict):</span>
<span class="gi">+            missing = set(levels) - set(arg)</span>
<span class="gi">+            if missing:</span>
<span class="gi">+                err = f&quot;These `{attr}` levels are missing values: {missing}&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+            lookup_table = arg</span>
<span class="gi">+        elif isinstance(arg, Sequence):</span>
<span class="gi">+            arg = self._check_list_length(levels, arg, attr)</span>
<span class="gi">+            lookup_table = dict(zip(levels, arg))</span>
<span class="gi">+        elif arg:</span>
<span class="gi">+            err = f&quot;This `{attr}` argument was not understood: {arg}&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+        else:</span>
<span class="gi">+            lookup_table = {}</span>
<span class="gi">+</span>
<span class="gi">+        return lookup_table</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =========================================================================== #</span>


<span class="w"> </span>class VectorPlotter:
<span class="w"> </span>    &quot;&quot;&quot;Base class for objects underlying *plot functions.&quot;&quot;&quot;
<span class="gd">-    wide_structure = {&#39;x&#39;: &#39;@index&#39;, &#39;y&#39;: &#39;@values&#39;, &#39;hue&#39;: &#39;@columns&#39;,</span>
<span class="gd">-        &#39;style&#39;: &#39;@columns&#39;}</span>
<span class="gd">-    flat_structure = {&#39;x&#39;: &#39;@index&#39;, &#39;y&#39;: &#39;@values&#39;}</span>
<span class="gd">-    _default_size_range = 1, 2</span>
<span class="gi">+</span>
<span class="gi">+    wide_structure = {</span>
<span class="gi">+        &quot;x&quot;: &quot;@index&quot;, &quot;y&quot;: &quot;@values&quot;, &quot;hue&quot;: &quot;@columns&quot;, &quot;style&quot;: &quot;@columns&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    flat_structure = {&quot;x&quot;: &quot;@index&quot;, &quot;y&quot;: &quot;@values&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    _default_size_range = 1, 2  # Unused but needed in tests, ugh</span>

<span class="w"> </span>    def __init__(self, data=None, variables={}):
<span class="gi">+</span>
<span class="w"> </span>        self._var_levels = {}
<span class="gd">-        self._var_ordered = {&#39;x&#39;: False, &#39;y&#39;: False}</span>
<span class="gi">+        # var_ordered is relevant only for categorical axis variables, and may</span>
<span class="gi">+        # be better handled by an internal axis information object that tracks</span>
<span class="gi">+        # such information and is set up by the scale_* methods. The analogous</span>
<span class="gi">+        # information for numeric axes would be information about log scales.</span>
<span class="gi">+        self._var_ordered = {&quot;x&quot;: False, &quot;y&quot;: False}  # alt., used DefaultDict</span>
<span class="w"> </span>        self.assign_variables(data, variables)
<span class="gd">-        for var in [&#39;hue&#39;, &#39;size&#39;, &#39;style&#39;]:</span>
<span class="gi">+</span>
<span class="gi">+        # TODO Lots of tests assume that these are called to initialize the</span>
<span class="gi">+        # mappings to default values on class initialization. I&#39;d prefer to</span>
<span class="gi">+        # move away from that and only have a mapping when explicitly called.</span>
<span class="gi">+        for var in [&quot;hue&quot;, &quot;size&quot;, &quot;style&quot;]:</span>
<span class="w"> </span>            if var in variables:
<span class="gd">-                getattr(self, f&#39;map_{var}&#39;)()</span>
<span class="gi">+                getattr(self, f&quot;map_{var}&quot;)()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def has_xy_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool({&quot;x&quot;, &quot;y&quot;} &amp; set(self.variables))</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def var_levels(self):
<span class="gu">@@ -229,11 +658,39 @@ class VectorPlotter:</span>
<span class="w"> </span>        tracking plot variables.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for var in self.variables:</span>
<span class="gi">+            if (map_obj := getattr(self, f&quot;_{var}_map&quot;, None)) is not None:</span>
<span class="gi">+                self._var_levels[var] = map_obj.levels</span>
<span class="gi">+        return self._var_levels</span>

<span class="w"> </span>    def assign_variables(self, data=None, variables={}):
<span class="w"> </span>        &quot;&quot;&quot;Define plot variables, optionally using lookup from `data`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = variables.get(&quot;x&quot;, None)</span>
<span class="gi">+        y = variables.get(&quot;y&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        if x is None and y is None:</span>
<span class="gi">+            self.input_format = &quot;wide&quot;</span>
<span class="gi">+            frame, names = self._assign_variables_wideform(data, **variables)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # When dealing with long-form input, use the newer PlotData</span>
<span class="gi">+            # object (internal but introduced for the objects interface)</span>
<span class="gi">+            # to centralize / standardize data consumption logic.</span>
<span class="gi">+            self.input_format = &quot;long&quot;</span>
<span class="gi">+            plot_data = PlotData(data, variables)</span>
<span class="gi">+            frame = plot_data.frame</span>
<span class="gi">+            names = plot_data.names</span>
<span class="gi">+</span>
<span class="gi">+        self.plot_data = frame</span>
<span class="gi">+        self.variables = names</span>
<span class="gi">+        self.var_types = {</span>
<span class="gi">+            v: variable_type(</span>
<span class="gi">+                frame[v],</span>
<span class="gi">+                boolean_type=&quot;numeric&quot; if v in &quot;xy&quot; else &quot;categorical&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            for v in names</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _assign_variables_wideform(self, data=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Define plot variables given wide-form data.
<span class="gu">@@ -257,10 +714,143 @@ class VectorPlotter:</span>
<span class="w"> </span>            the inputs (or None when no name can be determined).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Raise if semantic or other variables are assigned in wide-form mode</span>
<span class="gi">+        assigned = [k for k, v in kwargs.items() if v is not None]</span>
<span class="gi">+        if any(assigned):</span>
<span class="gi">+            s = &quot;s&quot; if len(assigned) &gt; 1 else &quot;&quot;</span>
<span class="gi">+            err = f&quot;The following variable{s} cannot be assigned with wide-form data: &quot;</span>
<span class="gi">+            err += &quot;, &quot;.join(f&quot;`{v}`&quot; for v in assigned)</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+        # Determine if the data object actually has any data in it</span>
<span class="gi">+        empty = data is None or not len(data)</span>
<span class="gi">+</span>
<span class="gi">+        # Then, determine if we have &quot;flat&quot; data (a single vector)</span>
<span class="gi">+        if isinstance(data, dict):</span>
<span class="gi">+            values = data.values()</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = np.atleast_1d(np.asarray(data, dtype=object))</span>
<span class="gi">+        flat = not any(</span>
<span class="gi">+            isinstance(v, Iterable) and not isinstance(v, (str, bytes))</span>
<span class="gi">+            for v in values</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if empty:</span>
<span class="gi">+</span>
<span class="gi">+            # Make an object with the structure of plot_data, but empty</span>
<span class="gi">+            plot_data = pd.DataFrame()</span>
<span class="gi">+            variables = {}</span>
<span class="gi">+</span>
<span class="gi">+        elif flat:</span>
<span class="gi">+</span>
<span class="gi">+            # Handle flat data by converting to pandas Series and using the</span>
<span class="gi">+            # index and/or values to define x and/or y</span>
<span class="gi">+            # (Could be accomplished with a more general to_series() interface)</span>
<span class="gi">+            flat_data = pd.Series(data).copy()</span>
<span class="gi">+            names = {</span>
<span class="gi">+                &quot;@values&quot;: flat_data.name,</span>
<span class="gi">+                &quot;@index&quot;: flat_data.index.name</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+            plot_data = {}</span>
<span class="gi">+            variables = {}</span>
<span class="gi">+</span>
<span class="gi">+            for var in [&quot;x&quot;, &quot;y&quot;]:</span>
<span class="gi">+                if var in self.flat_structure:</span>
<span class="gi">+                    attr = self.flat_structure[var]</span>
<span class="gi">+                    plot_data[var] = getattr(flat_data, attr[1:])</span>
<span class="gi">+                    variables[var] = names[self.flat_structure[var]]</span>

<span class="gd">-    def iter_data(self, grouping_vars=None, *, reverse=False,</span>
<span class="gd">-        from_comp_data=False, by_facet=True, allow_empty=False, dropna=True):</span>
<span class="gi">+            plot_data = pd.DataFrame(plot_data)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise assume we have some collection of vectors.</span>
<span class="gi">+</span>
<span class="gi">+            # Handle Python sequences such that entries end up in the columns,</span>
<span class="gi">+            # not in the rows, of the intermediate wide DataFrame.</span>
<span class="gi">+            # One way to accomplish this is to convert to a dict of Series.</span>
<span class="gi">+            if isinstance(data, Sequence):</span>
<span class="gi">+                data_dict = {}</span>
<span class="gi">+                for i, var in enumerate(data):</span>
<span class="gi">+                    key = getattr(var, &quot;name&quot;, i)</span>
<span class="gi">+                    # TODO is there a safer/more generic way to ensure Series?</span>
<span class="gi">+                    # sort of like np.asarray, but for pandas?</span>
<span class="gi">+                    data_dict[key] = pd.Series(var)</span>
<span class="gi">+</span>
<span class="gi">+                data = data_dict</span>
<span class="gi">+</span>
<span class="gi">+            # Pandas requires that dict values either be Series objects</span>
<span class="gi">+            # or all have the same length, but we want to allow &quot;ragged&quot; inputs</span>
<span class="gi">+            if isinstance(data, Mapping):</span>
<span class="gi">+                data = {key: pd.Series(val) for key, val in data.items()}</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise, delegate to the pandas DataFrame constructor</span>
<span class="gi">+            # This is where we&#39;d prefer to use a general interface that says</span>
<span class="gi">+            # &quot;give me this data as a pandas DataFrame&quot;, so we can accept</span>
<span class="gi">+            # DataFrame objects from other libraries</span>
<span class="gi">+            wide_data = pd.DataFrame(data, copy=True)</span>
<span class="gi">+</span>
<span class="gi">+            # At this point we should reduce the dataframe to numeric cols</span>
<span class="gi">+            numeric_cols = [</span>
<span class="gi">+                k for k, v in wide_data.items() if variable_type(v) == &quot;numeric&quot;</span>
<span class="gi">+            ]</span>
<span class="gi">+            wide_data = wide_data[numeric_cols]</span>
<span class="gi">+</span>
<span class="gi">+            # Now melt the data to long form</span>
<span class="gi">+            melt_kws = {&quot;var_name&quot;: &quot;@columns&quot;, &quot;value_name&quot;: &quot;@values&quot;}</span>
<span class="gi">+            use_index = &quot;@index&quot; in self.wide_structure.values()</span>
<span class="gi">+            if use_index:</span>
<span class="gi">+                melt_kws[&quot;id_vars&quot;] = &quot;@index&quot;</span>
<span class="gi">+                try:</span>
<span class="gi">+                    orig_categories = wide_data.columns.categories</span>
<span class="gi">+                    orig_ordered = wide_data.columns.ordered</span>
<span class="gi">+                    wide_data.columns = wide_data.columns.add_categories(&quot;@index&quot;)</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    category_columns = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    category_columns = True</span>
<span class="gi">+                wide_data[&quot;@index&quot;] = wide_data.index.to_series()</span>
<span class="gi">+</span>
<span class="gi">+            plot_data = wide_data.melt(**melt_kws)</span>
<span class="gi">+</span>
<span class="gi">+            if use_index and category_columns:</span>
<span class="gi">+                plot_data[&quot;@columns&quot;] = pd.Categorical(plot_data[&quot;@columns&quot;],</span>
<span class="gi">+                                                       orig_categories,</span>
<span class="gi">+                                                       orig_ordered)</span>
<span class="gi">+</span>
<span class="gi">+            # Assign names corresponding to plot semantics</span>
<span class="gi">+            for var, attr in self.wide_structure.items():</span>
<span class="gi">+                plot_data[var] = plot_data[attr]</span>
<span class="gi">+</span>
<span class="gi">+            # Define the variable names</span>
<span class="gi">+            variables = {}</span>
<span class="gi">+            for var, attr in self.wide_structure.items():</span>
<span class="gi">+                obj = getattr(wide_data, attr[1:])</span>
<span class="gi">+                variables[var] = getattr(obj, &quot;name&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            # Remove redundant columns from plot_data</span>
<span class="gi">+            plot_data = plot_data[list(variables)]</span>
<span class="gi">+</span>
<span class="gi">+        return plot_data, variables</span>
<span class="gi">+</span>
<span class="gi">+    def map_hue(self, palette=None, order=None, norm=None, saturation=1):</span>
<span class="gi">+        mapping = HueMapping(self, palette, order, norm, saturation)</span>
<span class="gi">+        self._hue_map = mapping</span>
<span class="gi">+</span>
<span class="gi">+    def map_size(self, sizes=None, order=None, norm=None):</span>
<span class="gi">+        mapping = SizeMapping(self, sizes, order, norm)</span>
<span class="gi">+        self._size_map = mapping</span>
<span class="gi">+</span>
<span class="gi">+    def map_style(self, markers=None, dashes=None, order=None):</span>
<span class="gi">+        mapping = StyleMapping(self, markers, dashes, order)</span>
<span class="gi">+        self._style_map = mapping</span>
<span class="gi">+</span>
<span class="gi">+    def iter_data(</span>
<span class="gi">+        self, grouping_vars=None, *,</span>
<span class="gi">+        reverse=False, from_comp_data=False,</span>
<span class="gi">+        by_facet=True, allow_empty=False, dropna=True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generator for getting subsets of data defined by semantic variables.

<span class="w"> </span>        Also injects &quot;col&quot; and &quot;row&quot; into grouping semantics.
<span class="gu">@@ -289,18 +879,158 @@ class VectorPlotter:</span>
<span class="w"> </span>            Subset of ``plot_data`` for this combination of semantic values.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO should this default to using all (non x/y?) semantics?</span>
<span class="gi">+        # or define grouping vars somewhere?</span>
<span class="gi">+        if grouping_vars is None:</span>
<span class="gi">+            grouping_vars = []</span>
<span class="gi">+        elif isinstance(grouping_vars, str):</span>
<span class="gi">+            grouping_vars = [grouping_vars]</span>
<span class="gi">+        elif isinstance(grouping_vars, tuple):</span>
<span class="gi">+            grouping_vars = list(grouping_vars)</span>
<span class="gi">+</span>
<span class="gi">+        # Always insert faceting variables</span>
<span class="gi">+        if by_facet:</span>
<span class="gi">+            facet_vars = {&quot;col&quot;, &quot;row&quot;}</span>
<span class="gi">+            grouping_vars.extend(</span>
<span class="gi">+                facet_vars &amp; set(self.variables) - set(grouping_vars)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Reduce to the semantics used in this plot</span>
<span class="gi">+        grouping_vars = [var for var in grouping_vars if var in self.variables]</span>
<span class="gi">+</span>
<span class="gi">+        if from_comp_data:</span>
<span class="gi">+            data = self.comp_data</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = self.plot_data</span>
<span class="gi">+</span>
<span class="gi">+        if dropna:</span>
<span class="gi">+            data = data.dropna()</span>
<span class="gi">+</span>
<span class="gi">+        levels = self.var_levels.copy()</span>
<span class="gi">+        if from_comp_data:</span>
<span class="gi">+            for axis in {&quot;x&quot;, &quot;y&quot;} &amp; set(grouping_vars):</span>
<span class="gi">+                converter = self.converters[axis].iloc[0]</span>
<span class="gi">+                if self.var_types[axis] == &quot;categorical&quot;:</span>
<span class="gi">+                    if self._var_ordered[axis]:</span>
<span class="gi">+                        # If the axis is ordered, then the axes in a possible</span>
<span class="gi">+                        # facet grid are by definition &quot;shared&quot;, or there is a</span>
<span class="gi">+                        # single axis with a unique cat -&gt; idx mapping.</span>
<span class="gi">+                        # So we can just take the first converter object.</span>
<span class="gi">+                        levels[axis] = converter.convert_units(levels[axis])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Otherwise, the mappings may not be unique, but we can</span>
<span class="gi">+                        # use the unique set of index values in comp_data.</span>
<span class="gi">+                        levels[axis] = np.sort(data[axis].unique())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    transform = converter.get_transform().transform</span>
<span class="gi">+                    levels[axis] = transform(converter.convert_units(levels[axis]))</span>
<span class="gi">+</span>
<span class="gi">+        if grouping_vars:</span>
<span class="gi">+</span>
<span class="gi">+            grouped_data = data.groupby(</span>
<span class="gi">+                grouping_vars, sort=False, as_index=False, observed=False,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            grouping_keys = []</span>
<span class="gi">+            for var in grouping_vars:</span>
<span class="gi">+                key = levels.get(var)</span>
<span class="gi">+                grouping_keys.append([] if key is None else key)</span>
<span class="gi">+</span>
<span class="gi">+            iter_keys = itertools.product(*grouping_keys)</span>
<span class="gi">+            if reverse:</span>
<span class="gi">+                iter_keys = reversed(list(iter_keys))</span>
<span class="gi">+</span>
<span class="gi">+            for key in iter_keys:</span>
<span class="gi">+</span>
<span class="gi">+                pd_key = (</span>
<span class="gi">+                    key[0] if len(key) == 1 and _version_predates(pd, &quot;2.2.0&quot;) else key</span>
<span class="gi">+                )</span>
<span class="gi">+                try:</span>
<span class="gi">+                    data_subset = grouped_data.get_group(pd_key)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    # XXX we are adding this to allow backwards compatibility</span>
<span class="gi">+                    # with the empty artists that old categorical plots would</span>
<span class="gi">+                    # add (before 0.12), which we may decide to break, in which</span>
<span class="gi">+                    # case this option could be removed</span>
<span class="gi">+                    data_subset = data.loc[[]]</span>
<span class="gi">+</span>
<span class="gi">+                if data_subset.empty and not allow_empty:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                sub_vars = dict(zip(grouping_vars, key))</span>
<span class="gi">+</span>
<span class="gi">+                yield sub_vars, data_subset.copy()</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            yield {}, data.copy()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def comp_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Dataframe with numeric x and y, after unit conversion and log scaling.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &quot;ax&quot;):</span>
<span class="gi">+            # Probably a good idea, but will need a bunch of tests updated</span>
<span class="gi">+            # Most of these tests should just use the external interface</span>
<span class="gi">+            # Then this can be re-enabled.</span>
<span class="gi">+            # raise AttributeError(&quot;No Axes attached to plotter&quot;)</span>
<span class="gi">+            return self.plot_data</span>
<span class="gi">+</span>
<span class="gi">+        if not hasattr(self, &quot;_comp_data&quot;):</span>
<span class="gi">+</span>
<span class="gi">+            comp_data = (</span>
<span class="gi">+                self.plot_data</span>
<span class="gi">+                .copy(deep=False)</span>
<span class="gi">+                .drop([&quot;x&quot;, &quot;y&quot;], axis=1, errors=&quot;ignore&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            for var in &quot;yx&quot;:</span>
<span class="gi">+                if var not in self.variables:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                parts = []</span>
<span class="gi">+                grouped = self.plot_data[var].groupby(self.converters[var], sort=False)</span>
<span class="gi">+                for converter, orig in grouped:</span>
<span class="gi">+                    orig = orig.mask(orig.isin([np.inf, -np.inf]), np.nan)</span>
<span class="gi">+                    orig = orig.dropna()</span>
<span class="gi">+                    if var in self.var_levels:</span>
<span class="gi">+                        # TODO this should happen in some centralized location</span>
<span class="gi">+                        # it is similar to GH2419, but more complicated because</span>
<span class="gi">+                        # supporting `order` in categorical plots is tricky</span>
<span class="gi">+                        orig = orig[orig.isin(self.var_levels[var])]</span>
<span class="gi">+                    comp = pd.to_numeric(converter.convert_units(orig)).astype(float)</span>
<span class="gi">+                    transform = converter.get_transform().transform</span>
<span class="gi">+                    parts.append(pd.Series(transform(comp), orig.index, name=orig.name))</span>
<span class="gi">+                if parts:</span>
<span class="gi">+                    comp_col = pd.concat(parts)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    comp_col = pd.Series(dtype=float, name=var)</span>
<span class="gi">+                comp_data.insert(0, var, comp_col)</span>
<span class="gi">+</span>
<span class="gi">+            self._comp_data = comp_data</span>
<span class="gi">+</span>
<span class="gi">+        return self._comp_data</span>

<span class="w"> </span>    def _get_axes(self, sub_vars):
<span class="w"> </span>        &quot;&quot;&quot;Return an Axes object based on existence of row/col variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _attach(self, obj, allowed_types=None, log_scale=None):</span>
<span class="gi">+        row = sub_vars.get(&quot;row&quot;, None)</span>
<span class="gi">+        col = sub_vars.get(&quot;col&quot;, None)</span>
<span class="gi">+        if row is not None and col is not None:</span>
<span class="gi">+            return self.facets.axes_dict[(row, col)]</span>
<span class="gi">+        elif row is not None:</span>
<span class="gi">+            return self.facets.axes_dict[row]</span>
<span class="gi">+        elif col is not None:</span>
<span class="gi">+            return self.facets.axes_dict[col]</span>
<span class="gi">+        elif self.ax is None:</span>
<span class="gi">+            return self.facets.ax</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.ax</span>
<span class="gi">+</span>
<span class="gi">+    def _attach(</span>
<span class="gi">+        self,</span>
<span class="gi">+        obj,</span>
<span class="gi">+        allowed_types=None,</span>
<span class="gi">+        log_scale=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Associate the plotter with an Axes manager and initialize its units.

<span class="w"> </span>        Parameters
<span class="gu">@@ -316,25 +1046,314 @@ class VectorPlotter:</span>
<span class="w"> </span>            arguments for the x and y axes.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .axisgrid import FacetGrid</span>
<span class="gi">+        if isinstance(obj, FacetGrid):</span>
<span class="gi">+            self.ax = None</span>
<span class="gi">+            self.facets = obj</span>
<span class="gi">+            ax_list = obj.axes.flatten()</span>
<span class="gi">+            if obj.col_names is not None:</span>
<span class="gi">+                self.var_levels[&quot;col&quot;] = obj.col_names</span>
<span class="gi">+            if obj.row_names is not None:</span>
<span class="gi">+                self.var_levels[&quot;row&quot;] = obj.row_names</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.ax = obj</span>
<span class="gi">+            self.facets = None</span>
<span class="gi">+            ax_list = [obj]</span>
<span class="gi">+</span>
<span class="gi">+        # Identify which &quot;axis&quot; variables we have defined</span>
<span class="gi">+        axis_variables = set(&quot;xy&quot;).intersection(self.variables)</span>
<span class="gi">+</span>
<span class="gi">+        # -- Verify the types of our x and y variables here.</span>
<span class="gi">+        # This doesn&#39;t really make complete sense being here here, but it&#39;s a fine</span>
<span class="gi">+        # place for it, given  the current system.</span>
<span class="gi">+        # (Note that for some plots, there might be more complicated restrictions)</span>
<span class="gi">+        # e.g. the categorical plots have their own check that as specific to the</span>
<span class="gi">+        # non-categorical axis.</span>
<span class="gi">+        if allowed_types is None:</span>
<span class="gi">+            allowed_types = [&quot;numeric&quot;, &quot;datetime&quot;, &quot;categorical&quot;]</span>
<span class="gi">+        elif isinstance(allowed_types, str):</span>
<span class="gi">+            allowed_types = [allowed_types]</span>
<span class="gi">+</span>
<span class="gi">+        for var in axis_variables:</span>
<span class="gi">+            var_type = self.var_types[var]</span>
<span class="gi">+            if var_type not in allowed_types:</span>
<span class="gi">+                err = (</span>
<span class="gi">+                    f&quot;The {var} variable is {var_type}, but one of &quot;</span>
<span class="gi">+                    f&quot;{allowed_types} is required&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        # -- Get axis objects for each row in plot_data for type conversions and scaling</span>
<span class="gi">+</span>
<span class="gi">+        facet_dim = {&quot;x&quot;: &quot;col&quot;, &quot;y&quot;: &quot;row&quot;}</span>
<span class="gi">+</span>
<span class="gi">+        self.converters = {}</span>
<span class="gi">+        for var in axis_variables:</span>
<span class="gi">+            other_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[var]</span>
<span class="gi">+</span>
<span class="gi">+            converter = pd.Series(index=self.plot_data.index, name=var, dtype=object)</span>
<span class="gi">+            share_state = getattr(self.facets, f&quot;_share{var}&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+            # Simplest cases are that we have a single axes, all axes are shared,</span>
<span class="gi">+            # or sharing is only on the orthogonal facet dimension. In these cases,</span>
<span class="gi">+            # all datapoints get converted the same way, so use the first axis</span>
<span class="gi">+            if share_state is True or share_state == facet_dim[other_var]:</span>
<span class="gi">+                converter.loc[:] = getattr(ax_list[0], f&quot;{var}axis&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                # Next simplest case is when no axes are shared, and we can</span>
<span class="gi">+                # use the axis objects within each facet</span>
<span class="gi">+                if share_state is False:</span>
<span class="gi">+                    for axes_vars, axes_data in self.iter_data():</span>
<span class="gi">+                        ax = self._get_axes(axes_vars)</span>
<span class="gi">+                        converter.loc[axes_data.index] = getattr(ax, f&quot;{var}axis&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # In the more complicated case, the axes are shared within each</span>
<span class="gi">+                # &quot;file&quot; of the facetgrid. In that case, we need to subset the data</span>
<span class="gi">+                # for that file and assign it the first axis in the slice of the grid</span>
<span class="gi">+                else:</span>
<span class="gi">+</span>
<span class="gi">+                    names = getattr(self.facets, f&quot;{share_state}_names&quot;)</span>
<span class="gi">+                    for i, level in enumerate(names):</span>
<span class="gi">+                        idx = (i, 0) if share_state == &quot;row&quot; else (0, i)</span>
<span class="gi">+                        axis = getattr(self.facets.axes[idx], f&quot;{var}axis&quot;)</span>
<span class="gi">+                        converter.loc[self.plot_data[share_state] == level] = axis</span>
<span class="gi">+</span>
<span class="gi">+            # Store the converter vector, which we use elsewhere (e.g comp_data)</span>
<span class="gi">+            self.converters[var] = converter</span>
<span class="gi">+</span>
<span class="gi">+            # Now actually update the matplotlib objects to do the conversion we want</span>
<span class="gi">+            grouped = self.plot_data[var].groupby(self.converters[var], sort=False)</span>
<span class="gi">+            for converter, seed_data in grouped:</span>
<span class="gi">+                if self.var_types[var] == &quot;categorical&quot;:</span>
<span class="gi">+                    if self._var_ordered[var]:</span>
<span class="gi">+                        order = self.var_levels[var]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        order = None</span>
<span class="gi">+                    seed_data = categorical_order(seed_data, order)</span>
<span class="gi">+                converter.update_units(seed_data)</span>
<span class="gi">+</span>
<span class="gi">+        # -- Set numerical axis scales</span>
<span class="gi">+</span>
<span class="gi">+        # First unpack the log_scale argument</span>
<span class="gi">+        if log_scale is None:</span>
<span class="gi">+            scalex = scaley = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Allow single value or x, y tuple</span>
<span class="gi">+            try:</span>
<span class="gi">+                scalex, scaley = log_scale</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                scalex = log_scale if self.var_types.get(&quot;x&quot;) == &quot;numeric&quot; else False</span>
<span class="gi">+                scaley = log_scale if self.var_types.get(&quot;y&quot;) == &quot;numeric&quot; else False</span>
<span class="gi">+</span>
<span class="gi">+        # Now use it</span>
<span class="gi">+        for axis, scale in zip(&quot;xy&quot;, (scalex, scaley)):</span>
<span class="gi">+            if scale:</span>
<span class="gi">+                for ax in ax_list:</span>
<span class="gi">+                    set_scale = getattr(ax, f&quot;set_{axis}scale&quot;)</span>
<span class="gi">+                    if scale is True:</span>
<span class="gi">+                        set_scale(&quot;log&quot;, nonpositive=&quot;mask&quot;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        set_scale(&quot;log&quot;, base=scale, nonpositive=&quot;mask&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # For categorical y, we want the &quot;first&quot; level to be at the top of the axis</span>
<span class="gi">+        if self.var_types.get(&quot;y&quot;, None) == &quot;categorical&quot;:</span>
<span class="gi">+            for ax in ax_list:</span>
<span class="gi">+                ax.yaxis.set_inverted(True)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO -- Add axes labels</span>

<span class="w"> </span>    def _get_scale_transforms(self, axis):
<span class="w"> </span>        &quot;&quot;&quot;Return a function implementing the scale transform (or its inverse).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ax is None:</span>
<span class="gi">+            axis_list = [getattr(ax, f&quot;{axis}axis&quot;) for ax in self.facets.axes.flat]</span>
<span class="gi">+            scales = {axis.get_scale() for axis in axis_list}</span>
<span class="gi">+            if len(scales) &gt; 1:</span>
<span class="gi">+                # It is a simplifying assumption that faceted axes will always have</span>
<span class="gi">+                # the same scale (even if they are unshared and have distinct limits).</span>
<span class="gi">+                # Nothing in the seaborn API allows you to create a FacetGrid with</span>
<span class="gi">+                # a mixture of scales, although it&#39;s possible via matplotlib.</span>
<span class="gi">+                # This is constraining, but no more so than previous behavior that</span>
<span class="gi">+                # only (properly) handled log scales, and there are some places where</span>
<span class="gi">+                # it would be much too complicated to use axes-specific transforms.</span>
<span class="gi">+                err = &quot;Cannot determine transform with mixed scales on faceted axes.&quot;</span>
<span class="gi">+                raise RuntimeError(err)</span>
<span class="gi">+            transform_obj = axis_list[0].get_transform()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # This case is more straightforward</span>
<span class="gi">+            transform_obj = getattr(self.ax, f&quot;{axis}axis&quot;).get_transform()</span>

<span class="gd">-    def _add_axis_labels(self, ax, default_x=&#39;&#39;, default_y=&#39;&#39;):</span>
<span class="gd">-        &quot;&quot;&quot;Add axis labels if not present, set visibility to match ticklabels.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        return transform_obj.transform, transform_obj.inverted().transform</span>

<span class="gd">-    def add_legend_data(self, ax, func, common_kws=None, attrs=None,</span>
<span class="gd">-        semantic_kws=None):</span>
<span class="gi">+    def _add_axis_labels(self, ax, default_x=&quot;&quot;, default_y=&quot;&quot;):</span>
<span class="gi">+        &quot;&quot;&quot;Add axis labels if not present, set visibility to match ticklabels.&quot;&quot;&quot;</span>
<span class="gi">+        # TODO ax could default to None and use attached axes if present</span>
<span class="gi">+        # but what to do about the case of facets? Currently using FacetGrid&#39;s</span>
<span class="gi">+        # set_axis_labels method, which doesn&#39;t add labels to the interior even</span>
<span class="gi">+        # when the axes are not shared. Maybe that makes sense?</span>
<span class="gi">+        if not ax.get_xlabel():</span>
<span class="gi">+            x_visible = any(t.get_visible() for t in ax.get_xticklabels())</span>
<span class="gi">+            ax.set_xlabel(self.variables.get(&quot;x&quot;, default_x), visible=x_visible)</span>
<span class="gi">+        if not ax.get_ylabel():</span>
<span class="gi">+            y_visible = any(t.get_visible() for t in ax.get_yticklabels())</span>
<span class="gi">+            ax.set_ylabel(self.variables.get(&quot;y&quot;, default_y), visible=y_visible)</span>
<span class="gi">+</span>
<span class="gi">+    def add_legend_data(</span>
<span class="gi">+        self, ax, func, common_kws=None, attrs=None, semantic_kws=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add labeled artists to represent the different plot semantics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _update_legend_data(self, update, var, verbosity, title, title_kws,</span>
<span class="gd">-        attr_names, other_props):</span>
<span class="gi">+        verbosity = self.legend</span>
<span class="gi">+        if isinstance(verbosity, str) and verbosity not in [&quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;]:</span>
<span class="gi">+            err = &quot;`legend` must be &#39;auto&#39;, &#39;brief&#39;, &#39;full&#39;, or a boolean.&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+        elif verbosity is True:</span>
<span class="gi">+            verbosity = &quot;auto&quot;</span>
<span class="gi">+</span>
<span class="gi">+        keys = []</span>
<span class="gi">+        legend_kws = {}</span>
<span class="gi">+        common_kws = {} if common_kws is None else common_kws.copy()</span>
<span class="gi">+        semantic_kws = {} if semantic_kws is None else semantic_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # Assign a legend title if there is only going to be one sub-legend,</span>
<span class="gi">+        # otherwise, subtitles will be inserted into the texts list with an</span>
<span class="gi">+        # invisible handle (which is a hack)</span>
<span class="gi">+        titles = {</span>
<span class="gi">+            title for title in</span>
<span class="gi">+            (self.variables.get(v, None) for v in [&quot;hue&quot;, &quot;size&quot;, &quot;style&quot;])</span>
<span class="gi">+            if title is not None</span>
<span class="gi">+        }</span>
<span class="gi">+        title = &quot;&quot; if len(titles) != 1 else titles.pop()</span>
<span class="gi">+        title_kws = dict(</span>
<span class="gi">+            visible=False, color=&quot;w&quot;, s=0, linewidth=0, marker=&quot;&quot;, dashes=&quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def update(var_name, val_name, **kws):</span>
<span class="gi">+</span>
<span class="gi">+            key = var_name, val_name</span>
<span class="gi">+            if key in legend_kws:</span>
<span class="gi">+                legend_kws[key].update(**kws)</span>
<span class="gi">+            else:</span>
<span class="gi">+                keys.append(key)</span>
<span class="gi">+                legend_kws[key] = dict(**kws)</span>
<span class="gi">+</span>
<span class="gi">+        if attrs is None:</span>
<span class="gi">+            attrs = {&quot;hue&quot;: &quot;color&quot;, &quot;size&quot;: [&quot;linewidth&quot;, &quot;s&quot;], &quot;style&quot;: None}</span>
<span class="gi">+        for var, names in attrs.items():</span>
<span class="gi">+            self._update_legend_data(</span>
<span class="gi">+                update, var, verbosity, title, title_kws, names, semantic_kws.get(var),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        legend_data = {}</span>
<span class="gi">+        legend_order = []</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t allow color=None so we can set a neutral color for size/style legends</span>
<span class="gi">+        if common_kws.get(&quot;color&quot;, False) is None:</span>
<span class="gi">+            common_kws.pop(&quot;color&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+</span>
<span class="gi">+            _, label = key</span>
<span class="gi">+            kws = legend_kws[key]</span>
<span class="gi">+            level_kws = {}</span>
<span class="gi">+            use_attrs = [</span>
<span class="gi">+                *self._legend_attributes,</span>
<span class="gi">+                *common_kws,</span>
<span class="gi">+                *[attr for var_attrs in semantic_kws.values() for attr in var_attrs],</span>
<span class="gi">+            ]</span>
<span class="gi">+            for attr in use_attrs:</span>
<span class="gi">+                if attr in kws:</span>
<span class="gi">+                    level_kws[attr] = kws[attr]</span>
<span class="gi">+            artist = func(label=label, **{&quot;color&quot;: &quot;.2&quot;, **common_kws, **level_kws})</span>
<span class="gi">+            if _version_predates(mpl, &quot;3.5.0&quot;):</span>
<span class="gi">+                if isinstance(artist, mpl.lines.Line2D):</span>
<span class="gi">+                    ax.add_line(artist)</span>
<span class="gi">+                elif isinstance(artist, mpl.patches.Patch):</span>
<span class="gi">+                    ax.add_patch(artist)</span>
<span class="gi">+                elif isinstance(artist, mpl.collections.Collection):</span>
<span class="gi">+                    ax.add_collection(artist)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ax.add_artist(artist)</span>
<span class="gi">+            legend_data[key] = artist</span>
<span class="gi">+            legend_order.append(key)</span>
<span class="gi">+</span>
<span class="gi">+        self.legend_title = title</span>
<span class="gi">+        self.legend_data = legend_data</span>
<span class="gi">+        self.legend_order = legend_order</span>
<span class="gi">+</span>
<span class="gi">+    def _update_legend_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        update,</span>
<span class="gi">+        var,</span>
<span class="gi">+        verbosity,</span>
<span class="gi">+        title,</span>
<span class="gi">+        title_kws,</span>
<span class="gi">+        attr_names,</span>
<span class="gi">+        other_props,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate legend tick values and formatted labels.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        brief_ticks = 6</span>
<span class="gi">+        mapper = getattr(self, f&quot;_{var}_map&quot;, None)</span>
<span class="gi">+        if mapper is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        brief = mapper.map_type == &quot;numeric&quot; and (</span>
<span class="gi">+            verbosity == &quot;brief&quot;</span>
<span class="gi">+            or (verbosity == &quot;auto&quot; and len(mapper.levels) &gt; brief_ticks)</span>
<span class="gi">+        )</span>
<span class="gi">+        if brief:</span>
<span class="gi">+            if isinstance(mapper.norm, mpl.colors.LogNorm):</span>
<span class="gi">+                locator = mpl.ticker.LogLocator(numticks=brief_ticks)</span>
<span class="gi">+            else:</span>
<span class="gi">+                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)</span>
<span class="gi">+            limits = min(mapper.levels), max(mapper.levels)</span>
<span class="gi">+            levels, formatted_levels = locator_to_legend_entries(</span>
<span class="gi">+                locator, limits, self.plot_data[var].infer_objects().dtype</span>
<span class="gi">+            )</span>
<span class="gi">+        elif mapper.levels is None:</span>
<span class="gi">+            levels = formatted_levels = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            levels = formatted_levels = mapper.levels</span>
<span class="gi">+</span>
<span class="gi">+        if not title and self.variables.get(var, None) is not None:</span>
<span class="gi">+            update((self.variables[var], &quot;title&quot;), self.variables[var], **title_kws)</span>
<span class="gi">+</span>
<span class="gi">+        other_props = {} if other_props is None else other_props</span>
<span class="gi">+</span>
<span class="gi">+        for level, formatted_level in zip(levels, formatted_levels):</span>
<span class="gi">+            if level is not None:</span>
<span class="gi">+                attr = mapper(level)</span>
<span class="gi">+                if isinstance(attr_names, list):</span>
<span class="gi">+                    attr = {name: attr for name in attr_names}</span>
<span class="gi">+                elif attr_names is not None:</span>
<span class="gi">+                    attr = {attr_names: attr}</span>
<span class="gi">+                attr.update({k: v[level] for k, v in other_props.items() if level in v})</span>
<span class="gi">+                update(self.variables[var], formatted_level, **attr)</span>
<span class="gi">+</span>
<span class="gi">+    # XXX If the scale_* methods are going to modify the plot_data structure, they</span>
<span class="gi">+    # can&#39;t be called twice. That means that if they are called twice, they should</span>
<span class="gi">+    # raise. Alternatively, we could store an original version of plot_data and each</span>
<span class="gi">+    # time they are called they operate on the store, not the current state.</span>
<span class="gi">+</span>
<span class="gi">+    def scale_native(self, axis, *args, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+        # Default, defer to matplotlib</span>
<span class="gi">+</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def scale_numeric(self, axis, *args, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+        # Feels needed to completeness, what should it do?</span>
<span class="gi">+        # Perhaps handle log scaling? Set the ticker/formatter/limits?</span>
<span class="gi">+</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def scale_datetime(self, axis, *args, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+        # Use pd.to_datetime to convert strings or numbers to datetime objects</span>
<span class="gi">+        # Note, use day-resolution for numeric-&gt;datetime to match matplotlib</span>
<span class="gi">+</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def scale_categorical(self, axis, order=None, formatter=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -354,7 +1373,80 @@ class VectorPlotter:</span>
<span class="w"> </span>        self

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method both modifies the internal representation of the data</span>
<span class="gi">+        # (converting it to string) and sets some attributes on self. It might be</span>
<span class="gi">+        # a good idea to have a separate object attached to self that contains the</span>
<span class="gi">+        # information in those attributes (i.e. whether to enforce variable order</span>
<span class="gi">+        # across facets, the order to use) similar to the SemanticMapping objects</span>
<span class="gi">+        # we have for semantic variables. That object could also hold the converter</span>
<span class="gi">+        # objects that get used, if we can decouple those from an existing axis</span>
<span class="gi">+        # (cf. https://github.com/matplotlib/matplotlib/issues/19229).</span>
<span class="gi">+        # There are some interactions with faceting information that would need</span>
<span class="gi">+        # to be thought through, since the converts to use depend on facets.</span>
<span class="gi">+        # If we go that route, these methods could become &quot;borrowed&quot; methods similar</span>
<span class="gi">+        # to what happens with the alternate semantic mapper constructors, although</span>
<span class="gi">+        # that approach is kind of fussy and confusing.</span>
<span class="gi">+</span>
<span class="gi">+        # TODO this method could also set the grid state? Since we like to have no</span>
<span class="gi">+        # grid on the categorical axis by default. Again, a case where we&#39;ll need to</span>
<span class="gi">+        # store information until we use it, so best to have a way to collect the</span>
<span class="gi">+        # attributes that this method sets.</span>
<span class="gi">+</span>
<span class="gi">+        # TODO if we are going to set visual properties of the axes with these methods,</span>
<span class="gi">+        # then we could do the steps currently in CategoricalPlotter._adjust_cat_axis</span>
<span class="gi">+</span>
<span class="gi">+        # TODO another, and distinct idea, is to expose a cut= param here</span>
<span class="gi">+</span>
<span class="gi">+        _check_argument(&quot;axis&quot;, [&quot;x&quot;, &quot;y&quot;], axis)</span>
<span class="gi">+</span>
<span class="gi">+        # Categorical plots can be &quot;univariate&quot; in which case they get an anonymous</span>
<span class="gi">+        # category label on the opposite axis.</span>
<span class="gi">+        if axis not in self.variables:</span>
<span class="gi">+            self.variables[axis] = None</span>
<span class="gi">+            self.var_types[axis] = &quot;categorical&quot;</span>
<span class="gi">+            self.plot_data[axis] = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # If the &quot;categorical&quot; variable has a numeric type, sort the rows so that</span>
<span class="gi">+        # the default result from categorical_order has those values sorted after</span>
<span class="gi">+        # they have been coerced to strings. The reason for this is so that later</span>
<span class="gi">+        # we can get facet-wise orders that are correct.</span>
<span class="gi">+        # XXX Should this also sort datetimes?</span>
<span class="gi">+        # It feels more consistent, but technically will be a default change</span>
<span class="gi">+        # If so, should also change categorical_order to behave that way</span>
<span class="gi">+        if self.var_types[axis] == &quot;numeric&quot;:</span>
<span class="gi">+            self.plot_data = self.plot_data.sort_values(axis, kind=&quot;mergesort&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Now get a reference to the categorical data vector and remove na values</span>
<span class="gi">+        cat_data = self.plot_data[axis].dropna()</span>
<span class="gi">+</span>
<span class="gi">+        # Get the initial categorical order, which we do before string</span>
<span class="gi">+        # conversion to respect the original types of the order list.</span>
<span class="gi">+        # Track whether the order is given explicitly so that we can know</span>
<span class="gi">+        # whether or not to use the order constructed here downstream</span>
<span class="gi">+        self._var_ordered[axis] = order is not None or cat_data.dtype.name == &quot;category&quot;</span>
<span class="gi">+        order = pd.Index(categorical_order(cat_data, order), name=axis)</span>
<span class="gi">+</span>
<span class="gi">+        # Then convert data to strings. This is because in matplotlib,</span>
<span class="gi">+        # &quot;categorical&quot; data really mean &quot;string&quot; data, so doing this artists</span>
<span class="gi">+        # will be drawn on the categorical axis with a fixed scale.</span>
<span class="gi">+        # TODO implement formatter here; check that it returns strings?</span>
<span class="gi">+        if formatter is not None:</span>
<span class="gi">+            cat_data = cat_data.map(formatter)</span>
<span class="gi">+            order = order.map(formatter)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cat_data = cat_data.astype(str)</span>
<span class="gi">+            order = order.astype(str)</span>
<span class="gi">+</span>
<span class="gi">+        # Update the levels list with the type-converted order variable</span>
<span class="gi">+        self.var_levels[axis] = order</span>
<span class="gi">+</span>
<span class="gi">+        # Now ensure that seaborn will use categorical rules internally</span>
<span class="gi">+        self.var_types[axis] = &quot;categorical&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Put the string-typed categorical vector back into the plot_data structure</span>
<span class="gi">+        self.plot_data[axis] = cat_data</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class VariableType(UserString):
<span class="gu">@@ -365,7 +1457,8 @@ class VariableType(UserString):</span>
<span class="w"> </span>    them. If that changes, they should be more verbose.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    allowed = &#39;numeric&#39;, &#39;datetime&#39;, &#39;categorical&#39;</span>
<span class="gi">+    # TODO we can replace this with typing.Literal on Python 3.8+</span>
<span class="gi">+    allowed = &quot;numeric&quot;, &quot;datetime&quot;, &quot;categorical&quot;</span>

<span class="w"> </span>    def __init__(self, data):
<span class="w"> </span>        assert data in self.allowed, data
<span class="gu">@@ -376,7 +1469,7 @@ class VariableType(UserString):</span>
<span class="w"> </span>        return self.data == other


<span class="gd">-def variable_type(vector, boolean_type=&#39;numeric&#39;):</span>
<span class="gi">+def variable_type(vector, boolean_type=&quot;numeric&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine whether a vector contains numeric, categorical, or datetime data.

<span class="gu">@@ -399,7 +1492,73 @@ def variable_type(vector, boolean_type=&#39;numeric&#39;):</span>
<span class="w"> </span>    var_type : &#39;numeric&#39;, &#39;categorical&#39;, or &#39;datetime&#39;
<span class="w"> </span>        Name identifying the type of data in the vector.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    vector = pd.Series(vector)</span>
<span class="gi">+</span>
<span class="gi">+    # If a categorical dtype is set, infer categorical</span>
<span class="gi">+    if isinstance(vector.dtype, pd.CategoricalDtype):</span>
<span class="gi">+        return VariableType(&quot;categorical&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Special-case all-na data, which is always &quot;numeric&quot;</span>
<span class="gi">+    if pd.isna(vector).all():</span>
<span class="gi">+        return VariableType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # At this point, drop nans to simplify further type inference</span>
<span class="gi">+    vector = vector.dropna()</span>
<span class="gi">+</span>
<span class="gi">+    # Special-case binary/boolean data, allow caller to determine</span>
<span class="gi">+    # This triggers a numpy warning when vector has strings/objects</span>
<span class="gi">+    # https://github.com/numpy/numpy/issues/6784</span>
<span class="gi">+    # Because we reduce with .all(), we are agnostic about whether the</span>
<span class="gi">+    # comparison returns a scalar or vector, so we will ignore the warning.</span>
<span class="gi">+    # It triggers a separate DeprecationWarning when the vector has datetimes:</span>
<span class="gi">+    # https://github.com/numpy/numpy/issues/13548</span>
<span class="gi">+    # This is considered a bug by numpy and will likely go away.</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.simplefilter(</span>
<span class="gi">+            action=&#39;ignore&#39;, category=(FutureWarning, DeprecationWarning)</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            if np.isin(vector, [0, 1]).all():</span>
<span class="gi">+                return VariableType(boolean_type)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # .isin comparison is not guaranteed to be possible under NumPy</span>
<span class="gi">+            # casting rules, depending on the (unknown) dtype of &#39;vector&#39;</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    # Defer to positive pandas tests</span>
<span class="gi">+    if pd.api.types.is_numeric_dtype(vector):</span>
<span class="gi">+        return VariableType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_datetime64_dtype(vector):</span>
<span class="gi">+        return VariableType(&quot;datetime&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # --- If we get to here, we need to check the entries</span>
<span class="gi">+</span>
<span class="gi">+    # Check for a collection where everything is a number</span>
<span class="gi">+</span>
<span class="gi">+    def all_numeric(x):</span>
<span class="gi">+        for x_i in x:</span>
<span class="gi">+            if not isinstance(x_i, Number):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if all_numeric(vector):</span>
<span class="gi">+        return VariableType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Check for a collection where everything is a datetime</span>
<span class="gi">+</span>
<span class="gi">+    def all_datetime(x):</span>
<span class="gi">+        for x_i in x:</span>
<span class="gi">+            if not isinstance(x_i, (datetime, np.datetime64)):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if all_datetime(vector):</span>
<span class="gi">+        return VariableType(&quot;datetime&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, our final fallback is to consider things categorical</span>
<span class="gi">+</span>
<span class="gi">+    return VariableType(&quot;categorical&quot;)</span>


<span class="w"> </span>def infer_orient(x=None, y=None, orient=None, require_numeric=True):
<span class="gu">@@ -430,7 +1589,59 @@ def infer_orient(x=None, y=None, orient=None, require_numeric=True):</span>
<span class="w"> </span>    TypeError: When dependent variable is not numeric, with `require_numeric`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    x_type = None if x is None else variable_type(x)</span>
<span class="gi">+    y_type = None if y is None else variable_type(y)</span>
<span class="gi">+</span>
<span class="gi">+    nonnumeric_dv_error = &quot;{} orientation requires numeric `{}` variable.&quot;</span>
<span class="gi">+    single_var_warning = &quot;{} orientation ignored with only `{}` specified.&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if x is None:</span>
<span class="gi">+        if str(orient).startswith(&quot;h&quot;):</span>
<span class="gi">+            warnings.warn(single_var_warning.format(&quot;Horizontal&quot;, &quot;y&quot;))</span>
<span class="gi">+        if require_numeric and y_type != &quot;numeric&quot;:</span>
<span class="gi">+            raise TypeError(nonnumeric_dv_error.format(&quot;Vertical&quot;, &quot;y&quot;))</span>
<span class="gi">+        return &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif y is None:</span>
<span class="gi">+        if str(orient).startswith(&quot;v&quot;):</span>
<span class="gi">+            warnings.warn(single_var_warning.format(&quot;Vertical&quot;, &quot;x&quot;))</span>
<span class="gi">+        if require_numeric and x_type != &quot;numeric&quot;:</span>
<span class="gi">+            raise TypeError(nonnumeric_dv_error.format(&quot;Horizontal&quot;, &quot;x&quot;))</span>
<span class="gi">+        return &quot;y&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif str(orient).startswith(&quot;v&quot;) or orient == &quot;x&quot;:</span>
<span class="gi">+        if require_numeric and y_type != &quot;numeric&quot;:</span>
<span class="gi">+            raise TypeError(nonnumeric_dv_error.format(&quot;Vertical&quot;, &quot;y&quot;))</span>
<span class="gi">+        return &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif str(orient).startswith(&quot;h&quot;) or orient == &quot;y&quot;:</span>
<span class="gi">+        if require_numeric and x_type != &quot;numeric&quot;:</span>
<span class="gi">+            raise TypeError(nonnumeric_dv_error.format(&quot;Horizontal&quot;, &quot;x&quot;))</span>
<span class="gi">+        return &quot;y&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif orient is not None:</span>
<span class="gi">+        err = (</span>
<span class="gi">+            &quot;`orient` must start with &#39;v&#39; or &#39;h&#39; or be None, &quot;</span>
<span class="gi">+            f&quot;but `{repr(orient)}` was passed.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+    elif x_type != &quot;categorical&quot; and y_type == &quot;categorical&quot;:</span>
<span class="gi">+        return &quot;y&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif x_type != &quot;numeric&quot; and y_type == &quot;numeric&quot;:</span>
<span class="gi">+        return &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif x_type == &quot;numeric&quot; and y_type != &quot;numeric&quot;:</span>
<span class="gi">+        return &quot;y&quot;</span>
<span class="gi">+</span>
<span class="gi">+    elif require_numeric and &quot;numeric&quot; not in (x_type, y_type):</span>
<span class="gi">+        err = &quot;Neither the `x` nor `y` variable appears to be numeric.&quot;</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;x&quot;</span>


<span class="w"> </span>def unique_dashes(n):
<span class="gu">@@ -450,7 +1661,38 @@ def unique_dashes(n):</span>
<span class="w"> </span>        dashes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Start with dash specs that are well distinguishable</span>
<span class="gi">+    dashes = [</span>
<span class="gi">+        &quot;&quot;,</span>
<span class="gi">+        (4, 1.5),</span>
<span class="gi">+        (1, 1),</span>
<span class="gi">+        (3, 1.25, 1.5, 1.25),</span>
<span class="gi">+        (5, 1, 1, 1),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Now programmatically build as many as we need</span>
<span class="gi">+    p = 3</span>
<span class="gi">+    while len(dashes) &lt; n:</span>
<span class="gi">+</span>
<span class="gi">+        # Take combinations of long and short dashes</span>
<span class="gi">+        a = itertools.combinations_with_replacement([3, 1.25], p)</span>
<span class="gi">+        b = itertools.combinations_with_replacement([4, 1], p)</span>
<span class="gi">+</span>
<span class="gi">+        # Interleave the combinations, reversing one of the streams</span>
<span class="gi">+        segment_list = itertools.chain(*zip(</span>
<span class="gi">+            list(a)[1:-1][::-1],</span>
<span class="gi">+            list(b)[1:-1]</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+        # Now insert the gaps</span>
<span class="gi">+        for segments in segment_list:</span>
<span class="gi">+            gap = min(segments)</span>
<span class="gi">+            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))</span>
<span class="gi">+            dashes.append(spec)</span>
<span class="gi">+</span>
<span class="gi">+        p += 1</span>
<span class="gi">+</span>
<span class="gi">+    return dashes[:n]</span>


<span class="w"> </span>def unique_markers(n):
<span class="gu">@@ -468,7 +1710,35 @@ def unique_markers(n):</span>
<span class="w"> </span>        All markers will be filled.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Start with marker specs that are well distinguishable</span>
<span class="gi">+    markers = [</span>
<span class="gi">+        &quot;o&quot;,</span>
<span class="gi">+        &quot;X&quot;,</span>
<span class="gi">+        (4, 0, 45),</span>
<span class="gi">+        &quot;P&quot;,</span>
<span class="gi">+        (4, 0, 0),</span>
<span class="gi">+        (4, 1, 0),</span>
<span class="gi">+        &quot;^&quot;,</span>
<span class="gi">+        (4, 1, 45),</span>
<span class="gi">+        &quot;v&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Now generate more from regular polygons of increasing order</span>
<span class="gi">+    s = 5</span>
<span class="gi">+    while len(markers) &lt; n:</span>
<span class="gi">+        a = 360 / (s + 1) / 2</span>
<span class="gi">+        markers.extend([</span>
<span class="gi">+            (s + 1, 1, a),</span>
<span class="gi">+            (s + 1, 0, a),</span>
<span class="gi">+            (s, 1, 0),</span>
<span class="gi">+            (s, 0, 0),</span>
<span class="gi">+        ])</span>
<span class="gi">+        s += 1</span>
<span class="gi">+</span>
<span class="gi">+    # Convert to MarkerStyle object, using only exactly what we need</span>
<span class="gi">+    # markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]</span>
<span class="gi">+</span>
<span class="gi">+    return markers[:n]</span>


<span class="w"> </span>def categorical_order(vector, order=None):
<span class="gu">@@ -490,4 +1760,18 @@ def categorical_order(vector, order=None):</span>
<span class="w"> </span>        Ordered list of category levels not including null values.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if order is None:</span>
<span class="gi">+        if hasattr(vector, &quot;categories&quot;):</span>
<span class="gi">+            order = vector.categories</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                order = vector.cat.categories</span>
<span class="gi">+            except (TypeError, AttributeError):</span>
<span class="gi">+</span>
<span class="gi">+                order = pd.Series(vector).unique()</span>
<span class="gi">+</span>
<span class="gi">+                if variable_type(vector) == &quot;numeric&quot;:</span>
<span class="gi">+                    order = np.sort(order)</span>
<span class="gi">+</span>
<span class="gi">+        order = filter(pd.notnull, order)</span>
<span class="gi">+    return list(order)</span>
<span class="gh">diff --git a/seaborn/_compat.py b/seaborn/_compat.py</span>
<span class="gh">index 76dc5054..bd2f0c12 100644</span>
<span class="gd">--- a/seaborn/_compat.py</span>
<span class="gi">+++ b/seaborn/_compat.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from typing import Literal
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="gu">@@ -9,35 +10,114 @@ from seaborn.utils import _version_predates</span>

<span class="w"> </span>def norm_from_scale(scale, norm):
<span class="w"> </span>    &quot;&quot;&quot;Produce a Normalize object given a Scale and min/max domain limits.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This is an internal maplotlib function that simplifies things to access</span>
<span class="gi">+    # It is likely to become part of the matplotlib API at some point:</span>
<span class="gi">+    # https://github.com/matplotlib/matplotlib/issues/20329</span>
<span class="gi">+    if isinstance(norm, mpl.colors.Normalize):</span>
<span class="gi">+        return norm</span>
<span class="gi">+</span>
<span class="gi">+    if scale is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if norm is None:</span>
<span class="gi">+        vmin = vmax = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        vmin, vmax = norm  # TODO more helpful error if this fails?</span>
<span class="gi">+</span>
<span class="gi">+    class ScaledNorm(mpl.colors.Normalize):</span>
<span class="gi">+</span>
<span class="gi">+        def __call__(self, value, clip=None):</span>
<span class="gi">+            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py</span>
<span class="gi">+            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE</span>
<span class="gi">+            value, is_scalar = self.process_value(value)</span>
<span class="gi">+            self.autoscale_None(value)</span>
<span class="gi">+            if self.vmin &gt; self.vmax:</span>
<span class="gi">+                raise ValueError(&quot;vmin must be less or equal to vmax&quot;)</span>
<span class="gi">+            if self.vmin == self.vmax:</span>
<span class="gi">+                return np.full_like(value, 0)</span>
<span class="gi">+            if clip is None:</span>
<span class="gi">+                clip = self.clip</span>
<span class="gi">+            if clip:</span>
<span class="gi">+                value = np.clip(value, self.vmin, self.vmax)</span>
<span class="gi">+            # ***** Seaborn changes start ****</span>
<span class="gi">+            t_value = self.transform(value).reshape(np.shape(value))</span>
<span class="gi">+            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])</span>
<span class="gi">+            # ***** Seaborn changes end *****</span>
<span class="gi">+            if not np.isfinite([t_vmin, t_vmax]).all():</span>
<span class="gi">+                raise ValueError(&quot;Invalid vmin or vmax&quot;)</span>
<span class="gi">+            t_value -= t_vmin</span>
<span class="gi">+            t_value /= (t_vmax - t_vmin)</span>
<span class="gi">+            t_value = np.ma.masked_invalid(t_value, copy=False)</span>
<span class="gi">+            return t_value[0] if is_scalar else t_value</span>
<span class="gi">+</span>
<span class="gi">+    new_norm = ScaledNorm(vmin, vmax)</span>
<span class="gi">+    new_norm.transform = scale.get_transform().transform</span>
<span class="gi">+</span>
<span class="gi">+    return new_norm</span>


<span class="w"> </span>def get_colormap(name):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to matplotlib colormap interface in 3.6.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return mpl.colormaps[name]</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return mpl.cm.get_cmap(name)</span>


<span class="w"> </span>def register_colormap(name, cmap):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to matplotlib colormap interface in 3.6.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if name not in mpl.colormaps:</span>
<span class="gi">+            mpl.colormaps.register(cmap, name=name)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        mpl.cm.register_cmap(name, cmap)</span>


<span class="gd">-def set_layout_engine(fig: Figure, engine: Literal[&#39;constrained&#39;,</span>
<span class="gd">-    &#39;compressed&#39;, &#39;tight&#39;, &#39;none&#39;]) -&gt;None:</span>
<span class="gi">+def set_layout_engine(</span>
<span class="gi">+    fig: Figure,</span>
<span class="gi">+    engine: Literal[&quot;constrained&quot;, &quot;compressed&quot;, &quot;tight&quot;, &quot;none&quot;],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to auto layout engine interface in 3.6&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(fig, &quot;set_layout_engine&quot;):</span>
<span class="gi">+        fig.set_layout_engine(engine)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # _version_predates(mpl, 3.6)</span>
<span class="gi">+        if engine == &quot;tight&quot;:</span>
<span class="gi">+            fig.set_tight_layout(True)  # type: ignore  # predates typing</span>
<span class="gi">+        elif engine == &quot;constrained&quot;:</span>
<span class="gi">+            fig.set_constrained_layout(True)  # type: ignore</span>
<span class="gi">+        elif engine == &quot;none&quot;:</span>
<span class="gi">+            fig.set_tight_layout(False)  # type: ignore</span>
<span class="gi">+            fig.set_constrained_layout(False)  # type: ignore</span>


<span class="gd">-def get_layout_engine(fig: Figure) -&gt;(mpl.layout_engine.LayoutEngine | None):</span>
<span class="gi">+def get_layout_engine(fig: Figure) -&gt; mpl.layout_engine.LayoutEngine | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to auto layout engine interface in 3.6&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(fig, &quot;get_layout_engine&quot;):</span>
<span class="gi">+        return fig.get_layout_engine()</span>
<span class="gi">+    else:</span>
<span class="gi">+        # _version_predates(mpl, 3.6)</span>
<span class="gi">+        return None</span>


<span class="w"> </span>def share_axis(ax0, ax1, which):
<span class="w"> </span>    &quot;&quot;&quot;Handle changes to post-hoc axis sharing.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.5&quot;):</span>
<span class="gi">+        group = getattr(ax0, f&quot;get_shared_{which}_axes&quot;)()</span>
<span class="gi">+        group.join(ax1, ax0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        getattr(ax1, f&quot;share{which}&quot;)(ax0)</span>


<span class="w"> </span>def get_legend_handles(legend):
<span class="w"> </span>    &quot;&quot;&quot;Handle legendHandles attribute rename.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _version_predates(mpl, &quot;3.7&quot;):</span>
<span class="gi">+        return legend.legendHandles</span>
<span class="gi">+    else:</span>
<span class="gi">+        return legend.legend_handles</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def groupby_apply_include_groups(val):</span>
<span class="gi">+    if _version_predates(pd, &quot;2.2.0&quot;):</span>
<span class="gi">+        return {}</span>
<span class="gi">+    return {&quot;include_groups&quot;: val}</span>
<span class="gh">diff --git a/seaborn/_core/data.py b/seaborn/_core/data.py</span>
<span class="gh">index e6ece7c9..c17bfe95 100644</span>
<span class="gd">--- a/seaborn/_core/data.py</span>
<span class="gi">+++ b/seaborn/_core/data.py</span>
<span class="gu">@@ -2,11 +2,14 @@</span>
<span class="w"> </span>Components for parsing variable assignments and internally representing plot data.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Mapping, Sized
<span class="w"> </span>from typing import cast
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import pandas as pd
<span class="w"> </span>from pandas import DataFrame
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.typing import DataSource, VariableSpec, ColumnName
<span class="w"> </span>from seaborn.utils import _version_predates

<span class="gu">@@ -45,30 +48,87 @@ class PlotData:</span>
<span class="w"> </span>    source_data: DataSource
<span class="w"> </span>    source_vars: dict[str, VariableSpec]

<span class="gd">-    def __init__(self, data: DataSource, variables: dict[str, VariableSpec]):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: DataSource,</span>
<span class="gi">+        variables: dict[str, VariableSpec],</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        data = handle_data_source(data)
<span class="w"> </span>        frame, names, ids = self._assign_variables(data, variables)
<span class="gi">+</span>
<span class="w"> </span>        self.frame = frame
<span class="w"> </span>        self.names = names
<span class="w"> </span>        self.ids = ids
<span class="gi">+</span>
<span class="gi">+        # The reason we possibly have a dictionary of frames is to support the</span>
<span class="gi">+        # Plot.pair operation, post scaling, where each x/y variable needs its</span>
<span class="gi">+        # own frame. This feels pretty clumsy and there are a bunch of places in</span>
<span class="gi">+        # the client code with awkard if frame / elif frames constructions.</span>
<span class="gi">+        # It would be great to have a cleaner abstraction here.</span>
<span class="w"> </span>        self.frames = {}
<span class="gi">+</span>
<span class="w"> </span>        self.source_data = data
<span class="w"> </span>        self.source_vars = variables

<span class="gd">-    def __contains__(self, key: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, key: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Boolean check on whether a variable is defined in this dataset.&quot;&quot;&quot;
<span class="w"> </span>        if self.frame is None:
<span class="w"> </span>            return any(key in df for df in self.frames.values())
<span class="w"> </span>        return key in self.frame

<span class="gd">-    def join(self, data: DataSource, variables: (dict[str, VariableSpec] |</span>
<span class="gd">-        None)) -&gt;PlotData:</span>
<span class="gi">+    def join(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: DataSource,</span>
<span class="gi">+        variables: dict[str, VariableSpec] | None,</span>
<span class="gi">+    ) -&gt; PlotData:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add, replace, or drop variables and return as a new dataset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Inherit the original source of the upstream data by default</span>
<span class="gi">+        if data is None:</span>
<span class="gi">+            data = self.source_data</span>
<span class="gi">+</span>
<span class="gi">+        # TODO allow `data` to be a function (that is called on the source data?)</span>
<span class="gi">+</span>
<span class="gi">+        if not variables:</span>
<span class="gi">+            variables = self.source_vars</span>
<span class="gi">+</span>
<span class="gi">+        # Passing var=None implies that we do not want that variable in this layer</span>
<span class="gi">+        disinherit = [k for k, v in variables.items() if v is None]</span>
<span class="gi">+</span>
<span class="gi">+        # Create a new dataset with just the info passed here</span>
<span class="gi">+        new = PlotData(data, variables)</span>

<span class="gd">-    def _assign_variables(self, data: (DataFrame | Mapping | None),</span>
<span class="gd">-        variables: dict[str, VariableSpec]) -&gt;tuple[DataFrame, dict[str, </span>
<span class="gd">-        str | None], dict[str, str | int]]:</span>
<span class="gi">+        # -- Update the inherited DataSource with this new information</span>
<span class="gi">+</span>
<span class="gi">+        drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]</span>
<span class="gi">+        parts = [self.frame.drop(columns=drop_cols), new.frame]</span>
<span class="gi">+</span>
<span class="gi">+        # Because we are combining distinct columns, this is perhaps more</span>
<span class="gi">+        # naturally thought of as a &quot;merge&quot;/&quot;join&quot;. But using concat because</span>
<span class="gi">+        # some simple testing suggests that it is marginally faster.</span>
<span class="gi">+        frame = pd.concat(parts, axis=1, sort=False, copy=False)</span>
<span class="gi">+</span>
<span class="gi">+        names = {k: v for k, v in self.names.items() if k not in disinherit}</span>
<span class="gi">+        names.update(new.names)</span>
<span class="gi">+</span>
<span class="gi">+        ids = {k: v for k, v in self.ids.items() if k not in disinherit}</span>
<span class="gi">+        ids.update(new.ids)</span>
<span class="gi">+</span>
<span class="gi">+        new.frame = frame</span>
<span class="gi">+        new.names = names</span>
<span class="gi">+        new.ids = ids</span>
<span class="gi">+</span>
<span class="gi">+        # Multiple chained operations should always inherit from the original object</span>
<span class="gi">+        new.source_data = self.source_data</span>
<span class="gi">+        new.source_vars = self.source_vars</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _assign_variables(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: DataFrame | Mapping | None,</span>
<span class="gi">+        variables: dict[str, VariableSpec],</span>
<span class="gi">+    ) -&gt; tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Assign values for plot variables given long-form data and/or vector inputs.

<span class="gu">@@ -102,14 +162,158 @@ class PlotData:</span>
<span class="w"> </span>            non-indexed vector datatypes that have a different length from `data`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        source_data: Mapping | DataFrame</span>
<span class="gi">+        frame: DataFrame</span>
<span class="gi">+        names: dict[str, str | None]</span>
<span class="gi">+        ids: dict[str, str | int]</span>
<span class="gi">+</span>
<span class="gi">+        plot_data = {}</span>
<span class="gi">+        names = {}</span>
<span class="gi">+        ids = {}</span>
<span class="gi">+</span>
<span class="gi">+        given_data = data is not None</span>
<span class="gi">+        if data is None:</span>
<span class="gi">+            # Data is optional; all variables can be defined as vectors</span>
<span class="gi">+            # But simplify downstream code by always having a usable source data object</span>
<span class="gi">+            source_data = {}</span>
<span class="gi">+        else:</span>
<span class="gi">+            source_data = data</span>
<span class="gi">+</span>
<span class="gi">+        # Variables can also be extracted from the index of a DataFrame</span>
<span class="gi">+        if isinstance(source_data, pd.DataFrame):</span>
<span class="gi">+            index = source_data.index.to_frame().to_dict(&quot;series&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            index = {}</span>

<span class="gi">+        for key, val in variables.items():</span>

<span class="gd">-def handle_data_source(data: object) -&gt;(pd.DataFrame | Mapping | None):</span>
<span class="gi">+            # Simply ignore variables with no specification</span>
<span class="gi">+            if val is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Try to treat the argument as a key for the data collection.</span>
<span class="gi">+            # But be flexible about what can be used as a key.</span>
<span class="gi">+            # Usually it will be a string, but allow other hashables when</span>
<span class="gi">+            # taking from the main data object. Allow only strings to reference</span>
<span class="gi">+            # fields in the index, because otherwise there is too much ambiguity.</span>
<span class="gi">+</span>
<span class="gi">+            # TODO this will be rendered unnecessary by the following pandas fix:</span>
<span class="gi">+            # https://github.com/pandas-dev/pandas/pull/41283</span>
<span class="gi">+            try:</span>
<span class="gi">+                hash(val)</span>
<span class="gi">+                val_is_hashable = True</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                val_is_hashable = False</span>
<span class="gi">+</span>
<span class="gi">+            val_as_data_key = (</span>
<span class="gi">+                # See https://github.com/pandas-dev/pandas/pull/41283</span>
<span class="gi">+                # (isinstance(val, abc.Hashable) and val in source_data)</span>
<span class="gi">+                (val_is_hashable and val in source_data)</span>
<span class="gi">+                or (isinstance(val, str) and val in index)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if val_as_data_key:</span>
<span class="gi">+                val = cast(ColumnName, val)</span>
<span class="gi">+                if val in source_data:</span>
<span class="gi">+                    plot_data[key] = source_data[val]</span>
<span class="gi">+                elif val in index:</span>
<span class="gi">+                    plot_data[key] = index[val]</span>
<span class="gi">+                names[key] = ids[key] = str(val)</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(val, str):</span>
<span class="gi">+</span>
<span class="gi">+                # This looks like a column name but, lookup failed.</span>
<span class="gi">+</span>
<span class="gi">+                err = f&quot;Could not interpret value `{val}` for `{key}`. &quot;</span>
<span class="gi">+                if not given_data:</span>
<span class="gi">+                    err += &quot;Value is a string, but `data` was not passed.&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    err += &quot;An entry with this name does not appear in `data`.&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                # Otherwise, assume the value somehow represents data</span>
<span class="gi">+</span>
<span class="gi">+                # Ignore empty data structures</span>
<span class="gi">+                if isinstance(val, Sized) and len(val) == 0:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # If vector has no index, it must match length of data table</span>
<span class="gi">+                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):</span>
<span class="gi">+                    if isinstance(val, Sized) and len(data) != len(val):</span>
<span class="gi">+                        val_cls = val.__class__.__name__</span>
<span class="gi">+                        err = (</span>
<span class="gi">+                            f&quot;Length of {val_cls} vectors must match length of `data`&quot;</span>
<span class="gi">+                            f&quot; when both are used, but `data` has length {len(data)}&quot;</span>
<span class="gi">+                            f&quot; and the vector passed to `{key}` has length {len(val)}.&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                        raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+                plot_data[key] = val</span>
<span class="gi">+</span>
<span class="gi">+                # Try to infer the original name using pandas-like metadata</span>
<span class="gi">+                if hasattr(val, &quot;name&quot;):</span>
<span class="gi">+                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424</span>
<span class="gi">+                else:</span>
<span class="gi">+                    names[key] = None</span>
<span class="gi">+                    ids[key] = id(val)</span>
<span class="gi">+</span>
<span class="gi">+        # Construct a tidy plot DataFrame. This will convert a number of</span>
<span class="gi">+        # types automatically, aligning on index in case of pandas objects</span>
<span class="gi">+        # TODO Note: this fails when variable specs *only* have scalars!</span>
<span class="gi">+        frame = pd.DataFrame(plot_data)</span>
<span class="gi">+</span>
<span class="gi">+        return frame, names, ids</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_data_source(data: object) -&gt; pd.DataFrame | Mapping | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the data source object to a common union representation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(data, pd.DataFrame) or hasattr(data, &quot;__dataframe__&quot;):</span>
<span class="gi">+        # Check for pd.DataFrame inheritance could be removed once</span>
<span class="gi">+        # minimal pandas version supports dataframe interchange (1.5.0).</span>
<span class="gi">+        data = convert_dataframe_to_pandas(data)</span>
<span class="gi">+    elif data is not None and not isinstance(data, Mapping):</span>
<span class="gi">+        err = f&quot;Data source must be a DataFrame or Mapping, not {type(data)!r}.&quot;</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+    return data</span>


<span class="gd">-def convert_dataframe_to_pandas(data: object) -&gt;pd.DataFrame:</span>
<span class="gi">+def convert_dataframe_to_pandas(data: object) -&gt; pd.DataFrame:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use the DataFrame exchange protocol, or fail gracefully.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(data, pd.DataFrame):</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    if not hasattr(pd.api, &quot;interchange&quot;):</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Support for non-pandas DataFrame objects requires a version of pandas &quot;</span>
<span class="gi">+            &quot;that implements the DataFrame interchange protocol. Please upgrade &quot;</span>
<span class="gi">+            &quot;your pandas version or coerce your data to pandas before passing &quot;</span>
<span class="gi">+            &quot;it to seaborn.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if _version_predates(pd, &quot;2.0.2&quot;):</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;DataFrame interchange with pandas&lt;2.0.2 has some known issues. &quot;</span>
<span class="gi">+            f&quot;You are using pandas {pd.__version__}. &quot;</span>
<span class="gi">+            &quot;Continuing, but it is recommended to carefully inspect the results and to &quot;</span>
<span class="gi">+            &quot;consider upgrading.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        warnings.warn(msg, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # This is going to convert all columns in the input dataframe, even though</span>
<span class="gi">+        # we may only need one or two of them. It would be more efficient to select</span>
<span class="gi">+        # the columns that are going to be used in the plot prior to interchange.</span>
<span class="gi">+        # Solving that in general is a hard problem, especially with the objects</span>
<span class="gi">+        # interface where variables passed in Plot() may only be referenced later</span>
<span class="gi">+        # in Plot.add(). But noting here in case this seems to be a bottleneck.</span>
<span class="gi">+        return pd.api.interchange.from_dataframe(data)</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Encountered an exception when converting data source &quot;</span>
<span class="gi">+            &quot;to a pandas DataFrame. See traceback above for details.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise RuntimeError(msg) from err</span>
<span class="gh">diff --git a/seaborn/_core/exceptions.py b/seaborn/_core/exceptions.py</span>
<span class="gh">index b90716ec..048443b0 100644</span>
<span class="gd">--- a/seaborn/_core/exceptions.py</span>
<span class="gi">+++ b/seaborn/_core/exceptions.py</span>
<span class="gu">@@ -18,10 +18,15 @@ class PlotSpecError(RuntimeError):</span>
<span class="w"> </span>    context (e.g., scaling errors could specify the variable that failed.)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def _during(cls, step: str, var: str=&#39;&#39;) -&gt;PlotSpecError:</span>
<span class="gi">+    def _during(cls, step: str, var: str = &quot;&quot;) -&gt; PlotSpecError:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize the class to report the failure of a specific operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = []</span>
<span class="gi">+        if var:</span>
<span class="gi">+            message.append(f&quot;{step} failed for the `{var}` variable.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            message.append(f&quot;{step} failed.&quot;)</span>
<span class="gi">+        message.append(&quot;See the traceback above for more information.&quot;)</span>
<span class="gi">+        return cls(&quot; &quot;.join(message))</span>
<span class="gh">diff --git a/seaborn/_core/groupby.py b/seaborn/_core/groupby.py</span>
<span class="gh">index 89566c5e..cb63c670 100644</span>
<span class="gd">--- a/seaborn/_core/groupby.py</span>
<span class="gi">+++ b/seaborn/_core/groupby.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Simplified split-apply-combine paradigm on dataframes for internal use.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import cast, Iterable
<span class="gi">+</span>
<span class="w"> </span>import pandas as pd
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.rules import categorical_order
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Callable
<span class="gu">@@ -22,8 +26,7 @@ class GroupBy:</span>
<span class="w"> </span>    - It increases future flexibility regarding alternate DataFrame libraries

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, order: (list[str] | dict[str, list | None])):</span>
<span class="gi">+    def __init__(self, order: list[str] | dict[str, list | None]):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize the GroupBy from grouping variables and optional level orders.

<span class="gu">@@ -37,21 +40,43 @@ class GroupBy:</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not order:
<span class="gd">-            raise ValueError(&#39;GroupBy requires at least one grouping variable&#39;)</span>
<span class="gi">+            raise ValueError(&quot;GroupBy requires at least one grouping variable&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(order, list):
<span class="w"> </span>            order = {k: None for k in order}
<span class="w"> </span>        self.order = order

<span class="gd">-    def _get_groups(self, data: DataFrame) -&gt;tuple[str | list[str], Index |</span>
<span class="gd">-        MultiIndex]:</span>
<span class="gi">+    def _get_groups(</span>
<span class="gi">+        self, data: DataFrame</span>
<span class="gi">+    ) -&gt; tuple[str | list[str], Index | MultiIndex]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return index with Cartesian product of ordered grouping variable levels.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = {}</span>
<span class="gi">+        for var, order in self.order.items():</span>
<span class="gi">+            if var in data:</span>
<span class="gi">+                if order is None:</span>
<span class="gi">+                    order = categorical_order(data[var])</span>
<span class="gi">+                levels[var] = order</span>
<span class="gi">+</span>
<span class="gi">+        grouper: str | list[str]</span>
<span class="gi">+        groups: Index | MultiIndex</span>
<span class="gi">+        if not levels:</span>
<span class="gi">+            grouper = []</span>
<span class="gi">+            groups = pd.Index([])</span>
<span class="gi">+        elif len(levels) &gt; 1:</span>
<span class="gi">+            grouper = list(levels)</span>
<span class="gi">+            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)</span>
<span class="gi">+        else:</span>
<span class="gi">+            grouper, = list(levels)</span>
<span class="gi">+            groups = pd.Index(levels[grouper], name=grouper)</span>
<span class="gi">+        return grouper, groups</span>

<span class="w"> </span>    def _reorder_columns(self, res, data):
<span class="w"> </span>        &quot;&quot;&quot;Reorder result columns to match original order with new columns appended.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cols = [c for c in data if c in res]</span>
<span class="gi">+        cols += [c for c in res if c not in data]</span>
<span class="gi">+        return res.reindex(columns=pd.Index(cols))</span>

<span class="gd">-    def agg(self, data: DataFrame, *args, **kwargs) -&gt;DataFrame:</span>
<span class="gi">+    def agg(self, data: DataFrame, *args, **kwargs) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reduce each group to a single row in the output.

<span class="gu">@@ -60,9 +85,45 @@ class GroupBy:</span>
<span class="w"> </span>        those combinations do not appear in the dataset.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        grouper, groups = self._get_groups(data)</span>

<span class="gd">-    def apply(self, data: DataFrame, func: Callable[..., DataFrame], *args,</span>
<span class="gd">-        **kwargs) -&gt;DataFrame:</span>
<span class="gi">+        if not grouper:</span>
<span class="gi">+            # We will need to see whether there are valid usecases that end up here</span>
<span class="gi">+            raise ValueError(&quot;No grouping variables are present in dataframe&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        res = (</span>
<span class="gi">+            data</span>
<span class="gi">+            .groupby(grouper, sort=False, observed=False)</span>
<span class="gi">+            .agg(*args, **kwargs)</span>
<span class="gi">+            .reindex(groups)</span>
<span class="gi">+            .reset_index()</span>
<span class="gi">+            .pipe(self._reorder_columns, data)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def apply(</span>
<span class="gi">+        self, data: DataFrame, func: Callable[..., DataFrame],</span>
<span class="gi">+        *args, **kwargs,</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply a DataFrame -&gt; DataFrame mapping to each group.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        grouper, groups = self._get_groups(data)</span>
<span class="gi">+</span>
<span class="gi">+        if not grouper:</span>
<span class="gi">+            return self._reorder_columns(func(data, *args, **kwargs), data)</span>
<span class="gi">+</span>
<span class="gi">+        parts = {}</span>
<span class="gi">+        for key, part_df in data.groupby(grouper, sort=False, observed=False):</span>
<span class="gi">+            parts[key] = func(part_df, *args, **kwargs)</span>
<span class="gi">+        stack = []</span>
<span class="gi">+        for key in groups:</span>
<span class="gi">+            if key in parts:</span>
<span class="gi">+                if isinstance(grouper, list):</span>
<span class="gi">+                    # Implies that we had a MultiIndex so key is iterable</span>
<span class="gi">+                    group_ids = dict(zip(grouper, cast(Iterable, key)))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    group_ids = {grouper: key}</span>
<span class="gi">+                stack.append(parts[key].assign(**group_ids))</span>
<span class="gi">+</span>
<span class="gi">+        res = pd.concat(stack, ignore_index=True)</span>
<span class="gi">+        return self._reorder_columns(res, data)</span>
<span class="gh">diff --git a/seaborn/_core/moves.py b/seaborn/_core/moves.py</span>
<span class="gh">index e907dbbe..179926e7 100644</span>
<span class="gd">--- a/seaborn/_core/moves.py</span>
<span class="gi">+++ b/seaborn/_core/moves.py</span>
<span class="gu">@@ -1,21 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar, Callable, Optional, Union, cast
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from pandas import DataFrame
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="w"> </span>from seaborn._core.typing import Default
<span class="gi">+</span>
<span class="w"> </span>default = Default()


<span class="w"> </span>@dataclass
<span class="w"> </span>class Move:
<span class="w"> </span>    &quot;&quot;&quot;Base class for objects that apply simple positional transforms.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = True

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="w"> </span>        raise NotImplementedError


<span class="gu">@@ -45,25 +50,30 @@ class Jitter(Move):</span>
<span class="w"> </span>    y: float = 0
<span class="w"> </span>    seed: int | None = None

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="w"> </span>        data = data.copy()
<span class="w"> </span>        rng = np.random.default_rng(self.seed)

<span class="w"> </span>        def jitter(data, col, scale):
<span class="gd">-            noise = rng.uniform(-0.5, +0.5, len(data))</span>
<span class="gi">+            noise = rng.uniform(-.5, +.5, len(data))</span>
<span class="w"> </span>            offsets = noise * scale
<span class="w"> </span>            return data[col] + offsets
<span class="gi">+</span>
<span class="w"> </span>        if self.width is default:
<span class="w"> </span>            width = 0.0 if self.x or self.y else 0.2
<span class="w"> </span>        else:
<span class="w"> </span>            width = cast(float, self.width)
<span class="gi">+</span>
<span class="w"> </span>        if self.width:
<span class="gd">-            data[orient] = jitter(data, orient, width * data[&#39;width&#39;])</span>
<span class="gi">+            data[orient] = jitter(data, orient, width * data[&quot;width&quot;])</span>
<span class="w"> </span>        if self.x:
<span class="gd">-            data[&#39;x&#39;] = jitter(data, &#39;x&#39;, self.x)</span>
<span class="gi">+            data[&quot;x&quot;] = jitter(data, &quot;x&quot;, self.x)</span>
<span class="w"> </span>        if self.y:
<span class="gd">-            data[&#39;y&#39;] = jitter(data, &#39;y&#39;, self.y)</span>
<span class="gi">+            data[&quot;y&quot;] = jitter(data, &quot;y&quot;, self.y)</span>
<span class="gi">+</span>
<span class="w"> </span>        return data


<span class="gu">@@ -85,41 +95,58 @@ class Dodge(Move):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Dodge.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    empty: str = &#39;keep&#39;</span>
<span class="gi">+    empty: str = &quot;keep&quot;  # Options: keep, drop, fill</span>
<span class="w"> </span>    gap: float = 0
<span class="gi">+</span>
<span class="gi">+    # TODO accept just a str here?</span>
<span class="gi">+    # TODO should this always be present?</span>
<span class="gi">+    # TODO should the default be an &quot;all&quot; singleton?</span>
<span class="w"> </span>    by: Optional[list[str]] = None

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="w"> </span>        grouping_vars = [v for v in groupby.order if v in data]
<span class="gd">-        groups = groupby.agg(data, {&#39;width&#39;: &#39;max&#39;})</span>
<span class="gd">-        if self.empty == &#39;fill&#39;:</span>
<span class="gi">+        groups = groupby.agg(data, {&quot;width&quot;: &quot;max&quot;})</span>
<span class="gi">+        if self.empty == &quot;fill&quot;:</span>
<span class="w"> </span>            groups = groups.dropna()

<span class="w"> </span>        def groupby_pos(s):
<span class="gd">-            grouper = [groups[v] for v in [orient, &#39;col&#39;, &#39;row&#39;] if v in data]</span>
<span class="gi">+            grouper = [groups[v] for v in [orient, &quot;col&quot;, &quot;row&quot;] if v in data]</span>
<span class="w"> </span>            return s.groupby(grouper, sort=False, observed=True)

<span class="w"> </span>        def scale_widths(w):
<span class="gd">-            empty = 0 if self.empty == &#39;fill&#39; else w.mean()</span>
<span class="gi">+            # TODO what value to fill missing widths??? Hard problem...</span>
<span class="gi">+            # TODO short circuit this if outer widths has no variance?</span>
<span class="gi">+            empty = 0 if self.empty == &quot;fill&quot; else w.mean()</span>
<span class="w"> </span>            filled = w.fillna(empty)
<span class="w"> </span>            scale = filled.max()
<span class="w"> </span>            norm = filled.sum()
<span class="gd">-            if self.empty == &#39;keep&#39;:</span>
<span class="gi">+            if self.empty == &quot;keep&quot;:</span>
<span class="w"> </span>                w = filled
<span class="w"> </span>            return w / norm * scale

<span class="w"> </span>        def widths_to_offsets(w):
<span class="w"> </span>            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2
<span class="gd">-        new_widths = groupby_pos(groups[&#39;width&#39;]).transform(scale_widths)</span>
<span class="gi">+</span>
<span class="gi">+        new_widths = groupby_pos(groups[&quot;width&quot;]).transform(scale_widths)</span>
<span class="w"> </span>        offsets = groupby_pos(new_widths).transform(widths_to_offsets)
<span class="gi">+</span>
<span class="w"> </span>        if self.gap:
<span class="w"> </span>            new_widths *= 1 - self.gap
<span class="gd">-        groups[&#39;_dodged&#39;] = groups[orient] + offsets</span>
<span class="gd">-        groups[&#39;width&#39;] = new_widths</span>
<span class="gd">-        out = data.drop(&#39;width&#39;, axis=1).merge(groups, on=grouping_vars,</span>
<span class="gd">-            how=&#39;left&#39;).drop(orient, axis=1).rename(columns={&#39;_dodged&#39;: orient}</span>
<span class="gd">-            )</span>
<span class="gi">+</span>
<span class="gi">+        groups[&quot;_dodged&quot;] = groups[orient] + offsets</span>
<span class="gi">+        groups[&quot;width&quot;] = new_widths</span>
<span class="gi">+</span>
<span class="gi">+        out = (</span>
<span class="gi">+            data</span>
<span class="gi">+            .drop(&quot;width&quot;, axis=1)</span>
<span class="gi">+            .merge(groups, on=grouping_vars, how=&quot;left&quot;)</span>
<span class="gi">+            .drop(orient, axis=1)</span>
<span class="gi">+            .rename(columns={&quot;_dodged&quot;: orient})</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        return out


<span class="gu">@@ -133,10 +160,33 @@ class Stack(Move):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Stack.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # TODO center? (or should this be a different move, eg. Stream())</span>
<span class="gi">+</span>
<span class="gi">+    def _stack(self, df, orient):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO should stack do something with ymin/ymax style marks?</span>
<span class="gi">+        # Should there be an upstream conversion to baseline/height parameterization?</span>

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        groupers = [&#39;col&#39;, &#39;row&#39;, orient]</span>
<span class="gi">+        if df[&quot;baseline&quot;].nunique() &gt; 1:</span>
<span class="gi">+            err = &quot;Stack move cannot be used when baselines are already heterogeneous&quot;</span>
<span class="gi">+            raise RuntimeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        stacked_lengths = (df[other] - df[&quot;baseline&quot;]).dropna().cumsum()</span>
<span class="gi">+        offsets = stacked_lengths.shift(1).fillna(0)</span>
<span class="gi">+</span>
<span class="gi">+        df[other] = stacked_lengths</span>
<span class="gi">+        df[&quot;baseline&quot;] = df[&quot;baseline&quot;] + offsets</span>
<span class="gi">+</span>
<span class="gi">+        return df</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        # TODO where to ensure that other semantic variables are sorted properly?</span>
<span class="gi">+        # TODO why are we not using the passed in groupby here?</span>
<span class="gi">+        groupers = [&quot;col&quot;, &quot;row&quot;, orient]</span>
<span class="w"> </span>        return GroupBy(groupers).apply(data, self._stack, orient)


<span class="gu">@@ -158,11 +208,13 @@ class Shift(Move):</span>
<span class="w"> </span>    x: float = 0
<span class="w"> </span>    y: float = 0

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="w"> </span>        data = data.copy(deep=False)
<span class="gd">-        data[&#39;x&#39;] = data[&#39;x&#39;] + self.x</span>
<span class="gd">-        data[&#39;y&#39;] = data[&#39;y&#39;] + self.y</span>
<span class="gi">+        data[&quot;x&quot;] = data[&quot;x&quot;] + self.x</span>
<span class="gi">+        data[&quot;y&quot;] = data[&quot;y&quot;] + self.y</span>
<span class="w"> </span>        return data


<span class="gu">@@ -187,13 +239,36 @@ class Norm(Move):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Norm.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    func: Union[Callable, str] = &#39;max&#39;</span>
<span class="gi">+</span>
<span class="gi">+    func: Union[Callable, str] = &quot;max&quot;</span>
<span class="w"> </span>    where: Optional[str] = None
<span class="w"> </span>    by: Optional[list[str]] = None
<span class="w"> </span>    percent: bool = False
<span class="gi">+</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = False

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        other = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gi">+    def _norm(self, df, var):</span>
<span class="gi">+</span>
<span class="gi">+        if self.where is None:</span>
<span class="gi">+            denom_data = df[var]</span>
<span class="gi">+        else:</span>
<span class="gi">+            denom_data = df.query(self.where)[var]</span>
<span class="gi">+        df[var] = df[var] / denom_data.agg(self.func)</span>
<span class="gi">+</span>
<span class="gi">+        if self.percent:</span>
<span class="gi">+            df[var] = df[var] * 100</span>
<span class="gi">+</span>
<span class="gi">+        return df</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="w"> </span>        return groupby.apply(data, self._norm, other)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO</span>
<span class="gi">+# @dataclass</span>
<span class="gi">+# class Ridge(Move):</span>
<span class="gi">+#     ...</span>
<span class="gh">diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py</span>
<span class="gh">index 0695b4a6..14348e35 100644</span>
<span class="gd">--- a/seaborn/_core/plot.py</span>
<span class="gi">+++ b/seaborn/_core/plot.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The classes for specifying and compiling a declarative visualization.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gu">@@ -11,6 +12,7 @@ from collections import abc</span>
<span class="w"> </span>from collections.abc import Callable, Generator
<span class="w"> </span>from typing import Any, List, Literal, Optional, cast
<span class="w"> </span>from xml.etree import ElementTree
<span class="gi">+</span>
<span class="w"> </span>from cycler import cycler
<span class="w"> </span>import pandas as pd
<span class="w"> </span>from pandas import DataFrame, Series, Index
<span class="gu">@@ -20,6 +22,7 @@ from matplotlib.artist import Artist</span>
<span class="w"> </span>from matplotlib.figure import Figure
<span class="w"> </span>import numpy as np
<span class="w"> </span>from PIL import Image
<span class="gi">+</span>
<span class="w"> </span>from seaborn._marks.base import Mark
<span class="w"> </span>from seaborn._stats.base import Stat
<span class="w"> </span>from seaborn._core.data import PlotData
<span class="gu">@@ -28,22 +31,35 @@ from seaborn._core.scales import Scale</span>
<span class="w"> </span>from seaborn._core.subplots import Subplots
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._core.properties import PROPERTIES, Property
<span class="gd">-from seaborn._core.typing import DataSource, VariableSpec, VariableSpecList, OrderSpec, Default</span>
<span class="gi">+from seaborn._core.typing import (</span>
<span class="gi">+    DataSource,</span>
<span class="gi">+    VariableSpec,</span>
<span class="gi">+    VariableSpecList,</span>
<span class="gi">+    OrderSpec,</span>
<span class="gi">+    Default,</span>
<span class="gi">+)</span>
<span class="w"> </span>from seaborn._core.exceptions import PlotSpecError
<span class="w"> </span>from seaborn._core.rules import categorical_order
<span class="w"> </span>from seaborn._compat import get_layout_engine, set_layout_engine
<span class="w"> </span>from seaborn.utils import _version_predates
<span class="w"> </span>from seaborn.rcmod import axes_style, plotting_context
<span class="w"> </span>from seaborn.palettes import color_palette
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, TypedDict
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from matplotlib.figure import SubFigure
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>default = Default()


<span class="gd">-class Layer(TypedDict, total=(False)):</span>
<span class="gd">-    mark: Mark</span>
<span class="gd">-    stat: Stat | None</span>
<span class="gi">+# ---- Definitions for internal specs ---------------------------------------------- #</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Layer(TypedDict, total=False):</span>
<span class="gi">+</span>
<span class="gi">+    mark: Mark  # TODO allow list?</span>
<span class="gi">+    stat: Stat | None  # TODO allow list?</span>
<span class="w"> </span>    move: Move | list[Move] | None
<span class="w"> </span>    data: PlotData
<span class="w"> </span>    source: DataSource
<span class="gu">@@ -53,23 +69,41 @@ class Layer(TypedDict, total=(False)):</span>
<span class="w"> </span>    label: str | None


<span class="gd">-class FacetSpec(TypedDict, total=(False)):</span>
<span class="gi">+class FacetSpec(TypedDict, total=False):</span>
<span class="gi">+</span>
<span class="w"> </span>    variables: dict[str, VariableSpec]
<span class="w"> </span>    structure: dict[str, list[str]]
<span class="w"> </span>    wrap: int | None


<span class="gd">-class PairSpec(TypedDict, total=(False)):</span>
<span class="gi">+class PairSpec(TypedDict, total=False):</span>
<span class="gi">+</span>
<span class="w"> </span>    variables: dict[str, VariableSpec]
<span class="w"> </span>    structure: dict[str, list[str]]
<span class="w"> </span>    cross: bool
<span class="w"> </span>    wrap: int | None


<span class="gi">+# --- Local helpers ---------------------------------------------------------------- #</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@contextmanager
<span class="gd">-def theme_context(params: dict[str, Any]) -&gt;Generator:</span>
<span class="gi">+def theme_context(params: dict[str, Any]) -&gt; Generator:</span>
<span class="w"> </span>    &quot;&quot;&quot;Temporarily modify specifc matplotlib rcParams.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    orig_params = {k: mpl.rcParams[k] for k in params}</span>
<span class="gi">+    color_codes = &quot;bgrmyck&quot;</span>
<span class="gi">+    nice_colors = [*color_palette(&quot;deep6&quot;), (.15, .15, .15)]</span>
<span class="gi">+    orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]</span>
<span class="gi">+    # TODO how to allow this to reflect the color cycle when relevant?</span>
<span class="gi">+    try:</span>
<span class="gi">+        mpl.rcParams.update(params)</span>
<span class="gi">+        for (code, color) in zip(color_codes, nice_colors):</span>
<span class="gi">+            mpl.colors.colorConverter.colors[code] = color</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        mpl.rcParams.update(orig_params)</span>
<span class="gi">+        for (code, color) in zip(color_codes, orig_colors):</span>
<span class="gi">+            mpl.colors.colorConverter.colors[code] = color</span>


<span class="w"> </span>def build_plot_signature(cls):
<span class="gu">@@ -81,50 +115,113 @@ def build_plot_signature(cls):</span>
<span class="w"> </span>    at which point dynamic signature generation would become more important.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = inspect.signature(cls)</span>
<span class="gi">+    params = [</span>
<span class="gi">+        inspect.Parameter(&quot;args&quot;, inspect.Parameter.VAR_POSITIONAL),</span>
<span class="gi">+        inspect.Parameter(&quot;data&quot;, inspect.Parameter.KEYWORD_ONLY, default=None)</span>
<span class="gi">+    ]</span>
<span class="gi">+    params.extend([</span>
<span class="gi">+        inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)</span>
<span class="gi">+        for name in PROPERTIES</span>
<span class="gi">+    ])</span>
<span class="gi">+    new_sig = sig.replace(parameters=params)</span>
<span class="gi">+    cls.__signature__ = new_sig</span>
<span class="gi">+</span>
<span class="gi">+    known_properties = textwrap.fill(</span>
<span class="gi">+        &quot;, &quot;.join([f&quot;|{p}|&quot; for p in PROPERTIES]),</span>
<span class="gi">+        width=78, subsequent_indent=&quot; &quot; * 8,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if cls.__doc__ is not None:  # support python -OO mode</span>
<span class="gi">+        cls.__doc__ = cls.__doc__.format(known_properties=known_properties)</span>
<span class="gi">+</span>
<span class="gi">+    return cls</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ---- Plot configuration ---------------------------------------------------------- #</span>


<span class="w"> </span>class ThemeConfig(mpl.RcParams):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Configuration object for the Plot.theme, using matplotlib rc parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    THEME_GROUPS = [&#39;axes&#39;, &#39;figure&#39;, &#39;font&#39;, &#39;grid&#39;, &#39;hatch&#39;, &#39;legend&#39;,</span>
<span class="gd">-        &#39;lines&#39;, &#39;mathtext&#39;, &#39;markers&#39;, &#39;patch&#39;, &#39;savefig&#39;, &#39;scatter&#39;,</span>
<span class="gd">-        &#39;xaxis&#39;, &#39;xtick&#39;, &#39;yaxis&#39;, &#39;ytick&#39;]</span>
<span class="gi">+    THEME_GROUPS = [</span>
<span class="gi">+        &quot;axes&quot;, &quot;figure&quot;, &quot;font&quot;, &quot;grid&quot;, &quot;hatch&quot;, &quot;legend&quot;, &quot;lines&quot;,</span>
<span class="gi">+        &quot;mathtext&quot;, &quot;markers&quot;, &quot;patch&quot;, &quot;savefig&quot;, &quot;scatter&quot;,</span>
<span class="gi">+        &quot;xaxis&quot;, &quot;xtick&quot;, &quot;yaxis&quot;, &quot;ytick&quot;,</span>
<span class="gi">+    ]</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.reset()

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _default(self) -&gt; dict[str, Any]:</span>
<span class="gi">+</span>
<span class="gi">+        return {</span>
<span class="gi">+            **self._filter_params(mpl.rcParamsDefault),</span>
<span class="gi">+            **axes_style(&quot;darkgrid&quot;),</span>
<span class="gi">+            **plotting_context(&quot;notebook&quot;),</span>
<span class="gi">+            &quot;axes.prop_cycle&quot;: cycler(&quot;color&quot;, color_palette(&quot;deep&quot;)),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the theme dictionary with seaborn&#39;s default values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.update(self._default)</span>

<span class="gd">-    def update(self, other: (dict[str, Any] | None)=None, /, **kwds):</span>
<span class="gi">+    def update(self, other: dict[str, Any] | None = None, /, **kwds):</span>
<span class="w"> </span>        &quot;&quot;&quot;Update the theme with a dictionary or keyword arguments of rc parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _filter_params(self, params: dict[str, Any]) -&gt;dict[str, Any]:</span>
<span class="gi">+        if other is not None:</span>
<span class="gi">+            theme = self._filter_params(other)</span>
<span class="gi">+        else:</span>
<span class="gi">+            theme = {}</span>
<span class="gi">+        theme.update(kwds)</span>
<span class="gi">+        super().update(theme)</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_params(self, params: dict[str, Any]) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Restruct to thematic rc params.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            k: v for k, v in params.items()</span>
<span class="gi">+            if any(k.startswith(p) for p in self.THEME_GROUPS)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _html_table(self, params: dict[str, Any]) -&gt; list[str]:</span>
<span class="gi">+</span>
<span class="gi">+        lines = [&quot;&lt;table&gt;&quot;]</span>
<span class="gi">+        for k, v in params.items():</span>
<span class="gi">+            row = f&quot;&lt;tr&gt;&lt;td&gt;{k}:&lt;/td&gt;&lt;td style=&#39;text-align:left&#39;&gt;{v!r}&lt;/td&gt;&lt;/tr&gt;&quot;</span>
<span class="gi">+            lines.append(row)</span>
<span class="gi">+        lines.append(&quot;&lt;/table&gt;&quot;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_html_(self) -&gt; str:</span>
<span class="gi">+</span>
<span class="gi">+        repr = [</span>
<span class="gi">+            &quot;&lt;div style=&#39;height: 300px&#39;&gt;&quot;,</span>
<span class="gi">+            &quot;&lt;div style=&#39;border-style: inset; border-width: 2px&#39;&gt;&quot;,</span>
<span class="gi">+            *self._html_table(self),</span>
<span class="gi">+            &quot;&lt;/div&gt;&quot;,</span>
<span class="gi">+            &quot;&lt;/div&gt;&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+        return &quot;\n&quot;.join(repr)</span>


<span class="w"> </span>class DisplayConfig(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;Configuration for IPython&#39;s rich display hooks.&quot;&quot;&quot;
<span class="gd">-    format: Literal[&#39;png&#39;, &#39;svg&#39;]</span>
<span class="gi">+    format: Literal[&quot;png&quot;, &quot;svg&quot;]</span>
<span class="w"> </span>    scaling: float
<span class="w"> </span>    hidpi: bool


<span class="w"> </span>class PlotConfig:
<span class="w"> </span>    &quot;&quot;&quot;Configuration for default behavior / appearance of class:`Plot` instances.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gi">+</span>
<span class="w"> </span>        self._theme = ThemeConfig()
<span class="gd">-        self._display = {&#39;format&#39;: &#39;png&#39;, &#39;scaling&#39;: 0.85, &#39;hidpi&#39;: True}</span>
<span class="gi">+        self._display = {&quot;format&quot;: &quot;png&quot;, &quot;scaling&quot;: .85, &quot;hidpi&quot;: True}</span>

<span class="w"> </span>    @property
<span class="gd">-    def theme(self) -&gt;dict[str, Any]:</span>
<span class="gi">+    def theme(self) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dictionary of base theme parameters for :class:`Plot`.

<span class="gu">@@ -132,10 +229,10 @@ class PlotConfig:</span>
<span class="w"> </span>        https://matplotlib.org/stable/tutorials/introductory/customizing.html

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._theme</span>

<span class="w"> </span>    @property
<span class="gd">-    def display(self) -&gt;DisplayConfig:</span>
<span class="gi">+    def display(self) -&gt; DisplayConfig:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dictionary of parameters for rich display in Jupyter notebook.

<span class="gu">@@ -146,7 +243,10 @@ class PlotConfig:</span>
<span class="w"> </span>        - hidpi (bool): When True, double the DPI while preserving the size

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._display</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ---- The main interface for declarative plotting --------------------------------- #</span>


<span class="w"> </span>@build_plot_signature
<span class="gu">@@ -185,61 +285,161 @@ class Plot:</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    config = PlotConfig()
<span class="gi">+</span>
<span class="w"> </span>    _data: PlotData
<span class="w"> </span>    _layers: list[Layer]
<span class="gi">+</span>
<span class="w"> </span>    _scales: dict[str, Scale]
<span class="w"> </span>    _shares: dict[str, bool | str]
<span class="w"> </span>    _limits: dict[str, tuple[Any, Any]]
<span class="w"> </span>    _labels: dict[str, str | Callable[[str], str]]
<span class="w"> </span>    _theme: dict[str, Any]
<span class="gi">+</span>
<span class="w"> </span>    _facet_spec: FacetSpec
<span class="w"> </span>    _pair_spec: PairSpec
<span class="gi">+</span>
<span class="w"> </span>    _figure_spec: dict[str, Any]
<span class="w"> </span>    _subplot_spec: dict[str, Any]
<span class="w"> </span>    _layout_spec: dict[str, Any]

<span class="gd">-    def __init__(self, *args: (DataSource | VariableSpec), data: DataSource</span>
<span class="gd">-        =None, **variables: VariableSpec):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *args: DataSource | VariableSpec,</span>
<span class="gi">+        data: DataSource = None,</span>
<span class="gi">+        **variables: VariableSpec,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        if args:
<span class="w"> </span>            data, variables = self._resolve_positionals(args, data, variables)
<span class="gi">+</span>
<span class="w"> </span>        unknown = [x for x in variables if x not in PROPERTIES]
<span class="w"> </span>        if unknown:
<span class="gd">-            err = (</span>
<span class="gd">-                f&quot;Plot() got unexpected keyword argument(s): {&#39;, &#39;.join(unknown)}&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            err = f&quot;Plot() got unexpected keyword argument(s): {&#39;, &#39;.join(unknown)}&quot;</span>
<span class="w"> </span>            raise TypeError(err)
<span class="gi">+</span>
<span class="w"> </span>        self._data = PlotData(data, variables)
<span class="gi">+</span>
<span class="w"> </span>        self._layers = []
<span class="gi">+</span>
<span class="w"> </span>        self._scales = {}
<span class="w"> </span>        self._shares = {}
<span class="w"> </span>        self._limits = {}
<span class="w"> </span>        self._labels = {}
<span class="w"> </span>        self._theme = {}
<span class="gi">+</span>
<span class="w"> </span>        self._facet_spec = {}
<span class="w"> </span>        self._pair_spec = {}
<span class="gi">+</span>
<span class="w"> </span>        self._figure_spec = {}
<span class="w"> </span>        self._subplot_spec = {}
<span class="w"> </span>        self._layout_spec = {}
<span class="gi">+</span>
<span class="w"> </span>        self._target = None

<span class="gd">-    def _resolve_positionals(self, args: tuple[DataSource | VariableSpec,</span>
<span class="gd">-        ...], data: DataSource, variables: dict[str, VariableSpec]) -&gt;tuple[</span>
<span class="gd">-        DataSource, dict[str, VariableSpec]]:</span>
<span class="gi">+    def _resolve_positionals(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: tuple[DataSource | VariableSpec, ...],</span>
<span class="gi">+        data: DataSource,</span>
<span class="gi">+        variables: dict[str, VariableSpec],</span>
<span class="gi">+    ) -&gt; tuple[DataSource, dict[str, VariableSpec]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle positional arguments, which may contain data / x / y.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(args) &gt; 3:</span>
<span class="gi">+            err = &quot;Plot() accepts no more than 3 positional arguments (data, x, y).&quot;</span>
<span class="gi">+            raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(args[0], (abc.Mapping, pd.DataFrame))</span>
<span class="gi">+            or hasattr(args[0], &quot;__dataframe__&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            if data is not None:</span>
<span class="gi">+                raise TypeError(&quot;`data` given by both name and position.&quot;)</span>
<span class="gi">+            data, args = args[0], args[1:]</span>
<span class="gi">+</span>
<span class="gi">+        if len(args) == 2:</span>
<span class="gi">+            x, y = args</span>
<span class="gi">+        elif len(args) == 1:</span>
<span class="gi">+            x, y = *args, None</span>
<span class="gi">+        else:</span>
<span class="gi">+            x = y = None</span>
<span class="gi">+</span>
<span class="gi">+        for name, var in zip(&quot;yx&quot;, (y, x)):</span>
<span class="gi">+            if var is not None:</span>
<span class="gi">+                if name in variables:</span>
<span class="gi">+                    raise TypeError(f&quot;`{name}` given by both name and position.&quot;)</span>
<span class="gi">+                # Keep coordinates at the front of the variables dict</span>
<span class="gi">+                # Cast type because we know this isn&#39;t a DataSource at this point</span>
<span class="gi">+                variables = {name: cast(VariableSpec, var), **variables}</span>
<span class="gi">+</span>
<span class="gi">+        return data, variables</span>

<span class="w"> </span>    def __add__(self, other):
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(other, Mark) or isinstance(other, Stat):
<span class="w"> </span>            raise TypeError(&quot;Sorry, this isn&#39;t ggplot! Perhaps try Plot.add?&quot;)
<span class="gi">+</span>
<span class="w"> </span>        other_type = other.__class__.__name__
<span class="gd">-        raise TypeError(</span>
<span class="gd">-            f&quot;Unsupported operand type(s) for +: &#39;Plot&#39; and &#39;{other_type}&quot;)</span>
<span class="gi">+        raise TypeError(f&quot;Unsupported operand type(s) for +: &#39;Plot&#39; and &#39;{other_type}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_png_(self) -&gt; tuple[bytes, dict[str, float]] | None:</span>
<span class="gi">+</span>
<span class="gi">+        if Plot.config.display[&quot;format&quot;] != &quot;png&quot;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.plot()._repr_png_()</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_svg_(self) -&gt; str | None:</span>
<span class="gi">+</span>
<span class="gi">+        if Plot.config.display[&quot;format&quot;] != &quot;svg&quot;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.plot()._repr_svg_()</span>

<span class="gd">-    def _clone(self) -&gt;Plot:</span>
<span class="gi">+    def _clone(self) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a new object with the same information as the current spec.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = Plot()</span>
<span class="gi">+</span>
<span class="gi">+        # TODO any way to enforce that data does not get mutated?</span>
<span class="gi">+        new._data = self._data</span>
<span class="gi">+</span>
<span class="gi">+        new._layers.extend(self._layers)</span>
<span class="gi">+</span>
<span class="gi">+        new._scales.update(self._scales)</span>
<span class="gi">+        new._shares.update(self._shares)</span>
<span class="gi">+        new._limits.update(self._limits)</span>
<span class="gi">+        new._labels.update(self._labels)</span>
<span class="gi">+        new._theme.update(self._theme)</span>
<span class="gi">+</span>
<span class="gi">+        new._facet_spec.update(self._facet_spec)</span>
<span class="gi">+        new._pair_spec.update(self._pair_spec)</span>
<span class="gi">+</span>
<span class="gi">+        new._figure_spec.update(self._figure_spec)</span>
<span class="gi">+        new._subplot_spec.update(self._subplot_spec)</span>
<span class="gi">+        new._layout_spec.update(self._layout_spec)</span>
<span class="gi">+</span>
<span class="gi">+        new._target = self._target</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>

<span class="gd">-    def on(self, target: (Axes | SubFigure | Figure)) -&gt;Plot:</span>
<span class="gi">+    def _theme_with_defaults(self) -&gt; dict[str, Any]:</span>
<span class="gi">+</span>
<span class="gi">+        theme = self.config.theme.copy()</span>
<span class="gi">+        theme.update(self._theme)</span>
<span class="gi">+        return theme</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _variables(self) -&gt; list[str]:</span>
<span class="gi">+</span>
<span class="gi">+        variables = (</span>
<span class="gi">+            list(self._data.frame)</span>
<span class="gi">+            + list(self._pair_spec.get(&quot;variables&quot;, []))</span>
<span class="gi">+            + list(self._facet_spec.get(&quot;variables&quot;, []))</span>
<span class="gi">+        )</span>
<span class="gi">+        for layer in self._layers:</span>
<span class="gi">+            variables.extend(v for v in layer[&quot;vars&quot;] if v not in variables)</span>
<span class="gi">+</span>
<span class="gi">+        # Coerce to str in return to appease mypy; we know these will only</span>
<span class="gi">+        # ever be strings but I don&#39;t think we can type a DataFrame that way yet</span>
<span class="gi">+        return [str(v) for v in variables]</span>
<span class="gi">+</span>
<span class="gi">+    def on(self, target: Axes | SubFigure | Figure) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Provide existing Matplotlib figure or axes for drawing the plot.

<span class="gu">@@ -261,11 +461,36 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.on.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        accepted_types: tuple  # Allow tuple of various length</span>
<span class="gi">+        accepted_types = (</span>
<span class="gi">+            mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure</span>
<span class="gi">+        )</span>
<span class="gi">+        accepted_types_str = (</span>
<span class="gi">+            f&quot;{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(target, accepted_types):</span>
<span class="gi">+            err = (</span>
<span class="gi">+                f&quot;The `Plot.on` target must be an instance of {accepted_types_str}. &quot;</span>
<span class="gi">+                f&quot;You passed an instance of {target.__class__} instead.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise TypeError(err)</span>

<span class="gd">-    def add(self, mark: Mark, *transforms: (Stat | Move), orient: (str |</span>
<span class="gd">-        None)=None, legend: bool=True, label: (str | None)=None, data:</span>
<span class="gd">-        DataSource=None, **variables: VariableSpec) -&gt;Plot:</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._target = target</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self,</span>
<span class="gi">+        mark: Mark,</span>
<span class="gi">+        *transforms: Stat | Move,</span>
<span class="gi">+        orient: str | None = None,</span>
<span class="gi">+        legend: bool = True,</span>
<span class="gi">+        label: str | None = None,</span>
<span class="gi">+        data: DataSource = None,</span>
<span class="gi">+        **variables: VariableSpec,</span>
<span class="gi">+    ) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Specify a layer of the visualization in terms of mark and data transform(s).

<span class="gu">@@ -302,10 +527,60 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.add.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def pair(self, x: VariableSpecList=None, y: VariableSpecList=None, wrap:</span>
<span class="gd">-        (int | None)=None, cross: bool=True) -&gt;Plot:</span>
<span class="gi">+        if not isinstance(mark, Mark):</span>
<span class="gi">+            msg = f&quot;mark must be a Mark instance, not {type(mark)!r}.&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO This API for transforms was a late decision, and previously Plot.add</span>
<span class="gi">+        # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.</span>
<span class="gi">+        # It will take some work to refactor the internals so that Stat and Move are</span>
<span class="gi">+        # treated identically, and until then well need to &quot;unpack&quot; the transforms</span>
<span class="gi">+        # here and enforce limitations on the order / types.</span>
<span class="gi">+</span>
<span class="gi">+        stat: Optional[Stat]</span>
<span class="gi">+        move: Optional[List[Move]]</span>
<span class="gi">+        error = False</span>
<span class="gi">+        if not transforms:</span>
<span class="gi">+            stat, move = None, None</span>
<span class="gi">+        elif isinstance(transforms[0], Stat):</span>
<span class="gi">+            stat = transforms[0]</span>
<span class="gi">+            move = [m for m in transforms[1:] if isinstance(m, Move)]</span>
<span class="gi">+            error = len(move) != len(transforms) - 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            stat = None</span>
<span class="gi">+            move = [m for m in transforms if isinstance(m, Move)]</span>
<span class="gi">+            error = len(move) != len(transforms)</span>
<span class="gi">+</span>
<span class="gi">+        if error:</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                &quot;Transforms must have at most one Stat type (in the first position),&quot;,</span>
<span class="gi">+                &quot;and all others must be a Move type. Given transform type(s):&quot;,</span>
<span class="gi">+                &quot;, &quot;.join(str(type(t).__name__) for t in transforms) + &quot;.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._layers.append({</span>
<span class="gi">+            &quot;mark&quot;: mark,</span>
<span class="gi">+            &quot;stat&quot;: stat,</span>
<span class="gi">+            &quot;move&quot;: move,</span>
<span class="gi">+            # TODO it doesn&#39;t work to supply scalars to variables, but it should</span>
<span class="gi">+            &quot;vars&quot;: variables,</span>
<span class="gi">+            &quot;source&quot;: data,</span>
<span class="gi">+            &quot;legend&quot;: legend,</span>
<span class="gi">+            &quot;label&quot;: label,</span>
<span class="gi">+            &quot;orient&quot;: {&quot;v&quot;: &quot;x&quot;, &quot;h&quot;: &quot;y&quot;}.get(orient, orient),  # type: ignore</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def pair(</span>
<span class="gi">+        self,</span>
<span class="gi">+        x: VariableSpecList = None,</span>
<span class="gi">+        y: VariableSpecList = None,</span>
<span class="gi">+        wrap: int | None = None,</span>
<span class="gi">+        cross: bool = True,</span>
<span class="gi">+    ) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Produce subplots by pairing multiple `x` and/or `y` variables.

<span class="gu">@@ -326,11 +601,49 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.pair.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def facet(self, col: VariableSpec=None, row: VariableSpec=None, order:</span>
<span class="gd">-        (OrderSpec | dict[str, OrderSpec])=None, wrap: (int | None)=None</span>
<span class="gd">-        ) -&gt;Plot:</span>
<span class="gi">+        # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows</span>
<span class="gi">+        # This may also be possible by setting `wrap=1`, but is that too unobvious?</span>
<span class="gi">+        # TODO PairGrid features not currently implemented: diagonals, corner</span>
<span class="gi">+</span>
<span class="gi">+        pair_spec: PairSpec = {}</span>
<span class="gi">+</span>
<span class="gi">+        axes = {&quot;x&quot;: [] if x is None else x, &quot;y&quot;: [] if y is None else y}</span>
<span class="gi">+        for axis, arg in axes.items():</span>
<span class="gi">+            if isinstance(arg, (str, int)):</span>
<span class="gi">+                err = f&quot;You must pass a sequence of variable keys to `{axis}`&quot;</span>
<span class="gi">+                raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        pair_spec[&quot;variables&quot;] = {}</span>
<span class="gi">+        pair_spec[&quot;structure&quot;] = {}</span>
<span class="gi">+</span>
<span class="gi">+        for axis in &quot;xy&quot;:</span>
<span class="gi">+            keys = []</span>
<span class="gi">+            for i, col in enumerate(axes[axis]):</span>
<span class="gi">+                key = f&quot;{axis}{i}&quot;</span>
<span class="gi">+                keys.append(key)</span>
<span class="gi">+                pair_spec[&quot;variables&quot;][key] = col</span>
<span class="gi">+</span>
<span class="gi">+            if keys:</span>
<span class="gi">+                pair_spec[&quot;structure&quot;][axis] = keys</span>
<span class="gi">+</span>
<span class="gi">+        if not cross and len(axes[&quot;x&quot;]) != len(axes[&quot;y&quot;]):</span>
<span class="gi">+            err = &quot;Lengths of the `x` and `y` lists must match with cross=False&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+        pair_spec[&quot;cross&quot;] = cross</span>
<span class="gi">+        pair_spec[&quot;wrap&quot;] = wrap</span>
<span class="gi">+</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._pair_spec.update(pair_spec)</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def facet(</span>
<span class="gi">+        self,</span>
<span class="gi">+        col: VariableSpec = None,</span>
<span class="gi">+        row: VariableSpec = None,</span>
<span class="gi">+        order: OrderSpec | dict[str, OrderSpec] = None,</span>
<span class="gi">+        wrap: int | None = None,</span>
<span class="gi">+    ) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Produce subplots with conditional subsets of the data.

<span class="gu">@@ -350,9 +663,44 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.facet.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def scale(self, **scales: Scale) -&gt;Plot:</span>
<span class="gi">+        variables: dict[str, VariableSpec] = {}</span>
<span class="gi">+        if col is not None:</span>
<span class="gi">+            variables[&quot;col&quot;] = col</span>
<span class="gi">+        if row is not None:</span>
<span class="gi">+            variables[&quot;row&quot;] = row</span>
<span class="gi">+</span>
<span class="gi">+        structure = {}</span>
<span class="gi">+        if isinstance(order, dict):</span>
<span class="gi">+            for dim in [&quot;col&quot;, &quot;row&quot;]:</span>
<span class="gi">+                dim_order = order.get(dim)</span>
<span class="gi">+                if dim_order is not None:</span>
<span class="gi">+                    structure[dim] = list(dim_order)</span>
<span class="gi">+        elif order is not None:</span>
<span class="gi">+            if col is not None and row is not None:</span>
<span class="gi">+                err = &quot; &quot;.join([</span>
<span class="gi">+                    &quot;When faceting on both col= and row=, passing `order` as a list&quot;</span>
<span class="gi">+                    &quot;is ambiguous. Use a dict with &#39;col&#39; and/or &#39;row&#39; keys instead.&quot;</span>
<span class="gi">+                ])</span>
<span class="gi">+                raise RuntimeError(err)</span>
<span class="gi">+            elif col is not None:</span>
<span class="gi">+                structure[&quot;col&quot;] = list(order)</span>
<span class="gi">+            elif row is not None:</span>
<span class="gi">+                structure[&quot;row&quot;] = list(order)</span>
<span class="gi">+</span>
<span class="gi">+        spec: FacetSpec = {</span>
<span class="gi">+            &quot;variables&quot;: variables,</span>
<span class="gi">+            &quot;structure&quot;: structure,</span>
<span class="gi">+            &quot;wrap&quot;: wrap,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._facet_spec.update(spec)</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    # TODO def twin()?</span>
<span class="gi">+</span>
<span class="gi">+    def scale(self, **scales: Scale) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Specify mappings from data units to visual properties.

<span class="gu">@@ -375,9 +723,11 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.scale.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._scales.update(scales)</span>
<span class="gi">+        return new</span>

<span class="gd">-    def share(self, **shares: (bool | str)) -&gt;Plot:</span>
<span class="gi">+    def share(self, **shares: bool | str) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Control sharing of axis limits and ticks across subplots.

<span class="gu">@@ -392,9 +742,11 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.share.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._shares.update(shares)</span>
<span class="gi">+        return new</span>

<span class="gd">-    def limit(self, **limits: tuple[Any, Any]) -&gt;Plot:</span>
<span class="gi">+    def limit(self, **limits: tuple[Any, Any]) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Control the range of visible data.

<span class="gu">@@ -411,10 +763,16 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.limit.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def label(self, *, title: (str | None)=None, legend: (str | None)=None,</span>
<span class="gd">-        **variables: (str | Callable[[str], str])) -&gt;Plot:</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        new._limits.update(limits)</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def label(</span>
<span class="gi">+        self, *,</span>
<span class="gi">+        title: str | None = None,</span>
<span class="gi">+        legend: str | None = None,</span>
<span class="gi">+        **variables: str | Callable[[str], str]</span>
<span class="gi">+    ) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Control the labels and titles for axes, legends, and subplots.

<span class="gu">@@ -440,11 +798,21 @@ class Plot:</span>


<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def layout(self, *, size: (tuple[float, float] | Default)=default,</span>
<span class="gd">-        engine: (str | None | Default)=default, extent: (tuple[float, float,</span>
<span class="gd">-        float, float] | Default)=default) -&gt;Plot:</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+        if title is not None:</span>
<span class="gi">+            new._labels[&quot;title&quot;] = title</span>
<span class="gi">+        if legend is not None:</span>
<span class="gi">+            new._labels[&quot;legend&quot;] = legend</span>
<span class="gi">+        new._labels.update(variables)</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def layout(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        size: tuple[float, float] | Default = default,</span>
<span class="gi">+        engine: str | None | Default = default,</span>
<span class="gi">+        extent: tuple[float, float, float, float] | Default = default,</span>
<span class="gi">+    ) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Control the figure size and layout.

<span class="gu">@@ -473,9 +841,25 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.layout.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO add an &quot;auto&quot; mode for figsize that roughly scales with the rcParams</span>
<span class="gi">+        # figsize (so that works), but expands to prevent subplots from being squished</span>
<span class="gi">+        # Also should we have height=, aspect=, exclusive with figsize? Or working</span>
<span class="gi">+        # with figsize when only one is defined?</span>
<span class="gi">+</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+</span>
<span class="gi">+        if size is not default:</span>
<span class="gi">+            new._figure_spec[&quot;figsize&quot;] = size</span>
<span class="gi">+        if engine is not default:</span>
<span class="gi">+            new._layout_spec[&quot;engine&quot;] = engine</span>
<span class="gi">+        if extent is not default:</span>
<span class="gi">+            new._layout_spec[&quot;extent&quot;] = extent</span>

<span class="gd">-    def theme(self, config: dict[str, Any], /) -&gt;Plot:</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    # TODO def legend (ugh)</span>
<span class="gi">+</span>
<span class="gi">+    def theme(self, config: dict[str, Any], /) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Control the appearance of elements in the plot.

<span class="gu">@@ -495,9 +879,14 @@ class Plot:</span>
<span class="w"> </span>        .. include:: ../docstrings/objects.Plot.theme.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = self._clone()</span>
<span class="gi">+</span>
<span class="gi">+        rc = mpl.RcParams(config)</span>
<span class="gi">+        new._theme.update(rc)</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>

<span class="gd">-    def save(self, loc, **kwargs) -&gt;Plot:</span>
<span class="gi">+    def save(self, loc, **kwargs) -&gt; Plot:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Compile the plot and write it to a buffer or file on disk.

<span class="gu">@@ -510,9 +899,12 @@ class Plot:</span>
<span class="w"> </span>            :meth:`matplotlib.figure.Figure.savefig`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO expose important keyword arguments in our signature?</span>
<span class="gi">+        with theme_context(self._theme_with_defaults()):</span>
<span class="gi">+            self._plot().save(loc, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def show(self, **kwargs) -&gt;None:</span>
<span class="gi">+    def show(self, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Compile the plot and display it by hooking into pyplot.

<span class="gu">@@ -524,13 +916,59 @@ class Plot:</span>
<span class="w"> </span>        the last method you call when specifying a plot.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO make pyplot configurable at the class level, and when not using,</span>
<span class="gi">+        # import IPython.display and call on self to populate cell output?</span>

<span class="gd">-    def plot(self, pyplot: bool=False) -&gt;Plotter:</span>
<span class="gi">+        # Keep an eye on whether matplotlib implements &quot;attaching&quot; an existing</span>
<span class="gi">+        # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024</span>
<span class="gi">+</span>
<span class="gi">+        self.plot(pyplot=True).show(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def plot(self, pyplot: bool = False) -&gt; Plotter:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Compile the plot spec and return the Plotter object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with theme_context(self._theme_with_defaults()):</span>
<span class="gi">+            return self._plot(pyplot)</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, pyplot: bool = False) -&gt; Plotter:</span>
<span class="gi">+</span>
<span class="gi">+        # TODO if we have _target object, pyplot should be determined by whether it</span>
<span class="gi">+        # is hooked into the pyplot state machine (how do we check?)</span>
<span class="gi">+</span>
<span class="gi">+        plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())</span>
<span class="gi">+</span>
<span class="gi">+        # Process the variable assignments and initialize the figure</span>
<span class="gi">+        common, layers = plotter._extract_data(self)</span>
<span class="gi">+        plotter._setup_figure(self, common, layers)</span>
<span class="gi">+</span>
<span class="gi">+        # Process the scale spec for coordinate variables and transform their data</span>
<span class="gi">+        coord_vars = [v for v in self._variables if re.match(r&quot;^x|y&quot;, v)]</span>
<span class="gi">+        plotter._setup_scales(self, common, layers, coord_vars)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply statistical transform(s)</span>
<span class="gi">+        plotter._compute_stats(self, layers)</span>
<span class="gi">+</span>
<span class="gi">+        # Process scale spec for semantic variables and coordinates computed by stat</span>
<span class="gi">+        plotter._setup_scales(self, common, layers)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO Remove these after updating other methods</span>
<span class="gi">+        # ---- Maybe have debug= param that attaches these when True?</span>
<span class="gi">+        plotter._data = common</span>
<span class="gi">+        plotter._layers = layers</span>
<span class="gi">+</span>
<span class="gi">+        # Process the data for each layer and add matplotlib artists</span>
<span class="gi">+        for layer in layers:</span>
<span class="gi">+            plotter._plot_layer(self, layer)</span>
<span class="gi">+</span>
<span class="gi">+        # Add various figure decorations</span>
<span class="gi">+        plotter._make_legend(self)</span>
<span class="gi">+        plotter._finalize_figure(self)</span>
<span class="gi">+</span>
<span class="gi">+        return plotter</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ---- The plot compilation engine ---------------------------------------------- #</span>


<span class="w"> </span>class Plotter:
<span class="gu">@@ -540,31 +978,853 @@ class Plotter:</span>
<span class="w"> </span>    This class is not intended to be instantiated directly by users.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # TODO decide if we ever want these (Plot.plot(debug=True))?</span>
<span class="w"> </span>    _data: PlotData
<span class="w"> </span>    _layers: list[Layer]
<span class="w"> </span>    _figure: Figure

<span class="w"> </span>    def __init__(self, pyplot: bool, theme: dict[str, Any]):
<span class="gi">+</span>
<span class="w"> </span>        self._pyplot = pyplot
<span class="w"> </span>        self._theme = theme
<span class="gd">-        self._legend_contents: list[tuple[tuple[str, str | int], list[</span>
<span class="gd">-            Artist], list[str]]] = []</span>
<span class="gi">+        self._legend_contents: list[tuple[</span>
<span class="gi">+            tuple[str, str | int], list[Artist], list[str],</span>
<span class="gi">+        ]] = []</span>
<span class="w"> </span>        self._scales: dict[str, Scale] = {}

<span class="gd">-    def show(self, **kwargs) -&gt;None:</span>
<span class="gi">+    def save(self, loc, **kwargs) -&gt; Plotter:  # TODO type args</span>
<span class="gi">+        kwargs.setdefault(&quot;dpi&quot;, 96)</span>
<span class="gi">+        try:</span>
<span class="gi">+            loc = os.path.expanduser(loc)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # loc may be a buffer in which case that would not work</span>
<span class="gi">+            pass</span>
<span class="gi">+        self._figure.savefig(loc, **kwargs)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def show(self, **kwargs) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Display the plot by hooking into pyplot.

<span class="w"> </span>        This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO if we did not create the Plotter with pyplot, is it possible to do this?</span>
<span class="gi">+        # If not we should clearly raise.</span>
<span class="gi">+        import matplotlib.pyplot as plt</span>
<span class="gi">+        with theme_context(self._theme):</span>
<span class="gi">+            plt.show(**kwargs)</span>

<span class="gd">-    def _update_legend_contents(self, p: Plot, mark: Mark, data: PlotData,</span>
<span class="gd">-        scales: dict[str, Scale], layer_label: (str | None)) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Add legend artists / labels for one layer in the plot.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    # TODO API for accessing the underlying matplotlib objects</span>
<span class="gi">+    # TODO what else is useful in the public API for this class?</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_png_(self) -&gt; tuple[bytes, dict[str, float]] | None:</span>
<span class="gi">+</span>
<span class="gi">+        # TODO use matplotlib backend directly instead of going through savefig?</span>
<span class="gi">+</span>
<span class="gi">+        # TODO perhaps have self.show() flip a switch to disable this, so that</span>
<span class="gi">+        # user does not end up with two versions of the figure in the output</span>
<span class="gi">+</span>
<span class="gi">+        # TODO use bbox_inches=&quot;tight&quot; like the inline backend?</span>
<span class="gi">+        # pro: better results,  con: (sometimes) confusing results</span>
<span class="gi">+        # Better solution would be to default (with option to change)</span>
<span class="gi">+        # to using constrained/tight layout.</span>
<span class="gi">+</span>
<span class="gi">+        if Plot.config.display[&quot;format&quot;] != &quot;png&quot;:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        buffer = io.BytesIO()</span>
<span class="gi">+</span>
<span class="gi">+        factor = 2 if Plot.config.display[&quot;hidpi&quot;] else 1</span>
<span class="gi">+        scaling = Plot.config.display[&quot;scaling&quot;] / factor</span>
<span class="gi">+        dpi = 96 * factor  # TODO put dpi in Plot.config?</span>
<span class="gi">+</span>
<span class="gi">+        with theme_context(self._theme):  # TODO _theme_with_defaults?</span>
<span class="gi">+            self._figure.savefig(buffer, dpi=dpi, format=&quot;png&quot;, bbox_inches=&quot;tight&quot;)</span>
<span class="gi">+        data = buffer.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+        w, h = Image.open(buffer).size</span>
<span class="gi">+        metadata = {&quot;width&quot;: w * scaling, &quot;height&quot;: h * scaling}</span>
<span class="gi">+        return data, metadata</span>

<span class="gd">-    def _make_legend(self, p: Plot) -&gt;None:</span>
<span class="gi">+    def _repr_svg_(self) -&gt; str | None:</span>
<span class="gi">+</span>
<span class="gi">+        if Plot.config.display[&quot;format&quot;] != &quot;svg&quot;:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # TODO DPI for rasterized artists?</span>
<span class="gi">+</span>
<span class="gi">+        scaling = Plot.config.display[&quot;scaling&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        buffer = io.StringIO()</span>
<span class="gi">+        with theme_context(self._theme):  # TODO _theme_with_defaults?</span>
<span class="gi">+            self._figure.savefig(buffer, format=&quot;svg&quot;, bbox_inches=&quot;tight&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        root = ElementTree.fromstring(buffer.getvalue())</span>
<span class="gi">+        w = scaling * float(root.attrib[&quot;width&quot;][:-2])</span>
<span class="gi">+        h = scaling * float(root.attrib[&quot;height&quot;][:-2])</span>
<span class="gi">+        root.attrib.update(width=f&quot;{w}pt&quot;, height=f&quot;{h}pt&quot;, viewbox=f&quot;0 0 {w} {h}&quot;)</span>
<span class="gi">+        ElementTree.ElementTree(root).write(out := io.BytesIO())</span>
<span class="gi">+</span>
<span class="gi">+        return out.getvalue().decode()</span>
<span class="gi">+</span>
<span class="gi">+    def _extract_data(self, p: Plot) -&gt; tuple[PlotData, list[Layer]]:</span>
<span class="gi">+</span>
<span class="gi">+        common_data = (</span>
<span class="gi">+            p._data</span>
<span class="gi">+            .join(None, p._facet_spec.get(&quot;variables&quot;))</span>
<span class="gi">+            .join(None, p._pair_spec.get(&quot;variables&quot;))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        layers: list[Layer] = []</span>
<span class="gi">+        for layer in p._layers:</span>
<span class="gi">+            spec = layer.copy()</span>
<span class="gi">+            spec[&quot;data&quot;] = common_data.join(layer.get(&quot;source&quot;), layer.get(&quot;vars&quot;))</span>
<span class="gi">+            layers.append(spec)</span>
<span class="gi">+</span>
<span class="gi">+        return common_data, layers</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -&gt; str:</span>
<span class="gi">+</span>
<span class="gi">+        if re.match(r&quot;[xy]\d+&quot;, var):</span>
<span class="gi">+            key = var if var in p._labels else var[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = var</span>
<span class="gi">+</span>
<span class="gi">+        label: str</span>
<span class="gi">+        if key in p._labels:</span>
<span class="gi">+            manual_label = p._labels[key]</span>
<span class="gi">+            if callable(manual_label) and auto_label is not None:</span>
<span class="gi">+                label = manual_label(auto_label)</span>
<span class="gi">+            else:</span>
<span class="gi">+                label = cast(str, manual_label)</span>
<span class="gi">+        elif auto_label is None:</span>
<span class="gi">+            label = &quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            label = auto_label</span>
<span class="gi">+        return label</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        # --- Parsing the faceting/pairing parameterization to specify figure grid</span>
<span class="gi">+</span>
<span class="gi">+        subplot_spec = p._subplot_spec.copy()</span>
<span class="gi">+        facet_spec = p._facet_spec.copy()</span>
<span class="gi">+        pair_spec = p._pair_spec.copy()</span>
<span class="gi">+</span>
<span class="gi">+        for axis in &quot;xy&quot;:</span>
<span class="gi">+            if axis in p._shares:</span>
<span class="gi">+                subplot_spec[f&quot;share{axis}&quot;] = p._shares[axis]</span>
<span class="gi">+</span>
<span class="gi">+        for dim in [&quot;col&quot;, &quot;row&quot;]:</span>
<span class="gi">+            if dim in common.frame and dim not in facet_spec[&quot;structure&quot;]:</span>
<span class="gi">+                order = categorical_order(common.frame[dim])</span>
<span class="gi">+                facet_spec[&quot;structure&quot;][dim] = order</span>
<span class="gi">+</span>
<span class="gi">+        self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)</span>
<span class="gi">+</span>
<span class="gi">+        # --- Figure initialization</span>
<span class="gi">+        self._figure = subplots.init_figure(</span>
<span class="gi">+            pair_spec, self._pyplot, p._figure_spec, p._target,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # --- Figure annotation</span>
<span class="gi">+        for sub in subplots:</span>
<span class="gi">+            ax = sub[&quot;ax&quot;]</span>
<span class="gi">+            for axis in &quot;xy&quot;:</span>
<span class="gi">+                axis_key = sub[axis]</span>
<span class="gi">+</span>
<span class="gi">+                # ~~ Axis labels</span>
<span class="gi">+</span>
<span class="gi">+                # TODO Should we make it possible to use only one x/y label for</span>
<span class="gi">+                # all rows/columns in a faceted plot? Maybe using sub{axis}label,</span>
<span class="gi">+                # although the alignments of the labels from that method leaves</span>
<span class="gi">+                # something to be desired (in terms of how it defines &#39;centered&#39;).</span>
<span class="gi">+                names = [</span>
<span class="gi">+                    common.names.get(axis_key),</span>
<span class="gi">+                    *(layer[&quot;data&quot;].names.get(axis_key) for layer in layers)</span>
<span class="gi">+                ]</span>
<span class="gi">+                auto_label = next((name for name in names if name is not None), None)</span>
<span class="gi">+                label = self._resolve_label(p, axis_key, auto_label)</span>
<span class="gi">+                ax.set(**{f&quot;{axis}label&quot;: label})</span>
<span class="gi">+</span>
<span class="gi">+                # ~~ Decoration visibility</span>
<span class="gi">+</span>
<span class="gi">+                # TODO there should be some override (in Plot.layout?) so that</span>
<span class="gi">+                # axis / tick labels can be shown on interior shared axes if desired</span>
<span class="gi">+</span>
<span class="gi">+                axis_obj = getattr(ax, f&quot;{axis}axis&quot;)</span>
<span class="gi">+                visible_side = {&quot;x&quot;: &quot;bottom&quot;, &quot;y&quot;: &quot;left&quot;}.get(axis)</span>
<span class="gi">+                show_axis_label = (</span>
<span class="gi">+                    sub[visible_side]</span>
<span class="gi">+                    or not p._pair_spec.get(&quot;cross&quot;, True)</span>
<span class="gi">+                    or (</span>
<span class="gi">+                        axis in p._pair_spec.get(&quot;structure&quot;, {})</span>
<span class="gi">+                        and bool(p._pair_spec.get(&quot;wrap&quot;))</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                axis_obj.get_label().set_visible(show_axis_label)</span>
<span class="gi">+</span>
<span class="gi">+                show_tick_labels = (</span>
<span class="gi">+                    show_axis_label</span>
<span class="gi">+                    or subplot_spec.get(f&quot;share{axis}&quot;) not in (</span>
<span class="gi">+                        True, &quot;all&quot;, {&quot;x&quot;: &quot;col&quot;, &quot;y&quot;: &quot;row&quot;}[axis]</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                for group in (&quot;major&quot;, &quot;minor&quot;):</span>
<span class="gi">+                    side = {&quot;x&quot;: &quot;bottom&quot;, &quot;y&quot;: &quot;left&quot;}[axis]</span>
<span class="gi">+                    axis_obj.set_tick_params(**{f&quot;label{side}&quot;: show_tick_labels})</span>
<span class="gi">+                    for t in getattr(axis_obj, f&quot;get_{group}ticklabels&quot;)():</span>
<span class="gi">+                        t.set_visible(show_tick_labels)</span>
<span class="gi">+</span>
<span class="gi">+            # TODO we want right-side titles for row facets in most cases?</span>
<span class="gi">+            # Let&#39;s have what we currently call &quot;margin titles&quot; but properly using the</span>
<span class="gi">+            # ax.set_title interface (see my gist)</span>
<span class="gi">+            title_parts = []</span>
<span class="gi">+            for dim in [&quot;col&quot;, &quot;row&quot;]:</span>
<span class="gi">+                if sub[dim] is not None:</span>
<span class="gi">+                    val = self._resolve_label(p, &quot;title&quot;, f&quot;{sub[dim]}&quot;)</span>
<span class="gi">+                    if dim in p._labels:</span>
<span class="gi">+                        key = self._resolve_label(p, dim, common.names.get(dim))</span>
<span class="gi">+                        val = f&quot;{key} {val}&quot;</span>
<span class="gi">+                    title_parts.append(val)</span>
<span class="gi">+</span>
<span class="gi">+            has_col = sub[&quot;col&quot;] is not None</span>
<span class="gi">+            has_row = sub[&quot;row&quot;] is not None</span>
<span class="gi">+            show_title = (</span>
<span class="gi">+                has_col and has_row</span>
<span class="gi">+                or (has_col or has_row) and p._facet_spec.get(&quot;wrap&quot;)</span>
<span class="gi">+                or (has_col and sub[&quot;top&quot;])</span>
<span class="gi">+                # TODO or has_row and sub[&quot;right&quot;] and &lt;right titles&gt;</span>
<span class="gi">+                or has_row  # TODO and not &lt;right titles&gt;</span>
<span class="gi">+            )</span>
<span class="gi">+            if title_parts:</span>
<span class="gi">+                title = &quot; | &quot;.join(title_parts)</span>
<span class="gi">+                title_text = ax.set_title(title)</span>
<span class="gi">+                title_text.set_visible(show_title)</span>
<span class="gi">+            elif not (has_col or has_row):</span>
<span class="gi">+                title = self._resolve_label(p, &quot;title&quot;, None)</span>
<span class="gi">+                title_text = ax.set_title(title)</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_stats(self, spec: Plot, layers: list[Layer]) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        grouping_vars = [v for v in PROPERTIES if v not in &quot;xy&quot;]</span>
<span class="gi">+        grouping_vars += [&quot;col&quot;, &quot;row&quot;, &quot;group&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        pair_vars = spec._pair_spec.get(&quot;structure&quot;, {})</span>
<span class="gi">+</span>
<span class="gi">+        for layer in layers:</span>
<span class="gi">+</span>
<span class="gi">+            data = layer[&quot;data&quot;]</span>
<span class="gi">+            mark = layer[&quot;mark&quot;]</span>
<span class="gi">+            stat = layer[&quot;stat&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            if stat is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            iter_axes = itertools.product(*[</span>
<span class="gi">+                pair_vars.get(axis, [axis]) for axis in &quot;xy&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="gi">+            old = data.frame</span>
<span class="gi">+</span>
<span class="gi">+            if pair_vars:</span>
<span class="gi">+                data.frames = {}</span>
<span class="gi">+                data.frame = data.frame.iloc[:0]  # TODO to simplify typing</span>
<span class="gi">+</span>
<span class="gi">+            for coord_vars in iter_axes:</span>
<span class="gi">+</span>
<span class="gi">+                pairings = &quot;xy&quot;, coord_vars</span>
<span class="gi">+</span>
<span class="gi">+                df = old.copy()</span>
<span class="gi">+                scales = self._scales.copy()</span>
<span class="gi">+</span>
<span class="gi">+                for axis, var in zip(*pairings):</span>
<span class="gi">+                    if axis != var:</span>
<span class="gi">+                        df = df.rename(columns={var: axis})</span>
<span class="gi">+                        drop_cols = [x for x in df if re.match(rf&quot;{axis}\d+&quot;, str(x))]</span>
<span class="gi">+                        df = df.drop(drop_cols, axis=1)</span>
<span class="gi">+                        scales[axis] = scales[var]</span>
<span class="gi">+</span>
<span class="gi">+                orient = layer[&quot;orient&quot;] or mark._infer_orient(scales)</span>
<span class="gi">+</span>
<span class="gi">+                if stat.group_by_orient:</span>
<span class="gi">+                    grouper = [orient, *grouping_vars]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    grouper = grouping_vars</span>
<span class="gi">+                groupby = GroupBy(grouper)</span>
<span class="gi">+                res = stat(df, groupby, orient, scales)</span>
<span class="gi">+</span>
<span class="gi">+                if pair_vars:</span>
<span class="gi">+                    data.frames[coord_vars] = res</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data.frame = res</span>
<span class="gi">+</span>
<span class="gi">+    def _get_scale(</span>
<span class="gi">+        self, p: Plot, var: str, prop: Property, values: Series</span>
<span class="gi">+    ) -&gt; Scale:</span>
<span class="gi">+</span>
<span class="gi">+        if re.match(r&quot;[xy]\d+&quot;, var):</span>
<span class="gi">+            key = var if var in p._scales else var[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = var</span>
<span class="gi">+</span>
<span class="gi">+        if key in p._scales:</span>
<span class="gi">+            arg = p._scales[key]</span>
<span class="gi">+            if arg is None or isinstance(arg, Scale):</span>
<span class="gi">+                scale = arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                scale = prop.infer_scale(arg, values)</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = prop.default_scale(values)</span>
<span class="gi">+</span>
<span class="gi">+        return scale</span>
<span class="gi">+</span>
<span class="gi">+    def _get_subplot_data(self, df, var, view, share_state):</span>
<span class="gi">+</span>
<span class="gi">+        if share_state in [True, &quot;all&quot;]:</span>
<span class="gi">+            # The all-shared case is easiest, every subplot sees all the data</span>
<span class="gi">+            seed_values = df[var]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, we need to setup separate scales for different subplots</span>
<span class="gi">+            if share_state in [False, &quot;none&quot;]:</span>
<span class="gi">+                # Fully independent axes are also easy: use each subplot&#39;s data</span>
<span class="gi">+                idx = self._get_subplot_index(df, view)</span>
<span class="gi">+            elif share_state in df:</span>
<span class="gi">+                # Sharing within row/col is more complicated</span>
<span class="gi">+                use_rows = df[share_state] == view[share_state]</span>
<span class="gi">+                idx = df.index[use_rows]</span>
<span class="gi">+            else:</span>
<span class="gi">+                # This configuration doesn&#39;t make much sense, but it&#39;s fine</span>
<span class="gi">+                idx = df.index</span>
<span class="gi">+</span>
<span class="gi">+            seed_values = df.loc[idx, var]</span>
<span class="gi">+</span>
<span class="gi">+        return seed_values</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_scales(</span>
<span class="gi">+        self,</span>
<span class="gi">+        p: Plot,</span>
<span class="gi">+        common: PlotData,</span>
<span class="gi">+        layers: list[Layer],</span>
<span class="gi">+        variables: list[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        if variables is None:</span>
<span class="gi">+            # Add variables that have data but not a scale, which happens</span>
<span class="gi">+            # because this method can be called multiple time, to handle</span>
<span class="gi">+            # variables added during the Stat transform.</span>
<span class="gi">+            variables = []</span>
<span class="gi">+            for layer in layers:</span>
<span class="gi">+                variables.extend(layer[&quot;data&quot;].frame.columns)</span>
<span class="gi">+                for df in layer[&quot;data&quot;].frames.values():</span>
<span class="gi">+                    variables.extend(str(v) for v in df if v not in variables)</span>
<span class="gi">+            variables = [v for v in variables if v not in self._scales]</span>
<span class="gi">+</span>
<span class="gi">+        for var in variables:</span>
<span class="gi">+</span>
<span class="gi">+            # Determine whether this is a coordinate variable</span>
<span class="gi">+            # (i.e., x/y, paired x/y, or derivative such as xmax)</span>
<span class="gi">+            m = re.match(r&quot;^(?P&lt;coord&gt;(?P&lt;axis&gt;x|y)\d*).*&quot;, var)</span>
<span class="gi">+            if m is None:</span>
<span class="gi">+                coord = axis = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                coord = m[&quot;coord&quot;]</span>
<span class="gi">+                axis = m[&quot;axis&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            # Get keys that handle things like x0, xmax, properly where relevant</span>
<span class="gi">+            prop_key = var if axis is None else axis</span>
<span class="gi">+            scale_key = var if coord is None else coord</span>
<span class="gi">+</span>
<span class="gi">+            if prop_key not in PROPERTIES:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Concatenate layers, using only the relevant coordinate and faceting vars,</span>
<span class="gi">+            # This is unnecessarily wasteful, as layer data will often be redundant.</span>
<span class="gi">+            # But figuring out the minimal amount we need is more complicated.</span>
<span class="gi">+            cols = [var, &quot;col&quot;, &quot;row&quot;]</span>
<span class="gi">+            parts = [common.frame.filter(cols)]</span>
<span class="gi">+            for layer in layers:</span>
<span class="gi">+                parts.append(layer[&quot;data&quot;].frame.filter(cols))</span>
<span class="gi">+                for df in layer[&quot;data&quot;].frames.values():</span>
<span class="gi">+                    parts.append(df.filter(cols))</span>
<span class="gi">+            var_df = pd.concat(parts, ignore_index=True)</span>
<span class="gi">+</span>
<span class="gi">+            prop = PROPERTIES[prop_key]</span>
<span class="gi">+            scale = self._get_scale(p, scale_key, prop, var_df[var])</span>
<span class="gi">+</span>
<span class="gi">+            if scale_key not in p._variables:</span>
<span class="gi">+                # TODO this implies that the variable was added by the stat</span>
<span class="gi">+                # It allows downstream orientation inference to work properly.</span>
<span class="gi">+                # But it feels rather hacky, so ideally revisit.</span>
<span class="gi">+                scale._priority = 0  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if axis is None:</span>
<span class="gi">+                # We could think about having a broader concept of (un)shared properties</span>
<span class="gi">+                # In general, not something you want to do (different scales in facets)</span>
<span class="gi">+                # But could make sense e.g. with paired plots. Build later.</span>
<span class="gi">+                share_state = None</span>
<span class="gi">+                subplots = []</span>
<span class="gi">+            else:</span>
<span class="gi">+                share_state = self._subplots.subplot_spec[f&quot;share{axis}&quot;]</span>
<span class="gi">+                subplots = [view for view in self._subplots if view[axis] == coord]</span>
<span class="gi">+</span>
<span class="gi">+            if scale is None:</span>
<span class="gi">+                self._scales[var] = Scale._identity()</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._scales[var] = scale._setup(var_df[var], prop)</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    raise PlotSpecError._during(&quot;Scale setup&quot;, var) from err</span>
<span class="gi">+</span>
<span class="gi">+            if axis is None or (var != coord and coord in p._variables):</span>
<span class="gi">+                # Everything below here applies only to coordinate variables</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Set up an empty series to receive the transformed values.</span>
<span class="gi">+            # We need this to handle piecemeal transforms of categories -&gt; floats.</span>
<span class="gi">+            transformed_data = []</span>
<span class="gi">+            for layer in layers:</span>
<span class="gi">+                index = layer[&quot;data&quot;].frame.index</span>
<span class="gi">+                empty_series = pd.Series(dtype=float, index=index, name=var)</span>
<span class="gi">+                transformed_data.append(empty_series)</span>
<span class="gi">+</span>
<span class="gi">+            for view in subplots:</span>
<span class="gi">+</span>
<span class="gi">+                axis_obj = getattr(view[&quot;ax&quot;], f&quot;{axis}axis&quot;)</span>
<span class="gi">+                seed_values = self._get_subplot_data(var_df, var, view, share_state)</span>
<span class="gi">+                view_scale = scale._setup(seed_values, prop, axis=axis_obj)</span>
<span class="gi">+                view[&quot;ax&quot;].set(**{f&quot;{axis}scale&quot;: view_scale._matplotlib_scale})</span>
<span class="gi">+</span>
<span class="gi">+                for layer, new_series in zip(layers, transformed_data):</span>
<span class="gi">+                    layer_df = layer[&quot;data&quot;].frame</span>
<span class="gi">+                    if var not in layer_df:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    idx = self._get_subplot_index(layer_df, view)</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        new_series.loc[idx] = view_scale(layer_df.loc[idx, var])</span>
<span class="gi">+                    except Exception as err:</span>
<span class="gi">+                        spec_error = PlotSpecError._during(&quot;Scaling operation&quot;, var)</span>
<span class="gi">+                        raise spec_error from err</span>
<span class="gi">+</span>
<span class="gi">+            # Now the transformed data series are complete, update the layer data</span>
<span class="gi">+            for layer, new_series in zip(layers, transformed_data):</span>
<span class="gi">+                layer_df = layer[&quot;data&quot;].frame</span>
<span class="gi">+                if var in layer_df:</span>
<span class="gi">+                    layer_df[var] = pd.to_numeric(new_series)</span>
<span class="gi">+</span>
<span class="gi">+    def _plot_layer(self, p: Plot, layer: Layer) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        data = layer[&quot;data&quot;]</span>
<span class="gi">+        mark = layer[&quot;mark&quot;]</span>
<span class="gi">+        move = layer[&quot;move&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        default_grouping_vars = [&quot;col&quot;, &quot;row&quot;, &quot;group&quot;]  # TODO where best to define?</span>
<span class="gi">+        grouping_properties = [v for v in PROPERTIES if v[0] not in &quot;xy&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        pair_variables = p._pair_spec.get(&quot;structure&quot;, {})</span>
<span class="gi">+</span>
<span class="gi">+        for subplots, df, scales in self._generate_pairings(data, pair_variables):</span>
<span class="gi">+</span>
<span class="gi">+            orient = layer[&quot;orient&quot;] or mark._infer_orient(scales)</span>
<span class="gi">+</span>
<span class="gi">+            def get_order(var):</span>
<span class="gi">+                # Ignore order for x/y: they have been scaled to numeric indices,</span>
<span class="gi">+                # so any original order is no longer valid. Default ordering rules</span>
<span class="gi">+                # sorted unique numbers will correctly reconstruct intended order</span>
<span class="gi">+                # TODO This is tricky, make sure we add some tests for this</span>
<span class="gi">+                if var not in &quot;xy&quot; and var in scales:</span>
<span class="gi">+                    return getattr(scales[var], &quot;order&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            if orient in df:</span>
<span class="gi">+                width = pd.Series(index=df.index, dtype=float)</span>
<span class="gi">+                for view in subplots:</span>
<span class="gi">+                    view_idx = self._get_subplot_data(</span>
<span class="gi">+                        df, orient, view, p._shares.get(orient)</span>
<span class="gi">+                    ).index</span>
<span class="gi">+                    view_df = df.loc[view_idx]</span>
<span class="gi">+                    if &quot;width&quot; in mark._mappable_props:</span>
<span class="gi">+                        view_width = mark._resolve(view_df, &quot;width&quot;, None)</span>
<span class="gi">+                    elif &quot;width&quot; in df:</span>
<span class="gi">+                        view_width = view_df[&quot;width&quot;]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        view_width = 0.8  # TODO what default?</span>
<span class="gi">+                    spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])</span>
<span class="gi">+                    width.loc[view_idx] = view_width * spacing</span>
<span class="gi">+                df[&quot;width&quot;] = width</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;baseline&quot; in mark._mappable_props:</span>
<span class="gi">+                # TODO what marks should have this?</span>
<span class="gi">+                # If we can set baseline with, e.g., Bar(), then the</span>
<span class="gi">+                # &quot;other&quot; (e.g. y for x oriented bars) parameterization</span>
<span class="gi">+                # is somewhat ambiguous.</span>
<span class="gi">+                baseline = mark._resolve(df, &quot;baseline&quot;, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # TODO unlike width, we might not want to add baseline to data</span>
<span class="gi">+                # if the mark doesn&#39;t use it. Practically, there is a concern about</span>
<span class="gi">+                # Mark abstraction like Area / Ribbon</span>
<span class="gi">+                baseline = 0 if &quot;baseline&quot; not in df else df[&quot;baseline&quot;]</span>
<span class="gi">+            df[&quot;baseline&quot;] = baseline</span>
<span class="gi">+</span>
<span class="gi">+            if move is not None:</span>
<span class="gi">+                moves = move if isinstance(move, list) else [move]</span>
<span class="gi">+                for move_step in moves:</span>
<span class="gi">+                    move_by = getattr(move_step, &quot;by&quot;, None)</span>
<span class="gi">+                    if move_by is None:</span>
<span class="gi">+                        move_by = grouping_properties</span>
<span class="gi">+                    move_groupers = [*move_by, *default_grouping_vars]</span>
<span class="gi">+                    if move_step.group_by_orient:</span>
<span class="gi">+                        move_groupers.insert(0, orient)</span>
<span class="gi">+                    order = {var: get_order(var) for var in move_groupers}</span>
<span class="gi">+                    groupby = GroupBy(order)</span>
<span class="gi">+                    df = move_step(df, groupby, orient, scales)</span>
<span class="gi">+</span>
<span class="gi">+            df = self._unscale_coords(subplots, df, orient)</span>
<span class="gi">+</span>
<span class="gi">+            grouping_vars = mark._grouping_props + default_grouping_vars</span>
<span class="gi">+            split_generator = self._setup_split_generator(grouping_vars, df, subplots)</span>
<span class="gi">+</span>
<span class="gi">+            mark._plot(split_generator, scales, orient)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO is this the right place for this?</span>
<span class="gi">+        for view in self._subplots:</span>
<span class="gi">+            view[&quot;ax&quot;].autoscale_view()</span>
<span class="gi">+</span>
<span class="gi">+        if layer[&quot;legend&quot;]:</span>
<span class="gi">+            self._update_legend_contents(p, mark, data, scales, layer[&quot;label&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    def _unscale_coords(</span>
<span class="gi">+        self, subplots: list[dict], df: DataFrame, orient: str,</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+        # TODO do we still have numbers in the variable name at this point?</span>
<span class="gi">+        coord_cols = [c for c in df if re.match(r&quot;^[xy]\D*$&quot;, str(c))]</span>
<span class="gi">+        out_df = (</span>
<span class="gi">+            df</span>
<span class="gi">+            .drop(coord_cols, axis=1)</span>
<span class="gi">+            .reindex(df.columns, axis=1)  # So unscaled columns retain their place</span>
<span class="gi">+            .copy(deep=False)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for view in subplots:</span>
<span class="gi">+            view_df = self._filter_subplot_data(df, view)</span>
<span class="gi">+            axes_df = view_df[coord_cols]</span>
<span class="gi">+            for var, values in axes_df.items():</span>
<span class="gi">+</span>
<span class="gi">+                axis = getattr(view[&quot;ax&quot;], f&quot;{str(var)[0]}axis&quot;)</span>
<span class="gi">+                # TODO see https://github.com/matplotlib/matplotlib/issues/22713</span>
<span class="gi">+                transform = axis.get_transform().inverted().transform</span>
<span class="gi">+                inverted = transform(values)</span>
<span class="gi">+                out_df.loc[values.index, str(var)] = inverted</span>
<span class="gi">+</span>
<span class="gi">+        return out_df</span>
<span class="gi">+</span>
<span class="gi">+    def _generate_pairings(</span>
<span class="gi">+        self, data: PlotData, pair_variables: dict,</span>
<span class="gi">+    ) -&gt; Generator[</span>
<span class="gi">+        tuple[list[dict], DataFrame, dict[str, Scale]], None, None</span>
<span class="gi">+    ]:</span>
<span class="gi">+        # TODO retype return with subplot_spec or similar</span>
<span class="gi">+</span>
<span class="gi">+        iter_axes = itertools.product(*[</span>
<span class="gi">+            pair_variables.get(axis, [axis]) for axis in &quot;xy&quot;</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+        for x, y in iter_axes:</span>
<span class="gi">+</span>
<span class="gi">+            subplots = []</span>
<span class="gi">+            for view in self._subplots:</span>
<span class="gi">+                if (view[&quot;x&quot;] == x) and (view[&quot;y&quot;] == y):</span>
<span class="gi">+                    subplots.append(view)</span>
<span class="gi">+</span>
<span class="gi">+            if data.frame.empty and data.frames:</span>
<span class="gi">+                out_df = data.frames[(x, y)].copy()</span>
<span class="gi">+            elif not pair_variables:</span>
<span class="gi">+                out_df = data.frame.copy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if data.frame.empty and data.frames:</span>
<span class="gi">+                    out_df = data.frames[(x, y)].copy()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    out_df = data.frame.copy()</span>
<span class="gi">+</span>
<span class="gi">+            scales = self._scales.copy()</span>
<span class="gi">+            if x in out_df:</span>
<span class="gi">+                scales[&quot;x&quot;] = self._scales[x]</span>
<span class="gi">+            if y in out_df:</span>
<span class="gi">+                scales[&quot;y&quot;] = self._scales[y]</span>
<span class="gi">+</span>
<span class="gi">+            for axis, var in zip(&quot;xy&quot;, (x, y)):</span>
<span class="gi">+                if axis != var:</span>
<span class="gi">+                    out_df = out_df.rename(columns={var: axis})</span>
<span class="gi">+                    cols = [col for col in out_df if re.match(rf&quot;{axis}\d+&quot;, str(col))]</span>
<span class="gi">+                    out_df = out_df.drop(cols, axis=1)</span>
<span class="gi">+</span>
<span class="gi">+            yield subplots, out_df, scales</span>
<span class="gi">+</span>
<span class="gi">+    def _get_subplot_index(self, df: DataFrame, subplot: dict) -&gt; Index:</span>
<span class="gi">+</span>
<span class="gi">+        dims = df.columns.intersection([&quot;col&quot;, &quot;row&quot;])</span>
<span class="gi">+        if dims.empty:</span>
<span class="gi">+            return df.index</span>
<span class="gi">+</span>
<span class="gi">+        keep_rows = pd.Series(True, df.index, dtype=bool)</span>
<span class="gi">+        for dim in dims:</span>
<span class="gi">+            keep_rows &amp;= df[dim] == subplot[dim]</span>
<span class="gi">+        return df.index[keep_rows]</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_subplot_data(self, df: DataFrame, subplot: dict) -&gt; DataFrame:</span>
<span class="gi">+        # TODO note redundancies with preceding function ... needs refactoring</span>
<span class="gi">+        dims = df.columns.intersection([&quot;col&quot;, &quot;row&quot;])</span>
<span class="gi">+        if dims.empty:</span>
<span class="gi">+            return df</span>
<span class="gi">+</span>
<span class="gi">+        keep_rows = pd.Series(True, df.index, dtype=bool)</span>
<span class="gi">+        for dim in dims:</span>
<span class="gi">+            keep_rows &amp;= df[dim] == subplot[dim]</span>
<span class="gi">+        return df[keep_rows]</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_split_generator(</span>
<span class="gi">+        self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],</span>
<span class="gi">+    ) -&gt; Callable[[], Generator]:</span>
<span class="gi">+</span>
<span class="gi">+        grouping_keys = []</span>
<span class="gi">+        grouping_vars = [</span>
<span class="gi">+            v for v in grouping_vars if v in df and v not in [&quot;col&quot;, &quot;row&quot;]</span>
<span class="gi">+        ]</span>
<span class="gi">+        for var in grouping_vars:</span>
<span class="gi">+            order = getattr(self._scales[var], &quot;order&quot;, None)</span>
<span class="gi">+            if order is None:</span>
<span class="gi">+                order = categorical_order(df[var])</span>
<span class="gi">+            grouping_keys.append(order)</span>
<span class="gi">+</span>
<span class="gi">+        def split_generator(keep_na=False) -&gt; Generator:</span>
<span class="gi">+</span>
<span class="gi">+            for view in subplots:</span>
<span class="gi">+</span>
<span class="gi">+                axes_df = self._filter_subplot_data(df, view)</span>
<span class="gi">+</span>
<span class="gi">+                axes_df_inf_as_nan = axes_df.copy()</span>
<span class="gi">+                axes_df_inf_as_nan = axes_df_inf_as_nan.mask(</span>
<span class="gi">+                    axes_df_inf_as_nan.isin([np.inf, -np.inf]), np.nan</span>
<span class="gi">+                )</span>
<span class="gi">+                if keep_na:</span>
<span class="gi">+                    # The simpler thing to do would be x.dropna().reindex(x.index).</span>
<span class="gi">+                    # But that doesn&#39;t work with the way that the subset iteration</span>
<span class="gi">+                    # is written below, which assumes data for grouping vars.</span>
<span class="gi">+                    # Matplotlib (usually?) masks nan data, so this should &quot;work&quot;.</span>
<span class="gi">+                    # Downstream code can also drop these rows, at some speed cost.</span>
<span class="gi">+                    present = axes_df_inf_as_nan.notna().all(axis=1)</span>
<span class="gi">+                    nulled = {}</span>
<span class="gi">+                    for axis in &quot;xy&quot;:</span>
<span class="gi">+                        if axis in axes_df:</span>
<span class="gi">+                            nulled[axis] = axes_df[axis].where(present)</span>
<span class="gi">+                    axes_df = axes_df_inf_as_nan.assign(**nulled)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    axes_df = axes_df_inf_as_nan.dropna()</span>
<span class="gi">+</span>
<span class="gi">+                subplot_keys = {}</span>
<span class="gi">+                for dim in [&quot;col&quot;, &quot;row&quot;]:</span>
<span class="gi">+                    if view[dim] is not None:</span>
<span class="gi">+                        subplot_keys[dim] = view[dim]</span>
<span class="gi">+</span>
<span class="gi">+                if not grouping_vars or not any(grouping_keys):</span>
<span class="gi">+                    if not axes_df.empty:</span>
<span class="gi">+                        yield subplot_keys, axes_df.copy(), view[&quot;ax&quot;]</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                grouped_df = axes_df.groupby(</span>
<span class="gi">+                    grouping_vars, sort=False, as_index=False, observed=False,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                for key in itertools.product(*grouping_keys):</span>
<span class="gi">+</span>
<span class="gi">+                    pd_key = (</span>
<span class="gi">+                        key[0] if len(key) == 1 and _version_predates(pd, &quot;2.2.0&quot;)</span>
<span class="gi">+                        else key</span>
<span class="gi">+                    )</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        df_subset = grouped_df.get_group(pd_key)</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        # TODO (from initial work on categorical plots refactor)</span>
<span class="gi">+                        # We are adding this to allow backwards compatability</span>
<span class="gi">+                        # with the empty artists that old categorical plots would</span>
<span class="gi">+                        # add (before 0.12), which we may decide to break, in which</span>
<span class="gi">+                        # case this option could be removed</span>
<span class="gi">+                        df_subset = axes_df.loc[[]]</span>
<span class="gi">+</span>
<span class="gi">+                    if df_subset.empty:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    sub_vars = dict(zip(grouping_vars, key))</span>
<span class="gi">+                    sub_vars.update(subplot_keys)</span>
<span class="gi">+</span>
<span class="gi">+                    # TODO need copy(deep=...) policy (here, above, anywhere else?)</span>
<span class="gi">+                    yield sub_vars, df_subset.copy(), view[&quot;ax&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        return split_generator</span>
<span class="gi">+</span>
<span class="gi">+    def _update_legend_contents(</span>
<span class="gi">+        self,</span>
<span class="gi">+        p: Plot,</span>
<span class="gi">+        mark: Mark,</span>
<span class="gi">+        data: PlotData,</span>
<span class="gi">+        scales: dict[str, Scale],</span>
<span class="gi">+        layer_label: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Add legend artists / labels for one layer in the plot.&quot;&quot;&quot;</span>
<span class="gi">+        if data.frame.empty and data.frames:</span>
<span class="gi">+            legend_vars: list[str] = []</span>
<span class="gi">+            for frame in data.frames.values():</span>
<span class="gi">+                frame_vars = frame.columns.intersection(list(scales))</span>
<span class="gi">+                legend_vars.extend(v for v in frame_vars if v not in legend_vars)</span>
<span class="gi">+        else:</span>
<span class="gi">+            legend_vars = list(data.frame.columns.intersection(list(scales)))</span>
<span class="gi">+</span>
<span class="gi">+        # First handle layer legends, which occupy a single entry in legend_contents.</span>
<span class="gi">+        if layer_label is not None:</span>
<span class="gi">+            legend_title = str(p._labels.get(&quot;legend&quot;, &quot;&quot;))</span>
<span class="gi">+            layer_key = (legend_title, -1)</span>
<span class="gi">+            artist = mark._legend_artist([], None, {})</span>
<span class="gi">+            if artist is not None:</span>
<span class="gi">+                for content in self._legend_contents:</span>
<span class="gi">+                    if content[0] == layer_key:</span>
<span class="gi">+                        content[1].append(artist)</span>
<span class="gi">+                        content[2].append(layer_label)</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._legend_contents.append((layer_key, [artist], [layer_label]))</span>
<span class="gi">+</span>
<span class="gi">+        # Then handle the scale legends</span>
<span class="gi">+        # First pass: Identify the values that will be shown for each variable</span>
<span class="gi">+        schema: list[tuple[</span>
<span class="gi">+            tuple[str, str | int], list[str], tuple[list[Any], list[str]]</span>
<span class="gi">+        ]] = []</span>
<span class="gi">+        schema = []</span>
<span class="gi">+        for var in legend_vars:</span>
<span class="gi">+            var_legend = scales[var]._legend</span>
<span class="gi">+            if var_legend is not None:</span>
<span class="gi">+                values, labels = var_legend</span>
<span class="gi">+                for (_, part_id), part_vars, _ in schema:</span>
<span class="gi">+                    if data.ids[var] == part_id:</span>
<span class="gi">+                        # Allow multiple plot semantics to represent same data variable</span>
<span class="gi">+                        part_vars.append(var)</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    title = self._resolve_label(p, var, data.names[var])</span>
<span class="gi">+                    entry = (title, data.ids[var]), [var], (values, labels)</span>
<span class="gi">+                    schema.append(entry)</span>
<span class="gi">+</span>
<span class="gi">+        # Second pass, generate an artist corresponding to each value</span>
<span class="gi">+        contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []</span>
<span class="gi">+        for key, variables, (values, labels) in schema:</span>
<span class="gi">+            artists = []</span>
<span class="gi">+            for val in values:</span>
<span class="gi">+                artist = mark._legend_artist(variables, val, scales)</span>
<span class="gi">+                if artist is not None:</span>
<span class="gi">+                    artists.append(artist)</span>
<span class="gi">+            if artists:</span>
<span class="gi">+                contents.append((key, artists, labels))</span>
<span class="gi">+</span>
<span class="gi">+        self._legend_contents.extend(contents)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_legend(self, p: Plot) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the legend artist(s) and add onto the figure.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Combine artists representing same information across layers</span>
<span class="gi">+        # Input list has an entry for each distinct variable in each layer</span>
<span class="gi">+        # Output dict has an entry for each distinct variable</span>
<span class="gi">+        merged_contents: dict[</span>
<span class="gi">+            tuple[str, str | int], tuple[list[tuple[Artist, ...]], list[str]],</span>
<span class="gi">+        ] = {}</span>
<span class="gi">+        for key, new_artists, labels in self._legend_contents:</span>
<span class="gi">+            # Key is (name, id); we need the id to resolve variable uniqueness,</span>
<span class="gi">+            # but will need the name in the next step to title the legend</span>
<span class="gi">+            if key not in merged_contents:</span>
<span class="gi">+                # Matplotlib accepts a tuple of artists and will overlay them</span>
<span class="gi">+                new_artist_tuples = [tuple([a]) for a in new_artists]</span>
<span class="gi">+                merged_contents[key] = new_artist_tuples, labels</span>
<span class="gi">+            else:</span>
<span class="gi">+                existing_artists = merged_contents[key][0]</span>
<span class="gi">+                for i, new_artist in enumerate(new_artists):</span>
<span class="gi">+                    existing_artists[i] += tuple([new_artist])</span>
<span class="gi">+</span>
<span class="gi">+        # When using pyplot, an &quot;external&quot; legend won&#39;t be shown, so this</span>
<span class="gi">+        # keeps it inside the axes (though still attached to the figure)</span>
<span class="gi">+        # This is necessary because matplotlib layout engines currently don&#39;t</span>
<span class="gi">+        # support figure legends — ideally this will change.</span>
<span class="gi">+        loc = &quot;center right&quot; if self._pyplot else &quot;center left&quot;</span>
<span class="gi">+</span>
<span class="gi">+        base_legend = None</span>
<span class="gi">+        for (name, _), (handles, labels) in merged_contents.items():</span>
<span class="gi">+</span>
<span class="gi">+            legend = mpl.legend.Legend(</span>
<span class="gi">+                self._figure,</span>
<span class="gi">+                handles,  # type: ignore  # matplotlib/issues/26639</span>
<span class="gi">+                labels,</span>
<span class="gi">+                title=name,</span>
<span class="gi">+                loc=loc,</span>
<span class="gi">+                bbox_to_anchor=(.98, .55),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if base_legend:</span>
<span class="gi">+                # Matplotlib has no public API for this so it is a bit of a hack.</span>
<span class="gi">+                # Ideally we&#39;d define our own legend class with more flexibility,</span>
<span class="gi">+                # but that is a lot of work!</span>
<span class="gi">+                base_legend_box = base_legend.get_children()[0]</span>
<span class="gi">+                this_legend_box = legend.get_children()[0]</span>
<span class="gi">+                base_legend_box.get_children().extend(this_legend_box.get_children())</span>
<span class="gi">+            else:</span>
<span class="gi">+                base_legend = legend</span>
<span class="gi">+                self._figure.legends.append(legend)</span>
<span class="gi">+</span>
<span class="gi">+    def _finalize_figure(self, p: Plot) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        for sub in self._subplots:</span>
<span class="gi">+            ax = sub[&quot;ax&quot;]</span>
<span class="gi">+            for axis in &quot;xy&quot;:</span>
<span class="gi">+                axis_key = sub[axis]</span>
<span class="gi">+                axis_obj = getattr(ax, f&quot;{axis}axis&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Axis limits</span>
<span class="gi">+                if axis_key in p._limits or axis in p._limits:</span>
<span class="gi">+                    convert_units = getattr(ax, f&quot;{axis}axis&quot;).convert_units</span>
<span class="gi">+                    a, b = p._limits.get(axis_key) or p._limits[axis]</span>
<span class="gi">+                    lo = a if a is None else convert_units(a)</span>
<span class="gi">+                    hi = b if b is None else convert_units(b)</span>
<span class="gi">+                    if isinstance(a, str):</span>
<span class="gi">+                        lo = cast(float, lo) - 0.5</span>
<span class="gi">+                    if isinstance(b, str):</span>
<span class="gi">+                        hi = cast(float, hi) + 0.5</span>
<span class="gi">+                    ax.set(**{f&quot;{axis}lim&quot;: (lo, hi)})</span>
<span class="gi">+</span>
<span class="gi">+                if axis_key in self._scales:  # TODO when would it not be?</span>
<span class="gi">+                    self._scales[axis_key]._finalize(p, axis_obj)</span>
<span class="gi">+</span>
<span class="gi">+        if (engine_name := p._layout_spec.get(&quot;engine&quot;, default)) is not default:</span>
<span class="gi">+            # None is a valid arg for Figure.set_layout_engine, hence `default`</span>
<span class="gi">+            set_layout_engine(self._figure, engine_name)</span>
<span class="gi">+        elif p._target is None:</span>
<span class="gi">+            # Don&#39;t modify the layout engine if the user supplied their own</span>
<span class="gi">+            # matplotlib figure and didn&#39;t specify an engine through Plot</span>
<span class="gi">+            # TODO switch default to &quot;constrained&quot;?</span>
<span class="gi">+            # TODO either way, make configurable</span>
<span class="gi">+            set_layout_engine(self._figure, &quot;tight&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if (extent := p._layout_spec.get(&quot;extent&quot;)) is not None:</span>
<span class="gi">+            engine = get_layout_engine(self._figure)</span>
<span class="gi">+            if engine is None:</span>
<span class="gi">+                self._figure.subplots_adjust(*extent)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Note the different parameterization for the layout engine rect...</span>
<span class="gi">+                left, bottom, right, top = extent</span>
<span class="gi">+                width, height = right - left, top - bottom</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # The base LayoutEngine.set method doesn&#39;t have rect= so we need</span>
<span class="gi">+                    # to avoid typechecking this statement. We also catch a TypeError</span>
<span class="gi">+                    # as a plugin LayoutEngine may not support it either.</span>
<span class="gi">+                    # Alternatively we could guard this with a check on the engine type,</span>
<span class="gi">+                    # but that would make later-developed engines would un-useable.</span>
<span class="gi">+                    engine.set(rect=[left, bottom, width, height])  # type: ignore</span>
<span class="gi">+                except TypeError:</span>
<span class="gi">+                    # Should we warn / raise? Note that we don&#39;t expect to get here</span>
<span class="gi">+                    # under any normal circumstances.</span>
<span class="gi">+                    pass</span>
<span class="gh">diff --git a/seaborn/_core/properties.py b/seaborn/_core/properties.py</span>
<span class="gh">index 74be300e..4e2df91b 100644</span>
<span class="gd">--- a/seaborn/_core/properties.py</span>
<span class="gi">+++ b/seaborn/_core/properties.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>import itertools
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from numpy.typing import ArrayLike
<span class="w"> </span>from pandas import Series
<span class="gu">@@ -8,55 +9,132 @@ import matplotlib as mpl</span>
<span class="w"> </span>from matplotlib.colors import to_rgb, to_rgba, to_rgba_array
<span class="w"> </span>from matplotlib.markers import MarkerStyle
<span class="w"> </span>from matplotlib.path import Path
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.scales import Scale, Boolean, Continuous, Nominal, Temporal
<span class="w"> </span>from seaborn._core.rules import categorical_order, variable_type
<span class="w"> </span>from seaborn.palettes import QUAL_PALETTES, color_palette, blend_palette
<span class="w"> </span>from seaborn.utils import get_color_cycle
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Callable, Tuple, List, Union, Optional
<span class="gi">+</span>
<span class="w"> </span>RGBTuple = Tuple[float, float, float]
<span class="w"> </span>RGBATuple = Tuple[float, float, float, float]
<span class="w"> </span>ColorSpec = Union[RGBTuple, RGBATuple, str]
<span class="gi">+</span>
<span class="w"> </span>DashPattern = Tuple[float, ...]
<span class="w"> </span>DashPatternWithOffset = Tuple[float, Optional[DashPattern]]
<span class="gd">-MarkerPattern = Union[float, str, Tuple[int, int, float], List[Tuple[float,</span>
<span class="gd">-    float]], Path, MarkerStyle]</span>
<span class="gi">+</span>
<span class="gi">+MarkerPattern = Union[</span>
<span class="gi">+    float,</span>
<span class="gi">+    str,</span>
<span class="gi">+    Tuple[int, int, float],</span>
<span class="gi">+    List[Tuple[float, float]],</span>
<span class="gi">+    Path,</span>
<span class="gi">+    MarkerStyle,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>Mapping = Callable[[ArrayLike], ArrayLike]


<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Base classes</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Property:
<span class="w"> </span>    &quot;&quot;&quot;Base class for visual properties that can be set directly or be data scaling.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # When True, scales for this property will populate the legend by default</span>
<span class="w"> </span>    legend = False
<span class="gi">+</span>
<span class="gi">+    # When True, scales for this property normalize data to [0, 1] before mapping</span>
<span class="w"> </span>    normed = False

<span class="gd">-    def __init__(self, variable: (str | None)=None):</span>
<span class="gi">+    def __init__(self, variable: str | None = None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the property with the name of the corresponding plot variable.&quot;&quot;&quot;
<span class="w"> </span>        if not variable:
<span class="w"> </span>            variable = self.__class__.__name__.lower()
<span class="w"> </span>        self.variable = variable

<span class="gd">-    def default_scale(self, data: Series) -&gt;Scale:</span>
<span class="gi">+    def default_scale(self, data: Series) -&gt; Scale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given data, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def infer_scale(self, arg: Any, data: Series) -&gt;Scale:</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+        if var_type == &quot;numeric&quot;:</span>
<span class="gi">+            return Continuous()</span>
<span class="gi">+        elif var_type == &quot;datetime&quot;:</span>
<span class="gi">+            return Temporal()</span>
<span class="gi">+        elif var_type == &quot;boolean&quot;:</span>
<span class="gi">+            return Boolean()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Nominal()</span>
<span class="gi">+</span>
<span class="gi">+    def infer_scale(self, arg: Any, data: Series) -&gt; Scale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:</span>
<span class="gi">+        # TODO put these somewhere external for validation</span>
<span class="gi">+        # TODO putting this here won&#39;t pick it up if subclasses define infer_scale</span>
<span class="gi">+        # (e.g. color). How best to handle that? One option is to call super after</span>
<span class="gi">+        # handling property-specific possibilities (e.g. for color check that the</span>
<span class="gi">+        # arg is not a valid palette name) but that could get tricky.</span>
<span class="gi">+        trans_args = [&quot;log&quot;, &quot;symlog&quot;, &quot;logit&quot;, &quot;pow&quot;, &quot;sqrt&quot;]</span>
<span class="gi">+        if isinstance(arg, str):</span>
<span class="gi">+            if any(arg.startswith(k) for k in trans_args):</span>
<span class="gi">+                # TODO validate numeric type? That should happen centrally somewhere</span>
<span class="gi">+                return Continuous(trans=arg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;Unknown magic arg for {self.variable} scale: &#39;{arg}&#39;.&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg_type = type(arg).__name__</span>
<span class="gi">+            msg = f&quot;Magic arg for {self.variable} scale must be str, not {arg_type}.&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping(self, scale: Scale, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def identity(x):</span>
<span class="gi">+            return x</span>
<span class="gi">+        return identity</span>

<span class="gd">-    def standardize(self, val: Any) -&gt;Any:</span>
<span class="gi">+    def standardize(self, val: Any) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Coerce flexible property value to standardized representation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return val</span>

<span class="gd">-    def _check_dict_entries(self, levels: list, values: dict) -&gt;None:</span>
<span class="gi">+    def _check_dict_entries(self, levels: list, values: dict) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing = set(levels) - set(values)</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            formatted = &quot;, &quot;.join(map(repr, sorted(missing, key=str)))</span>
<span class="gi">+            err = f&quot;No entry in {self.variable} dictionary for {formatted}&quot;</span>
<span class="gi">+            raise ValueError(err)</span>

<span class="gd">-    def _check_list_length(self, levels: list, values: list) -&gt;list:</span>
<span class="gi">+    def _check_list_length(self, levels: list, values: list) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Input check when values are provided as a list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = &quot;&quot;</span>
<span class="gi">+        if len(levels) &gt; len(values):</span>
<span class="gi">+            message = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;\nThe {self.variable} list has fewer values ({len(values)})&quot;,</span>
<span class="gi">+                f&quot;than needed ({len(levels)}) and will cycle, which may&quot;,</span>
<span class="gi">+                &quot;produce an uninterpretable plot.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            values = [x for _, x in zip(levels, itertools.cycle(values))]</span>
<span class="gi">+</span>
<span class="gi">+        elif len(values) &gt; len(levels):</span>
<span class="gi">+            message = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;The {self.variable} list has more values ({len(values)})&quot;,</span>
<span class="gi">+                f&quot;than needed ({len(levels)}), which may not be intended.&quot;,</span>
<span class="gi">+            ])</span>
<span class="gi">+            values = values[:len(levels)]</span>
<span class="gi">+</span>
<span class="gi">+        # TODO look into custom PlotSpecWarning with better formatting</span>
<span class="gi">+        if message:</span>
<span class="gi">+            warnings.warn(message, UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Properties relating to spatial position of marks on the plotting axes</span>
<span class="gi">+# =================================================================================== #</span>


<span class="w"> </span>class Coordinate(Property):
<span class="gu">@@ -65,85 +143,170 @@ class Coordinate(Property):</span>
<span class="w"> </span>    normed = False


<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Properties with numeric values where scale range can be defined as an interval</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class IntervalProperty(Property):
<span class="w"> </span>    &quot;&quot;&quot;A numeric property where scale range can be defined as an interval.&quot;&quot;&quot;
<span class="w"> </span>    legend = True
<span class="w"> </span>    normed = True
<span class="gi">+</span>
<span class="w"> </span>    _default_range: tuple[float, float] = (0, 1)

<span class="w"> </span>    @property
<span class="gd">-    def default_range(self) -&gt;tuple[float, float]:</span>
<span class="gi">+    def default_range(self) -&gt; tuple[float, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._default_range</span>

<span class="gd">-    def _forward(self, values: ArrayLike) -&gt;ArrayLike:</span>
<span class="gi">+    def _forward(self, values: ArrayLike) -&gt; ArrayLike:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform applied to native values before linear mapping into interval.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return values</span>

<span class="gd">-    def _inverse(self, values: ArrayLike) -&gt;ArrayLike:</span>
<span class="gi">+    def _inverse(self, values: ArrayLike) -&gt; ArrayLike:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform applied to results of mapping that returns to native values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return values</span>

<span class="gd">-    def infer_scale(self, arg: Any, data: Series) -&gt;Scale:</span>
<span class="gi">+    def infer_scale(self, arg: Any, data: Series) -&gt; Scale:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:</span>
<span class="gd">-        &quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        # TODO infer continuous based on log/sqrt etc?</span>
<span class="gi">+</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>

<span class="gd">-    def _get_nominal_mapping(self, scale: Nominal, data: Series) -&gt;Mapping:</span>
<span class="gi">+        if var_type == &quot;boolean&quot;:</span>
<span class="gi">+            return Boolean(arg)</span>
<span class="gi">+        elif isinstance(arg, (list, dict)):</span>
<span class="gi">+            return Nominal(arg)</span>
<span class="gi">+        elif var_type == &quot;categorical&quot;:</span>
<span class="gi">+            return Nominal(arg)</span>
<span class="gi">+        elif var_type == &quot;datetime&quot;:</span>
<span class="gi">+            return Temporal(arg)</span>
<span class="gi">+        # TODO other variable types</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Continuous(arg)</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping(self, scale: Scale, data: Series) -&gt; Mapping:</span>
<span class="gi">+        &quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(scale, Nominal):</span>
<span class="gi">+            return self._get_nominal_mapping(scale, data)</span>
<span class="gi">+        elif isinstance(scale, Boolean):</span>
<span class="gi">+            return self._get_boolean_mapping(scale, data)</span>
<span class="gi">+</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            vmin, vmax = self._forward(self.default_range)</span>
<span class="gi">+        elif isinstance(scale.values, tuple) and len(scale.values) == 2:</span>
<span class="gi">+            vmin, vmax = self._forward(scale.values)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(scale.values, tuple):</span>
<span class="gi">+                actual = f&quot;{len(scale.values)}-tuple&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                actual = str(type(scale.values))</span>
<span class="gi">+            scale_class = scale.__class__.__name__</span>
<span class="gi">+            err = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;Values for {self.variable} variables with {scale_class} scale&quot;,</span>
<span class="gi">+                f&quot;must be 2-tuple; not {actual}.&quot;,</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            return self._inverse(np.multiply(x, vmax - vmin) + vmin)</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_nominal_mapping(self, scale: Nominal, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        levels = categorical_order(data, scale.order)</span>
<span class="gi">+        values = self._get_values(scale, levels)</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            ixs = np.asarray(x, np.intp)</span>
<span class="gi">+            out = np.full(len(x), np.nan)</span>
<span class="gi">+            use = np.isfinite(x)</span>
<span class="gi">+            out[use] = np.take(values, ixs[use])</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>

<span class="gd">-    def _get_boolean_mapping(self, scale: Boolean, data: Series) -&gt;Mapping:</span>
<span class="gi">+    def _get_boolean_mapping(self, scale: Boolean, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = self._get_values(scale, [True, False])</span>

<span class="gd">-    def _get_values(self, scale: Scale, levels: list) -&gt;list:</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            out = np.full(len(x), np.nan)</span>
<span class="gi">+            use = np.isfinite(x)</span>
<span class="gi">+            out[use] = np.where(x[use], *values)</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_values(self, scale: Scale, levels: list) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            values = [scale.values[x] for x in levels]</span>
<span class="gi">+        elif isinstance(scale.values, list):</span>
<span class="gi">+            values = self._check_list_length(levels, scale.values)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if scale.values is None:</span>
<span class="gi">+                vmin, vmax = self.default_range</span>
<span class="gi">+            elif isinstance(scale.values, tuple):</span>
<span class="gi">+                vmin, vmax = scale.values</span>
<span class="gi">+            else:</span>
<span class="gi">+                scale_class = scale.__class__.__name__</span>
<span class="gi">+                err = &quot; &quot;.join([</span>
<span class="gi">+                    f&quot;Values for {self.variable} variables with {scale_class} scale&quot;,</span>
<span class="gi">+                    f&quot;must be a dict, list or tuple; not {type(scale.values)}&quot;,</span>
<span class="gi">+                ])</span>
<span class="gi">+                raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+            vmin, vmax = self._forward([vmin, vmax])</span>
<span class="gi">+            values = list(self._inverse(np.linspace(vmax, vmin, len(levels))))</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>


<span class="w"> </span>class PointSize(IntervalProperty):
<span class="w"> </span>    &quot;&quot;&quot;Size (diameter) of a point mark, in points, with scaling by area.&quot;&quot;&quot;
<span class="gd">-    _default_range = 2, 8</span>
<span class="gi">+    _default_range = 2, 8  # TODO use rcparams?</span>

<span class="w"> </span>    def _forward(self, values):
<span class="w"> </span>        &quot;&quot;&quot;Square native values to implement linear scaling of point area.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return np.square(values)</span>

<span class="w"> </span>    def _inverse(self, values):
<span class="w"> </span>        &quot;&quot;&quot;Invert areal values back to point diameter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return np.sqrt(values)</span>


<span class="w"> </span>class LineWidth(IntervalProperty):
<span class="w"> </span>    &quot;&quot;&quot;Thickness of a line mark, in points.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    @property
<span class="gd">-    def default_range(self) -&gt;tuple[float, float]:</span>
<span class="gi">+    def default_range(self) -&gt; tuple[float, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+        return base * .5, base * 2</span>


<span class="w"> </span>class EdgeWidth(IntervalProperty):
<span class="w"> </span>    &quot;&quot;&quot;Thickness of the edges on a patch mark, in points.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    @property
<span class="gd">-    def default_range(self) -&gt;tuple[float, float]:</span>
<span class="gi">+    def default_range(self) -&gt; tuple[float, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = mpl.rcParams[&quot;patch.linewidth&quot;]</span>
<span class="gi">+        return base * .5, base * 2</span>


<span class="w"> </span>class Stroke(IntervalProperty):
<span class="w"> </span>    &quot;&quot;&quot;Thickness of lines that define point glyphs.&quot;&quot;&quot;
<span class="gd">-    _default_range = 0.25, 2.5</span>
<span class="gi">+    _default_range = .25, 2.5</span>


<span class="w"> </span>class Alpha(IntervalProperty):
<span class="w"> </span>    &quot;&quot;&quot;Opacity of the color values for an arbitrary mark.&quot;&quot;&quot;
<span class="gd">-    _default_range = 0.3, 0.95</span>
<span class="gi">+    _default_range = .3, .95</span>
<span class="gi">+    # TODO validate / enforce that output is in [0, 1]</span>


<span class="w"> </span>class Offset(IntervalProperty):
<span class="gu">@@ -157,31 +320,90 @@ class FontSize(IntervalProperty):</span>
<span class="w"> </span>    _legend = False

<span class="w"> </span>    @property
<span class="gd">-    def default_range(self) -&gt;tuple[float, float]:</span>
<span class="gi">+    def default_range(self) -&gt; tuple[float, float]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = mpl.rcParams[&quot;font.size&quot;]</span>
<span class="gi">+        return base * .5, base * 2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Properties defined by arbitrary objects with inherently nominal scaling</span>
<span class="gi">+# =================================================================================== #</span>


<span class="w"> </span>class ObjectProperty(Property):
<span class="w"> </span>    &quot;&quot;&quot;A property defined by arbitrary an object, with inherently nominal scaling.&quot;&quot;&quot;
<span class="w"> </span>    legend = True
<span class="w"> </span>    normed = False
<span class="gi">+</span>
<span class="gi">+    # Object representing null data, should appear invisible when drawn by matplotlib</span>
<span class="gi">+    # Note that we now drop nulls in Plot._plot_layer and thus may not need this</span>
<span class="w"> </span>    null_value: Any = None

<span class="gd">-    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def default_scale(self, data: Series) -&gt; Scale:</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+        return Boolean() if var_type == &quot;boolean&quot; else Nominal()</span>
<span class="gi">+</span>
<span class="gi">+    def infer_scale(self, arg: Any, data: Series) -&gt; Scale:</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+        return Boolean(arg) if var_type == &quot;boolean&quot; else Nominal(arg)</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping(self, scale: Scale, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Define mapping as lookup into list of object values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        boolean_scale = isinstance(scale, Boolean)</span>
<span class="gi">+        order = getattr(scale, &quot;order&quot;, [True, False] if boolean_scale else None)</span>
<span class="gi">+        levels = categorical_order(data, order)</span>
<span class="gi">+        values = self._get_values(scale, levels)</span>
<span class="gi">+</span>
<span class="gi">+        if boolean_scale:</span>
<span class="gi">+            values = values[::-1]</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            ixs = np.asarray(np.nan_to_num(x), np.intp)</span>
<span class="gi">+            return [</span>
<span class="gi">+                values[ix] if np.isfinite(x_i) else self.null_value</span>
<span class="gi">+                for x_i, ix in zip(x, ixs)</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>

<span class="gd">-    def _get_values(self, scale: Scale, levels: list) -&gt;list:</span>
<span class="gi">+    def _get_values(self, scale: Scale, levels: list) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        n = len(levels)</span>
<span class="gi">+        if isinstance(scale.values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, scale.values)</span>
<span class="gi">+            values = [scale.values[x] for x in levels]</span>
<span class="gi">+        elif isinstance(scale.values, list):</span>
<span class="gi">+            values = self._check_list_length(levels, scale.values)</span>
<span class="gi">+        elif scale.values is None:</span>
<span class="gi">+            values = self._default_values(n)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;Scale values for a {self.variable} variable must be provided&quot;,</span>
<span class="gi">+                f&quot;in a dict or list; not {type(scale.values)}.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        values = [self.standardize(x) for x in values]</span>
<span class="gi">+        return values</span>


<span class="w"> </span>class Marker(ObjectProperty):
<span class="w"> </span>    &quot;&quot;&quot;Shape of points in scatter-type marks or lines with data points marked.&quot;&quot;&quot;
<span class="gd">-    null_value = MarkerStyle(&#39;&#39;)</span>
<span class="gi">+    null_value = MarkerStyle(&quot;&quot;)</span>

<span class="gd">-    def _default_values(self, n: int) -&gt;list[MarkerStyle]:</span>
<span class="gi">+    # TODO should we have named marker &quot;palettes&quot;? (e.g. see d3 options)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO need some sort of &quot;require_scale&quot; functionality</span>
<span class="gi">+    # to raise when we get the wrong kind explicitly specified</span>
<span class="gi">+</span>
<span class="gi">+    def standardize(self, val: MarkerPattern) -&gt; MarkerStyle:</span>
<span class="gi">+        return MarkerStyle(val)</span>
<span class="gi">+</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list[MarkerStyle]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build an arbitrarily long list of unique marker styles.

<span class="w"> </span>        Parameters
<span class="gu">@@ -196,14 +418,31 @@ class Marker(ObjectProperty):</span>
<span class="w"> </span>            All markers will be filled.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start with marker specs that are well distinguishable</span>
<span class="gi">+        markers = [</span>
<span class="gi">+            &quot;o&quot;, &quot;X&quot;, (4, 0, 45), &quot;P&quot;, (4, 0, 0), (4, 1, 0), &quot;^&quot;, (4, 1, 45), &quot;v&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Now generate more from regular polygons of increasing order</span>
<span class="gi">+        s = 5</span>
<span class="gi">+        while len(markers) &lt; n:</span>
<span class="gi">+            a = 360 / (s + 1) / 2</span>
<span class="gi">+            markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])</span>
<span class="gi">+            s += 1</span>
<span class="gi">+</span>
<span class="gi">+        markers = [MarkerStyle(m) for m in markers[:n]]</span>
<span class="gi">+</span>
<span class="gi">+        return markers</span>


<span class="w"> </span>class LineStyle(ObjectProperty):
<span class="w"> </span>    &quot;&quot;&quot;Dash pattern for line-type marks.&quot;&quot;&quot;
<span class="gd">-    null_value = &#39;&#39;</span>
<span class="gi">+    null_value = &quot;&quot;</span>

<span class="gd">-    def _default_values(self, n: int) -&gt;list[DashPatternWithOffset]:</span>
<span class="gi">+    def standardize(self, val: str | DashPattern) -&gt; DashPatternWithOffset:</span>
<span class="gi">+        return self._get_dash_pattern(val)</span>
<span class="gi">+</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list[DashPatternWithOffset]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build an arbitrarily long list of unique dash styles for lines.

<span class="w"> </span>        Parameters
<span class="gu">@@ -220,12 +459,77 @@ class LineStyle(ObjectProperty):</span>
<span class="w"> </span>            dashes.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start with dash specs that are well distinguishable</span>
<span class="gi">+        dashes: list[str | DashPattern] = [</span>
<span class="gi">+            &quot;-&quot;, (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Now programmatically build as many as we need</span>
<span class="gi">+        p = 3</span>
<span class="gi">+        while len(dashes) &lt; n:</span>
<span class="gi">+</span>
<span class="gi">+            # Take combinations of long and short dashes</span>
<span class="gi">+            a = itertools.combinations_with_replacement([3, 1.25], p)</span>
<span class="gi">+            b = itertools.combinations_with_replacement([4, 1], p)</span>
<span class="gi">+</span>
<span class="gi">+            # Interleave the combinations, reversing one of the streams</span>
<span class="gi">+            segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1]))</span>
<span class="gi">+</span>
<span class="gi">+            # Now insert the gaps</span>
<span class="gi">+            for segments in segment_list:</span>
<span class="gi">+                gap = min(segments)</span>
<span class="gi">+                spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))</span>
<span class="gi">+                dashes.append(spec)</span>
<span class="gi">+</span>
<span class="gi">+            p += 1</span>
<span class="gi">+</span>
<span class="gi">+        return [self._get_dash_pattern(x) for x in dashes]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_dash_pattern(style: (str | DashPattern)) -&gt;DashPatternWithOffset:</span>
<span class="gi">+    def _get_dash_pattern(style: str | DashPattern) -&gt; DashPatternWithOffset:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert linestyle arguments to dash pattern with offset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Copied and modified from Matplotlib 3.4</span>
<span class="gi">+        # go from short hand -&gt; full strings</span>
<span class="gi">+        ls_mapper = {&quot;-&quot;: &quot;solid&quot;, &quot;--&quot;: &quot;dashed&quot;, &quot;-.&quot;: &quot;dashdot&quot;, &quot;:&quot;: &quot;dotted&quot;}</span>
<span class="gi">+        if isinstance(style, str):</span>
<span class="gi">+            style = ls_mapper.get(style, style)</span>
<span class="gi">+            # un-dashed styles</span>
<span class="gi">+            if style in [&quot;solid&quot;, &quot;none&quot;, &quot;None&quot;]:</span>
<span class="gi">+                offset = 0</span>
<span class="gi">+                dashes = None</span>
<span class="gi">+            # dashed styles</span>
<span class="gi">+            elif style in [&quot;dashed&quot;, &quot;dashdot&quot;, &quot;dotted&quot;]:</span>
<span class="gi">+                offset = 0</span>
<span class="gi">+                dashes = tuple(mpl.rcParams[f&quot;lines.{style}_pattern&quot;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                options = [*ls_mapper.values(), *ls_mapper.keys()]</span>
<span class="gi">+                msg = f&quot;Linestyle string must be one of {options}, not {repr(style)}.&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(style, tuple):</span>
<span class="gi">+            if len(style) &gt; 1 and isinstance(style[1], tuple):</span>
<span class="gi">+                offset, dashes = style</span>
<span class="gi">+            elif len(style) &gt; 1 and style[1] is None:</span>
<span class="gi">+                offset, dashes = style</span>
<span class="gi">+            else:</span>
<span class="gi">+                offset = 0</span>
<span class="gi">+                dashes = style</span>
<span class="gi">+        else:</span>
<span class="gi">+            val_type = type(style).__name__</span>
<span class="gi">+            msg = f&quot;Linestyle must be str or tuple, not {val_type}.&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # Normalize offset to be positive and shorter than the dash cycle</span>
<span class="gi">+        if dashes is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                dsum = sum(dashes)</span>
<span class="gi">+            except TypeError as err:</span>
<span class="gi">+                msg = f&quot;Invalid dash pattern: {dashes}&quot;</span>
<span class="gi">+                raise TypeError(msg) from err</span>
<span class="gi">+            if dsum:</span>
<span class="gi">+                offset %= dsum</span>
<span class="gi">+</span>
<span class="gi">+        return offset, dashes</span>


<span class="w"> </span>class TextAlignment(ObjectProperty):
<span class="gu">@@ -233,11 +537,22 @@ class TextAlignment(ObjectProperty):</span>


<span class="w"> </span>class HorizontalAlignment(TextAlignment):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list:</span>
<span class="gi">+        vals = itertools.cycle([&quot;left&quot;, &quot;right&quot;])</span>
<span class="gi">+        return [next(vals) for _ in range(n)]</span>


<span class="w"> </span>class VerticalAlignment(TextAlignment):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list:</span>
<span class="gi">+        vals = itertools.cycle([&quot;top&quot;, &quot;bottom&quot;])</span>
<span class="gi">+        return [next(vals) for _ in range(n)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Properties with  RGB(A) color values</span>
<span class="gi">+# =================================================================================== #</span>


<span class="w"> </span>class Color(Property):
<span class="gu">@@ -245,17 +560,173 @@ class Color(Property):</span>
<span class="w"> </span>    legend = True
<span class="w"> </span>    normed = True

<span class="gd">-    def _standardize_color_sequence(self, colors: ArrayLike) -&gt;ArrayLike:</span>
<span class="gd">-        &quot;&quot;&quot;Convert color sequence to RGB(A) array, preserving but not adding alpha.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def standardize(self, val: ColorSpec) -&gt; RGBTuple | RGBATuple:</span>
<span class="gi">+        # Return color with alpha channel only if the input spec has it</span>
<span class="gi">+        # This is so that RGBA colors can override the Alpha property</span>
<span class="gi">+        if to_rgba(val) != to_rgba(val, 1):</span>
<span class="gi">+            return to_rgba(val)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return to_rgb(val)</span>

<span class="gd">-    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:</span>
<span class="gi">+    def _standardize_color_sequence(self, colors: ArrayLike) -&gt; ArrayLike:</span>
<span class="gi">+        &quot;&quot;&quot;Convert color sequence to RGB(A) array, preserving but not adding alpha.&quot;&quot;&quot;</span>
<span class="gi">+        def has_alpha(x):</span>
<span class="gi">+            return to_rgba(x) != to_rgba(x, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(colors, np.ndarray):</span>
<span class="gi">+            needs_alpha = colors.shape[1] == 4</span>
<span class="gi">+        else:</span>
<span class="gi">+            needs_alpha = any(has_alpha(x) for x in colors)</span>
<span class="gi">+</span>
<span class="gi">+        if needs_alpha:</span>
<span class="gi">+            return to_rgba_array(colors)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return to_rgba_array(colors)[:, :3]</span>
<span class="gi">+</span>
<span class="gi">+    def infer_scale(self, arg: Any, data: Series) -&gt; Scale:</span>
<span class="gi">+        # TODO when inferring Continuous without data, verify type</span>
<span class="gi">+</span>
<span class="gi">+        # TODO need to rethink the variable type system</span>
<span class="gi">+        # (e.g. boolean, ordered categories as Ordinal, etc)..</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+</span>
<span class="gi">+        if var_type == &quot;boolean&quot;:</span>
<span class="gi">+            return Boolean(arg)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(arg, (dict, list)):</span>
<span class="gi">+            return Nominal(arg)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(arg, tuple):</span>
<span class="gi">+            if var_type == &quot;categorical&quot;:</span>
<span class="gi">+                # TODO It seems reasonable to allow a gradient mapping for nominal</span>
<span class="gi">+                # scale but it also feels &quot;technically&quot; wrong. Should this infer</span>
<span class="gi">+                # Ordinal with categorical data and, if so, verify orderedness?</span>
<span class="gi">+                return Nominal(arg)</span>
<span class="gi">+            return Continuous(arg)</span>
<span class="gi">+</span>
<span class="gi">+        if callable(arg):</span>
<span class="gi">+            return Continuous(arg)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO Do we accept str like &quot;log&quot;, &quot;pow&quot;, etc. for semantics?</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(arg, str):</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;A single scale argument for {self.variable} variables must be&quot;,</span>
<span class="gi">+                f&quot;a string, dict, tuple, list, or callable, not {type(arg)}.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        if arg in QUAL_PALETTES:</span>
<span class="gi">+            return Nominal(arg)</span>
<span class="gi">+        elif var_type == &quot;numeric&quot;:</span>
<span class="gi">+            return Continuous(arg)</span>
<span class="gi">+        # TODO implement scales for date variables and any others.</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Nominal(arg)</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping(self, scale: Scale, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps from data domain to color values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_values(self, scale: Scale, levels: list) -&gt;ArrayLike:</span>
<span class="gi">+        # TODO what is best way to do this conditional?</span>
<span class="gi">+        # Should it be class-based or should classes have behavioral attributes?</span>
<span class="gi">+        if isinstance(scale, Nominal):</span>
<span class="gi">+            return self._get_nominal_mapping(scale, data)</span>
<span class="gi">+        elif isinstance(scale, Boolean):</span>
<span class="gi">+            return self._get_boolean_mapping(scale, data)</span>
<span class="gi">+</span>
<span class="gi">+        if scale.values is None:</span>
<span class="gi">+            # TODO Rethink best default continuous color gradient</span>
<span class="gi">+            mapping = color_palette(&quot;ch:&quot;, as_cmap=True)</span>
<span class="gi">+        elif isinstance(scale.values, tuple):</span>
<span class="gi">+            # TODO blend_palette will strip alpha, but we should support</span>
<span class="gi">+            # interpolation on all four channels</span>
<span class="gi">+            mapping = blend_palette(scale.values, as_cmap=True)</span>
<span class="gi">+        elif isinstance(scale.values, str):</span>
<span class="gi">+            # TODO for matplotlib colormaps this will clip extremes, which is</span>
<span class="gi">+            # different from what using the named colormap directly would do</span>
<span class="gi">+            # This may or may not be desireable.</span>
<span class="gi">+            mapping = color_palette(scale.values, as_cmap=True)</span>
<span class="gi">+        elif callable(scale.values):</span>
<span class="gi">+            mapping = scale.values</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale_class = scale.__class__.__name__</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;Scale values for {self.variable} with a {scale_class} mapping&quot;,</span>
<span class="gi">+                f&quot;must be string, tuple, or callable; not {type(scale.values)}.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        def _mapping(x):</span>
<span class="gi">+            # Remove alpha channel so it does not override alpha property downstream</span>
<span class="gi">+            # TODO this will need to be more flexible to support RGBA tuples (see above)</span>
<span class="gi">+            invalid = ~np.isfinite(x)</span>
<span class="gi">+            out = mapping(x)[:, :3]</span>
<span class="gi">+            out[invalid] = np.nan</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return _mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_nominal_mapping(self, scale: Nominal, data: Series) -&gt; Mapping:</span>
<span class="gi">+</span>
<span class="gi">+        levels = categorical_order(data, scale.order)</span>
<span class="gi">+        colors = self._get_values(scale, levels)</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            ixs = np.asarray(np.nan_to_num(x), np.intp)</span>
<span class="gi">+            use = np.isfinite(x)</span>
<span class="gi">+            out = np.full((len(ixs), colors.shape[1]), np.nan)</span>
<span class="gi">+            out[use] = np.take(colors, ixs[use], axis=0)</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_boolean_mapping(self, scale: Boolean, data: Series) -&gt; Mapping:</span>
<span class="gi">+</span>
<span class="gi">+        colors = self._get_values(scale, [True, False])</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+</span>
<span class="gi">+            use = np.isfinite(x)</span>
<span class="gi">+            x = np.asarray(np.nan_to_num(x)).astype(bool)</span>
<span class="gi">+            out = np.full((len(x), colors.shape[1]), np.nan)</span>
<span class="gi">+            out[x &amp; use] = colors[0]</span>
<span class="gi">+            out[~x &amp; use] = colors[1]</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_values(self, scale: Scale, levels: list) -&gt; ArrayLike:</span>
<span class="w"> </span>        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        n = len(levels)</span>
<span class="gi">+        values = scale.values</span>
<span class="gi">+        if isinstance(values, dict):</span>
<span class="gi">+            self._check_dict_entries(levels, values)</span>
<span class="gi">+            colors = [values[x] for x in levels]</span>
<span class="gi">+        elif isinstance(values, list):</span>
<span class="gi">+            colors = self._check_list_length(levels, values)</span>
<span class="gi">+        elif isinstance(values, tuple):</span>
<span class="gi">+            colors = blend_palette(values, n)</span>
<span class="gi">+        elif isinstance(values, str):</span>
<span class="gi">+            colors = color_palette(values, n)</span>
<span class="gi">+        elif values is None:</span>
<span class="gi">+            if n &lt;= len(get_color_cycle()):</span>
<span class="gi">+                # Use current (global) default palette</span>
<span class="gi">+                colors = color_palette(n_colors=n)</span>
<span class="gi">+            else:</span>
<span class="gi">+                colors = color_palette(&quot;husl&quot;, n)</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale_class = scale.__class__.__name__</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;Scale values for {self.variable} with a {scale_class} mapping&quot;,</span>
<span class="gi">+                f&quot;must be string, list, tuple, or dict; not {type(scale.values)}.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        return self._standardize_color_sequence(colors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Properties that can take only two states</span>
<span class="gi">+# =================================================================================== #</span>


<span class="w"> </span>class Fill(Property):
<span class="gu">@@ -263,25 +734,101 @@ class Fill(Property):</span>
<span class="w"> </span>    legend = True
<span class="w"> </span>    normed = False

<span class="gd">-    def _default_values(self, n: int) -&gt;list:</span>
<span class="gd">-        &quot;&quot;&quot;Return a list of n values, alternating True and False.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def default_scale(self, data: Series) -&gt; Scale:</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+        return Boolean() if var_type == &quot;boolean&quot; else Nominal()</span>
<span class="gi">+</span>
<span class="gi">+    def infer_scale(self, arg: Any, data: Series) -&gt; Scale:</span>
<span class="gi">+        var_type = variable_type(data, boolean_type=&quot;boolean&quot;, strict_boolean=True)</span>
<span class="gi">+        return Boolean(arg) if var_type == &quot;boolean&quot; else Nominal(arg)</span>

<span class="gd">-    def get_mapping(self, scale: Scale, data: Series) -&gt;Mapping:</span>
<span class="gi">+    def standardize(self, val: Any) -&gt; bool:</span>
<span class="gi">+        return bool(val)</span>
<span class="gi">+</span>
<span class="gi">+    def _default_values(self, n: int) -&gt; list:</span>
<span class="gi">+        &quot;&quot;&quot;Return a list of n values, alternating True and False.&quot;&quot;&quot;</span>
<span class="gi">+        if n &gt; 2:</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;The variable assigned to {self.variable} has more than two levels,&quot;,</span>
<span class="gi">+                f&quot;so {self.variable} values will cycle and may be uninterpretable&quot;,</span>
<span class="gi">+            ])</span>
<span class="gi">+            # TODO fire in a &quot;nice&quot; way (see above)</span>
<span class="gi">+            warnings.warn(msg, UserWarning)</span>
<span class="gi">+        return [x for x, _ in zip(itertools.cycle([True, False]), range(n))]</span>
<span class="gi">+</span>
<span class="gi">+    def get_mapping(self, scale: Scale, data: Series) -&gt; Mapping:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a function that maps each data value to True or False.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        boolean_scale = isinstance(scale, Boolean)</span>
<span class="gi">+        order = getattr(scale, &quot;order&quot;, [True, False] if boolean_scale else None)</span>
<span class="gi">+        levels = categorical_order(data, order)</span>
<span class="gi">+        values = self._get_values(scale, levels)</span>

<span class="gd">-    def _get_values(self, scale: Scale, levels: list) -&gt;list:</span>
<span class="gd">-        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if boolean_scale:</span>
<span class="gi">+            values = values[::-1]</span>
<span class="gi">+</span>
<span class="gi">+        def mapping(x):</span>
<span class="gi">+            ixs = np.asarray(np.nan_to_num(x), np.intp)</span>
<span class="gi">+            return [</span>
<span class="gi">+                values[ix] if np.isfinite(x_i) else False</span>
<span class="gi">+                for x_i, ix in zip(x, ixs)</span>
<span class="gi">+            ]</span>

<span class="gi">+        return mapping</span>
<span class="gi">+</span>
<span class="gi">+    def _get_values(self, scale: Scale, levels: list) -&gt; list:</span>
<span class="gi">+        &quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(scale.values, list):</span>
<span class="gi">+            values = [bool(x) for x in scale.values]</span>
<span class="gi">+        elif isinstance(scale.values, dict):</span>
<span class="gi">+            values = [bool(scale.values[x]) for x in levels]</span>
<span class="gi">+        elif scale.values is None:</span>
<span class="gi">+            values = self._default_values(len(levels))</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;Scale values for {self.variable} must be passed in&quot;,</span>
<span class="gi">+                f&quot;a list or dict; not {type(scale.values)}.&quot;</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# Enumeration of properties for use by Plot and Mark classes</span>
<span class="gi">+# =================================================================================== #</span>
<span class="gi">+# TODO turn this into a property registry with hooks, etc.</span>
<span class="gi">+# TODO Users do not interact directly with properties, so how to document them?</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+PROPERTY_CLASSES = {</span>
<span class="gi">+    &quot;x&quot;: Coordinate,</span>
<span class="gi">+    &quot;y&quot;: Coordinate,</span>
<span class="gi">+    &quot;color&quot;: Color,</span>
<span class="gi">+    &quot;alpha&quot;: Alpha,</span>
<span class="gi">+    &quot;fill&quot;: Fill,</span>
<span class="gi">+    &quot;marker&quot;: Marker,</span>
<span class="gi">+    &quot;pointsize&quot;: PointSize,</span>
<span class="gi">+    &quot;stroke&quot;: Stroke,</span>
<span class="gi">+    &quot;linewidth&quot;: LineWidth,</span>
<span class="gi">+    &quot;linestyle&quot;: LineStyle,</span>
<span class="gi">+    &quot;fillcolor&quot;: Color,</span>
<span class="gi">+    &quot;fillalpha&quot;: Alpha,</span>
<span class="gi">+    &quot;edgewidth&quot;: EdgeWidth,</span>
<span class="gi">+    &quot;edgestyle&quot;: LineStyle,</span>
<span class="gi">+    &quot;edgecolor&quot;: Color,</span>
<span class="gi">+    &quot;edgealpha&quot;: Alpha,</span>
<span class="gi">+    &quot;text&quot;: Property,</span>
<span class="gi">+    &quot;halign&quot;: HorizontalAlignment,</span>
<span class="gi">+    &quot;valign&quot;: VerticalAlignment,</span>
<span class="gi">+    &quot;offset&quot;: Offset,</span>
<span class="gi">+    &quot;fontsize&quot;: FontSize,</span>
<span class="gi">+    &quot;xmin&quot;: Coordinate,</span>
<span class="gi">+    &quot;xmax&quot;: Coordinate,</span>
<span class="gi">+    &quot;ymin&quot;: Coordinate,</span>
<span class="gi">+    &quot;ymax&quot;: Coordinate,</span>
<span class="gi">+    &quot;group&quot;: Property,</span>
<span class="gi">+    # TODO pattern?</span>
<span class="gi">+    # TODO gradient?</span>
<span class="gi">+}</span>

<span class="gd">-PROPERTY_CLASSES = {&#39;x&#39;: Coordinate, &#39;y&#39;: Coordinate, &#39;color&#39;: Color,</span>
<span class="gd">-    &#39;alpha&#39;: Alpha, &#39;fill&#39;: Fill, &#39;marker&#39;: Marker, &#39;pointsize&#39;: PointSize,</span>
<span class="gd">-    &#39;stroke&#39;: Stroke, &#39;linewidth&#39;: LineWidth, &#39;linestyle&#39;: LineStyle,</span>
<span class="gd">-    &#39;fillcolor&#39;: Color, &#39;fillalpha&#39;: Alpha, &#39;edgewidth&#39;: EdgeWidth,</span>
<span class="gd">-    &#39;edgestyle&#39;: LineStyle, &#39;edgecolor&#39;: Color, &#39;edgealpha&#39;: Alpha, &#39;text&#39;:</span>
<span class="gd">-    Property, &#39;halign&#39;: HorizontalAlignment, &#39;valign&#39;: VerticalAlignment,</span>
<span class="gd">-    &#39;offset&#39;: Offset, &#39;fontsize&#39;: FontSize, &#39;xmin&#39;: Coordinate, &#39;xmax&#39;:</span>
<span class="gd">-    Coordinate, &#39;ymin&#39;: Coordinate, &#39;ymax&#39;: Coordinate, &#39;group&#39;: Property}</span>
<span class="w"> </span>PROPERTIES = {var: cls(var) for var, cls in PROPERTY_CLASSES.items()}
<span class="gh">diff --git a/seaborn/_core/rules.py b/seaborn/_core/rules.py</span>
<span class="gh">index d78093c0..de6c651d 100644</span>
<span class="gd">--- a/seaborn/_core/rules.py</span>
<span class="gi">+++ b/seaborn/_core/rules.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from collections import UserString
<span class="w"> </span>from numbers import Number
<span class="w"> </span>from datetime import datetime
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Literal
<span class="gu">@@ -19,7 +22,9 @@ class VarType(UserString):</span>
<span class="w"> </span>    them. If that changes, they should be more verbose.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    allowed = &#39;numeric&#39;, &#39;datetime&#39;, &#39;categorical&#39;, &#39;boolean&#39;, &#39;unknown&#39;</span>
<span class="gi">+    # TODO VarType is an awfully overloaded name, but so is DataType ...</span>
<span class="gi">+    # TODO adding unknown because we are using this in for scales, is that right?</span>
<span class="gi">+    allowed = &quot;numeric&quot;, &quot;datetime&quot;, &quot;categorical&quot;, &quot;boolean&quot;, &quot;unknown&quot;</span>

<span class="w"> </span>    def __init__(self, data):
<span class="w"> </span>        assert data in self.allowed, data
<span class="gu">@@ -30,8 +35,11 @@ class VarType(UserString):</span>
<span class="w"> </span>        return self.data == other


<span class="gd">-def variable_type(vector: Series, boolean_type: Literal[&#39;numeric&#39;,</span>
<span class="gd">-    &#39;categorical&#39;, &#39;boolean&#39;]=&#39;numeric&#39;, strict_boolean: bool=False) -&gt;VarType:</span>
<span class="gi">+def variable_type(</span>
<span class="gi">+    vector: Series,</span>
<span class="gi">+    boolean_type: Literal[&quot;numeric&quot;, &quot;categorical&quot;, &quot;boolean&quot;] = &quot;numeric&quot;,</span>
<span class="gi">+    strict_boolean: bool = False,</span>
<span class="gi">+) -&gt; VarType:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine whether a vector contains numeric, categorical, or datetime data.

<span class="gu">@@ -57,10 +65,84 @@ def variable_type(vector: Series, boolean_type: Literal[&#39;numeric&#39;,</span>
<span class="w"> </span>    var_type : &#39;numeric&#39;, &#39;categorical&#39;, or &#39;datetime&#39;
<span class="w"> </span>        Name identifying the type of data in the vector.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-def categorical_order(vector: Series, order: (list | None)=None) -&gt;list:</span>
<span class="gi">+    # If a categorical dtype is set, infer categorical</span>
<span class="gi">+    if isinstance(getattr(vector, &#39;dtype&#39;, None), pd.CategoricalDtype):</span>
<span class="gi">+        return VarType(&quot;categorical&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Special-case all-na data, which is always &quot;numeric&quot;</span>
<span class="gi">+    if pd.isna(vector).all():</span>
<span class="gi">+        return VarType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Now drop nulls to simplify further type inference</span>
<span class="gi">+    vector = vector.dropna()</span>
<span class="gi">+</span>
<span class="gi">+    # Special-case binary/boolean data, allow caller to determine</span>
<span class="gi">+    # This triggers a numpy warning when vector has strings/objects</span>
<span class="gi">+    # https://github.com/numpy/numpy/issues/6784</span>
<span class="gi">+    # Because we reduce with .all(), we are agnostic about whether the</span>
<span class="gi">+    # comparison returns a scalar or vector, so we will ignore the warning.</span>
<span class="gi">+    # It triggers a separate DeprecationWarning when the vector has datetimes:</span>
<span class="gi">+    # https://github.com/numpy/numpy/issues/13548</span>
<span class="gi">+    # This is considered a bug by numpy and will likely go away.</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.simplefilter(</span>
<span class="gi">+            action=&#39;ignore&#39;,</span>
<span class="gi">+            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?</span>
<span class="gi">+        )</span>
<span class="gi">+        if strict_boolean:</span>
<span class="gi">+            if isinstance(vector.dtype, pd.core.dtypes.base.ExtensionDtype):</span>
<span class="gi">+                boolean_dtypes = [&quot;bool&quot;, &quot;boolean&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                boolean_dtypes = [&quot;bool&quot;]</span>
<span class="gi">+            boolean_vector = vector.dtype in boolean_dtypes</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                boolean_vector = bool(np.isin(vector, [0, 1]).all())</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                # .isin comparison is not guaranteed to be possible under NumPy</span>
<span class="gi">+                # casting rules, depending on the (unknown) dtype of &#39;vector&#39;</span>
<span class="gi">+                boolean_vector = False</span>
<span class="gi">+        if boolean_vector:</span>
<span class="gi">+            return VarType(boolean_type)</span>
<span class="gi">+</span>
<span class="gi">+    # Defer to positive pandas tests</span>
<span class="gi">+    if pd.api.types.is_numeric_dtype(vector):</span>
<span class="gi">+        return VarType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if pd.api.types.is_datetime64_dtype(vector):</span>
<span class="gi">+        return VarType(&quot;datetime&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # --- If we get to here, we need to check the entries</span>
<span class="gi">+</span>
<span class="gi">+    # Check for a collection where everything is a number</span>
<span class="gi">+</span>
<span class="gi">+    def all_numeric(x):</span>
<span class="gi">+        for x_i in x:</span>
<span class="gi">+            if not isinstance(x_i, Number):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if all_numeric(vector):</span>
<span class="gi">+        return VarType(&quot;numeric&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Check for a collection where everything is a datetime</span>
<span class="gi">+</span>
<span class="gi">+    def all_datetime(x):</span>
<span class="gi">+        for x_i in x:</span>
<span class="gi">+            if not isinstance(x_i, (datetime, np.datetime64)):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if all_datetime(vector):</span>
<span class="gi">+        return VarType(&quot;datetime&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, our final fallback is to consider things categorical</span>
<span class="gi">+</span>
<span class="gi">+    return VarType(&quot;categorical&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def categorical_order(vector: Series, order: list | None = None) -&gt; list:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a list of unique data values using seaborn&#39;s ordering rules.

<span class="gu">@@ -78,4 +160,14 @@ def categorical_order(vector: Series, order: (list | None)=None) -&gt;list:</span>
<span class="w"> </span>        Ordered list of category levels not including null values.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if order is not None:</span>
<span class="gi">+        return order</span>
<span class="gi">+</span>
<span class="gi">+    if vector.dtype.name == &quot;category&quot;:</span>
<span class="gi">+        order = list(vector.cat.categories)</span>
<span class="gi">+    else:</span>
<span class="gi">+        order = list(filter(pd.notnull, vector.unique()))</span>
<span class="gi">+        if variable_type(pd.Series(order)) == &quot;numeric&quot;:</span>
<span class="gi">+            order.sort()</span>
<span class="gi">+</span>
<span class="gi">+    return order</span>
<span class="gh">diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py</span>
<span class="gh">index 99f98988..1e7bef8a 100644</span>
<span class="gd">--- a/seaborn/_core/scales.py</span>
<span class="gi">+++ b/seaborn/_core/scales.py</span>
<span class="gu">@@ -5,28 +5,58 @@ from collections.abc import Sequence</span>
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from functools import partial
<span class="w"> </span>from typing import Any, Callable, Tuple, Optional, ClassVar
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gd">-from matplotlib.ticker import Locator, Formatter, AutoLocator, AutoMinorLocator, FixedLocator, LinearLocator, LogLocator, SymmetricalLogLocator, MaxNLocator, MultipleLocator, EngFormatter, FuncFormatter, LogFormatterSciNotation, ScalarFormatter, StrMethodFormatter</span>
<span class="gd">-from matplotlib.dates import AutoDateLocator, AutoDateFormatter, ConciseDateFormatter</span>
<span class="gi">+from matplotlib.ticker import (</span>
<span class="gi">+    Locator,</span>
<span class="gi">+    Formatter,</span>
<span class="gi">+    AutoLocator,</span>
<span class="gi">+    AutoMinorLocator,</span>
<span class="gi">+    FixedLocator,</span>
<span class="gi">+    LinearLocator,</span>
<span class="gi">+    LogLocator,</span>
<span class="gi">+    SymmetricalLogLocator,</span>
<span class="gi">+    MaxNLocator,</span>
<span class="gi">+    MultipleLocator,</span>
<span class="gi">+    EngFormatter,</span>
<span class="gi">+    FuncFormatter,</span>
<span class="gi">+    LogFormatterSciNotation,</span>
<span class="gi">+    ScalarFormatter,</span>
<span class="gi">+    StrMethodFormatter,</span>
<span class="gi">+)</span>
<span class="gi">+from matplotlib.dates import (</span>
<span class="gi">+    AutoDateLocator,</span>
<span class="gi">+    AutoDateFormatter,</span>
<span class="gi">+    ConciseDateFormatter,</span>
<span class="gi">+)</span>
<span class="w"> </span>from matplotlib.axis import Axis
<span class="w"> </span>from matplotlib.scale import ScaleBase
<span class="w"> </span>from pandas import Series
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.rules import categorical_order
<span class="w"> </span>from seaborn._core.typing import Default, default
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from seaborn._core.plot import Plot
<span class="w"> </span>    from seaborn._core.properties import Property
<span class="w"> </span>    from numpy.typing import ArrayLike, NDArray
<span class="gd">-    TransFuncs = Tuple[Callable[[ArrayLike], ArrayLike], Callable[[</span>
<span class="gd">-        ArrayLike], ArrayLike]]</span>
<span class="gi">+</span>
<span class="gi">+    TransFuncs = Tuple[</span>
<span class="gi">+        Callable[[ArrayLike], ArrayLike], Callable[[ArrayLike], ArrayLike]</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # TODO Reverting typing to Any as it was proving too complicated to</span>
<span class="gi">+    # work out the right way to communicate the types to mypy. Revisit!</span>
<span class="w"> </span>    Pipeline = Sequence[Optional[Callable[[Any], Any]]]


<span class="w"> </span>class Scale:
<span class="w"> </span>    &quot;&quot;&quot;Base class for objects that map data values to visual properties.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    values: tuple | str | list | dict | None
<span class="gi">+</span>
<span class="w"> </span>    _priority: ClassVar[int]
<span class="w"> </span>    _pipeline: Pipeline
<span class="w"> </span>    _matplotlib_scale: ScaleBase
<span class="gu">@@ -34,29 +64,86 @@ class Scale:</span>
<span class="w"> </span>    _legend: tuple[list[Any], list[str]] | None

<span class="w"> </span>    def __post_init__(self):
<span class="gi">+</span>
<span class="w"> </span>        self._tick_params = None
<span class="w"> </span>        self._label_params = None
<span class="w"> </span>        self._legend = None

<span class="gd">-    def _finalize(self, p: Plot, axis: Axis) -&gt;None:</span>
<span class="gi">+    def tick(self):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def label(self):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locators(self):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatter(self, locator: Locator | None = None):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_scale(self, name: str, forward: Callable, inverse: Callable):</span>
<span class="gi">+</span>
<span class="gi">+        major_locator, minor_locator = self._get_locators(**self._tick_params)</span>
<span class="gi">+        major_formatter = self._get_formatter(major_locator, **self._label_params)</span>
<span class="gi">+</span>
<span class="gi">+        class InternalScale(mpl.scale.FuncScale):</span>
<span class="gi">+            def set_default_locators_and_formatters(self, axis):</span>
<span class="gi">+                axis.set_major_locator(major_locator)</span>
<span class="gi">+                if minor_locator is not None:</span>
<span class="gi">+                    axis.set_minor_locator(minor_locator)</span>
<span class="gi">+                axis.set_major_formatter(major_formatter)</span>
<span class="gi">+</span>
<span class="gi">+        return InternalScale(name, (forward, inverse))</span>
<span class="gi">+</span>
<span class="gi">+    def _spacing(self, x: Series) -&gt; float:</span>
<span class="gi">+        space = self._spacer(x)</span>
<span class="gi">+        if np.isnan(space):</span>
<span class="gi">+            # This happens when there is no variance in the orient coordinate data</span>
<span class="gi">+            # Not exactly clear what the right default is, but 1 seems reasonable?</span>
<span class="gi">+            return 1</span>
<span class="gi">+        return space</span>
<span class="gi">+</span>
<span class="gi">+    def _setup(</span>
<span class="gi">+        self, data: Series, prop: Property, axis: Axis | None = None,</span>
<span class="gi">+    ) -&gt; Scale:</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _finalize(self, p: Plot, axis: Axis) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform scale-specific axis tweaks after adding artists.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gd">-    def __call__(self, data: Series) -&gt;ArrayLike:</span>
<span class="gi">+    def __call__(self, data: Series) -&gt; ArrayLike:</span>
<span class="gi">+</span>
<span class="w"> </span>        trans_data: Series | NDArray | list
<span class="gi">+</span>
<span class="gi">+        # TODO sometimes we need to handle scalars (e.g. for Line)</span>
<span class="gi">+        # but what is the best way to do that?</span>
<span class="w"> </span>        scalar_data = np.isscalar(data)
<span class="w"> </span>        if scalar_data:
<span class="w"> </span>            trans_data = np.array([data])
<span class="w"> </span>        else:
<span class="w"> </span>            trans_data = data
<span class="gi">+</span>
<span class="w"> </span>        for func in self._pipeline:
<span class="w"> </span>            if func is not None:
<span class="w"> </span>                trans_data = func(trans_data)
<span class="gi">+</span>
<span class="w"> </span>        if scalar_data:
<span class="w"> </span>            return trans_data[0]
<span class="w"> </span>        else:
<span class="w"> </span>            return trans_data

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _identity():</span>
<span class="gi">+</span>
<span class="gi">+        class Identity(Scale):</span>
<span class="gi">+            _pipeline = []</span>
<span class="gi">+            _spacer = None</span>
<span class="gi">+            _legend = None</span>
<span class="gi">+            _matplotlib_scale = None</span>
<span class="gi">+</span>
<span class="gi">+        return Identity()</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass
<span class="w"> </span>class Boolean(Scale):
<span class="gu">@@ -71,19 +158,183 @@ class Boolean(Scale):</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    values: tuple | list | dict | None = None
<span class="gi">+</span>
<span class="w"> </span>    _priority: ClassVar[int] = 3

<span class="gi">+    def _setup(</span>
<span class="gi">+        self, data: Series, prop: Property, axis: Axis | None = None,</span>
<span class="gi">+    ) -&gt; Scale:</span>
<span class="gi">+</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        if new._tick_params is None:</span>
<span class="gi">+            new = new.tick()</span>
<span class="gi">+        if new._label_params is None:</span>
<span class="gi">+            new = new.label()</span>
<span class="gi">+</span>
<span class="gi">+        def na_safe_cast(x):</span>
<span class="gi">+            # TODO this doesn&#39;t actually need to be a closure</span>
<span class="gi">+            if np.isscalar(x):</span>
<span class="gi">+                return float(bool(x))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if hasattr(x, &quot;notna&quot;):</span>
<span class="gi">+                    # Handle pd.NA; np&lt;&gt;pd interop with NA is tricky</span>
<span class="gi">+                    use = x.notna().to_numpy()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    use = np.isfinite(x)</span>
<span class="gi">+                out = np.full(len(x), np.nan, dtype=float)</span>
<span class="gi">+                out[use] = x[use].astype(bool).astype(float)</span>
<span class="gi">+                return out</span>
<span class="gi">+</span>
<span class="gi">+        new._pipeline = [na_safe_cast, prop.get_mapping(new, data)]</span>
<span class="gi">+        new._spacer = _default_spacer</span>
<span class="gi">+        if prop.legend:</span>
<span class="gi">+            new._legend = [True, False], [&quot;True&quot;, &quot;False&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        forward, inverse = _make_identity_transforms()</span>
<span class="gi">+        mpl_scale = new._get_scale(str(data.name), forward, inverse)</span>
<span class="gi">+</span>
<span class="gi">+        axis = PseudoAxis(mpl_scale) if axis is None else axis</span>
<span class="gi">+        mpl_scale.set_default_locators_and_formatters(axis)</span>
<span class="gi">+        new._matplotlib_scale = mpl_scale</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _finalize(self, p: Plot, axis: Axis) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        # We want values to appear in a True, False order but also want</span>
<span class="gi">+        # True/False to be drawn at 1/0 positions respectively to avoid nasty</span>
<span class="gi">+        # surprises if additional artists are added through the matplotlib API.</span>
<span class="gi">+        # We accomplish this using axis inversion akin to what we do in Nominal.</span>
<span class="gi">+</span>
<span class="gi">+        ax = axis.axes</span>
<span class="gi">+        name = axis.axis_name</span>
<span class="gi">+        axis.grid(False, which=&quot;both&quot;)</span>
<span class="gi">+        if name not in p._limits:</span>
<span class="gi">+            nticks = len(axis.get_major_ticks())</span>
<span class="gi">+            lo, hi = -.5, nticks - .5</span>
<span class="gi">+            if name == &quot;x&quot;:</span>
<span class="gi">+                lo, hi = hi, lo</span>
<span class="gi">+            set_lim = getattr(ax, f&quot;set_{name}lim&quot;)</span>
<span class="gi">+            set_lim(lo, hi, auto=None)</span>
<span class="gi">+</span>
<span class="gi">+    def tick(self, locator: Locator | None = None):</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._tick_params = {&quot;locator&quot;: locator}</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def label(self, formatter: Formatter | None = None):</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._label_params = {&quot;formatter&quot;: formatter}</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locators(self, locator):</span>
<span class="gi">+        if locator is not None:</span>
<span class="gi">+            return locator</span>
<span class="gi">+        return FixedLocator([0, 1]), None</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatter(self, locator, formatter):</span>
<span class="gi">+        if formatter is not None:</span>
<span class="gi">+            return formatter</span>
<span class="gi">+        return FuncFormatter(lambda x, _: str(bool(x)))</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass
<span class="w"> </span>class Nominal(Scale):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A categorical scale without relative importance / magnitude.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # Categorical (convert to strings), un-sortable</span>
<span class="gi">+</span>
<span class="w"> </span>    values: tuple | str | list | dict | None = None
<span class="w"> </span>    order: list | None = None
<span class="gi">+</span>
<span class="w"> </span>    _priority: ClassVar[int] = 4

<span class="gd">-    def tick(self, locator: (Locator | None)=None) -&gt;Nominal:</span>
<span class="gi">+    def _setup(</span>
<span class="gi">+        self, data: Series, prop: Property, axis: Axis | None = None,</span>
<span class="gi">+    ) -&gt; Scale:</span>
<span class="gi">+</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        if new._tick_params is None:</span>
<span class="gi">+            new = new.tick()</span>
<span class="gi">+        if new._label_params is None:</span>
<span class="gi">+            new = new.label()</span>
<span class="gi">+</span>
<span class="gi">+        # TODO flexibility over format() which isn&#39;t great for numbers / dates</span>
<span class="gi">+        stringify = np.vectorize(format, otypes=[&quot;object&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        units_seed = categorical_order(data, new.order)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO move to Nominal._get_scale?</span>
<span class="gi">+        # TODO this needs some more complicated rethinking about how to pass</span>
<span class="gi">+        # a unit dictionary down to these methods, along with how much we want</span>
<span class="gi">+        # to invest in their API. What is it useful for tick() to do here?</span>
<span class="gi">+        # (Ordinal may be different if we draw that contrast).</span>
<span class="gi">+        # Any customization we do to allow, e.g., label wrapping will probably</span>
<span class="gi">+        # require defining our own Formatter subclass.</span>
<span class="gi">+        # We could also potentially implement auto-wrapping in an Axis subclass</span>
<span class="gi">+        # (see Axis.draw ... it already is computing the bboxes).</span>
<span class="gi">+        # major_locator, minor_locator = new._get_locators(**new._tick_params)</span>
<span class="gi">+        # major_formatter = new._get_formatter(major_locator, **new._label_params)</span>
<span class="gi">+</span>
<span class="gi">+        class CatScale(mpl.scale.LinearScale):</span>
<span class="gi">+            def set_default_locators_and_formatters(self, axis):</span>
<span class="gi">+                ...</span>
<span class="gi">+                # axis.set_major_locator(major_locator)</span>
<span class="gi">+                # if minor_locator is not None:</span>
<span class="gi">+                #     axis.set_minor_locator(minor_locator)</span>
<span class="gi">+                # axis.set_major_formatter(major_formatter)</span>
<span class="gi">+</span>
<span class="gi">+        mpl_scale = CatScale(data.name)</span>
<span class="gi">+        if axis is None:</span>
<span class="gi">+            axis = PseudoAxis(mpl_scale)</span>
<span class="gi">+</span>
<span class="gi">+            # TODO Currently just used in non-Coordinate contexts, but should</span>
<span class="gi">+            # we use this to (A) set the padding we want for categorial plots</span>
<span class="gi">+            # and (B) allow the values parameter for a Coordinate to set xlim/ylim</span>
<span class="gi">+            axis.set_view_interval(0, len(units_seed) - 1)</span>
<span class="gi">+</span>
<span class="gi">+        new._matplotlib_scale = mpl_scale</span>
<span class="gi">+</span>
<span class="gi">+        # TODO array cast necessary to handle float/int mixture, which we need</span>
<span class="gi">+        # to solve in a more systematic way probably</span>
<span class="gi">+        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)</span>
<span class="gi">+        axis.update_units(stringify(np.array(units_seed)))</span>
<span class="gi">+</span>
<span class="gi">+        # TODO define this more centrally</span>
<span class="gi">+        def convert_units(x):</span>
<span class="gi">+            # TODO only do this with explicit order?</span>
<span class="gi">+            # (But also category dtype?)</span>
<span class="gi">+            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)</span>
<span class="gi">+            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)</span>
<span class="gi">+            # keep = x.isin(units_seed)</span>
<span class="gi">+            keep = np.array([x_ in units_seed for x_ in x], bool)</span>
<span class="gi">+            out = np.full(len(x), np.nan)</span>
<span class="gi">+            out[keep] = axis.convert_units(stringify(x[keep]))</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        new._pipeline = [convert_units, prop.get_mapping(new, data)]</span>
<span class="gi">+        new._spacer = _default_spacer</span>
<span class="gi">+</span>
<span class="gi">+        if prop.legend:</span>
<span class="gi">+            new._legend = units_seed, list(stringify(units_seed))</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _finalize(self, p: Plot, axis: Axis) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        ax = axis.axes</span>
<span class="gi">+        name = axis.axis_name</span>
<span class="gi">+        axis.grid(False, which=&quot;both&quot;)</span>
<span class="gi">+        if name not in p._limits:</span>
<span class="gi">+            nticks = len(axis.get_major_ticks())</span>
<span class="gi">+            lo, hi = -.5, nticks - .5</span>
<span class="gi">+            if name == &quot;y&quot;:</span>
<span class="gi">+                lo, hi = hi, lo</span>
<span class="gi">+            set_lim = getattr(ax, f&quot;set_{name}lim&quot;)</span>
<span class="gi">+            set_lim(lo, hi, auto=None)</span>
<span class="gi">+</span>
<span class="gi">+    def tick(self, locator: Locator | None = None) -&gt; Nominal:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the selection of ticks for the scale&#39;s axis or legend.

<span class="gu">@@ -101,9 +352,11 @@ class Nominal(Scale):</span>
<span class="w"> </span>        Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._tick_params = {&quot;locator&quot;: locator}</span>
<span class="gi">+        return new</span>

<span class="gd">-    def label(self, formatter: (Formatter | None)=None) -&gt;Nominal:</span>
<span class="gi">+    def label(self, formatter: Formatter | None = None) -&gt; Nominal:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the selection of labels for the scale&#39;s axis or legend.

<span class="gu">@@ -122,24 +375,152 @@ class Nominal(Scale):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._label_params = {&quot;formatter&quot;: formatter}</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locators(self, locator):</span>
<span class="gi">+</span>
<span class="gi">+        if locator is not None:</span>
<span class="gi">+            return locator, None</span>
<span class="gi">+</span>
<span class="gi">+        locator = mpl.category.StrCategoryLocator({})</span>
<span class="gi">+</span>
<span class="gi">+        return locator, None</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatter(self, locator, formatter):</span>
<span class="gi">+</span>
<span class="gi">+        if formatter is not None:</span>
<span class="gi">+            return formatter</span>
<span class="gi">+</span>
<span class="gi">+        formatter = mpl.category.StrCategoryFormatter({})</span>
<span class="gi">+</span>
<span class="gi">+        return formatter</span>


<span class="w"> </span>@dataclass
<span class="w"> </span>class Ordinal(Scale):
<span class="gi">+    # Categorical (convert to strings), sortable, can skip ticklabels</span>
<span class="w"> </span>    ...


<span class="w"> </span>@dataclass
<span class="w"> </span>class Discrete(Scale):
<span class="gi">+    # Numeric, integral, can skip ticks/ticklabels</span>
<span class="w"> </span>    ...


<span class="w"> </span>@dataclass
<span class="w"> </span>class ContinuousBase(Scale):
<span class="gi">+</span>
<span class="w"> </span>    values: tuple | str | None = None
<span class="w"> </span>    norm: tuple | None = None

<span class="gi">+    def _setup(</span>
<span class="gi">+        self, data: Series, prop: Property, axis: Axis | None = None,</span>
<span class="gi">+    ) -&gt; Scale:</span>
<span class="gi">+</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        if new._tick_params is None:</span>
<span class="gi">+            new = new.tick()</span>
<span class="gi">+        if new._label_params is None:</span>
<span class="gi">+            new = new.label()</span>
<span class="gi">+</span>
<span class="gi">+        forward, inverse = new._get_transform()</span>
<span class="gi">+</span>
<span class="gi">+        mpl_scale = new._get_scale(str(data.name), forward, inverse)</span>
<span class="gi">+</span>
<span class="gi">+        if axis is None:</span>
<span class="gi">+            axis = PseudoAxis(mpl_scale)</span>
<span class="gi">+            axis.update_units(data)</span>
<span class="gi">+</span>
<span class="gi">+        mpl_scale.set_default_locators_and_formatters(axis)</span>
<span class="gi">+        new._matplotlib_scale = mpl_scale</span>
<span class="gi">+</span>
<span class="gi">+        normalize: Optional[Callable[[ArrayLike], ArrayLike]]</span>
<span class="gi">+        if prop.normed:</span>
<span class="gi">+            if new.norm is None:</span>
<span class="gi">+                vmin, vmax = data.min(), data.max()</span>
<span class="gi">+            else:</span>
<span class="gi">+                vmin, vmax = new.norm</span>
<span class="gi">+            vmin, vmax = map(float, axis.convert_units((vmin, vmax)))</span>
<span class="gi">+            a = forward(vmin)</span>
<span class="gi">+            b = forward(vmax) - forward(vmin)</span>
<span class="gi">+</span>
<span class="gi">+            def normalize(x):</span>
<span class="gi">+                return (x - a) / b</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            normalize = vmin = vmax = None</span>
<span class="gi">+</span>
<span class="gi">+        new._pipeline = [</span>
<span class="gi">+            axis.convert_units,</span>
<span class="gi">+            forward,</span>
<span class="gi">+            normalize,</span>
<span class="gi">+            prop.get_mapping(new, data)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        def spacer(x):</span>
<span class="gi">+            x = x.dropna().unique()</span>
<span class="gi">+            if len(x) &lt; 2:</span>
<span class="gi">+                return np.nan</span>
<span class="gi">+            return np.min(np.diff(np.sort(x)))</span>
<span class="gi">+        new._spacer = spacer</span>
<span class="gi">+</span>
<span class="gi">+        # TODO How to allow disabling of legend for all uses of property?</span>
<span class="gi">+        # Could add a Scale parameter, or perhaps Scale.suppress()?</span>
<span class="gi">+        # Are there other useful parameters that would be in Scale.legend()</span>
<span class="gi">+        # besides allowing Scale.legend(False)?</span>
<span class="gi">+        if prop.legend:</span>
<span class="gi">+            axis.set_view_interval(vmin, vmax)</span>
<span class="gi">+            locs = axis.major.locator()</span>
<span class="gi">+            locs = locs[(vmin &lt;= locs) &amp; (locs &lt;= vmax)]</span>
<span class="gi">+            # Avoid having an offset / scientific notation in a legend</span>
<span class="gi">+            # as we don&#39;t represent that anywhere so it ends up incorrect.</span>
<span class="gi">+            # This could become an option (e.g. Continuous.label(offset=True))</span>
<span class="gi">+            # in which case we would need to figure out how to show it.</span>
<span class="gi">+            if hasattr(axis.major.formatter, &quot;set_useOffset&quot;):</span>
<span class="gi">+                axis.major.formatter.set_useOffset(False)</span>
<span class="gi">+            if hasattr(axis.major.formatter, &quot;set_scientific&quot;):</span>
<span class="gi">+                axis.major.formatter.set_scientific(False)</span>
<span class="gi">+            labels = axis.major.formatter.format_ticks(locs)</span>
<span class="gi">+            new._legend = list(locs), list(labels)</span>
<span class="gi">+</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _get_transform(self):</span>
<span class="gi">+</span>
<span class="gi">+        arg = self.trans</span>
<span class="gi">+</span>
<span class="gi">+        def get_param(method, default):</span>
<span class="gi">+            if arg == method:</span>
<span class="gi">+                return default</span>
<span class="gi">+            return float(arg[len(method):])</span>
<span class="gi">+</span>
<span class="gi">+        if arg is None:</span>
<span class="gi">+            return _make_identity_transforms()</span>
<span class="gi">+        elif isinstance(arg, tuple):</span>
<span class="gi">+            return arg</span>
<span class="gi">+        elif isinstance(arg, str):</span>
<span class="gi">+            if arg == &quot;ln&quot;:</span>
<span class="gi">+                return _make_log_transforms()</span>
<span class="gi">+            elif arg == &quot;logit&quot;:</span>
<span class="gi">+                base = get_param(&quot;logit&quot;, 10)</span>
<span class="gi">+                return _make_logit_transforms(base)</span>
<span class="gi">+            elif arg.startswith(&quot;log&quot;):</span>
<span class="gi">+                base = get_param(&quot;log&quot;, 10)</span>
<span class="gi">+                return _make_log_transforms(base)</span>
<span class="gi">+            elif arg.startswith(&quot;symlog&quot;):</span>
<span class="gi">+                c = get_param(&quot;symlog&quot;, 1)</span>
<span class="gi">+                return _make_symlog_transforms(c)</span>
<span class="gi">+            elif arg.startswith(&quot;pow&quot;):</span>
<span class="gi">+                exp = get_param(&quot;pow&quot;, 2)</span>
<span class="gi">+                return _make_power_transforms(exp)</span>
<span class="gi">+            elif arg == &quot;sqrt&quot;:</span>
<span class="gi">+                return _make_sqrt_transforms()</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Unknown value provided for trans: {arg!r}&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>@dataclass
<span class="w"> </span>class Continuous(ContinuousBase):
<span class="gu">@@ -148,12 +529,22 @@ class Continuous(ContinuousBase):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    values: tuple | str | None = None
<span class="w"> </span>    trans: str | TransFuncs | None = None
<span class="gi">+</span>
<span class="gi">+    # TODO Add this to deal with outliers?</span>
<span class="gi">+    # outside: Literal[&quot;keep&quot;, &quot;drop&quot;, &quot;clip&quot;] = &quot;keep&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    _priority: ClassVar[int] = 1

<span class="gd">-    def tick(self, locator: (Locator | None)=None, *, at: (Sequence[float] |</span>
<span class="gd">-        None)=None, upto: (int | None)=None, count: (int | None)=None,</span>
<span class="gd">-        every: (float | None)=None, between: (tuple[float, float] | None)=</span>
<span class="gd">-        None, minor: (int | None)=None) -&gt;Continuous:</span>
<span class="gi">+    def tick(</span>
<span class="gi">+        self,</span>
<span class="gi">+        locator: Locator | None = None, *,</span>
<span class="gi">+        at: Sequence[float] | None = None,</span>
<span class="gi">+        upto: int | None = None,</span>
<span class="gi">+        count: int | None = None,</span>
<span class="gi">+        every: float | None = None,</span>
<span class="gi">+        between: tuple[float, float] | None = None,</span>
<span class="gi">+        minor: int | None = None,</span>
<span class="gi">+    ) -&gt; Continuous:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the selection of ticks for the scale&#39;s axis or legend.

<span class="gu">@@ -180,11 +571,38 @@ class Continuous(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Input checks</span>
<span class="gi">+        if locator is not None and not isinstance(locator, Locator):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;Tick locator must be an instance of {Locator!r}, &quot;</span>
<span class="gi">+                f&quot;not {type(locator)!r}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        log_base, symlog_thresh = self._parse_for_log_params(self.trans)</span>
<span class="gi">+        if log_base or symlog_thresh:</span>
<span class="gi">+            if count is not None and between is None:</span>
<span class="gi">+                raise RuntimeError(&quot;`count` requires `between` with log transform.&quot;)</span>
<span class="gi">+            if every is not None:</span>
<span class="gi">+                raise RuntimeError(&quot;`every` not supported with log transform.&quot;)</span>

<span class="gd">-    def label(self, formatter: (Formatter | None)=None, *, like: (str |</span>
<span class="gd">-        Callable | None)=None, base: (int | None | Default)=default, unit:</span>
<span class="gd">-        (str | None)=None) -&gt;Continuous:</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._tick_params = {</span>
<span class="gi">+            &quot;locator&quot;: locator,</span>
<span class="gi">+            &quot;at&quot;: at,</span>
<span class="gi">+            &quot;upto&quot;: upto,</span>
<span class="gi">+            &quot;count&quot;: count,</span>
<span class="gi">+            &quot;every&quot;: every,</span>
<span class="gi">+            &quot;between&quot;: between,</span>
<span class="gi">+            &quot;minor&quot;: minor,</span>
<span class="gi">+        }</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def label(</span>
<span class="gi">+        self,</span>
<span class="gi">+        formatter: Formatter | None = None, *,</span>
<span class="gi">+        like: str | Callable | None = None,</span>
<span class="gi">+        base: int | None | Default = default,</span>
<span class="gi">+        unit: str | None = None,</span>
<span class="gi">+    ) -&gt; Continuous:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the appearance of tick labels for the scale&#39;s axis or legend.

<span class="gu">@@ -211,7 +629,133 @@ class Continuous(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new label configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Input checks</span>
<span class="gi">+        if formatter is not None and not isinstance(formatter, Formatter):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;Label formatter must be an instance of {Formatter!r}, &quot;</span>
<span class="gi">+                f&quot;not {type(formatter)!r}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        if like is not None and not (isinstance(like, str) or callable(like)):</span>
<span class="gi">+            msg = f&quot;`like` must be a string or callable, not {type(like).__name__}.&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._label_params = {</span>
<span class="gi">+            &quot;formatter&quot;: formatter,</span>
<span class="gi">+            &quot;like&quot;: like,</span>
<span class="gi">+            &quot;base&quot;: base,</span>
<span class="gi">+            &quot;unit&quot;: unit,</span>
<span class="gi">+        }</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_for_log_params(</span>
<span class="gi">+        self, trans: str | TransFuncs | None</span>
<span class="gi">+    ) -&gt; tuple[float | None, float | None]:</span>
<span class="gi">+</span>
<span class="gi">+        log_base = symlog_thresh = None</span>
<span class="gi">+        if isinstance(trans, str):</span>
<span class="gi">+            m = re.match(r&quot;^log(\d*)&quot;, trans)</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                log_base = float(m[1] or 10)</span>
<span class="gi">+            m = re.match(r&quot;symlog(\d*)&quot;, trans)</span>
<span class="gi">+            if m is not None:</span>
<span class="gi">+                symlog_thresh = float(m[1] or 1)</span>
<span class="gi">+        return log_base, symlog_thresh</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locators(self, locator, at, upto, count, every, between, minor):</span>
<span class="gi">+</span>
<span class="gi">+        log_base, symlog_thresh = self._parse_for_log_params(self.trans)</span>
<span class="gi">+</span>
<span class="gi">+        if locator is not None:</span>
<span class="gi">+            major_locator = locator</span>
<span class="gi">+</span>
<span class="gi">+        elif upto is not None:</span>
<span class="gi">+            if log_base:</span>
<span class="gi">+                major_locator = LogLocator(base=log_base, numticks=upto)</span>
<span class="gi">+            else:</span>
<span class="gi">+                major_locator = MaxNLocator(upto, steps=[1, 1.5, 2, 2.5, 3, 5, 10])</span>
<span class="gi">+</span>
<span class="gi">+        elif count is not None:</span>
<span class="gi">+            if between is None:</span>
<span class="gi">+                # This is rarely useful (unless you are setting limits)</span>
<span class="gi">+                major_locator = LinearLocator(count)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if log_base or symlog_thresh:</span>
<span class="gi">+                    forward, inverse = self._get_transform()</span>
<span class="gi">+                    lo, hi = forward(between)</span>
<span class="gi">+                    ticks = inverse(np.linspace(lo, hi, num=count))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ticks = np.linspace(*between, num=count)</span>
<span class="gi">+                major_locator = FixedLocator(ticks)</span>
<span class="gi">+</span>
<span class="gi">+        elif every is not None:</span>
<span class="gi">+            if between is None:</span>
<span class="gi">+                major_locator = MultipleLocator(every)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lo, hi = between</span>
<span class="gi">+                ticks = np.arange(lo, hi + every, every)</span>
<span class="gi">+                major_locator = FixedLocator(ticks)</span>
<span class="gi">+</span>
<span class="gi">+        elif at is not None:</span>
<span class="gi">+            major_locator = FixedLocator(at)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            if log_base:</span>
<span class="gi">+                major_locator = LogLocator(log_base)</span>
<span class="gi">+            elif symlog_thresh:</span>
<span class="gi">+                major_locator = SymmetricalLogLocator(linthresh=symlog_thresh, base=10)</span>
<span class="gi">+            else:</span>
<span class="gi">+                major_locator = AutoLocator()</span>
<span class="gi">+</span>
<span class="gi">+        if minor is None:</span>
<span class="gi">+            minor_locator = LogLocator(log_base, subs=None) if log_base else None</span>
<span class="gi">+        else:</span>
<span class="gi">+            if log_base:</span>
<span class="gi">+                subs = np.linspace(0, log_base, minor + 2)[1:-1]</span>
<span class="gi">+                minor_locator = LogLocator(log_base, subs=subs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                minor_locator = AutoMinorLocator(minor + 1)</span>
<span class="gi">+</span>
<span class="gi">+        return major_locator, minor_locator</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatter(self, locator, formatter, like, base, unit):</span>
<span class="gi">+</span>
<span class="gi">+        log_base, symlog_thresh = self._parse_for_log_params(self.trans)</span>
<span class="gi">+        if base is default:</span>
<span class="gi">+            if symlog_thresh:</span>
<span class="gi">+                log_base = 10</span>
<span class="gi">+            base = log_base</span>
<span class="gi">+</span>
<span class="gi">+        if formatter is not None:</span>
<span class="gi">+            return formatter</span>
<span class="gi">+</span>
<span class="gi">+        if like is not None:</span>
<span class="gi">+            if isinstance(like, str):</span>
<span class="gi">+                if &quot;{x&quot; in like or &quot;{pos&quot; in like:</span>
<span class="gi">+                    fmt = like</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fmt = f&quot;{{x:{like}}}&quot;</span>
<span class="gi">+                formatter = StrMethodFormatter(fmt)</span>
<span class="gi">+            else:</span>
<span class="gi">+                formatter = FuncFormatter(like)</span>
<span class="gi">+</span>
<span class="gi">+        elif base is not None:</span>
<span class="gi">+            # We could add other log options if necessary</span>
<span class="gi">+            formatter = LogFormatterSciNotation(base)</span>
<span class="gi">+</span>
<span class="gi">+        elif unit is not None:</span>
<span class="gi">+            if isinstance(unit, tuple):</span>
<span class="gi">+                sep, unit = unit</span>
<span class="gi">+            elif not unit:</span>
<span class="gi">+                sep = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                sep = &quot; &quot;</span>
<span class="gi">+            formatter = EngFormatter(unit, sep=sep)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            formatter = ScalarFormatter()</span>
<span class="gi">+</span>
<span class="gi">+        return formatter</span>


<span class="w"> </span>@dataclass
<span class="gu">@@ -219,11 +763,24 @@ class Temporal(ContinuousBase):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A scale for date/time data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # TODO date: bool?</span>
<span class="gi">+    # For when we only care about the time component, would affect</span>
<span class="gi">+    # default formatter and norm conversion. Should also happen in</span>
<span class="gi">+    # Property.default_scale. The alternative was having distinct</span>
<span class="gi">+    # Calendric / Temporal scales, but that feels a bit fussy, and it</span>
<span class="gi">+    # would get in the way of using first-letter shorthands because</span>
<span class="gi">+    # Calendric and Continuous would collide. Still, we haven&#39;t implemented</span>
<span class="gi">+    # those yet, and having a clear distinction betewen date(time) / time</span>
<span class="gi">+    # may be more useful.</span>
<span class="gi">+</span>
<span class="w"> </span>    trans = None
<span class="gi">+</span>
<span class="w"> </span>    _priority: ClassVar[int] = 2

<span class="gd">-    def tick(self, locator: (Locator | None)=None, *, upto: (int | None)=None</span>
<span class="gd">-        ) -&gt;Temporal:</span>
<span class="gi">+    def tick(</span>
<span class="gi">+        self, locator: Locator | None = None, *,</span>
<span class="gi">+        upto: int | None = None,</span>
<span class="gi">+    ) -&gt; Temporal:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the selection of ticks for the scale&#39;s axis or legend.

<span class="gu">@@ -243,10 +800,22 @@ class Temporal(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new tick configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if locator is not None and not isinstance(locator, Locator):</span>
<span class="gi">+            err = (</span>
<span class="gi">+                f&quot;Tick locator must be an instance of {Locator!r}, &quot;</span>
<span class="gi">+                f&quot;not {type(locator)!r}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._tick_params = {&quot;locator&quot;: locator, &quot;upto&quot;: upto}</span>
<span class="gi">+        return new</span>

<span class="gd">-    def label(self, formatter: (Formatter | None)=None, *, concise: bool=False</span>
<span class="gd">-        ) -&gt;Temporal:</span>
<span class="gi">+    def label(</span>
<span class="gi">+        self,</span>
<span class="gi">+        formatter: Formatter | None = None, *,</span>
<span class="gi">+        concise: bool = False,</span>
<span class="gi">+    ) -&gt; Temporal:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Configure the appearance of tick labels for the scale&#39;s axis or legend.

<span class="gu">@@ -267,7 +836,54 @@ class Temporal(ContinuousBase):</span>
<span class="w"> </span>            Copy of self with new label configuration.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new = copy(self)</span>
<span class="gi">+        new._label_params = {&quot;formatter&quot;: formatter, &quot;concise&quot;: concise}</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _get_locators(self, locator, upto):</span>
<span class="gi">+</span>
<span class="gi">+        if locator is not None:</span>
<span class="gi">+            major_locator = locator</span>
<span class="gi">+        elif upto is not None:</span>
<span class="gi">+            major_locator = AutoDateLocator(minticks=2, maxticks=upto)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            major_locator = AutoDateLocator(minticks=2, maxticks=6)</span>
<span class="gi">+        minor_locator = None</span>
<span class="gi">+</span>
<span class="gi">+        return major_locator, minor_locator</span>
<span class="gi">+</span>
<span class="gi">+    def _get_formatter(self, locator, formatter, concise):</span>
<span class="gi">+</span>
<span class="gi">+        if formatter is not None:</span>
<span class="gi">+            return formatter</span>
<span class="gi">+</span>
<span class="gi">+        if concise:</span>
<span class="gi">+            # TODO ideally we would have concise coordinate ticks,</span>
<span class="gi">+            # but full semantic ticks. Is that possible?</span>
<span class="gi">+            formatter = ConciseDateFormatter(locator)</span>
<span class="gi">+        else:</span>
<span class="gi">+            formatter = AutoDateFormatter(locator)</span>
<span class="gi">+</span>
<span class="gi">+        return formatter</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ----------------------------------------------------------------------------------- #</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO Have this separate from Temporal or have Temporal(date=True) or similar?</span>
<span class="gi">+# class Calendric(Scale):</span>
<span class="gi">+</span>
<span class="gi">+# TODO Needed? Or handle this at layer (in stat or as param, eg binning=)</span>
<span class="gi">+# class Binned(Scale):</span>
<span class="gi">+</span>
<span class="gi">+# TODO any need for color-specific scales?</span>
<span class="gi">+# class Sequential(Continuous):</span>
<span class="gi">+# class Diverging(Continuous):</span>
<span class="gi">+# class Qualitative(Nominal):</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ----------------------------------------------------------------------------------- #</span>


<span class="w"> </span>class PseudoAxis:
<span class="gu">@@ -280,21 +896,195 @@ class PseudoAxis:</span>
<span class="w"> </span>    code, this object acts like an Axis and can be used to scale other variables.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    axis_name = &#39;&#39;</span>
<span class="gi">+    axis_name = &quot;&quot;  # Matplotlib requirement but not actually used</span>

<span class="w"> </span>    def __init__(self, scale):
<span class="gi">+</span>
<span class="w"> </span>        self.converter = None
<span class="w"> </span>        self.units = None
<span class="w"> </span>        self.scale = scale
<span class="w"> </span>        self.major = mpl.axis.Ticker()
<span class="w"> </span>        self.minor = mpl.axis.Ticker()
<span class="gi">+</span>
<span class="gi">+        # It appears that this needs to be initialized this way on matplotlib 3.1,</span>
<span class="gi">+        # but not later versions. It is unclear whether there are any issues with it.</span>
<span class="w"> </span>        self._data_interval = None, None
<span class="gi">+</span>
<span class="w"> </span>        scale.set_default_locators_and_formatters(self)
<span class="gi">+        # self.set_default_intervals()  Is this ever needed?</span>
<span class="gi">+</span>
<span class="gi">+    def set_view_interval(self, vmin, vmax):</span>
<span class="gi">+        self._view_interval = vmin, vmax</span>
<span class="gi">+</span>
<span class="gi">+    def get_view_interval(self):</span>
<span class="gi">+        return self._view_interval</span>
<span class="gi">+</span>
<span class="gi">+    # TODO do we want to distinguish view/data intervals? e.g. for a legend</span>
<span class="gi">+    # we probably want to represent the full range of the data values, but</span>
<span class="gi">+    # still norm the colormap. If so, we&#39;ll need to track data range separately</span>
<span class="gi">+    # from the norm, which we currently don&#39;t do.</span>
<span class="gi">+</span>
<span class="gi">+    def set_data_interval(self, vmin, vmax):</span>
<span class="gi">+        self._data_interval = vmin, vmax</span>
<span class="gi">+</span>
<span class="gi">+    def get_data_interval(self):</span>
<span class="gi">+        return self._data_interval</span>
<span class="gi">+</span>
<span class="gi">+    def get_tick_space(self):</span>
<span class="gi">+        # TODO how to do this in a configurable / auto way?</span>
<span class="gi">+        # Would be cool to have legend density adapt to figure size, etc.</span>
<span class="gi">+        return 5</span>
<span class="gi">+</span>
<span class="gi">+    def set_major_locator(self, locator):</span>
<span class="gi">+        self.major.locator = locator</span>
<span class="gi">+        locator.set_axis(self)</span>
<span class="gi">+</span>
<span class="gi">+    def set_major_formatter(self, formatter):</span>
<span class="gi">+        self.major.formatter = formatter</span>
<span class="gi">+        formatter.set_axis(self)</span>
<span class="gi">+</span>
<span class="gi">+    def set_minor_locator(self, locator):</span>
<span class="gi">+        self.minor.locator = locator</span>
<span class="gi">+        locator.set_axis(self)</span>
<span class="gi">+</span>
<span class="gi">+    def set_minor_formatter(self, formatter):</span>
<span class="gi">+        self.minor.formatter = formatter</span>
<span class="gi">+        formatter.set_axis(self)</span>
<span class="gi">+</span>
<span class="gi">+    def set_units(self, units):</span>
<span class="gi">+        self.units = units</span>

<span class="w"> </span>    def update_units(self, x):
<span class="w"> </span>        &quot;&quot;&quot;Pass units to the internal converter, potentially updating its mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.converter = mpl.units.registry.get_converter(x)</span>
<span class="gi">+        if self.converter is not None:</span>
<span class="gi">+            self.converter.default_units(x, self)</span>
<span class="gi">+</span>
<span class="gi">+            info = self.converter.axisinfo(self.units, self)</span>
<span class="gi">+</span>
<span class="gi">+            if info is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if info.majloc is not None:</span>
<span class="gi">+                self.set_major_locator(info.majloc)</span>
<span class="gi">+            if info.majfmt is not None:</span>
<span class="gi">+                self.set_major_formatter(info.majfmt)</span>
<span class="gi">+</span>
<span class="gi">+            # This is in matplotlib method; do we need this?</span>
<span class="gi">+            # self.set_default_intervals()</span>

<span class="w"> </span>    def convert_units(self, x):
<span class="w"> </span>        &quot;&quot;&quot;Return a numeric representation of the input data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if np.issubdtype(np.asarray(x).dtype, np.number):</span>
<span class="gi">+            return x</span>
<span class="gi">+        elif self.converter is None:</span>
<span class="gi">+            return x</span>
<span class="gi">+        return self.converter.convert(x, self.units, self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_scale(self):</span>
<span class="gi">+        # Note that matplotlib actually returns a string here!</span>
<span class="gi">+        # (e.g., with a log scale, axis.get_scale() returns &quot;log&quot;)</span>
<span class="gi">+        # Currently we just hit it with minor ticks where it checks for</span>
<span class="gi">+        # scale == &quot;log&quot;. I&#39;m not sure how you&#39;d actually use log-scale</span>
<span class="gi">+        # minor &quot;ticks&quot; in a legend context, so this is fine....</span>
<span class="gi">+        return self.scale</span>
<span class="gi">+</span>
<span class="gi">+    def get_majorticklocs(self):</span>
<span class="gi">+        return self.major.locator()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ------------------------------------------------------------------------------------ #</span>
<span class="gi">+# Transform function creation</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_identity_transforms() -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    def identity(x):</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    return identity, identity</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_logit_transforms(base: float | None = None) -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    log, exp = _make_log_transforms(base)</span>
<span class="gi">+</span>
<span class="gi">+    def logit(x):</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return log(x) - log(1 - x)</span>
<span class="gi">+</span>
<span class="gi">+    def expit(x):</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return exp(x) / (1 + exp(x))</span>
<span class="gi">+</span>
<span class="gi">+    return logit, expit</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_log_transforms(base: float | None = None) -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    fs: TransFuncs</span>
<span class="gi">+    if base is None:</span>
<span class="gi">+        fs = np.log, np.exp</span>
<span class="gi">+    elif base == 2:</span>
<span class="gi">+        fs = np.log2, partial(np.power, 2)</span>
<span class="gi">+    elif base == 10:</span>
<span class="gi">+        fs = np.log10, partial(np.power, 10)</span>
<span class="gi">+    else:</span>
<span class="gi">+        def forward(x):</span>
<span class="gi">+            return np.log(x) / np.log(base)</span>
<span class="gi">+        fs = forward, partial(np.power, base)</span>
<span class="gi">+</span>
<span class="gi">+    def log(x: ArrayLike) -&gt; ArrayLike:</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return fs[0](x)</span>
<span class="gi">+</span>
<span class="gi">+    def exp(x: ArrayLike) -&gt; ArrayLike:</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return fs[1](x)</span>
<span class="gi">+</span>
<span class="gi">+    return log, exp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_symlog_transforms(c: float = 1, base: float = 10) -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    # From https://iopscience.iop.org/article/10.1088/0957-0233/24/2/027001</span>
<span class="gi">+</span>
<span class="gi">+    # Note: currently not using base because we only get</span>
<span class="gi">+    # one parameter from the string, and are using c (this is consistent with d3)</span>
<span class="gi">+</span>
<span class="gi">+    log, exp = _make_log_transforms(base)</span>
<span class="gi">+</span>
<span class="gi">+    def symlog(x):</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return np.sign(x) * log(1 + np.abs(np.divide(x, c)))</span>
<span class="gi">+</span>
<span class="gi">+    def symexp(x):</span>
<span class="gi">+        with np.errstate(invalid=&quot;ignore&quot;, divide=&quot;ignore&quot;):</span>
<span class="gi">+            return np.sign(x) * c * (exp(np.abs(x)) - 1)</span>
<span class="gi">+</span>
<span class="gi">+    return symlog, symexp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_sqrt_transforms() -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    def sqrt(x):</span>
<span class="gi">+        return np.sign(x) * np.sqrt(np.abs(x))</span>
<span class="gi">+</span>
<span class="gi">+    def square(x):</span>
<span class="gi">+        return np.sign(x) * np.square(x)</span>
<span class="gi">+</span>
<span class="gi">+    return sqrt, square</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_power_transforms(exp: float) -&gt; TransFuncs:</span>
<span class="gi">+</span>
<span class="gi">+    def forward(x):</span>
<span class="gi">+        return np.sign(x) * np.power(np.abs(x), exp)</span>
<span class="gi">+</span>
<span class="gi">+    def inverse(x):</span>
<span class="gi">+        return np.sign(x) * np.power(np.abs(x), 1 / exp)</span>
<span class="gi">+</span>
<span class="gi">+    return forward, inverse</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _default_spacer(x: Series) -&gt; float:</span>
<span class="gi">+    return 1</span>
<span class="gh">diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py</span>
<span class="gh">index ab72e2f0..287f4416 100644</span>
<span class="gd">--- a/seaborn/_core/subplots.py</span>
<span class="gi">+++ b/seaborn/_core/subplots.py</span>
<span class="gu">@@ -1,12 +1,14 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from collections.abc import Generator
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="gi">+</span>
<span class="w"> </span>from matplotlib.axes import Axes
<span class="w"> </span>from matplotlib.figure import Figure
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gd">-if TYPE_CHECKING:</span>
<span class="gi">+if TYPE_CHECKING:  # TODO move to seaborn._core.typing?</span>
<span class="w"> </span>    from seaborn._core.plot import FacetSpec, PairSpec
<span class="w"> </span>    from matplotlib.figure import SubFigure

<span class="gu">@@ -27,44 +29,235 @@ class Subplots:</span>
<span class="w"> </span>        Data used to define figure setup.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        subplot_spec: dict,  # TODO define as TypedDict</span>
<span class="gi">+        facet_spec: FacetSpec,</span>
<span class="gi">+        pair_spec: PairSpec,</span>
<span class="gi">+    ):</span>

<span class="gd">-    def __init__(self, subplot_spec: dict, facet_spec: FacetSpec, pair_spec:</span>
<span class="gd">-        PairSpec):</span>
<span class="w"> </span>        self.subplot_spec = subplot_spec
<span class="gi">+</span>
<span class="w"> </span>        self._check_dimension_uniqueness(facet_spec, pair_spec)
<span class="w"> </span>        self._determine_grid_dimensions(facet_spec, pair_spec)
<span class="w"> </span>        self._handle_wrapping(facet_spec, pair_spec)
<span class="w"> </span>        self._determine_axis_sharing(pair_spec)

<span class="gd">-    def _check_dimension_uniqueness(self, facet_spec: FacetSpec, pair_spec:</span>
<span class="gd">-        PairSpec) -&gt;None:</span>
<span class="gi">+    def _check_dimension_uniqueness(</span>
<span class="gi">+        self, facet_spec: FacetSpec, pair_spec: PairSpec</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reject specs that pair and facet on (or wrap to) same figure dimension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        err = None</span>
<span class="gi">+</span>
<span class="gi">+        facet_vars = facet_spec.get(&quot;variables&quot;, {})</span>

<span class="gd">-    def _determine_grid_dimensions(self, facet_spec: FacetSpec, pair_spec:</span>
<span class="gd">-        PairSpec) -&gt;None:</span>
<span class="gi">+        if facet_spec.get(&quot;wrap&quot;) and {&quot;col&quot;, &quot;row&quot;} &lt;= set(facet_vars):</span>
<span class="gi">+            err = &quot;Cannot wrap facets when specifying both `col` and `row`.&quot;</span>
<span class="gi">+        elif (</span>
<span class="gi">+            pair_spec.get(&quot;wrap&quot;)</span>
<span class="gi">+            and pair_spec.get(&quot;cross&quot;, True)</span>
<span class="gi">+            and len(pair_spec.get(&quot;structure&quot;, {}).get(&quot;x&quot;, [])) &gt; 1</span>
<span class="gi">+            and len(pair_spec.get(&quot;structure&quot;, {}).get(&quot;y&quot;, [])) &gt; 1</span>
<span class="gi">+        ):</span>
<span class="gi">+            err = &quot;Cannot wrap subplots when pairing on both `x` and `y`.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        collisions = {&quot;x&quot;: [&quot;columns&quot;, &quot;rows&quot;], &quot;y&quot;: [&quot;rows&quot;, &quot;columns&quot;]}</span>
<span class="gi">+        for pair_axis, (multi_dim, wrap_dim) in collisions.items():</span>
<span class="gi">+            if pair_axis not in pair_spec.get(&quot;structure&quot;, {}):</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif multi_dim[:3] in facet_vars:</span>
<span class="gi">+                err = f&quot;Cannot facet the {multi_dim} while pairing on `{pair_axis}``.&quot;</span>
<span class="gi">+            elif wrap_dim[:3] in facet_vars and facet_spec.get(&quot;wrap&quot;):</span>
<span class="gi">+                err = f&quot;Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``.&quot;</span>
<span class="gi">+            elif wrap_dim[:3] in facet_vars and pair_spec.get(&quot;wrap&quot;):</span>
<span class="gi">+                err = f&quot;Cannot wrap the {multi_dim} while faceting the {wrap_dim}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if err is not None:</span>
<span class="gi">+            raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?</span>
<span class="gi">+</span>
<span class="gi">+    def _determine_grid_dimensions(</span>
<span class="gi">+        self, facet_spec: FacetSpec, pair_spec: PairSpec</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse faceting and pairing information to define figure structure.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.grid_dimensions: dict[str, list] = {}</span>
<span class="gi">+        for dim, axis in zip([&quot;col&quot;, &quot;row&quot;], [&quot;x&quot;, &quot;y&quot;]):</span>
<span class="gi">+</span>
<span class="gi">+            facet_vars = facet_spec.get(&quot;variables&quot;, {})</span>
<span class="gi">+            if dim in facet_vars:</span>
<span class="gi">+                self.grid_dimensions[dim] = facet_spec[&quot;structure&quot;][dim]</span>
<span class="gi">+            elif axis in pair_spec.get(&quot;structure&quot;, {}):</span>
<span class="gi">+                self.grid_dimensions[dim] = [</span>
<span class="gi">+                    None for _ in pair_spec.get(&quot;structure&quot;, {})[axis]</span>
<span class="gi">+                ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.grid_dimensions[dim] = [None]</span>

<span class="gd">-    def _handle_wrapping(self, facet_spec: FacetSpec, pair_spec: PairSpec</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+            self.subplot_spec[f&quot;n{dim}s&quot;] = len(self.grid_dimensions[dim])</span>
<span class="gi">+</span>
<span class="gi">+        if not pair_spec.get(&quot;cross&quot;, True):</span>
<span class="gi">+            self.subplot_spec[&quot;nrows&quot;] = 1</span>
<span class="gi">+</span>
<span class="gi">+        self.n_subplots = self.subplot_spec[&quot;ncols&quot;] * self.subplot_spec[&quot;nrows&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_wrapping(</span>
<span class="gi">+        self, facet_spec: FacetSpec, pair_spec: PairSpec</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update figure structure parameters based on facet/pair wrapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.wrap = wrap = facet_spec.get(&quot;wrap&quot;) or pair_spec.get(&quot;wrap&quot;)</span>
<span class="gi">+        if not wrap:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        wrap_dim = &quot;row&quot; if self.subplot_spec[&quot;nrows&quot;] &gt; 1 else &quot;col&quot;</span>
<span class="gi">+        flow_dim = {&quot;row&quot;: &quot;col&quot;, &quot;col&quot;: &quot;row&quot;}[wrap_dim]</span>
<span class="gi">+        n_subplots = self.subplot_spec[f&quot;n{wrap_dim}s&quot;]</span>
<span class="gi">+        flow = int(np.ceil(n_subplots / wrap))</span>

<span class="gd">-    def _determine_axis_sharing(self, pair_spec: PairSpec) -&gt;None:</span>
<span class="gi">+        if wrap &lt; self.subplot_spec[f&quot;n{wrap_dim}s&quot;]:</span>
<span class="gi">+            self.subplot_spec[f&quot;n{wrap_dim}s&quot;] = wrap</span>
<span class="gi">+        self.subplot_spec[f&quot;n{flow_dim}s&quot;] = flow</span>
<span class="gi">+        self.n_subplots = n_subplots</span>
<span class="gi">+        self.wrap_dim = wrap_dim</span>
<span class="gi">+</span>
<span class="gi">+    def _determine_axis_sharing(self, pair_spec: PairSpec) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update subplot spec with default or specified axis sharing parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        axis_to_dim = {&quot;x&quot;: &quot;col&quot;, &quot;y&quot;: &quot;row&quot;}</span>
<span class="gi">+        key: str</span>
<span class="gi">+        val: str | bool</span>
<span class="gi">+        for axis in &quot;xy&quot;:</span>
<span class="gi">+            key = f&quot;share{axis}&quot;</span>
<span class="gi">+            # Always use user-specified value, if present</span>
<span class="gi">+            if key not in self.subplot_spec:</span>
<span class="gi">+                if axis in pair_spec.get(&quot;structure&quot;, {}):</span>
<span class="gi">+                    # Paired axes are shared along one dimension by default</span>
<span class="gi">+                    if self.wrap is None and pair_spec.get(&quot;cross&quot;, True):</span>
<span class="gi">+                        val = axis_to_dim[axis]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        val = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # This will pick up faceted plots, as well as single subplot</span>
<span class="gi">+                    # figures, where the value doesn&#39;t really matter</span>
<span class="gi">+                    val = True</span>
<span class="gi">+                self.subplot_spec[key] = val</span>

<span class="gd">-    def init_figure(self, pair_spec: PairSpec, pyplot: bool=False,</span>
<span class="gd">-        figure_kws: (dict | None)=None, target: (Axes | Figure | SubFigure |</span>
<span class="gd">-        None)=None) -&gt;Figure:</span>
<span class="gi">+    def init_figure(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pair_spec: PairSpec,</span>
<span class="gi">+        pyplot: bool = False,</span>
<span class="gi">+        figure_kws: dict | None = None,</span>
<span class="gi">+        target: Axes | Figure | SubFigure | None = None,</span>
<span class="gi">+    ) -&gt; Figure:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize matplotlib objects and add seaborn-relevant metadata.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO reduce need to pass pair_spec here?</span>
<span class="gi">+</span>
<span class="gi">+        if figure_kws is None:</span>
<span class="gi">+            figure_kws = {}</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(target, mpl.axes.Axes):</span>
<span class="gi">+</span>
<span class="gi">+            if max(self.subplot_spec[&quot;nrows&quot;], self.subplot_spec[&quot;ncols&quot;]) &gt; 1:</span>
<span class="gi">+                err = &quot; &quot;.join([</span>
<span class="gi">+                    &quot;Cannot create multiple subplots after calling `Plot.on` with&quot;,</span>
<span class="gi">+                    f&quot;a {mpl.axes.Axes} object.&quot;,</span>
<span class="gi">+                    f&quot; You may want to use a {mpl.figure.SubFigure} instead.&quot;,</span>
<span class="gi">+                ])</span>
<span class="gi">+                raise RuntimeError(err)</span>
<span class="gi">+</span>
<span class="gi">+            self._subplot_list = [{</span>
<span class="gi">+                &quot;ax&quot;: target,</span>
<span class="gi">+                &quot;left&quot;: True,</span>
<span class="gi">+                &quot;right&quot;: True,</span>
<span class="gi">+                &quot;top&quot;: True,</span>
<span class="gi">+                &quot;bottom&quot;: True,</span>
<span class="gi">+                &quot;col&quot;: None,</span>
<span class="gi">+                &quot;row&quot;: None,</span>
<span class="gi">+                &quot;x&quot;: &quot;x&quot;,</span>
<span class="gi">+                &quot;y&quot;: &quot;y&quot;,</span>
<span class="gi">+            }]</span>
<span class="gi">+            self._figure = target.figure</span>
<span class="gi">+            return self._figure</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(target, mpl.figure.SubFigure):</span>
<span class="gi">+            figure = target.figure</span>
<span class="gi">+        elif isinstance(target, mpl.figure.Figure):</span>
<span class="gi">+            figure = target</span>
<span class="gi">+        else:</span>
<span class="gi">+            if pyplot:</span>
<span class="gi">+                figure = plt.figure(**figure_kws)</span>
<span class="gi">+            else:</span>
<span class="gi">+                figure = mpl.figure.Figure(**figure_kws)</span>
<span class="gi">+            target = figure</span>
<span class="gi">+        self._figure = figure</span>
<span class="gi">+</span>
<span class="gi">+        axs = target.subplots(**self.subplot_spec, squeeze=False)</span>
<span class="gi">+</span>
<span class="gi">+        if self.wrap:</span>
<span class="gi">+            # Remove unused Axes and flatten the rest into a (2D) vector</span>
<span class="gi">+            axs_flat = axs.ravel({&quot;col&quot;: &quot;C&quot;, &quot;row&quot;: &quot;F&quot;}[self.wrap_dim])</span>
<span class="gi">+            axs, extra = np.split(axs_flat, [self.n_subplots])</span>
<span class="gi">+            for ax in extra:</span>
<span class="gi">+                ax.remove()</span>
<span class="gi">+            if self.wrap_dim == &quot;col&quot;:</span>
<span class="gi">+                axs = axs[np.newaxis, :]</span>
<span class="gi">+            else:</span>
<span class="gi">+                axs = axs[:, np.newaxis]</span>
<span class="gi">+</span>
<span class="gi">+        # Get i, j coordinates for each Axes object</span>
<span class="gi">+        # Note that i, j are with respect to faceting/pairing,</span>
<span class="gi">+        # not the subplot grid itself, (which only matters in the case of wrapping).</span>
<span class="gi">+        iter_axs: np.ndenumerate | zip</span>
<span class="gi">+        if not pair_spec.get(&quot;cross&quot;, True):</span>
<span class="gi">+            indices = np.arange(self.n_subplots)</span>
<span class="gi">+            iter_axs = zip(zip(indices, indices), axs.flat)</span>
<span class="gi">+        else:</span>
<span class="gi">+            iter_axs = np.ndenumerate(axs)</span>
<span class="gi">+</span>
<span class="gi">+        self._subplot_list = []</span>
<span class="gi">+        for (i, j), ax in iter_axs:</span>
<span class="gi">+</span>
<span class="gi">+            info = {&quot;ax&quot;: ax}</span>
<span class="gi">+</span>
<span class="gi">+            nrows, ncols = self.subplot_spec[&quot;nrows&quot;], self.subplot_spec[&quot;ncols&quot;]</span>
<span class="gi">+            if not self.wrap:</span>
<span class="gi">+                info[&quot;left&quot;] = j % ncols == 0</span>
<span class="gi">+                info[&quot;right&quot;] = (j + 1) % ncols == 0</span>
<span class="gi">+                info[&quot;top&quot;] = i == 0</span>
<span class="gi">+                info[&quot;bottom&quot;] = i == nrows - 1</span>
<span class="gi">+            elif self.wrap_dim == &quot;col&quot;:</span>
<span class="gi">+                info[&quot;left&quot;] = j % ncols == 0</span>
<span class="gi">+                info[&quot;right&quot;] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)</span>
<span class="gi">+                info[&quot;top&quot;] = j &lt; ncols</span>
<span class="gi">+                info[&quot;bottom&quot;] = j &gt;= (self.n_subplots - ncols)</span>
<span class="gi">+            elif self.wrap_dim == &quot;row&quot;:</span>
<span class="gi">+                info[&quot;left&quot;] = i &lt; nrows</span>
<span class="gi">+                info[&quot;right&quot;] = i &gt;= self.n_subplots - nrows</span>
<span class="gi">+                info[&quot;top&quot;] = i % nrows == 0</span>
<span class="gi">+                info[&quot;bottom&quot;] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)</span>
<span class="gi">+</span>
<span class="gi">+            if not pair_spec.get(&quot;cross&quot;, True):</span>
<span class="gi">+                info[&quot;top&quot;] = j &lt; ncols</span>
<span class="gi">+                info[&quot;bottom&quot;] = j &gt;= self.n_subplots - ncols</span>
<span class="gi">+</span>
<span class="gi">+            for dim in [&quot;row&quot;, &quot;col&quot;]:</span>
<span class="gi">+                idx = {&quot;row&quot;: i, &quot;col&quot;: j}[dim]</span>
<span class="gi">+                info[dim] = self.grid_dimensions[dim][idx]</span>
<span class="gi">+</span>
<span class="gi">+            for axis in &quot;xy&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                idx = {&quot;x&quot;: j, &quot;y&quot;: i}[axis]</span>
<span class="gi">+                if axis in pair_spec.get(&quot;structure&quot;, {}):</span>
<span class="gi">+                    key = f&quot;{axis}{idx}&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    key = axis</span>
<span class="gi">+                info[axis] = key</span>
<span class="gi">+</span>
<span class="gi">+            self._subplot_list.append(info)</span>
<span class="gi">+</span>
<span class="gi">+        return figure</span>

<span class="gd">-    def __iter__(self) -&gt;Generator[dict, None, None]:</span>
<span class="gi">+    def __iter__(self) -&gt; Generator[dict, None, None]:  # TODO TypedDict?</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield each subplot dictionary with Axes object and metadata.&quot;&quot;&quot;
<span class="w"> </span>        yield from self._subplot_list

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the number of subplots in this figure.&quot;&quot;&quot;
<span class="w"> </span>        return len(self._subplot_list)
<span class="gh">diff --git a/seaborn/_core/typing.py b/seaborn/_core/typing.py</span>
<span class="gh">index 1ff7dfb2..9bdf8a6e 100644</span>
<span class="gd">--- a/seaborn/_core/typing.py</span>
<span class="gi">+++ b/seaborn/_core/typing.py</span>
<span class="gu">@@ -1,34 +1,48 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Iterable, Mapping
<span class="w"> </span>from datetime import date, datetime, timedelta
<span class="w"> </span>from typing import Any, Optional, Union, Tuple, List, Dict
<span class="gd">-from numpy import ndarray</span>
<span class="gi">+</span>
<span class="gi">+from numpy import ndarray  # TODO use ArrayLike?</span>
<span class="w"> </span>from pandas import Series, Index, Timestamp, Timedelta
<span class="w"> </span>from matplotlib.colors import Colormap, Normalize
<span class="gd">-ColumnName = Union[str, bytes, date, datetime, timedelta, bool, complex,</span>
<span class="gd">-    Timestamp, Timedelta]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ColumnName = Union[</span>
<span class="gi">+    str, bytes, date, datetime, timedelta, bool, complex, Timestamp, Timedelta</span>
<span class="gi">+]</span>
<span class="w"> </span>Vector = Union[Series, Index, ndarray]
<span class="gi">+</span>
<span class="w"> </span>VariableSpec = Union[ColumnName, Vector, None]
<span class="w"> </span>VariableSpecList = Union[List[VariableSpec], Index, None]
<span class="gi">+</span>
<span class="gi">+# A DataSource can be an object implementing __dataframe__, or a Mapping</span>
<span class="gi">+# (and is optional in all contexts where it is used).</span>
<span class="gi">+# I don&#39;t think there&#39;s an abc for &quot;has __dataframe__&quot;, so we type as object</span>
<span class="gi">+# but keep the (slightly odd) Union alias for better user-facing annotations.</span>
<span class="w"> </span>DataSource = Union[object, Mapping, None]
<span class="gd">-OrderSpec = Union[Iterable, None]</span>
<span class="gi">+</span>
<span class="gi">+OrderSpec = Union[Iterable, None]  # TODO technically str is iterable</span>
<span class="w"> </span>NormSpec = Union[Tuple[Optional[float], Optional[float]], Normalize, None]
<span class="gi">+</span>
<span class="gi">+# TODO for discrete mappings, it would be ideal to use a parameterized type</span>
<span class="gi">+# as the dict values / list entries should be of specific type(s) for each method</span>
<span class="w"> </span>PaletteSpec = Union[str, list, dict, Colormap, None]
<span class="w"> </span>DiscreteValueSpec = Union[dict, list, None]
<span class="gd">-ContinuousValueSpec = Union[Tuple[float, float], List[float], Dict[Any,</span>
<span class="gd">-    float], None]</span>
<span class="gi">+ContinuousValueSpec = Union[</span>
<span class="gi">+    Tuple[float, float], List[float], Dict[Any, float], None,</span>
<span class="gi">+]</span>


<span class="w"> </span>class Default:
<span class="gd">-</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;default&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;default&gt;&quot;</span>


<span class="w"> </span>class Deprecated:
<span class="gd">-</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;deprecated&gt;&#39;</span>
<span class="gi">+        return &quot;&lt;deprecated&gt;&quot;</span>


<span class="w"> </span>default = Default()
<span class="gh">diff --git a/seaborn/_docstrings.py b/seaborn/_docstrings.py</span>
<span class="gh">index 92bca3b0..2ab210b6 100644</span>
<span class="gd">--- a/seaborn/_docstrings.py</span>
<span class="gi">+++ b/seaborn/_docstrings.py</span>
<span class="gu">@@ -4,7 +4,8 @@ from .external.docscrape import NumpyDocString</span>


<span class="w"> </span>class DocstringComponents:
<span class="gd">-    regexp = re.compile(&#39;\\n((\\n|.)+)\\n\\s*&#39;, re.MULTILINE)</span>
<span class="gi">+</span>
<span class="gi">+    regexp = re.compile(r&quot;\n((\n|.)+)\n\s*&quot;, re.MULTILINE)</span>

<span class="w"> </span>    def __init__(self, comp_dict, strip_whitespace=True):
<span class="w"> </span>        &quot;&quot;&quot;Read entries from a dict, optionally stripping outer whitespace.&quot;&quot;&quot;
<span class="gu">@@ -18,6 +19,7 @@ class DocstringComponents:</span>
<span class="w"> </span>                    entries[key] = m.group(1)
<span class="w"> </span>        else:
<span class="w"> </span>            entries = comp_dict.copy()
<span class="gi">+</span>
<span class="w"> </span>        self.entries = entries

<span class="w"> </span>    def __getattr__(self, attr):
<span class="gu">@@ -28,6 +30,11 @@ class DocstringComponents:</span>
<span class="w"> </span>            try:
<span class="w"> </span>                return self.__getattribute__(attr)
<span class="w"> </span>            except AttributeError as err:
<span class="gi">+                # If Python is run with -OO, it will strip docstrings and our lookup</span>
<span class="gi">+                # from self.entries will fail. We check for __debug__, which is actually</span>
<span class="gi">+                # set to False by -O (it is True for normal execution).</span>
<span class="gi">+                # But we only want to see an error when building the docs;</span>
<span class="gi">+                # not something users should see, so this slight inconsistency is fine.</span>
<span class="w"> </span>                if __debug__:
<span class="w"> </span>                    raise err
<span class="w"> </span>                else:
<span class="gu">@@ -36,139 +43,156 @@ class DocstringComponents:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_nested_components(cls, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Add multiple sub-sets of components.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(kwargs, strip_whitespace=False)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_function_params(cls, func):
<span class="w"> </span>        &quot;&quot;&quot;Use the numpydoc parser to extract components from existing func.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        params = NumpyDocString(pydoc.getdoc(func))[&quot;Parameters&quot;]</span>
<span class="gi">+        comp_dict = {}</span>
<span class="gi">+        for p in params:</span>
<span class="gi">+            name = p.name</span>
<span class="gi">+            type = p.type</span>
<span class="gi">+            desc = &quot;\n    &quot;.join(p.desc)</span>
<span class="gi">+            comp_dict[name] = f&quot;{name} : {type}\n    {desc}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return cls(comp_dict)</span>
<span class="gi">+</span>

<span class="gi">+# TODO is &quot;vector&quot; the best term here? We mean to imply 1D data with a variety</span>
<span class="gi">+# of types?</span>

<span class="gd">-_core_params = dict(data=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+# TODO now that we can parse numpydoc style strings, do we need to define dicts</span>
<span class="gi">+# of docstring components, or just write out a docstring?</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_core_params = dict(</span>
<span class="gi">+    data=&quot;&quot;&quot;</span>
<span class="w"> </span>data : :class:`pandas.DataFrame`, :class:`numpy.ndarray`, mapping, or sequence
<span class="w"> </span>    Input data structure. Either a long-form collection of vectors that can be
<span class="w"> </span>    assigned to named variables or a wide-form dataset that will be internally
<span class="w"> </span>    reshaped.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , xy=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,  # TODO add link to user guide narrative when exists</span>
<span class="gi">+    xy=&quot;&quot;&quot;</span>
<span class="w"> </span>x, y : vectors or keys in ``data``
<span class="w"> </span>    Variables that specify positions on the x and y axes.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , hue=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    hue=&quot;&quot;&quot;</span>
<span class="w"> </span>hue : vector or key in ``data``
<span class="w"> </span>    Semantic variable that is mapped to determine the color of plot elements.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , palette=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    palette=&quot;&quot;&quot;</span>
<span class="w"> </span>palette : string, list, dict, or :class:`matplotlib.colors.Colormap`
<span class="w"> </span>    Method for choosing the colors to use when mapping the ``hue`` semantic.
<span class="w"> </span>    String values are passed to :func:`color_palette`. List or dict values
<span class="w"> </span>    imply categorical mapping, while a colormap object implies numeric mapping.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , hue_order=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,  # noqa: E501</span>
<span class="gi">+    hue_order=&quot;&quot;&quot;</span>
<span class="w"> </span>hue_order : vector of strings
<span class="w"> </span>    Specify the order of processing and plotting for categorical levels of the
<span class="w"> </span>    ``hue`` semantic.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , hue_norm=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    hue_norm=&quot;&quot;&quot;</span>
<span class="w"> </span>hue_norm : tuple or :class:`matplotlib.colors.Normalize`
<span class="w"> </span>    Either a pair of values that set the normalization range in data units
<span class="w"> </span>    or an object that will map from data units into a [0, 1] interval. Usage
<span class="w"> </span>    implies numeric mapping.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , color=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    color=&quot;&quot;&quot;</span>
<span class="w"> </span>color : :mod:`matplotlib color &lt;matplotlib.colors&gt;`
<span class="w"> </span>    Single color specification for when hue mapping is not used. Otherwise, the
<span class="w"> </span>    plot will try to hook into the matplotlib property cycle.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , ax=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    ax=&quot;&quot;&quot;</span>
<span class="w"> </span>ax : :class:`matplotlib.axes.Axes`
<span class="w"> </span>    Pre-existing axes for the plot. Otherwise, call :func:`matplotlib.pyplot.gca`
<span class="w"> </span>    internally.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-_core_returns = dict(ax=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,  # noqa: E501</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_core_returns = dict(</span>
<span class="gi">+    ax=&quot;&quot;&quot;</span>
<span class="w"> </span>:class:`matplotlib.axes.Axes`
<span class="w"> </span>    The matplotlib axes containing the plot.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , facetgrid=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    facetgrid=&quot;&quot;&quot;</span>
<span class="w"> </span>:class:`FacetGrid`
<span class="w"> </span>    An object managing one or more subplots that correspond to conditional data
<span class="w"> </span>    subsets with convenient methods for batch-setting of axes attributes.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , jointgrid=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    jointgrid=&quot;&quot;&quot;</span>
<span class="w"> </span>:class:`JointGrid`
<span class="w"> </span>    An object managing multiple subplots that correspond to joint and marginal axes
<span class="w"> </span>    for plotting a bivariate relationship or distribution.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , pairgrid=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    pairgrid=&quot;&quot;&quot;</span>
<span class="w"> </span>:class:`PairGrid`
<span class="w"> </span>    An object managing multiple subplots that correspond to joint and marginal axes
<span class="w"> </span>    for pairwise combinations of multiple variables in a dataset.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-_seealso_blurbs = dict(scatterplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_seealso_blurbs = dict(</span>
<span class="gi">+</span>
<span class="gi">+    # Relational plots</span>
<span class="gi">+    scatterplot=&quot;&quot;&quot;</span>
<span class="w"> </span>scatterplot : Plot data using points.
<span class="gd">-    &quot;&quot;&quot;, lineplot=</span>
<span class="gd">-    &#39;\nlineplot : Plot data using lines.\n    &#39;, displot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    lineplot=&quot;&quot;&quot;</span>
<span class="gi">+lineplot : Plot data using lines.</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    # Distribution plots</span>
<span class="gi">+    displot=&quot;&quot;&quot;</span>
<span class="w"> </span>displot : Figure-level interface to distribution plot functions.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , histplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    histplot=&quot;&quot;&quot;</span>
<span class="w"> </span>histplot : Plot a histogram of binned counts with optional normalization or smoothing.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , kdeplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    kdeplot=&quot;&quot;&quot;</span>
<span class="w"> </span>kdeplot : Plot univariate or bivariate distributions using kernel density estimation.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , ecdfplot=</span>
<span class="gd">-    &#39;\necdfplot : Plot empirical cumulative distribution functions.\n    &#39;,</span>
<span class="gd">-    rugplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    ecdfplot=&quot;&quot;&quot;</span>
<span class="gi">+ecdfplot : Plot empirical cumulative distribution functions.</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    rugplot=&quot;&quot;&quot;</span>
<span class="w"> </span>rugplot : Plot a tick at each observation value along the x and/or y axes.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , stripplot=</span>
<span class="gd">-    &#39;\nstripplot : Plot a categorical scatter with jitter.\n    &#39;,</span>
<span class="gd">-    swarmplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    # Categorical plots</span>
<span class="gi">+    stripplot=&quot;&quot;&quot;</span>
<span class="gi">+stripplot : Plot a categorical scatter with jitter.</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    swarmplot=&quot;&quot;&quot;</span>
<span class="w"> </span>swarmplot : Plot a categorical scatter with non-overlapping points.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , violinplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    violinplot=&quot;&quot;&quot;</span>
<span class="w"> </span>violinplot : Draw an enhanced boxplot using kernel density estimation.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , pointplot=</span>
<span class="gd">-    &#39;\npointplot : Plot point estimates and CIs using markers and lines.\n    &#39;</span>
<span class="gd">-    , jointplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    pointplot=&quot;&quot;&quot;</span>
<span class="gi">+pointplot : Plot point estimates and CIs using markers and lines.</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    # Multiples</span>
<span class="gi">+    jointplot=&quot;&quot;&quot;</span>
<span class="w"> </span>jointplot : Draw a bivariate plot with univariate marginal distributions.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , pairplot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    pairplot=&quot;&quot;&quot;</span>
<span class="w"> </span>jointplot : Draw multiple bivariate plots with univariate marginal distributions.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , jointgrid=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    jointgrid=&quot;&quot;&quot;</span>
<span class="w"> </span>JointGrid : Set up a figure with joint and marginal views on bivariate data.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , pairgrid=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    pairgrid=&quot;&quot;&quot;</span>
<span class="w"> </span>PairGrid : Set up a figure with joint and marginal views on multiple variables.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-_core_docs = dict(params=DocstringComponents(_core_params), returns=</span>
<span class="gd">-    DocstringComponents(_core_returns), seealso=DocstringComponents(</span>
<span class="gd">-    _seealso_blurbs))</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_core_docs = dict(</span>
<span class="gi">+    params=DocstringComponents(_core_params),</span>
<span class="gi">+    returns=DocstringComponents(_core_returns),</span>
<span class="gi">+    seealso=DocstringComponents(_seealso_blurbs),</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/seaborn/_marks/area.py b/seaborn/_marks/area.py</span>
<span class="gh">index 427c1a16..7514a6d1 100644</span>
<span class="gd">--- a/seaborn/_marks/area.py</span>
<span class="gi">+++ b/seaborn/_marks/area.py</span>
<span class="gu">@@ -1,13 +1,89 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from dataclasses import dataclass
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gd">-from seaborn._marks.base import Mark, Mappable, MappableBool, MappableFloat, MappableColor, MappableStyle, resolve_properties, resolve_color, document_properties</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import (</span>
<span class="gi">+    Mark,</span>
<span class="gi">+    Mappable,</span>
<span class="gi">+    MappableBool,</span>
<span class="gi">+    MappableFloat,</span>
<span class="gi">+    MappableColor,</span>
<span class="gi">+    MappableStyle,</span>
<span class="gi">+    resolve_properties,</span>
<span class="gi">+    resolve_color,</span>
<span class="gi">+    document_properties,</span>
<span class="gi">+)</span>


<span class="w"> </span>class AreaBase:
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        patches = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        for keys, data, ax in split_gen():</span>
<span class="gi">+</span>
<span class="gi">+            kws = {}</span>
<span class="gi">+            data = self._standardize_coordinate_parameters(data, orient)</span>
<span class="gi">+            resolved = resolve_properties(self, keys, scales)</span>
<span class="gi">+            verts = self._get_verts(data, orient)</span>
<span class="gi">+            ax.update_datalim(verts)</span>
<span class="gi">+</span>
<span class="gi">+            # TODO should really move this logic into resolve_color</span>
<span class="gi">+            fc = resolve_color(self, keys, &quot;&quot;, scales)</span>
<span class="gi">+            if not resolved[&quot;fill&quot;]:</span>
<span class="gi">+                fc = mpl.colors.to_rgba(fc, 0)</span>
<span class="gi">+</span>
<span class="gi">+            kws[&quot;facecolor&quot;] = fc</span>
<span class="gi">+            kws[&quot;edgecolor&quot;] = resolve_color(self, keys, &quot;edge&quot;, scales)</span>
<span class="gi">+            kws[&quot;linewidth&quot;] = resolved[&quot;edgewidth&quot;]</span>
<span class="gi">+            kws[&quot;linestyle&quot;] = resolved[&quot;edgestyle&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            patches[ax].append(mpl.patches.Polygon(verts, **kws))</span>
<span class="gi">+</span>
<span class="gi">+        for ax, ax_patches in patches.items():</span>
<span class="gi">+</span>
<span class="gi">+            for patch in ax_patches:</span>
<span class="gi">+                self._postprocess_artist(patch, ax, orient)</span>
<span class="gi">+                ax.add_patch(patch)</span>
<span class="gi">+</span>
<span class="gi">+    def _standardize_coordinate_parameters(self, data, orient):</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _postprocess_artist(self, artist, ax, orient):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _get_verts(self, data, orient):</span>
<span class="gi">+</span>
<span class="gi">+        dv = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        data = data.sort_values(orient, kind=&quot;mergesort&quot;)</span>
<span class="gi">+        verts = np.concatenate([</span>
<span class="gi">+            data[[orient, f&quot;{dv}min&quot;]].to_numpy(),</span>
<span class="gi">+            data[[orient, f&quot;{dv}max&quot;]].to_numpy()[::-1],</span>
<span class="gi">+        ])</span>
<span class="gi">+        if orient == &quot;y&quot;:</span>
<span class="gi">+            verts = verts[:, ::-1]</span>
<span class="gi">+        return verts</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(self, variables, value, scales):</span>
<span class="gi">+</span>
<span class="gi">+        keys = {v: value for v in variables}</span>
<span class="gi">+        resolved = resolve_properties(self, keys, scales)</span>
<span class="gi">+</span>
<span class="gi">+        fc = resolve_color(self, keys, &quot;&quot;, scales)</span>
<span class="gi">+        if not resolved[&quot;fill&quot;]:</span>
<span class="gi">+            fc = mpl.colors.to_rgba(fc, 0)</span>
<span class="gi">+</span>
<span class="gi">+        return mpl.patches.Patch(</span>
<span class="gi">+            facecolor=fc,</span>
<span class="gi">+            edgecolor=resolve_color(self, keys, &quot;edge&quot;, scales),</span>
<span class="gi">+            linewidth=resolved[&quot;edgewidth&quot;],</span>
<span class="gi">+            linestyle=resolved[&quot;edgestyle&quot;],</span>
<span class="gi">+            **self.artist_kws,</span>
<span class="gi">+        )</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -25,15 +101,40 @@ class Area(AreaBase, Mark):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Area.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;)</span>
<span class="gd">-    alpha: MappableFloat = Mappable(0.2)</span>
<span class="gd">-    fill: MappableBool = Mappable(True)</span>
<span class="gd">-    edgecolor: MappableColor = Mappable(depend=&#39;color&#39;)</span>
<span class="gd">-    edgealpha: MappableFloat = Mappable(1)</span>
<span class="gd">-    edgewidth: MappableFloat = Mappable(rc=&#39;patch.linewidth&#39;)</span>
<span class="gd">-    edgestyle: MappableStyle = Mappable(&#39;-&#39;)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, )</span>
<span class="gi">+    alpha: MappableFloat = Mappable(.2, )</span>
<span class="gi">+    fill: MappableBool = Mappable(True, )</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(depend=&quot;color&quot;)</span>
<span class="gi">+    edgealpha: MappableFloat = Mappable(1, )</span>
<span class="gi">+    edgewidth: MappableFloat = Mappable(rc=&quot;patch.linewidth&quot;, )</span>
<span class="gi">+    edgestyle: MappableStyle = Mappable(&quot;-&quot;, )</span>
<span class="gi">+</span>
<span class="gi">+    # TODO should this be settable / mappable?</span>
<span class="w"> </span>    baseline: MappableFloat = Mappable(0, grouping=False)

<span class="gi">+    def _standardize_coordinate_parameters(self, data, orient):</span>
<span class="gi">+        dv = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        return data.rename(columns={&quot;baseline&quot;: f&quot;{dv}min&quot;, dv: f&quot;{dv}max&quot;})</span>
<span class="gi">+</span>
<span class="gi">+    def _postprocess_artist(self, artist, ax, orient):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO copying a lot of code from Bar, let&#39;s abstract this</span>
<span class="gi">+        # See comments there, I am not going to repeat them too</span>
<span class="gi">+</span>
<span class="gi">+        artist.set_linewidth(artist.get_linewidth() * 2)</span>
<span class="gi">+</span>
<span class="gi">+        linestyle = artist.get_linestyle()</span>
<span class="gi">+        if linestyle[1]:</span>
<span class="gi">+            linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))</span>
<span class="gi">+        artist.set_linestyle(linestyle)</span>
<span class="gi">+</span>
<span class="gi">+        artist.set_clip_path(artist.get_path(), artist.get_transform() + ax.transData)</span>
<span class="gi">+        if self.artist_kws.get(&quot;clip_on&quot;, True):</span>
<span class="gi">+            artist.set_clip_box(ax.bbox)</span>
<span class="gi">+</span>
<span class="gi">+        val_idx = [&quot;y&quot;, &quot;x&quot;].index(orient)</span>
<span class="gi">+        artist.sticky_edges[val_idx][:] = (0, np.inf)</span>
<span class="gi">+</span>

<span class="w"> </span>@document_properties
<span class="w"> </span>@dataclass
<span class="gu">@@ -50,10 +151,20 @@ class Band(AreaBase, Mark):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Band.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;)</span>
<span class="gd">-    alpha: MappableFloat = Mappable(0.2)</span>
<span class="gd">-    fill: MappableBool = Mappable(True)</span>
<span class="gd">-    edgecolor: MappableColor = Mappable(depend=&#39;color&#39;)</span>
<span class="gd">-    edgealpha: MappableFloat = Mappable(1)</span>
<span class="gd">-    edgewidth: MappableFloat = Mappable(0)</span>
<span class="gd">-    edgestyle: MappableFloat = Mappable(&#39;-&#39;)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, )</span>
<span class="gi">+    alpha: MappableFloat = Mappable(.2, )</span>
<span class="gi">+    fill: MappableBool = Mappable(True, )</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(depend=&quot;color&quot;, )</span>
<span class="gi">+    edgealpha: MappableFloat = Mappable(1, )</span>
<span class="gi">+    edgewidth: MappableFloat = Mappable(0, )</span>
<span class="gi">+    edgestyle: MappableFloat = Mappable(&quot;-&quot;, )</span>
<span class="gi">+</span>
<span class="gi">+    def _standardize_coordinate_parameters(self, data, orient):</span>
<span class="gi">+        # dv = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        # TODO assert that all(ymax &gt;= ymin)?</span>
<span class="gi">+        # TODO what if only one exist?</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        if not set(data.columns) &amp; {f&quot;{other}min&quot;, f&quot;{other}max&quot;}:</span>
<span class="gi">+            agg = {f&quot;{other}min&quot;: (other, &quot;min&quot;), f&quot;{other}max&quot;: (other, &quot;max&quot;)}</span>
<span class="gi">+            data = data.groupby(orient).agg(**agg).reset_index()</span>
<span class="gi">+        return data</span>
<span class="gh">diff --git a/seaborn/_marks/bar.py b/seaborn/_marks/bar.py</span>
<span class="gh">index 66c20024..2aed6830 100644</span>
<span class="gd">--- a/seaborn/_marks/bar.py</span>
<span class="gi">+++ b/seaborn/_marks/bar.py</span>
<span class="gu">@@ -1,9 +1,22 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from dataclasses import dataclass
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gd">-from seaborn._marks.base import Mark, Mappable, MappableBool, MappableColor, MappableFloat, MappableStyle, resolve_properties, resolve_color, document_properties</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import (</span>
<span class="gi">+    Mark,</span>
<span class="gi">+    Mappable,</span>
<span class="gi">+    MappableBool,</span>
<span class="gi">+    MappableColor,</span>
<span class="gi">+    MappableFloat,</span>
<span class="gi">+    MappableStyle,</span>
<span class="gi">+    resolve_properties,</span>
<span class="gi">+    resolve_color,</span>
<span class="gi">+    document_properties</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Any
<span class="gu">@@ -12,7 +25,87 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class BarBase(Mark):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _make_patches(self, data, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        transform = scales[orient]._matplotlib_scale.get_transform()</span>
<span class="gi">+        forward = transform.transform</span>
<span class="gi">+        reverse = transform.inverted().transform</span>
<span class="gi">+</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+</span>
<span class="gi">+        pos = reverse(forward(data[orient]) - data[&quot;width&quot;] / 2)</span>
<span class="gi">+        width = reverse(forward(data[orient]) + data[&quot;width&quot;] / 2) - pos</span>
<span class="gi">+</span>
<span class="gi">+        val = (data[other] - data[&quot;baseline&quot;]).to_numpy()</span>
<span class="gi">+        base = data[&quot;baseline&quot;].to_numpy()</span>
<span class="gi">+</span>
<span class="gi">+        kws = self._resolve_properties(data, scales)</span>
<span class="gi">+        if orient == &quot;x&quot;:</span>
<span class="gi">+            kws.update(x=pos, y=base, w=width, h=val)</span>
<span class="gi">+        else:</span>
<span class="gi">+            kws.update(x=base, y=pos, w=val, h=width)</span>
<span class="gi">+</span>
<span class="gi">+        kws.pop(&quot;width&quot;, None)</span>
<span class="gi">+        kws.pop(&quot;baseline&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        val_dim = {&quot;x&quot;: &quot;h&quot;, &quot;y&quot;: &quot;w&quot;}[orient]</span>
<span class="gi">+        bars, vals = [], []</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(len(data)):</span>
<span class="gi">+</span>
<span class="gi">+            row = {k: v[i] for k, v in kws.items()}</span>
<span class="gi">+</span>
<span class="gi">+            # Skip bars with no value. It&#39;s possible we&#39;ll want to make this</span>
<span class="gi">+            # an option (i.e so you have an artist for animating or annotating),</span>
<span class="gi">+            # but let&#39;s keep things simple for now.</span>
<span class="gi">+            if not np.nan_to_num(row[val_dim]):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            bar = mpl.patches.Rectangle(</span>
<span class="gi">+                xy=(row[&quot;x&quot;], row[&quot;y&quot;]),</span>
<span class="gi">+                width=row[&quot;w&quot;],</span>
<span class="gi">+                height=row[&quot;h&quot;],</span>
<span class="gi">+                facecolor=row[&quot;facecolor&quot;],</span>
<span class="gi">+                edgecolor=row[&quot;edgecolor&quot;],</span>
<span class="gi">+                linestyle=row[&quot;edgestyle&quot;],</span>
<span class="gi">+                linewidth=row[&quot;edgewidth&quot;],</span>
<span class="gi">+                **self.artist_kws,</span>
<span class="gi">+            )</span>
<span class="gi">+            bars.append(bar)</span>
<span class="gi">+            vals.append(row[val_dim])</span>
<span class="gi">+</span>
<span class="gi">+        return bars, vals</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_properties(self, data, scales):</span>
<span class="gi">+</span>
<span class="gi">+        resolved = resolve_properties(self, data, scales)</span>
<span class="gi">+</span>
<span class="gi">+        resolved[&quot;facecolor&quot;] = resolve_color(self, data, &quot;&quot;, scales)</span>
<span class="gi">+        resolved[&quot;edgecolor&quot;] = resolve_color(self, data, &quot;edge&quot;, scales)</span>
<span class="gi">+</span>
<span class="gi">+        fc = resolved[&quot;facecolor&quot;]</span>
<span class="gi">+        if isinstance(fc, tuple):</span>
<span class="gi">+            resolved[&quot;facecolor&quot;] = fc[0], fc[1], fc[2], fc[3] * resolved[&quot;fill&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            fc[:, 3] = fc[:, 3] * resolved[&quot;fill&quot;]  # TODO Is inplace mod a problem?</span>
<span class="gi">+            resolved[&quot;facecolor&quot;] = fc</span>
<span class="gi">+</span>
<span class="gi">+        return resolved</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(</span>
<span class="gi">+        self, variables: list[str], value: Any, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; Artist:</span>
<span class="gi">+        # TODO return some sensible default?</span>
<span class="gi">+        key = {v: value for v in variables}</span>
<span class="gi">+        key = self._resolve_properties(key, scales)</span>
<span class="gi">+        artist = mpl.patches.Patch(</span>
<span class="gi">+            facecolor=key[&quot;facecolor&quot;],</span>
<span class="gi">+            edgecolor=key[&quot;edgecolor&quot;],</span>
<span class="gi">+            linewidth=key[&quot;edgewidth&quot;],</span>
<span class="gi">+            linestyle=key[&quot;edgestyle&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+        return artist</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -30,15 +123,56 @@ class Bar(BarBase):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Bar.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;, grouping=False)</span>
<span class="gd">-    alpha: MappableFloat = Mappable(0.7, grouping=False)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, grouping=False)</span>
<span class="gi">+    alpha: MappableFloat = Mappable(.7, grouping=False)</span>
<span class="w"> </span>    fill: MappableBool = Mappable(True, grouping=False)
<span class="gd">-    edgecolor: MappableColor = Mappable(depend=&#39;color&#39;, grouping=False)</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(depend=&quot;color&quot;, grouping=False)</span>
<span class="w"> </span>    edgealpha: MappableFloat = Mappable(1, grouping=False)
<span class="gd">-    edgewidth: MappableFloat = Mappable(rc=&#39;patch.linewidth&#39;, grouping=False)</span>
<span class="gd">-    edgestyle: MappableStyle = Mappable(&#39;-&#39;, grouping=False)</span>
<span class="gd">-    width: MappableFloat = Mappable(0.8, grouping=False)</span>
<span class="gd">-    baseline: MappableFloat = Mappable(0, grouping=False)</span>
<span class="gi">+    edgewidth: MappableFloat = Mappable(rc=&quot;patch.linewidth&quot;, grouping=False)</span>
<span class="gi">+    edgestyle: MappableStyle = Mappable(&quot;-&quot;, grouping=False)</span>
<span class="gi">+    # pattern: MappableString = Mappable(None)  # TODO no Property yet</span>
<span class="gi">+</span>
<span class="gi">+    width: MappableFloat = Mappable(.8, grouping=False)</span>
<span class="gi">+    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        val_idx = [&quot;y&quot;, &quot;x&quot;].index(orient)</span>
<span class="gi">+</span>
<span class="gi">+        for _, data, ax in split_gen():</span>
<span class="gi">+</span>
<span class="gi">+            bars, vals = self._make_patches(data, scales, orient)</span>
<span class="gi">+</span>
<span class="gi">+            for bar in bars:</span>
<span class="gi">+</span>
<span class="gi">+                # Because we are clipping the artist (see below), the edges end up</span>
<span class="gi">+                # looking half as wide as they actually are. I don&#39;t love this clumsy</span>
<span class="gi">+                # workaround, which is going to cause surprises if you work with the</span>
<span class="gi">+                # artists directly. We may need to revisit after feedback.</span>
<span class="gi">+                bar.set_linewidth(bar.get_linewidth() * 2)</span>
<span class="gi">+                linestyle = bar.get_linestyle()</span>
<span class="gi">+                if linestyle[1]:</span>
<span class="gi">+                    linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))</span>
<span class="gi">+                bar.set_linestyle(linestyle)</span>
<span class="gi">+</span>
<span class="gi">+                # This is a bit of a hack to handle the fact that the edge lines are</span>
<span class="gi">+                # centered on the actual extents of the bar, and overlap when bars are</span>
<span class="gi">+                # stacked or dodged. We may discover that this causes problems and needs</span>
<span class="gi">+                # to be revisited at some point. Also it should be faster to clip with</span>
<span class="gi">+                # a bbox than a path, but I cant&#39;t work out how to get the intersection</span>
<span class="gi">+                # with the axes bbox.</span>
<span class="gi">+                bar.set_clip_path(bar.get_path(), bar.get_transform() + ax.transData)</span>
<span class="gi">+                if self.artist_kws.get(&quot;clip_on&quot;, True):</span>
<span class="gi">+                    # It seems the above hack undoes the default axes clipping</span>
<span class="gi">+                    bar.set_clip_box(ax.bbox)</span>
<span class="gi">+                bar.sticky_edges[val_idx][:] = (0, np.inf)</span>
<span class="gi">+                ax.add_patch(bar)</span>
<span class="gi">+</span>
<span class="gi">+            # Add a container which is useful for, e.g. Axes.bar_label</span>
<span class="gi">+            orientation = {&quot;x&quot;: &quot;vertical&quot;, &quot;y&quot;: &quot;horizontal&quot;}[orient]</span>
<span class="gi">+            container_kws = dict(datavalues=vals, orientation=orientation)</span>
<span class="gi">+            container = mpl.container.BarContainer(bars, **container_kws)</span>
<span class="gi">+            ax.add_container(container)</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -56,12 +190,63 @@ class Bars(BarBase):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Bars.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;, grouping=False)</span>
<span class="gd">-    alpha: MappableFloat = Mappable(0.7, grouping=False)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, grouping=False)</span>
<span class="gi">+    alpha: MappableFloat = Mappable(.7, grouping=False)</span>
<span class="w"> </span>    fill: MappableBool = Mappable(True, grouping=False)
<span class="gd">-    edgecolor: MappableColor = Mappable(rc=&#39;patch.edgecolor&#39;, grouping=False)</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(rc=&quot;patch.edgecolor&quot;, grouping=False)</span>
<span class="w"> </span>    edgealpha: MappableFloat = Mappable(1, grouping=False)
<span class="w"> </span>    edgewidth: MappableFloat = Mappable(auto=True, grouping=False)
<span class="gd">-    edgestyle: MappableStyle = Mappable(&#39;-&#39;, grouping=False)</span>
<span class="gi">+    edgestyle: MappableStyle = Mappable(&quot;-&quot;, grouping=False)</span>
<span class="gi">+    # pattern: MappableString = Mappable(None)  # TODO no Property yet</span>
<span class="gi">+</span>
<span class="w"> </span>    width: MappableFloat = Mappable(1, grouping=False)
<span class="gd">-    baseline: MappableFloat = Mappable(0, grouping=False)</span>
<span class="gi">+    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        ori_idx = [&quot;x&quot;, &quot;y&quot;].index(orient)</span>
<span class="gi">+        val_idx = [&quot;y&quot;, &quot;x&quot;].index(orient)</span>
<span class="gi">+</span>
<span class="gi">+        patches = defaultdict(list)</span>
<span class="gi">+        for _, data, ax in split_gen():</span>
<span class="gi">+            bars, _ = self._make_patches(data, scales, orient)</span>
<span class="gi">+            patches[ax].extend(bars)</span>
<span class="gi">+</span>
<span class="gi">+        collections = {}</span>
<span class="gi">+        for ax, ax_patches in patches.items():</span>
<span class="gi">+</span>
<span class="gi">+            col = mpl.collections.PatchCollection(ax_patches, match_original=True)</span>
<span class="gi">+            col.sticky_edges[val_idx][:] = (0, np.inf)</span>
<span class="gi">+            ax.add_collection(col, autolim=False)</span>
<span class="gi">+            collections[ax] = col</span>
<span class="gi">+</span>
<span class="gi">+            # Workaround for matplotlib autoscaling bug</span>
<span class="gi">+            # https://github.com/matplotlib/matplotlib/issues/11898</span>
<span class="gi">+            # https://github.com/matplotlib/matplotlib/issues/23129</span>
<span class="gi">+            xys = np.vstack([path.vertices for path in col.get_paths()])</span>
<span class="gi">+            ax.update_datalim(xys)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;edgewidth&quot; not in scales and isinstance(self.edgewidth, Mappable):</span>
<span class="gi">+</span>
<span class="gi">+            for ax in collections:</span>
<span class="gi">+                ax.autoscale_view()</span>
<span class="gi">+</span>
<span class="gi">+            def get_dimensions(collection):</span>
<span class="gi">+                edges, widths = [], []</span>
<span class="gi">+                for verts in (path.vertices for path in collection.get_paths()):</span>
<span class="gi">+                    edges.append(min(verts[:, ori_idx]))</span>
<span class="gi">+                    widths.append(np.ptp(verts[:, ori_idx]))</span>
<span class="gi">+                return np.array(edges), np.array(widths)</span>
<span class="gi">+</span>
<span class="gi">+            min_width = np.inf</span>
<span class="gi">+            for ax, col in collections.items():</span>
<span class="gi">+                edges, widths = get_dimensions(col)</span>
<span class="gi">+                points = 72 / ax.figure.dpi * abs(</span>
<span class="gi">+                    ax.transData.transform([edges + widths] * 2)</span>
<span class="gi">+                    - ax.transData.transform([edges] * 2)</span>
<span class="gi">+                )</span>
<span class="gi">+                min_width = min(min_width, min(points[:, ori_idx]))</span>
<span class="gi">+</span>
<span class="gi">+            linewidth = min(.1 * min_width, mpl.rcParams[&quot;patch.linewidth&quot;])</span>
<span class="gi">+            for _, col in collections.items():</span>
<span class="gi">+                col.set_linewidth(linewidth)</span>
<span class="gh">diff --git a/seaborn/_marks/base.py b/seaborn/_marks/base.py</span>
<span class="gh">index 03ee03a9..ac8fdf4a 100644</span>
<span class="gd">--- a/seaborn/_marks/base.py</span>
<span class="gi">+++ b/seaborn/_marks/base.py</span>
<span class="gu">@@ -3,21 +3,35 @@ from dataclasses import dataclass, fields, field</span>
<span class="w"> </span>import textwrap
<span class="w"> </span>from typing import Any, Callable, Union
<span class="w"> </span>from collections.abc import Generator
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="gi">+</span>
<span class="w"> </span>from numpy import ndarray
<span class="w"> </span>from pandas import DataFrame
<span class="w"> </span>from matplotlib.artist import Artist
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="gd">-from seaborn._core.properties import PROPERTIES, Property, RGBATuple, DashPattern, DashPatternWithOffset</span>
<span class="gi">+from seaborn._core.properties import (</span>
<span class="gi">+    PROPERTIES,</span>
<span class="gi">+    Property,</span>
<span class="gi">+    RGBATuple,</span>
<span class="gi">+    DashPattern,</span>
<span class="gi">+    DashPatternWithOffset,</span>
<span class="gi">+)</span>
<span class="w"> </span>from seaborn._core.exceptions import PlotSpecError


<span class="w"> </span>class Mappable:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, val: Any=None, depend: (str | None)=None, rc: (str |</span>
<span class="gd">-        None)=None, auto: bool=False, grouping: bool=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        val: Any = None,</span>
<span class="gi">+        depend: str | None = None,</span>
<span class="gi">+        rc: str | None = None,</span>
<span class="gi">+        auto: bool = False,</span>
<span class="gi">+        grouping: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Property that can be mapped from data or set directly, with flexible defaults.

<span class="gu">@@ -39,6 +53,7 @@ class Mappable:</span>
<span class="w"> </span>            assert depend in PROPERTIES
<span class="w"> </span>        if rc is not None:
<span class="w"> </span>            assert rc in mpl.rcParams
<span class="gi">+</span>
<span class="w"> </span>        self._val = val
<span class="w"> </span>        self._rc = rc
<span class="w"> </span>        self._depend = depend
<span class="gu">@@ -48,27 +63,36 @@ class Mappable:</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Nice formatting for when object appears in Mark init signature.&quot;&quot;&quot;
<span class="w"> </span>        if self._val is not None:
<span class="gd">-            s = f&#39;&lt;{repr(self._val)}&gt;&#39;</span>
<span class="gi">+            s = f&quot;&lt;{repr(self._val)}&gt;&quot;</span>
<span class="w"> </span>        elif self._depend is not None:
<span class="gd">-            s = f&#39;&lt;depend:{self._depend}&gt;&#39;</span>
<span class="gi">+            s = f&quot;&lt;depend:{self._depend}&gt;&quot;</span>
<span class="w"> </span>        elif self._rc is not None:
<span class="gd">-            s = f&#39;&lt;rc:{self._rc}&gt;&#39;</span>
<span class="gi">+            s = f&quot;&lt;rc:{self._rc}&gt;&quot;</span>
<span class="w"> </span>        elif self._auto:
<span class="gd">-            s = &#39;&lt;auto&gt;&#39;</span>
<span class="gi">+            s = &quot;&lt;auto&gt;&quot;</span>
<span class="w"> </span>        else:
<span class="gd">-            s = &#39;&lt;undefined&gt;&#39;</span>
<span class="gi">+            s = &quot;&lt;undefined&gt;&quot;</span>
<span class="w"> </span>        return s

<span class="w"> </span>    @property
<span class="gd">-    def depend(self) -&gt;Any:</span>
<span class="gi">+    def depend(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the name of the feature to source a default value from.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._depend</span>

<span class="w"> </span>    @property
<span class="gd">-    def default(self) -&gt;Any:</span>
<span class="gi">+    def grouping(self) -&gt; bool:</span>
<span class="gi">+        return self._grouping</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def default(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the default value for this feature, or access the relevant rcParam.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._val is not None:</span>
<span class="gi">+            return self._val</span>
<span class="gi">+        elif self._rc is not None:</span>
<span class="gi">+            return mpl.rcParams.get(self._rc)</span>
<span class="gi">+</span>

<span class="gi">+# TODO where is the right place to put this kind of type aliasing?</span>

<span class="w"> </span>MappableBool = Union[bool, Mappable]
<span class="w"> </span>MappableString = Union[str, Mappable]
<span class="gu">@@ -80,10 +104,32 @@ MappableStyle = Union[str, DashPattern, DashPatternWithOffset, Mappable]</span>
<span class="w"> </span>@dataclass
<span class="w"> </span>class Mark:
<span class="w"> </span>    &quot;&quot;&quot;Base class for objects that visually represent data.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    artist_kws: dict = field(default_factory=dict)

<span class="gd">-    def _resolve(self, data: (DataFrame | dict[str, Any]), name: str,</span>
<span class="gd">-        scales: (dict[str, Scale] | None)=None) -&gt;Any:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _mappable_props(self):</span>
<span class="gi">+        return {</span>
<span class="gi">+            f.name: getattr(self, f.name) for f in fields(self)</span>
<span class="gi">+            if isinstance(f.default, Mappable)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _grouping_props(self):</span>
<span class="gi">+        # TODO does it make sense to have variation within a Mark&#39;s</span>
<span class="gi">+        # properties about whether they are grouping?</span>
<span class="gi">+        return [</span>
<span class="gi">+            f.name for f in fields(self)</span>
<span class="gi">+            if isinstance(f.default, Mappable) and f.default.grouping</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    # TODO make this method private? Would extender every need to call directly?</span>
<span class="gi">+    def _resolve(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: DataFrame | dict[str, Any],</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        scales: dict[str, Scale] | None = None,</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Obtain default, specified, or mapped value for a named feature.

<span class="w"> </span>        Parameters
<span class="gu">@@ -103,16 +149,102 @@ class Mark:</span>
<span class="w"> </span>            of values with matching length).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        feature = self._mappable_props[name]</span>
<span class="gi">+        prop = PROPERTIES.get(name, Property(name))</span>
<span class="gi">+        directly_specified = not isinstance(feature, Mappable)</span>
<span class="gi">+        return_multiple = isinstance(data, pd.DataFrame)</span>
<span class="gi">+        return_array = return_multiple and not name.endswith(&quot;style&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Special case width because it needs to be resolved and added to the dataframe</span>
<span class="gi">+        # during layer prep (so the Move operations use it properly).</span>
<span class="gi">+        # TODO how does width *scaling* work, e.g. for violin width by count?</span>
<span class="gi">+        if name == &quot;width&quot;:</span>
<span class="gi">+            directly_specified = directly_specified and name not in data</span>
<span class="gi">+</span>
<span class="gi">+        if directly_specified:</span>
<span class="gi">+            feature = prop.standardize(feature)</span>
<span class="gi">+            if return_multiple:</span>
<span class="gi">+                feature = [feature] * len(data)</span>
<span class="gi">+            if return_array:</span>
<span class="gi">+                feature = np.array(feature)</span>
<span class="gi">+            return feature</span>
<span class="gi">+</span>
<span class="gi">+        if name in data:</span>
<span class="gi">+            if scales is None or name not in scales:</span>
<span class="gi">+                # TODO Might this obviate the identity scale? Just don&#39;t add a scale?</span>
<span class="gi">+                feature = data[name]</span>
<span class="gi">+            else:</span>
<span class="gi">+                scale = scales[name]</span>
<span class="gi">+                value = data[name]</span>
<span class="gi">+                try:</span>
<span class="gi">+                    feature = scale(value)</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    raise PlotSpecError._during(&quot;Scaling operation&quot;, name) from err</span>
<span class="gi">+</span>
<span class="gi">+            if return_array:</span>
<span class="gi">+                feature = np.asarray(feature)</span>
<span class="gi">+            return feature</span>
<span class="gi">+</span>
<span class="gi">+        if feature.depend is not None:</span>
<span class="gi">+            # TODO add source_func or similar to transform the source value?</span>
<span class="gi">+            # e.g. set linewidth as a proportion of pointsize?</span>
<span class="gi">+            return self._resolve(data, feature.depend, scales)</span>

<span class="gd">-    def _plot(self, split_generator: Callable[[], Generator], scales: dict[</span>
<span class="gd">-        str, Scale], orient: str) -&gt;None:</span>
<span class="gi">+        default = prop.standardize(feature.default)</span>
<span class="gi">+        if return_multiple:</span>
<span class="gi">+            default = [default] * len(data)</span>
<span class="gi">+        if return_array:</span>
<span class="gi">+            default = np.array(default)</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def _infer_orient(self, scales: dict) -&gt; str:  # TODO type scales</span>
<span class="gi">+</span>
<span class="gi">+        # TODO The original version of this (in seaborn._base) did more checking.</span>
<span class="gi">+        # Paring that down here for the prototype to see what restrictions make sense.</span>
<span class="gi">+</span>
<span class="gi">+        # TODO rethink this to map from scale type to &quot;DV priority&quot; and use that?</span>
<span class="gi">+        # e.g. Nominal &gt; Discrete &gt; Continuous</span>
<span class="gi">+</span>
<span class="gi">+        x = 0 if &quot;x&quot; not in scales else scales[&quot;x&quot;]._priority</span>
<span class="gi">+        y = 0 if &quot;y&quot; not in scales else scales[&quot;y&quot;]._priority</span>
<span class="gi">+</span>
<span class="gi">+        if y &gt; x:</span>
<span class="gi">+            return &quot;y&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(</span>
<span class="gi">+        self,</span>
<span class="gi">+        split_generator: Callable[[], Generator],</span>
<span class="gi">+        scales: dict[str, Scale],</span>
<span class="gi">+        orient: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Main interface for creating a plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(</span>
<span class="gi">+        self, variables: list[str], value: Any, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; Artist | None:</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="gi">+def resolve_properties(</span>
<span class="gi">+    mark: Mark, data: DataFrame, scales: dict[str, Scale]</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>

<span class="gd">-def resolve_color(mark: Mark, data: (DataFrame | dict), prefix: str=&#39;&#39;,</span>
<span class="gd">-    scales: (dict[str, Scale] | None)=None) -&gt;(RGBATuple | ndarray):</span>
<span class="gi">+    props = {</span>
<span class="gi">+        name: mark._resolve(data, name, scales) for name in mark._mappable_props</span>
<span class="gi">+    }</span>
<span class="gi">+    return props</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_color(</span>
<span class="gi">+    mark: Mark,</span>
<span class="gi">+    data: DataFrame | dict,</span>
<span class="gi">+    prefix: str = &quot;&quot;,</span>
<span class="gi">+    scales: dict[str, Scale] | None = None,</span>
<span class="gi">+) -&gt; RGBATuple | ndarray:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Obtain a default, specified, or mapped value for a color feature.

<span class="gu">@@ -133,4 +265,53 @@ def resolve_color(mark: Mark, data: (DataFrame | dict), prefix: str=&#39;&#39;,</span>
<span class="w"> </span>        Support &quot;color&quot;, &quot;fillcolor&quot;, etc.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    color = mark._resolve(data, f&quot;{prefix}color&quot;, scales)</span>
<span class="gi">+</span>
<span class="gi">+    if f&quot;{prefix}alpha&quot; in mark._mappable_props:</span>
<span class="gi">+        alpha = mark._resolve(data, f&quot;{prefix}alpha&quot;, scales)</span>
<span class="gi">+    else:</span>
<span class="gi">+        alpha = mark._resolve(data, &quot;alpha&quot;, scales)</span>
<span class="gi">+</span>
<span class="gi">+    def visible(x, axis=None):</span>
<span class="gi">+        &quot;&quot;&quot;Detect &quot;invisible&quot; colors to set alpha appropriately.&quot;&quot;&quot;</span>
<span class="gi">+        # TODO First clause only needed to handle non-rgba arrays,</span>
<span class="gi">+        # which we are trying to handle upstream</span>
<span class="gi">+        return np.array(x).dtype.kind != &quot;f&quot; or np.isfinite(x).all(axis)</span>
<span class="gi">+</span>
<span class="gi">+    # Second check here catches vectors of strings with identity scale</span>
<span class="gi">+    # It could probably be handled better upstream. This is a tricky problem</span>
<span class="gi">+    if np.ndim(color) &lt; 2 and all(isinstance(x, float) for x in color):</span>
<span class="gi">+        if len(color) == 4:</span>
<span class="gi">+            return mpl.colors.to_rgba(color)</span>
<span class="gi">+        alpha = alpha if visible(color) else np.nan</span>
<span class="gi">+        return mpl.colors.to_rgba(color, alpha)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if np.ndim(color) == 2 and color.shape[1] == 4:</span>
<span class="gi">+            return mpl.colors.to_rgba_array(color)</span>
<span class="gi">+        alpha = np.where(visible(color, axis=1), alpha, np.nan)</span>
<span class="gi">+        return mpl.colors.to_rgba_array(color, alpha)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO should we be implementing fill here too?</span>
<span class="gi">+    # (i.e. set fillalpha to 0 when fill=False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def document_properties(mark):</span>
<span class="gi">+</span>
<span class="gi">+    properties = [f.name for f in fields(mark) if isinstance(f.default, Mappable)]</span>
<span class="gi">+    text = [</span>
<span class="gi">+        &quot;&quot;,</span>
<span class="gi">+        &quot;    This mark defines the following properties:&quot;,</span>
<span class="gi">+        textwrap.fill(</span>
<span class="gi">+            &quot;, &quot;.join([f&quot;|{p}|&quot; for p in properties]),</span>
<span class="gi">+            width=78, initial_indent=&quot; &quot; * 8, subsequent_indent=&quot; &quot; * 8,</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    docstring_lines = mark.__doc__.split(&quot;\n&quot;)</span>
<span class="gi">+    new_docstring = &quot;\n&quot;.join([</span>
<span class="gi">+        *docstring_lines[:2],</span>
<span class="gi">+        *text,</span>
<span class="gi">+        *docstring_lines[2:],</span>
<span class="gi">+    ])</span>
<span class="gi">+    mark.__doc__ = new_docstring</span>
<span class="gi">+    return mark</span>
<span class="gh">diff --git a/seaborn/_marks/dot.py b/seaborn/_marks/dot.py</span>
<span class="gh">index c188ed0d..beef412d 100644</span>
<span class="gd">--- a/seaborn/_marks/dot.py</span>
<span class="gi">+++ b/seaborn/_marks/dot.py</span>
<span class="gu">@@ -1,8 +1,22 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gd">-from seaborn._marks.base import Mark, Mappable, MappableBool, MappableFloat, MappableString, MappableColor, MappableStyle, resolve_properties, resolve_color, document_properties</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import (</span>
<span class="gi">+    Mark,</span>
<span class="gi">+    Mappable,</span>
<span class="gi">+    MappableBool,</span>
<span class="gi">+    MappableFloat,</span>
<span class="gi">+    MappableString,</span>
<span class="gi">+    MappableColor,</span>
<span class="gi">+    MappableStyle,</span>
<span class="gi">+    resolve_properties,</span>
<span class="gi">+    resolve_color,</span>
<span class="gi">+    document_properties,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Any
<span class="gu">@@ -11,7 +25,82 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class DotBase(Mark):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_paths(self, data):</span>
<span class="gi">+</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        path_cache = {}</span>
<span class="gi">+        marker = data[&quot;marker&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        def get_transformed_path(m):</span>
<span class="gi">+            return m.get_path().transformed(m.get_transform())</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(marker, mpl.markers.MarkerStyle):</span>
<span class="gi">+            return get_transformed_path(marker)</span>
<span class="gi">+</span>
<span class="gi">+        for m in marker:</span>
<span class="gi">+            if m not in path_cache:</span>
<span class="gi">+                path_cache[m] = get_transformed_path(m)</span>
<span class="gi">+            paths.append(path_cache[m])</span>
<span class="gi">+        return paths</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_properties(self, data, scales):</span>
<span class="gi">+</span>
<span class="gi">+        resolved = resolve_properties(self, data, scales)</span>
<span class="gi">+        resolved[&quot;path&quot;] = self._resolve_paths(resolved)</span>
<span class="gi">+        resolved[&quot;size&quot;] = resolved[&quot;pointsize&quot;] ** 2</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(data, dict):  # Properties for single dot</span>
<span class="gi">+            filled_marker = resolved[&quot;marker&quot;].is_filled()</span>
<span class="gi">+        else:</span>
<span class="gi">+            filled_marker = [m.is_filled() for m in resolved[&quot;marker&quot;]]</span>
<span class="gi">+</span>
<span class="gi">+        resolved[&quot;fill&quot;] = resolved[&quot;fill&quot;] * filled_marker</span>
<span class="gi">+</span>
<span class="gi">+        return resolved</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO Not backcompat with allowed (but nonfunctional) univariate plots</span>
<span class="gi">+        # (That should be solved upstream by defaulting to &quot;&quot; for unset x/y?)</span>
<span class="gi">+        # (Be mindful of xmin/xmax, etc!)</span>
<span class="gi">+</span>
<span class="gi">+        for _, data, ax in split_gen():</span>
<span class="gi">+</span>
<span class="gi">+            offsets = np.column_stack([data[&quot;x&quot;], data[&quot;y&quot;]])</span>
<span class="gi">+            data = self._resolve_properties(data, scales)</span>
<span class="gi">+</span>
<span class="gi">+            points = mpl.collections.PathCollection(</span>
<span class="gi">+                offsets=offsets,</span>
<span class="gi">+                paths=data[&quot;path&quot;],</span>
<span class="gi">+                sizes=data[&quot;size&quot;],</span>
<span class="gi">+                facecolors=data[&quot;facecolor&quot;],</span>
<span class="gi">+                edgecolors=data[&quot;edgecolor&quot;],</span>
<span class="gi">+                linewidths=data[&quot;linewidth&quot;],</span>
<span class="gi">+                linestyles=data[&quot;edgestyle&quot;],</span>
<span class="gi">+                transOffset=ax.transData,</span>
<span class="gi">+                transform=mpl.transforms.IdentityTransform(),</span>
<span class="gi">+                **self.artist_kws,</span>
<span class="gi">+            )</span>
<span class="gi">+            ax.add_collection(points)</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(</span>
<span class="gi">+        self, variables: list[str], value: Any, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; Artist:</span>
<span class="gi">+</span>
<span class="gi">+        key = {v: value for v in variables}</span>
<span class="gi">+        res = self._resolve_properties(key, scales)</span>
<span class="gi">+</span>
<span class="gi">+        return mpl.collections.PathCollection(</span>
<span class="gi">+            paths=[res[&quot;path&quot;]],</span>
<span class="gi">+            sizes=[res[&quot;size&quot;]],</span>
<span class="gi">+            facecolors=[res[&quot;facecolor&quot;]],</span>
<span class="gi">+            edgecolors=[res[&quot;edgecolor&quot;]],</span>
<span class="gi">+            linewidths=[res[&quot;linewidth&quot;]],</span>
<span class="gi">+            linestyles=[res[&quot;edgestyle&quot;]],</span>
<span class="gi">+            transform=mpl.transforms.IdentityTransform(),</span>
<span class="gi">+            **self.artist_kws,</span>
<span class="gi">+        )</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -29,16 +118,43 @@ class Dot(DotBase):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Dot.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    marker: MappableString = Mappable(&#39;o&#39;, grouping=False)</span>
<span class="gd">-    pointsize: MappableFloat = Mappable(6, grouping=False)</span>
<span class="gd">-    stroke: MappableFloat = Mappable(0.75, grouping=False)</span>
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;, grouping=False)</span>
<span class="gi">+    marker: MappableString = Mappable(&quot;o&quot;, grouping=False)</span>
<span class="gi">+    pointsize: MappableFloat = Mappable(6, grouping=False)  # TODO rcParam?</span>
<span class="gi">+    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, grouping=False)</span>
<span class="w"> </span>    alpha: MappableFloat = Mappable(1, grouping=False)
<span class="w"> </span>    fill: MappableBool = Mappable(True, grouping=False)
<span class="gd">-    edgecolor: MappableColor = Mappable(depend=&#39;color&#39;, grouping=False)</span>
<span class="gd">-    edgealpha: MappableFloat = Mappable(depend=&#39;alpha&#39;, grouping=False)</span>
<span class="gd">-    edgewidth: MappableFloat = Mappable(0.5, grouping=False)</span>
<span class="gd">-    edgestyle: MappableStyle = Mappable(&#39;-&#39;, grouping=False)</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(depend=&quot;color&quot;, grouping=False)</span>
<span class="gi">+    edgealpha: MappableFloat = Mappable(depend=&quot;alpha&quot;, grouping=False)</span>
<span class="gi">+    edgewidth: MappableFloat = Mappable(.5, grouping=False)  # TODO rcParam?</span>
<span class="gi">+    edgestyle: MappableStyle = Mappable(&quot;-&quot;, grouping=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_properties(self, data, scales):</span>
<span class="gi">+</span>
<span class="gi">+        resolved = super()._resolve_properties(data, scales)</span>
<span class="gi">+        filled = resolved[&quot;fill&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        main_stroke = resolved[&quot;stroke&quot;]</span>
<span class="gi">+        edge_stroke = resolved[&quot;edgewidth&quot;]</span>
<span class="gi">+        resolved[&quot;linewidth&quot;] = np.where(filled, edge_stroke, main_stroke)</span>
<span class="gi">+</span>
<span class="gi">+        main_color = resolve_color(self, data, &quot;&quot;, scales)</span>
<span class="gi">+        edge_color = resolve_color(self, data, &quot;edge&quot;, scales)</span>
<span class="gi">+</span>
<span class="gi">+        if not np.isscalar(filled):</span>
<span class="gi">+            # Expand dims to use in np.where with rgba arrays</span>
<span class="gi">+            filled = filled[:, None]</span>
<span class="gi">+        resolved[&quot;edgecolor&quot;] = np.where(filled, edge_color, main_color)</span>
<span class="gi">+</span>
<span class="gi">+        filled = np.squeeze(filled)</span>
<span class="gi">+        if isinstance(main_color, tuple):</span>
<span class="gi">+            # TODO handle this in resolve_color</span>
<span class="gi">+            main_color = tuple([*main_color[:3], main_color[3] * filled])</span>
<span class="gi">+        else:</span>
<span class="gi">+            main_color = np.c_[main_color[:, :3], main_color[:, 3] * filled]</span>
<span class="gi">+        resolved[&quot;facecolor&quot;] = main_color</span>
<span class="gi">+</span>
<span class="gi">+        return resolved</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -56,11 +172,29 @@ class Dots(DotBase):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Dots.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    marker: MappableString = Mappable(rc=&#39;scatter.marker&#39;, grouping=False)</span>
<span class="gd">-    pointsize: MappableFloat = Mappable(4, grouping=False)</span>
<span class="gd">-    stroke: MappableFloat = Mappable(0.75, grouping=False)</span>
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;, grouping=False)</span>
<span class="gd">-    alpha: MappableFloat = Mappable(1, grouping=False)</span>
<span class="gi">+    # TODO retype marker as MappableMarker</span>
<span class="gi">+    marker: MappableString = Mappable(rc=&quot;scatter.marker&quot;, grouping=False)</span>
<span class="gi">+    pointsize: MappableFloat = Mappable(4, grouping=False)  # TODO rcParam?</span>
<span class="gi">+    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;, grouping=False)</span>
<span class="gi">+    alpha: MappableFloat = Mappable(1, grouping=False)  # TODO auto alpha?</span>
<span class="w"> </span>    fill: MappableBool = Mappable(True, grouping=False)
<span class="gd">-    fillcolor: MappableColor = Mappable(depend=&#39;color&#39;, grouping=False)</span>
<span class="gd">-    fillalpha: MappableFloat = Mappable(0.2, grouping=False)</span>
<span class="gi">+    fillcolor: MappableColor = Mappable(depend=&quot;color&quot;, grouping=False)</span>
<span class="gi">+    fillalpha: MappableFloat = Mappable(.2, grouping=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _resolve_properties(self, data, scales):</span>
<span class="gi">+</span>
<span class="gi">+        resolved = super()._resolve_properties(data, scales)</span>
<span class="gi">+        resolved[&quot;linewidth&quot;] = resolved.pop(&quot;stroke&quot;)</span>
<span class="gi">+        resolved[&quot;facecolor&quot;] = resolve_color(self, data, &quot;fill&quot;, scales)</span>
<span class="gi">+        resolved[&quot;edgecolor&quot;] = resolve_color(self, data, &quot;&quot;, scales)</span>
<span class="gi">+        resolved.setdefault(&quot;edgestyle&quot;, (0, None))</span>
<span class="gi">+</span>
<span class="gi">+        fc = resolved[&quot;facecolor&quot;]</span>
<span class="gi">+        if isinstance(fc, tuple):</span>
<span class="gi">+            resolved[&quot;facecolor&quot;] = fc[0], fc[1], fc[2], fc[3] * resolved[&quot;fill&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            fc[:, 3] = fc[:, 3] * resolved[&quot;fill&quot;]  # TODO Is inplace mod a problem?</span>
<span class="gi">+            resolved[&quot;facecolor&quot;] = fc</span>
<span class="gi">+</span>
<span class="gi">+        return resolved</span>
<span class="gh">diff --git a/seaborn/_marks/line.py b/seaborn/_marks/line.py</span>
<span class="gh">index 9ba99240..a517f1b8 100644</span>
<span class="gd">--- a/seaborn/_marks/line.py</span>
<span class="gi">+++ b/seaborn/_marks/line.py</span>
<span class="gu">@@ -1,9 +1,20 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gd">-from seaborn._marks.base import Mark, Mappable, MappableFloat, MappableString, MappableColor, resolve_properties, resolve_color, document_properties</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import (</span>
<span class="gi">+    Mark,</span>
<span class="gi">+    Mappable,</span>
<span class="gi">+    MappableFloat,</span>
<span class="gi">+    MappableString,</span>
<span class="gi">+    MappableColor,</span>
<span class="gi">+    resolve_properties,</span>
<span class="gi">+    resolve_color,</span>
<span class="gi">+    document_properties,</span>
<span class="gi">+)</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -22,17 +33,80 @@ class Path(Mark):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Path.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;)</span>
<span class="w"> </span>    alpha: MappableFloat = Mappable(1)
<span class="gd">-    linewidth: MappableFloat = Mappable(rc=&#39;lines.linewidth&#39;)</span>
<span class="gd">-    linestyle: MappableString = Mappable(rc=&#39;lines.linestyle&#39;)</span>
<span class="gd">-    marker: MappableString = Mappable(rc=&#39;lines.marker&#39;)</span>
<span class="gd">-    pointsize: MappableFloat = Mappable(rc=&#39;lines.markersize&#39;)</span>
<span class="gd">-    fillcolor: MappableColor = Mappable(depend=&#39;color&#39;)</span>
<span class="gd">-    edgecolor: MappableColor = Mappable(depend=&#39;color&#39;)</span>
<span class="gd">-    edgewidth: MappableFloat = Mappable(rc=&#39;lines.markeredgewidth&#39;)</span>
<span class="gi">+    linewidth: MappableFloat = Mappable(rc=&quot;lines.linewidth&quot;)</span>
<span class="gi">+    linestyle: MappableString = Mappable(rc=&quot;lines.linestyle&quot;)</span>
<span class="gi">+    marker: MappableString = Mappable(rc=&quot;lines.marker&quot;)</span>
<span class="gi">+    pointsize: MappableFloat = Mappable(rc=&quot;lines.markersize&quot;)</span>
<span class="gi">+    fillcolor: MappableColor = Mappable(depend=&quot;color&quot;)</span>
<span class="gi">+    edgecolor: MappableColor = Mappable(depend=&quot;color&quot;)</span>
<span class="gi">+    edgewidth: MappableFloat = Mappable(rc=&quot;lines.markeredgewidth&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    _sort: ClassVar[bool] = False

<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        for keys, data, ax in split_gen(keep_na=not self._sort):</span>
<span class="gi">+</span>
<span class="gi">+            vals = resolve_properties(self, keys, scales)</span>
<span class="gi">+            vals[&quot;color&quot;] = resolve_color(self, keys, scales=scales)</span>
<span class="gi">+            vals[&quot;fillcolor&quot;] = resolve_color(self, keys, prefix=&quot;fill&quot;, scales=scales)</span>
<span class="gi">+            vals[&quot;edgecolor&quot;] = resolve_color(self, keys, prefix=&quot;edge&quot;, scales=scales)</span>
<span class="gi">+</span>
<span class="gi">+            if self._sort:</span>
<span class="gi">+                data = data.sort_values(orient, kind=&quot;mergesort&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            artist_kws = self.artist_kws.copy()</span>
<span class="gi">+            self._handle_capstyle(artist_kws, vals)</span>
<span class="gi">+</span>
<span class="gi">+            line = mpl.lines.Line2D(</span>
<span class="gi">+                data[&quot;x&quot;].to_numpy(),</span>
<span class="gi">+                data[&quot;y&quot;].to_numpy(),</span>
<span class="gi">+                color=vals[&quot;color&quot;],</span>
<span class="gi">+                linewidth=vals[&quot;linewidth&quot;],</span>
<span class="gi">+                linestyle=vals[&quot;linestyle&quot;],</span>
<span class="gi">+                marker=vals[&quot;marker&quot;],</span>
<span class="gi">+                markersize=vals[&quot;pointsize&quot;],</span>
<span class="gi">+                markerfacecolor=vals[&quot;fillcolor&quot;],</span>
<span class="gi">+                markeredgecolor=vals[&quot;edgecolor&quot;],</span>
<span class="gi">+                markeredgewidth=vals[&quot;edgewidth&quot;],</span>
<span class="gi">+                **artist_kws,</span>
<span class="gi">+            )</span>
<span class="gi">+            ax.add_line(line)</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(self, variables, value, scales):</span>
<span class="gi">+</span>
<span class="gi">+        keys = {v: value for v in variables}</span>
<span class="gi">+        vals = resolve_properties(self, keys, scales)</span>
<span class="gi">+        vals[&quot;color&quot;] = resolve_color(self, keys, scales=scales)</span>
<span class="gi">+        vals[&quot;fillcolor&quot;] = resolve_color(self, keys, prefix=&quot;fill&quot;, scales=scales)</span>
<span class="gi">+        vals[&quot;edgecolor&quot;] = resolve_color(self, keys, prefix=&quot;edge&quot;, scales=scales)</span>
<span class="gi">+</span>
<span class="gi">+        artist_kws = self.artist_kws.copy()</span>
<span class="gi">+        self._handle_capstyle(artist_kws, vals)</span>
<span class="gi">+</span>
<span class="gi">+        return mpl.lines.Line2D(</span>
<span class="gi">+            [], [],</span>
<span class="gi">+            color=vals[&quot;color&quot;],</span>
<span class="gi">+            linewidth=vals[&quot;linewidth&quot;],</span>
<span class="gi">+            linestyle=vals[&quot;linestyle&quot;],</span>
<span class="gi">+            marker=vals[&quot;marker&quot;],</span>
<span class="gi">+            markersize=vals[&quot;pointsize&quot;],</span>
<span class="gi">+            markerfacecolor=vals[&quot;fillcolor&quot;],</span>
<span class="gi">+            markeredgecolor=vals[&quot;edgecolor&quot;],</span>
<span class="gi">+            markeredgewidth=vals[&quot;edgewidth&quot;],</span>
<span class="gi">+            **artist_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_capstyle(self, kws, vals):</span>
<span class="gi">+</span>
<span class="gi">+        # Work around for this matplotlib issue:</span>
<span class="gi">+        # https://github.com/matplotlib/matplotlib/issues/23437</span>
<span class="gi">+        if vals[&quot;linestyle&quot;][1] is None:</span>
<span class="gi">+            capstyle = kws.get(&quot;solid_capstyle&quot;, mpl.rcParams[&quot;lines.solid_capstyle&quot;])</span>
<span class="gi">+            kws[&quot;dash_capstyle&quot;] = capstyle</span>
<span class="gi">+</span>

<span class="w"> </span>@document_properties
<span class="w"> </span>@dataclass
<span class="gu">@@ -68,15 +142,80 @@ class Paths(Mark):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Paths.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    color: MappableColor = Mappable(&#39;C0&#39;)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;C0&quot;)</span>
<span class="w"> </span>    alpha: MappableFloat = Mappable(1)
<span class="gd">-    linewidth: MappableFloat = Mappable(rc=&#39;lines.linewidth&#39;)</span>
<span class="gd">-    linestyle: MappableString = Mappable(rc=&#39;lines.linestyle&#39;)</span>
<span class="gi">+    linewidth: MappableFloat = Mappable(rc=&quot;lines.linewidth&quot;)</span>
<span class="gi">+    linestyle: MappableString = Mappable(rc=&quot;lines.linestyle&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    _sort: ClassVar[bool] = False

<span class="w"> </span>    def __post_init__(self):
<span class="gd">-        self.artist_kws.setdefault(&#39;capstyle&#39;, mpl.rcParams[</span>
<span class="gd">-            &#39;lines.solid_capstyle&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        # LineCollection artists have a capstyle property but don&#39;t source its value</span>
<span class="gi">+        # from the rc, so we do that manually here. Unfortunately, because we add</span>
<span class="gi">+        # only one LineCollection, we have the use the same capstyle for all lines</span>
<span class="gi">+        # even when they are dashed. It&#39;s a slight inconsistency, but looks fine IMO.</span>
<span class="gi">+        self.artist_kws.setdefault(&quot;capstyle&quot;, mpl.rcParams[&quot;lines.solid_capstyle&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        line_data = {}</span>
<span class="gi">+        for keys, data, ax in split_gen(keep_na=not self._sort):</span>
<span class="gi">+</span>
<span class="gi">+            if ax not in line_data:</span>
<span class="gi">+                line_data[ax] = {</span>
<span class="gi">+                    &quot;segments&quot;: [],</span>
<span class="gi">+                    &quot;colors&quot;: [],</span>
<span class="gi">+                    &quot;linewidths&quot;: [],</span>
<span class="gi">+                    &quot;linestyles&quot;: [],</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            segments = self._setup_segments(data, orient)</span>
<span class="gi">+            line_data[ax][&quot;segments&quot;].extend(segments)</span>
<span class="gi">+            n = len(segments)</span>
<span class="gi">+</span>
<span class="gi">+            vals = resolve_properties(self, keys, scales)</span>
<span class="gi">+            vals[&quot;color&quot;] = resolve_color(self, keys, scales=scales)</span>
<span class="gi">+</span>
<span class="gi">+            line_data[ax][&quot;colors&quot;].extend([vals[&quot;color&quot;]] * n)</span>
<span class="gi">+            line_data[ax][&quot;linewidths&quot;].extend([vals[&quot;linewidth&quot;]] * n)</span>
<span class="gi">+            line_data[ax][&quot;linestyles&quot;].extend([vals[&quot;linestyle&quot;]] * n)</span>
<span class="gi">+</span>
<span class="gi">+        for ax, ax_data in line_data.items():</span>
<span class="gi">+            lines = mpl.collections.LineCollection(**ax_data, **self.artist_kws)</span>
<span class="gi">+            # Handle datalim update manually</span>
<span class="gi">+            # https://github.com/matplotlib/matplotlib/issues/23129</span>
<span class="gi">+            ax.add_collection(lines, autolim=False)</span>
<span class="gi">+            if ax_data[&quot;segments&quot;]:</span>
<span class="gi">+                xy = np.concatenate(ax_data[&quot;segments&quot;])</span>
<span class="gi">+                ax.update_datalim(xy)</span>
<span class="gi">+</span>
<span class="gi">+    def _legend_artist(self, variables, value, scales):</span>
<span class="gi">+</span>
<span class="gi">+        key = resolve_properties(self, {v: value for v in variables}, scales)</span>
<span class="gi">+</span>
<span class="gi">+        artist_kws = self.artist_kws.copy()</span>
<span class="gi">+        capstyle = artist_kws.pop(&quot;capstyle&quot;)</span>
<span class="gi">+        artist_kws[&quot;solid_capstyle&quot;] = capstyle</span>
<span class="gi">+        artist_kws[&quot;dash_capstyle&quot;] = capstyle</span>
<span class="gi">+</span>
<span class="gi">+        return mpl.lines.Line2D(</span>
<span class="gi">+            [], [],</span>
<span class="gi">+            color=key[&quot;color&quot;],</span>
<span class="gi">+            linewidth=key[&quot;linewidth&quot;],</span>
<span class="gi">+            linestyle=key[&quot;linestyle&quot;],</span>
<span class="gi">+            **artist_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_segments(self, data, orient):</span>
<span class="gi">+</span>
<span class="gi">+        if self._sort:</span>
<span class="gi">+            data = data.sort_values(orient, kind=&quot;mergesort&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Column stack to avoid block consolidation</span>
<span class="gi">+        xy = np.column_stack([data[&quot;x&quot;], data[&quot;y&quot;]])</span>
<span class="gi">+</span>
<span class="gi">+        return [xy]</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -108,6 +247,19 @@ class Range(Paths):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Range.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def _setup_segments(self, data, orient):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO better checks on what variables we have</span>
<span class="gi">+        # TODO what if only one exist?</span>
<span class="gi">+        val = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        if not set(data.columns) &amp; {f&quot;{val}min&quot;, f&quot;{val}max&quot;}:</span>
<span class="gi">+            agg = {f&quot;{val}min&quot;: (val, &quot;min&quot;), f&quot;{val}max&quot;: (val, &quot;max&quot;)}</span>
<span class="gi">+            data = data.groupby(orient).agg(**agg).reset_index()</span>
<span class="gi">+</span>
<span class="gi">+        cols = [orient, f&quot;{val}min&quot;, f&quot;{val}max&quot;]</span>
<span class="gi">+        data = data[cols].melt(orient, value_name=val)[[&quot;x&quot;, &quot;y&quot;]]</span>
<span class="gi">+        segments = [d.to_numpy() for _, d in data.groupby(orient)]</span>
<span class="gi">+        return segments</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -121,4 +273,13 @@ class Dash(Paths):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Dash.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    width: MappableFloat = Mappable(0.8, grouping=False)</span>
<span class="gi">+    width: MappableFloat = Mappable(.8, grouping=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _setup_segments(self, data, orient):</span>
<span class="gi">+</span>
<span class="gi">+        ori = [&quot;x&quot;, &quot;y&quot;].index(orient)</span>
<span class="gi">+        xys = data[[&quot;x&quot;, &quot;y&quot;]].to_numpy().astype(float)</span>
<span class="gi">+        segments = np.stack([xys, xys], axis=1)</span>
<span class="gi">+        segments[:, 0, ori] -= data[&quot;width&quot;] / 2</span>
<span class="gi">+        segments[:, 1, ori] += data[&quot;width&quot;] / 2</span>
<span class="gi">+        return segments</span>
<span class="gh">diff --git a/seaborn/_marks/text.py b/seaborn/_marks/text.py</span>
<span class="gh">index 5c00231f..58d757c1 100644</span>
<span class="gd">--- a/seaborn/_marks/text.py</span>
<span class="gi">+++ b/seaborn/_marks/text.py</span>
<span class="gu">@@ -1,10 +1,21 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from dataclasses import dataclass
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from matplotlib.transforms import ScaledTranslation
<span class="gd">-from seaborn._marks.base import Mark, Mappable, MappableFloat, MappableString, MappableColor, resolve_properties, resolve_color, document_properties</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import (</span>
<span class="gi">+    Mark,</span>
<span class="gi">+    Mappable,</span>
<span class="gi">+    MappableFloat,</span>
<span class="gi">+    MappableString,</span>
<span class="gi">+    MappableColor,</span>
<span class="gi">+    resolve_properties,</span>
<span class="gi">+    resolve_color,</span>
<span class="gi">+    document_properties,</span>
<span class="gi">+)</span>


<span class="w"> </span>@document_properties
<span class="gu">@@ -18,10 +29,48 @@ class Text(Mark):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Text.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    text: MappableString = Mappable(&#39;&#39;)</span>
<span class="gd">-    color: MappableColor = Mappable(&#39;k&#39;)</span>
<span class="gi">+    text: MappableString = Mappable(&quot;&quot;)</span>
<span class="gi">+    color: MappableColor = Mappable(&quot;k&quot;)</span>
<span class="w"> </span>    alpha: MappableFloat = Mappable(1)
<span class="gd">-    fontsize: MappableFloat = Mappable(rc=&#39;font.size&#39;)</span>
<span class="gd">-    halign: MappableString = Mappable(&#39;center&#39;)</span>
<span class="gd">-    valign: MappableString = Mappable(&#39;center_baseline&#39;)</span>
<span class="gi">+    fontsize: MappableFloat = Mappable(rc=&quot;font.size&quot;)</span>
<span class="gi">+    halign: MappableString = Mappable(&quot;center&quot;)</span>
<span class="gi">+    valign: MappableString = Mappable(&quot;center_baseline&quot;)</span>
<span class="w"> </span>    offset: MappableFloat = Mappable(4)
<span class="gi">+</span>
<span class="gi">+    def _plot(self, split_gen, scales, orient):</span>
<span class="gi">+</span>
<span class="gi">+        ax_data = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        for keys, data, ax in split_gen():</span>
<span class="gi">+</span>
<span class="gi">+            vals = resolve_properties(self, keys, scales)</span>
<span class="gi">+            color = resolve_color(self, keys, &quot;&quot;, scales)</span>
<span class="gi">+</span>
<span class="gi">+            halign = vals[&quot;halign&quot;]</span>
<span class="gi">+            valign = vals[&quot;valign&quot;]</span>
<span class="gi">+            fontsize = vals[&quot;fontsize&quot;]</span>
<span class="gi">+            offset = vals[&quot;offset&quot;] / 72</span>
<span class="gi">+</span>
<span class="gi">+            offset_trans = ScaledTranslation(</span>
<span class="gi">+                {&quot;right&quot;: -offset, &quot;left&quot;: +offset}.get(halign, 0),</span>
<span class="gi">+                {&quot;top&quot;: -offset, &quot;bottom&quot;: +offset, &quot;baseline&quot;: +offset}.get(valign, 0),</span>
<span class="gi">+                ax.figure.dpi_scale_trans,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            for row in data.to_dict(&quot;records&quot;):</span>
<span class="gi">+                artist = mpl.text.Text(</span>
<span class="gi">+                    x=row[&quot;x&quot;],</span>
<span class="gi">+                    y=row[&quot;y&quot;],</span>
<span class="gi">+                    text=str(row.get(&quot;text&quot;, vals[&quot;text&quot;])),</span>
<span class="gi">+                    color=color,</span>
<span class="gi">+                    fontsize=fontsize,</span>
<span class="gi">+                    horizontalalignment=halign,</span>
<span class="gi">+                    verticalalignment=valign,</span>
<span class="gi">+                    transform=ax.transData + offset_trans,</span>
<span class="gi">+                    **self.artist_kws,</span>
<span class="gi">+                )</span>
<span class="gi">+                ax.add_artist(artist)</span>
<span class="gi">+                ax_data[ax].append([row[&quot;x&quot;], row[&quot;y&quot;]])</span>
<span class="gi">+</span>
<span class="gi">+        for ax, ax_vals in ax_data.items():</span>
<span class="gi">+            ax.update_datalim(np.array(ax_vals))</span>
<span class="gh">diff --git a/seaborn/_statistics.py b/seaborn/_statistics.py</span>
<span class="gh">index 2b81faf7..40346b02 100644</span>
<span class="gd">--- a/seaborn/_statistics.py</span>
<span class="gi">+++ b/seaborn/_statistics.py</span>
<span class="gu">@@ -34,15 +34,22 @@ try:</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from .external.kde import gaussian_kde
<span class="w"> </span>    _no_scipy = True
<span class="gi">+</span>
<span class="w"> </span>from .algorithms import bootstrap
<span class="w"> </span>from .utils import _check_argument


<span class="w"> </span>class KDE:
<span class="w"> </span>    &quot;&quot;&quot;Univariate and bivariate kernel density estimator.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, bw_method=None, bw_adjust=1, gridsize=200, cut=3,</span>
<span class="gd">-        clip=None, cumulative=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, *,</span>
<span class="gi">+        bw_method=None,</span>
<span class="gi">+        bw_adjust=1,</span>
<span class="gi">+        gridsize=200,</span>
<span class="gi">+        cut=3,</span>
<span class="gi">+        clip=None,</span>
<span class="gi">+        cumulative=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the estimator with its parameters.

<span class="w"> </span>        Parameters
<span class="gu">@@ -67,43 +74,118 @@ class KDE:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if clip is None:
<span class="w"> </span>            clip = None, None
<span class="gi">+</span>
<span class="w"> </span>        self.bw_method = bw_method
<span class="w"> </span>        self.bw_adjust = bw_adjust
<span class="w"> </span>        self.gridsize = gridsize
<span class="w"> </span>        self.cut = cut
<span class="w"> </span>        self.clip = clip
<span class="w"> </span>        self.cumulative = cumulative
<span class="gi">+</span>
<span class="w"> </span>        if cumulative and _no_scipy:
<span class="gd">-            raise RuntimeError(&#39;Cumulative KDE evaluation requires scipy&#39;)</span>
<span class="gi">+            raise RuntimeError(&quot;Cumulative KDE evaluation requires scipy&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.support = None

<span class="w"> </span>    def _define_support_grid(self, x, bw, cut, clip, gridsize):
<span class="w"> </span>        &quot;&quot;&quot;Create the grid of evaluation points depending for vector x.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clip_lo = -np.inf if clip[0] is None else clip[0]</span>
<span class="gi">+        clip_hi = +np.inf if clip[1] is None else clip[1]</span>
<span class="gi">+        gridmin = max(x.min() - bw * cut, clip_lo)</span>
<span class="gi">+        gridmax = min(x.max() + bw * cut, clip_hi)</span>
<span class="gi">+        return np.linspace(gridmin, gridmax, gridsize)</span>

<span class="w"> </span>    def _define_support_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Create a 1D grid of evaluation points.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kde = self._fit(x, weights)</span>
<span class="gi">+        bw = np.sqrt(kde.covariance.squeeze())</span>
<span class="gi">+        grid = self._define_support_grid(</span>
<span class="gi">+            x, bw, self.cut, self.clip, self.gridsize</span>
<span class="gi">+        )</span>
<span class="gi">+        return grid</span>

<span class="w"> </span>    def _define_support_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Create a 2D grid of evaluation points.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clip = self.clip</span>
<span class="gi">+        if clip[0] is None or np.isscalar(clip[0]):</span>
<span class="gi">+            clip = (clip, clip)</span>
<span class="gi">+</span>
<span class="gi">+        kde = self._fit([x1, x2], weights)</span>
<span class="gi">+        bw = np.sqrt(np.diag(kde.covariance).squeeze())</span>
<span class="gi">+</span>
<span class="gi">+        grid1 = self._define_support_grid(</span>
<span class="gi">+            x1, bw[0], self.cut, clip[0], self.gridsize</span>
<span class="gi">+        )</span>
<span class="gi">+        grid2 = self._define_support_grid(</span>
<span class="gi">+            x2, bw[1], self.cut, clip[1], self.gridsize</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return grid1, grid2</span>

<span class="w"> </span>    def define_support(self, x1, x2=None, weights=None, cache=True):
<span class="w"> </span>        &quot;&quot;&quot;Create the evaluation grid for a given data set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if x2 is None:</span>
<span class="gi">+            support = self._define_support_univariate(x1, weights)</span>
<span class="gi">+        else:</span>
<span class="gi">+            support = self._define_support_bivariate(x1, x2, weights)</span>
<span class="gi">+</span>
<span class="gi">+        if cache:</span>
<span class="gi">+            self.support = support</span>
<span class="gi">+</span>
<span class="gi">+        return support</span>

<span class="w"> </span>    def _fit(self, fit_data, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit the scipy kde while adding bw_adjust logic and version check.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fit_kws = {&quot;bw_method&quot;: self.bw_method}</span>
<span class="gi">+        if weights is not None:</span>
<span class="gi">+            fit_kws[&quot;weights&quot;] = weights</span>
<span class="gi">+</span>
<span class="gi">+        kde = gaussian_kde(fit_data, **fit_kws)</span>
<span class="gi">+        kde.set_bandwidth(kde.factor * self.bw_adjust)</span>
<span class="gi">+</span>
<span class="gi">+        return kde</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate a univariate on univariate data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        support = self.support</span>
<span class="gi">+        if support is None:</span>
<span class="gi">+            support = self.define_support(x, cache=False)</span>
<span class="gi">+</span>
<span class="gi">+        kde = self._fit(x, weights)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            s_0 = support[0]</span>
<span class="gi">+            density = np.array([</span>
<span class="gi">+                kde.integrate_box_1d(s_0, s_i) for s_i in support</span>
<span class="gi">+            ])</span>
<span class="gi">+        else:</span>
<span class="gi">+            density = kde(support)</span>
<span class="gi">+</span>
<span class="gi">+        return density, support</span>

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate a univariate on bivariate data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        support = self.support</span>
<span class="gi">+        if support is None:</span>
<span class="gi">+            support = self.define_support(x1, x2, cache=False)</span>
<span class="gi">+</span>
<span class="gi">+        kde = self._fit([x1, x2], weights)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+</span>
<span class="gi">+            grid1, grid2 = support</span>
<span class="gi">+            density = np.zeros((grid1.size, grid2.size))</span>
<span class="gi">+            p0 = grid1.min(), grid2.min()</span>
<span class="gi">+            for i, xi in enumerate(grid1):</span>
<span class="gi">+                for j, xj in enumerate(grid2):</span>
<span class="gi">+                    density[i, j] = kde.integrate_box(p0, (xi, xj))</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            xx1, xx2 = np.meshgrid(*support)</span>
<span class="gi">+            density = kde([xx1.ravel(), xx2.ravel()]).reshape(xx1.shape)</span>
<span class="gi">+</span>
<span class="gi">+        return density, support</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit and evaluate on univariate or bivariate data.&quot;&quot;&quot;
<span class="gu">@@ -113,11 +195,19 @@ class KDE:</span>
<span class="w"> </span>            return self._eval_bivariate(x1, x2, weights)


<span class="gi">+# Note: we no longer use this for univariate histograms in histplot,</span>
<span class="gi">+# preferring _stats.Hist. We&#39;ll deprecate this once we have a bivariate Stat class.</span>
<span class="w"> </span>class Histogram:
<span class="w"> </span>    &quot;&quot;&quot;Univariate and bivariate histogram estimator.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, stat=&#39;count&#39;, bins=&#39;auto&#39;, binwidth=None, binrange=</span>
<span class="gd">-        None, discrete=False, cumulative=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stat=&quot;count&quot;,</span>
<span class="gi">+        bins=&quot;auto&quot;,</span>
<span class="gi">+        binwidth=None,</span>
<span class="gi">+        binrange=None,</span>
<span class="gi">+        discrete=False,</span>
<span class="gi">+        cumulative=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the estimator with its parameters.

<span class="w"> </span>        Parameters
<span class="gu">@@ -148,33 +238,158 @@ class Histogram:</span>
<span class="w"> </span>            If True, return the cumulative statistic.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        stat_choices = [&#39;count&#39;, &#39;frequency&#39;, &#39;density&#39;, &#39;probability&#39;,</span>
<span class="gd">-            &#39;proportion&#39;, &#39;percent&#39;]</span>
<span class="gd">-        _check_argument(&#39;stat&#39;, stat_choices, stat)</span>
<span class="gi">+        stat_choices = [</span>
<span class="gi">+            &quot;count&quot;, &quot;frequency&quot;, &quot;density&quot;, &quot;probability&quot;, &quot;proportion&quot;, &quot;percent&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+        _check_argument(&quot;stat&quot;, stat_choices, stat)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.stat = stat
<span class="w"> </span>        self.bins = bins
<span class="w"> </span>        self.binwidth = binwidth
<span class="w"> </span>        self.binrange = binrange
<span class="w"> </span>        self.discrete = discrete
<span class="w"> </span>        self.cumulative = cumulative
<span class="gi">+</span>
<span class="w"> </span>        self.bin_kws = None

<span class="gd">-    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete</span>
<span class="gd">-        ):</span>
<span class="gi">+    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):</span>
<span class="w"> </span>        &quot;&quot;&quot;Inner function that takes bin parameters as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if binrange is None:</span>
<span class="gi">+            start, stop = x.min(), x.max()</span>
<span class="gi">+        else:</span>
<span class="gi">+            start, stop = binrange</span>
<span class="gi">+</span>
<span class="gi">+        if discrete:</span>
<span class="gi">+            bin_edges = np.arange(start - .5, stop + 1.5)</span>
<span class="gi">+        elif binwidth is not None:</span>
<span class="gi">+            step = binwidth</span>
<span class="gi">+            bin_edges = np.arange(start, stop + step, step)</span>
<span class="gi">+            # Handle roundoff error (maybe there is a less clumsy way?)</span>
<span class="gi">+            if bin_edges.max() &lt; stop or len(bin_edges) &lt; 2:</span>
<span class="gi">+                bin_edges = np.append(bin_edges, bin_edges.max() + step)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bin_edges = np.histogram_bin_edges(</span>
<span class="gi">+                x, bins, binrange, weights,</span>
<span class="gi">+            )</span>
<span class="gi">+        return bin_edges</span>

<span class="w"> </span>    def define_bin_params(self, x1, x2=None, weights=None, cache=True):
<span class="w"> </span>        &quot;&quot;&quot;Given data, return numpy.histogram parameters to define bins.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if x2 is None:</span>
<span class="gi">+</span>
<span class="gi">+            bin_edges = self._define_bin_edges(</span>
<span class="gi">+                x1, weights, self.bins, self.binwidth, self.binrange, self.discrete,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(self.bins, (str, Number)):</span>
<span class="gi">+                n_bins = len(bin_edges) - 1</span>
<span class="gi">+                bin_range = bin_edges.min(), bin_edges.max()</span>
<span class="gi">+                bin_kws = dict(bins=n_bins, range=bin_range)</span>
<span class="gi">+            else:</span>
<span class="gi">+                bin_kws = dict(bins=bin_edges)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            bin_edges = []</span>
<span class="gi">+            for i, x in enumerate([x1, x2]):</span>
<span class="gi">+</span>
<span class="gi">+                # Resolve out whether bin parameters are shared</span>
<span class="gi">+                # or specific to each variable</span>
<span class="gi">+</span>
<span class="gi">+                bins = self.bins</span>
<span class="gi">+                if not bins or isinstance(bins, (str, Number)):</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif isinstance(bins[i], str):</span>
<span class="gi">+                    bins = bins[i]</span>
<span class="gi">+                elif len(bins) == 2:</span>
<span class="gi">+                    bins = bins[i]</span>
<span class="gi">+</span>
<span class="gi">+                binwidth = self.binwidth</span>
<span class="gi">+                if binwidth is None:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif not isinstance(binwidth, Number):</span>
<span class="gi">+                    binwidth = binwidth[i]</span>
<span class="gi">+</span>
<span class="gi">+                binrange = self.binrange</span>
<span class="gi">+                if binrange is None:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif not isinstance(binrange[0], Number):</span>
<span class="gi">+                    binrange = binrange[i]</span>
<span class="gi">+</span>
<span class="gi">+                discrete = self.discrete</span>
<span class="gi">+                if not isinstance(discrete, bool):</span>
<span class="gi">+                    discrete = discrete[i]</span>
<span class="gi">+</span>
<span class="gi">+                # Define the bins for this variable</span>
<span class="gi">+</span>
<span class="gi">+                bin_edges.append(self._define_bin_edges(</span>
<span class="gi">+                    x, weights, bins, binwidth, binrange, discrete,</span>
<span class="gi">+                ))</span>
<span class="gi">+</span>
<span class="gi">+            bin_kws = dict(bins=tuple(bin_edges))</span>
<span class="gi">+</span>
<span class="gi">+        if cache:</span>
<span class="gi">+            self.bin_kws = bin_kws</span>
<span class="gi">+</span>
<span class="gi">+        return bin_kws</span>

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for histogram of two variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bin_kws = self.bin_kws</span>
<span class="gi">+        if bin_kws is None:</span>
<span class="gi">+            bin_kws = self.define_bin_params(x1, x2, cache=False)</span>
<span class="gi">+</span>
<span class="gi">+        density = self.stat == &quot;density&quot;</span>
<span class="gi">+</span>
<span class="gi">+        hist, *bin_edges = np.histogram2d(</span>
<span class="gi">+            x1, x2, **bin_kws, weights=weights, density=density</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        area = np.outer(</span>
<span class="gi">+            np.diff(bin_edges[0]),</span>
<span class="gi">+            np.diff(bin_edges[1]),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.stat == &quot;probability&quot; or self.stat == &quot;proportion&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum()</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum() * 100</span>
<span class="gi">+        elif self.stat == &quot;frequency&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / area</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            if self.stat in [&quot;density&quot;, &quot;frequency&quot;]:</span>
<span class="gi">+                hist = (hist * area).cumsum(axis=0).cumsum(axis=1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                hist = hist.cumsum(axis=0).cumsum(axis=1)</span>
<span class="gi">+</span>
<span class="gi">+        return hist, bin_edges</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for histogram of one variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bin_kws = self.bin_kws</span>
<span class="gi">+        if bin_kws is None:</span>
<span class="gi">+            bin_kws = self.define_bin_params(x, weights=weights, cache=False)</span>
<span class="gi">+</span>
<span class="gi">+        density = self.stat == &quot;density&quot;</span>
<span class="gi">+        hist, bin_edges = np.histogram(</span>
<span class="gi">+            x, **bin_kws, weights=weights, density=density,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.stat == &quot;probability&quot; or self.stat == &quot;proportion&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum()</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum() * 100</span>
<span class="gi">+        elif self.stat == &quot;frequency&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / np.diff(bin_edges)</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            if self.stat in [&quot;density&quot;, &quot;frequency&quot;]:</span>
<span class="gi">+                hist = (hist * np.diff(bin_edges)).cumsum()</span>
<span class="gi">+            else:</span>
<span class="gi">+                hist = hist.cumsum()</span>
<span class="gi">+</span>
<span class="gi">+        return hist, bin_edges</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Count the occurrences in each bin, maybe normalize.&quot;&quot;&quot;
<span class="gu">@@ -186,8 +401,7 @@ class Histogram:</span>

<span class="w"> </span>class ECDF:
<span class="w"> </span>    &quot;&quot;&quot;Univariate empirical cumulative distribution estimator.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, stat=&#39;proportion&#39;, complementary=False):</span>
<span class="gi">+    def __init__(self, stat=&quot;proportion&quot;, complementary=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the class with its parameters

<span class="w"> </span>        Parameters
<span class="gu">@@ -198,17 +412,33 @@ class ECDF:</span>
<span class="w"> </span>            If True, use the complementary CDF (1 - CDF)

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        _check_argument(&#39;stat&#39;, [&#39;count&#39;, &#39;percent&#39;, &#39;proportion&#39;], stat)</span>
<span class="gi">+        _check_argument(&quot;stat&quot;, [&quot;count&quot;, &quot;percent&quot;, &quot;proportion&quot;], stat)</span>
<span class="w"> </span>        self.stat = stat
<span class="w"> </span>        self.complementary = complementary

<span class="w"> </span>    def _eval_bivariate(self, x1, x2, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for ECDF of two variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Bivariate ECDF is not implemented&quot;)</span>

<span class="w"> </span>    def _eval_univariate(self, x, weights):
<span class="w"> </span>        &quot;&quot;&quot;Inner function for ECDF of one variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sorter = x.argsort()</span>
<span class="gi">+        x = x[sorter]</span>
<span class="gi">+        weights = weights[sorter]</span>
<span class="gi">+        y = weights.cumsum()</span>
<span class="gi">+</span>
<span class="gi">+        if self.stat in [&quot;percent&quot;, &quot;proportion&quot;]:</span>
<span class="gi">+            y = y / y.max()</span>
<span class="gi">+        if self.stat == &quot;percent&quot;:</span>
<span class="gi">+            y = y * 100</span>
<span class="gi">+</span>
<span class="gi">+        x = np.r_[-np.inf, x]</span>
<span class="gi">+        y = np.r_[0, y]</span>
<span class="gi">+</span>
<span class="gi">+        if self.complementary:</span>
<span class="gi">+            y = y.max() - y</span>
<span class="gi">+</span>
<span class="gi">+        return y, x</span>

<span class="w"> </span>    def __call__(self, x1, x2=None, weights=None):
<span class="w"> </span>        &quot;&quot;&quot;Return proportion or count of observations below each sorted datapoint.&quot;&quot;&quot;
<span class="gu">@@ -217,6 +447,7 @@ class ECDF:</span>
<span class="w"> </span>            weights = np.ones_like(x1)
<span class="w"> </span>        else:
<span class="w"> </span>            weights = np.asarray(weights)
<span class="gi">+</span>
<span class="w"> </span>        if x2 is None:
<span class="w"> </span>            return self._eval_univariate(x1, weights)
<span class="w"> </span>        else:
<span class="gu">@@ -243,41 +474,50 @@ class EstimateAggregator:</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.estimator = estimator
<span class="gi">+</span>
<span class="w"> </span>        method, level = _validate_errorbar_arg(errorbar)
<span class="w"> </span>        self.error_method = method
<span class="w"> </span>        self.error_level = level
<span class="gi">+</span>
<span class="w"> </span>        self.boot_kws = boot_kws

<span class="w"> </span>    def __call__(self, data, var):
<span class="w"> </span>        &quot;&quot;&quot;Aggregate over `var` column of `data` with estimate and error interval.&quot;&quot;&quot;
<span class="w"> </span>        vals = data[var]
<span class="w"> </span>        if callable(self.estimator):
<span class="gi">+            # You would think we could pass to vals.agg, and yet:</span>
<span class="gi">+            # https://github.com/mwaskom/seaborn/issues/2943</span>
<span class="w"> </span>            estimate = self.estimator(vals)
<span class="w"> </span>        else:
<span class="w"> </span>            estimate = vals.agg(self.estimator)
<span class="gi">+</span>
<span class="gi">+        # Options that produce no error bars</span>
<span class="w"> </span>        if self.error_method is None:
<span class="w"> </span>            err_min = err_max = np.nan
<span class="w"> </span>        elif len(data) &lt;= 1:
<span class="w"> </span>            err_min = err_max = np.nan
<span class="gi">+</span>
<span class="gi">+        # Generic errorbars from user-supplied function</span>
<span class="w"> </span>        elif callable(self.error_method):
<span class="w"> </span>            err_min, err_max = self.error_method(vals)
<span class="gd">-        elif self.error_method == &#39;sd&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        # Parametric options</span>
<span class="gi">+        elif self.error_method == &quot;sd&quot;:</span>
<span class="w"> </span>            half_interval = vals.std() * self.error_level
<span class="gd">-            err_min, err_max = (estimate - half_interval, estimate +</span>
<span class="gd">-                half_interval)</span>
<span class="gd">-        elif self.error_method == &#39;se&#39;:</span>
<span class="gi">+            err_min, err_max = estimate - half_interval, estimate + half_interval</span>
<span class="gi">+        elif self.error_method == &quot;se&quot;:</span>
<span class="w"> </span>            half_interval = vals.sem() * self.error_level
<span class="gd">-            err_min, err_max = (estimate - half_interval, estimate +</span>
<span class="gd">-                half_interval)</span>
<span class="gd">-        elif self.error_method == &#39;pi&#39;:</span>
<span class="gi">+            err_min, err_max = estimate - half_interval, estimate + half_interval</span>
<span class="gi">+</span>
<span class="gi">+        # Nonparametric options</span>
<span class="gi">+        elif self.error_method == &quot;pi&quot;:</span>
<span class="w"> </span>            err_min, err_max = _percentile_interval(vals, self.error_level)
<span class="gd">-        elif self.error_method == &#39;ci&#39;:</span>
<span class="gd">-            units = data.get(&#39;units&#39;, None)</span>
<span class="gd">-            boots = bootstrap(vals, units=units, func=self.estimator, **</span>
<span class="gd">-                self.boot_kws)</span>
<span class="gi">+        elif self.error_method == &quot;ci&quot;:</span>
<span class="gi">+            units = data.get(&quot;units&quot;, None)</span>
<span class="gi">+            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)</span>
<span class="w"> </span>            err_min, err_max = _percentile_interval(boots, self.error_level)
<span class="gd">-        return pd.Series({var: estimate, f&#39;{var}min&#39;: err_min, f&#39;{var}max&#39;:</span>
<span class="gd">-            err_max})</span>
<span class="gi">+</span>
<span class="gi">+        return pd.Series({var: estimate, f&quot;{var}min&quot;: err_min, f&quot;{var}max&quot;: err_max})</span>


<span class="w"> </span>class WeightedAggregator:
<span class="gu">@@ -298,32 +538,42 @@ class WeightedAggregator:</span>
<span class="w"> </span>            Additional keywords are passed to bootstrap when error_method is &quot;ci&quot;.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if estimator != &#39;mean&#39;:</span>
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                f&quot;Weighted estimator must be &#39;mean&#39;, not {estimator!r}.&quot;)</span>
<span class="gi">+        if estimator != &quot;mean&quot;:</span>
<span class="gi">+            # Note that, while other weighted estimators may make sense (e.g. median),</span>
<span class="gi">+            # I&#39;m not aware of an implementation in our dependencies. We can add one</span>
<span class="gi">+            # in seaborn later, if there is sufficient interest. For now, limit to mean.</span>
<span class="gi">+            raise ValueError(f&quot;Weighted estimator must be &#39;mean&#39;, not {estimator!r}.&quot;)</span>
<span class="w"> </span>        self.estimator = estimator
<span class="gi">+</span>
<span class="w"> </span>        method, level = _validate_errorbar_arg(errorbar)
<span class="gd">-        if method is not None and method != &#39;ci&#39;:</span>
<span class="gi">+        if method is not None and method != &quot;ci&quot;:</span>
<span class="gi">+            # As with the estimator, weighted &#39;sd&#39; or &#39;pi&#39; error bars may make sense.</span>
<span class="gi">+            # But we&#39;ll keep things simple for now and limit to (bootstrap) CI.</span>
<span class="w"> </span>            raise ValueError(f&quot;Error bar method must be &#39;ci&#39;, not {method!r}.&quot;)
<span class="w"> </span>        self.error_method = method
<span class="w"> </span>        self.error_level = level
<span class="gi">+</span>
<span class="w"> </span>        self.boot_kws = boot_kws

<span class="w"> </span>    def __call__(self, data, var):
<span class="w"> </span>        &quot;&quot;&quot;Aggregate over `var` column of `data` with estimate and error interval.&quot;&quot;&quot;
<span class="w"> </span>        vals = data[var]
<span class="gd">-        weights = data[&#39;weight&#39;]</span>
<span class="gi">+        weights = data[&quot;weight&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>        estimate = np.average(vals, weights=weights)
<span class="gd">-        if self.error_method == &#39;ci&#39; and len(data) &gt; 1:</span>
<span class="gi">+</span>
<span class="gi">+        if self.error_method == &quot;ci&quot; and len(data) &gt; 1:</span>

<span class="w"> </span>            def error_func(x, w):
<span class="w"> </span>                return np.average(x, weights=w)
<span class="gi">+</span>
<span class="w"> </span>            boots = bootstrap(vals, weights, func=error_func, **self.boot_kws)
<span class="w"> </span>            err_min, err_max = _percentile_interval(boots, self.error_level)
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="w"> </span>            err_min = err_max = np.nan
<span class="gd">-        return pd.Series({var: estimate, f&#39;{var}min&#39;: err_min, f&#39;{var}max&#39;:</span>
<span class="gd">-            err_max})</span>
<span class="gi">+</span>
<span class="gi">+        return pd.Series({var: estimate, f&quot;{var}min&quot;: err_min, f&quot;{var}max&quot;: err_max})</span>


<span class="w"> </span>class LetterValues:
<span class="gu">@@ -352,39 +602,97 @@ class LetterValues:</span>
<span class="w"> </span>        https://vita.had.co.nz/papers/letter-value-plot.pdf

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        k_options = [&#39;tukey&#39;, &#39;proportion&#39;, &#39;trustworthy&#39;, &#39;full&#39;]</span>
<span class="gi">+        k_options = [&quot;tukey&quot;, &quot;proportion&quot;, &quot;trustworthy&quot;, &quot;full&quot;]</span>
<span class="w"> </span>        if isinstance(k_depth, str):
<span class="gd">-            _check_argument(&#39;k_depth&#39;, k_options, k_depth)</span>
<span class="gi">+            _check_argument(&quot;k_depth&quot;, k_options, k_depth)</span>
<span class="w"> </span>        elif not isinstance(k_depth, int):
<span class="w"> </span>            err = (
<span class="gd">-                f&#39;The `k_depth` parameter must be either an integer or string (one of {k_options}), not {k_depth!r}.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;The `k_depth` parameter must be either an integer or string &quot;</span>
<span class="gi">+                f&quot;(one of {k_options}), not {k_depth!r}.&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>            raise TypeError(err)
<span class="gi">+</span>
<span class="w"> </span>        self.k_depth = k_depth
<span class="w"> </span>        self.outlier_prop = outlier_prop
<span class="w"> </span>        self.trust_alpha = trust_alpha

<span class="gi">+    def _compute_k(self, n):</span>
<span class="gi">+</span>
<span class="gi">+        # Select the depth, i.e. number of boxes to draw, based on the method</span>
<span class="gi">+        if self.k_depth == &quot;full&quot;:</span>
<span class="gi">+            # extend boxes to 100% of the data</span>
<span class="gi">+            k = int(np.log2(n)) + 1</span>
<span class="gi">+        elif self.k_depth == &quot;tukey&quot;:</span>
<span class="gi">+            # This results with 5-8 points in each tail</span>
<span class="gi">+            k = int(np.log2(n)) - 3</span>
<span class="gi">+        elif self.k_depth == &quot;proportion&quot;:</span>
<span class="gi">+            k = int(np.log2(n)) - int(np.log2(n * self.outlier_prop)) + 1</span>
<span class="gi">+        elif self.k_depth == &quot;trustworthy&quot;:</span>
<span class="gi">+            normal_quantile_func = np.vectorize(NormalDist().inv_cdf)</span>
<span class="gi">+            point_conf = 2 * normal_quantile_func(1 - self.trust_alpha / 2) ** 2</span>
<span class="gi">+            k = int(np.log2(n / point_conf)) + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Allow having k directly specified as input</span>
<span class="gi">+            k = int(self.k_depth)</span>
<span class="gi">+</span>
<span class="gi">+        return max(k, 1)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __call__(self, x):
<span class="w"> </span>        &quot;&quot;&quot;Evaluate the letter values.&quot;&quot;&quot;
<span class="w"> </span>        k = self._compute_k(len(x))
<span class="w"> </span>        exp = np.arange(k + 1, 1, -1), np.arange(2, k + 2)
<span class="w"> </span>        levels = k + 1 - np.concatenate([exp[0], exp[1][1:]])
<span class="w"> </span>        percentiles = 100 * np.concatenate([0.5 ** exp[0], 1 - 0.5 ** exp[1]])
<span class="gd">-        if self.k_depth == &#39;full&#39;:</span>
<span class="gi">+        if self.k_depth == &quot;full&quot;:</span>
<span class="w"> </span>            percentiles[0] = 0
<span class="w"> </span>            percentiles[-1] = 100
<span class="w"> </span>        values = np.percentile(x, percentiles)
<span class="w"> </span>        fliers = np.asarray(x[(x &lt; values.min()) | (x &gt; values.max())])
<span class="w"> </span>        median = np.percentile(x, 50)
<span class="gd">-        return {&#39;k&#39;: k, &#39;levels&#39;: levels, &#39;percs&#39;: percentiles, &#39;values&#39;:</span>
<span class="gd">-            values, &#39;fliers&#39;: fliers, &#39;median&#39;: median}</span>
<span class="gi">+</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;k&quot;: k,</span>
<span class="gi">+            &quot;levels&quot;: levels,</span>
<span class="gi">+            &quot;percs&quot;: percentiles,</span>
<span class="gi">+            &quot;values&quot;: values,</span>
<span class="gi">+            &quot;fliers&quot;: fliers,</span>
<span class="gi">+            &quot;median&quot;: median,</span>
<span class="gi">+        }</span>


<span class="w"> </span>def _percentile_interval(data, width):
<span class="w"> </span>    &quot;&quot;&quot;Return a percentile interval from data of a given width.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edge = (100 - width) / 2</span>
<span class="gi">+    percentiles = edge, 100 - edge</span>
<span class="gi">+    return np.nanpercentile(data, percentiles)</span>


<span class="w"> </span>def _validate_errorbar_arg(arg):
<span class="w"> </span>    &quot;&quot;&quot;Check type and value of errorbar argument and assign default level.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    DEFAULT_LEVELS = {</span>
<span class="gi">+        &quot;ci&quot;: 95,</span>
<span class="gi">+        &quot;pi&quot;: 95,</span>
<span class="gi">+        &quot;se&quot;: 1,</span>
<span class="gi">+        &quot;sd&quot;: 1,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    usage = &quot;`errorbar` must be a callable, string, or (string, number) tuple&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if arg is None:</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    elif callable(arg):</span>
<span class="gi">+        return arg, None</span>
<span class="gi">+    elif isinstance(arg, str):</span>
<span class="gi">+        method = arg</span>
<span class="gi">+        level = DEFAULT_LEVELS.get(method, None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            method, level = arg</span>
<span class="gi">+        except (ValueError, TypeError) as err:</span>
<span class="gi">+            raise err.__class__(usage) from err</span>
<span class="gi">+</span>
<span class="gi">+    _check_argument(&quot;errorbar&quot;, list(DEFAULT_LEVELS), method)</span>
<span class="gi">+    if level is not None and not isinstance(level, Number):</span>
<span class="gi">+        raise TypeError(usage)</span>
<span class="gi">+</span>
<span class="gi">+    return method, level</span>
<span class="gh">diff --git a/seaborn/_stats/aggregation.py b/seaborn/_stats/aggregation.py</span>
<span class="gh">index edd0bde5..7e7d6021 100644</span>
<span class="gd">--- a/seaborn/_stats/aggregation.py</span>
<span class="gi">+++ b/seaborn/_stats/aggregation.py</span>
<span class="gu">@@ -1,12 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar, Callable
<span class="gi">+</span>
<span class="w"> </span>import pandas as pd
<span class="w"> </span>from pandas import DataFrame
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._stats.base import Stat
<span class="gd">-from seaborn._statistics import EstimateAggregator, WeightedAggregator</span>
<span class="gi">+from seaborn._statistics import (</span>
<span class="gi">+    EstimateAggregator,</span>
<span class="gi">+    WeightedAggregator,</span>
<span class="gi">+)</span>
<span class="w"> </span>from seaborn._core.typing import Vector


<span class="gu">@@ -29,14 +34,21 @@ class Agg(Stat):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Agg.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    func: str | Callable[[Vector], float] = &#39;mean&#39;</span>
<span class="gi">+    func: str | Callable[[Vector], float] = &quot;mean&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = True

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        var = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}.get(orient)</span>
<span class="gd">-        res = groupby.agg(data, {var: self.func}).dropna(subset=[var]</span>
<span class="gd">-            ).reset_index(drop=True)</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}.get(orient)</span>
<span class="gi">+        res = (</span>
<span class="gi">+            groupby</span>
<span class="gi">+            .agg(data, {var: self.func})</span>
<span class="gi">+            .dropna(subset=[var])</span>
<span class="gi">+            .reset_index(drop=True)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return res


<span class="gu">@@ -72,23 +84,41 @@ class Est(Stat):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Est.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    func: str | Callable[[Vector], float] = &#39;mean&#39;</span>
<span class="gd">-    errorbar: str | tuple[str, float] = (&#39;ci&#39;, 95)</span>
<span class="gi">+    func: str | Callable[[Vector], float] = &quot;mean&quot;</span>
<span class="gi">+    errorbar: str | tuple[str, float] = (&quot;ci&quot;, 95)</span>
<span class="w"> </span>    n_boot: int = 1000
<span class="w"> </span>    seed: int | None = None
<span class="gi">+</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = True

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        boot_kws = {&#39;n_boot&#39;: self.n_boot, &#39;seed&#39;: self.seed}</span>
<span class="gd">-        if &#39;weight&#39; in data:</span>
<span class="gi">+    def _process(</span>
<span class="gi">+        self, data: DataFrame, var: str, estimator: EstimateAggregator</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+        # Needed because GroupBy.apply assumes func is DataFrame -&gt; DataFrame</span>
<span class="gi">+        # which we could probably make more general to allow Series return</span>
<span class="gi">+        res = estimator(data, var)</span>
<span class="gi">+        return pd.DataFrame([res])</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        boot_kws = {&quot;n_boot&quot;: self.n_boot, &quot;seed&quot;: self.seed}</span>
<span class="gi">+        if &quot;weight&quot; in data:</span>
<span class="w"> </span>            engine = WeightedAggregator(self.func, self.errorbar, **boot_kws)
<span class="w"> </span>        else:
<span class="w"> </span>            engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)
<span class="gd">-        var = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gd">-        res = groupby.apply(data, self._process, var, engine).dropna(subset</span>
<span class="gd">-            =[var]).reset_index(drop=True)</span>
<span class="gd">-        res = res.fillna({f&#39;{var}min&#39;: res[var], f&#39;{var}max&#39;: res[var]})</span>
<span class="gi">+</span>
<span class="gi">+        var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        res = (</span>
<span class="gi">+            groupby</span>
<span class="gi">+            .apply(data, self._process, var, engine)</span>
<span class="gi">+            .dropna(subset=[var])</span>
<span class="gi">+            .reset_index(drop=True)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        res = res.fillna({f&quot;{var}min&quot;: res[var], f&quot;{var}max&quot;: res[var]})</span>
<span class="gi">+</span>
<span class="w"> </span>        return res


<span class="gh">diff --git a/seaborn/_stats/base.py b/seaborn/_stats/base.py</span>
<span class="gh">index 4c8201ba..b80b2281 100644</span>
<span class="gd">--- a/seaborn/_stats/base.py</span>
<span class="gi">+++ b/seaborn/_stats/base.py</span>
<span class="gu">@@ -4,6 +4,7 @@ from collections.abc import Iterable</span>
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar, Any
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pandas import DataFrame
<span class="gu">@@ -14,18 +15,51 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>@dataclass
<span class="w"> </span>class Stat:
<span class="w"> </span>    &quot;&quot;&quot;Base class for objects that apply statistical transformations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # The class supports a partial-function application pattern. The object is</span>
<span class="gi">+    # initialized with desired parameters and the result is a callable that</span>
<span class="gi">+    # accepts and returns dataframes.</span>
<span class="gi">+</span>
<span class="gi">+    # The statistical transformation logic should not add any state to the instance</span>
<span class="gi">+    # beyond what is defined with the initialization parameters.</span>
<span class="gi">+</span>
<span class="gi">+    # Subclasses can declare whether the orient dimension should be used in grouping</span>
<span class="gi">+    # TODO consider whether this should be a parameter. Motivating example:</span>
<span class="gi">+    # use the same KDE class violin plots and univariate density estimation.</span>
<span class="gi">+    # In the former case, we would expect separate densities for each unique</span>
<span class="gi">+    # value on the orient axis, but we would not in the latter case.</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = False

<span class="gd">-    def _check_param_one_of(self, param: str, options: Iterable[Any]) -&gt;None:</span>
<span class="gi">+    def _check_param_one_of(self, param: str, options: Iterable[Any]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Raise when parameter value is not one of a specified set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = getattr(self, param)</span>
<span class="gi">+        if value not in options:</span>
<span class="gi">+            *most, last = options</span>
<span class="gi">+            option_str = &quot;, &quot;.join(f&quot;{x!r}&quot; for x in most[:-1]) + f&quot; or {last!r}&quot;</span>
<span class="gi">+            err = &quot; &quot;.join([</span>
<span class="gi">+                f&quot;The `{param}` parameter for `{self.__class__.__name__}` must be&quot;,</span>
<span class="gi">+                f&quot;one of {option_str}; not {value!r}.&quot;,</span>
<span class="gi">+            ])</span>
<span class="gi">+            raise ValueError(err)</span>

<span class="gd">-    def _check_grouping_vars(self, param: str, data_vars: list[str],</span>
<span class="gd">-        stacklevel: int=2) -&gt;None:</span>
<span class="gi">+    def _check_grouping_vars(</span>
<span class="gi">+        self, param: str, data_vars: list[str], stacklevel: int = 2,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Warn if vars are named in parameter without being present in the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        param_vars = getattr(self, param)</span>
<span class="gi">+        undefined = set(param_vars) - set(data_vars)</span>
<span class="gi">+        if undefined:</span>
<span class="gi">+            param = f&quot;{self.__class__.__name__}.{param}&quot;</span>
<span class="gi">+            names = &quot;, &quot;.join(f&quot;{x!r}&quot; for x in undefined)</span>
<span class="gi">+            msg = f&quot;Undefined variable(s) passed for {param}: {names}.&quot;</span>
<span class="gi">+            warnings.warn(msg, stacklevel=stacklevel)</span>

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data: DataFrame,</span>
<span class="gi">+        groupby: GroupBy,</span>
<span class="gi">+        orient: str,</span>
<span class="gi">+        scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply statistical transform to data subgroups and return combined result.&quot;&quot;&quot;
<span class="w"> </span>        return data
<span class="gh">diff --git a/seaborn/_stats/counting.py b/seaborn/_stats/counting.py</span>
<span class="gh">index b1bf2a2d..0c2fb7d4 100644</span>
<span class="gd">--- a/seaborn/_stats/counting.py</span>
<span class="gi">+++ b/seaborn/_stats/counting.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>from pandas import DataFrame
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="w"> </span>from seaborn._stats.base import Stat
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from numpy.typing import ArrayLike
<span class="gu">@@ -28,11 +31,17 @@ class Count(Stat):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    group_by_orient: ClassVar[bool] = True

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        var = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gd">-        res = groupby.agg(data.assign(**{var: data[orient]}), {var: len}</span>
<span class="gd">-            ).dropna(subset=[&#39;x&#39;, &#39;y&#39;]).reset_index(drop=True)</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        res = (</span>
<span class="gi">+            groupby</span>
<span class="gi">+            .agg(data.assign(**{var: data[orient]}), {var: len})</span>
<span class="gi">+            .dropna(subset=[&quot;x&quot;, &quot;y&quot;])</span>
<span class="gi">+            .reset_index(drop=True)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return res


<span class="gu">@@ -95,8 +104,8 @@ class Hist(Stat):</span>
<span class="w"> </span>    .. include:: ../docstrings/objects.Hist.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    stat: str = &#39;count&#39;</span>
<span class="gd">-    bins: str | int | ArrayLike = &#39;auto&#39;</span>
<span class="gi">+    stat: str = &quot;count&quot;</span>
<span class="gi">+    bins: str | int | ArrayLike = &quot;auto&quot;</span>
<span class="w"> </span>    binwidth: float | None = None
<span class="w"> </span>    binrange: tuple[float, float] | None = None
<span class="w"> </span>    common_norm: bool | list[str] = True
<span class="gu">@@ -105,21 +114,94 @@ class Hist(Stat):</span>
<span class="w"> </span>    discrete: bool = False

<span class="w"> </span>    def __post_init__(self):
<span class="gd">-        stat_options = [&#39;count&#39;, &#39;density&#39;, &#39;percent&#39;, &#39;probability&#39;,</span>
<span class="gd">-            &#39;proportion&#39;, &#39;frequency&#39;]</span>
<span class="gd">-        self._check_param_one_of(&#39;stat&#39;, stat_options)</span>

<span class="gd">-    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange,</span>
<span class="gd">-        discrete):</span>
<span class="gi">+        stat_options = [</span>
<span class="gi">+            &quot;count&quot;, &quot;density&quot;, &quot;percent&quot;, &quot;probability&quot;, &quot;proportion&quot;, &quot;frequency&quot;</span>
<span class="gi">+        ]</span>
<span class="gi">+        self._check_param_one_of(&quot;stat&quot;, stat_options)</span>
<span class="gi">+</span>
<span class="gi">+    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange, discrete):</span>
<span class="w"> </span>        &quot;&quot;&quot;Inner function that takes bin parameters as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vals = vals.replace(-np.inf, np.nan).replace(np.inf, np.nan).dropna()</span>
<span class="gi">+</span>
<span class="gi">+        if binrange is None:</span>
<span class="gi">+            start, stop = vals.min(), vals.max()</span>
<span class="gi">+        else:</span>
<span class="gi">+            start, stop = binrange</span>
<span class="gi">+</span>
<span class="gi">+        if discrete:</span>
<span class="gi">+            bin_edges = np.arange(start - .5, stop + 1.5)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if binwidth is not None:</span>
<span class="gi">+                bins = int(round((stop - start) / binwidth))</span>
<span class="gi">+            bin_edges = np.histogram_bin_edges(vals, bins, binrange, weight)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO warning or cap on too many bins?</span>
<span class="gi">+</span>
<span class="gi">+        return bin_edges</span>

<span class="w"> </span>    def _define_bin_params(self, data, orient, scale_type):
<span class="w"> </span>        &quot;&quot;&quot;Given data, return numpy.histogram parameters to define bins.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vals = data[orient]</span>
<span class="gi">+        weights = data.get(&quot;weight&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO We&#39;ll want this for ordinal / discrete scales too</span>
<span class="gi">+        # (Do we need discrete as a parameter or just infer from scale?)</span>
<span class="gi">+        discrete = self.discrete or scale_type == &quot;nominal&quot;</span>
<span class="gi">+</span>
<span class="gi">+        bin_edges = self._define_bin_edges(</span>
<span class="gi">+            vals, weights, self.bins, self.binwidth, self.binrange, discrete,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self.bins, (str, int)):</span>
<span class="gi">+            n_bins = len(bin_edges) - 1</span>
<span class="gi">+            bin_range = bin_edges.min(), bin_edges.max()</span>
<span class="gi">+            bin_kws = dict(bins=n_bins, range=bin_range)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bin_kws = dict(bins=bin_edges)</span>
<span class="gi">+</span>
<span class="gi">+        return bin_kws</span>
<span class="gi">+</span>
<span class="gi">+    def _get_bins_and_eval(self, data, orient, groupby, scale_type):</span>
<span class="gi">+</span>
<span class="gi">+        bin_kws = self._define_bin_params(data, orient, scale_type)</span>
<span class="gi">+        return groupby.apply(data, self._eval, orient, bin_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def _eval(self, data, orient, bin_kws):</span>
<span class="gi">+</span>
<span class="gi">+        vals = data[orient]</span>
<span class="gi">+        weights = data.get(&quot;weight&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        density = self.stat == &quot;density&quot;</span>
<span class="gi">+        hist, edges = np.histogram(vals, **bin_kws, weights=weights, density=density)</span>
<span class="gi">+</span>
<span class="gi">+        width = np.diff(edges)</span>
<span class="gi">+        center = edges[:-1] + width / 2</span>
<span class="gi">+</span>
<span class="gi">+        return pd.DataFrame({orient: center, &quot;count&quot;: hist, &quot;space&quot;: width})</span>
<span class="gi">+</span>
<span class="gi">+    def _normalize(self, data):</span>
<span class="gi">+</span>
<span class="gi">+        hist = data[&quot;count&quot;]</span>
<span class="gi">+        if self.stat == &quot;probability&quot; or self.stat == &quot;proportion&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum()</span>
<span class="gi">+        elif self.stat == &quot;percent&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / hist.sum() * 100</span>
<span class="gi">+        elif self.stat == &quot;frequency&quot;:</span>
<span class="gi">+            hist = hist.astype(float) / data[&quot;space&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            if self.stat in [&quot;density&quot;, &quot;frequency&quot;]:</span>
<span class="gi">+                hist = (hist * data[&quot;space&quot;]).cumsum()</span>
<span class="gi">+            else:</span>
<span class="gi">+                hist = hist.cumsum()</span>
<span class="gi">+</span>
<span class="gi">+        return data.assign(**{self.stat: hist})</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="w"> </span>        scale_type = scales[orient].__class__.__name__.lower()
<span class="w"> </span>        grouping_vars = [str(v) for v in data if v in groupby.order]
<span class="w"> </span>        if not grouping_vars or self.common_bins is True:
<span class="gu">@@ -130,9 +212,12 @@ class Hist(Stat):</span>
<span class="w"> </span>                bin_groupby = GroupBy(grouping_vars)
<span class="w"> </span>            else:
<span class="w"> </span>                bin_groupby = GroupBy(self.common_bins)
<span class="gd">-                self._check_grouping_vars(&#39;common_bins&#39;, grouping_vars)</span>
<span class="gd">-            data = bin_groupby.apply(data, self._get_bins_and_eval, orient,</span>
<span class="gd">-                groupby, scale_type)</span>
<span class="gi">+                self._check_grouping_vars(&quot;common_bins&quot;, grouping_vars)</span>
<span class="gi">+</span>
<span class="gi">+            data = bin_groupby.apply(</span>
<span class="gi">+                data, self._get_bins_and_eval, orient, groupby, scale_type,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        if not grouping_vars or self.common_norm is True:
<span class="w"> </span>            data = self._normalize(data)
<span class="w"> </span>        else:
<span class="gu">@@ -140,7 +225,8 @@ class Hist(Stat):</span>
<span class="w"> </span>                norm_groupby = GroupBy(grouping_vars)
<span class="w"> </span>            else:
<span class="w"> </span>                norm_groupby = GroupBy(self.common_norm)
<span class="gd">-                self._check_grouping_vars(&#39;common_norm&#39;, grouping_vars)</span>
<span class="gi">+                self._check_grouping_vars(&quot;common_norm&quot;, grouping_vars)</span>
<span class="w"> </span>            data = norm_groupby.apply(data, self._normalize)
<span class="gd">-        other = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gi">+</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="w"> </span>        return data.assign(**{other: data[self.stat]})
<span class="gh">diff --git a/seaborn/_stats/density.py b/seaborn/_stats/density.py</span>
<span class="gh">index 410c1a0b..e4613876 100644</span>
<span class="gd">--- a/seaborn/_stats/density.py</span>
<span class="gi">+++ b/seaborn/_stats/density.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import Any, Callable
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from numpy import ndarray
<span class="w"> </span>import pandas as pd
<span class="gu">@@ -11,6 +12,7 @@ try:</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from seaborn.external.kde import gaussian_kde
<span class="w"> </span>    _no_scipy = True
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="w"> </span>from seaborn._stats.base import Stat
<span class="gu">@@ -82,7 +84,7 @@ class KDE(Stat):</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    bw_adjust: float = 1
<span class="gd">-    bw_method: str | float | Callable[[gaussian_kde], float] = &#39;scott&#39;</span>
<span class="gi">+    bw_method: str | float | Callable[[gaussian_kde], float] = &quot;scott&quot;</span>
<span class="w"> </span>    common_norm: bool | list[str] = True
<span class="w"> </span>    common_grid: bool | list[str] = True
<span class="w"> </span>    gridsize: int | None = 200
<span class="gu">@@ -90,37 +92,92 @@ class KDE(Stat):</span>
<span class="w"> </span>    cumulative: bool = False

<span class="w"> </span>    def __post_init__(self):
<span class="gi">+</span>
<span class="w"> </span>        if self.cumulative and _no_scipy:
<span class="gd">-            raise RuntimeError(&#39;Cumulative KDE evaluation requires scipy&#39;)</span>
<span class="gi">+            raise RuntimeError(&quot;Cumulative KDE evaluation requires scipy&quot;)</span>

<span class="gd">-    def _check_var_list_or_boolean(self, param: str, grouping_vars: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_var_list_or_boolean(self, param: str, grouping_vars: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do input checks on grouping parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _fit(self, data: DataFrame, orient: str) -&gt;gaussian_kde:</span>
<span class="gi">+        value = getattr(self, param)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(value, bool)</span>
<span class="gi">+            or (isinstance(value, list) and all(isinstance(v, str) for v in value))</span>
<span class="gi">+        ):</span>
<span class="gi">+            param_name = f&quot;{self.__class__.__name__}.{param}&quot;</span>
<span class="gi">+            raise TypeError(f&quot;{param_name} must be a boolean or list of strings.&quot;)</span>
<span class="gi">+        self._check_grouping_vars(param, grouping_vars, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+    def _fit(self, data: DataFrame, orient: str) -&gt; gaussian_kde:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fit and return a KDE object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO need to handle singular data</span>

<span class="gd">-    def _get_support(self, data: DataFrame, orient: str) -&gt;ndarray:</span>
<span class="gd">-        &quot;&quot;&quot;Define the grid that the KDE will be evaluated on.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        fit_kws: dict[str, Any] = {&quot;bw_method&quot;: self.bw_method}</span>
<span class="gi">+        if &quot;weight&quot; in data:</span>
<span class="gi">+            fit_kws[&quot;weights&quot;] = data[&quot;weight&quot;]</span>
<span class="gi">+        kde = gaussian_kde(data[orient], **fit_kws)</span>
<span class="gi">+        kde.set_bandwidth(kde.factor * self.bw_adjust)</span>
<span class="gi">+</span>
<span class="gi">+        return kde</span>

<span class="gd">-    def _fit_and_evaluate(self, data: DataFrame, orient: str, support: ndarray</span>
<span class="gd">-        ) -&gt;DataFrame:</span>
<span class="gi">+    def _get_support(self, data: DataFrame, orient: str) -&gt; ndarray:</span>
<span class="gi">+        &quot;&quot;&quot;Define the grid that the KDE will be evaluated on.&quot;&quot;&quot;</span>
<span class="gi">+        if self.gridsize is None:</span>
<span class="gi">+            return data[orient].to_numpy()</span>
<span class="gi">+</span>
<span class="gi">+        kde = self._fit(data, orient)</span>
<span class="gi">+        bw = np.sqrt(kde.covariance.squeeze())</span>
<span class="gi">+        gridmin = data[orient].min() - bw * self.cut</span>
<span class="gi">+        gridmax = data[orient].max() + bw * self.cut</span>
<span class="gi">+        return np.linspace(gridmin, gridmax, self.gridsize)</span>
<span class="gi">+</span>
<span class="gi">+    def _fit_and_evaluate(</span>
<span class="gi">+        self, data: DataFrame, orient: str, support: ndarray</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform single group by fitting a KDE and evaluating on a support grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        empty = pd.DataFrame(columns=[orient, &quot;weight&quot;, &quot;density&quot;], dtype=float)</span>
<span class="gi">+        if len(data) &lt; 2:</span>
<span class="gi">+            return empty</span>
<span class="gi">+        try:</span>
<span class="gi">+            kde = self._fit(data, orient)</span>
<span class="gi">+        except np.linalg.LinAlgError:</span>
<span class="gi">+            return empty</span>
<span class="gi">+</span>
<span class="gi">+        if self.cumulative:</span>
<span class="gi">+            s_0 = support[0]</span>
<span class="gi">+            density = np.array([kde.integrate_box_1d(s_0, s_i) for s_i in support])</span>
<span class="gi">+        else:</span>
<span class="gi">+            density = kde(support)</span>

<span class="gd">-    def _transform(self, data: DataFrame, orient: str, grouping_vars: list[str]</span>
<span class="gd">-        ) -&gt;DataFrame:</span>
<span class="gd">-        &quot;&quot;&quot;Transform multiple groups by fitting KDEs and evaluating.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        weight = data[&quot;weight&quot;].sum()</span>
<span class="gi">+        return pd.DataFrame({orient: support, &quot;weight&quot;: weight, &quot;density&quot;: density})</span>

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        if &#39;weight&#39; not in data:</span>
<span class="gi">+    def _transform(</span>
<span class="gi">+        self, data: DataFrame, orient: str, grouping_vars: list[str]</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+        &quot;&quot;&quot;Transform multiple groups by fitting KDEs and evaluating.&quot;&quot;&quot;</span>
<span class="gi">+        empty = pd.DataFrame(columns=[*data.columns, &quot;density&quot;], dtype=float)</span>
<span class="gi">+        if len(data) &lt; 2:</span>
<span class="gi">+            return empty</span>
<span class="gi">+        try:</span>
<span class="gi">+            support = self._get_support(data, orient)</span>
<span class="gi">+        except np.linalg.LinAlgError:</span>
<span class="gi">+            return empty</span>
<span class="gi">+</span>
<span class="gi">+        grouping_vars = [x for x in grouping_vars if data[x].nunique() &gt; 1]</span>
<span class="gi">+        if not grouping_vars:</span>
<span class="gi">+            return self._fit_and_evaluate(data, orient, support)</span>
<span class="gi">+        groupby = GroupBy(grouping_vars)</span>
<span class="gi">+        return groupby.apply(data, self._fit_and_evaluate, orient, support)</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;weight&quot; not in data:</span>
<span class="w"> </span>            data = data.assign(weight=1)
<span class="gd">-        data = data.dropna(subset=[orient, &#39;weight&#39;])</span>
<span class="gi">+        data = data.dropna(subset=[orient, &quot;weight&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        # Transform each group separately</span>
<span class="w"> </span>        grouping_vars = [str(v) for v in data if v in groupby.order]
<span class="w"> </span>        if not grouping_vars or self.common_grid is True:
<span class="w"> </span>            res = self._transform(data, orient, grouping_vars)
<span class="gu">@@ -128,21 +185,30 @@ class KDE(Stat):</span>
<span class="w"> </span>            if self.common_grid is False:
<span class="w"> </span>                grid_vars = grouping_vars
<span class="w"> </span>            else:
<span class="gd">-                self._check_var_list_or_boolean(&#39;common_grid&#39;, grouping_vars)</span>
<span class="gi">+                self._check_var_list_or_boolean(&quot;common_grid&quot;, grouping_vars)</span>
<span class="w"> </span>                grid_vars = [v for v in self.common_grid if v in grouping_vars]
<span class="gd">-            res = GroupBy(grid_vars).apply(data, self._transform, orient,</span>
<span class="gd">-                grouping_vars)</span>
<span class="gi">+</span>
<span class="gi">+            res = (</span>
<span class="gi">+                GroupBy(grid_vars)</span>
<span class="gi">+                .apply(data, self._transform, orient, grouping_vars)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Normalize, potentially within groups</span>
<span class="w"> </span>        if not grouping_vars or self.common_norm is True:
<span class="gd">-            res = res.assign(group_weight=data[&#39;weight&#39;].sum())</span>
<span class="gi">+            res = res.assign(group_weight=data[&quot;weight&quot;].sum())</span>
<span class="w"> </span>        else:
<span class="w"> </span>            if self.common_norm is False:
<span class="w"> </span>                norm_vars = grouping_vars
<span class="w"> </span>            else:
<span class="gd">-                self._check_var_list_or_boolean(&#39;common_norm&#39;, grouping_vars)</span>
<span class="gi">+                self._check_var_list_or_boolean(&quot;common_norm&quot;, grouping_vars)</span>
<span class="w"> </span>                norm_vars = [v for v in self.common_norm if v in grouping_vars]
<span class="gd">-            res = res.join(data.groupby(norm_vars)[&#39;weight&#39;].sum().rename(</span>
<span class="gd">-                &#39;group_weight&#39;), on=norm_vars)</span>
<span class="gd">-        res[&#39;density&#39;] *= res.eval(&#39;weight / group_weight&#39;)</span>
<span class="gd">-        value = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gd">-        res[value] = res[&#39;density&#39;]</span>
<span class="gd">-        return res.drop([&#39;weight&#39;, &#39;group_weight&#39;], axis=1)</span>
<span class="gi">+</span>
<span class="gi">+            res = res.join(</span>
<span class="gi">+                data.groupby(norm_vars)[&quot;weight&quot;].sum().rename(&quot;group_weight&quot;),</span>
<span class="gi">+                on=norm_vars,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        res[&quot;density&quot;] *= res.eval(&quot;weight / group_weight&quot;)</span>
<span class="gi">+        value = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+        res[value] = res[&quot;density&quot;]</span>
<span class="gi">+        return res.drop([&quot;weight&quot;, &quot;group_weight&quot;], axis=1)</span>
<span class="gh">diff --git a/seaborn/_stats/order.py b/seaborn/_stats/order.py</span>
<span class="gh">index f80fd1f6..c37c0985 100644</span>
<span class="gd">--- a/seaborn/_stats/order.py</span>
<span class="gi">+++ b/seaborn/_stats/order.py</span>
<span class="gu">@@ -1,20 +1,37 @@</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from typing import ClassVar, cast
<span class="w"> </span>try:
<span class="w"> </span>    from typing import Literal
<span class="w"> </span>except ImportError:
<span class="gd">-    from typing_extensions import Literal</span>
<span class="gi">+    from typing_extensions import Literal  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>from pandas import DataFrame
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.scales import Scale
<span class="w"> </span>from seaborn._core.groupby import GroupBy
<span class="w"> </span>from seaborn._stats.base import Stat
<span class="w"> </span>from seaborn.utils import _version_predates
<span class="gd">-_MethodKind = Literal[&#39;inverted_cdf&#39;, &#39;averaged_inverted_cdf&#39;,</span>
<span class="gd">-    &#39;closest_observation&#39;, &#39;interpolated_inverted_cdf&#39;, &#39;hazen&#39;, &#39;weibull&#39;,</span>
<span class="gd">-    &#39;linear&#39;, &#39;median_unbiased&#39;, &#39;normal_unbiased&#39;, &#39;lower&#39;, &#39;higher&#39;,</span>
<span class="gd">-    &#39;midpoint&#39;, &#39;nearest&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# From https://github.com/numpy/numpy/blob/main/numpy/lib/function_base.pyi</span>
<span class="gi">+_MethodKind = Literal[</span>
<span class="gi">+    &quot;inverted_cdf&quot;,</span>
<span class="gi">+    &quot;averaged_inverted_cdf&quot;,</span>
<span class="gi">+    &quot;closest_observation&quot;,</span>
<span class="gi">+    &quot;interpolated_inverted_cdf&quot;,</span>
<span class="gi">+    &quot;hazen&quot;,</span>
<span class="gi">+    &quot;weibull&quot;,</span>
<span class="gi">+    &quot;linear&quot;,</span>
<span class="gi">+    &quot;median_unbiased&quot;,</span>
<span class="gi">+    &quot;normal_unbiased&quot;,</span>
<span class="gi">+    &quot;lower&quot;,</span>
<span class="gi">+    &quot;higher&quot;,</span>
<span class="gi">+    &quot;midpoint&quot;,</span>
<span class="gi">+    &quot;nearest&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@dataclass
<span class="gu">@@ -38,10 +55,24 @@ class Perc(Stat):</span>

<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    k: int | list[float] = 5
<span class="gd">-    method: str = &#39;linear&#39;</span>
<span class="gi">+    method: str = &quot;linear&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    group_by_orient: ClassVar[bool] = True

<span class="gd">-    def __call__(self, data: DataFrame, groupby: GroupBy, orient: str,</span>
<span class="gd">-        scales: dict[str, Scale]) -&gt;DataFrame:</span>
<span class="gd">-        var = {&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}[orient]</span>
<span class="gi">+    def _percentile(self, data: DataFrame, var: str) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        k = list(np.linspace(0, 100, self.k)) if isinstance(self.k, int) else self.k</span>
<span class="gi">+        method = cast(_MethodKind, self.method)</span>
<span class="gi">+        values = data[var].dropna()</span>
<span class="gi">+        if _version_predates(np, &quot;1.22&quot;):</span>
<span class="gi">+            res = np.percentile(values, k, interpolation=method)  # type: ignore</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = np.percentile(data[var].dropna(), k, method=method)</span>
<span class="gi">+        return DataFrame({var: res, &quot;percentile&quot;: k})</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],</span>
<span class="gi">+    ) -&gt; DataFrame:</span>
<span class="gi">+</span>
<span class="gi">+        var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="w"> </span>        return groupby.apply(data, self._percentile, var)
<span class="gh">diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py</span>
<span class="gh">index d5681d04..9ec81a4e 100644</span>
<span class="gd">--- a/seaborn/_stats/regression.py</span>
<span class="gi">+++ b/seaborn/_stats/regression.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from dataclasses import dataclass
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="gi">+</span>
<span class="w"> </span>from seaborn._stats.base import Stat


<span class="gu">@@ -10,13 +12,39 @@ class PolyFit(Stat):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Fit a polynomial of the given order and resample data onto predicted curve.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # This is a provisional class that is useful for building out functionality.</span>
<span class="gi">+    # It may or may not change substantially in form or dissappear as we think</span>
<span class="gi">+    # through the organization of the stats subpackage.</span>
<span class="gi">+</span>
<span class="w"> </span>    order: int = 2
<span class="w"> </span>    gridsize: int = 100

<span class="gi">+    def _fit_predict(self, data):</span>
<span class="gi">+</span>
<span class="gi">+        x = data[&quot;x&quot;]</span>
<span class="gi">+        y = data[&quot;y&quot;]</span>
<span class="gi">+        if x.nunique() &lt;= self.order:</span>
<span class="gi">+            # TODO warn?</span>
<span class="gi">+            xx = yy = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            p = np.polyfit(x, y, self.order)</span>
<span class="gi">+            xx = np.linspace(x.min(), x.max(), self.gridsize)</span>
<span class="gi">+            yy = np.polyval(p, xx)</span>
<span class="gi">+</span>
<span class="gi">+        return pd.DataFrame(dict(x=xx, y=yy))</span>
<span class="gi">+</span>
<span class="gi">+    # TODO we should have a way of identifying the method that will be applied</span>
<span class="gi">+    # and then only define __call__ on a base-class of stats with this pattern</span>
<span class="gi">+</span>
<span class="w"> </span>    def __call__(self, data, groupby, orient, scales):
<span class="gd">-        return groupby.apply(data.dropna(subset=[&#39;x&#39;, &#39;y&#39;]), self._fit_predict)</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            groupby</span>
<span class="gi">+            .apply(data.dropna(subset=[&quot;x&quot;, &quot;y&quot;]), self._fit_predict)</span>
<span class="gi">+        )</span>


<span class="w"> </span>@dataclass
<span class="w"> </span>class OLSFit(Stat):
<span class="gi">+</span>
<span class="w"> </span>    ...
<span class="gh">diff --git a/seaborn/_testing.py b/seaborn/_testing.py</span>
<span class="gh">index b1953e9a..c6f821cb 100644</span>
<span class="gd">--- a/seaborn/_testing.py</span>
<span class="gi">+++ b/seaborn/_testing.py</span>
<span class="gu">@@ -2,5 +2,89 @@ import numpy as np</span>
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from matplotlib.colors import to_rgb, to_rgba
<span class="w"> </span>from numpy.testing import assert_array_equal
<span class="gd">-USE_PROPS = [&#39;alpha&#39;, &#39;edgecolor&#39;, &#39;facecolor&#39;, &#39;fill&#39;, &#39;hatch&#39;, &#39;height&#39;,</span>
<span class="gd">-    &#39;linestyle&#39;, &#39;linewidth&#39;, &#39;paths&#39;, &#39;xy&#39;, &#39;xydata&#39;, &#39;sizes&#39;, &#39;zorder&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+USE_PROPS = [</span>
<span class="gi">+    &quot;alpha&quot;,</span>
<span class="gi">+    &quot;edgecolor&quot;,</span>
<span class="gi">+    &quot;facecolor&quot;,</span>
<span class="gi">+    &quot;fill&quot;,</span>
<span class="gi">+    &quot;hatch&quot;,</span>
<span class="gi">+    &quot;height&quot;,</span>
<span class="gi">+    &quot;linestyle&quot;,</span>
<span class="gi">+    &quot;linewidth&quot;,</span>
<span class="gi">+    &quot;paths&quot;,</span>
<span class="gi">+    &quot;xy&quot;,</span>
<span class="gi">+    &quot;xydata&quot;,</span>
<span class="gi">+    &quot;sizes&quot;,</span>
<span class="gi">+    &quot;zorder&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def assert_artists_equal(list1, list2):</span>
<span class="gi">+</span>
<span class="gi">+    assert len(list1) == len(list2)</span>
<span class="gi">+    for a1, a2 in zip(list1, list2):</span>
<span class="gi">+        assert a1.__class__ == a2.__class__</span>
<span class="gi">+        prop1 = a1.properties()</span>
<span class="gi">+        prop2 = a2.properties()</span>
<span class="gi">+        for key in USE_PROPS:</span>
<span class="gi">+            if key not in prop1:</span>
<span class="gi">+                continue</span>
<span class="gi">+            v1 = prop1[key]</span>
<span class="gi">+            v2 = prop2[key]</span>
<span class="gi">+            if key == &quot;paths&quot;:</span>
<span class="gi">+                for p1, p2 in zip(v1, v2):</span>
<span class="gi">+                    assert_array_equal(p1.vertices, p2.vertices)</span>
<span class="gi">+                    assert_array_equal(p1.codes, p2.codes)</span>
<span class="gi">+            elif key == &quot;color&quot;:</span>
<span class="gi">+                v1 = mpl.colors.to_rgba(v1)</span>
<span class="gi">+                v2 = mpl.colors.to_rgba(v2)</span>
<span class="gi">+                assert v1 == v2</span>
<span class="gi">+            elif isinstance(v1, np.ndarray):</span>
<span class="gi">+                assert_array_equal(v1, v2)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert v1 == v2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def assert_legends_equal(leg1, leg2):</span>
<span class="gi">+</span>
<span class="gi">+    assert leg1.get_title().get_text() == leg2.get_title().get_text()</span>
<span class="gi">+    for t1, t2 in zip(leg1.get_texts(), leg2.get_texts()):</span>
<span class="gi">+        assert t1.get_text() == t2.get_text()</span>
<span class="gi">+</span>
<span class="gi">+    assert_artists_equal(</span>
<span class="gi">+        leg1.get_patches(), leg2.get_patches(),</span>
<span class="gi">+    )</span>
<span class="gi">+    assert_artists_equal(</span>
<span class="gi">+        leg1.get_lines(), leg2.get_lines(),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def assert_plots_equal(ax1, ax2, labels=True):</span>
<span class="gi">+</span>
<span class="gi">+    assert_artists_equal(ax1.patches, ax2.patches)</span>
<span class="gi">+    assert_artists_equal(ax1.lines, ax2.lines)</span>
<span class="gi">+    assert_artists_equal(ax1.collections, ax2.collections)</span>
<span class="gi">+</span>
<span class="gi">+    if labels:</span>
<span class="gi">+        assert ax1.get_xlabel() == ax2.get_xlabel()</span>
<span class="gi">+        assert ax1.get_ylabel() == ax2.get_ylabel()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def assert_colors_equal(a, b, check_alpha=True):</span>
<span class="gi">+</span>
<span class="gi">+    def handle_array(x):</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(x, np.ndarray):</span>
<span class="gi">+            if x.ndim &gt; 1:</span>
<span class="gi">+                x = np.unique(x, axis=0).squeeze()</span>
<span class="gi">+            if x.ndim &gt; 1:</span>
<span class="gi">+                raise ValueError(&quot;Color arrays must be 1 dimensional&quot;)</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    a = handle_array(a)</span>
<span class="gi">+    b = handle_array(b)</span>
<span class="gi">+</span>
<span class="gi">+    f = to_rgba if check_alpha else to_rgb</span>
<span class="gi">+    assert f(a) == f(b)</span>
<span class="gh">diff --git a/seaborn/algorithms.py b/seaborn/algorithms.py</span>
<span class="gh">index 2939e8bd..2e34b9dd 100644</span>
<span class="gd">--- a/seaborn/algorithms.py</span>
<span class="gi">+++ b/seaborn/algorithms.py</span>
<span class="gu">@@ -32,9 +32,89 @@ def bootstrap(*args, **kwargs):</span>
<span class="w"> </span>        array of bootstrapped statistic values

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Ensure list of arrays are same length</span>
<span class="gi">+    if len(np.unique(list(map(len, args)))) &gt; 1:</span>
<span class="gi">+        raise ValueError(&quot;All input arrays must have the same length&quot;)</span>
<span class="gi">+    n = len(args[0])</span>
<span class="gi">+</span>
<span class="gi">+    # Default keyword arguments</span>
<span class="gi">+    n_boot = kwargs.get(&quot;n_boot&quot;, 10000)</span>
<span class="gi">+    func = kwargs.get(&quot;func&quot;, &quot;mean&quot;)</span>
<span class="gi">+    axis = kwargs.get(&quot;axis&quot;, None)</span>
<span class="gi">+    units = kwargs.get(&quot;units&quot;, None)</span>
<span class="gi">+    random_seed = kwargs.get(&quot;random_seed&quot;, None)</span>
<span class="gi">+    if random_seed is not None:</span>
<span class="gi">+        msg = &quot;`random_seed` has been renamed to `seed` and will be removed&quot;</span>
<span class="gi">+        warnings.warn(msg)</span>
<span class="gi">+    seed = kwargs.get(&quot;seed&quot;, random_seed)</span>
<span class="gi">+    if axis is None:</span>
<span class="gi">+        func_kwargs = dict()</span>
<span class="gi">+    else:</span>
<span class="gi">+        func_kwargs = dict(axis=axis)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the resampler</span>
<span class="gi">+    if isinstance(seed, np.random.RandomState):</span>
<span class="gi">+        rng = seed</span>
<span class="gi">+    else:</span>
<span class="gi">+        rng = np.random.default_rng(seed)</span>
<span class="gi">+</span>
<span class="gi">+    # Coerce to arrays</span>
<span class="gi">+    args = list(map(np.asarray, args))</span>
<span class="gi">+    if units is not None:</span>
<span class="gi">+        units = np.asarray(units)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(func, str):</span>
<span class="gi">+</span>
<span class="gi">+        # Allow named numpy functions</span>
<span class="gi">+        f = getattr(np, func)</span>
<span class="gi">+</span>
<span class="gi">+        # Try to use nan-aware version of function if necessary</span>
<span class="gi">+        missing_data = np.isnan(np.sum(np.column_stack(args)))</span>
<span class="gi">+</span>
<span class="gi">+        if missing_data and not func.startswith(&quot;nan&quot;):</span>
<span class="gi">+            nanf = getattr(np, f&quot;nan{func}&quot;, None)</span>
<span class="gi">+            if nanf is None:</span>
<span class="gi">+                msg = f&quot;Data contain nans but no nan-aware version of `{func}` found&quot;</span>
<span class="gi">+                warnings.warn(msg, UserWarning)</span>
<span class="gi">+            else:</span>
<span class="gi">+                f = nanf</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        f = func</span>
<span class="gi">+</span>
<span class="gi">+    # Handle numpy changes</span>
<span class="gi">+    try:</span>
<span class="gi">+        integers = rng.integers</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        integers = rng.randint</span>
<span class="gi">+</span>
<span class="gi">+    # Do the bootstrap</span>
<span class="gi">+    if units is not None:</span>
<span class="gi">+        return _structured_bootstrap(args, n_boot, units, f,</span>
<span class="gi">+                                     func_kwargs, integers)</span>
<span class="gi">+</span>
<span class="gi">+    boot_dist = []</span>
<span class="gi">+    for i in range(int(n_boot)):</span>
<span class="gi">+        resampler = integers(0, n, n, dtype=np.intp)  # intp is indexing dtype</span>
<span class="gi">+        sample = [a.take(resampler, axis=0) for a in args]</span>
<span class="gi">+        boot_dist.append(f(*sample, **func_kwargs))</span>
<span class="gi">+    return np.array(boot_dist)</span>


<span class="w"> </span>def _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):
<span class="w"> </span>    &quot;&quot;&quot;Resample units instead of datapoints.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    unique_units = np.unique(units)</span>
<span class="gi">+    n_units = len(unique_units)</span>
<span class="gi">+</span>
<span class="gi">+    args = [[a[units == unit] for unit in unique_units] for a in args]</span>
<span class="gi">+</span>
<span class="gi">+    boot_dist = []</span>
<span class="gi">+    for i in range(int(n_boot)):</span>
<span class="gi">+        resampler = integers(0, n_units, n_units, dtype=np.intp)</span>
<span class="gi">+        sample = [[a[i] for i in resampler] for a in args]</span>
<span class="gi">+        lengths = map(len, sample[0])</span>
<span class="gi">+        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]</span>
<span class="gi">+        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in sample]</span>
<span class="gi">+        sample = list(map(np.concatenate, sample))</span>
<span class="gi">+        boot_dist.append(func(*sample, **func_kwargs))</span>
<span class="gi">+    return np.array(boot_dist)</span>
<span class="gh">diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py</span>
<span class="gh">index 54c0052d..17d333bc 100644</span>
<span class="gd">--- a/seaborn/axisgrid.py</span>
<span class="gi">+++ b/seaborn/axisgrid.py</span>
<span class="gu">@@ -3,20 +3,35 @@ from itertools import product</span>
<span class="w"> </span>from inspect import signature
<span class="w"> </span>import warnings
<span class="w"> </span>from textwrap import dedent
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="gi">+</span>
<span class="w"> </span>from ._base import VectorPlotter, variable_type, categorical_order
<span class="w"> </span>from ._core.data import handle_data_source
<span class="w"> </span>from ._compat import share_axis, get_legend_handles
<span class="w"> </span>from . import utils
<span class="gd">-from .utils import adjust_legend_subtitles, set_hls_values, _check_argument, _draw_figure, _disable_autolayout</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    adjust_legend_subtitles,</span>
<span class="gi">+    set_hls_values,</span>
<span class="gi">+    _check_argument,</span>
<span class="gi">+    _draw_figure,</span>
<span class="gi">+    _disable_autolayout</span>
<span class="gi">+)</span>
<span class="w"> </span>from .palettes import color_palette, blend_palette
<span class="gd">-from ._docstrings import DocstringComponents, _core_docs</span>
<span class="gd">-__all__ = [&#39;FacetGrid&#39;, &#39;PairGrid&#39;, &#39;JointGrid&#39;, &#39;pairplot&#39;, &#39;jointplot&#39;]</span>
<span class="gd">-_param_docs = DocstringComponents.from_nested_components(core=_core_docs[</span>
<span class="gd">-    &#39;params&#39;])</span>
<span class="gi">+from ._docstrings import (</span>
<span class="gi">+    DocstringComponents,</span>
<span class="gi">+    _core_docs,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;FacetGrid&quot;, &quot;PairGrid&quot;, &quot;JointGrid&quot;, &quot;pairplot&quot;, &quot;jointplot&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_param_docs = DocstringComponents.from_nested_components(</span>
<span class="gi">+    core=_core_docs[&quot;params&quot;],</span>
<span class="gi">+)</span>


<span class="w"> </span>class _BaseGrid:
<span class="gu">@@ -24,17 +39,24 @@ class _BaseGrid:</span>

<span class="w"> </span>    def set(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Set attributes on each subplot Axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.axes.flat:</span>
<span class="gi">+            if ax is not None:  # Handle removed axes</span>
<span class="gi">+                ax.set(**kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def fig(self):
<span class="w"> </span>        &quot;&quot;&quot;DEPRECATED: prefer the `figure` property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Grid.figure is preferred because it matches the Axes attribute name.</span>
<span class="gi">+        # But as the maintanace burden on having this property is minimal,</span>
<span class="gi">+        # let&#39;s be slow about formally deprecating it. For now just note its deprecation</span>
<span class="gi">+        # in the docstring; add a warning in version 0.13, and eventually remove it.</span>
<span class="gi">+        return self._figure</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def figure(self):
<span class="w"> </span>        &quot;&quot;&quot;Access the :class:`matplotlib.figure.Figure` object underlying the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._figure</span>

<span class="w"> </span>    def apply(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -48,7 +70,8 @@ class _BaseGrid:</span>
<span class="w"> </span>        Added in v0.12.0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        func(self, *args, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def pipe(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -62,7 +85,7 @@ class _BaseGrid:</span>
<span class="w"> </span>        Added in v0.12.0.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>

<span class="w"> </span>    def savefig(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -72,7 +95,9 @@ class _BaseGrid:</span>
<span class="w"> </span>        by default. Parameters are passed through to the matplotlib function.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        kwargs.setdefault(&quot;bbox_inches&quot;, &quot;tight&quot;)</span>
<span class="gi">+        self.figure.savefig(*args, **kwargs)</span>


<span class="w"> </span>class Grid(_BaseGrid):
<span class="gu">@@ -81,16 +106,25 @@ class Grid(_BaseGrid):</span>
<span class="w"> </span>    _legend_out = True

<span class="w"> </span>    def __init__(self):
<span class="gi">+</span>
<span class="w"> </span>        self._tight_layout_rect = [0, 0, 1, 1]
<span class="w"> </span>        self._tight_layout_pad = None
<span class="gi">+</span>
<span class="gi">+        # This attribute is set externally and is a hack to handle newer functions that</span>
<span class="gi">+        # don&#39;t add proxy artists onto the Axes. We need an overall cleaner approach.</span>
<span class="w"> </span>        self._extract_legend_handles = False

<span class="w"> </span>    def tight_layout(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Call fig.tight_layout within rect that exclude the legend.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        kwargs.setdefault(&quot;rect&quot;, self._tight_layout_rect)</span>
<span class="gi">+        if self._tight_layout_pad is not None:</span>
<span class="gi">+            kwargs.setdefault(&quot;pad&quot;, self._tight_layout_pad)</span>
<span class="gi">+        self._figure.tight_layout(*args, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def add_legend(self, legend_data=None, title=None, label_order=None,
<span class="gd">-        adjust_subtitles=False, **kwargs):</span>
<span class="gi">+                   adjust_subtitles=False, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Draw a legend, maybe placing it outside axes and resizing the figure.

<span class="w"> </span>        Parameters
<span class="gu">@@ -117,20 +151,138 @@ class Grid(_BaseGrid):</span>
<span class="w"> </span>            Returns self for easy chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Find the data for the legend</span>
<span class="gi">+        if legend_data is None:</span>
<span class="gi">+            legend_data = self._legend_data</span>
<span class="gi">+        if label_order is None:</span>
<span class="gi">+            if self.hue_names is None:</span>
<span class="gi">+                label_order = list(legend_data.keys())</span>
<span class="gi">+            else:</span>
<span class="gi">+                label_order = list(map(utils.to_utf8, self.hue_names))</span>
<span class="gi">+</span>
<span class="gi">+        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)</span>
<span class="gi">+        handles = [legend_data.get(lab, blank_handle) for lab in label_order]</span>
<span class="gi">+        title = self._hue_var if title is None else title</span>
<span class="gi">+        title_size = mpl.rcParams[&quot;legend.title_fontsize&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # Unpack nested labels from a hierarchical legend</span>
<span class="gi">+        labels = []</span>
<span class="gi">+        for entry in label_order:</span>
<span class="gi">+            if isinstance(entry, tuple):</span>
<span class="gi">+                _, label = entry</span>
<span class="gi">+            else:</span>
<span class="gi">+                label = entry</span>
<span class="gi">+            labels.append(label)</span>
<span class="gi">+</span>
<span class="gi">+        # Set default legend kwargs</span>
<span class="gi">+        kwargs.setdefault(&quot;scatterpoints&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if self._legend_out:</span>
<span class="gi">+</span>
<span class="gi">+            kwargs.setdefault(&quot;frameon&quot;, False)</span>
<span class="gi">+            kwargs.setdefault(&quot;loc&quot;, &quot;center right&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # Draw a full-figure legend outside the grid</span>
<span class="gi">+            figlegend = self._figure.legend(handles, labels, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            self._legend = figlegend</span>
<span class="gi">+            figlegend.set_title(title, prop={&quot;size&quot;: title_size})</span>
<span class="gi">+</span>
<span class="gi">+            if adjust_subtitles:</span>
<span class="gi">+                adjust_legend_subtitles(figlegend)</span>
<span class="gi">+</span>
<span class="gi">+            # Draw the plot to set the bounding boxes correctly</span>
<span class="gi">+            _draw_figure(self._figure)</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate and set the new width of the figure so the legend fits</span>
<span class="gi">+            legend_width = figlegend.get_window_extent().width / self._figure.dpi</span>
<span class="gi">+            fig_width, fig_height = self._figure.get_size_inches()</span>
<span class="gi">+            self._figure.set_size_inches(fig_width + legend_width, fig_height)</span>
<span class="gi">+</span>
<span class="gi">+            # Draw the plot again to get the new transformations</span>
<span class="gi">+            _draw_figure(self._figure)</span>
<span class="gi">+</span>
<span class="gi">+            # Now calculate how much space we need on the right side</span>
<span class="gi">+            legend_width = figlegend.get_window_extent().width / self._figure.dpi</span>
<span class="gi">+            space_needed = legend_width / (fig_width + legend_width)</span>
<span class="gi">+            margin = .04 if self._margin_titles else .01</span>
<span class="gi">+            self._space_needed = margin + space_needed</span>
<span class="gi">+            right = 1 - self._space_needed</span>
<span class="gi">+</span>
<span class="gi">+            # Place the subplot axes to give space for the legend</span>
<span class="gi">+            self._figure.subplots_adjust(right=right)</span>
<span class="gi">+            self._tight_layout_rect[2] = right</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Draw a legend in the first axis</span>
<span class="gi">+            ax = self.axes.flat[0]</span>
<span class="gi">+            kwargs.setdefault(&quot;loc&quot;, &quot;best&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            leg = ax.legend(handles, labels, **kwargs)</span>
<span class="gi">+            leg.set_title(title, prop={&quot;size&quot;: title_size})</span>
<span class="gi">+            self._legend = leg</span>
<span class="gi">+</span>
<span class="gi">+            if adjust_subtitles:</span>
<span class="gi">+                adjust_legend_subtitles(leg)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _update_legend_data(self, ax):
<span class="w"> </span>        &quot;&quot;&quot;Extract the legend data from an axes object and save it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Get data directly from the legend, which is necessary</span>
<span class="gi">+        # for newer functions that don&#39;t add labeled proxy artists</span>
<span class="gi">+        if ax.legend_ is not None and self._extract_legend_handles:</span>
<span class="gi">+            handles = get_legend_handles(ax.legend_)</span>
<span class="gi">+            labels = [t.get_text() for t in ax.legend_.texts]</span>
<span class="gi">+            data.update({label: handle for handle, label in zip(handles, labels)})</span>
<span class="gi">+</span>
<span class="gi">+        handles, labels = ax.get_legend_handles_labels()</span>
<span class="gi">+        data.update({label: handle for handle, label in zip(handles, labels)})</span>
<span class="gi">+</span>
<span class="gi">+        self._legend_data.update(data)</span>
<span class="gi">+</span>
<span class="gi">+        # Now clear the legend</span>
<span class="gi">+        ax.legend_ = None</span>

<span class="w"> </span>    def _get_palette(self, data, hue, hue_order, palette):
<span class="w"> </span>        &quot;&quot;&quot;Get a list of colors for the hue variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hue is None:</span>
<span class="gi">+            palette = color_palette(n_colors=1)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            hue_names = categorical_order(data[hue], hue_order)</span>
<span class="gi">+            n_colors = len(hue_names)</span>
<span class="gi">+</span>
<span class="gi">+            # By default use either the current color palette or HUSL</span>
<span class="gi">+            if palette is None:</span>
<span class="gi">+                current_palette = utils.get_color_cycle()</span>
<span class="gi">+                if n_colors &gt; len(current_palette):</span>
<span class="gi">+                    colors = color_palette(&quot;husl&quot;, n_colors)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    colors = color_palette(n_colors=n_colors)</span>
<span class="gi">+</span>
<span class="gi">+            # Allow for palette to map from hue variable names</span>
<span class="gi">+            elif isinstance(palette, dict):</span>
<span class="gi">+                color_names = [palette[h] for h in hue_names]</span>
<span class="gi">+                colors = color_palette(color_names, n_colors)</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise act as if we just got a list of colors</span>
<span class="gi">+            else:</span>
<span class="gi">+                colors = color_palette(palette, n_colors)</span>
<span class="gi">+</span>
<span class="gi">+            palette = color_palette(colors, n_colors)</span>
<span class="gi">+</span>
<span class="gi">+        return palette</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def legend(self):
<span class="w"> </span>        &quot;&quot;&quot;The :class:`matplotlib.legend.Legend` object, if present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._legend</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def tick_params(self, axis=&#39;both&#39;, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Modify the ticks, tick labels, and gridlines.
<span class="gu">@@ -149,81 +301,111 @@ class Grid(_BaseGrid):</span>
<span class="w"> </span>            Returns self for easy chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.figure.axes:</span>
<span class="gi">+            ax.tick_params(axis=axis, **kwargs)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>

<span class="gi">+_facet_docs = dict(</span>

<span class="gd">-_facet_docs = dict(data=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    data : DataFrame</span>
<span class="gi">+    data=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    data : DataFrame</span>
<span class="w"> </span>        Tidy (&quot;long-form&quot;) dataframe where each column is a variable and each
<span class="gd">-        row is an observation.    &quot;&quot;&quot;</span>
<span class="gd">-    ), rowcol=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    row, col : vectors or keys in ``data``</span>
<span class="gd">-        Variables that define subsets to plot on different facets.    &quot;&quot;&quot;</span>
<span class="gd">-    ), rowcol_order=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    {row,col}_order : vector of strings</span>
<span class="gi">+        row is an observation.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    rowcol=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    row, col : vectors or keys in ``data``</span>
<span class="gi">+        Variables that define subsets to plot on different facets.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    rowcol_order=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    {row,col}_order : vector of strings</span>
<span class="w"> </span>        Specify the order in which levels of the ``row`` and/or ``col`` variables
<span class="gd">-        appear in the grid of subplots.    &quot;&quot;&quot;</span>
<span class="gd">-    ), col_wrap=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    col_wrap : int</span>
<span class="gi">+        appear in the grid of subplots.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    col_wrap=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    col_wrap : int</span>
<span class="w"> </span>        &quot;Wrap&quot; the column variable at this width, so that the column facets
<span class="gd">-        span multiple rows. Incompatible with a ``row`` facet.    &quot;&quot;&quot;</span>
<span class="gd">-    ), share_xy=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    share{x,y} : bool, &#39;col&#39;, or &#39;row&#39; optional</span>
<span class="gi">+        span multiple rows. Incompatible with a ``row`` facet.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    share_xy=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    share{x,y} : bool, &#39;col&#39;, or &#39;row&#39; optional</span>
<span class="w"> </span>        If true, the facets will share y axes across columns and/or x axes
<span class="gd">-        across rows.    &quot;&quot;&quot;</span>
<span class="gd">-    ), height=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    height : scalar</span>
<span class="gd">-        Height (in inches) of each facet. See also: ``aspect``.    &quot;&quot;&quot;</span>
<span class="gd">-    ), aspect=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    aspect : scalar</span>
<span class="gi">+        across rows.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    height=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    height : scalar</span>
<span class="gi">+        Height (in inches) of each facet. See also: ``aspect``.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    aspect=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    aspect : scalar</span>
<span class="w"> </span>        Aspect ratio of each facet, so that ``aspect * height`` gives the width
<span class="gd">-        of each facet in inches.    &quot;&quot;&quot;</span>
<span class="gd">-    ), palette=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    palette : palette name, list, or dict</span>
<span class="gi">+        of each facet in inches.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    palette=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    palette : palette name, list, or dict</span>
<span class="w"> </span>        Colors to use for the different levels of the ``hue`` variable. Should
<span class="w"> </span>        be something that can be interpreted by :func:`color_palette`, or a
<span class="gd">-        dictionary mapping hue levels to matplotlib colors.    &quot;&quot;&quot;</span>
<span class="gd">-    ), legend_out=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    legend_out : bool</span>
<span class="gi">+        dictionary mapping hue levels to matplotlib colors.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    legend_out=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    legend_out : bool</span>
<span class="w"> </span>        If ``True``, the figure size will be extended, and the legend will be
<span class="gd">-        drawn outside the plot on the center right.    &quot;&quot;&quot;</span>
<span class="gd">-    ), margin_titles=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    margin_titles : bool</span>
<span class="gi">+        drawn outside the plot on the center right.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    margin_titles=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    margin_titles : bool</span>
<span class="w"> </span>        If ``True``, the titles for the row variable are drawn to the right of
<span class="w"> </span>        the last column. This option is experimental and may not work in all
<span class="gd">-        cases.    &quot;&quot;&quot;</span>
<span class="gd">-    ), facet_kws=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    facet_kws : dict</span>
<span class="gi">+        cases.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    facet_kws=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    facet_kws : dict</span>
<span class="w"> </span>        Additional parameters passed to :class:`FacetGrid`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ))</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+)</span>


<span class="w"> </span>class FacetGrid(Grid):
<span class="w"> </span>    &quot;&quot;&quot;Multi-plot grid for plotting conditional relationships.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, data, *, row=None, col=None, hue=None, col_wrap=None,</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, data, *,</span>
<span class="gi">+        row=None, col=None, hue=None, col_wrap=None,</span>
<span class="w"> </span>        sharex=True, sharey=True, height=3, aspect=1, palette=None,
<span class="w"> </span>        row_order=None, col_order=None, hue_order=None, hue_kws=None,
<span class="gd">-        dropna=False, legend_out=True, despine=True, margin_titles=False,</span>
<span class="gd">-        xlim=None, ylim=None, subplot_kws=None, gridspec_kws=None):</span>
<span class="gi">+        dropna=False, legend_out=True, despine=True,</span>
<span class="gi">+        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,</span>
<span class="gi">+        gridspec_kws=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        data = handle_data_source(data)
<span class="gi">+</span>
<span class="gi">+        # Determine the hue facet layer information</span>
<span class="w"> </span>        hue_var = hue
<span class="w"> </span>        if hue is None:
<span class="w"> </span>            hue_names = None
<span class="w"> </span>        else:
<span class="w"> </span>            hue_names = categorical_order(data[hue], hue_order)
<span class="gi">+</span>
<span class="w"> </span>        colors = self._get_palette(data, hue, hue_order, palette)
<span class="gi">+</span>
<span class="gi">+        # Set up the lists of names for the row and column facet variables</span>
<span class="w"> </span>        if row is None:
<span class="w"> </span>            row_names = []
<span class="w"> </span>        else:
<span class="w"> </span>            row_names = categorical_order(data[row], row_order)
<span class="gi">+</span>
<span class="w"> </span>        if col is None:
<span class="w"> </span>            col_names = []
<span class="w"> </span>        else:
<span class="w"> </span>            col_names = categorical_order(data[col], col_order)
<span class="gi">+</span>
<span class="gi">+        # Additional dict of kwarg -&gt; list of values for mapping the hue var</span>
<span class="w"> </span>        hue_kws = hue_kws if hue_kws is not None else {}
<span class="gi">+</span>
<span class="gi">+        # Make a boolean mask that is True anywhere there is an NA</span>
<span class="gi">+        # value in one of the faceting variables, but only if dropna is True</span>
<span class="w"> </span>        none_na = np.zeros(len(data), bool)
<span class="w"> </span>        if dropna:
<span class="w"> </span>            row_na = none_na if row is None else data[row].isnull()
<span class="gu">@@ -232,33 +414,53 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            not_na = ~(row_na | col_na | hue_na)
<span class="w"> </span>        else:
<span class="w"> </span>            not_na = ~none_na
<span class="gi">+</span>
<span class="gi">+        # Compute the grid shape</span>
<span class="w"> </span>        ncol = 1 if col is None else len(col_names)
<span class="w"> </span>        nrow = 1 if row is None else len(row_names)
<span class="w"> </span>        self._n_facets = ncol * nrow
<span class="gi">+</span>
<span class="w"> </span>        self._col_wrap = col_wrap
<span class="w"> </span>        if col_wrap is not None:
<span class="w"> </span>            if row is not None:
<span class="gd">-                err = &#39;Cannot use `row` and `col_wrap` together.&#39;</span>
<span class="gi">+                err = &quot;Cannot use `row` and `col_wrap` together.&quot;</span>
<span class="w"> </span>                raise ValueError(err)
<span class="w"> </span>            ncol = col_wrap
<span class="w"> </span>            nrow = int(np.ceil(len(col_names) / col_wrap))
<span class="w"> </span>        self._ncol = ncol
<span class="w"> </span>        self._nrow = nrow
<span class="gd">-        figsize = ncol * height * aspect, nrow * height</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the base figure size</span>
<span class="gi">+        # This can get stretched later by a legend</span>
<span class="gi">+        # TODO this doesn&#39;t account for axis labels</span>
<span class="gi">+        figsize = (ncol * height * aspect, nrow * height)</span>
<span class="gi">+</span>
<span class="gi">+        # Validate some inputs</span>
<span class="w"> </span>        if col_wrap is not None:
<span class="w"> </span>            margin_titles = False
<span class="gi">+</span>
<span class="gi">+        # Build the subplot keyword dictionary</span>
<span class="w"> </span>        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()
<span class="w"> </span>        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()
<span class="w"> </span>        if xlim is not None:
<span class="gd">-            subplot_kws[&#39;xlim&#39;] = xlim</span>
<span class="gi">+            subplot_kws[&quot;xlim&quot;] = xlim</span>
<span class="w"> </span>        if ylim is not None:
<span class="gd">-            subplot_kws[&#39;ylim&#39;] = ylim</span>
<span class="gi">+            subplot_kws[&quot;ylim&quot;] = ylim</span>
<span class="gi">+</span>
<span class="gi">+        # --- Initialize the subplot grid</span>
<span class="gi">+</span>
<span class="w"> </span>        with _disable_autolayout():
<span class="w"> </span>            fig = plt.figure(figsize=figsize)
<span class="gi">+</span>
<span class="w"> </span>        if col_wrap is None:
<span class="gd">-            kwargs = dict(squeeze=False, sharex=sharex, sharey=sharey,</span>
<span class="gd">-                subplot_kw=subplot_kws, gridspec_kw=gridspec_kws)</span>
<span class="gi">+</span>
<span class="gi">+            kwargs = dict(squeeze=False,</span>
<span class="gi">+                          sharex=sharex, sharey=sharey,</span>
<span class="gi">+                          subplot_kw=subplot_kws,</span>
<span class="gi">+                          gridspec_kw=gridspec_kws)</span>
<span class="gi">+</span>
<span class="w"> </span>            axes = fig.subplots(nrow, ncol, **kwargs)
<span class="gi">+</span>
<span class="w"> </span>            if col is None and row is None:
<span class="w"> </span>                axes_dict = {}
<span class="w"> </span>            elif col is None:
<span class="gu">@@ -268,32 +470,48 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            else:
<span class="w"> </span>                facet_product = product(row_names, col_names)
<span class="w"> </span>                axes_dict = dict(zip(facet_product, axes.flat))
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="gi">+</span>
<span class="gi">+            # If wrapping the col variable we need to make the grid ourselves</span>
<span class="w"> </span>            if gridspec_kws:
<span class="gd">-                warnings.warn(&#39;`gridspec_kws` ignored when using `col_wrap`&#39;)</span>
<span class="gi">+                warnings.warn(&quot;`gridspec_kws` ignored when using `col_wrap`&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>            n_axes = len(col_names)
<span class="w"> </span>            axes = np.empty(n_axes, object)
<span class="w"> </span>            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)
<span class="w"> </span>            if sharex:
<span class="gd">-                subplot_kws[&#39;sharex&#39;] = axes[0]</span>
<span class="gi">+                subplot_kws[&quot;sharex&quot;] = axes[0]</span>
<span class="w"> </span>            if sharey:
<span class="gd">-                subplot_kws[&#39;sharey&#39;] = axes[0]</span>
<span class="gi">+                subplot_kws[&quot;sharey&quot;] = axes[0]</span>
<span class="w"> </span>            for i in range(1, n_axes):
<span class="w"> </span>                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)
<span class="gi">+</span>
<span class="w"> </span>            axes_dict = dict(zip(col_names, axes))
<span class="gi">+</span>
<span class="gi">+        # --- Set up the class attributes</span>
<span class="gi">+</span>
<span class="gi">+        # Attributes that are part of the public API but accessed through</span>
<span class="gi">+        # a  property so that Sphinx adds them to the auto class doc</span>
<span class="w"> </span>        self._figure = fig
<span class="w"> </span>        self._axes = axes
<span class="w"> </span>        self._axes_dict = axes_dict
<span class="w"> </span>        self._legend = None
<span class="gi">+</span>
<span class="gi">+        # Public attributes that aren&#39;t explicitly documented</span>
<span class="gi">+        # (It&#39;s not obvious that having them be public was a good idea)</span>
<span class="w"> </span>        self.data = data
<span class="w"> </span>        self.row_names = row_names
<span class="w"> </span>        self.col_names = col_names
<span class="w"> </span>        self.hue_names = hue_names
<span class="w"> </span>        self.hue_kws = hue_kws
<span class="gi">+</span>
<span class="gi">+        # Next the private variables</span>
<span class="w"> </span>        self._nrow = nrow
<span class="w"> </span>        self._row_var = row
<span class="w"> </span>        self._ncol = ncol
<span class="w"> </span>        self._col_var = col
<span class="gi">+</span>
<span class="w"> </span>        self._margin_titles = margin_titles
<span class="w"> </span>        self._margin_titles_texts = []
<span class="w"> </span>        self._col_wrap = col_wrap
<span class="gu">@@ -307,24 +525,31 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>        self._sharey = sharey
<span class="w"> </span>        self._dropna = dropna
<span class="w"> </span>        self._not_na = not_na
<span class="gi">+</span>
<span class="gi">+        # --- Make the axes look good</span>
<span class="gi">+</span>
<span class="w"> </span>        self.set_titles()
<span class="w"> </span>        self.tight_layout()
<span class="gi">+</span>
<span class="w"> </span>        if despine:
<span class="w"> </span>            self.despine()
<span class="gi">+</span>
<span class="w"> </span>        if sharex in [True, &#39;col&#39;]:
<span class="w"> </span>            for ax in self._not_bottom_axes:
<span class="w"> </span>                for label in ax.get_xticklabels():
<span class="w"> </span>                    label.set_visible(False)
<span class="w"> </span>                ax.xaxis.offsetText.set_visible(False)
<span class="w"> </span>                ax.xaxis.label.set_visible(False)
<span class="gi">+</span>
<span class="w"> </span>        if sharey in [True, &#39;row&#39;]:
<span class="w"> </span>            for ax in self._not_left_axes:
<span class="w"> </span>                for label in ax.get_yticklabels():
<span class="w"> </span>                    label.set_visible(False)
<span class="w"> </span>                ax.yaxis.offsetText.set_visible(False)
<span class="w"> </span>                ax.yaxis.label.set_visible(False)
<span class="gd">-    __init__.__doc__ = dedent(</span>
<span class="gd">-        &quot;&quot;&quot;        Initialize the matplotlib figure and FacetGrid object.</span>
<span class="gi">+</span>
<span class="gi">+    __init__.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+        Initialize the matplotlib figure and FacetGrid object.</span>

<span class="w"> </span>        This class maps a dataset onto multiple axes arrayed in a grid of rows
<span class="w"> </span>        and columns that correspond to *levels* of variables in the dataset.
<span class="gu">@@ -413,8 +638,7 @@ class FacetGrid(Grid):</span>

<span class="w"> </span>        .. include:: ../docstrings/FacetGrid.rst

<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        ).format(**_facet_docs)</span>
<span class="gi">+        &quot;&quot;&quot;).format(**_facet_docs)</span>

<span class="w"> </span>    def facet_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Generator for name indices and data subsets for each facet.
<span class="gu">@@ -429,7 +653,32 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            is None.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self.data</span>
<span class="gi">+</span>
<span class="gi">+        # Construct masks for the row variable</span>
<span class="gi">+        if self.row_names:</span>
<span class="gi">+            row_masks = [data[self._row_var] == n for n in self.row_names]</span>
<span class="gi">+        else:</span>
<span class="gi">+            row_masks = [np.repeat(True, len(self.data))]</span>
<span class="gi">+</span>
<span class="gi">+        # Construct masks for the column variable</span>
<span class="gi">+        if self.col_names:</span>
<span class="gi">+            col_masks = [data[self._col_var] == n for n in self.col_names]</span>
<span class="gi">+        else:</span>
<span class="gi">+            col_masks = [np.repeat(True, len(self.data))]</span>
<span class="gi">+</span>
<span class="gi">+        # Construct masks for the hue variable</span>
<span class="gi">+        if self.hue_names:</span>
<span class="gi">+            hue_masks = [data[self._hue_var] == n for n in self.hue_names]</span>
<span class="gi">+        else:</span>
<span class="gi">+            hue_masks = [np.repeat(True, len(self.data))]</span>
<span class="gi">+</span>
<span class="gi">+        # Here is the main generator loop</span>
<span class="gi">+        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),</span>
<span class="gi">+                                                    enumerate(col_masks),</span>
<span class="gi">+                                                    enumerate(hue_masks)):</span>
<span class="gi">+            data_ijk = data[row &amp; col &amp; hue &amp; self._not_na]</span>
<span class="gi">+            yield (i, j, k), data_ijk</span>

<span class="w"> </span>    def map(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Apply a plotting function to each facet&#39;s subset of the data.
<span class="gu">@@ -454,7 +703,64 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            Returns self.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If color was a keyword argument, grab it here</span>
<span class="gi">+        kw_color = kwargs.pop(&quot;color&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # How we use the function depends on where it comes from</span>
<span class="gi">+        func_module = str(getattr(func, &quot;__module__&quot;, &quot;&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Check for categorical plots without order information</span>
<span class="gi">+        if func_module == &quot;seaborn.categorical&quot;:</span>
<span class="gi">+            if &quot;order&quot; not in kwargs:</span>
<span class="gi">+                warning = (&quot;Using the {} function without specifying &quot;</span>
<span class="gi">+                           &quot;`order` is likely to produce an incorrect &quot;</span>
<span class="gi">+                           &quot;plot.&quot;.format(func.__name__))</span>
<span class="gi">+                warnings.warn(warning)</span>
<span class="gi">+            if len(args) == 3 and &quot;hue_order&quot; not in kwargs:</span>
<span class="gi">+                warning = (&quot;Using the {} function without specifying &quot;</span>
<span class="gi">+                           &quot;`hue_order` is likely to produce an incorrect &quot;</span>
<span class="gi">+                           &quot;plot.&quot;.format(func.__name__))</span>
<span class="gi">+                warnings.warn(warning)</span>
<span class="gi">+</span>
<span class="gi">+        # Iterate over the data subsets</span>
<span class="gi">+        for (row_i, col_j, hue_k), data_ijk in self.facet_data():</span>
<span class="gi">+</span>
<span class="gi">+            # If this subset is null, move on</span>
<span class="gi">+            if not data_ijk.values.size:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Get the current axis</span>
<span class="gi">+            modify_state = not func_module.startswith(&quot;seaborn&quot;)</span>
<span class="gi">+            ax = self.facet_axis(row_i, col_j, modify_state)</span>
<span class="gi">+</span>
<span class="gi">+            # Decide what color to plot with</span>
<span class="gi">+            kwargs[&quot;color&quot;] = self._facet_color(hue_k, kw_color)</span>
<span class="gi">+</span>
<span class="gi">+            # Insert the other hue aesthetics if appropriate</span>
<span class="gi">+            for kw, val_list in self.hue_kws.items():</span>
<span class="gi">+                kwargs[kw] = val_list[hue_k]</span>
<span class="gi">+</span>
<span class="gi">+            # Insert a label in the keyword arguments for the legend</span>
<span class="gi">+            if self._hue_var is not None:</span>
<span class="gi">+                kwargs[&quot;label&quot;] = utils.to_utf8(self.hue_names[hue_k])</span>
<span class="gi">+</span>
<span class="gi">+            # Get the actual data we are going to plot with</span>
<span class="gi">+            plot_data = data_ijk[list(args)]</span>
<span class="gi">+            if self._dropna:</span>
<span class="gi">+                plot_data = plot_data.dropna()</span>
<span class="gi">+            plot_args = [v for k, v in plot_data.items()]</span>
<span class="gi">+</span>
<span class="gi">+            # Some matplotlib functions don&#39;t handle pandas objects correctly</span>
<span class="gi">+            if func_module.startswith(&quot;matplotlib&quot;):</span>
<span class="gi">+                plot_args = [v.values for v in plot_args]</span>
<span class="gi">+</span>
<span class="gi">+            # Draw the plot</span>
<span class="gi">+            self._facet_plot(func, ax, plot_args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Finalize the annotations and layout</span>
<span class="gi">+        self._finalize_grid(args[:2])</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def map_dataframe(self, func, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Like ``.map`` but passes args as strings and inserts data in kwargs.
<span class="gu">@@ -484,43 +790,158 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            Returns self.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # If color was a keyword argument, grab it here</span>
<span class="gi">+        kw_color = kwargs.pop(&quot;color&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Iterate over the data subsets</span>
<span class="gi">+        for (row_i, col_j, hue_k), data_ijk in self.facet_data():</span>
<span class="gi">+</span>
<span class="gi">+            # If this subset is null, move on</span>
<span class="gi">+            if not data_ijk.values.size:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Get the current axis</span>
<span class="gi">+            modify_state = not str(func.__module__).startswith(&quot;seaborn&quot;)</span>
<span class="gi">+            ax = self.facet_axis(row_i, col_j, modify_state)</span>
<span class="gi">+</span>
<span class="gi">+            # Decide what color to plot with</span>
<span class="gi">+            kwargs[&quot;color&quot;] = self._facet_color(hue_k, kw_color)</span>
<span class="gi">+</span>
<span class="gi">+            # Insert the other hue aesthetics if appropriate</span>
<span class="gi">+            for kw, val_list in self.hue_kws.items():</span>
<span class="gi">+                kwargs[kw] = val_list[hue_k]</span>
<span class="gi">+</span>
<span class="gi">+            # Insert a label in the keyword arguments for the legend</span>
<span class="gi">+            if self._hue_var is not None:</span>
<span class="gi">+                kwargs[&quot;label&quot;] = self.hue_names[hue_k]</span>
<span class="gi">+</span>
<span class="gi">+            # Stick the facet dataframe into the kwargs</span>
<span class="gi">+            if self._dropna:</span>
<span class="gi">+                data_ijk = data_ijk.dropna()</span>
<span class="gi">+            kwargs[&quot;data&quot;] = data_ijk</span>
<span class="gi">+</span>
<span class="gi">+            # Draw the plot</span>
<span class="gi">+            self._facet_plot(func, ax, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # For axis labels, prefer to use positional args for backcompat</span>
<span class="gi">+        # but also extract the x/y kwargs and use if no corresponding arg</span>
<span class="gi">+        axis_labels = [kwargs.get(&quot;x&quot;, None), kwargs.get(&quot;y&quot;, None)]</span>
<span class="gi">+        for i, val in enumerate(args[:2]):</span>
<span class="gi">+            axis_labels[i] = val</span>
<span class="gi">+        self._finalize_grid(axis_labels)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _facet_color(self, hue_index, kw_color):</span>
<span class="gi">+</span>
<span class="gi">+        color = self._colors[hue_index]</span>
<span class="gi">+        if kw_color is not None:</span>
<span class="gi">+            return kw_color</span>
<span class="gi">+        elif color is not None:</span>
<span class="gi">+            return color</span>
<span class="gi">+</span>
<span class="gi">+    def _facet_plot(self, func, ax, plot_args, plot_kwargs):</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the plot</span>
<span class="gi">+        if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+            plot_kwargs = plot_kwargs.copy()</span>
<span class="gi">+            semantics = [&quot;x&quot;, &quot;y&quot;, &quot;hue&quot;, &quot;size&quot;, &quot;style&quot;]</span>
<span class="gi">+            for key, val in zip(semantics, plot_args):</span>
<span class="gi">+                plot_kwargs[key] = val</span>
<span class="gi">+            plot_args = []</span>
<span class="gi">+            plot_kwargs[&quot;ax&quot;] = ax</span>
<span class="gi">+        func(*plot_args, **plot_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Sort out the supporting information</span>
<span class="gi">+        self._update_legend_data(ax)</span>

<span class="w"> </span>    def _finalize_grid(self, axlabels):
<span class="w"> </span>        &quot;&quot;&quot;Finalize the annotations and layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_axis_labels(*axlabels)</span>
<span class="gi">+        self.tight_layout()</span>

<span class="w"> </span>    def facet_axis(self, row_i, col_j, modify_state=True):
<span class="w"> </span>        &quot;&quot;&quot;Make the axis identified by these indices active and return it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the actual indices of the axes to plot on</span>
<span class="gi">+        if self._col_wrap is not None:</span>
<span class="gi">+            ax = self.axes.flat[col_j]</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax = self.axes[row_i, col_j]</span>
<span class="gi">+</span>
<span class="gi">+        # Get a reference to the axes object we want, and make it active</span>
<span class="gi">+        if modify_state:</span>
<span class="gi">+            plt.sca(ax)</span>
<span class="gi">+        return ax</span>

<span class="w"> </span>    def despine(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Remove axis spines from the facets.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        utils.despine(self._figure, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **</span>
<span class="gd">-        kwargs):</span>
<span class="gi">+    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Set axis labels on the left column and bottom row of the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if x_var is not None:</span>
<span class="gi">+            self._x_var = x_var</span>
<span class="gi">+            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)</span>
<span class="gi">+        if y_var is not None:</span>
<span class="gi">+            self._y_var = y_var</span>
<span class="gi">+            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_xlabels(self, label=None, clear_inner=True, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Label the x axis on the bottom row of the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if label is None:</span>
<span class="gi">+            label = self._x_var</span>
<span class="gi">+        for ax in self._bottom_axes:</span>
<span class="gi">+            ax.set_xlabel(label, **kwargs)</span>
<span class="gi">+        if clear_inner:</span>
<span class="gi">+            for ax in self._not_bottom_axes:</span>
<span class="gi">+                ax.set_xlabel(&quot;&quot;)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_ylabels(self, label=None, clear_inner=True, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Label the y axis on the left column of the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if label is None:</span>
<span class="gi">+            label = self._y_var</span>
<span class="gi">+        for ax in self._left_axes:</span>
<span class="gi">+            ax.set_ylabel(label, **kwargs)</span>
<span class="gi">+        if clear_inner:</span>
<span class="gi">+            for ax in self._not_left_axes:</span>
<span class="gi">+                ax.set_ylabel(&quot;&quot;)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_xticklabels(self, labels=None, step=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Set x axis tick labels of the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.axes.flat:</span>
<span class="gi">+            curr_ticks = ax.get_xticks()</span>
<span class="gi">+            ax.set_xticks(curr_ticks)</span>
<span class="gi">+            if labels is None:</span>
<span class="gi">+                curr_labels = [label.get_text() for label in ax.get_xticklabels()]</span>
<span class="gi">+                if step is not None:</span>
<span class="gi">+                    xticks = ax.get_xticks()[::step]</span>
<span class="gi">+                    curr_labels = curr_labels[::step]</span>
<span class="gi">+                    ax.set_xticks(xticks)</span>
<span class="gi">+                ax.set_xticklabels(curr_labels, **kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ax.set_xticklabels(labels, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def set_yticklabels(self, labels=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Set y axis tick labels on the left column of the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax in self.axes.flat:</span>
<span class="gi">+            curr_ticks = ax.get_yticks()</span>
<span class="gi">+            ax.set_yticks(curr_ticks)</span>
<span class="gi">+            if labels is None:</span>
<span class="gi">+                curr_labels = [label.get_text() for label in ax.get_yticklabels()]</span>
<span class="gi">+                ax.set_yticklabels(curr_labels, **kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ax.set_yticklabels(labels, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def set_titles(self, template=None, row_template=None, col_template=</span>
<span class="gd">-        None, **kwargs):</span>
<span class="gi">+    def set_titles(self, template=None, row_template=None, col_template=None, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Draw titles either above each facet or on the grid margins.

<span class="w"> </span>        Parameters
<span class="gu">@@ -542,10 +963,76 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            Returns self.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def refline(self, *, x=None, y=None, color=&#39;.5&#39;, linestyle=&#39;--&#39;, **line_kws</span>
<span class="gd">-        ):</span>
<span class="gi">+        args = dict(row_var=self._row_var, col_var=self._col_var)</span>
<span class="gi">+        kwargs[&quot;size&quot;] = kwargs.pop(&quot;size&quot;, mpl.rcParams[&quot;axes.labelsize&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        # Establish default templates</span>
<span class="gi">+        if row_template is None:</span>
<span class="gi">+            row_template = &quot;{row_var} = {row_name}&quot;</span>
<span class="gi">+        if col_template is None:</span>
<span class="gi">+            col_template = &quot;{col_var} = {col_name}&quot;</span>
<span class="gi">+        if template is None:</span>
<span class="gi">+            if self._row_var is None:</span>
<span class="gi">+                template = col_template</span>
<span class="gi">+            elif self._col_var is None:</span>
<span class="gi">+                template = row_template</span>
<span class="gi">+            else:</span>
<span class="gi">+                template = &quot; | &quot;.join([row_template, col_template])</span>
<span class="gi">+</span>
<span class="gi">+        row_template = utils.to_utf8(row_template)</span>
<span class="gi">+        col_template = utils.to_utf8(col_template)</span>
<span class="gi">+        template = utils.to_utf8(template)</span>
<span class="gi">+</span>
<span class="gi">+        if self._margin_titles:</span>
<span class="gi">+</span>
<span class="gi">+            # Remove any existing title texts</span>
<span class="gi">+            for text in self._margin_titles_texts:</span>
<span class="gi">+                text.remove()</span>
<span class="gi">+            self._margin_titles_texts = []</span>
<span class="gi">+</span>
<span class="gi">+            if self.row_names is not None:</span>
<span class="gi">+                # Draw the row titles on the right edge of the grid</span>
<span class="gi">+                for i, row_name in enumerate(self.row_names):</span>
<span class="gi">+                    ax = self.axes[i, -1]</span>
<span class="gi">+                    args.update(dict(row_name=row_name))</span>
<span class="gi">+                    title = row_template.format(**args)</span>
<span class="gi">+                    text = ax.annotate(</span>
<span class="gi">+                        title, xy=(1.02, .5), xycoords=&quot;axes fraction&quot;,</span>
<span class="gi">+                        rotation=270, ha=&quot;left&quot;, va=&quot;center&quot;,</span>
<span class="gi">+                        **kwargs</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self._margin_titles_texts.append(text)</span>
<span class="gi">+</span>
<span class="gi">+            if self.col_names is not None:</span>
<span class="gi">+                # Draw the column titles  as normal titles</span>
<span class="gi">+                for j, col_name in enumerate(self.col_names):</span>
<span class="gi">+                    args.update(dict(col_name=col_name))</span>
<span class="gi">+                    title = col_template.format(**args)</span>
<span class="gi">+                    self.axes[0, j].set_title(title, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise title each facet with all the necessary information</span>
<span class="gi">+        if (self._row_var is not None) and (self._col_var is not None):</span>
<span class="gi">+            for i, row_name in enumerate(self.row_names):</span>
<span class="gi">+                for j, col_name in enumerate(self.col_names):</span>
<span class="gi">+                    args.update(dict(row_name=row_name, col_name=col_name))</span>
<span class="gi">+                    title = template.format(**args)</span>
<span class="gi">+                    self.axes[i, j].set_title(title, **kwargs)</span>
<span class="gi">+        elif self.row_names is not None and len(self.row_names):</span>
<span class="gi">+            for i, row_name in enumerate(self.row_names):</span>
<span class="gi">+                args.update(dict(row_name=row_name))</span>
<span class="gi">+                title = template.format(**args)</span>
<span class="gi">+                self.axes[i, 0].set_title(title, **kwargs)</span>
<span class="gi">+        elif self.col_names is not None and len(self.col_names):</span>
<span class="gi">+            for i, col_name in enumerate(self.col_names):</span>
<span class="gi">+                args.update(dict(col_name=col_name))</span>
<span class="gi">+                title = template.format(**args)</span>
<span class="gi">+                # Index the flat array so col_wrap works</span>
<span class="gi">+                self.axes.flat[i].set_title(title, **kwargs)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def refline(self, *, x=None, y=None, color=&#39;.5&#39;, linestyle=&#39;--&#39;, **line_kws):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a reference line(s) to each facet.

<span class="w"> </span>        Parameters
<span class="gu">@@ -568,17 +1055,34 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line_kws[&#39;color&#39;] = color</span>
<span class="gi">+        line_kws[&#39;linestyle&#39;] = linestyle</span>
<span class="gi">+</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            self.map(plt.axvline, x=x, **line_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if y is not None:</span>
<span class="gi">+            self.map(plt.axhline, y=y, **line_kws)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    # ------ Properties that are part of the public API and documented by Sphinx</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def axes(self):
<span class="w"> </span>        &quot;&quot;&quot;An array of the :class:`matplotlib.axes.Axes` objects in the grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._axes</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def ax(self):
<span class="w"> </span>        &quot;&quot;&quot;The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.axes.shape == (1, 1):</span>
<span class="gi">+            return self.axes[0, 0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            err = (</span>
<span class="gi">+                &quot;Use the `.axes` attribute when facet variables are assigned.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise AttributeError(err)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def axes_dict(self):
<span class="gu">@@ -589,32 +1093,85 @@ class FacetGrid(Grid):</span>
<span class="w"> </span>        assigned, each key is a ``({row_level}, {col_level})`` tuple.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._axes_dict</span>
<span class="gi">+</span>
<span class="gi">+    # ------ Private properties, that require some computation to get</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _inner_axes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a flat array of the inner axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._col_wrap is None:</span>
<span class="gi">+            return self.axes[:-1, 1:].flat</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes = []</span>
<span class="gi">+            n_empty = self._nrow * self._ncol - self._n_facets</span>
<span class="gi">+            for i, ax in enumerate(self.axes):</span>
<span class="gi">+                append = (</span>
<span class="gi">+                    i % self._ncol</span>
<span class="gi">+                    and i &lt; (self._ncol * (self._nrow - 1))</span>
<span class="gi">+                    and i &lt; (self._ncol * (self._nrow - 1) - n_empty)</span>
<span class="gi">+                )</span>
<span class="gi">+                if append:</span>
<span class="gi">+                    axes.append(ax)</span>
<span class="gi">+            return np.array(axes, object).flat</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _left_axes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a flat array of the left column of axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._col_wrap is None:</span>
<span class="gi">+            return self.axes[:, 0].flat</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes = []</span>
<span class="gi">+            for i, ax in enumerate(self.axes):</span>
<span class="gi">+                if not i % self._ncol:</span>
<span class="gi">+                    axes.append(ax)</span>
<span class="gi">+            return np.array(axes, object).flat</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _not_left_axes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a flat array of axes that aren&#39;t on the left column.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._col_wrap is None:</span>
<span class="gi">+            return self.axes[:, 1:].flat</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes = []</span>
<span class="gi">+            for i, ax in enumerate(self.axes):</span>
<span class="gi">+                if i % self._ncol:</span>
<span class="gi">+                    axes.append(ax)</span>
<span class="gi">+            return np.array(axes, object).flat</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _bottom_axes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a flat array of the bottom row of axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._col_wrap is None:</span>
<span class="gi">+            return self.axes[-1, :].flat</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes = []</span>
<span class="gi">+            n_empty = self._nrow * self._ncol - self._n_facets</span>
<span class="gi">+            for i, ax in enumerate(self.axes):</span>
<span class="gi">+                append = (</span>
<span class="gi">+                    i &gt;= (self._ncol * (self._nrow - 1))</span>
<span class="gi">+                    or i &gt;= (self._ncol * (self._nrow - 1) - n_empty)</span>
<span class="gi">+                )</span>
<span class="gi">+                if append:</span>
<span class="gi">+                    axes.append(ax)</span>
<span class="gi">+            return np.array(axes, object).flat</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _not_bottom_axes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a flat array of axes that aren&#39;t on the bottom row.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._col_wrap is None:</span>
<span class="gi">+            return self.axes[:-1, :].flat</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes = []</span>
<span class="gi">+            n_empty = self._nrow * self._ncol - self._n_facets</span>
<span class="gi">+            for i, ax in enumerate(self.axes):</span>
<span class="gi">+                append = (</span>
<span class="gi">+                    i &lt; (self._ncol * (self._nrow - 1))</span>
<span class="gi">+                    and i &lt; (self._ncol * (self._nrow - 1) - n_empty)</span>
<span class="gi">+                )</span>
<span class="gi">+                if append:</span>
<span class="gi">+                    axes.append(ax)</span>
<span class="gi">+            return np.array(axes, object).flat</span>


<span class="w"> </span>class PairGrid(Grid):
<span class="gu">@@ -631,11 +1188,11 @@ class PairGrid(Grid):</span>
<span class="w"> </span>    See the :ref:`tutorial &lt;grid_tutorial&gt;` for more information.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, data, *, hue=None, vars=None, x_vars=None, y_vars=</span>
<span class="gd">-        None, hue_order=None, palette=None, hue_kws=None, corner=False,</span>
<span class="gd">-        diag_sharey=True, height=2.5, aspect=1, layout_pad=0.5, despine=</span>
<span class="gd">-        True, dropna=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,</span>
<span class="gi">+        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,</span>
<span class="gi">+        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the plot figure and PairGrid object.

<span class="w"> </span>        Parameters
<span class="gu">@@ -686,8 +1243,11 @@ class PairGrid(Grid):</span>
<span class="w"> </span>        .. include:: ../docstrings/PairGrid.rst

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        data = handle_data_source(data)
<span class="gi">+</span>
<span class="gi">+        # Sort out the variables that define the grid</span>
<span class="w"> </span>        numeric_cols = self._find_numeric_cols(data)
<span class="w"> </span>        if hue in numeric_cols:
<span class="w"> </span>            numeric_cols.remove(hue)
<span class="gu">@@ -698,52 +1258,88 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            x_vars = numeric_cols
<span class="w"> </span>        if y_vars is None:
<span class="w"> </span>            y_vars = numeric_cols
<span class="gi">+</span>
<span class="w"> </span>        if np.isscalar(x_vars):
<span class="w"> </span>            x_vars = [x_vars]
<span class="w"> </span>        if np.isscalar(y_vars):
<span class="w"> </span>            y_vars = [y_vars]
<span class="gi">+</span>
<span class="w"> </span>        self.x_vars = x_vars = list(x_vars)
<span class="w"> </span>        self.y_vars = y_vars = list(y_vars)
<span class="w"> </span>        self.square_grid = self.x_vars == self.y_vars
<span class="gi">+</span>
<span class="w"> </span>        if not x_vars:
<span class="gd">-            raise ValueError(&#39;No variables found for grid columns.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;No variables found for grid columns.&quot;)</span>
<span class="w"> </span>        if not y_vars:
<span class="gd">-            raise ValueError(&#39;No variables found for grid rows.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;No variables found for grid rows.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Create the figure and the array of subplots</span>
<span class="w"> </span>        figsize = len(x_vars) * height * aspect, len(y_vars) * height
<span class="gi">+</span>
<span class="w"> </span>        with _disable_autolayout():
<span class="w"> </span>            fig = plt.figure(figsize=figsize)
<span class="gd">-        axes = fig.subplots(len(y_vars), len(x_vars), sharex=&#39;col&#39;, sharey=</span>
<span class="gd">-            &#39;row&#39;, squeeze=False)</span>
<span class="gi">+</span>
<span class="gi">+        axes = fig.subplots(len(y_vars), len(x_vars),</span>
<span class="gi">+                            sharex=&quot;col&quot;, sharey=&quot;row&quot;,</span>
<span class="gi">+                            squeeze=False)</span>
<span class="gi">+</span>
<span class="gi">+        # Possibly remove upper axes to make a corner grid</span>
<span class="gi">+        # Note: setting up the axes is usually the most time-intensive part</span>
<span class="gi">+        # of using the PairGrid. We are foregoing the speed improvement that</span>
<span class="gi">+        # we would get by just not setting up the hidden axes so that we can</span>
<span class="gi">+        # avoid implementing fig.subplots ourselves. But worth thinking about.</span>
<span class="w"> </span>        self._corner = corner
<span class="w"> </span>        if corner:
<span class="w"> </span>            hide_indices = np.triu_indices_from(axes, 1)
<span class="w"> </span>            for i, j in zip(*hide_indices):
<span class="w"> </span>                axes[i, j].remove()
<span class="w"> </span>                axes[i, j] = None
<span class="gi">+</span>
<span class="w"> </span>        self._figure = fig
<span class="w"> </span>        self.axes = axes
<span class="w"> </span>        self.data = data
<span class="gi">+</span>
<span class="gi">+        # Save what we are going to do with the diagonal</span>
<span class="w"> </span>        self.diag_sharey = diag_sharey
<span class="w"> </span>        self.diag_vars = None
<span class="w"> </span>        self.diag_axes = None
<span class="gi">+</span>
<span class="w"> </span>        self._dropna = dropna
<span class="gi">+</span>
<span class="gi">+        # Label the axes</span>
<span class="w"> </span>        self._add_axis_labels()
<span class="gi">+</span>
<span class="gi">+        # Sort out the hue variable</span>
<span class="w"> </span>        self._hue_var = hue
<span class="w"> </span>        if hue is None:
<span class="gd">-            self.hue_names = hue_order = [&#39;_nolegend_&#39;]</span>
<span class="gd">-            self.hue_vals = pd.Series([&#39;_nolegend_&#39;] * len(data), index=</span>
<span class="gd">-                data.index)</span>
<span class="gi">+            self.hue_names = hue_order = [&quot;_nolegend_&quot;]</span>
<span class="gi">+            self.hue_vals = pd.Series([&quot;_nolegend_&quot;] * len(data),</span>
<span class="gi">+                                      index=data.index)</span>
<span class="w"> </span>        else:
<span class="gi">+            # We need hue_order and hue_names because the former is used to control</span>
<span class="gi">+            # the order of drawing and the latter is used to control the order of</span>
<span class="gi">+            # the legend. hue_names can become string-typed while hue_order must</span>
<span class="gi">+            # retain the type of the input data. This is messy but results from</span>
<span class="gi">+            # the fact that PairGrid can implement the hue-mapping logic itself</span>
<span class="gi">+            # (and was originally written exclusively that way) but now can delegate</span>
<span class="gi">+            # to the axes-level functions, while always handling legend creation.</span>
<span class="gi">+            # See GH2307</span>
<span class="w"> </span>            hue_names = hue_order = categorical_order(data[hue], hue_order)
<span class="w"> </span>            if dropna:
<span class="gi">+                # Filter NA from the list of unique hue names</span>
<span class="w"> </span>                hue_names = list(filter(pd.notnull, hue_names))
<span class="w"> </span>            self.hue_names = hue_names
<span class="w"> </span>            self.hue_vals = data[hue]
<span class="gi">+</span>
<span class="gi">+        # Additional dict of kwarg -&gt; list of values for mapping the hue var</span>
<span class="w"> </span>        self.hue_kws = hue_kws if hue_kws is not None else {}
<span class="gi">+</span>
<span class="w"> </span>        self._orig_palette = palette
<span class="w"> </span>        self._hue_order = hue_order
<span class="w"> </span>        self.palette = self._get_palette(data, hue, hue_order, palette)
<span class="w"> </span>        self._legend_data = {}
<span class="gi">+</span>
<span class="gi">+        # Make the plot look nice</span>
<span class="w"> </span>        for ax in axes[:-1, :].flat:
<span class="w"> </span>            if ax is None:
<span class="w"> </span>                continue
<span class="gu">@@ -751,6 +1347,7 @@ class PairGrid(Grid):</span>
<span class="w"> </span>                label.set_visible(False)
<span class="w"> </span>            ax.xaxis.offsetText.set_visible(False)
<span class="w"> </span>            ax.xaxis.label.set_visible(False)
<span class="gi">+</span>
<span class="w"> </span>        for ax in axes[:, 1:].flat:
<span class="w"> </span>            if ax is None:
<span class="w"> </span>                continue
<span class="gu">@@ -758,7 +1355,8 @@ class PairGrid(Grid):</span>
<span class="w"> </span>                label.set_visible(False)
<span class="w"> </span>            ax.yaxis.offsetText.set_visible(False)
<span class="w"> </span>            ax.yaxis.label.set_visible(False)
<span class="gd">-        self._tight_layout_rect = [0.01, 0.01, 0.99, 0.99]</span>
<span class="gi">+</span>
<span class="gi">+        self._tight_layout_rect = [.01, .01, .99, .99]</span>
<span class="w"> </span>        self._tight_layout_pad = layout_pad
<span class="w"> </span>        self._despine = despine
<span class="w"> </span>        if despine:
<span class="gu">@@ -776,7 +1374,11 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            called ``color`` and  ``label``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        row_indices, col_indices = np.indices(self.axes.shape)</span>
<span class="gi">+        indices = zip(row_indices.flat, col_indices.flat)</span>
<span class="gi">+        self._map_bivariate(func, indices, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def map_lower(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Plot with a bivariate function on the lower diagonal subplots.
<span class="gu">@@ -789,7 +1391,9 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            called ``color`` and  ``label``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indices = zip(*np.tril_indices_from(self.axes, -1))</span>
<span class="gi">+        self._map_bivariate(func, indices, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def map_upper(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Plot with a bivariate function on the upper diagonal subplots.
<span class="gu">@@ -802,7 +1406,9 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            called ``color`` and  ``label``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indices = zip(*np.triu_indices_from(self.axes, 1))</span>
<span class="gi">+        self._map_bivariate(func, indices, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def map_offdiag(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Plot with a bivariate function on the off-diagonal subplots.
<span class="gu">@@ -815,7 +1421,18 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            called ``color`` and  ``label``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.square_grid:</span>
<span class="gi">+            self.map_lower(func, **kwargs)</span>
<span class="gi">+            if not self._corner:</span>
<span class="gi">+                self.map_upper(func, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            indices = []</span>
<span class="gi">+            for i, (y_var) in enumerate(self.y_vars):</span>
<span class="gi">+                for j, (x_var) in enumerate(self.x_vars):</span>
<span class="gi">+                    if x_var != y_var:</span>
<span class="gi">+                        indices.append((i, j))</span>
<span class="gi">+            self._map_bivariate(func, indices, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def map_diag(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Plot with a univariate function on each diagonal subplot.
<span class="gu">@@ -828,31 +1445,235 @@ class PairGrid(Grid):</span>
<span class="w"> </span>            called ``color`` and  ``label``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Add special diagonal axes for the univariate plot</span>
<span class="gi">+        if self.diag_axes is None:</span>
<span class="gi">+            diag_vars = []</span>
<span class="gi">+            diag_axes = []</span>
<span class="gi">+            for i, y_var in enumerate(self.y_vars):</span>
<span class="gi">+                for j, x_var in enumerate(self.x_vars):</span>
<span class="gi">+                    if x_var == y_var:</span>
<span class="gi">+</span>
<span class="gi">+                        # Make the density axes</span>
<span class="gi">+                        diag_vars.append(x_var)</span>
<span class="gi">+                        ax = self.axes[i, j]</span>
<span class="gi">+                        diag_ax = ax.twinx()</span>
<span class="gi">+                        diag_ax.set_axis_off()</span>
<span class="gi">+                        diag_axes.append(diag_ax)</span>
<span class="gi">+</span>
<span class="gi">+                        # Work around matplotlib bug</span>
<span class="gi">+                        # https://github.com/matplotlib/matplotlib/issues/15188</span>
<span class="gi">+                        if not plt.rcParams.get(&quot;ytick.left&quot;, True):</span>
<span class="gi">+                            for tick in ax.yaxis.majorTicks:</span>
<span class="gi">+                                tick.tick1line.set_visible(False)</span>
<span class="gi">+</span>
<span class="gi">+                        # Remove main y axis from density axes in a corner plot</span>
<span class="gi">+                        if self._corner:</span>
<span class="gi">+                            ax.yaxis.set_visible(False)</span>
<span class="gi">+                            if self._despine:</span>
<span class="gi">+                                utils.despine(ax=ax, left=True)</span>
<span class="gi">+                            # TODO add optional density ticks (on the right)</span>
<span class="gi">+                            # when drawing a corner plot?</span>
<span class="gi">+</span>
<span class="gi">+            if self.diag_sharey and diag_axes:</span>
<span class="gi">+                for ax in diag_axes[1:]:</span>
<span class="gi">+                    share_axis(diag_axes[0], ax, &quot;y&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.diag_vars = diag_vars</span>
<span class="gi">+            self.diag_axes = diag_axes</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; not in signature(func).parameters:</span>
<span class="gi">+            return self._map_diag_iter_hue(func, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Loop over diagonal variables and axes, making one plot in each</span>
<span class="gi">+        for var, ax in zip(self.diag_vars, self.diag_axes):</span>
<span class="gi">+</span>
<span class="gi">+            plot_kwargs = kwargs.copy()</span>
<span class="gi">+            if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+                plot_kwargs[&quot;ax&quot;] = ax</span>
<span class="gi">+            else:</span>
<span class="gi">+                plt.sca(ax)</span>
<span class="gi">+</span>
<span class="gi">+            vector = self.data[var]</span>
<span class="gi">+            if self._hue_var is not None:</span>
<span class="gi">+                hue = self.data[self._hue_var]</span>
<span class="gi">+            else:</span>
<span class="gi">+                hue = None</span>
<span class="gi">+</span>
<span class="gi">+            if self._dropna:</span>
<span class="gi">+                not_na = vector.notna()</span>
<span class="gi">+                if hue is not None:</span>
<span class="gi">+                    not_na &amp;= hue.notna()</span>
<span class="gi">+                vector = vector[not_na]</span>
<span class="gi">+                if hue is not None:</span>
<span class="gi">+                    hue = hue[not_na]</span>
<span class="gi">+</span>
<span class="gi">+            plot_kwargs.setdefault(&quot;hue&quot;, hue)</span>
<span class="gi">+            plot_kwargs.setdefault(&quot;hue_order&quot;, self._hue_order)</span>
<span class="gi">+            plot_kwargs.setdefault(&quot;palette&quot;, self._orig_palette)</span>
<span class="gi">+            func(x=vector, **plot_kwargs)</span>
<span class="gi">+            ax.legend_ = None</span>
<span class="gi">+</span>
<span class="gi">+        self._add_axis_labels()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _map_diag_iter_hue(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Put marginal plot on each diagonal axes, iterating over hue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Plot on each of the diagonal axes</span>
<span class="gi">+        fixed_color = kwargs.pop(&quot;color&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        for var, ax in zip(self.diag_vars, self.diag_axes):</span>
<span class="gi">+            hue_grouped = self.data[var].groupby(self.hue_vals, observed=True)</span>
<span class="gi">+</span>
<span class="gi">+            plot_kwargs = kwargs.copy()</span>
<span class="gi">+            if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+                plot_kwargs[&quot;ax&quot;] = ax</span>
<span class="gi">+            else:</span>
<span class="gi">+                plt.sca(ax)</span>
<span class="gi">+</span>
<span class="gi">+            for k, label_k in enumerate(self._hue_order):</span>
<span class="gi">+</span>
<span class="gi">+                # Attempt to get data for this level, allowing for empty</span>
<span class="gi">+                try:</span>
<span class="gi">+                    data_k = hue_grouped.get_group(label_k)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    data_k = pd.Series([], dtype=float)</span>
<span class="gi">+</span>
<span class="gi">+                if fixed_color is None:</span>
<span class="gi">+                    color = self.palette[k]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    color = fixed_color</span>
<span class="gi">+</span>
<span class="gi">+                if self._dropna:</span>
<span class="gi">+                    data_k = utils.remove_na(data_k)</span>
<span class="gi">+</span>
<span class="gi">+                if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+                    func(x=data_k, label=label_k, color=color, **plot_kwargs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    func(data_k, label=label_k, color=color, **plot_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        self._add_axis_labels()</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _map_bivariate(self, func, indices, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw a bivariate plot on the indicated axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a hack to handle the fact that new distribution plots don&#39;t add</span>
<span class="gi">+        # their artists onto the axes. This is probably superior in general, but</span>
<span class="gi">+        # we&#39;ll need a better way to handle it in the axisgrid functions.</span>
<span class="gi">+        from .distributions import histplot, kdeplot</span>
<span class="gi">+        if func is histplot or func is kdeplot:</span>
<span class="gi">+            self._extract_legend_handles = True</span>
<span class="gi">+</span>
<span class="gi">+        kws = kwargs.copy()  # Use copy as we insert other kwargs</span>
<span class="gi">+        for i, j in indices:</span>
<span class="gi">+            x_var = self.x_vars[j]</span>
<span class="gi">+            y_var = self.y_vars[i]</span>
<span class="gi">+            ax = self.axes[i, j]</span>
<span class="gi">+            if ax is None:  # i.e. we are in corner mode</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._plot_bivariate(x_var, y_var, ax, func, **kws)</span>
<span class="gi">+        self._add_axis_labels()</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in signature(func).parameters:</span>
<span class="gi">+            self.hue_names = list(self._legend_data)</span>

<span class="w"> </span>    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw a bivariate plot on the specified axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;hue&quot; not in signature(func).parameters:</span>
<span class="gi">+            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+            kwargs[&quot;ax&quot;] = ax</span>
<span class="gi">+        else:</span>
<span class="gi">+            plt.sca(ax)</span>
<span class="gi">+</span>
<span class="gi">+        if x_var == y_var:</span>
<span class="gi">+            axes_vars = [x_var]</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes_vars = [x_var, y_var]</span>
<span class="gi">+</span>
<span class="gi">+        if self._hue_var is not None and self._hue_var not in axes_vars:</span>
<span class="gi">+            axes_vars.append(self._hue_var)</span>
<span class="gi">+</span>
<span class="gi">+        data = self.data[axes_vars]</span>
<span class="gi">+        if self._dropna:</span>
<span class="gi">+            data = data.dropna()</span>
<span class="gi">+</span>
<span class="gi">+        x = data[x_var]</span>
<span class="gi">+        y = data[y_var]</span>
<span class="gi">+        if self._hue_var is None:</span>
<span class="gi">+            hue = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            hue = data.get(self._hue_var)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; not in kwargs:</span>
<span class="gi">+            kwargs.update({</span>
<span class="gi">+                &quot;hue&quot;: hue, &quot;hue_order&quot;: self._hue_order, &quot;palette&quot;: self._orig_palette,</span>
<span class="gi">+            })</span>
<span class="gi">+        func(x=x, y=y, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        self._update_legend_data(ax)</span>

<span class="w"> </span>    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw a bivariate plot while iterating over hue subsets.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+            kwargs[&quot;ax&quot;] = ax</span>
<span class="gi">+        else:</span>
<span class="gi">+            plt.sca(ax)</span>
<span class="gi">+</span>
<span class="gi">+        if x_var == y_var:</span>
<span class="gi">+            axes_vars = [x_var]</span>
<span class="gi">+        else:</span>
<span class="gi">+            axes_vars = [x_var, y_var]</span>
<span class="gi">+</span>
<span class="gi">+        hue_grouped = self.data.groupby(self.hue_vals, observed=True)</span>
<span class="gi">+        for k, label_k in enumerate(self._hue_order):</span>
<span class="gi">+</span>
<span class="gi">+            kws = kwargs.copy()</span>
<span class="gi">+</span>
<span class="gi">+            # Attempt to get data for this level, allowing for empty</span>
<span class="gi">+            try:</span>
<span class="gi">+                data_k = hue_grouped.get_group(label_k)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                data_k = pd.DataFrame(columns=axes_vars,</span>
<span class="gi">+                                      dtype=float)</span>
<span class="gi">+</span>
<span class="gi">+            if self._dropna:</span>
<span class="gi">+                data_k = data_k[axes_vars].dropna()</span>
<span class="gi">+</span>
<span class="gi">+            x = data_k[x_var]</span>
<span class="gi">+            y = data_k[y_var]</span>
<span class="gi">+</span>
<span class="gi">+            for kw, val_list in self.hue_kws.items():</span>
<span class="gi">+                kws[kw] = val_list[k]</span>
<span class="gi">+            kws.setdefault(&quot;color&quot;, self.palette[k])</span>
<span class="gi">+            if self._hue_var is not None:</span>
<span class="gi">+                kws[&quot;label&quot;] = label_k</span>
<span class="gi">+</span>
<span class="gi">+            if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+                func(x=x, y=y, **kws)</span>
<span class="gi">+            else:</span>
<span class="gi">+                func(x, y, **kws)</span>
<span class="gi">+</span>
<span class="gi">+        self._update_legend_data(ax)</span>

<span class="w"> </span>    def _add_axis_labels(self):
<span class="w"> </span>        &quot;&quot;&quot;Add labels to the left and bottom Axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for ax, label in zip(self.axes[-1, :], self.x_vars):</span>
<span class="gi">+            ax.set_xlabel(label)</span>
<span class="gi">+        for ax, label in zip(self.axes[:, 0], self.y_vars):</span>
<span class="gi">+            ax.set_ylabel(label)</span>

<span class="w"> </span>    def _find_numeric_cols(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Find which variables in a DataFrame are numeric.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        numeric_cols = []</span>
<span class="gi">+        for col in data:</span>
<span class="gi">+            if variable_type(data[col]) == &quot;numeric&quot;:</span>
<span class="gi">+                numeric_cols.append(col)</span>
<span class="gi">+        return numeric_cols</span>


<span class="w"> </span>class JointGrid(_BaseGrid):
<span class="gu">@@ -863,22 +1684,34 @@ class JointGrid(_BaseGrid):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, data=None, *, x=None, y=None, hue=None, height=6,</span>
<span class="gd">-        ratio=5, space=0.2, palette=None, hue_order=None, hue_norm=None,</span>
<span class="gd">-        dropna=False, xlim=None, ylim=None, marginal_ticks=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, data=None, *,</span>
<span class="gi">+        x=None, y=None, hue=None,</span>
<span class="gi">+        height=6, ratio=5, space=.2,</span>
<span class="gi">+        palette=None, hue_order=None, hue_norm=None,</span>
<span class="gi">+        dropna=False, xlim=None, ylim=None, marginal_ticks=False,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # Set up the subplot grid</span>
<span class="w"> </span>        f = plt.figure(figsize=(height, height))
<span class="w"> </span>        gs = plt.GridSpec(ratio + 1, ratio + 1)
<span class="gi">+</span>
<span class="w"> </span>        ax_joint = f.add_subplot(gs[1:, :-1])
<span class="w"> </span>        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)
<span class="w"> </span>        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)
<span class="gi">+</span>
<span class="w"> </span>        self._figure = f
<span class="w"> </span>        self.ax_joint = ax_joint
<span class="w"> </span>        self.ax_marg_x = ax_marg_x
<span class="w"> </span>        self.ax_marg_y = ax_marg_y
<span class="gi">+</span>
<span class="gi">+        # Turn off tick visibility for the measure axis on the marginal plots</span>
<span class="w"> </span>        plt.setp(ax_marg_x.get_xticklabels(), visible=False)
<span class="w"> </span>        plt.setp(ax_marg_y.get_yticklabels(), visible=False)
<span class="w"> </span>        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)
<span class="w"> </span>        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)
<span class="gi">+</span>
<span class="gi">+        # Turn off the ticks on the density axis for the marginal plots</span>
<span class="w"> </span>        if not marginal_ticks:
<span class="w"> </span>            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)
<span class="w"> </span>            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)
<span class="gu">@@ -890,8 +1723,12 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)
<span class="w"> </span>            ax_marg_x.yaxis.grid(False)
<span class="w"> </span>            ax_marg_y.xaxis.grid(False)
<span class="gi">+</span>
<span class="gi">+        # Process the input variables</span>
<span class="w"> </span>        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))
<span class="w"> </span>        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]
<span class="gi">+</span>
<span class="gi">+        # Possibly drop NA</span>
<span class="w"> </span>        if dropna:
<span class="w"> </span>            plot_data = plot_data.dropna()

<span class="gu">@@ -900,19 +1737,25 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            if vector is not None:
<span class="w"> </span>                vector = vector.rename(p.variables.get(var, None))
<span class="w"> </span>            return vector
<span class="gd">-        self.x = get_var(&#39;x&#39;)</span>
<span class="gd">-        self.y = get_var(&#39;y&#39;)</span>
<span class="gd">-        self.hue = get_var(&#39;hue&#39;)</span>
<span class="gd">-        for axis in &#39;xy&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        self.x = get_var(&quot;x&quot;)</span>
<span class="gi">+        self.y = get_var(&quot;y&quot;)</span>
<span class="gi">+        self.hue = get_var(&quot;hue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for axis in &quot;xy&quot;:</span>
<span class="w"> </span>            name = p.variables.get(axis, None)
<span class="w"> </span>            if name is not None:
<span class="gd">-                getattr(ax_joint, f&#39;set_{axis}label&#39;)(name)</span>
<span class="gi">+                getattr(ax_joint, f&quot;set_{axis}label&quot;)(name)</span>
<span class="gi">+</span>
<span class="w"> </span>        if xlim is not None:
<span class="w"> </span>            ax_joint.set_xlim(xlim)
<span class="w"> </span>        if ylim is not None:
<span class="w"> </span>            ax_joint.set_ylim(ylim)
<span class="gd">-        self._hue_params = dict(palette=palette, hue_order=hue_order,</span>
<span class="gd">-            hue_norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+        # Store the semantic mapping parameters for axes-level functions</span>
<span class="gi">+        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+        # Make the grid look nice</span>
<span class="w"> </span>        utils.despine(f)
<span class="w"> </span>        if not marginal_ticks:
<span class="w"> </span>            utils.despine(ax=ax_marg_x, left=True)
<span class="gu">@@ -925,7 +1768,10 @@ class JointGrid(_BaseGrid):</span>

<span class="w"> </span>    def _inject_kwargs(self, func, kws, params):
<span class="w"> </span>        &quot;&quot;&quot;Add params to kws if they are accepted by func.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        func_params = signature(func).parameters</span>
<span class="gi">+        for key, val in params.items():</span>
<span class="gi">+            if key in func_params:</span>
<span class="gi">+                kws.setdefault(key, val)</span>

<span class="w"> </span>    def plot(self, joint_func, marginal_func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw the plot by passing functions for joint and marginal axes.
<span class="gu">@@ -949,7 +1795,9 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.plot_marginals(marginal_func, **kwargs)</span>
<span class="gi">+        self.plot_joint(joint_func, **kwargs)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def plot_joint(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw a bivariate plot on the joint axes of the grid.
<span class="gu">@@ -971,7 +1819,21 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+            kwargs[&quot;ax&quot;] = self.ax_joint</span>
<span class="gi">+        else:</span>
<span class="gi">+            plt.sca(self.ax_joint)</span>
<span class="gi">+        if self.hue is not None:</span>
<span class="gi">+            kwargs[&quot;hue&quot;] = self.hue</span>
<span class="gi">+            self._inject_kwargs(func, kwargs, self._hue_params)</span>
<span class="gi">+</span>
<span class="gi">+        if str(func.__module__).startswith(&quot;seaborn&quot;):</span>
<span class="gi">+            func(x=self.x, y=self.y, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            func(self.x, self.y, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def plot_marginals(self, func, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Draw univariate plots on each marginal axes.
<span class="gu">@@ -994,10 +1856,50 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        seaborn_func = (</span>
<span class="gi">+            str(func.__module__).startswith(&quot;seaborn&quot;)</span>
<span class="gi">+            # deprecated distplot has a legacy API, special case it</span>
<span class="gi">+            and not func.__name__ == &quot;distplot&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        func_params = signature(func).parameters</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        if self.hue is not None:</span>
<span class="gi">+            kwargs[&quot;hue&quot;] = self.hue</span>
<span class="gi">+            self._inject_kwargs(func, kwargs, self._hue_params)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;legend&quot; in func_params:</span>
<span class="gi">+            kwargs.setdefault(&quot;legend&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;orientation&quot; in func_params:</span>
<span class="gi">+            # e.g. plt.hist</span>
<span class="gi">+            orient_kw_x = {&quot;orientation&quot;: &quot;vertical&quot;}</span>
<span class="gi">+            orient_kw_y = {&quot;orientation&quot;: &quot;horizontal&quot;}</span>
<span class="gi">+        elif &quot;vertical&quot; in func_params:</span>
<span class="gi">+            # e.g. sns.distplot (also how did this get backwards?)</span>
<span class="gi">+            orient_kw_x = {&quot;vertical&quot;: False}</span>
<span class="gi">+            orient_kw_y = {&quot;vertical&quot;: True}</span>
<span class="gi">+</span>
<span class="gi">+        if seaborn_func:</span>
<span class="gi">+            func(x=self.x, ax=self.ax_marg_x, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            plt.sca(self.ax_marg_x)</span>
<span class="gi">+            func(self.x, **orient_kw_x, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if seaborn_func:</span>
<span class="gi">+            func(y=self.y, ax=self.ax_marg_y, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            plt.sca(self.ax_marg_y)</span>
<span class="gi">+            func(self.y, **orient_kw_y, **kwargs)</span>

<span class="gd">-    def refline(self, *, x=None, y=None, joint=True, marginal=True, color=</span>
<span class="gd">-        &#39;.5&#39;, linestyle=&#39;--&#39;, **line_kws):</span>
<span class="gi">+        self.ax_marg_x.yaxis.get_label().set_visible(False)</span>
<span class="gi">+        self.ax_marg_y.xaxis.get_label().set_visible(False)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def refline(</span>
<span class="gi">+        self, *, x=None, y=None, joint=True, marginal=True,</span>
<span class="gi">+        color=&#39;.5&#39;, linestyle=&#39;--&#39;, **line_kws</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a reference line(s) to joint and/or marginal axes.

<span class="w"> </span>        Parameters
<span class="gu">@@ -1021,9 +1923,24 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line_kws[&#39;color&#39;] = color</span>
<span class="gi">+        line_kws[&#39;linestyle&#39;] = linestyle</span>
<span class="gi">+</span>
<span class="gi">+        if x is not None:</span>
<span class="gi">+            if joint:</span>
<span class="gi">+                self.ax_joint.axvline(x, **line_kws)</span>
<span class="gi">+            if marginal:</span>
<span class="gi">+                self.ax_marg_x.axvline(x, **line_kws)</span>

<span class="gd">-    def set_axis_labels(self, xlabel=&#39;&#39;, ylabel=&#39;&#39;, **kwargs):</span>
<span class="gi">+        if y is not None:</span>
<span class="gi">+            if joint:</span>
<span class="gi">+                self.ax_joint.axhline(y, **line_kws)</span>
<span class="gi">+            if marginal:</span>
<span class="gi">+                self.ax_marg_y.axhline(y, **line_kws)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def set_axis_labels(self, xlabel=&quot;&quot;, ylabel=&quot;&quot;, **kwargs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Set axis labels on the bivariate axes.

<span class="w"> </span>        Parameters
<span class="gu">@@ -1042,11 +1959,13 @@ class JointGrid(_BaseGrid):</span>
<span class="w"> </span>            Returns ``self`` for easy method chaining.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ax_joint.set_xlabel(xlabel, **kwargs)</span>
<span class="gi">+        self.ax_joint.set_ylabel(ylabel, **kwargs)</span>
<span class="gi">+        return self</span>


<span class="gd">-JointGrid.__init__.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Set up the grid of subplots and store data internally for easy plotting.</span>
<span class="gi">+JointGrid.__init__.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Set up the grid of subplots and store data internally for easy plotting.</span>

<span class="w"> </span>Parameters
<span class="w"> </span>----------
<span class="gu">@@ -1082,14 +2001,20 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/JointGrid.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, seealso=_core_docs[&#39;seealso&#39;]))</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>


<span class="gd">-def pairplot(data, *, hue=None, hue_order=None, palette=None, vars=None,</span>
<span class="gd">-    x_vars=None, y_vars=None, kind=&#39;scatter&#39;, diag_kind=&#39;auto&#39;, markers=</span>
<span class="gd">-    None, height=2.5, aspect=1, corner=False, dropna=False, plot_kws=None,</span>
<span class="gd">-    diag_kws=None, grid_kws=None, size=None):</span>
<span class="gi">+def pairplot(</span>
<span class="gi">+    data, *,</span>
<span class="gi">+    hue=None, hue_order=None, palette=None,</span>
<span class="gi">+    vars=None, x_vars=None, y_vars=None,</span>
<span class="gi">+    kind=&quot;scatter&quot;, diag_kind=&quot;auto&quot;, markers=None,</span>
<span class="gi">+    height=2.5, aspect=1, corner=False, dropna=False,</span>
<span class="gi">+    plot_kws=None, diag_kws=None, grid_kws=None, size=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Plot pairwise relationships in a dataset.

<span class="w"> </span>    By default, this function will create a grid of Axes such that each numeric
<span class="gu">@@ -1164,11 +2089,260 @@ def pairplot(data, *, hue=None, hue_order=None, palette=None, vars=None,</span>
<span class="w"> </span>    .. include:: ../docstrings/pairplot.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Avoid circular import</span>
<span class="gi">+    from .distributions import histplot, kdeplot</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecations</span>
<span class="gi">+    if size is not None:</span>
<span class="gi">+        height = size</span>
<span class="gi">+        msg = (&quot;The `size` parameter has been renamed to `height`; &quot;</span>
<span class="gi">+               &quot;please update your code.&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(data, pd.DataFrame):</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            f&quot;&#39;data&#39; must be pandas DataFrame object, not: {type(data)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    plot_kws = {} if plot_kws is None else plot_kws.copy()</span>
<span class="gi">+    diag_kws = {} if diag_kws is None else diag_kws.copy()</span>
<span class="gi">+    grid_kws = {} if grid_kws is None else grid_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Resolve &quot;auto&quot; diag kind</span>
<span class="gi">+    if diag_kind == &quot;auto&quot;:</span>
<span class="gi">+        if hue is None:</span>
<span class="gi">+            diag_kind = &quot;kde&quot; if kind == &quot;kde&quot; else &quot;hist&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            diag_kind = &quot;hist&quot; if kind == &quot;hist&quot; else &quot;kde&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Set up the PairGrid</span>
<span class="gi">+    grid_kws.setdefault(&quot;diag_sharey&quot;, diag_kind == &quot;hist&quot;)</span>
<span class="gi">+    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,</span>
<span class="gi">+                    hue_order=hue_order, palette=palette, corner=corner,</span>
<span class="gi">+                    height=height, aspect=aspect, dropna=dropna, **grid_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Add the markers here as PairGrid has figured out how many levels of the</span>
<span class="gi">+    # hue variable are needed and we don&#39;t want to duplicate that process</span>
<span class="gi">+    if markers is not None:</span>
<span class="gi">+        if kind == &quot;reg&quot;:</span>
<span class="gi">+            # Needed until regplot supports style</span>
<span class="gi">+            if grid.hue_names is None:</span>
<span class="gi">+                n_markers = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                n_markers = len(grid.hue_names)</span>
<span class="gi">+            if not isinstance(markers, list):</span>
<span class="gi">+                markers = [markers] * n_markers</span>
<span class="gi">+            if len(markers) != n_markers:</span>
<span class="gi">+                raise ValueError(&quot;markers must be a singleton or a list of &quot;</span>
<span class="gi">+                                 &quot;markers for each level of the hue variable&quot;)</span>
<span class="gi">+            grid.hue_kws = {&quot;marker&quot;: markers}</span>
<span class="gi">+        elif kind == &quot;scatter&quot;:</span>
<span class="gi">+            if isinstance(markers, str):</span>
<span class="gi">+                plot_kws[&quot;marker&quot;] = markers</span>
<span class="gi">+            elif hue is not None:</span>
<span class="gi">+                plot_kws[&quot;style&quot;] = data[hue]</span>
<span class="gi">+                plot_kws[&quot;markers&quot;] = markers</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the marginal plots on the diagonal</span>
<span class="gi">+    diag_kws = diag_kws.copy()</span>
<span class="gi">+    diag_kws.setdefault(&quot;legend&quot;, False)</span>
<span class="gi">+    if diag_kind == &quot;hist&quot;:</span>
<span class="gi">+        grid.map_diag(histplot, **diag_kws)</span>
<span class="gi">+    elif diag_kind == &quot;kde&quot;:</span>
<span class="gi">+        diag_kws.setdefault(&quot;fill&quot;, True)</span>
<span class="gi">+        diag_kws.setdefault(&quot;warn_singular&quot;, False)</span>
<span class="gi">+        grid.map_diag(kdeplot, **diag_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Maybe plot on the off-diagonals</span>
<span class="gi">+    if diag_kind is not None:</span>
<span class="gi">+        plotter = grid.map_offdiag</span>
<span class="gi">+    else:</span>
<span class="gi">+        plotter = grid.map</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;scatter&quot;:</span>
<span class="gi">+        from .relational import scatterplot  # Avoid circular import</span>
<span class="gi">+        plotter(scatterplot, **plot_kws)</span>
<span class="gi">+    elif kind == &quot;reg&quot;:</span>
<span class="gi">+        from .regression import regplot  # Avoid circular import</span>
<span class="gi">+        plotter(regplot, **plot_kws)</span>
<span class="gi">+    elif kind == &quot;kde&quot;:</span>
<span class="gi">+        from .distributions import kdeplot  # Avoid circular import</span>
<span class="gi">+        plot_kws.setdefault(&quot;warn_singular&quot;, False)</span>
<span class="gi">+        plotter(kdeplot, **plot_kws)</span>
<span class="gi">+    elif kind == &quot;hist&quot;:</span>
<span class="gi">+        from .distributions import histplot  # Avoid circular import</span>
<span class="gi">+        plotter(histplot, **plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Add a legend</span>
<span class="gi">+    if hue is not None:</span>
<span class="gi">+        grid.add_legend()</span>
<span class="gi">+</span>
<span class="gi">+    grid.tight_layout()</span>
<span class="gi">+</span>
<span class="gi">+    return grid</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def jointplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, kind=&quot;scatter&quot;,</span>
<span class="gi">+    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,</span>
<span class="gi">+    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,</span>
<span class="gi">+    joint_kws=None, marginal_kws=None,</span>
<span class="gi">+    **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+    # Avoid circular imports</span>
<span class="gi">+    from .relational import scatterplot</span>
<span class="gi">+    from .regression import regplot, residplot</span>
<span class="gi">+    from .distributions import histplot, kdeplot, _freedman_diaconis_bins</span>
<span class="gi">+</span>
<span class="gi">+    if kwargs.pop(&quot;ax&quot;, None) is not None:</span>
<span class="gi">+        msg = &quot;Ignoring `ax`; jointplot is a figure-level function.&quot;</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # Set up empty default kwarg dicts</span>
<span class="gi">+    joint_kws = {} if joint_kws is None else joint_kws.copy()</span>
<span class="gi">+    joint_kws.update(kwargs)</span>
<span class="gi">+    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecations of distplot-specific kwargs</span>
<span class="gi">+    distplot_keys = [</span>
<span class="gi">+        &quot;rug&quot;, &quot;fit&quot;, &quot;hist_kws&quot;, &quot;norm_hist&quot; &quot;hist_kws&quot;, &quot;rug_kws&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    unused_keys = []</span>
<span class="gi">+    for key in distplot_keys:</span>
<span class="gi">+        if key in marginal_kws:</span>
<span class="gi">+            unused_keys.append(key)</span>
<span class="gi">+            marginal_kws.pop(key)</span>
<span class="gi">+    if unused_keys and kind != &quot;kde&quot;:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;The marginal plotting function has changed to `histplot`,&quot;</span>
<span class="gi">+            &quot; which does not accept the following argument(s): {}.&quot;</span>
<span class="gi">+        ).format(&quot;, &quot;.join(unused_keys))</span>
<span class="gi">+        warnings.warn(msg, UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate the plot kind</span>
<span class="gi">+    plot_kinds = [&quot;scatter&quot;, &quot;hist&quot;, &quot;hex&quot;, &quot;kde&quot;, &quot;reg&quot;, &quot;resid&quot;]</span>
<span class="gi">+    _check_argument(&quot;kind&quot;, plot_kinds, kind)</span>
<span class="gi">+</span>
<span class="gi">+    # Raise early if using `hue` with a kind that does not support it</span>
<span class="gi">+    if hue is not None and kind in [&quot;hex&quot;, &quot;reg&quot;, &quot;resid&quot;]:</span>
<span class="gi">+        msg = f&quot;Use of `hue` with `kind=&#39;{kind}&#39;` is not currently supported.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Make a colormap based off the plot color</span>
<span class="gi">+    # (Currently used only for kind=&quot;hex&quot;)</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        color = &quot;C0&quot;</span>
<span class="gi">+    color_rgb = mpl.colors.colorConverter.to_rgb(color)</span>
<span class="gi">+    colors = [set_hls_values(color_rgb, l=val) for val in np.linspace(1, 0, 12)]</span>
<span class="gi">+    cmap = blend_palette(colors, as_cmap=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Matplotlib&#39;s hexbin plot is not na-robust</span>
<span class="gi">+    if kind == &quot;hex&quot;:</span>
<span class="gi">+        dropna = True</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the JointGrid object</span>
<span class="gi">+    grid = JointGrid(</span>
<span class="gi">+        data=data, x=x, y=y, hue=hue,</span>
<span class="gi">+        palette=palette, hue_order=hue_order, hue_norm=hue_norm,</span>
<span class="gi">+        dropna=dropna, height=height, ratio=ratio, space=space,</span>
<span class="gi">+        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if grid.hue is not None:</span>
<span class="gi">+        marginal_kws.setdefault(&quot;legend&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+    # Plot the data using the grid</span>
<span class="gi">+    if kind.startswith(&quot;scatter&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_joint(scatterplot, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if grid.hue is None:</span>
<span class="gi">+            marg_func = histplot</span>
<span class="gi">+        else:</span>
<span class="gi">+            marg_func = kdeplot</span>
<span class="gi">+            marginal_kws.setdefault(&quot;warn_singular&quot;, False)</span>
<span class="gi">+            marginal_kws.setdefault(&quot;fill&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_marginals(marg_func, **marginal_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind.startswith(&quot;hist&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO process pair parameters for bins, etc. and pass</span>
<span class="gi">+        # to both joint and marginal plots</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_joint(histplot, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+        marginal_kws.setdefault(&quot;kde&quot;, False)</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+</span>
<span class="gi">+        marg_x_kws = marginal_kws.copy()</span>
<span class="gi">+        marg_y_kws = marginal_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        pair_keys = &quot;bins&quot;, &quot;binwidth&quot;, &quot;binrange&quot;</span>
<span class="gi">+        for key in pair_keys:</span>
<span class="gi">+            if isinstance(joint_kws.get(key), tuple):</span>
<span class="gi">+                x_val, y_val = joint_kws[key]</span>
<span class="gi">+                marg_x_kws.setdefault(key, x_val)</span>
<span class="gi">+                marg_y_kws.setdefault(key, y_val)</span>
<span class="gi">+</span>
<span class="gi">+        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)</span>
<span class="gi">+        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind.startswith(&quot;kde&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        joint_kws.setdefault(&quot;warn_singular&quot;, False)</span>
<span class="gi">+        grid.plot_joint(kdeplot, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        if &quot;fill&quot; in joint_kws:</span>
<span class="gi">+            marginal_kws.setdefault(&quot;fill&quot;, joint_kws[&quot;fill&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        grid.plot_marginals(kdeplot, **marginal_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind.startswith(&quot;hex&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        x_bins = min(_freedman_diaconis_bins(grid.x), 50)</span>
<span class="gi">+        y_bins = min(_freedman_diaconis_bins(grid.y), 50)</span>
<span class="gi">+        gridsize = int(np.mean([x_bins, y_bins]))</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;gridsize&quot;, gridsize)</span>
<span class="gi">+        joint_kws.setdefault(&quot;cmap&quot;, cmap)</span>
<span class="gi">+        grid.plot_joint(plt.hexbin, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+        marginal_kws.setdefault(&quot;kde&quot;, False)</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_marginals(histplot, **marginal_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind.startswith(&quot;reg&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        marginal_kws.setdefault(&quot;kde&quot;, True)</span>
<span class="gi">+        grid.plot_marginals(histplot, **marginal_kws)</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_joint(regplot, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind.startswith(&quot;resid&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        joint_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        grid.plot_joint(residplot, **joint_kws)</span>
<span class="gi">+</span>
<span class="gi">+        x, y = grid.ax_joint.collections[0].get_offsets().T</span>
<span class="gi">+        marginal_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)</span>
<span class="gi">+        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Make the main axes active in the matplotlib state machine</span>
<span class="gi">+    plt.sca(grid.ax_joint)</span>
<span class="gi">+</span>
<span class="gi">+    return grid</span>


<span class="gd">-jointplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Draw a plot of two variables with bivariate and univariate graphs.</span>
<span class="gi">+jointplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Draw a plot of two variables with bivariate and univariate graphs.</span>

<span class="w"> </span>This function provides a convenient interface to the :class:`JointGrid`
<span class="w"> </span>class, with several canned plot kinds. This is intended to be a fairly
<span class="gu">@@ -1220,6 +2394,8 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/jointplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;], seealso=</span>
<span class="gd">-    _core_docs[&#39;seealso&#39;]))</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/seaborn/categorical.py b/seaborn/categorical.py</span>
<span class="gh">index b0ff7288..a43c085b 100644</span>
<span class="gd">--- a/seaborn/categorical.py</span>
<span class="gi">+++ b/seaborn/categorical.py</span>
<span class="gu">@@ -3,62 +3,131 @@ from textwrap import dedent</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from colorsys import rgb_to_hls
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="gi">+</span>
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from matplotlib.cbook import normalize_kwargs
<span class="w"> </span>from matplotlib.collections import PatchCollection
<span class="w"> </span>from matplotlib.markers import MarkerStyle
<span class="w"> </span>from matplotlib.patches import Rectangle
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.typing import default, deprecated
<span class="w"> </span>from seaborn._base import VectorPlotter, infer_orient, categorical_order
<span class="w"> </span>from seaborn._stats.density import KDE
<span class="w"> </span>from seaborn import utils
<span class="gd">-from seaborn.utils import desaturate, _check_argument, _draw_figure, _default_color, _get_patch_legend_artist, _get_transform_functions, _scatter_legend_artist, _version_predates</span>
<span class="gi">+from seaborn.utils import (</span>
<span class="gi">+    desaturate,</span>
<span class="gi">+    _check_argument,</span>
<span class="gi">+    _draw_figure,</span>
<span class="gi">+    _default_color,</span>
<span class="gi">+    _get_patch_legend_artist,</span>
<span class="gi">+    _get_transform_functions,</span>
<span class="gi">+    _scatter_legend_artist,</span>
<span class="gi">+    _version_predates,</span>
<span class="gi">+)</span>
<span class="w"> </span>from seaborn._compat import groupby_apply_include_groups
<span class="gd">-from seaborn._statistics import EstimateAggregator, LetterValues, WeightedAggregator</span>
<span class="gi">+from seaborn._statistics import (</span>
<span class="gi">+    EstimateAggregator,</span>
<span class="gi">+    LetterValues,</span>
<span class="gi">+    WeightedAggregator,</span>
<span class="gi">+)</span>
<span class="w"> </span>from seaborn.palettes import light_palette
<span class="w"> </span>from seaborn.axisgrid import FacetGrid, _facet_docs
<span class="gd">-__all__ = [&#39;catplot&#39;, &#39;stripplot&#39;, &#39;swarmplot&#39;, &#39;boxplot&#39;, &#39;violinplot&#39;,</span>
<span class="gd">-    &#39;boxenplot&#39;, &#39;pointplot&#39;, &#39;barplot&#39;, &#39;countplot&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;catplot&quot;,</span>
<span class="gi">+    &quot;stripplot&quot;, &quot;swarmplot&quot;,</span>
<span class="gi">+    &quot;boxplot&quot;, &quot;violinplot&quot;, &quot;boxenplot&quot;,</span>
<span class="gi">+    &quot;pointplot&quot;, &quot;barplot&quot;, &quot;countplot&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class _CategoricalPlotter(VectorPlotter):
<span class="gd">-    wide_structure = {&#39;x&#39;: &#39;@columns&#39;, &#39;y&#39;: &#39;@values&#39;, &#39;hue&#39;: &#39;@columns&#39;}</span>
<span class="gd">-    flat_structure = {&#39;y&#39;: &#39;@values&#39;}</span>
<span class="gd">-    _legend_attributes = [&#39;color&#39;]</span>

<span class="gd">-    def __init__(self, data=None, variables={}, order=None, orient=None,</span>
<span class="gd">-        require_numeric=False, color=None, legend=&#39;auto&#39;):</span>
<span class="gi">+    wide_structure = {&quot;x&quot;: &quot;@columns&quot;, &quot;y&quot;: &quot;@values&quot;, &quot;hue&quot;: &quot;@columns&quot;}</span>
<span class="gi">+    flat_structure = {&quot;y&quot;: &quot;@values&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    _legend_attributes = [&quot;color&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        variables={},</span>
<span class="gi">+        order=None,</span>
<span class="gi">+        orient=None,</span>
<span class="gi">+        require_numeric=False,</span>
<span class="gi">+        color=None,</span>
<span class="gi">+        legend=&quot;auto&quot;,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(data=data, variables=variables)
<span class="gd">-        if self.input_format == &#39;wide&#39; and orient in [&#39;h&#39;, &#39;y&#39;]:</span>
<span class="gd">-            self.plot_data = self.plot_data.rename(columns={&#39;x&#39;: &#39;y&#39;, &#39;y&#39;: &#39;x&#39;}</span>
<span class="gd">-                )</span>
<span class="gi">+</span>
<span class="gi">+        # This method takes care of some bookkeeping that is necessary because the</span>
<span class="gi">+        # original categorical plots (prior to the 2021 refactor) had some rules that</span>
<span class="gi">+        # don&#39;t fit exactly into VectorPlotter logic. It may be wise to have a second</span>
<span class="gi">+        # round of refactoring that moves the logic deeper, but this will keep things</span>
<span class="gi">+        # relatively sensible for now.</span>
<span class="gi">+</span>
<span class="gi">+        # For wide data, orient determines assignment to x/y differently from the</span>
<span class="gi">+        # default VectorPlotter rules. If we do decide to make orient part of the</span>
<span class="gi">+        # _base variable assignment, we&#39;ll want to figure out how to express that.</span>
<span class="gi">+        if self.input_format == &quot;wide&quot; and orient in [&quot;h&quot;, &quot;y&quot;]:</span>
<span class="gi">+            self.plot_data = self.plot_data.rename(columns={&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;})</span>
<span class="w"> </span>            orig_variables = set(self.variables)
<span class="gd">-            orig_x = self.variables.pop(&#39;x&#39;, None)</span>
<span class="gd">-            orig_y = self.variables.pop(&#39;y&#39;, None)</span>
<span class="gd">-            orig_x_type = self.var_types.pop(&#39;x&#39;, None)</span>
<span class="gd">-            orig_y_type = self.var_types.pop(&#39;y&#39;, None)</span>
<span class="gd">-            if &#39;x&#39; in orig_variables:</span>
<span class="gd">-                self.variables[&#39;y&#39;] = orig_x</span>
<span class="gd">-                self.var_types[&#39;y&#39;] = orig_x_type</span>
<span class="gd">-            if &#39;y&#39; in orig_variables:</span>
<span class="gd">-                self.variables[&#39;x&#39;] = orig_y</span>
<span class="gd">-                self.var_types[&#39;x&#39;] = orig_y_type</span>
<span class="gd">-        if (self.input_format == &#39;wide&#39; and &#39;hue&#39; in self.variables and </span>
<span class="gd">-            color is not None):</span>
<span class="gd">-            self.plot_data.drop(&#39;hue&#39;, axis=1)</span>
<span class="gd">-            self.variables.pop(&#39;hue&#39;)</span>
<span class="gd">-        self.orient = infer_orient(x=self.plot_data.get(&#39;x&#39;, None), y=self.</span>
<span class="gd">-            plot_data.get(&#39;y&#39;, None), orient=orient, require_numeric=False)</span>
<span class="gi">+            orig_x = self.variables.pop(&quot;x&quot;, None)</span>
<span class="gi">+            orig_y = self.variables.pop(&quot;y&quot;, None)</span>
<span class="gi">+            orig_x_type = self.var_types.pop(&quot;x&quot;, None)</span>
<span class="gi">+            orig_y_type = self.var_types.pop(&quot;y&quot;, None)</span>
<span class="gi">+            if &quot;x&quot; in orig_variables:</span>
<span class="gi">+                self.variables[&quot;y&quot;] = orig_x</span>
<span class="gi">+                self.var_types[&quot;y&quot;] = orig_x_type</span>
<span class="gi">+            if &quot;y&quot; in orig_variables:</span>
<span class="gi">+                self.variables[&quot;x&quot;] = orig_y</span>
<span class="gi">+                self.var_types[&quot;x&quot;] = orig_y_type</span>
<span class="gi">+</span>
<span class="gi">+        # Initially there was more special code for wide-form data where plots were</span>
<span class="gi">+        # multi-colored by default and then either palette or color could be used.</span>
<span class="gi">+        # We want to provide backwards compatibility for this behavior in a relatively</span>
<span class="gi">+        # simply way, so we delete the hue information when color is specified.</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.input_format == &quot;wide&quot;</span>
<span class="gi">+            and &quot;hue&quot; in self.variables</span>
<span class="gi">+            and color is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.plot_data.drop(&quot;hue&quot;, axis=1)</span>
<span class="gi">+            self.variables.pop(&quot;hue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # The concept of an &quot;orientation&quot; is important to the original categorical</span>
<span class="gi">+        # plots, but there&#39;s no provision for it in VectorPlotter, so we need it here.</span>
<span class="gi">+        # Note that it could be useful for the other functions in at least two ways</span>
<span class="gi">+        # (orienting a univariate distribution plot from long-form data and selecting</span>
<span class="gi">+        # the aggregation axis in lineplot), so we may want to eventually refactor it.</span>
<span class="gi">+        self.orient = infer_orient(</span>
<span class="gi">+            x=self.plot_data.get(&quot;x&quot;, None),</span>
<span class="gi">+            y=self.plot_data.get(&quot;y&quot;, None),</span>
<span class="gi">+            orient=orient,</span>
<span class="gi">+            require_numeric=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.legend = legend
<span class="gi">+</span>
<span class="gi">+        # Short-circuit in the case of an empty plot</span>
<span class="w"> </span>        if not self.has_xy_data:
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="gi">+        # Categorical plots can be &quot;univariate&quot; in which case they get an anonymous</span>
<span class="gi">+        # category label on the opposite axis. Note: this duplicates code in the core</span>
<span class="gi">+        # scale_categorical function. We need to do it here because of the next line.</span>
<span class="w"> </span>        if self.orient not in self.variables:
<span class="w"> </span>            self.variables[self.orient] = None
<span class="gd">-            self.var_types[self.orient] = &#39;categorical&#39;</span>
<span class="gd">-            self.plot_data[self.orient] = &#39;&#39;</span>
<span class="gi">+            self.var_types[self.orient] = &quot;categorical&quot;</span>
<span class="gi">+            self.plot_data[self.orient] = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Categorical variables have discrete levels that we need to track</span>
<span class="w"> </span>        cat_levels = categorical_order(self.plot_data[self.orient], order)
<span class="w"> </span>        self.var_levels[self.orient] = cat_levels

<span class="gu">@@ -70,92 +139,1253 @@ class _CategoricalPlotter(VectorPlotter):</span>
<span class="w"> </span>        It can be removed after completion of the work.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The original categorical functions applied a palette to the categorical axis</span>
<span class="gi">+        # by default. We want to require an explicit hue mapping, to be more consistent</span>
<span class="gi">+        # with how things work elsewhere now. I don&#39;t think there&#39;s any good way to</span>
<span class="gi">+        # do this gently -- because it&#39;s triggered by the default value of hue=None,</span>
<span class="gi">+        # users would always get a warning, unless we introduce some sentinel &quot;default&quot;</span>
<span class="gi">+        # argument for this change. That&#39;s possible, but asking users to set `hue=None`</span>
<span class="gi">+        # on every call is annoying.</span>
<span class="gi">+        # We are keeping the logic for implementing the old behavior in with the current</span>
<span class="gi">+        # system so that (a) we can punt on that decision and (b) we can ensure that</span>
<span class="gi">+        # refactored code passes old tests.</span>
<span class="gi">+        default_behavior = color is None or palette is not None</span>
<span class="gi">+        if force_hue and &quot;hue&quot; not in self.variables and default_behavior:</span>
<span class="gi">+            self._redundant_hue = True</span>
<span class="gi">+            self.plot_data[&quot;hue&quot;] = self.plot_data[self.orient]</span>
<span class="gi">+            self.variables[&quot;hue&quot;] = self.variables[self.orient]</span>
<span class="gi">+            self.var_types[&quot;hue&quot;] = &quot;categorical&quot;</span>
<span class="gi">+            hue_order = self.var_levels[self.orient]</span>
<span class="gi">+</span>
<span class="gi">+            # Because we convert the categorical axis variable to string,</span>
<span class="gi">+            # we need to update a dictionary palette too</span>
<span class="gi">+            if isinstance(palette, dict):</span>
<span class="gi">+                palette = {str(k): v for k, v in palette.items()}</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                redundant = (self.plot_data[&quot;hue&quot;] == self.plot_data[self.orient]).all()</span>
<span class="gi">+            else:</span>
<span class="gi">+                redundant = False</span>
<span class="gi">+            self._redundant_hue = redundant</span>
<span class="gi">+</span>
<span class="gi">+        # Previously, categorical plots had a trick where color= could seed the palette.</span>
<span class="gi">+        # Because that&#39;s an explicit parameterization, we are going to give it one</span>
<span class="gi">+        # release cycle with a warning before removing.</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and palette is None and color is not None:</span>
<span class="gi">+            if not isinstance(color, str):</span>
<span class="gi">+                color = mpl.colors.to_hex(color)</span>
<span class="gi">+            palette = f&quot;dark:{color}&quot;</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nSetting a gradient palette using color= is deprecated and will be &quot;</span>
<span class="gi">+                f&quot;removed in v0.14.0. Set `palette=&#39;{palette}&#39;` for the same effect.\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        return palette, hue_order</span>

<span class="w"> </span>    def _palette_without_hue_backcompat(self, palette, hue_order):
<span class="w"> </span>        &quot;&quot;&quot;Provide one cycle where palette= implies hue= when not provided&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;hue&quot; not in self.variables and palette is not None:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nPassing `palette` without assigning `hue` is deprecated &quot;</span>
<span class="gi">+                f&quot;and will be removed in v0.14.0. Assign the `{self.orient}` variable &quot;</span>
<span class="gi">+                &quot;to `hue` and set `legend=False` for the same effect.\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+            self.legend = False</span>
<span class="gi">+            self.plot_data[&quot;hue&quot;] = self.plot_data[self.orient]</span>
<span class="gi">+            self.variables[&quot;hue&quot;] = self.variables.get(self.orient)</span>
<span class="gi">+            self.var_types[&quot;hue&quot;] = self.var_types.get(self.orient)</span>
<span class="gi">+</span>
<span class="gi">+            hue_order = self.var_levels.get(self.orient)</span>
<span class="gi">+            self._var_levels.pop(&quot;hue&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        return hue_order</span>

<span class="w"> </span>    def _point_kwargs_backcompat(self, scale, join, kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Provide two cycles where scale= and join= work, but redirect to kwargs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale is not deprecated:</span>
<span class="gi">+            lw = mpl.rcParams[&quot;lines.linewidth&quot;] * 1.8 * scale</span>
<span class="gi">+            mew = lw * .75</span>
<span class="gi">+            ms = lw * 2</span>
<span class="gi">+</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\n&quot;</span>
<span class="gi">+                &quot;The `scale` parameter is deprecated and will be removed in v0.15.0. &quot;</span>
<span class="gi">+                &quot;You can now control the size of each plot element using matplotlib &quot;</span>
<span class="gi">+                &quot;`Line2D` parameters (e.g., `linewidth`, `markersize`, etc.).&quot;</span>
<span class="gi">+                &quot;\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, stacklevel=3)</span>
<span class="gi">+            kwargs.update(linewidth=lw, markeredgewidth=mew, markersize=ms)</span>
<span class="gi">+</span>
<span class="gi">+        if join is not deprecated:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\n&quot;</span>
<span class="gi">+                &quot;The `join` parameter is deprecated and will be removed in v0.15.0.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            if not join:</span>
<span class="gi">+                msg += (</span>
<span class="gi">+                    &quot; You can remove the line between points with `linestyle=&#39;none&#39;`.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                kwargs.update(linestyle=&quot;&quot;)</span>
<span class="gi">+            msg += &quot;\n&quot;</span>
<span class="gi">+            warnings.warn(msg, stacklevel=3)</span>

<span class="w"> </span>    def _err_kws_backcompat(self, err_kws, errcolor, errwidth, capsize):
<span class="w"> </span>        &quot;&quot;&quot;Provide two cycles where existing signature-level err_kws are handled.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _violin_scale_backcompat(self, scale, scale_hue, density_norm,</span>
<span class="gd">-        common_norm):</span>
<span class="gi">+        def deprecate_err_param(name, key, val):</span>
<span class="gi">+            if val is deprecated:</span>
<span class="gi">+                return</span>
<span class="gi">+            suggest = f&quot;err_kws={{&#39;{key}&#39;: {val!r}}}&quot;</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                f&quot;\n\nThe `{name}` parameter is deprecated. And will be removed &quot;</span>
<span class="gi">+                f&quot;in v0.15.0. Pass `{suggest}` instead.\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=4)</span>
<span class="gi">+            err_kws[key] = val</span>
<span class="gi">+</span>
<span class="gi">+        if errcolor is not None:</span>
<span class="gi">+            deprecate_err_param(&quot;errcolor&quot;, &quot;color&quot;, errcolor)</span>
<span class="gi">+        deprecate_err_param(&quot;errwidth&quot;, &quot;linewidth&quot;, errwidth)</span>
<span class="gi">+</span>
<span class="gi">+        if capsize is None:</span>
<span class="gi">+            capsize = 0</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nPassing `capsize=None` is deprecated and will be removed &quot;</span>
<span class="gi">+                &quot;in v0.15.0. Pass `capsize=0` to disable caps.\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        return err_kws, capsize</span>
<span class="gi">+</span>
<span class="gi">+    def _violin_scale_backcompat(self, scale, scale_hue, density_norm, common_norm):</span>
<span class="w"> </span>        &quot;&quot;&quot;Provide two cycles of backcompat for scale kwargs&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale is not deprecated:</span>
<span class="gi">+            density_norm = scale</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nThe `scale` parameter has been renamed and will be removed &quot;</span>
<span class="gi">+                f&quot;in v0.15.0. Pass `density_norm={scale!r}` for the same effect.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        if scale_hue is not deprecated:</span>
<span class="gi">+            common_norm = scale_hue</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nThe `scale_hue` parameter has been replaced and will be removed &quot;</span>
<span class="gi">+                f&quot;in v0.15.0. Pass `common_norm={not scale_hue}` for the same effect.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        return density_norm, common_norm</span>

<span class="w"> </span>    def _violin_bw_backcompat(self, bw, bw_method):
<span class="w"> </span>        &quot;&quot;&quot;Provide two cycles of backcompat for violin bandwidth parameterization.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bw is not deprecated:</span>
<span class="gi">+            bw_method = bw</span>
<span class="gi">+            msg = dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+                The `bw` parameter is deprecated in favor of `bw_method`/`bw_adjust`.</span>
<span class="gi">+                Setting `bw_method={bw!r}`, but please see docs for the new parameters</span>
<span class="gi">+                and update your code. This will become an error in seaborn v0.15.0.</span>
<span class="gi">+            &quot;&quot;&quot;)</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+        return bw_method</span>

<span class="w"> </span>    def _boxen_scale_backcompat(self, scale, width_method):
<span class="w"> </span>        &quot;&quot;&quot;Provide two cycles of backcompat for scale kwargs&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scale is not deprecated:</span>
<span class="gi">+            width_method = scale</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;\n\nThe `scale` parameter has been renamed to `width_method` and &quot;</span>
<span class="gi">+                f&quot;will be removed in v0.15. Pass `width_method={scale!r}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            if scale == &quot;area&quot;:</span>
<span class="gi">+                msg += &quot;, but note that the result for &#39;area&#39; will appear different.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg += &quot; for the same effect.&quot;</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        return width_method</span>

<span class="w"> </span>    def _complement_color(self, color, base_color, hue_map):
<span class="w"> </span>        &quot;&quot;&quot;Allow a color to be set automatically using a basis of comparison.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if color == &quot;gray&quot;:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &#39;Use &quot;auto&quot; to set automatic grayscale colors. From v0.14.0, &#39;</span>
<span class="gi">+                &#39;&quot;gray&quot; will default to matplotlib\&#39;s definition.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+            color = &quot;auto&quot;</span>
<span class="gi">+        elif color is None or color is default:</span>
<span class="gi">+            color = &quot;auto&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if color != &quot;auto&quot;:</span>
<span class="gi">+            return color</span>
<span class="gi">+</span>
<span class="gi">+        if hue_map.lookup_table is None:</span>
<span class="gi">+            if base_color is None:</span>
<span class="gi">+                return None</span>
<span class="gi">+            basis = [mpl.colors.to_rgb(base_color)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            basis = [mpl.colors.to_rgb(c) for c in hue_map.lookup_table.values()]</span>
<span class="gi">+        unique_colors = np.unique(basis, axis=0)</span>
<span class="gi">+        light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]</span>
<span class="gi">+        lum = min(light_vals) * .6</span>
<span class="gi">+        return (lum, lum, lum)</span>

<span class="w"> </span>    def _map_prop_with_hue(self, name, value, fallback, plot_kws):
<span class="w"> </span>        &quot;&quot;&quot;Support pointplot behavior of modifying the marker/linestyle with hue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is default:</span>
<span class="gi">+            value = plot_kws.pop(name, fallback)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables:</span>
<span class="gi">+            levels = self._hue_map.levels</span>
<span class="gi">+            if isinstance(value, list):</span>
<span class="gi">+                mapping = {k: v for k, v in zip(levels, value)}</span>
<span class="gi">+            else:</span>
<span class="gi">+                mapping = {k: value for k in levels}</span>
<span class="gi">+        else:</span>
<span class="gi">+            mapping = {None: value}</span>
<span class="gi">+</span>
<span class="gi">+        return mapping</span>

<span class="w"> </span>    def _adjust_cat_axis(self, ax, axis):
<span class="w"> </span>        &quot;&quot;&quot;Set ticks and limits for a categorical variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Note: in theory, this could happen in _attach for all categorical axes</span>
<span class="gi">+        # But two reasons not to do that:</span>
<span class="gi">+        # - If it happens before plotting, autoscaling messes up the plot limits</span>
<span class="gi">+        # - It would change existing plots from other seaborn functions</span>
<span class="gi">+        if self.var_types[axis] != &quot;categorical&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If both x/y data are empty, the correct way to set up the plot is</span>
<span class="gi">+        # somewhat undefined; because we don&#39;t add null category data to the plot in</span>
<span class="gi">+        # this case we don&#39;t *have* a categorical axis (yet), so best to just bail.</span>
<span class="gi">+        if self.plot_data[axis].empty:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # We can infer the total number of categories (including those from previous</span>
<span class="gi">+        # plots that are not part of the plot we are currently making) from the number</span>
<span class="gi">+        # of ticks, which matplotlib sets up while doing unit conversion. This feels</span>
<span class="gi">+        # slightly risky, as if we are relying on something that may be a matplotlib</span>
<span class="gi">+        # implementation detail. But I cannot think of a better way to keep track of</span>
<span class="gi">+        # the state from previous categorical calls (see GH2516 for context)</span>
<span class="gi">+        n = len(getattr(ax, f&quot;get_{axis}ticks&quot;)())</span>
<span class="gi">+</span>
<span class="gi">+        if axis == &quot;x&quot;:</span>
<span class="gi">+            ax.xaxis.grid(False)</span>
<span class="gi">+            ax.set_xlim(-.5, n - .5, auto=None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax.yaxis.grid(False)</span>
<span class="gi">+            # Note limits that correspond to previously-inverted y axis</span>
<span class="gi">+            ax.set_ylim(n - .5, -.5, auto=None)</span>

<span class="w"> </span>    def _dodge_needed(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True when use of `hue` would cause overlaps.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        groupers = list({self.orient, &quot;col&quot;, &quot;row&quot;} &amp; set(self.variables))</span>
<span class="gi">+        if &quot;hue&quot; in self.variables:</span>
<span class="gi">+            orient = self.plot_data[groupers].value_counts()</span>
<span class="gi">+            paired = self.plot_data[[*groupers, &quot;hue&quot;]].value_counts()</span>
<span class="gi">+            return orient.size != paired.size</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def _dodge(self, keys, data):
<span class="w"> </span>        &quot;&quot;&quot;Apply a dodge transform to coordinates in place.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;hue&quot; not in self.variables:</span>
<span class="gi">+            # Short-circuit if hue variable was not assigned</span>
<span class="gi">+            # We could potentially warn when hue=None, dodge=True, user may be confused</span>
<span class="gi">+            # But I think it&#39;s fine to just treat it as a no-op.</span>
<span class="gi">+            return</span>
<span class="gi">+        hue_idx = self._hue_map.levels.index(keys[&quot;hue&quot;])</span>
<span class="gi">+        n = len(self._hue_map.levels)</span>
<span class="gi">+        data[&quot;width&quot;] /= n</span>
<span class="gi">+</span>
<span class="gi">+        full_width = data[&quot;width&quot;] * n</span>
<span class="gi">+        offset = data[&quot;width&quot;] * hue_idx + data[&quot;width&quot;] / 2 - full_width / 2</span>
<span class="gi">+        data[self.orient] += offset</span>

<span class="gd">-    def _invert_scale(self, ax, data, vars=(&#39;x&#39;, &#39;y&#39;)):</span>
<span class="gi">+    def _invert_scale(self, ax, data, vars=(&quot;x&quot;, &quot;y&quot;)):</span>
<span class="w"> </span>        &quot;&quot;&quot;Undo scaling after computation so data are plotted correctly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for var in vars:</span>
<span class="gi">+            _, inv = _get_transform_functions(ax, var[0])</span>
<span class="gi">+            if var == self.orient and &quot;width&quot; in data:</span>
<span class="gi">+                hw = data[&quot;width&quot;] / 2</span>
<span class="gi">+                data[&quot;edge&quot;] = inv(data[var] - hw)</span>
<span class="gi">+                data[&quot;width&quot;] = inv(data[var] + hw) - data[&quot;edge&quot;].to_numpy()</span>
<span class="gi">+            for suf in [&quot;&quot;, &quot;min&quot;, &quot;max&quot;]:</span>
<span class="gi">+                if (col := f&quot;{var}{suf}&quot;) in data:</span>
<span class="gi">+                    data[col] = inv(data[col])</span>
<span class="gi">+</span>
<span class="gi">+    def _configure_legend(self, ax, func, common_kws=None, semantic_kws=None):</span>
<span class="gi">+        if self.legend == &quot;auto&quot;:</span>
<span class="gi">+            show_legend = not self._redundant_hue and self.input_format != &quot;wide&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            show_legend = bool(self.legend)</span>
<span class="gi">+        if show_legend:</span>
<span class="gi">+            self.add_legend_data(ax, func, common_kws, semantic_kws=semantic_kws)</span>
<span class="gi">+            handles, _ = ax.get_legend_handles_labels()</span>
<span class="gi">+            if handles:</span>
<span class="gi">+                ax.legend(title=self.legend_title)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _native_width(self):
<span class="w"> </span>        &quot;&quot;&quot;Return unit of width separating categories on native numeric scale.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Categorical data always have a unit width</span>
<span class="gi">+        if self.var_types[self.orient] == &quot;categorical&quot;:</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, define the width as the smallest space between observations</span>
<span class="gi">+        unique_values = np.unique(self.comp_data[self.orient])</span>
<span class="gi">+        if len(unique_values) &gt; 1:</span>
<span class="gi">+            native_width = np.nanmin(np.diff(unique_values))</span>
<span class="gi">+        else:</span>
<span class="gi">+            native_width = 1</span>
<span class="gi">+        return native_width</span>

<span class="w"> </span>    def _nested_offsets(self, width, dodge):
<span class="w"> </span>        &quot;&quot;&quot;Return offsets for each hue level for dodged plots.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        offsets = None</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and self._hue_map.levels is not None:</span>
<span class="gi">+            n_levels = len(self._hue_map.levels)</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                each_width = width / n_levels</span>
<span class="gi">+                offsets = np.linspace(0, width - each_width, n_levels)</span>
<span class="gi">+                offsets -= offsets.mean()</span>
<span class="gi">+            else:</span>
<span class="gi">+                offsets = np.zeros(n_levels)</span>
<span class="gi">+        return offsets</span>
<span class="gi">+</span>
<span class="gi">+    # Note that the plotting methods here aim (in most cases) to produce the</span>
<span class="gi">+    # exact same artists as the original (pre 0.12) version of the code, so</span>
<span class="gi">+    # there is some weirdness that might not otherwise be clean or make sense in</span>
<span class="gi">+    # this context, such as adding empty artists for combinations of variables</span>
<span class="gi">+    # with no observations</span>
<span class="gi">+</span>
<span class="gi">+    def plot_strips(</span>
<span class="gi">+        self,</span>
<span class="gi">+        jitter,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        color,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        width = .8 * self._native_width</span>
<span class="gi">+        offsets = self._nested_offsets(width, dodge)</span>
<span class="gi">+</span>
<span class="gi">+        if jitter is True:</span>
<span class="gi">+            jlim = 0.1</span>
<span class="gi">+        else:</span>
<span class="gi">+            jlim = float(jitter)</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and dodge and self._hue_map.levels is not None:</span>
<span class="gi">+            jlim /= len(self._hue_map.levels)</span>
<span class="gi">+        jlim *= self._native_width</span>
<span class="gi">+        jitterer = partial(np.random.uniform, low=-jlim, high=+jlim)</span>
<span class="gi">+</span>
<span class="gi">+        iter_vars = [self.orient]</span>
<span class="gi">+        if dodge:</span>
<span class="gi">+            iter_vars.append(&quot;hue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+        dodge_move = jitter_move = 0</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;marker&quot; in plot_kws and not MarkerStyle(plot_kws[&quot;marker&quot;]).is_filled():</span>
<span class="gi">+            plot_kws.pop(&quot;edgecolor&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=True):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            if offsets is not None and (offsets != 0).any():</span>
<span class="gi">+                dodge_move = offsets[sub_data[&quot;hue&quot;].map(self._hue_map.levels.index)]</span>
<span class="gi">+</span>
<span class="gi">+            jitter_move = jitterer(size=len(sub_data)) if len(sub_data) &gt; 1 else 0</span>
<span class="gi">+</span>
<span class="gi">+            adjusted_data = sub_data[self.orient] + dodge_move + jitter_move</span>
<span class="gi">+            sub_data[self.orient] = adjusted_data</span>
<span class="gi">+            self._invert_scale(ax, sub_data)</span>
<span class="gi">+</span>
<span class="gi">+            points = ax.scatter(sub_data[&quot;x&quot;], sub_data[&quot;y&quot;], color=color, **plot_kws)</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                points.set_facecolors(self._hue_map(sub_data[&quot;hue&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+        self._configure_legend(ax, _scatter_legend_artist, common_kws=plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_swarms(</span>
<span class="gi">+        self,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        color,</span>
<span class="gi">+        warn_thresh,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        width = .8 * self._native_width</span>
<span class="gi">+        offsets = self._nested_offsets(width, dodge)</span>
<span class="gi">+</span>
<span class="gi">+        iter_vars = [self.orient]</span>
<span class="gi">+        if dodge:</span>
<span class="gi">+            iter_vars.append(&quot;hue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+        point_collections = {}</span>
<span class="gi">+        dodge_move = 0</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;marker&quot; in plot_kws and not MarkerStyle(plot_kws[&quot;marker&quot;]).is_filled():</span>
<span class="gi">+            plot_kws.pop(&quot;edgecolor&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=True):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            if offsets is not None:</span>
<span class="gi">+                dodge_move = offsets[sub_data[&quot;hue&quot;].map(self._hue_map.levels.index)]</span>
<span class="gi">+</span>
<span class="gi">+            if not sub_data.empty:</span>
<span class="gi">+                sub_data[self.orient] = sub_data[self.orient] + dodge_move</span>
<span class="gi">+</span>
<span class="gi">+            self._invert_scale(ax, sub_data)</span>
<span class="gi">+</span>
<span class="gi">+            points = ax.scatter(sub_data[&quot;x&quot;], sub_data[&quot;y&quot;], color=color, **plot_kws)</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                points.set_facecolors(self._hue_map(sub_data[&quot;hue&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+            if not sub_data.empty:</span>
<span class="gi">+                point_collections[(ax, sub_data[self.orient].iloc[0])] = points</span>
<span class="gi">+</span>
<span class="gi">+        beeswarm = Beeswarm(width=width, orient=self.orient, warn_thresh=warn_thresh)</span>
<span class="gi">+        for (ax, center), points in point_collections.items():</span>
<span class="gi">+            if points.get_offsets().shape[0] &gt; 1:</span>
<span class="gi">+</span>
<span class="gi">+                def draw(points, renderer, *, center=center):</span>
<span class="gi">+</span>
<span class="gi">+                    beeswarm(points, center)</span>
<span class="gi">+</span>
<span class="gi">+                    if self.orient == &quot;y&quot;:</span>
<span class="gi">+                        scalex = False</span>
<span class="gi">+                        scaley = ax.get_autoscaley_on()</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        scalex = ax.get_autoscalex_on()</span>
<span class="gi">+                        scaley = False</span>
<span class="gi">+</span>
<span class="gi">+                    # This prevents us from undoing the nice categorical axis limits</span>
<span class="gi">+                    # set in _adjust_cat_axis, because that method currently leave</span>
<span class="gi">+                    # the autoscale flag in its original setting. It may be better</span>
<span class="gi">+                    # to disable autoscaling there to avoid needing to do this.</span>
<span class="gi">+                    fixed_scale = self.var_types[self.orient] == &quot;categorical&quot;</span>
<span class="gi">+                    ax.update_datalim(points.get_datalim(ax.transData))</span>
<span class="gi">+                    if not fixed_scale and (scalex or scaley):</span>
<span class="gi">+                        ax.autoscale_view(scalex=scalex, scaley=scaley)</span>
<span class="gi">+</span>
<span class="gi">+                    super(points.__class__, points).draw(renderer)</span>
<span class="gi">+</span>
<span class="gi">+                points.draw = draw.__get__(points)</span>
<span class="gi">+</span>
<span class="gi">+        _draw_figure(ax.figure)</span>
<span class="gi">+        self._configure_legend(ax, _scatter_legend_artist, plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_boxes(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        gap,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        whis,</span>
<span class="gi">+        color,</span>
<span class="gi">+        linecolor,</span>
<span class="gi">+        linewidth,</span>
<span class="gi">+        fliersize,</span>
<span class="gi">+        plot_kws,  # TODO rename user_kws?</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        iter_vars = [&quot;hue&quot;]</span>
<span class="gi">+        value_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+</span>
<span class="gi">+        def get_props(element, artist=mpl.lines.Line2D):</span>
<span class="gi">+            return normalize_kwargs(plot_kws.pop(f&quot;{element}props&quot;, {}), artist)</span>
<span class="gi">+</span>
<span class="gi">+        if not fill and linewidth is None:</span>
<span class="gi">+            linewidth = mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+        bootstrap = plot_kws.pop(&quot;bootstrap&quot;, mpl.rcParams[&quot;boxplot.bootstrap&quot;])</span>
<span class="gi">+        plot_kws.setdefault(&quot;shownotches&quot;, plot_kws.pop(&quot;notch&quot;, False))</span>
<span class="gi">+</span>
<span class="gi">+        box_artist = mpl.patches.Rectangle if fill else mpl.lines.Line2D</span>
<span class="gi">+        props = {</span>
<span class="gi">+            &quot;box&quot;: get_props(&quot;box&quot;, box_artist),</span>
<span class="gi">+            &quot;median&quot;: get_props(&quot;median&quot;),</span>
<span class="gi">+            &quot;whisker&quot;: get_props(&quot;whisker&quot;),</span>
<span class="gi">+            &quot;flier&quot;: get_props(&quot;flier&quot;),</span>
<span class="gi">+            &quot;cap&quot;: get_props(&quot;cap&quot;),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        props[&quot;median&quot;].setdefault(&quot;solid_capstyle&quot;, &quot;butt&quot;)</span>
<span class="gi">+        props[&quot;whisker&quot;].setdefault(&quot;solid_capstyle&quot;, &quot;butt&quot;)</span>
<span class="gi">+        props[&quot;flier&quot;].setdefault(&quot;markersize&quot;, fliersize)</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=False):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            grouped = sub_data.groupby(self.orient)[value_var]</span>
<span class="gi">+            positions = sorted(sub_data[self.orient].unique().astype(float))</span>
<span class="gi">+            value_data = [x.to_numpy() for _, x in grouped]</span>
<span class="gi">+            stats = pd.DataFrame(mpl.cbook.boxplot_stats(value_data, whis=whis,</span>
<span class="gi">+                                                         bootstrap=bootstrap))</span>
<span class="gi">+</span>
<span class="gi">+            orig_width = width * self._native_width</span>
<span class="gi">+            data = pd.DataFrame({self.orient: positions, &quot;width&quot;: orig_width})</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                self._dodge(sub_vars, data)</span>
<span class="gi">+            if gap:</span>
<span class="gi">+                data[&quot;width&quot;] *= 1 - gap</span>
<span class="gi">+            capwidth = plot_kws.get(&quot;capwidths&quot;, 0.5 * data[&quot;width&quot;])</span>
<span class="gi">+</span>
<span class="gi">+            self._invert_scale(ax, data)</span>
<span class="gi">+            _, inv = _get_transform_functions(ax, value_var)</span>
<span class="gi">+            for stat in [&quot;mean&quot;, &quot;med&quot;, &quot;q1&quot;, &quot;q3&quot;, &quot;cilo&quot;, &quot;cihi&quot;, &quot;whislo&quot;, &quot;whishi&quot;]:</span>
<span class="gi">+                stats[stat] = inv(stats[stat])</span>
<span class="gi">+            stats[&quot;fliers&quot;] = stats[&quot;fliers&quot;].map(inv)</span>
<span class="gi">+</span>
<span class="gi">+            linear_orient_scale = getattr(ax, f&quot;get_{self.orient}scale&quot;)() == &quot;linear&quot;</span>
<span class="gi">+</span>
<span class="gi">+            maincolor = self._hue_map(sub_vars[&quot;hue&quot;]) if &quot;hue&quot; in sub_vars else color</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                boxprops = {</span>
<span class="gi">+                    &quot;facecolor&quot;: maincolor, &quot;edgecolor&quot;: linecolor, **props[&quot;box&quot;]</span>
<span class="gi">+                }</span>
<span class="gi">+                medianprops = {&quot;color&quot;: linecolor, **props[&quot;median&quot;]}</span>
<span class="gi">+                whiskerprops = {&quot;color&quot;: linecolor, **props[&quot;whisker&quot;]}</span>
<span class="gi">+                flierprops = {&quot;markeredgecolor&quot;: linecolor, **props[&quot;flier&quot;]}</span>
<span class="gi">+                capprops = {&quot;color&quot;: linecolor, **props[&quot;cap&quot;]}</span>
<span class="gi">+            else:</span>
<span class="gi">+                boxprops = {&quot;color&quot;: maincolor, **props[&quot;box&quot;]}</span>
<span class="gi">+                medianprops = {&quot;color&quot;: maincolor, **props[&quot;median&quot;]}</span>
<span class="gi">+                whiskerprops = {&quot;color&quot;: maincolor, **props[&quot;whisker&quot;]}</span>
<span class="gi">+                flierprops = {&quot;markeredgecolor&quot;: maincolor, **props[&quot;flier&quot;]}</span>
<span class="gi">+                capprops = {&quot;color&quot;: maincolor, **props[&quot;cap&quot;]}</span>
<span class="gi">+</span>
<span class="gi">+            if linewidth is not None:</span>
<span class="gi">+                for prop_dict in [boxprops, medianprops, whiskerprops, capprops]:</span>
<span class="gi">+                    prop_dict.setdefault(&quot;linewidth&quot;, linewidth)</span>
<span class="gi">+</span>
<span class="gi">+            default_kws = dict(</span>
<span class="gi">+                bxpstats=stats.to_dict(&quot;records&quot;),</span>
<span class="gi">+                positions=data[self.orient],</span>
<span class="gi">+                # Set width to 0 to avoid going out of domain</span>
<span class="gi">+                widths=data[&quot;width&quot;] if linear_orient_scale else 0,</span>
<span class="gi">+                patch_artist=fill,</span>
<span class="gi">+                vert=self.orient == &quot;x&quot;,</span>
<span class="gi">+                manage_ticks=False,</span>
<span class="gi">+                boxprops=boxprops,</span>
<span class="gi">+                medianprops=medianprops,</span>
<span class="gi">+                whiskerprops=whiskerprops,</span>
<span class="gi">+                flierprops=flierprops,</span>
<span class="gi">+                capprops=capprops,</span>
<span class="gi">+                # Added in matplotlib 3.6.0; see below</span>
<span class="gi">+                # capwidths=capwidth,</span>
<span class="gi">+                **(</span>
<span class="gi">+                    {} if _version_predates(mpl, &quot;3.6.0&quot;)</span>
<span class="gi">+                    else {&quot;capwidths&quot;: capwidth}</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            boxplot_kws = {**default_kws, **plot_kws}</span>
<span class="gi">+            artists = ax.bxp(**boxplot_kws)</span>
<span class="gi">+</span>
<span class="gi">+            # Reset artist widths after adding so everything stays positive</span>
<span class="gi">+            ori_idx = [&quot;x&quot;, &quot;y&quot;].index(self.orient)</span>
<span class="gi">+</span>
<span class="gi">+            if not linear_orient_scale:</span>
<span class="gi">+                for i, box in enumerate(data.to_dict(&quot;records&quot;)):</span>
<span class="gi">+                    p0 = box[&quot;edge&quot;]</span>
<span class="gi">+                    p1 = box[&quot;edge&quot;] + box[&quot;width&quot;]</span>
<span class="gi">+</span>
<span class="gi">+                    if artists[&quot;boxes&quot;]:</span>
<span class="gi">+                        box_artist = artists[&quot;boxes&quot;][i]</span>
<span class="gi">+                        if fill:</span>
<span class="gi">+                            box_verts = box_artist.get_path().vertices.T</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            box_verts = box_artist.get_data()</span>
<span class="gi">+                        box_verts[ori_idx][0] = p0</span>
<span class="gi">+                        box_verts[ori_idx][3:] = p0</span>
<span class="gi">+                        box_verts[ori_idx][1:3] = p1</span>
<span class="gi">+                        if not fill:</span>
<span class="gi">+                            # When fill is True, the data get changed in place</span>
<span class="gi">+                            box_artist.set_data(box_verts)</span>
<span class="gi">+                        ax.update_datalim(</span>
<span class="gi">+                            np.transpose(box_verts),</span>
<span class="gi">+                            updatex=self.orient == &quot;x&quot;,</span>
<span class="gi">+                            updatey=self.orient == &quot;y&quot;,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                    if artists[&quot;medians&quot;]:</span>
<span class="gi">+                        verts = artists[&quot;medians&quot;][i].get_xydata().T</span>
<span class="gi">+                        verts[ori_idx][:] = p0, p1</span>
<span class="gi">+                        artists[&quot;medians&quot;][i].set_data(verts)</span>
<span class="gi">+</span>
<span class="gi">+                    if artists[&quot;caps&quot;]:</span>
<span class="gi">+                        f_fwd, f_inv = _get_transform_functions(ax, self.orient)</span>
<span class="gi">+                        for line in artists[&quot;caps&quot;][2 * i:2 * i + 2]:</span>
<span class="gi">+                            p0 = f_inv(f_fwd(box[self.orient]) - capwidth[i] / 2)</span>
<span class="gi">+                            p1 = f_inv(f_fwd(box[self.orient]) + capwidth[i] / 2)</span>
<span class="gi">+                            verts = line.get_xydata().T</span>
<span class="gi">+                            verts[ori_idx][:] = p0, p1</span>
<span class="gi">+                            line.set_data(verts)</span>
<span class="gi">+</span>
<span class="gi">+            ax.add_container(BoxPlotContainer(artists))</span>
<span class="gi">+</span>
<span class="gi">+        legend_artist = _get_patch_legend_artist(fill)</span>
<span class="gi">+        self._configure_legend(ax, legend_artist, boxprops)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_boxens(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        gap,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        color,</span>
<span class="gi">+        linecolor,</span>
<span class="gi">+        linewidth,</span>
<span class="gi">+        width_method,</span>
<span class="gi">+        k_depth,</span>
<span class="gi">+        outlier_prop,</span>
<span class="gi">+        trust_alpha,</span>
<span class="gi">+        showfliers,</span>
<span class="gi">+        box_kws,</span>
<span class="gi">+        flier_kws,</span>
<span class="gi">+        line_kws,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        iter_vars = [self.orient, &quot;hue&quot;]</span>
<span class="gi">+        value_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+</span>
<span class="gi">+        estimator = LetterValues(k_depth, outlier_prop, trust_alpha)</span>
<span class="gi">+</span>
<span class="gi">+        width_method_options = [&quot;exponential&quot;, &quot;linear&quot;, &quot;area&quot;]</span>
<span class="gi">+        _check_argument(&quot;width_method&quot;, width_method_options, width_method)</span>
<span class="gi">+</span>
<span class="gi">+        box_kws = plot_kws if box_kws is None else {**plot_kws, **box_kws}</span>
<span class="gi">+        flier_kws = {} if flier_kws is None else flier_kws.copy()</span>
<span class="gi">+        line_kws = {} if line_kws is None else line_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        if linewidth is None:</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                linewidth = 0.5 * mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                linewidth = mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=False):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+            _, inv_ori = _get_transform_functions(ax, self.orient)</span>
<span class="gi">+            _, inv_val = _get_transform_functions(ax, value_var)</span>
<span class="gi">+</span>
<span class="gi">+            # Statistics</span>
<span class="gi">+            lv_data = estimator(sub_data[value_var])</span>
<span class="gi">+            n = lv_data[&quot;k&quot;] * 2 - 1</span>
<span class="gi">+            vals = lv_data[&quot;values&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            pos_data = pd.DataFrame({</span>
<span class="gi">+                self.orient: [sub_vars[self.orient]],</span>
<span class="gi">+                &quot;width&quot;: [width * self._native_width],</span>
<span class="gi">+            })</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                self._dodge(sub_vars, pos_data)</span>
<span class="gi">+            if gap:</span>
<span class="gi">+                pos_data[&quot;width&quot;] *= 1 - gap</span>
<span class="gi">+</span>
<span class="gi">+            # Letter-value boxes</span>
<span class="gi">+            levels = lv_data[&quot;levels&quot;]</span>
<span class="gi">+            exponent = (levels - 1 - lv_data[&quot;k&quot;]).astype(float)</span>
<span class="gi">+            if width_method == &quot;linear&quot;:</span>
<span class="gi">+                rel_widths = levels + 1</span>
<span class="gi">+            elif width_method == &quot;exponential&quot;:</span>
<span class="gi">+                rel_widths = 2 ** exponent</span>
<span class="gi">+            elif width_method == &quot;area&quot;:</span>
<span class="gi">+                tails = levels &lt; (lv_data[&quot;k&quot;] - 1)</span>
<span class="gi">+                rel_widths = 2 ** (exponent - tails) / np.diff(lv_data[&quot;values&quot;])</span>
<span class="gi">+</span>
<span class="gi">+            center = pos_data[self.orient].item()</span>
<span class="gi">+            widths = rel_widths / rel_widths.max() * pos_data[&quot;width&quot;].item()</span>
<span class="gi">+</span>
<span class="gi">+            box_vals = inv_val(vals)</span>
<span class="gi">+            box_pos = inv_ori(center - widths / 2)</span>
<span class="gi">+            box_heights = inv_val(vals[1:]) - inv_val(vals[:-1])</span>
<span class="gi">+            box_widths = inv_ori(center + widths / 2) - inv_ori(center - widths / 2)</span>
<span class="gi">+</span>
<span class="gi">+            maincolor = self._hue_map(sub_vars[&quot;hue&quot;]) if &quot;hue&quot; in sub_vars else color</span>
<span class="gi">+            flier_colors = {</span>
<span class="gi">+                &quot;facecolor&quot;: &quot;none&quot;, &quot;edgecolor&quot;: &quot;.45&quot; if fill else maincolor</span>
<span class="gi">+            }</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                cmap = light_palette(maincolor, as_cmap=True)</span>
<span class="gi">+                boxcolors = cmap(2 ** ((exponent + 2) / 3))</span>
<span class="gi">+            else:</span>
<span class="gi">+                boxcolors = maincolor</span>
<span class="gi">+</span>
<span class="gi">+            boxen = []</span>
<span class="gi">+            for i in range(n):</span>
<span class="gi">+                if self.orient == &quot;x&quot;:</span>
<span class="gi">+                    xy = (box_pos[i], box_vals[i])</span>
<span class="gi">+                    w, h = (box_widths[i], box_heights[i])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    xy = (box_vals[i], box_pos[i])</span>
<span class="gi">+                    w, h = (box_heights[i], box_widths[i])</span>
<span class="gi">+                boxen.append(Rectangle(xy, w, h))</span>
<span class="gi">+</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                box_colors = {&quot;facecolors&quot;: boxcolors, &quot;edgecolors&quot;: linecolor}</span>
<span class="gi">+            else:</span>
<span class="gi">+                box_colors = {&quot;facecolors&quot;: &quot;none&quot;, &quot;edgecolors&quot;: boxcolors}</span>
<span class="gi">+</span>
<span class="gi">+            collection_kws = {**box_colors, &quot;linewidth&quot;: linewidth, **box_kws}</span>
<span class="gi">+            ax.add_collection(PatchCollection(boxen, **collection_kws), autolim=False)</span>
<span class="gi">+            ax.update_datalim(</span>
<span class="gi">+                np.column_stack([box_vals, box_vals]),</span>
<span class="gi">+                updatex=self.orient == &quot;y&quot;,</span>
<span class="gi">+                updatey=self.orient == &quot;x&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Median line</span>
<span class="gi">+            med = lv_data[&quot;median&quot;]</span>
<span class="gi">+            hw = pos_data[&quot;width&quot;].item() / 2</span>
<span class="gi">+            if self.orient == &quot;x&quot;:</span>
<span class="gi">+                x, y = inv_ori([center - hw, center + hw]), inv_val([med, med])</span>
<span class="gi">+            else:</span>
<span class="gi">+                x, y = inv_val([med, med]), inv_ori([center - hw, center + hw])</span>
<span class="gi">+            default_kws = {</span>
<span class="gi">+                &quot;color&quot;: linecolor if fill else maincolor,</span>
<span class="gi">+                &quot;solid_capstyle&quot;: &quot;butt&quot;,</span>
<span class="gi">+                &quot;linewidth&quot;: 1.25 * linewidth,</span>
<span class="gi">+            }</span>
<span class="gi">+            ax.plot(x, y, **{**default_kws, **line_kws})</span>
<span class="gi">+</span>
<span class="gi">+            # Outliers (&quot;fliers&quot;)</span>
<span class="gi">+            if showfliers:</span>
<span class="gi">+                vals = inv_val(lv_data[&quot;fliers&quot;])</span>
<span class="gi">+                pos = np.full(len(vals), inv_ori(pos_data[self.orient].item()))</span>
<span class="gi">+                x, y = (pos, vals) if self.orient == &quot;x&quot; else (vals, pos)</span>
<span class="gi">+                ax.scatter(x, y, **{**flier_colors, &quot;s&quot;: 25, **flier_kws})</span>
<span class="gi">+</span>
<span class="gi">+        ax.autoscale_view(scalex=self.orient == &quot;y&quot;, scaley=self.orient == &quot;x&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        legend_artist = _get_patch_legend_artist(fill)</span>
<span class="gi">+        common_kws = {**box_kws, &quot;linewidth&quot;: linewidth, &quot;edgecolor&quot;: linecolor}</span>
<span class="gi">+        self._configure_legend(ax, legend_artist, common_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_violins(</span>
<span class="gi">+        self,</span>
<span class="gi">+        width,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        gap,</span>
<span class="gi">+        split,</span>
<span class="gi">+        color,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        linecolor,</span>
<span class="gi">+        linewidth,</span>
<span class="gi">+        inner,</span>
<span class="gi">+        density_norm,</span>
<span class="gi">+        common_norm,</span>
<span class="gi">+        kde_kws,</span>
<span class="gi">+        inner_kws,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        iter_vars = [self.orient, &quot;hue&quot;]</span>
<span class="gi">+        value_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+</span>
<span class="gi">+        inner_options = [&quot;box&quot;, &quot;quart&quot;, &quot;stick&quot;, &quot;point&quot;, None]</span>
<span class="gi">+        _check_argument(&quot;inner&quot;, inner_options, inner, prefix=True)</span>
<span class="gi">+        _check_argument(&quot;density_norm&quot;, [&quot;area&quot;, &quot;count&quot;, &quot;width&quot;], density_norm)</span>
<span class="gi">+</span>
<span class="gi">+        if linewidth is None:</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                linewidth = 1.25 * mpl.rcParams[&quot;patch.linewidth&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                linewidth = mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if inner is not None and inner.startswith(&quot;box&quot;):</span>
<span class="gi">+            box_width = inner_kws.pop(&quot;box_width&quot;, linewidth * 4.5)</span>
<span class="gi">+            whis_width = inner_kws.pop(&quot;whis_width&quot;, box_width / 3)</span>
<span class="gi">+            marker = inner_kws.pop(&quot;marker&quot;, &quot;_&quot; if self.orient == &quot;x&quot; else &quot;|&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        kde = KDE(**kde_kws)</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+        violin_data = []</span>
<span class="gi">+</span>
<span class="gi">+        # Iterate through all the data splits once to compute the KDEs</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=False):</span>
<span class="gi">+</span>
<span class="gi">+            sub_data[&quot;weight&quot;] = sub_data.get(&quot;weights&quot;, 1)</span>
<span class="gi">+            stat_data = kde._transform(sub_data, value_var, [])</span>
<span class="gi">+</span>
<span class="gi">+            maincolor = self._hue_map(sub_vars[&quot;hue&quot;]) if &quot;hue&quot; in sub_vars else color</span>
<span class="gi">+            if not fill:</span>
<span class="gi">+                linecolor = maincolor</span>
<span class="gi">+                maincolor = &quot;none&quot;</span>
<span class="gi">+            default_kws = dict(</span>
<span class="gi">+                facecolor=maincolor,</span>
<span class="gi">+                edgecolor=linecolor,</span>
<span class="gi">+                linewidth=linewidth,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            violin_data.append({</span>
<span class="gi">+                &quot;position&quot;: sub_vars[self.orient],</span>
<span class="gi">+                &quot;observations&quot;: sub_data[value_var],</span>
<span class="gi">+                &quot;density&quot;: stat_data[&quot;density&quot;],</span>
<span class="gi">+                &quot;support&quot;: stat_data[value_var],</span>
<span class="gi">+                &quot;kwargs&quot;: {**default_kws, **plot_kws},</span>
<span class="gi">+                &quot;sub_vars&quot;: sub_vars,</span>
<span class="gi">+                &quot;ax&quot;: self._get_axes(sub_vars),</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        # Once we&#39;ve computed all the KDEs, get statistics for normalization</span>
<span class="gi">+        def vars_to_key(sub_vars):</span>
<span class="gi">+            return tuple((k, v) for k, v in sub_vars.items() if k != self.orient)</span>
<span class="gi">+</span>
<span class="gi">+        norm_keys = [vars_to_key(violin[&quot;sub_vars&quot;]) for violin in violin_data]</span>
<span class="gi">+        if common_norm:</span>
<span class="gi">+            common_max_density = np.nanmax([v[&quot;density&quot;].max() for v in violin_data])</span>
<span class="gi">+            common_max_count = np.nanmax([len(v[&quot;observations&quot;]) for v in violin_data])</span>
<span class="gi">+            max_density = {key: common_max_density for key in norm_keys}</span>
<span class="gi">+            max_count = {key: common_max_count for key in norm_keys}</span>
<span class="gi">+        else:</span>
<span class="gi">+            with warnings.catch_warnings():</span>
<span class="gi">+                # Ignore warning when all violins are singular; it&#39;s not important</span>
<span class="gi">+                warnings.filterwarnings(&#39;ignore&#39;, &quot;All-NaN (slice|axis) encountered&quot;)</span>
<span class="gi">+                max_density = {</span>
<span class="gi">+                    key: np.nanmax([</span>
<span class="gi">+                        v[&quot;density&quot;].max() for v in violin_data</span>
<span class="gi">+                        if vars_to_key(v[&quot;sub_vars&quot;]) == key</span>
<span class="gi">+                    ]) for key in norm_keys</span>
<span class="gi">+                }</span>
<span class="gi">+            max_count = {</span>
<span class="gi">+                key: np.nanmax([</span>
<span class="gi">+                    len(v[&quot;observations&quot;]) for v in violin_data</span>
<span class="gi">+                    if vars_to_key(v[&quot;sub_vars&quot;]) == key</span>
<span class="gi">+                ]) for key in norm_keys</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        real_width = width * self._native_width</span>
<span class="gi">+</span>
<span class="gi">+        # Now iterate through the violins again to apply the normalization and plot</span>
<span class="gi">+        for violin in violin_data:</span>
<span class="gi">+</span>
<span class="gi">+            index = pd.RangeIndex(0, max(len(violin[&quot;support&quot;]), 1))</span>
<span class="gi">+            data = pd.DataFrame({</span>
<span class="gi">+                self.orient: violin[&quot;position&quot;],</span>
<span class="gi">+                value_var: violin[&quot;support&quot;],</span>
<span class="gi">+                &quot;density&quot;: violin[&quot;density&quot;],</span>
<span class="gi">+                &quot;width&quot;: real_width,</span>
<span class="gi">+            }, index=index)</span>
<span class="gi">+</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                self._dodge(violin[&quot;sub_vars&quot;], data)</span>
<span class="gi">+            if gap:</span>
<span class="gi">+                data[&quot;width&quot;] *= 1 - gap</span>
<span class="gi">+</span>
<span class="gi">+            # Normalize the density across the distribution(s) and relative to the width</span>
<span class="gi">+            norm_key = vars_to_key(violin[&quot;sub_vars&quot;])</span>
<span class="gi">+            hw = data[&quot;width&quot;] / 2</span>
<span class="gi">+            peak_density = violin[&quot;density&quot;].max()</span>
<span class="gi">+            if np.isnan(peak_density):</span>
<span class="gi">+                span = 1</span>
<span class="gi">+            elif density_norm == &quot;area&quot;:</span>
<span class="gi">+                span = data[&quot;density&quot;] / max_density[norm_key]</span>
<span class="gi">+            elif density_norm == &quot;count&quot;:</span>
<span class="gi">+                count = len(violin[&quot;observations&quot;])</span>
<span class="gi">+                span = data[&quot;density&quot;] / peak_density * (count / max_count[norm_key])</span>
<span class="gi">+            elif density_norm == &quot;width&quot;:</span>
<span class="gi">+                span = data[&quot;density&quot;] / peak_density</span>
<span class="gi">+            span = span * hw * (2 if split else 1)</span>
<span class="gi">+</span>
<span class="gi">+            # Handle split violins (i.e. asymmetric spans)</span>
<span class="gi">+            right_side = (</span>
<span class="gi">+                0 if &quot;hue&quot; not in self.variables</span>
<span class="gi">+                else self._hue_map.levels.index(violin[&quot;sub_vars&quot;][&quot;hue&quot;]) % 2</span>
<span class="gi">+            )</span>
<span class="gi">+            if split:</span>
<span class="gi">+                offsets = (hw, span - hw) if right_side else (span - hw, hw)</span>
<span class="gi">+            else:</span>
<span class="gi">+                offsets = span, span</span>
<span class="gi">+</span>
<span class="gi">+            ax = violin[&quot;ax&quot;]</span>
<span class="gi">+            _, invx = _get_transform_functions(ax, &quot;x&quot;)</span>
<span class="gi">+            _, invy = _get_transform_functions(ax, &quot;y&quot;)</span>
<span class="gi">+            inv_pos = {&quot;x&quot;: invx, &quot;y&quot;: invy}[self.orient]</span>
<span class="gi">+            inv_val = {&quot;x&quot;: invx, &quot;y&quot;: invy}[value_var]</span>
<span class="gi">+</span>
<span class="gi">+            linecolor = violin[&quot;kwargs&quot;][&quot;edgecolor&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            # Handle singular datasets (one or more observations with no variance</span>
<span class="gi">+            if np.isnan(peak_density):</span>
<span class="gi">+                pos = data[self.orient].iloc[0]</span>
<span class="gi">+                val = violin[&quot;observations&quot;].mean()</span>
<span class="gi">+                if self.orient == &quot;x&quot;:</span>
<span class="gi">+                    x, y = [pos - offsets[0], pos + offsets[1]], [val, val]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    x, y = [val, val], [pos - offsets[0], pos + offsets[1]]</span>
<span class="gi">+                ax.plot(invx(x), invy(y), color=linecolor, linewidth=linewidth)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Plot the main violin body</span>
<span class="gi">+            plot_func = {&quot;x&quot;: ax.fill_betweenx, &quot;y&quot;: ax.fill_between}[self.orient]</span>
<span class="gi">+            plot_func(</span>
<span class="gi">+                inv_val(data[value_var]),</span>
<span class="gi">+                inv_pos(data[self.orient] - offsets[0]),</span>
<span class="gi">+                inv_pos(data[self.orient] + offsets[1]),</span>
<span class="gi">+                **violin[&quot;kwargs&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Adjust the observation data</span>
<span class="gi">+            obs = violin[&quot;observations&quot;]</span>
<span class="gi">+            pos_dict = {self.orient: violin[&quot;position&quot;], &quot;width&quot;: real_width}</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                self._dodge(violin[&quot;sub_vars&quot;], pos_dict)</span>
<span class="gi">+            if gap:</span>
<span class="gi">+                pos_dict[&quot;width&quot;] *= (1 - gap)</span>
<span class="gi">+</span>
<span class="gi">+            # --- Plot the inner components</span>
<span class="gi">+            if inner is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            elif inner.startswith(&quot;point&quot;):</span>
<span class="gi">+                pos = np.array([pos_dict[self.orient]] * len(obs))</span>
<span class="gi">+                if split:</span>
<span class="gi">+                    pos += (-1 if right_side else 1) * pos_dict[&quot;width&quot;] / 2</span>
<span class="gi">+                x, y = (pos, obs) if self.orient == &quot;x&quot; else (obs, pos)</span>
<span class="gi">+                kws = {</span>
<span class="gi">+                    &quot;color&quot;: linecolor,</span>
<span class="gi">+                    &quot;edgecolor&quot;: linecolor,</span>
<span class="gi">+                    &quot;s&quot;: (linewidth * 2) ** 2,</span>
<span class="gi">+                    &quot;zorder&quot;: violin[&quot;kwargs&quot;].get(&quot;zorder&quot;, 2) + 1,</span>
<span class="gi">+                    **inner_kws,</span>
<span class="gi">+                }</span>
<span class="gi">+                ax.scatter(invx(x), invy(y), **kws)</span>
<span class="gi">+</span>
<span class="gi">+            elif inner.startswith(&quot;stick&quot;):</span>
<span class="gi">+                pos0 = np.interp(obs, data[value_var], data[self.orient] - offsets[0])</span>
<span class="gi">+                pos1 = np.interp(obs, data[value_var], data[self.orient] + offsets[1])</span>
<span class="gi">+                pos_pts = np.stack([inv_pos(pos0), inv_pos(pos1)])</span>
<span class="gi">+                val_pts = np.stack([inv_val(obs), inv_val(obs)])</span>
<span class="gi">+                segments = np.stack([pos_pts, val_pts]).transpose(2, 1, 0)</span>
<span class="gi">+                if self.orient == &quot;y&quot;:</span>
<span class="gi">+                    segments = segments[:, :, ::-1]</span>
<span class="gi">+                kws = {</span>
<span class="gi">+                    &quot;color&quot;: linecolor,</span>
<span class="gi">+                    &quot;linewidth&quot;: linewidth / 2,</span>
<span class="gi">+                    **inner_kws,</span>
<span class="gi">+                }</span>
<span class="gi">+                lines = mpl.collections.LineCollection(segments, **kws)</span>
<span class="gi">+                ax.add_collection(lines, autolim=False)</span>
<span class="gi">+</span>
<span class="gi">+            elif inner.startswith(&quot;quart&quot;):</span>
<span class="gi">+                stats = np.percentile(obs, [25, 50, 75])</span>
<span class="gi">+                pos0 = np.interp(stats, data[value_var], data[self.orient] - offsets[0])</span>
<span class="gi">+                pos1 = np.interp(stats, data[value_var], data[self.orient] + offsets[1])</span>
<span class="gi">+                pos_pts = np.stack([inv_pos(pos0), inv_pos(pos1)])</span>
<span class="gi">+                val_pts = np.stack([inv_val(stats), inv_val(stats)])</span>
<span class="gi">+                segments = np.stack([pos_pts, val_pts]).transpose(2, 0, 1)</span>
<span class="gi">+                if self.orient == &quot;y&quot;:</span>
<span class="gi">+                    segments = segments[:, ::-1, :]</span>
<span class="gi">+                dashes = [(1.25, .75), (2.5, 1), (1.25, .75)]</span>
<span class="gi">+                for i, segment in enumerate(segments):</span>
<span class="gi">+                    kws = {</span>
<span class="gi">+                        &quot;color&quot;: linecolor,</span>
<span class="gi">+                        &quot;linewidth&quot;: linewidth,</span>
<span class="gi">+                        &quot;dashes&quot;: dashes[i],</span>
<span class="gi">+                        **inner_kws,</span>
<span class="gi">+                    }</span>
<span class="gi">+                    ax.plot(*segment, **kws)</span>
<span class="gi">+</span>
<span class="gi">+            elif inner.startswith(&quot;box&quot;):</span>
<span class="gi">+                stats = mpl.cbook.boxplot_stats(obs)[0]</span>
<span class="gi">+                pos = np.array(pos_dict[self.orient])</span>
<span class="gi">+                if split:</span>
<span class="gi">+                    pos += (-1 if right_side else 1) * pos_dict[&quot;width&quot;] / 2</span>
<span class="gi">+                pos = [pos, pos], [pos, pos], [pos]</span>
<span class="gi">+                val = (</span>
<span class="gi">+                    [stats[&quot;whislo&quot;], stats[&quot;whishi&quot;]],</span>
<span class="gi">+                    [stats[&quot;q1&quot;], stats[&quot;q3&quot;]],</span>
<span class="gi">+                    [stats[&quot;med&quot;]]</span>
<span class="gi">+                )</span>
<span class="gi">+                if self.orient == &quot;x&quot;:</span>
<span class="gi">+                    (x0, x1, x2), (y0, y1, y2) = pos, val</span>
<span class="gi">+                else:</span>
<span class="gi">+                    (x0, x1, x2), (y0, y1, y2) = val, pos</span>
<span class="gi">+</span>
<span class="gi">+                if split:</span>
<span class="gi">+                    offset = (1 if right_side else -1) * box_width / 72 / 2</span>
<span class="gi">+                    dx, dy = (offset, 0) if self.orient == &quot;x&quot; else (0, -offset)</span>
<span class="gi">+                    trans = ax.transData + mpl.transforms.ScaledTranslation(</span>
<span class="gi">+                        dx, dy, ax.figure.dpi_scale_trans,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    trans = ax.transData</span>
<span class="gi">+                line_kws = {</span>
<span class="gi">+                    &quot;color&quot;: linecolor,</span>
<span class="gi">+                    &quot;transform&quot;: trans,</span>
<span class="gi">+                    **inner_kws,</span>
<span class="gi">+                    &quot;linewidth&quot;: whis_width,</span>
<span class="gi">+                }</span>
<span class="gi">+                ax.plot(invx(x0), invy(y0), **line_kws)</span>
<span class="gi">+                line_kws[&quot;linewidth&quot;] = box_width</span>
<span class="gi">+                ax.plot(invx(x1), invy(y1), **line_kws)</span>
<span class="gi">+                dot_kws = {</span>
<span class="gi">+                    &quot;marker&quot;: marker,</span>
<span class="gi">+                    &quot;markersize&quot;: box_width / 1.2,</span>
<span class="gi">+                    &quot;markeredgewidth&quot;: box_width / 5,</span>
<span class="gi">+                    &quot;transform&quot;: trans,</span>
<span class="gi">+                    **inner_kws,</span>
<span class="gi">+                    &quot;markeredgecolor&quot;: &quot;w&quot;,</span>
<span class="gi">+                    &quot;markerfacecolor&quot;: &quot;w&quot;,</span>
<span class="gi">+                    &quot;color&quot;: linecolor,  # simplify tests</span>
<span class="gi">+                }</span>
<span class="gi">+                ax.plot(invx(x2), invy(y2), **dot_kws)</span>
<span class="gi">+</span>
<span class="gi">+        legend_artist = _get_patch_legend_artist(fill)</span>
<span class="gi">+        common_kws = {**plot_kws, &quot;linewidth&quot;: linewidth, &quot;edgecolor&quot;: linecolor}</span>
<span class="gi">+        self._configure_legend(ax, legend_artist, common_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_points(</span>
<span class="gi">+        self,</span>
<span class="gi">+        aggregator,</span>
<span class="gi">+        markers,</span>
<span class="gi">+        linestyles,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        color,</span>
<span class="gi">+        capsize,</span>
<span class="gi">+        err_kws,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        agg_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+        iter_vars = [&quot;hue&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws = normalize_kwargs(plot_kws, mpl.lines.Line2D)</span>
<span class="gi">+        plot_kws.setdefault(&quot;linewidth&quot;, mpl.rcParams[&quot;lines.linewidth&quot;] * 1.8)</span>
<span class="gi">+        plot_kws.setdefault(&quot;markeredgewidth&quot;, plot_kws[&quot;linewidth&quot;] * 0.75)</span>
<span class="gi">+        plot_kws.setdefault(&quot;markersize&quot;, plot_kws[&quot;linewidth&quot;] * np.sqrt(2 * np.pi))</span>
<span class="gi">+</span>
<span class="gi">+        markers = self._map_prop_with_hue(&quot;marker&quot;, markers, &quot;o&quot;, plot_kws)</span>
<span class="gi">+        linestyles = self._map_prop_with_hue(&quot;linestyle&quot;, linestyles, &quot;-&quot;, plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+        base_positions = self.var_levels[self.orient]</span>
<span class="gi">+        if self.var_types[self.orient] == &quot;categorical&quot;:</span>
<span class="gi">+            min_cat_val = int(self.comp_data[self.orient].min())</span>
<span class="gi">+            max_cat_val = int(self.comp_data[self.orient].max())</span>
<span class="gi">+            base_positions = [i for i in range(min_cat_val, max_cat_val + 1)]</span>
<span class="gi">+</span>
<span class="gi">+        n_hue_levels = 0 if self._hue_map.levels is None else len(self._hue_map.levels)</span>
<span class="gi">+        if dodge is True:</span>
<span class="gi">+            dodge = .025 * n_hue_levels</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=True):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            ori_axis = getattr(ax, f&quot;{self.orient}axis&quot;)</span>
<span class="gi">+            transform, _ = _get_transform_functions(ax, self.orient)</span>
<span class="gi">+            positions = transform(ori_axis.convert_units(base_positions))</span>
<span class="gi">+            agg_data = sub_data if sub_data.empty else (</span>
<span class="gi">+                sub_data</span>
<span class="gi">+                .groupby(self.orient)</span>
<span class="gi">+                .apply(aggregator, agg_var, **groupby_apply_include_groups(False))</span>
<span class="gi">+                .reindex(pd.Index(positions, name=self.orient))</span>
<span class="gi">+                .reset_index()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                hue_idx = self._hue_map.levels.index(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+                step_size = dodge / (n_hue_levels - 1)</span>
<span class="gi">+                offset = -dodge / 2 + step_size * hue_idx</span>
<span class="gi">+                agg_data[self.orient] += offset * self._native_width</span>
<span class="gi">+</span>
<span class="gi">+            self._invert_scale(ax, agg_data)</span>
<span class="gi">+</span>
<span class="gi">+            sub_kws = plot_kws.copy()</span>
<span class="gi">+            sub_kws.update(</span>
<span class="gi">+                marker=markers[sub_vars.get(&quot;hue&quot;)],</span>
<span class="gi">+                linestyle=linestyles[sub_vars.get(&quot;hue&quot;)],</span>
<span class="gi">+                color=self._hue_map(sub_vars[&quot;hue&quot;]) if &quot;hue&quot; in sub_vars else color,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            line, = ax.plot(agg_data[&quot;x&quot;], agg_data[&quot;y&quot;], **sub_kws)</span>
<span class="gi">+</span>
<span class="gi">+            sub_err_kws = err_kws.copy()</span>
<span class="gi">+            line_props = line.properties()</span>
<span class="gi">+            for prop in [&quot;color&quot;, &quot;linewidth&quot;, &quot;alpha&quot;, &quot;zorder&quot;]:</span>
<span class="gi">+                sub_err_kws.setdefault(prop, line_props[prop])</span>
<span class="gi">+            if aggregator.error_method is not None:</span>
<span class="gi">+                self.plot_errorbars(ax, agg_data, capsize, sub_err_kws)</span>
<span class="gi">+</span>
<span class="gi">+        legend_artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+        semantic_kws = {&quot;hue&quot;: {&quot;marker&quot;: markers, &quot;linestyle&quot;: linestyles}}</span>
<span class="gi">+        self._configure_legend(ax, legend_artist, sub_kws, semantic_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_bars(</span>
<span class="gi">+        self,</span>
<span class="gi">+        aggregator,</span>
<span class="gi">+        dodge,</span>
<span class="gi">+        gap,</span>
<span class="gi">+        width,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        color,</span>
<span class="gi">+        capsize,</span>
<span class="gi">+        err_kws,</span>
<span class="gi">+        plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        agg_var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+        iter_vars = [&quot;hue&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax</span>
<span class="gi">+</span>
<span class="gi">+        if self._hue_map.levels is None:</span>
<span class="gi">+            dodge = False</span>
<span class="gi">+</span>
<span class="gi">+        if dodge and capsize is not None:</span>
<span class="gi">+            capsize = capsize / len(self._hue_map.levels)</span>
<span class="gi">+</span>
<span class="gi">+        if not fill:</span>
<span class="gi">+            plot_kws.setdefault(&quot;linewidth&quot;, 1.5 * mpl.rcParams[&quot;lines.linewidth&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        err_kws.setdefault(&quot;linewidth&quot;, 1.5 * mpl.rcParams[&quot;lines.linewidth&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(iter_vars,</span>
<span class="gi">+                                                 from_comp_data=True,</span>
<span class="gi">+                                                 allow_empty=True):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            agg_data = sub_data if sub_data.empty else (</span>
<span class="gi">+                sub_data</span>
<span class="gi">+                .groupby(self.orient)</span>
<span class="gi">+                .apply(aggregator, agg_var, **groupby_apply_include_groups(False))</span>
<span class="gi">+                .reset_index()</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            agg_data[&quot;width&quot;] = width * self._native_width</span>
<span class="gi">+            if dodge:</span>
<span class="gi">+                self._dodge(sub_vars, agg_data)</span>
<span class="gi">+            if gap:</span>
<span class="gi">+                agg_data[&quot;width&quot;] *= 1 - gap</span>
<span class="gi">+</span>
<span class="gi">+            agg_data[&quot;edge&quot;] = agg_data[self.orient] - agg_data[&quot;width&quot;] / 2</span>
<span class="gi">+            self._invert_scale(ax, agg_data)</span>
<span class="gi">+</span>
<span class="gi">+            if self.orient == &quot;x&quot;:</span>
<span class="gi">+                bar_func = ax.bar</span>
<span class="gi">+                kws = dict(</span>
<span class="gi">+                    x=agg_data[&quot;edge&quot;], height=agg_data[&quot;y&quot;], width=agg_data[&quot;width&quot;]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                bar_func = ax.barh</span>
<span class="gi">+                kws = dict(</span>
<span class="gi">+                    y=agg_data[&quot;edge&quot;], width=agg_data[&quot;x&quot;], height=agg_data[&quot;width&quot;]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            main_color = self._hue_map(sub_vars[&quot;hue&quot;]) if &quot;hue&quot; in sub_vars else color</span>
<span class="gi">+</span>
<span class="gi">+            # Set both color and facecolor for property cycle logic</span>
<span class="gi">+            kws[&quot;align&quot;] = &quot;edge&quot;</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                kws.update(color=main_color, facecolor=main_color)</span>
<span class="gi">+            else:</span>
<span class="gi">+                kws.update(color=main_color, edgecolor=main_color, facecolor=&quot;none&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            bar_func(**{**kws, **plot_kws})</span>
<span class="gi">+</span>
<span class="gi">+            if aggregator.error_method is not None:</span>
<span class="gi">+                self.plot_errorbars(</span>
<span class="gi">+                    ax, agg_data, capsize,</span>
<span class="gi">+                    {&quot;color&quot;: &quot;.26&quot; if fill else main_color, **err_kws}</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        legend_artist = _get_patch_legend_artist(fill)</span>
<span class="gi">+        self._configure_legend(ax, legend_artist, plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_errorbars(self, ax, data, capsize, err_kws):</span>
<span class="gi">+</span>
<span class="gi">+        var = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[self.orient]</span>
<span class="gi">+        for row in data.to_dict(&quot;records&quot;):</span>
<span class="gi">+</span>
<span class="gi">+            row = dict(row)</span>
<span class="gi">+            pos = np.array([row[self.orient], row[self.orient]])</span>
<span class="gi">+            val = np.array([row[f&quot;{var}min&quot;], row[f&quot;{var}max&quot;]])</span>
<span class="gi">+</span>
<span class="gi">+            if capsize:</span>
<span class="gi">+</span>
<span class="gi">+                cw = capsize * self._native_width / 2</span>
<span class="gi">+                scl, inv = _get_transform_functions(ax, self.orient)</span>
<span class="gi">+                cap = inv(scl(pos[0]) - cw), inv(scl(pos[1]) + cw)</span>
<span class="gi">+</span>
<span class="gi">+                pos = np.concatenate([</span>
<span class="gi">+                    [*cap, np.nan], pos, [np.nan, *cap]</span>
<span class="gi">+                ])</span>
<span class="gi">+                val = np.concatenate([</span>
<span class="gi">+                    [val[0], val[0], np.nan], val, [np.nan, val[-1], val[-1]],</span>
<span class="gi">+                ])</span>
<span class="gi">+</span>
<span class="gi">+            if self.orient == &quot;x&quot;:</span>
<span class="gi">+                args = pos, val</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = val, pos</span>
<span class="gi">+            ax.plot(*args, **err_kws)</span>


<span class="w"> </span>class _CategoricalAggPlotter(_CategoricalPlotter):
<span class="gd">-    flat_structure = {&#39;x&#39;: &#39;@index&#39;, &#39;y&#39;: &#39;@values&#39;}</span>

<span class="gi">+    flat_structure = {&quot;x&quot;: &quot;@index&quot;, &quot;y&quot;: &quot;@values&quot;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_categorical_docs = dict(</span>

<span class="gd">-_categorical_docs = dict(categorical_narrative=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    See the :ref:`tutorial &lt;categorical_tutorial&gt;` for more information.</span>
<span class="gi">+    # Shared narrative docs</span>
<span class="gi">+    categorical_narrative=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    See the :ref:`tutorial &lt;categorical_tutorial&gt;` for more information.</span>

<span class="w"> </span>    .. note::
<span class="w"> </span>        By default, this function treats one of the variables as categorical
<span class="w"> </span>        and draws data at ordinal positions (0, 1, ... n) on the relevant axis.
<span class="w"> </span>        As of version 0.13.0, this can be disabled by setting `native_scale=True`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ), input_params=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    x, y, hue : names of variables in `data` or vector data</span>
<span class="gd">-        Inputs for plotting long-form data. See examples for interpretation.    &quot;&quot;&quot;</span>
<span class="gd">-    ), categorical_data=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    data : DataFrame, Series, dict, array, or list of arrays</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+</span>
<span class="gi">+    # Shared function parameters</span>
<span class="gi">+    input_params=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    x, y, hue : names of variables in `data` or vector data</span>
<span class="gi">+        Inputs for plotting long-form data. See examples for interpretation.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    categorical_data=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    data : DataFrame, Series, dict, array, or list of arrays</span>
<span class="w"> </span>        Dataset for plotting. If `x` and `y` are absent, this is
<span class="gd">-        interpreted as wide-form. Otherwise it is expected to be long-form.    &quot;&quot;&quot;</span>
<span class="gd">-    ), order_vars=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    order, hue_order : lists of strings</span>
<span class="gi">+        interpreted as wide-form. Otherwise it is expected to be long-form.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    order_vars=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    order, hue_order : lists of strings</span>
<span class="w"> </span>        Order to plot the categorical levels in; otherwise the levels are
<span class="gd">-        inferred from the data objects.    &quot;&quot;&quot;</span>
<span class="gd">-    ), stat_api_params=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    estimator : string or callable that maps vector -&gt; scalar</span>
<span class="gi">+        inferred from the data objects.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    stat_api_params=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    estimator : string or callable that maps vector -&gt; scalar</span>
<span class="w"> </span>        Statistical function to estimate within each categorical bin.
<span class="w"> </span>    errorbar : string, (string, number) tuple, callable or None
<span class="w"> </span>        Name of errorbar method (either &quot;ci&quot;, &quot;pi&quot;, &quot;se&quot;, or &quot;sd&quot;), or a tuple
<span class="gu">@@ -175,150 +1405,253 @@ _categorical_docs = dict(categorical_narrative=dedent(</span>
<span class="w"> </span>        Data values or column used to compute weighted statistics.
<span class="w"> </span>        Note that the use of weights may limit other statistical options.

<span class="gd">-        .. versionadded:: v0.13.1    &quot;&quot;&quot;</span>
<span class="gd">-    ), ci=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    ci : float</span>
<span class="gi">+        .. versionadded:: v0.13.1\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    ci=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    ci : float</span>
<span class="w"> </span>        Level of the confidence interval to show, in [0, 100].

<span class="w"> </span>        .. deprecated:: v0.12.0
<span class="gd">-            Use `errorbar=(&quot;ci&quot;, ...)`.    &quot;&quot;&quot;</span>
<span class="gd">-    ), orient=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    orient : &quot;v&quot; | &quot;h&quot; | &quot;x&quot; | &quot;y&quot;</span>
<span class="gi">+            Use `errorbar=(&quot;ci&quot;, ...)`.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    orient=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    orient : &quot;v&quot; | &quot;h&quot; | &quot;x&quot; | &quot;y&quot;</span>
<span class="w"> </span>        Orientation of the plot (vertical or horizontal). This is usually
<span class="w"> </span>        inferred based on the type of the input variables, but it can be used
<span class="w"> </span>        to resolve ambiguity when both `x` and `y` are numeric or when
<span class="w"> </span>        plotting wide-form data.

<span class="w"> </span>        .. versionchanged:: v0.13.0
<span class="gd">-            Added &#39;x&#39;/&#39;y&#39; as options, equivalent to &#39;v&#39;/&#39;h&#39;.    &quot;&quot;&quot;</span>
<span class="gd">-    ), color=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    color : matplotlib color</span>
<span class="gd">-        Single color for the elements in the plot.    &quot;&quot;&quot;</span>
<span class="gd">-    ), palette=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    palette : palette name, list, dict, or :class:`matplotlib.colors.Colormap`</span>
<span class="gi">+            Added &#39;x&#39;/&#39;y&#39; as options, equivalent to &#39;v&#39;/&#39;h&#39;.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    color=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    color : matplotlib color</span>
<span class="gi">+        Single color for the elements in the plot.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    palette=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    palette : palette name, list, dict, or :class:`matplotlib.colors.Colormap`</span>
<span class="w"> </span>        Color palette that maps the hue variable. If the palette is a dictionary,
<span class="w"> </span>        keys should be names of levels and values should be matplotlib colors.
<span class="gd">-        The type/value will sometimes force a qualitative/quantitative mapping.    &quot;&quot;&quot;</span>
<span class="gd">-    ), hue_norm=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    hue_norm : tuple or :class:`matplotlib.colors.Normalize` object</span>
<span class="gi">+        The type/value will sometimes force a qualitative/quantitative mapping.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    hue_norm=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    hue_norm : tuple or :class:`matplotlib.colors.Normalize` object</span>
<span class="w"> </span>        Normalization in data units for colormap applied to the `hue`
<span class="w"> </span>        variable when it is numeric. Not relevant if `hue` is categorical.

<span class="gd">-        .. versionadded:: v0.12.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), saturation=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    saturation : float</span>
<span class="gi">+        .. versionadded:: v0.12.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    saturation=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    saturation : float</span>
<span class="w"> </span>        Proportion of the original saturation to draw fill colors in. Large
<span class="w"> </span>        patches often look better with desaturated colors, but set this to
<span class="gd">-        `1` if you want the colors to perfectly match the input values.    &quot;&quot;&quot;</span>
<span class="gd">-    ), capsize=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    capsize : float</span>
<span class="gd">-        Width of the &quot;caps&quot; on error bars, relative to bar spacing.    &quot;&quot;&quot;</span>
<span class="gd">-    ), errcolor=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    errcolor : matplotlib color</span>
<span class="gi">+        `1` if you want the colors to perfectly match the input values.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    capsize=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    capsize : float</span>
<span class="gi">+        Width of the &quot;caps&quot; on error bars, relative to bar spacing.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    errcolor=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    errcolor : matplotlib color</span>
<span class="w"> </span>        Color used for the error bar lines.

<span class="w"> </span>        .. deprecated:: 0.13.0
<span class="gd">-            Use `err_kws={&#39;color&#39;: ...}`.    &quot;&quot;&quot;</span>
<span class="gd">-    ), errwidth=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    errwidth : float</span>
<span class="gi">+            Use `err_kws={&#39;color&#39;: ...}`.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    errwidth=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    errwidth : float</span>
<span class="w"> </span>        Thickness of error bar lines (and caps), in points.

<span class="w"> </span>        .. deprecated:: 0.13.0
<span class="gd">-            Use `err_kws={&#39;linewidth&#39;: ...}`.    &quot;&quot;&quot;</span>
<span class="gd">-    ), fill=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    fill : bool</span>
<span class="gi">+            Use `err_kws={&#39;linewidth&#39;: ...}`.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    fill=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    fill : bool</span>
<span class="w"> </span>        If True, use a solid patch. Otherwise, draw as line art.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), gap=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    gap : float</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    gap=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    gap : float</span>
<span class="w"> </span>        Shrink on the orient axis by this factor to add a gap between dodged elements.

<span class="gd">-        .. versionadded:: 0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), width=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    width : float</span>
<span class="gi">+        .. versionadded:: 0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    width=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    width : float</span>
<span class="w"> </span>        Width allotted to each element on the orient axis. When `native_scale=True`,
<span class="gd">-        it is relative to the minimum distance between two values in the native scale.    &quot;&quot;&quot;</span>
<span class="gd">-    ), dodge=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    dodge : &quot;auto&quot; or bool</span>
<span class="gi">+        it is relative to the minimum distance between two values in the native scale.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    dodge=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    dodge : &quot;auto&quot; or bool</span>
<span class="w"> </span>        When hue mapping is used, whether elements should be narrowed and shifted along
<span class="w"> </span>        the orient axis to eliminate overlap. If `&quot;auto&quot;`, set to `True` when the
<span class="w"> </span>        orient variable is crossed with the categorical variable or `False` otherwise.

<span class="w"> </span>        .. versionchanged:: 0.13.0

<span class="gd">-            Added `&quot;auto&quot;` mode as a new default.    &quot;&quot;&quot;</span>
<span class="gd">-    ), linewidth=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    linewidth : float</span>
<span class="gd">-        Width of the lines that frame the plot elements.    &quot;&quot;&quot;</span>
<span class="gd">-    ), linecolor=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    linecolor : color</span>
<span class="gi">+            Added `&quot;auto&quot;` mode as a new default.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    linewidth=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    linewidth : float</span>
<span class="gi">+        Width of the lines that frame the plot elements.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    linecolor=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    linecolor : color</span>
<span class="w"> </span>        Color to use for line elements, when `fill` is True.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), log_scale=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    log_scale : bool or number, or pair of bools or numbers</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    log_scale=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    log_scale : bool or number, or pair of bools or numbers</span>
<span class="w"> </span>        Set axis scale(s) to log. A single value sets the data axis for any numeric
<span class="w"> </span>        axes in the plot. A pair of values sets each axis independently.
<span class="w"> </span>        Numeric values are interpreted as the desired base (default 10).
<span class="w"> </span>        When `None` or `False`, seaborn defers to the existing Axes scale.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), native_scale=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    native_scale : bool</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    native_scale=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    native_scale : bool</span>
<span class="w"> </span>        When True, numeric or datetime values on the categorical axis will maintain
<span class="w"> </span>        their original scaling rather than being converted to fixed indices.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), formatter=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    formatter : callable</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    formatter=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    formatter : callable</span>
<span class="w"> </span>        Function for converting categorical data into strings. Affects both grouping
<span class="w"> </span>        and tick labels.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), legend=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    legend : &quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;, or False</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    legend=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    legend : &quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;, or False</span>
<span class="w"> </span>        How to draw the legend. If &quot;brief&quot;, numeric `hue` and `size`
<span class="w"> </span>        variables will be represented with a sample of evenly spaced values.
<span class="w"> </span>        If &quot;full&quot;, every group will get an entry in the legend. If &quot;auto&quot;,
<span class="w"> </span>        choose between brief or full representation based on number of levels.
<span class="w"> </span>        If `False`, no legend data is added and no legend is drawn.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), err_kws=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    err_kws : dict</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    err_kws=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    err_kws : dict</span>
<span class="w"> </span>        Parameters of :class:`matplotlib.lines.Line2D`, for the error bar artists.

<span class="gd">-        .. versionadded:: v0.13.0    &quot;&quot;&quot;</span>
<span class="gd">-    ), ax_in=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    ax : matplotlib Axes</span>
<span class="gd">-        Axes object to draw the plot onto, otherwise uses the current Axes.    &quot;&quot;&quot;</span>
<span class="gd">-    ), ax_out=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    ax : matplotlib Axes</span>
<span class="gd">-        Returns the Axes object with the plot drawn onto it.    &quot;&quot;&quot;</span>
<span class="gd">-    ), boxplot=dedent(</span>
<span class="gd">-    &#39;    boxplot : A traditional box-and-whisker plot with a similar API.    &#39;</span>
<span class="gd">-    ), violinplot=dedent(</span>
<span class="gd">-    &#39;    violinplot : A combination of boxplot and kernel density estimation.    &#39;</span>
<span class="gd">-    ), stripplot=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    stripplot : A scatterplot where one variable is categorical. Can be used</span>
<span class="gd">-                in conjunction with other plots to show each observation.    &quot;&quot;&quot;</span>
<span class="gd">-    ), swarmplot=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    swarmplot : A categorical scatterplot where the points do not overlap. Can</span>
<span class="gd">-                be used with other plots to show each observation.    &quot;&quot;&quot;</span>
<span class="gd">-    ), barplot=dedent(</span>
<span class="gd">-    &#39;    barplot : Show point estimates and confidence intervals using bars.    &#39;</span>
<span class="gd">-    ), countplot=dedent(</span>
<span class="gd">-    &#39;    countplot : Show the counts of observations in each categorical bin.    &#39;</span>
<span class="gd">-    ), pointplot=dedent(</span>
<span class="gd">-    &#39;    pointplot : Show point estimates and confidence intervals using dots.    &#39;</span>
<span class="gd">-    ), catplot=dedent(</span>
<span class="gd">-    &#39;    catplot : Combine a categorical plot with a :class:`FacetGrid`.    &#39;</span>
<span class="gd">-    ), boxenplot=dedent(</span>
<span class="gd">-    &#39;    boxenplot : An enhanced boxplot for larger datasets.    &#39;))</span>
<span class="gi">+        .. versionadded:: v0.13.0\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    ax_in=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    ax : matplotlib Axes</span>
<span class="gi">+        Axes object to draw the plot onto, otherwise uses the current Axes.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    ax_out=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    ax : matplotlib Axes</span>
<span class="gi">+        Returns the Axes object with the plot drawn onto it.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+</span>
<span class="gi">+    # Shared see also</span>
<span class="gi">+    boxplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    boxplot : A traditional box-and-whisker plot with a similar API.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    violinplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    violinplot : A combination of boxplot and kernel density estimation.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    stripplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    stripplot : A scatterplot where one variable is categorical. Can be used</span>
<span class="gi">+                in conjunction with other plots to show each observation.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    swarmplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    swarmplot : A categorical scatterplot where the points do not overlap. Can</span>
<span class="gi">+                be used with other plots to show each observation.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    barplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    barplot : Show point estimates and confidence intervals using bars.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    countplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    countplot : Show the counts of observations in each categorical bin.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    pointplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    pointplot : Show point estimates and confidence intervals using dots.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    catplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    catplot : Combine a categorical plot with a :class:`FacetGrid`.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    boxenplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    boxenplot : An enhanced boxplot for larger datasets.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>_categorical_docs.update(_facet_docs)
<span class="gd">-boxplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Draw a box plot to show distributions with respect to categories.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def boxplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    orient=None, color=None, palette=None, saturation=.75, fill=True,</span>
<span class="gi">+    dodge=&quot;auto&quot;, width=.8, gap=0, whis=1.5, linecolor=&quot;auto&quot;, linewidth=None,</span>
<span class="gi">+    fliersize=None, hue_norm=None, native_scale=False, log_scale=None, formatter=None,</span>
<span class="gi">+    legend=&quot;auto&quot;, ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        # Needs to be before scale_categorical changes the coordinate series dtype</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = saturation if fill else 1</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+    color = _default_color(</span>
<span class="gi">+        ax.fill_between, hue, color,</span>
<span class="gi">+        {k: v for k, v in kwargs.items() if k in [&quot;c&quot;, &quot;color&quot;, &quot;fc&quot;, &quot;facecolor&quot;]},</span>
<span class="gi">+        saturation=saturation,</span>
<span class="gi">+    )</span>
<span class="gi">+    linecolor = p._complement_color(linecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_boxes(</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        gap=gap,</span>
<span class="gi">+        fill=fill,</span>
<span class="gi">+        whis=whis,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        linecolor=linecolor,</span>
<span class="gi">+        linewidth=linewidth,</span>
<span class="gi">+        fliersize=fliersize,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+boxplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Draw a box plot to show distributions with respect to categories.</span>

<span class="w"> </span>    A box plot (or box-and-whisker plot) shows the distribution of quantitative
<span class="w"> </span>    data in a way that facilitates comparisons between variables or across
<span class="gu">@@ -375,10 +1708,90 @@ boxplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/boxplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-violinplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Draw a patch representing a KDE and add observations or box plot statistics.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def violinplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    orient=None, color=None, palette=None, saturation=.75, fill=True,</span>
<span class="gi">+    inner=&quot;box&quot;, split=False, width=.8, dodge=&quot;auto&quot;, gap=0,</span>
<span class="gi">+    linewidth=None, linecolor=&quot;auto&quot;, cut=2, gridsize=100,</span>
<span class="gi">+    bw_method=&quot;scott&quot;, bw_adjust=1, density_norm=&quot;area&quot;, common_norm=False,</span>
<span class="gi">+    hue_norm=None, formatter=None, log_scale=None, native_scale=False,</span>
<span class="gi">+    legend=&quot;auto&quot;, scale=deprecated, scale_hue=deprecated, bw=deprecated,</span>
<span class="gi">+    inner_kws=None, ax=None, **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        # Needs to be before scale_categorical changes the coordinate series dtype</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = saturation if fill else 1</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+    color = _default_color(</span>
<span class="gi">+        ax.fill_between, hue, color,</span>
<span class="gi">+        {k: v for k, v in kwargs.items() if k in [&quot;c&quot;, &quot;color&quot;, &quot;fc&quot;, &quot;facecolor&quot;]},</span>
<span class="gi">+        saturation=saturation,</span>
<span class="gi">+    )</span>
<span class="gi">+    linecolor = p._complement_color(linecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+    density_norm, common_norm = p._violin_scale_backcompat(</span>
<span class="gi">+        scale, scale_hue, density_norm, common_norm,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    bw_method = p._violin_bw_backcompat(bw, bw_method)</span>
<span class="gi">+    kde_kws = dict(cut=cut, gridsize=gridsize, bw_method=bw_method, bw_adjust=bw_adjust)</span>
<span class="gi">+    inner_kws = {} if inner_kws is None else inner_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_violins(</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        gap=gap,</span>
<span class="gi">+        split=split,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        fill=fill,</span>
<span class="gi">+        linecolor=linecolor,</span>
<span class="gi">+        linewidth=linewidth,</span>
<span class="gi">+        inner=inner,</span>
<span class="gi">+        density_norm=density_norm,</span>
<span class="gi">+        common_norm=common_norm,</span>
<span class="gi">+        kde_kws=kde_kws,</span>
<span class="gi">+        inner_kws=inner_kws,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+violinplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Draw a patch representing a KDE and add observations or box plot statistics.</span>

<span class="w"> </span>    A violin plot plays a similar role as a box-and-whisker plot. It shows the
<span class="w"> </span>    distribution of data points after grouping by one (or more) variables.
<span class="gu">@@ -485,10 +1898,87 @@ violinplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/violinplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-boxenplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Draw an enhanced box plot for larger datasets.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def boxenplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    orient=None, color=None, palette=None, saturation=.75, fill=True,</span>
<span class="gi">+    dodge=&quot;auto&quot;, width=.8, gap=0, linewidth=None, linecolor=None,</span>
<span class="gi">+    width_method=&quot;exponential&quot;, k_depth=&quot;tukey&quot;, outlier_prop=0.007, trust_alpha=0.05,</span>
<span class="gi">+    showfliers=True, hue_norm=None, log_scale=None, native_scale=False, formatter=None,</span>
<span class="gi">+    legend=&quot;auto&quot;, scale=deprecated, box_kws=None, flier_kws=None, line_kws=None,</span>
<span class="gi">+    ax=None, **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        # Needs to be before scale_categorical changes the coordinate series dtype</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    # Longer-term deprecations</span>
<span class="gi">+    width_method = p._boxen_scale_backcompat(scale, width_method)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = saturation if fill else 1</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+    color = _default_color(</span>
<span class="gi">+        ax.fill_between, hue, color,</span>
<span class="gi">+        {},  # TODO how to get default color?</span>
<span class="gi">+        # {k: v for k, v in kwargs.items() if k in [&quot;c&quot;, &quot;color&quot;, &quot;fc&quot;, &quot;facecolor&quot;]},</span>
<span class="gi">+        saturation=saturation,</span>
<span class="gi">+    )</span>
<span class="gi">+    linecolor = p._complement_color(linecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_boxens(</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        gap=gap,</span>
<span class="gi">+        fill=fill,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        linecolor=linecolor,</span>
<span class="gi">+        linewidth=linewidth,</span>
<span class="gi">+        width_method=width_method,</span>
<span class="gi">+        k_depth=k_depth,</span>
<span class="gi">+        outlier_prop=outlier_prop,</span>
<span class="gi">+        trust_alpha=trust_alpha,</span>
<span class="gi">+        showfliers=showfliers,</span>
<span class="gi">+        box_kws=box_kws,</span>
<span class="gi">+        flier_kws=flier_kws,</span>
<span class="gi">+        line_kws=line_kws,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+boxenplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Draw an enhanced box plot for larger datasets.</span>

<span class="w"> </span>    This style of plot was originally named a &quot;letter value&quot; plot because it
<span class="w"> </span>    shows a large number of quantiles that are defined as &quot;letter values&quot;.  It
<span class="gu">@@ -578,10 +2068,72 @@ boxenplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/boxenplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-stripplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Draw a categorical scatterplot using jitter to reduce overplotting.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stripplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    jitter=True, dodge=False, orient=None, color=None, palette=None,</span>
<span class="gi">+    size=5, edgecolor=default, linewidth=0,</span>
<span class="gi">+    hue_norm=None, log_scale=None, native_scale=False, formatter=None, legend=&quot;auto&quot;,</span>
<span class="gi">+    ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    color = _default_color(ax.scatter, hue, color, kwargs)</span>
<span class="gi">+    edgecolor = p._complement_color(edgecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;zorder&quot;, 3)</span>
<span class="gi">+    size = kwargs.get(&quot;s&quot;, size)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.update(</span>
<span class="gi">+        s=size ** 2,</span>
<span class="gi">+        edgecolor=edgecolor,</span>
<span class="gi">+        linewidth=linewidth,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_strips(</span>
<span class="gi">+        jitter=jitter,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # XXX this happens inside a plotting method in the distribution plots</span>
<span class="gi">+    # but maybe it&#39;s better out here? Alternatively, we have an open issue</span>
<span class="gi">+    # suggesting that _attach could add default axes labels, which seems smart.</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+stripplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Draw a categorical scatterplot using jitter to reduce overplotting.</span>

<span class="w"> </span>    A strip plot can be drawn on its own, but it is also a good complement
<span class="w"> </span>    to a box or violin plot in cases where you want to show all observations
<span class="gu">@@ -641,10 +2193,75 @@ stripplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/stripplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-swarmplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Draw a categorical scatterplot with points adjusted to be non-overlapping.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def swarmplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    dodge=False, orient=None, color=None, palette=None,</span>
<span class="gi">+    size=5, edgecolor=None, linewidth=0, hue_norm=None, log_scale=None,</span>
<span class="gi">+    native_scale=False, formatter=None, legend=&quot;auto&quot;, warn_thresh=.05,</span>
<span class="gi">+    ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    color = _default_color(ax.scatter, hue, color, kwargs)</span>
<span class="gi">+    edgecolor = p._complement_color(edgecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;zorder&quot;, 3)</span>
<span class="gi">+    size = kwargs.get(&quot;s&quot;, size)</span>
<span class="gi">+</span>
<span class="gi">+    if linewidth is None:</span>
<span class="gi">+        linewidth = size / 10</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.update(dict(</span>
<span class="gi">+        s=size ** 2,</span>
<span class="gi">+        edgecolor=edgecolor,</span>
<span class="gi">+        linewidth=linewidth,</span>
<span class="gi">+    ))</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_swarms(</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        warn_thresh=warn_thresh,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+swarmplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Draw a categorical scatterplot with points adjusted to be non-overlapping.</span>

<span class="w"> </span>    This function is similar to :func:`stripplot`, but the points are adjusted
<span class="w"> </span>    (only along the categorical axis) so that they don&#39;t overlap. This gives a
<span class="gu">@@ -702,10 +2319,84 @@ swarmplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/swarmplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-barplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Show point estimates and errors as rectangular bars.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def barplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    estimator=&quot;mean&quot;, errorbar=(&quot;ci&quot;, 95), n_boot=1000, seed=None, units=None,</span>
<span class="gi">+    weights=None, orient=None, color=None, palette=None, saturation=.75,</span>
<span class="gi">+    fill=True, hue_norm=None, width=.8, dodge=&quot;auto&quot;, gap=0, log_scale=None,</span>
<span class="gi">+    native_scale=False, formatter=None, legend=&quot;auto&quot;, capsize=0, err_kws=None,</span>
<span class="gi">+    ci=deprecated, errcolor=deprecated, errwidth=deprecated, ax=None, **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    errorbar = utils._deprecate_ci(errorbar, ci)</span>
<span class="gi">+</span>
<span class="gi">+    # Be backwards compatible with len passed directly, which</span>
<span class="gi">+    # does not work in Series.agg (maybe a pandas bug?)</span>
<span class="gi">+    if estimator is len:</span>
<span class="gi">+        estimator = &quot;size&quot;</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalAggPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, units=units, weight=weights),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        # Needs to be before scale_categorical changes the coordinate series dtype</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = saturation if fill else 1</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+    color = _default_color(ax.bar, hue, color, kwargs, saturation=saturation)</span>
<span class="gi">+</span>
<span class="gi">+    agg_cls = WeightedAggregator if &quot;weight&quot; in p.plot_data else EstimateAggregator</span>
<span class="gi">+    aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)</span>
<span class="gi">+    err_kws = {} if err_kws is None else normalize_kwargs(err_kws, mpl.lines.Line2D)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.15.0.</span>
<span class="gi">+    err_kws, capsize = p._err_kws_backcompat(err_kws, errcolor, errwidth, capsize)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_bars(</span>
<span class="gi">+        aggregator=aggregator,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        gap=gap,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        fill=fill,</span>
<span class="gi">+        capsize=capsize,</span>
<span class="gi">+        err_kws=err_kws,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+barplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Show point estimates and errors as rectangular bars.</span>

<span class="w"> </span>    A bar plot represents an aggregate or statistical estimate for a numeric
<span class="w"> </span>    variable with the height of each rectangle and indicates the uncertainty
<span class="gu">@@ -770,10 +2461,77 @@ barplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/barplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-pointplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Show point estimates and errors using lines with markers.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pointplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    estimator=&quot;mean&quot;, errorbar=(&quot;ci&quot;, 95), n_boot=1000, seed=None, units=None,</span>
<span class="gi">+    weights=None, color=None, palette=None, hue_norm=None, markers=default,</span>
<span class="gi">+    linestyles=default, dodge=False, log_scale=None, native_scale=False,</span>
<span class="gi">+    orient=None, capsize=0, formatter=None, legend=&quot;auto&quot;, err_kws=None,</span>
<span class="gi">+    ci=deprecated, errwidth=deprecated, join=deprecated, scale=deprecated,</span>
<span class="gi">+    ax=None, **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    errorbar = utils._deprecate_ci(errorbar, ci)</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalAggPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, units=units, weight=weights),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        # Handle special backwards compatibility where pointplot originally</span>
<span class="gi">+        # did *not* default to multi-colored unless a palette was specified.</span>
<span class="gi">+        color=&quot;C0&quot; if (color is None and palette is None) else color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    color = _default_color(ax.plot, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    agg_cls = WeightedAggregator if &quot;weight&quot; in p.plot_data else EstimateAggregator</span>
<span class="gi">+    aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)</span>
<span class="gi">+    err_kws = {} if err_kws is None else normalize_kwargs(err_kws, mpl.lines.Line2D)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.15.0.</span>
<span class="gi">+    p._point_kwargs_backcompat(scale, join, kwargs)</span>
<span class="gi">+    err_kws, capsize = p._err_kws_backcompat(err_kws, None, errwidth, capsize)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_points(</span>
<span class="gi">+        aggregator=aggregator,</span>
<span class="gi">+        markers=markers,</span>
<span class="gi">+        linestyles=linestyles,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        capsize=capsize,</span>
<span class="gi">+        err_kws=err_kws,</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+pointplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Show point estimates and errors using lines with markers.</span>

<span class="w"> </span>    A point plot represents an estimate of central tendency for a numeric
<span class="w"> </span>    variable by the position of the dot and provides some indication of the
<span class="gu">@@ -851,10 +2609,89 @@ pointplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/pointplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-countplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Show the counts of observations in each categorical bin using bars.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def countplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,</span>
<span class="gi">+    orient=None, color=None, palette=None, saturation=.75, fill=True, hue_norm=None,</span>
<span class="gi">+    stat=&quot;count&quot;, width=.8, dodge=&quot;auto&quot;, gap=0, log_scale=None, native_scale=False,</span>
<span class="gi">+    formatter=None, legend=&quot;auto&quot;, ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    if x is None and y is not None:</span>
<span class="gi">+        orient = &quot;y&quot;</span>
<span class="gi">+        x = 1 if list(y) else None</span>
<span class="gi">+    elif x is not None and y is None:</span>
<span class="gi">+        orient = &quot;x&quot;</span>
<span class="gi">+        y = 1 if list(x) else None</span>
<span class="gi">+    elif x is not None and y is not None:</span>
<span class="gi">+        raise TypeError(&quot;Cannot pass values for both `x` and `y`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    p = _CategoricalAggPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if p.plot_data.empty:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        # Needs to be before scale_categorical changes the coordinate series dtype</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if p.var_types.get(p.orient) == &quot;categorical&quot; or not native_scale:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = saturation if fill else 1</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+    color = _default_color(ax.bar, hue, color, kwargs, saturation)</span>
<span class="gi">+</span>
<span class="gi">+    count_axis = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[p.orient]</span>
<span class="gi">+    if p.input_format == &quot;wide&quot;:</span>
<span class="gi">+        p.plot_data[count_axis] = 1</span>
<span class="gi">+</span>
<span class="gi">+    _check_argument(&quot;stat&quot;, [&quot;count&quot;, &quot;percent&quot;, &quot;probability&quot;, &quot;proportion&quot;], stat)</span>
<span class="gi">+    p.variables[count_axis] = stat</span>
<span class="gi">+    if stat != &quot;count&quot;:</span>
<span class="gi">+        denom = 100 if stat == &quot;percent&quot; else 1</span>
<span class="gi">+        p.plot_data[count_axis] /= len(p.plot_data) / denom</span>
<span class="gi">+</span>
<span class="gi">+    aggregator = EstimateAggregator(&quot;sum&quot;, errorbar=None)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_bars(</span>
<span class="gi">+        aggregator=aggregator,</span>
<span class="gi">+        dodge=dodge,</span>
<span class="gi">+        width=width,</span>
<span class="gi">+        gap=gap,</span>
<span class="gi">+        color=color,</span>
<span class="gi">+        fill=fill,</span>
<span class="gi">+        capsize=0,</span>
<span class="gi">+        err_kws={},</span>
<span class="gi">+        plot_kws=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p._add_axis_labels(ax)</span>
<span class="gi">+    p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+countplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Show the counts of observations in each categorical bin using bars.</span>

<span class="w"> </span>    A count plot can be thought of as a histogram across a categorical, instead
<span class="w"> </span>    of quantitative, variable. The basic API and options are identical to those
<span class="gu">@@ -904,10 +2741,401 @@ countplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/countplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gd">-catplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Figure-level interface for drawing categorical plots onto a FacetGrid.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def catplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, row=None, col=None, kind=&quot;strip&quot;,</span>
<span class="gi">+    estimator=&quot;mean&quot;, errorbar=(&quot;ci&quot;, 95), n_boot=1000, seed=None, units=None,</span>
<span class="gi">+    weights=None, order=None, hue_order=None, row_order=None, col_order=None,</span>
<span class="gi">+    col_wrap=None, height=5, aspect=1, log_scale=None, native_scale=False,</span>
<span class="gi">+    formatter=None, orient=None, color=None, palette=None, hue_norm=None,</span>
<span class="gi">+    legend=&quot;auto&quot;, legend_out=True, sharex=True, sharey=True,</span>
<span class="gi">+    margin_titles=False, facet_kws=None, ci=deprecated, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    # Check for attempt to plot onto specific axes and warn</span>
<span class="gi">+    if &quot;ax&quot; in kwargs:</span>
<span class="gi">+        msg = (&quot;catplot is a figure-level function and does not accept &quot;</span>
<span class="gi">+               f&quot;target axes. You may wish to try {kind}plot&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning)</span>
<span class="gi">+        kwargs.pop(&quot;ax&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    desaturated_kinds = [&quot;bar&quot;, &quot;count&quot;, &quot;box&quot;, &quot;violin&quot;, &quot;boxen&quot;]</span>
<span class="gi">+    undodged_kinds = [&quot;strip&quot;, &quot;swarm&quot;, &quot;point&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if kind in [&quot;bar&quot;, &quot;point&quot;, &quot;count&quot;]:</span>
<span class="gi">+        Plotter = _CategoricalAggPlotter</span>
<span class="gi">+    else:</span>
<span class="gi">+        Plotter = _CategoricalPlotter</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;count&quot;:</span>
<span class="gi">+        if x is None and y is not None:</span>
<span class="gi">+            orient = &quot;y&quot;</span>
<span class="gi">+            x = 1</span>
<span class="gi">+        elif x is not None and y is None:</span>
<span class="gi">+            orient = &quot;x&quot;</span>
<span class="gi">+            y = 1</span>
<span class="gi">+        elif x is not None and y is not None:</span>
<span class="gi">+            raise ValueError(&quot;Cannot pass values for both `x` and `y`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    p = Plotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(</span>
<span class="gi">+            x=x, y=y, hue=hue, row=row, col=col, units=units, weight=weights</span>
<span class="gi">+        ),</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        orient=orient,</span>
<span class="gi">+        # Handle special backwards compatibility where pointplot originally</span>
<span class="gi">+        # did *not* default to multi-colored unless a palette was specified.</span>
<span class="gi">+        color=&quot;C0&quot; if kind == &quot;point&quot; and palette is None and color is None else color,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    for var in [&quot;row&quot;, &quot;col&quot;]:</span>
<span class="gi">+        # Handle faceting variables that lack name information</span>
<span class="gi">+        if var in p.variables and p.variables[var] is None:</span>
<span class="gi">+            p.variables[var] = f&quot;_{var}_&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Adapt the plot_data dataframe for use with FacetGrid</span>
<span class="gi">+    facet_data = p.plot_data.rename(columns=p.variables)</span>
<span class="gi">+    facet_data = facet_data.loc[:, ~facet_data.columns.duplicated()]</span>
<span class="gi">+</span>
<span class="gi">+    col_name = p.variables.get(&quot;col&quot;, None)</span>
<span class="gi">+    row_name = p.variables.get(&quot;row&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if facet_kws is None:</span>
<span class="gi">+        facet_kws = {}</span>
<span class="gi">+</span>
<span class="gi">+    g = FacetGrid(</span>
<span class="gi">+        data=facet_data, row=row_name, col=col_name, col_wrap=col_wrap,</span>
<span class="gi">+        row_order=row_order, col_order=col_order, sharex=sharex, sharey=sharey,</span>
<span class="gi">+        legend_out=legend_out, margin_titles=margin_titles,</span>
<span class="gi">+        height=height, aspect=aspect,</span>
<span class="gi">+        **facet_kws,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Capture this here because scale_categorical is going to insert a (null)</span>
<span class="gi">+    # x variable even if it is empty. It&#39;s not clear whether that needs to</span>
<span class="gi">+    # happen or if disabling that is the cleaner solution.</span>
<span class="gi">+    has_xy_data = p.has_xy_data</span>
<span class="gi">+</span>
<span class="gi">+    if not native_scale or p.var_types[p.orient] == &quot;categorical&quot;:</span>
<span class="gi">+        p.scale_categorical(p.orient, order=order, formatter=formatter)</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(g, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    if not has_xy_data:</span>
<span class="gi">+        return g</span>
<span class="gi">+</span>
<span class="gi">+    # Deprecations to remove in v0.14.0.</span>
<span class="gi">+    hue_order = p._palette_without_hue_backcompat(palette, hue_order)</span>
<span class="gi">+    palette, hue_order = p._hue_backcompat(color, palette, hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    # Othe deprecations</span>
<span class="gi">+    errorbar = utils._deprecate_ci(errorbar, ci)</span>
<span class="gi">+</span>
<span class="gi">+    saturation = kwargs.pop(</span>
<span class="gi">+        &quot;saturation&quot;,</span>
<span class="gi">+        0.75 if kind in desaturated_kinds and kwargs.get(&quot;fill&quot;, True) else 1</span>
<span class="gi">+    )</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)</span>
<span class="gi">+</span>
<span class="gi">+    # Set a default color</span>
<span class="gi">+    # Otherwise each artist will be plotted separately and trip the color cycle</span>
<span class="gi">+    if hue is None:</span>
<span class="gi">+        color = &quot;C0&quot; if color is None else color</span>
<span class="gi">+        if saturation &lt; 1:</span>
<span class="gi">+            color = desaturate(color, saturation)</span>
<span class="gi">+</span>
<span class="gi">+    if kind in [&quot;strip&quot;, &quot;swarm&quot;]:</span>
<span class="gi">+        kwargs = normalize_kwargs(kwargs, mpl.collections.PathCollection)</span>
<span class="gi">+        kwargs[&quot;edgecolor&quot;] = p._complement_color(</span>
<span class="gi">+            kwargs.pop(&quot;edgecolor&quot;, default), color, p._hue_map</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    width = kwargs.pop(&quot;width&quot;, 0.8)</span>
<span class="gi">+    dodge = kwargs.pop(&quot;dodge&quot;, False if kind in undodged_kinds else &quot;auto&quot;)</span>
<span class="gi">+    if dodge == &quot;auto&quot;:</span>
<span class="gi">+        dodge = p._dodge_needed()</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;weight&quot; in p.plot_data:</span>
<span class="gi">+        if kind not in [&quot;bar&quot;, &quot;point&quot;]:</span>
<span class="gi">+            msg = f&quot;The `weights` parameter has no effect with kind={kind!r}.&quot;</span>
<span class="gi">+            warnings.warn(msg, stacklevel=2)</span>
<span class="gi">+        agg_cls = WeightedAggregator</span>
<span class="gi">+    else:</span>
<span class="gi">+        agg_cls = EstimateAggregator</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;strip&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        jitter = kwargs.pop(&quot;jitter&quot;, True)</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+        plot_kws.setdefault(&quot;zorder&quot;, 3)</span>
<span class="gi">+        plot_kws.setdefault(&quot;linewidth&quot;, 0)</span>
<span class="gi">+        if &quot;s&quot; not in plot_kws:</span>
<span class="gi">+            plot_kws[&quot;s&quot;] = plot_kws.pop(&quot;size&quot;, 5) ** 2</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_strips(</span>
<span class="gi">+            jitter=jitter,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            plot_kws=plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;swarm&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        warn_thresh = kwargs.pop(&quot;warn_thresh&quot;, .05)</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+        plot_kws.setdefault(&quot;zorder&quot;, 3)</span>
<span class="gi">+        if &quot;s&quot; not in plot_kws:</span>
<span class="gi">+            plot_kws[&quot;s&quot;] = plot_kws.pop(&quot;size&quot;, 5) ** 2</span>
<span class="gi">+</span>
<span class="gi">+        if plot_kws.setdefault(&quot;linewidth&quot;, 0) is None:</span>
<span class="gi">+            plot_kws[&quot;linewidth&quot;] = np.sqrt(plot_kws[&quot;s&quot;]) / 10</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_swarms(</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            warn_thresh=warn_thresh,</span>
<span class="gi">+            plot_kws=plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;box&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+        gap = plot_kws.pop(&quot;gap&quot;, 0)</span>
<span class="gi">+        fill = plot_kws.pop(&quot;fill&quot;, True)</span>
<span class="gi">+        whis = plot_kws.pop(&quot;whis&quot;, 1.5)</span>
<span class="gi">+        linewidth = plot_kws.pop(&quot;linewidth&quot;, None)</span>
<span class="gi">+        fliersize = plot_kws.pop(&quot;fliersize&quot;, 5)</span>
<span class="gi">+        linecolor = p._complement_color(</span>
<span class="gi">+            plot_kws.pop(&quot;linecolor&quot;, &quot;auto&quot;), color, p._hue_map</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_boxes(</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            gap=gap,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            whis=whis,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            linecolor=linecolor,</span>
<span class="gi">+            linewidth=linewidth,</span>
<span class="gi">+            fliersize=fliersize,</span>
<span class="gi">+            plot_kws=plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;violin&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+        gap = plot_kws.pop(&quot;gap&quot;, 0)</span>
<span class="gi">+        fill = plot_kws.pop(&quot;fill&quot;, True)</span>
<span class="gi">+        split = plot_kws.pop(&quot;split&quot;, False)</span>
<span class="gi">+        inner = plot_kws.pop(&quot;inner&quot;, &quot;box&quot;)</span>
<span class="gi">+        density_norm = plot_kws.pop(&quot;density_norm&quot;, &quot;area&quot;)</span>
<span class="gi">+        common_norm = plot_kws.pop(&quot;common_norm&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+        scale = plot_kws.pop(&quot;scale&quot;, deprecated)</span>
<span class="gi">+        scale_hue = plot_kws.pop(&quot;scale_hue&quot;, deprecated)</span>
<span class="gi">+        density_norm, common_norm = p._violin_scale_backcompat(</span>
<span class="gi">+            scale, scale_hue, density_norm, common_norm,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        bw_method = p._violin_bw_backcompat(</span>
<span class="gi">+            plot_kws.pop(&quot;bw&quot;, deprecated), plot_kws.pop(&quot;bw_method&quot;, &quot;scott&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        kde_kws = dict(</span>
<span class="gi">+            cut=plot_kws.pop(&quot;cut&quot;, 2),</span>
<span class="gi">+            gridsize=plot_kws.pop(&quot;gridsize&quot;, 100),</span>
<span class="gi">+            bw_adjust=plot_kws.pop(&quot;bw_adjust&quot;, 1),</span>
<span class="gi">+            bw_method=bw_method,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        inner_kws = plot_kws.pop(&quot;inner_kws&quot;, {}).copy()</span>
<span class="gi">+        linewidth = plot_kws.pop(&quot;linewidth&quot;, None)</span>
<span class="gi">+        linecolor = plot_kws.pop(&quot;linecolor&quot;, &quot;auto&quot;)</span>
<span class="gi">+        linecolor = p._complement_color(linecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_violins(</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            gap=gap,</span>
<span class="gi">+            split=split,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            linecolor=linecolor,</span>
<span class="gi">+            linewidth=linewidth,</span>
<span class="gi">+            inner=inner,</span>
<span class="gi">+            density_norm=density_norm,</span>
<span class="gi">+            common_norm=common_norm,</span>
<span class="gi">+            kde_kws=kde_kws,</span>
<span class="gi">+            inner_kws=inner_kws,</span>
<span class="gi">+            plot_kws=plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;boxen&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+        gap = plot_kws.pop(&quot;gap&quot;, 0)</span>
<span class="gi">+        fill = plot_kws.pop(&quot;fill&quot;, True)</span>
<span class="gi">+        linecolor = plot_kws.pop(&quot;linecolor&quot;, &quot;auto&quot;)</span>
<span class="gi">+        linewidth = plot_kws.pop(&quot;linewidth&quot;, None)</span>
<span class="gi">+        k_depth = plot_kws.pop(&quot;k_depth&quot;, &quot;tukey&quot;)</span>
<span class="gi">+        width_method = plot_kws.pop(&quot;width_method&quot;, &quot;exponential&quot;)</span>
<span class="gi">+        outlier_prop = plot_kws.pop(&quot;outlier_prop&quot;, 0.007)</span>
<span class="gi">+        trust_alpha = plot_kws.pop(&quot;trust_alpha&quot;, 0.05)</span>
<span class="gi">+        showfliers = plot_kws.pop(&quot;showfliers&quot;, True)</span>
<span class="gi">+        box_kws = plot_kws.pop(&quot;box_kws&quot;, {})</span>
<span class="gi">+        flier_kws = plot_kws.pop(&quot;flier_kws&quot;, {})</span>
<span class="gi">+        line_kws = plot_kws.pop(&quot;line_kws&quot;, {})</span>
<span class="gi">+        if &quot;scale&quot; in plot_kws:</span>
<span class="gi">+            width_method = p._boxen_scale_backcompat(</span>
<span class="gi">+                plot_kws[&quot;scale&quot;], width_method</span>
<span class="gi">+            )</span>
<span class="gi">+        linecolor = p._complement_color(linecolor, color, p._hue_map)</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_boxens(</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            gap=gap,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            linecolor=linecolor,</span>
<span class="gi">+            linewidth=linewidth,</span>
<span class="gi">+            width_method=width_method,</span>
<span class="gi">+            k_depth=k_depth,</span>
<span class="gi">+            outlier_prop=outlier_prop,</span>
<span class="gi">+            trust_alpha=trust_alpha,</span>
<span class="gi">+            showfliers=showfliers,</span>
<span class="gi">+            box_kws=box_kws,</span>
<span class="gi">+            flier_kws=flier_kws,</span>
<span class="gi">+            line_kws=line_kws,</span>
<span class="gi">+            plot_kws=plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;point&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+        markers = kwargs.pop(&quot;markers&quot;, default)</span>
<span class="gi">+        linestyles = kwargs.pop(&quot;linestyles&quot;, default)</span>
<span class="gi">+</span>
<span class="gi">+        # Deprecations to remove in v0.15.0.</span>
<span class="gi">+        # TODO Uncomment when removing deprecation backcompat</span>
<span class="gi">+        # capsize = kwargs.pop(&quot;capsize&quot;, 0)</span>
<span class="gi">+        # err_kws = normalize_kwargs(kwargs.pop(&quot;err_kws&quot;, {}), mpl.lines.Line2D)</span>
<span class="gi">+        p._point_kwargs_backcompat(</span>
<span class="gi">+            kwargs.pop(&quot;scale&quot;, deprecated),</span>
<span class="gi">+            kwargs.pop(&quot;join&quot;, deprecated),</span>
<span class="gi">+            kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+        err_kws, capsize = p._err_kws_backcompat(</span>
<span class="gi">+            normalize_kwargs(kwargs.pop(&quot;err_kws&quot;, {}), mpl.lines.Line2D),</span>
<span class="gi">+            None,</span>
<span class="gi">+            errwidth=kwargs.pop(&quot;errwidth&quot;, deprecated),</span>
<span class="gi">+            capsize=kwargs.pop(&quot;capsize&quot;, 0),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_points(</span>
<span class="gi">+            aggregator=aggregator,</span>
<span class="gi">+            markers=markers,</span>
<span class="gi">+            linestyles=linestyles,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            capsize=capsize,</span>
<span class="gi">+            err_kws=err_kws,</span>
<span class="gi">+            plot_kws=kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;bar&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+        err_kws, capsize = p._err_kws_backcompat(</span>
<span class="gi">+            normalize_kwargs(kwargs.pop(&quot;err_kws&quot;, {}), mpl.lines.Line2D),</span>
<span class="gi">+            errcolor=kwargs.pop(&quot;errcolor&quot;, deprecated),</span>
<span class="gi">+            errwidth=kwargs.pop(&quot;errwidth&quot;, deprecated),</span>
<span class="gi">+            capsize=kwargs.pop(&quot;capsize&quot;, 0),</span>
<span class="gi">+        )</span>
<span class="gi">+        gap = kwargs.pop(&quot;gap&quot;, 0)</span>
<span class="gi">+        fill = kwargs.pop(&quot;fill&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_bars(</span>
<span class="gi">+            aggregator=aggregator,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            gap=gap,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            capsize=capsize,</span>
<span class="gi">+            err_kws=err_kws,</span>
<span class="gi">+            plot_kws=kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;count&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        aggregator = EstimateAggregator(&quot;sum&quot;, errorbar=None)</span>
<span class="gi">+</span>
<span class="gi">+        count_axis = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[p.orient]</span>
<span class="gi">+        p.plot_data[count_axis] = 1</span>
<span class="gi">+</span>
<span class="gi">+        stat_options = [&quot;count&quot;, &quot;percent&quot;, &quot;probability&quot;, &quot;proportion&quot;]</span>
<span class="gi">+        stat = _check_argument(&quot;stat&quot;, stat_options, kwargs.pop(&quot;stat&quot;, &quot;count&quot;))</span>
<span class="gi">+        p.variables[count_axis] = stat</span>
<span class="gi">+        if stat != &quot;count&quot;:</span>
<span class="gi">+            denom = 100 if stat == &quot;percent&quot; else 1</span>
<span class="gi">+            p.plot_data[count_axis] /= len(p.plot_data) / denom</span>
<span class="gi">+</span>
<span class="gi">+        gap = kwargs.pop(&quot;gap&quot;, 0)</span>
<span class="gi">+        fill = kwargs.pop(&quot;fill&quot;, True)</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_bars(</span>
<span class="gi">+            aggregator=aggregator,</span>
<span class="gi">+            dodge=dodge,</span>
<span class="gi">+            width=width,</span>
<span class="gi">+            gap=gap,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            capsize=0,</span>
<span class="gi">+            err_kws={},</span>
<span class="gi">+            plot_kws=kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            f&quot;Invalid `kind`: {kind!r}. Options are &#39;strip&#39;, &#39;swarm&#39;, &quot;</span>
<span class="gi">+            &quot;&#39;box&#39;, &#39;boxen&#39;, &#39;violin&#39;, &#39;bar&#39;, &#39;count&#39;, and &#39;point&#39;.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    for ax in g.axes.flat:</span>
<span class="gi">+        p._adjust_cat_axis(ax, axis=p.orient)</span>
<span class="gi">+</span>
<span class="gi">+    g.set_axis_labels(p.variables.get(&quot;x&quot;), p.variables.get(&quot;y&quot;))</span>
<span class="gi">+    g.set_titles()</span>
<span class="gi">+    g.tight_layout()</span>
<span class="gi">+</span>
<span class="gi">+    for ax in g.axes.flat:</span>
<span class="gi">+        g._update_legend_data(ax)</span>
<span class="gi">+        ax.legend_ = None</span>
<span class="gi">+</span>
<span class="gi">+    if legend == &quot;auto&quot;:</span>
<span class="gi">+        show_legend = not p._redundant_hue and p.input_format != &quot;wide&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        show_legend = bool(legend)</span>
<span class="gi">+    if show_legend:</span>
<span class="gi">+        g.add_legend(title=p.variables.get(&quot;hue&quot;), label_order=hue_order)</span>
<span class="gi">+</span>
<span class="gi">+    if data is not None:</span>
<span class="gi">+        # Replace the dataframe on the FacetGrid for any subsequent maps</span>
<span class="gi">+        g.data = data</span>
<span class="gi">+</span>
<span class="gi">+    return g</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+catplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Figure-level interface for drawing categorical plots onto a FacetGrid.</span>

<span class="w"> </span>    This function provides access to several axes-level functions that
<span class="w"> </span>    show the relationship between a numerical and one or more categorical
<span class="gu">@@ -983,102 +3211,246 @@ catplot.__doc__ = dedent(</span>
<span class="w"> </span>    --------
<span class="w"> </span>    .. include:: ../docstrings/catplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_categorical_docs)</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_categorical_docs)</span>


<span class="w"> </span>class Beeswarm:
<span class="w"> </span>    &quot;&quot;&quot;Modifies a scatterplot artist to show a beeswarm plot.&quot;&quot;&quot;
<span class="gi">+    def __init__(self, orient=&quot;x&quot;, width=0.8, warn_thresh=.05):</span>

<span class="gd">-    def __init__(self, orient=&#39;x&#39;, width=0.8, warn_thresh=0.05):</span>
<span class="w"> </span>        self.orient = orient
<span class="w"> </span>        self.width = width
<span class="w"> </span>        self.warn_thresh = warn_thresh

<span class="w"> </span>    def __call__(self, points, center):
<span class="w"> </span>        &quot;&quot;&quot;Swarm `points`, a PathCollection, around the `center` position.&quot;&quot;&quot;
<span class="gi">+        # Convert from point size (area) to diameter</span>
<span class="gi">+</span>
<span class="w"> </span>        ax = points.axes
<span class="w"> </span>        dpi = ax.figure.dpi
<span class="gi">+</span>
<span class="gi">+        # Get the original positions of the points</span>
<span class="w"> </span>        orig_xy_data = points.get_offsets()
<span class="gd">-        cat_idx = 1 if self.orient == &#39;y&#39; else 0</span>
<span class="gi">+</span>
<span class="gi">+        # Reset the categorical positions to the center line</span>
<span class="gi">+        cat_idx = 1 if self.orient == &quot;y&quot; else 0</span>
<span class="w"> </span>        orig_xy_data[:, cat_idx] = center
<span class="gi">+</span>
<span class="gi">+        # Transform the data coordinates to point coordinates.</span>
<span class="gi">+        # We&#39;ll figure out the swarm positions in the latter</span>
<span class="gi">+        # and then convert back to data coordinates and replot</span>
<span class="w"> </span>        orig_x_data, orig_y_data = orig_xy_data.T
<span class="w"> </span>        orig_xy = ax.transData.transform(orig_xy_data)
<span class="gd">-        if self.orient == &#39;y&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        # Order the variables so that x is the categorical axis</span>
<span class="gi">+        if self.orient == &quot;y&quot;:</span>
<span class="w"> </span>            orig_xy = orig_xy[:, [1, 0]]
<span class="gi">+</span>
<span class="gi">+        # Add a column with each point&#39;s radius</span>
<span class="w"> </span>        sizes = points.get_sizes()
<span class="w"> </span>        if sizes.size == 1:
<span class="w"> </span>            sizes = np.repeat(sizes, orig_xy.shape[0])
<span class="w"> </span>        edge = points.get_linewidth().item()
<span class="w"> </span>        radii = (np.sqrt(sizes) + edge) / 2 * (dpi / 72)
<span class="w"> </span>        orig_xy = np.c_[orig_xy, radii]
<span class="gi">+</span>
<span class="gi">+        # Sort along the value axis to facilitate the beeswarm</span>
<span class="w"> </span>        sorter = np.argsort(orig_xy[:, 1])
<span class="w"> </span>        orig_xyr = orig_xy[sorter]
<span class="gi">+</span>
<span class="gi">+        # Adjust points along the categorical axis to prevent overlaps</span>
<span class="w"> </span>        new_xyr = np.empty_like(orig_xyr)
<span class="w"> </span>        new_xyr[sorter] = self.beeswarm(orig_xyr)
<span class="gd">-        if self.orient == &#39;y&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        # Transform the point coordinates back to data coordinates</span>
<span class="gi">+        if self.orient == &quot;y&quot;:</span>
<span class="w"> </span>            new_xy = new_xyr[:, [1, 0]]
<span class="w"> </span>        else:
<span class="w"> </span>            new_xy = new_xyr[:, :2]
<span class="w"> </span>        new_x_data, new_y_data = ax.transData.inverted().transform(new_xy).T
<span class="gi">+</span>
<span class="gi">+        # Add gutters</span>
<span class="w"> </span>        t_fwd, t_inv = _get_transform_functions(ax, self.orient)
<span class="gd">-        if self.orient == &#39;y&#39;:</span>
<span class="gi">+        if self.orient == &quot;y&quot;:</span>
<span class="w"> </span>            self.add_gutters(new_y_data, center, t_fwd, t_inv)
<span class="w"> </span>        else:
<span class="w"> </span>            self.add_gutters(new_x_data, center, t_fwd, t_inv)
<span class="gd">-        if self.orient == &#39;y&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        # Reposition the points so they do not overlap</span>
<span class="gi">+        if self.orient == &quot;y&quot;:</span>
<span class="w"> </span>            points.set_offsets(np.c_[orig_x_data, new_y_data])
<span class="w"> </span>        else:
<span class="w"> </span>            points.set_offsets(np.c_[new_x_data, orig_y_data])

<span class="w"> </span>    def beeswarm(self, orig_xyr):
<span class="w"> </span>        &quot;&quot;&quot;Adjust x position of points to avoid overlaps.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # In this method, `x` is always the categorical axis</span>
<span class="gi">+        # Center of the swarm, in point coordinates</span>
<span class="gi">+        midline = orig_xyr[0, 0]</span>
<span class="gi">+</span>
<span class="gi">+        # Start the swarm with the first point</span>
<span class="gi">+        swarm = np.atleast_2d(orig_xyr[0])</span>
<span class="gi">+</span>
<span class="gi">+        # Loop over the remaining points</span>
<span class="gi">+        for xyr_i in orig_xyr[1:]:</span>
<span class="gi">+</span>
<span class="gi">+            # Find the points in the swarm that could possibly</span>
<span class="gi">+            # overlap with the point we are currently placing</span>
<span class="gi">+            neighbors = self.could_overlap(xyr_i, swarm)</span>
<span class="gi">+</span>
<span class="gi">+            # Find positions that would be valid individually</span>
<span class="gi">+            # with respect to each of the swarm neighbors</span>
<span class="gi">+            candidates = self.position_candidates(xyr_i, neighbors)</span>
<span class="gi">+</span>
<span class="gi">+            # Sort candidates by their centrality</span>
<span class="gi">+            offsets = np.abs(candidates[:, 0] - midline)</span>
<span class="gi">+            candidates = candidates[np.argsort(offsets)]</span>
<span class="gi">+</span>
<span class="gi">+            # Find the first candidate that does not overlap any neighbors</span>
<span class="gi">+            new_xyr_i = self.first_non_overlapping_candidate(candidates, neighbors)</span>
<span class="gi">+</span>
<span class="gi">+            # Place it into the swarm</span>
<span class="gi">+            swarm = np.vstack([swarm, new_xyr_i])</span>
<span class="gi">+</span>
<span class="gi">+        return swarm</span>

<span class="w"> </span>    def could_overlap(self, xyr_i, swarm):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of all swarm points that could overlap with target.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Because we work backwards through the swarm and can short-circuit,</span>
<span class="gi">+        # the for-loop is faster than vectorization</span>
<span class="gi">+        _, y_i, r_i = xyr_i</span>
<span class="gi">+        neighbors = []</span>
<span class="gi">+        for xyr_j in reversed(swarm):</span>
<span class="gi">+            _, y_j, r_j = xyr_j</span>
<span class="gi">+            if (y_i - y_j) &lt; (r_i + r_j):</span>
<span class="gi">+                neighbors.append(xyr_j)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        return np.array(neighbors)[::-1]</span>

<span class="w"> </span>    def position_candidates(self, xyr_i, neighbors):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of coordinates that might be valid by adjusting x.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        candidates = [xyr_i]</span>
<span class="gi">+        x_i, y_i, r_i = xyr_i</span>
<span class="gi">+        left_first = True</span>
<span class="gi">+        for x_j, y_j, r_j in neighbors:</span>
<span class="gi">+            dy = y_i - y_j</span>
<span class="gi">+            dx = np.sqrt(max((r_i + r_j) ** 2 - dy ** 2, 0)) * 1.05</span>
<span class="gi">+            cl, cr = (x_j - dx, y_i, r_i), (x_j + dx, y_i, r_i)</span>
<span class="gi">+            if left_first:</span>
<span class="gi">+                new_candidates = [cl, cr]</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_candidates = [cr, cl]</span>
<span class="gi">+            candidates.extend(new_candidates)</span>
<span class="gi">+            left_first = not left_first</span>
<span class="gi">+        return np.array(candidates)</span>

<span class="w"> </span>    def first_non_overlapping_candidate(self, candidates, neighbors):
<span class="w"> </span>        &quot;&quot;&quot;Find the first candidate that does not overlap with the swarm.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # If we have no neighbors, all candidates are good.</span>
<span class="gi">+        if len(neighbors) == 0:</span>
<span class="gi">+            return candidates[0]</span>
<span class="gi">+</span>
<span class="gi">+        neighbors_x = neighbors[:, 0]</span>
<span class="gi">+        neighbors_y = neighbors[:, 1]</span>
<span class="gi">+        neighbors_r = neighbors[:, 2]</span>
<span class="gi">+</span>
<span class="gi">+        for xyr_i in candidates:</span>
<span class="gi">+</span>
<span class="gi">+            x_i, y_i, r_i = xyr_i</span>
<span class="gi">+</span>
<span class="gi">+            dx = neighbors_x - x_i</span>
<span class="gi">+            dy = neighbors_y - y_i</span>
<span class="gi">+            sq_distances = np.square(dx) + np.square(dy)</span>
<span class="gi">+</span>
<span class="gi">+            sep_needed = np.square(neighbors_r + r_i)</span>
<span class="gi">+</span>
<span class="gi">+            # Good candidate does not overlap any of neighbors which means that</span>
<span class="gi">+            # squared distance between candidate and any of the neighbors has</span>
<span class="gi">+            # to be at least square of the summed radii</span>
<span class="gi">+            good_candidate = np.all(sq_distances &gt;= sep_needed)</span>
<span class="gi">+</span>
<span class="gi">+            if good_candidate:</span>
<span class="gi">+                return xyr_i</span>
<span class="gi">+</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            &quot;No non-overlapping candidates found. This should not happen.&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def add_gutters(self, points, center, trans_fwd, trans_inv):
<span class="w"> </span>        &quot;&quot;&quot;Stop points from extending beyond their territory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        half_width = self.width / 2</span>
<span class="gi">+        low_gutter = trans_inv(trans_fwd(center) - half_width)</span>
<span class="gi">+        off_low = points &lt; low_gutter</span>
<span class="gi">+        if off_low.any():</span>
<span class="gi">+            points[off_low] = low_gutter</span>
<span class="gi">+        high_gutter = trans_inv(trans_fwd(center) + half_width)</span>
<span class="gi">+        off_high = points &gt; high_gutter</span>
<span class="gi">+        if off_high.any():</span>
<span class="gi">+            points[off_high] = high_gutter</span>
<span class="gi">+</span>
<span class="gi">+        gutter_prop = (off_high + off_low).sum() / len(points)</span>
<span class="gi">+        if gutter_prop &gt; self.warn_thresh:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;{:.1%} of the points cannot be placed; you may want &quot;</span>
<span class="gi">+                &quot;to decrease the size of the markers or use stripplot.&quot;</span>
<span class="gi">+            ).format(gutter_prop)</span>
<span class="gi">+            warnings.warn(msg, UserWarning)</span>
<span class="gi">+</span>
<span class="gi">+        return points</span>


<span class="gd">-BoxPlotArtists = namedtuple(&#39;BoxPlotArtists&#39;,</span>
<span class="gd">-    &#39;box median whiskers caps fliers mean&#39;)</span>
<span class="gi">+BoxPlotArtists = namedtuple(&quot;BoxPlotArtists&quot;, &quot;box median whiskers caps fliers mean&quot;)</span>


<span class="w"> </span>class BoxPlotContainer:

<span class="w"> </span>    def __init__(self, artist_dict):
<span class="gd">-        self.boxes = artist_dict[&#39;boxes&#39;]</span>
<span class="gd">-        self.medians = artist_dict[&#39;medians&#39;]</span>
<span class="gd">-        self.whiskers = artist_dict[&#39;whiskers&#39;]</span>
<span class="gd">-        self.caps = artist_dict[&#39;caps&#39;]</span>
<span class="gd">-        self.fliers = artist_dict[&#39;fliers&#39;]</span>
<span class="gd">-        self.means = artist_dict[&#39;means&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        self.boxes = artist_dict[&quot;boxes&quot;]</span>
<span class="gi">+        self.medians = artist_dict[&quot;medians&quot;]</span>
<span class="gi">+        self.whiskers = artist_dict[&quot;whiskers&quot;]</span>
<span class="gi">+        self.caps = artist_dict[&quot;caps&quot;]</span>
<span class="gi">+        self.fliers = artist_dict[&quot;fliers&quot;]</span>
<span class="gi">+        self.means = artist_dict[&quot;means&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>        self._label = None
<span class="gd">-        self._children = [*self.boxes, *self.medians, *self.whiskers, *self</span>
<span class="gd">-            .caps, *self.fliers, *self.means]</span>
<span class="gi">+        self._children = [</span>
<span class="gi">+            *self.boxes,</span>
<span class="gi">+            *self.medians,</span>
<span class="gi">+            *self.whiskers,</span>
<span class="gi">+            *self.caps,</span>
<span class="gi">+            *self.fliers,</span>
<span class="gi">+            *self.means,</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;BoxPlotContainer object with {len(self.boxes)} boxes&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;BoxPlotContainer object with {len(self.boxes)} boxes&gt;&quot;</span>

<span class="w"> </span>    def __getitem__(self, idx):
<span class="w"> </span>        pair_slice = slice(2 * idx, 2 * idx + 2)
<span class="gd">-        return BoxPlotArtists(self.boxes[idx] if self.boxes else [], self.</span>
<span class="gd">-            medians[idx] if self.medians else [], self.whiskers[pair_slice] if</span>
<span class="gd">-            self.whiskers else [], self.caps[pair_slice] if self.caps else</span>
<span class="gd">-            [], self.fliers[idx] if self.fliers else [], self.means[idx] if</span>
<span class="gd">-            self.means else [])</span>
<span class="gi">+        return BoxPlotArtists(</span>
<span class="gi">+            self.boxes[idx] if self.boxes else [],</span>
<span class="gi">+            self.medians[idx] if self.medians else [],</span>
<span class="gi">+            self.whiskers[pair_slice] if self.whiskers else [],</span>
<span class="gi">+            self.caps[pair_slice] if self.caps else [],</span>
<span class="gi">+            self.fliers[idx] if self.fliers else [],</span>
<span class="gi">+            self.means[idx]if self.means else [],</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        yield from (self[i] for i in range(len(self.boxes)))
<span class="gi">+</span>
<span class="gi">+    def get_label(self):</span>
<span class="gi">+        return self._label</span>
<span class="gi">+</span>
<span class="gi">+    def set_label(self, value):</span>
<span class="gi">+        self._label = value</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self):</span>
<span class="gi">+        return self._children</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self):</span>
<span class="gi">+        for child in self._children:</span>
<span class="gi">+            child.remove()</span>
<span class="gh">diff --git a/seaborn/cm.py b/seaborn/cm.py</span>
<span class="gh">index af7a3d4b..df7ce619 100644</span>
<span class="gd">--- a/seaborn/cm.py</span>
<span class="gi">+++ b/seaborn/cm.py</span>
<span class="gu">@@ -1,908 +1,1586 @@</span>
<span class="w"> </span>from matplotlib import colors
<span class="w"> </span>from seaborn._compat import register_colormap
<span class="gd">-_rocket_lut = [[0.01060815, 0.01808215, 0.10018654], [0.01428972, </span>
<span class="gd">-    0.02048237, 0.10374486], [0.01831941, 0.0229766, 0.10738511], [</span>
<span class="gd">-    0.02275049, 0.02554464, 0.11108639], [0.02759119, 0.02818316, </span>
<span class="gd">-    0.11483751], [0.03285175, 0.03088792, 0.11863035], [0.03853466, </span>
<span class="gd">-    0.03365771, 0.12245873], [0.04447016, 0.03648425, 0.12631831], [</span>
<span class="gd">-    0.05032105, 0.03936808, 0.13020508], [0.05611171, 0.04224835, </span>
<span class="gd">-    0.13411624], [0.0618531, 0.04504866, 0.13804929], [0.06755457, </span>
<span class="gd">-    0.04778179, 0.14200206], [0.0732236, 0.05045047, 0.14597263], [</span>
<span class="gd">-    0.0788708, 0.05305461, 0.14995981], [0.08450105, 0.05559631, 0.15396203</span>
<span class="gd">-    ], [0.09011319, 0.05808059, 0.15797687], [0.09572396, 0.06050127, </span>
<span class="gd">-    0.16200507], [0.10132312, 0.06286782, 0.16604287], [0.10692823, </span>
<span class="gd">-    0.06517224, 0.17009175], [0.1125315, 0.06742194, 0.17414848], [</span>
<span class="gd">-    0.11813947, 0.06961499, 0.17821272], [0.12375803, 0.07174938, </span>
<span class="gd">-    0.18228425], [0.12938228, 0.07383015, 0.18636053], [0.13501631, </span>
<span class="gd">-    0.07585609, 0.19044109], [0.14066867, 0.0778224, 0.19452676], [</span>
<span class="gd">-    0.14633406, 0.07973393, 0.1986151], [0.15201338, 0.08159108, 0.20270523</span>
<span class="gd">-    ], [0.15770877, 0.08339312, 0.20679668], [0.16342174, 0.0851396, </span>
<span class="gd">-    0.21088893], [0.16915387, 0.08682996, 0.21498104], [0.17489524, </span>
<span class="gd">-    0.08848235, 0.2190294], [0.18065495, 0.09009031, 0.22303512], [</span>
<span class="gd">-    0.18643324, 0.09165431, 0.22699705], [0.19223028, 0.09317479, </span>
<span class="gd">-    0.23091409], [0.19804623, 0.09465217, 0.23478512], [0.20388117, </span>
<span class="gd">-    0.09608689, 0.23860907], [0.20973515, 0.09747934, 0.24238489], [</span>
<span class="gd">-    0.21560818, 0.09882993, 0.24611154], [0.22150014, 0.10013944, 0.2497868</span>
<span class="gd">-    ], [0.22741085, 0.10140876, 0.25340813], [0.23334047, 0.10263737, </span>
<span class="gd">-    0.25697736], [0.23928891, 0.10382562, 0.2604936], [0.24525608, </span>
<span class="gd">-    0.10497384, 0.26395596], [0.25124182, 0.10608236, 0.26736359], [</span>
<span class="gd">-    0.25724602, 0.10715148, 0.27071569], [0.26326851, 0.1081815, 0.27401148</span>
<span class="gd">-    ], [0.26930915, 0.1091727, 0.2772502], [0.27536766, 0.11012568, </span>
<span class="gd">-    0.28043021], [0.28144375, 0.11104133, 0.2835489], [0.2875374, </span>
<span class="gd">-    0.11191896, 0.28660853], [0.29364846, 0.11275876, 0.2896085], [</span>
<span class="gd">-    0.29977678, 0.11356089, 0.29254823], [0.30592213, 0.11432553, </span>
<span class="gd">-    0.29542718], [0.31208435, 0.11505284, 0.29824485], [0.31826327, </span>
<span class="gd">-    0.1157429, 0.30100076], [0.32445869, 0.11639585, 0.30369448], [</span>
<span class="gd">-    0.33067031, 0.11701189, 0.30632563], [0.33689808, 0.11759095, 0.3088938</span>
<span class="gd">-    ], [0.34314168, 0.11813362, 0.31139721], [0.34940101, 0.11863987, </span>
<span class="gd">-    0.3138355], [0.355676, 0.11910909, 0.31620996], [0.36196644, 0.1195413,</span>
<span class="gd">-    0.31852037], [0.36827206, 0.11993653, 0.32076656], [0.37459292, </span>
<span class="gd">-    0.12029443, 0.32294825], [0.38092887, 0.12061482, 0.32506528], [</span>
<span class="gd">-    0.38727975, 0.12089756, 0.3271175], [0.39364518, 0.12114272, 0.32910494</span>
<span class="gd">-    ], [0.40002537, 0.12134964, 0.33102734], [0.40642019, 0.12151801, </span>
<span class="gd">-    0.33288464], [0.41282936, 0.12164769, 0.33467689], [0.41925278, </span>
<span class="gd">-    0.12173833, 0.33640407], [0.42569057, 0.12178916, 0.33806605], [</span>
<span class="gd">-    0.43214263, 0.12179973, 0.33966284], [0.43860848, 0.12177004, </span>
<span class="gd">-    0.34119475], [0.44508855, 0.12169883, 0.34266151], [0.45158266, </span>
<span class="gd">-    0.12158557, 0.34406324], [0.45809049, 0.12142996, 0.34540024], [</span>
<span class="gd">-    0.46461238, 0.12123063, 0.34667231], [0.47114798, 0.12098721, </span>
<span class="gd">-    0.34787978], [0.47769736, 0.12069864, 0.34902273], [0.48426077, </span>
<span class="gd">-    0.12036349, 0.35010104], [0.49083761, 0.11998161, 0.35111537], [</span>
<span class="gd">-    0.49742847, 0.11955087, 0.35206533], [0.50403286, 0.11907081, </span>
<span class="gd">-    0.35295152], [0.51065109, 0.11853959, 0.35377385], [0.51728314, </span>
<span class="gd">-    0.1179558, 0.35453252], [0.52392883, 0.11731817, 0.35522789], [</span>
<span class="gd">-    0.53058853, 0.11662445, 0.35585982], [0.53726173, 0.11587369, </span>
<span class="gd">-    0.35642903], [0.54394898, 0.11506307, 0.35693521], [0.5506426, </span>
<span class="gd">-    0.11420757, 0.35737863], [0.55734473, 0.11330456, 0.35775059], [</span>
<span class="gd">-    0.56405586, 0.11235265, 0.35804813], [0.57077365, 0.11135597, </span>
<span class="gd">-    0.35827146], [0.5774991, 0.11031233, 0.35841679], [0.58422945, </span>
<span class="gd">-    0.10922707, 0.35848469], [0.59096382, 0.10810205, 0.35847347], [</span>
<span class="gd">-    0.59770215, 0.10693774, 0.35838029], [0.60444226, 0.10573912, </span>
<span class="gd">-    0.35820487], [0.61118304, 0.10450943, 0.35794557], [0.61792306, </span>
<span class="gd">-    0.10325288, 0.35760108], [0.62466162, 0.10197244, 0.35716891], [</span>
<span class="gd">-    0.63139686, 0.10067417, 0.35664819], [0.63812122, 0.09938212, </span>
<span class="gd">-    0.35603757], [0.64483795, 0.0980891, 0.35533555], [0.65154562, </span>
<span class="gd">-    0.09680192, 0.35454107], [0.65824241, 0.09552918, 0.3536529], [</span>
<span class="gd">-    0.66492652, 0.09428017, 0.3526697], [0.67159578, 0.09306598, 0.35159077</span>
<span class="gd">-    ], [0.67824099, 0.09192342, 0.3504148], [0.684863, 0.09085633, </span>
<span class="gd">-    0.34914061], [0.69146268, 0.0898675, 0.34776864], [0.69803757, </span>
<span class="gd">-    0.08897226, 0.3462986], [0.70457834, 0.0882129, 0.34473046], [</span>
<span class="gd">-    0.71108138, 0.08761223, 0.3430635], [0.7175507, 0.08716212, 0.34129974],</span>
<span class="gd">-    [0.72398193, 0.08688725, 0.33943958], [0.73035829, 0.0868623, </span>
<span class="gd">-    0.33748452], [0.73669146, 0.08704683, 0.33543669], [0.74297501, </span>
<span class="gd">-    0.08747196, 0.33329799], [0.74919318, 0.08820542, 0.33107204], [</span>
<span class="gd">-    0.75535825, 0.08919792, 0.32876184], [0.76145589, 0.09050716, </span>
<span class="gd">-    0.32637117], [0.76748424, 0.09213602, 0.32390525], [0.77344838, </span>
<span class="gd">-    0.09405684, 0.32136808], [0.77932641, 0.09634794, 0.31876642], [</span>
<span class="gd">-    0.78513609, 0.09892473, 0.31610488], [0.79085854, 0.10184672, 0.313391],</span>
<span class="gd">-    [0.7965014, 0.10506637, 0.31063031], [0.80205987, 0.10858333, 0.30783],</span>
<span class="gd">-    [0.80752799, 0.11239964, 0.30499738], [0.81291606, 0.11645784, </span>
<span class="gd">-    0.30213802], [0.81820481, 0.12080606, 0.29926105], [0.82341472, </span>
<span class="gd">-    0.12535343, 0.2963705], [0.82852822, 0.13014118, 0.29347474], [</span>
<span class="gd">-    0.83355779, 0.13511035, 0.29057852], [0.83850183, 0.14025098, 0.2876878</span>
<span class="gd">-    ], [0.84335441, 0.14556683, 0.28480819], [0.84813096, 0.15099892, </span>
<span class="gd">-    0.281943], [0.85281737, 0.15657772, 0.27909826], [0.85742602, 0.1622583,</span>
<span class="gd">-    0.27627462], [0.86196552, 0.16801239, 0.27346473], [0.86641628, </span>
<span class="gd">-    0.17387796, 0.27070818], [0.87079129, 0.17982114, 0.26797378], [</span>
<span class="gd">-    0.87507281, 0.18587368, 0.26529697], [0.87925878, 0.19203259, </span>
<span class="gd">-    0.26268136], [0.8833417, 0.19830556, 0.26014181], [0.88731387, </span>
<span class="gd">-    0.20469941, 0.25769539], [0.89116859, 0.21121788, 0.2553592], [</span>
<span class="gd">-    0.89490337, 0.21785614, 0.25314362], [0.8985026, 0.22463251, 0.25108745</span>
<span class="gd">-    ], [0.90197527, 0.23152063, 0.24918223], [0.90530097, 0.23854541, </span>
<span class="gd">-    0.24748098], [0.90848638, 0.24568473, 0.24598324], [0.911533, </span>
<span class="gd">-    0.25292623, 0.24470258], [0.9144225, 0.26028902, 0.24369359], [</span>
<span class="gd">-    0.91717106, 0.26773821, 0.24294137], [0.91978131, 0.27526191, </span>
<span class="gd">-    0.24245973], [0.92223947, 0.28287251, 0.24229568], [0.92456587, </span>
<span class="gd">-    0.29053388, 0.24242622], [0.92676657, 0.29823282, 0.24285536], [</span>
<span class="gd">-    0.92882964, 0.30598085, 0.24362274], [0.93078135, 0.31373977, </span>
<span class="gd">-    0.24468803], [0.93262051, 0.3215093, 0.24606461], [0.93435067, </span>
<span class="gd">-    0.32928362, 0.24775328], [0.93599076, 0.33703942, 0.24972157], [</span>
<span class="gd">-    0.93752831, 0.34479177, 0.25199928], [0.93899289, 0.35250734, </span>
<span class="gd">-    0.25452808], [0.94036561, 0.36020899, 0.25734661], [0.94167588, </span>
<span class="gd">-    0.36786594, 0.2603949], [0.94291042, 0.37549479, 0.26369821], [</span>
<span class="gd">-    0.94408513, 0.3830811, 0.26722004], [0.94520419, 0.39062329, 0.27094924</span>
<span class="gd">-    ], [0.94625977, 0.39813168, 0.27489742], [0.94727016, 0.4055909, </span>
<span class="gd">-    0.27902322], [0.94823505, 0.41300424, 0.28332283], [0.94914549, </span>
<span class="gd">-    0.42038251, 0.28780969], [0.95001704, 0.42771398, 0.29244728], [</span>
<span class="gd">-    0.95085121, 0.43500005, 0.29722817], [0.95165009, 0.44224144, </span>
<span class="gd">-    0.30214494], [0.9524044, 0.44944853, 0.3072105], [0.95312556, </span>
<span class="gd">-    0.45661389, 0.31239776], [0.95381595, 0.46373781, 0.31769923], [</span>
<span class="gd">-    0.95447591, 0.47082238, 0.32310953], [0.95510255, 0.47787236, </span>
<span class="gd">-    0.32862553], [0.95569679, 0.48489115, 0.33421404], [0.95626788, </span>
<span class="gd">-    0.49187351, 0.33985601], [0.95681685, 0.49882008, 0.34555431], [</span>
<span class="gd">-    0.9573439, 0.50573243, 0.35130912], [0.95784842, 0.51261283, 0.35711942</span>
<span class="gd">-    ], [0.95833051, 0.51946267, 0.36298589], [0.95879054, 0.52628305, </span>
<span class="gd">-    0.36890904], [0.95922872, 0.53307513, 0.3748895], [0.95964538, </span>
<span class="gd">-    0.53983991, 0.38092784], [0.96004345, 0.54657593, 0.3870292], [</span>
<span class="gd">-    0.96042097, 0.55328624, 0.39319057], [0.96077819, 0.55997184, </span>
<span class="gd">-    0.39941173], [0.9611152, 0.5666337, 0.40569343], [0.96143273, </span>
<span class="gd">-    0.57327231, 0.41203603], [0.96173392, 0.57988594, 0.41844491], [</span>
<span class="gd">-    0.96201757, 0.58647675, 0.42491751], [0.96228344, 0.59304598, </span>
<span class="gd">-    0.43145271], [0.96253168, 0.5995944, 0.43805131], [0.96276513, </span>
<span class="gd">-    0.60612062, 0.44471698], [0.96298491, 0.6126247, 0.45145074], [</span>
<span class="gd">-    0.96318967, 0.61910879, 0.45824902], [0.96337949, 0.6255736, 0.46511271</span>
<span class="gd">-    ], [0.96355923, 0.63201624, 0.47204746], [0.96372785, 0.63843852, </span>
<span class="gd">-    0.47905028], [0.96388426, 0.64484214, 0.4861196], [0.96403203, </span>
<span class="gd">-    0.65122535, 0.4932578], [0.96417332, 0.65758729, 0.50046894], [</span>
<span class="gd">-    0.9643063, 0.66393045, 0.5077467], [0.96443322, 0.67025402, 0.51509334],</span>
<span class="gd">-    [0.96455845, 0.67655564, 0.52251447], [0.96467922, 0.68283846, </span>
<span class="gd">-    0.53000231], [0.96479861, 0.68910113, 0.53756026], [0.96492035, </span>
<span class="gd">-    0.69534192, 0.5451917], [0.96504223, 0.7015636, 0.5528892], [0.96516917,</span>
<span class="gd">-    0.70776351, 0.5606593], [0.96530224, 0.71394212, 0.56849894], [</span>
<span class="gd">-    0.96544032, 0.72010124, 0.57640375], [0.96559206, 0.72623592, </span>
<span class="gd">-    0.58438387], [0.96575293, 0.73235058, 0.59242739], [0.96592829, </span>
<span class="gd">-    0.73844258, 0.60053991], [0.96612013, 0.74451182, 0.60871954], [</span>
<span class="gd">-    0.96632832, 0.75055966, 0.61696136], [0.96656022, 0.75658231, </span>
<span class="gd">-    0.62527295], [0.96681185, 0.76258381, 0.63364277], [0.96709183, </span>
<span class="gd">-    0.76855969, 0.64207921], [0.96739773, 0.77451297, 0.65057302], [</span>
<span class="gd">-    0.96773482, 0.78044149, 0.65912731], [0.96810471, 0.78634563, </span>
<span class="gd">-    0.66773889], [0.96850919, 0.79222565, 0.6764046], [0.96893132, </span>
<span class="gd">-    0.79809112, 0.68512266], [0.96935926, 0.80395415, 0.69383201], [</span>
<span class="gd">-    0.9698028, 0.80981139, 0.70252255], [0.97025511, 0.81566605, 0.71120296</span>
<span class="gd">-    ], [0.97071849, 0.82151775, 0.71987163], [0.97120159, 0.82736371, </span>
<span class="gd">-    0.72851999], [0.97169389, 0.83320847, 0.73716071], [0.97220061, </span>
<span class="gd">-    0.83905052, 0.74578903], [0.97272597, 0.84488881, 0.75440141], [</span>
<span class="gd">-    0.97327085, 0.85072354, 0.76299805], [0.97383206, 0.85655639, </span>
<span class="gd">-    0.77158353], [0.97441222, 0.86238689, 0.78015619], [0.97501782, </span>
<span class="gd">-    0.86821321, 0.78871034], [0.97564391, 0.87403763, 0.79725261], [</span>
<span class="gd">-    0.97628674, 0.87986189, 0.8057883], [0.97696114, 0.88568129, 0.81430324</span>
<span class="gd">-    ], [0.97765722, 0.89149971, 0.82280948], [0.97837585, 0.89731727, </span>
<span class="gd">-    0.83130786], [0.97912374, 0.90313207, 0.83979337], [0.979891, </span>
<span class="gd">-    0.90894778, 0.84827858], [0.98067764, 0.91476465, 0.85676611], [</span>
<span class="gd">-    0.98137749, 0.92061729, 0.86536915]]</span>
<span class="gd">-_mako_lut = [[0.04503935, 0.01482344, 0.02092227], [0.04933018, 0.01709292,</span>
<span class="gd">-    0.02535719], [0.05356262, 0.01950702, 0.03018802], [0.05774337, </span>
<span class="gd">-    0.02205989, 0.03545515], [0.06188095, 0.02474764, 0.04115287], [</span>
<span class="gd">-    0.06598247, 0.0275665, 0.04691409], [0.07005374, 0.03051278, 0.05264306</span>
<span class="gd">-    ], [0.07409947, 0.03358324, 0.05834631], [0.07812339, 0.03677446, </span>
<span class="gd">-    0.06403249], [0.08212852, 0.0400833, 0.06970862], [0.08611731, </span>
<span class="gd">-    0.04339148, 0.07538208], [0.09009161, 0.04664706, 0.08105568], [</span>
<span class="gd">-    0.09405308, 0.04985685, 0.08673591], [0.09800301, 0.05302279, </span>
<span class="gd">-    0.09242646], [0.10194255, 0.05614641, 0.09813162], [0.10587261, </span>
<span class="gd">-    0.05922941, 0.103854], [0.1097942, 0.06227277, 0.10959847], [0.11370826,</span>
<span class="gd">-    0.06527747, 0.11536893], [0.11761516, 0.06824548, 0.12116393], [</span>
<span class="gd">-    0.12151575, 0.07117741, 0.12698763], [0.12541095, 0.07407363, 0.1328442</span>
<span class="gd">-    ], [0.12930083, 0.07693611, 0.13873064], [0.13317849, 0.07976988, </span>
<span class="gd">-    0.14465095], [0.13701138, 0.08259683, 0.15060265], [0.14079223, </span>
<span class="gd">-    0.08542126, 0.15659379], [0.14452486, 0.08824175, 0.16262484], [</span>
<span class="gd">-    0.14820351, 0.09106304, 0.16869476], [0.15183185, 0.09388372, </span>
<span class="gd">-    0.17480366], [0.15540398, 0.09670855, 0.18094993], [0.15892417, </span>
<span class="gd">-    0.09953561, 0.18713384], [0.16238588, 0.10236998, 0.19335329], [</span>
<span class="gd">-    0.16579435, 0.10520905, 0.19960847], [0.16914226, 0.10805832, </span>
<span class="gd">-    0.20589698], [0.17243586, 0.11091443, 0.21221911], [0.17566717, </span>
<span class="gd">-    0.11378321, 0.21857219], [0.17884322, 0.11666074, 0.2249565], [</span>
<span class="gd">-    0.18195582, 0.11955283, 0.23136943], [0.18501213, 0.12245547, </span>
<span class="gd">-    0.23781116], [0.18800459, 0.12537395, 0.24427914], [0.19093944, </span>
<span class="gd">-    0.1283047, 0.25077369], [0.19381092, 0.13125179, 0.25729255], [</span>
<span class="gd">-    0.19662307, 0.13421303, 0.26383543], [0.19937337, 0.13719028, </span>
<span class="gd">-    0.27040111], [0.20206187, 0.14018372, 0.27698891], [0.20469116, </span>
<span class="gd">-    0.14319196, 0.28359861], [0.20725547, 0.14621882, 0.29022775], [</span>
<span class="gd">-    0.20976258, 0.14925954, 0.29687795], [0.21220409, 0.15231929, </span>
<span class="gd">-    0.30354703], [0.21458611, 0.15539445, 0.31023563], [0.21690827, </span>
<span class="gd">-    0.15848519, 0.31694355], [0.21916481, 0.16159489, 0.32366939], [</span>
<span class="gd">-    0.2213631, 0.16471913, 0.33041431], [0.22349947, 0.1678599, 0.33717781],</span>
<span class="gd">-    [0.2255714, 0.1710185, 0.34395925], [0.22758415, 0.17419169, 0.35075983</span>
<span class="gd">-    ], [0.22953569, 0.17738041, 0.35757941], [0.23142077, 0.18058733, </span>
<span class="gd">-    0.3644173], [0.2332454, 0.18380872, 0.37127514], [0.2350092, 0.18704459,</span>
<span class="gd">-    0.3781528], [0.23670785, 0.190297, 0.38504973], [0.23834119, 0.19356547,</span>
<span class="gd">-    0.39196711], [0.23991189, 0.19684817, 0.39890581], [0.24141903, </span>
<span class="gd">-    0.20014508, 0.4058667], [0.24286214, 0.20345642, 0.4128484], [</span>
<span class="gd">-    0.24423453, 0.20678459, 0.41985299], [0.24554109, 0.21012669, </span>
<span class="gd">-    0.42688124], [0.2467815, 0.21348266, 0.43393244], [0.24795393, </span>
<span class="gd">-    0.21685249, 0.4410088], [0.24905614, 0.22023618, 0.448113], [0.25007383,</span>
<span class="gd">-    0.22365053, 0.45519562], [0.25098926, 0.22710664, 0.46223892], [</span>
<span class="gd">-    0.25179696, 0.23060342, 0.46925447], [0.25249346, 0.23414353, </span>
<span class="gd">-    0.47623196], [0.25307401, 0.23772973, 0.48316271], [0.25353152, </span>
<span class="gd">-    0.24136961, 0.49001976], [0.25386167, 0.24506548, 0.49679407], [</span>
<span class="gd">-    0.25406082, 0.2488164, 0.50348932], [0.25412435, 0.25262843, 0.51007843</span>
<span class="gd">-    ], [0.25404842, 0.25650743, 0.51653282], [0.25383134, 0.26044852, </span>
<span class="gd">-    0.52286845], [0.2534705, 0.26446165, 0.52903422], [0.25296722, </span>
<span class="gd">-    0.2685428, 0.53503572], [0.2523226, 0.27269346, 0.54085315], [</span>
<span class="gd">-    0.25153974, 0.27691629, 0.54645752], [0.25062402, 0.28120467, </span>
<span class="gd">-    0.55185939], [0.24958205, 0.28556371, 0.55701246], [0.24842386, </span>
<span class="gd">-    0.28998148, 0.56194601], [0.24715928, 0.29446327, 0.56660884], [</span>
<span class="gd">-    0.24580099, 0.29899398, 0.57104399], [0.24436202, 0.30357852, </span>
<span class="gd">-    0.57519929], [0.24285591, 0.30819938, 0.57913247], [0.24129828, </span>
<span class="gd">-    0.31286235, 0.58278615], [0.23970131, 0.3175495, 0.5862272], [</span>
<span class="gd">-    0.23807973, 0.32226344, 0.58941872], [0.23644557, 0.32699241, </span>
<span class="gd">-    0.59240198], [0.2348113, 0.33173196, 0.59518282], [0.23318874, </span>
<span class="gd">-    0.33648036, 0.59775543], [0.2315855, 0.34122763, 0.60016456], [</span>
<span class="gd">-    0.23001121, 0.34597357, 0.60240251], [0.2284748, 0.35071512, 0.6044784],</span>
<span class="gd">-    [0.22698081, 0.35544612, 0.60642528], [0.22553305, 0.36016515, </span>
<span class="gd">-    0.60825252], [0.22413977, 0.36487341, 0.60994938], [0.22280246, </span>
<span class="gd">-    0.36956728, 0.61154118], [0.22152555, 0.37424409, 0.61304472], [</span>
<span class="gd">-    0.22030752, 0.37890437, 0.61446646], [0.2191538, 0.38354668, 0.61581561</span>
<span class="gd">-    ], [0.21806257, 0.38817169, 0.61709794], [0.21703799, 0.39277882, </span>
<span class="gd">-    0.61831922], [0.21607792, 0.39736958, 0.61948028], [0.21518463, </span>
<span class="gd">-    0.40194196, 0.62059763], [0.21435467, 0.40649717, 0.62167507], [</span>
<span class="gd">-    0.21358663, 0.41103579, 0.62271724], [0.21288172, 0.41555771, </span>
<span class="gd">-    0.62373011], [0.21223835, 0.42006355, 0.62471794], [0.21165312, </span>
<span class="gd">-    0.42455441, 0.62568371], [0.21112526, 0.42903064, 0.6266318], [</span>
<span class="gd">-    0.21065161, 0.43349321, 0.62756504], [0.21023306, 0.43794288, </span>
<span class="gd">-    0.62848279], [0.20985996, 0.44238227, 0.62938329], [0.20951045, </span>
<span class="gd">-    0.44680966, 0.63030696], [0.20916709, 0.45122981, 0.63124483], [</span>
<span class="gd">-    0.20882976, 0.45564335, 0.63219599], [0.20849798, 0.46005094, </span>
<span class="gd">-    0.63315928], [0.20817199, 0.46445309, 0.63413391], [0.20785149, </span>
<span class="gd">-    0.46885041, 0.63511876], [0.20753716, 0.47324327, 0.63611321], [</span>
<span class="gd">-    0.20722876, 0.47763224, 0.63711608], [0.20692679, 0.48201774, </span>
<span class="gd">-    0.63812656], [0.20663156, 0.48640018, 0.63914367], [0.20634336, </span>
<span class="gd">-    0.49078002, 0.64016638], [0.20606303, 0.49515755, 0.6411939], [</span>
<span class="gd">-    0.20578999, 0.49953341, 0.64222457], [0.20552612, 0.50390766, </span>
<span class="gd">-    0.64325811], [0.20527189, 0.50828072, 0.64429331], [0.20502868, </span>
<span class="gd">-    0.51265277, 0.64532947], [0.20479718, 0.51702417, 0.64636539], [</span>
<span class="gd">-    0.20457804, 0.52139527, 0.64739979], [0.20437304, 0.52576622, </span>
<span class="gd">-    0.64843198], [0.20418396, 0.53013715, 0.64946117], [0.20401238, </span>
<span class="gd">-    0.53450825, 0.65048638], [0.20385896, 0.53887991, 0.65150606], [</span>
<span class="gd">-    0.20372653, 0.54325208, 0.65251978], [0.20361709, 0.5476249, 0.6535266],</span>
<span class="gd">-    [0.20353258, 0.55199854, 0.65452542], [0.20347472, 0.55637318, 0.655515</span>
<span class="gd">-    ], [0.20344718, 0.56074869, 0.65649508], [0.20345161, 0.56512531, </span>
<span class="gd">-    0.65746419], [0.20349089, 0.56950304, 0.65842151], [0.20356842, </span>
<span class="gd">-    0.57388184, 0.65936642], [0.20368663, 0.57826181, 0.66029768], [</span>
<span class="gd">-    0.20384884, 0.58264293, 0.6612145], [0.20405904, 0.58702506, 0.66211645</span>
<span class="gd">-    ], [0.20431921, 0.59140842, 0.66300179], [0.20463464, 0.59579264, </span>
<span class="gd">-    0.66387079], [0.20500731, 0.60017798, 0.66472159], [0.20544449, </span>
<span class="gd">-    0.60456387, 0.66555409], [0.20596097, 0.60894927, 0.66636568], [</span>
<span class="gd">-    0.20654832, 0.61333521, 0.66715744], [0.20721003, 0.61772167, </span>
<span class="gd">-    0.66792838], [0.20795035, 0.62210845, 0.66867802], [0.20877302, </span>
<span class="gd">-    0.62649546, 0.66940555], [0.20968223, 0.63088252, 0.6701105], [</span>
<span class="gd">-    0.21068163, 0.63526951, 0.67079211], [0.21177544, 0.63965621, </span>
<span class="gd">-    0.67145005], [0.21298582, 0.64404072, 0.67208182], [0.21430361, </span>
<span class="gd">-    0.64842404, 0.67268861], [0.21572716, 0.65280655, 0.67326978], [</span>
<span class="gd">-    0.21726052, 0.65718791, 0.6738255], [0.21890636, 0.66156803, 0.67435491</span>
<span class="gd">-    ], [0.220668, 0.66594665, 0.67485792], [0.22255447, 0.67032297, </span>
<span class="gd">-    0.67533374], [0.22458372, 0.67469531, 0.67578061], [0.22673713, </span>
<span class="gd">-    0.67906542, 0.67620044], [0.22901625, 0.6834332, 0.67659251], [</span>
<span class="gd">-    0.23142316, 0.68779836, 0.67695703], [0.23395924, 0.69216072, </span>
<span class="gd">-    0.67729378], [0.23663857, 0.69651881, 0.67760151], [0.23946645, </span>
<span class="gd">-    0.70087194, 0.67788018], [0.24242624, 0.70522162, 0.67813088], [</span>
<span class="gd">-    0.24549008, 0.70957083, 0.67835215], [0.24863372, 0.71392166, </span>
<span class="gd">-    0.67854868], [0.25187832, 0.71827158, 0.67872193], [0.25524083, </span>
<span class="gd">-    0.72261873, 0.67887024], [0.25870947, 0.72696469, 0.67898912], [</span>
<span class="gd">-    0.26229238, 0.73130855, 0.67907645], [0.26604085, 0.73564353, </span>
<span class="gd">-    0.67914062], [0.26993099, 0.73997282, 0.67917264], [0.27397488, </span>
<span class="gd">-    0.74429484, 0.67917096], [0.27822463, 0.74860229, 0.67914468], [</span>
<span class="gd">-    0.28264201, 0.75290034, 0.67907959], [0.2873016, 0.75717817, 0.67899164</span>
<span class="gd">-    ], [0.29215894, 0.76144162, 0.67886578], [0.29729823, 0.76567816, </span>
<span class="gd">-    0.67871894], [0.30268199, 0.76989232, 0.67853896], [0.30835665, </span>
<span class="gd">-    0.77407636, 0.67833512], [0.31435139, 0.77822478, 0.67811118], [</span>
<span class="gd">-    0.3206671, 0.78233575, 0.67786729], [0.32733158, 0.78640315, 0.67761027</span>
<span class="gd">-    ], [0.33437168, 0.79042043, 0.67734882], [0.34182112, 0.79437948, </span>
<span class="gd">-    0.67709394], [0.34968889, 0.79827511, 0.67685638], [0.35799244, </span>
<span class="gd">-    0.80210037, 0.67664969], [0.36675371, 0.80584651, 0.67649539], [</span>
<span class="gd">-    0.3759816, 0.80950627, 0.67641393], [0.38566792, 0.81307432, 0.67642947</span>
<span class="gd">-    ], [0.39579804, 0.81654592, 0.67656899], [0.40634556, 0.81991799, </span>
<span class="gd">-    0.67686215], [0.41730243, 0.82318339, 0.67735255], [0.4285828, </span>
<span class="gd">-    0.82635051, 0.6780564], [0.44012728, 0.82942353, 0.67900049], [</span>
<span class="gd">-    0.45189421, 0.83240398, 0.68021733], [0.46378379, 0.83530763, 0.6817062</span>
<span class="gd">-    ], [0.47573199, 0.83814472, 0.68347352], [0.48769865, 0.84092197, </span>
<span class="gd">-    0.68552698], [0.49962354, 0.84365379, 0.68783929], [0.5114027, </span>
<span class="gd">-    0.8463718, 0.69029789], [0.52301693, 0.84908401, 0.69288545], [</span>
<span class="gd">-    0.53447549, 0.85179048, 0.69561066], [0.54578602, 0.8544913, 0.69848331</span>
<span class="gd">-    ], [0.55695565, 0.85718723, 0.70150427], [0.56798832, 0.85987893, </span>
<span class="gd">-    0.70468261], [0.57888639, 0.86256715, 0.70802931], [0.5896541, </span>
<span class="gd">-    0.8652532, 0.71154204], [0.60028928, 0.86793835, 0.71523675], [</span>
<span class="gd">-    0.61079441, 0.87062438, 0.71910895], [0.62116633, 0.87331311, </span>
<span class="gd">-    0.72317003], [0.63140509, 0.87600675, 0.72741689], [0.64150735, </span>
<span class="gd">-    0.87870746, 0.73185717], [0.65147219, 0.8814179, 0.73648495], [</span>
<span class="gd">-    0.66129632, 0.8841403, 0.74130658], [0.67097934, 0.88687758, 0.74631123</span>
<span class="gd">-    ], [0.68051833, 0.88963189, 0.75150483], [0.68991419, 0.89240612, </span>
<span class="gd">-    0.75687187], [0.69916533, 0.89520211, 0.76241714], [0.70827373, </span>
<span class="gd">-    0.89802257, 0.76812286], [0.71723995, 0.90086891, 0.77399039], [</span>
<span class="gd">-    0.72606665, 0.90374337, 0.7800041], [0.73475675, 0.90664718, 0.78615802</span>
<span class="gd">-    ], [0.74331358, 0.90958151, 0.79244474], [0.75174143, 0.91254787, </span>
<span class="gd">-    0.79884925], [0.76004473, 0.91554656, 0.80536823], [0.76827704, </span>
<span class="gd">-    0.91856549, 0.81196513], [0.77647029, 0.921603, 0.81855729], [</span>
<span class="gd">-    0.78462009, 0.92466151, 0.82514119], [0.79273542, 0.92773848, </span>
<span class="gd">-    0.83172131], [0.8008109, 0.93083672, 0.83829355], [0.80885107, </span>
<span class="gd">-    0.93395528, 0.84485982], [0.81685878, 0.9370938, 0.85142101], [</span>
<span class="gd">-    0.82483206, 0.94025378, 0.8579751], [0.83277661, 0.94343371, 0.86452477</span>
<span class="gd">-    ], [0.84069127, 0.94663473, 0.87106853], [0.84857662, 0.9498573, </span>
<span class="gd">-    0.8776059], [0.8564431, 0.95309792, 0.88414253], [0.86429066, </span>
<span class="gd">-    0.95635719, 0.89067759], [0.87218969, 0.95960708, 0.89725384]]</span>
<span class="gd">-_vlag_lut = [[0.13850039, 0.41331206, 0.74052025], [0.15077609, 0.41762684,</span>
<span class="gd">-    0.73970427], [0.16235219, 0.4219191, 0.7389667], [0.1733322, 0.42619024,</span>
<span class="gd">-    0.73832537], [0.18382538, 0.43044226, 0.73776764], [0.19394034, </span>
<span class="gd">-    0.4346772, 0.73725867], [0.20367115, 0.43889576, 0.73685314], [</span>
<span class="gd">-    0.21313625, 0.44310003, 0.73648045], [0.22231173, 0.44729079, </span>
<span class="gd">-    0.73619681], [0.23125148, 0.45146945, 0.73597803], [0.23998101, </span>
<span class="gd">-    0.45563715, 0.7358223], [0.24853358, 0.45979489, 0.73571524], [</span>
<span class="gd">-    0.25691416, 0.4639437, 0.73566943], [0.26513894, 0.46808455, 0.73568319</span>
<span class="gd">-    ], [0.27322194, 0.47221835, 0.73575497], [0.28117543, 0.47634598, </span>
<span class="gd">-    0.73588332], [0.28901021, 0.48046826, 0.73606686], [0.2967358, </span>
<span class="gd">-    0.48458597, 0.73630433], [0.30436071, 0.48869986, 0.73659451], [</span>
<span class="gd">-    0.3118955, 0.49281055, 0.73693255], [0.31935389, 0.49691847, 0.73730851</span>
<span class="gd">-    ], [0.32672701, 0.5010247, 0.73774013], [0.33402607, 0.50512971, </span>
<span class="gd">-    0.73821941], [0.34125337, 0.50923419, 0.73874905], [0.34840921, </span>
<span class="gd">-    0.51333892, 0.73933402], [0.35551826, 0.51744353, 0.73994642], [</span>
<span class="gd">-    0.3625676, 0.52154929, 0.74060763], [0.36956356, 0.52565656, 0.74131327</span>
<span class="gd">-    ], [0.37649902, 0.52976642, 0.74207698], [0.38340273, 0.53387791, </span>
<span class="gd">-    0.74286286], [0.39025859, 0.53799253, 0.7436962], [0.39706821, </span>
<span class="gd">-    0.54211081, 0.744578], [0.40384046, 0.54623277, 0.74549872], [</span>
<span class="gd">-    0.41058241, 0.55035849, 0.74645094], [0.41728385, 0.55448919, </span>
<span class="gd">-    0.74745174], [0.42395178, 0.55862494, 0.74849357], [0.4305964, </span>
<span class="gd">-    0.56276546, 0.74956387], [0.4372044, 0.56691228, 0.75068412], [</span>
<span class="gd">-    0.4437909, 0.57106468, 0.75183427], [0.45035117, 0.5752235, 0.75302312],</span>
<span class="gd">-    [0.45687824, 0.57938983, 0.75426297], [0.46339713, 0.58356191, </span>
<span class="gd">-    0.75551816], [0.46988778, 0.58774195, 0.75682037], [0.47635605, </span>
<span class="gd">-    0.59192986, 0.75816245], [0.48281101, 0.5961252, 0.75953212], [</span>
<span class="gd">-    0.4892374, 0.60032986, 0.76095418], [0.49566225, 0.60454154, 0.76238852</span>
<span class="gd">-    ], [0.50206137, 0.60876307, 0.76387371], [0.50845128, 0.61299312, </span>
<span class="gd">-    0.76538551], [0.5148258, 0.61723272, 0.76693475], [0.52118385, </span>
<span class="gd">-    0.62148236, 0.76852436], [0.52753571, 0.62574126, 0.77013939], [</span>
<span class="gd">-    0.53386831, 0.63001125, 0.77180152], [0.54020159, 0.63429038, 0.7734803</span>
<span class="gd">-    ], [0.54651272, 0.63858165, 0.77521306], [0.55282975, 0.64288207, </span>
<span class="gd">-    0.77695608], [0.55912585, 0.64719519, 0.77875327], [0.56542599, </span>
<span class="gd">-    0.65151828, 0.78056551], [0.57170924, 0.65585426, 0.78242747], [</span>
<span class="gd">-    0.57799572, 0.6602009, 0.78430751], [0.58426817, 0.66456073, 0.78623458</span>
<span class="gd">-    ], [0.590544, 0.66893178, 0.78818117], [0.59680758, 0.67331643, </span>
<span class="gd">-    0.79017369], [0.60307553, 0.67771273, 0.79218572], [0.60934065, </span>
<span class="gd">-    0.68212194, 0.79422987], [0.61559495, 0.68654548, 0.7963202], [</span>
<span class="gd">-    0.62185554, 0.69098125, 0.79842918], [0.62810662, 0.69543176, </span>
<span class="gd">-    0.80058381], [0.63436425, 0.69989499, 0.80275812], [0.64061445, </span>
<span class="gd">-    0.70437326, 0.80497621], [0.6468706, 0.70886488, 0.80721641], [</span>
<span class="gd">-    0.65312213, 0.7133717, 0.80949719], [0.65937818, 0.71789261, 0.81180392</span>
<span class="gd">-    ], [0.66563334, 0.72242871, 0.81414642], [0.67189155, 0.72697967, </span>
<span class="gd">-    0.81651872], [0.67815314, 0.73154569, 0.81892097], [0.68441395, </span>
<span class="gd">-    0.73612771, 0.82136094], [0.69068321, 0.74072452, 0.82382353], [</span>
<span class="gd">-    0.69694776, 0.7453385, 0.82633199], [0.70322431, 0.74996721, 0.8288583],</span>
<span class="gd">-    [0.70949595, 0.75461368, 0.83143221], [0.7157774, 0.75927574, </span>
<span class="gd">-    0.83402904], [0.72206299, 0.76395461, 0.83665922], [0.72835227, </span>
<span class="gd">-    0.76865061, 0.8393242], [0.73465238, 0.7733628, 0.84201224], [</span>
<span class="gd">-    0.74094862, 0.77809393, 0.84474951], [0.74725683, 0.78284158, </span>
<span class="gd">-    0.84750915], [0.75357103, 0.78760701, 0.85030217], [0.75988961, </span>
<span class="gd">-    0.79239077, 0.85313207], [0.76621987, 0.79719185, 0.85598668], [</span>
<span class="gd">-    0.77255045, 0.8020125, 0.85888658], [0.77889241, 0.80685102, 0.86181298</span>
<span class="gd">-    ], [0.78524572, 0.81170768, 0.86476656], [0.79159841, 0.81658489, </span>
<span class="gd">-    0.86776906], [0.79796459, 0.82148036, 0.8707962], [0.80434168, </span>
<span class="gd">-    0.82639479, 0.87385315], [0.8107221, 0.83132983, 0.87695392], [</span>
<span class="gd">-    0.81711301, 0.8362844, 0.88008641], [0.82351479, 0.84125863, 0.88325045</span>
<span class="gd">-    ], [0.82992772, 0.84625263, 0.88644594], [0.83634359, 0.85126806, </span>
<span class="gd">-    0.8896878], [0.84277295, 0.85630293, 0.89295721], [0.84921192, </span>
<span class="gd">-    0.86135782, 0.89626076], [0.85566206, 0.866432, 0.89959467], [</span>
<span class="gd">-    0.86211514, 0.87152627, 0.90297183], [0.86857483, 0.87663856, </span>
<span class="gd">-    0.90638248], [0.87504231, 0.88176648, 0.90981938], [0.88151194, </span>
<span class="gd">-    0.88690782, 0.91328493], [0.88797938, 0.89205857, 0.91677544], [</span>
<span class="gd">-    0.89443865, 0.89721298, 0.9202854], [0.90088204, 0.90236294, 0.92380601</span>
<span class="gd">-    ], [0.90729768, 0.90749778, 0.92732797], [0.91367037, 0.91260329, </span>
<span class="gd">-    0.93083814], [0.91998105, 0.91766106, 0.93431861], [0.92620596, </span>
<span class="gd">-    0.92264789, 0.93774647], [0.93231683, 0.9275351, 0.94109192], [</span>
<span class="gd">-    0.93827772, 0.9322888, 0.94432312], [0.94404755, 0.93686925, 0.94740137</span>
<span class="gd">-    ], [0.94958284, 0.94123072, 0.95027696], [0.95482682, 0.9453245, </span>
<span class="gd">-    0.95291103], [0.9597248, 0.94909728, 0.95525103], [0.96422552, </span>
<span class="gd">-    0.95249273, 0.95723271], [0.96826161, 0.95545812, 0.95882188], [</span>
<span class="gd">-    0.97178458, 0.95793984, 0.95995705], [0.97474105, 0.95989142, </span>
<span class="gd">-    0.96059997], [0.97708604, 0.96127366, 0.96071853], [0.97877855, </span>
<span class="gd">-    0.96205832, 0.96030095], [0.97978484, 0.96222949, 0.95935496], [</span>
<span class="gd">-    0.9805997, 0.96155216, 0.95813083], [0.98152619, 0.95993719, 0.95639322</span>
<span class="gd">-    ], [0.9819726, 0.95766608, 0.95399269], [0.98191855, 0.9547873, </span>
<span class="gd">-    0.95098107], [0.98138514, 0.95134771, 0.94740644], [0.98040845, </span>
<span class="gd">-    0.94739906, 0.94332125], [0.97902107, 0.94300131, 0.93878672], [</span>
<span class="gd">-    0.97729348, 0.93820409, 0.93385135], [0.9752533, 0.933073, 0.92858252],</span>
<span class="gd">-    [0.97297834, 0.92765261, 0.92302309], [0.97049104, 0.92200317, </span>
<span class="gd">-    0.91723505], [0.96784372, 0.91616744, 0.91126063], [0.96507281, </span>
<span class="gd">-    0.91018664, 0.90514124], [0.96222034, 0.90409203, 0.89890756], [</span>
<span class="gd">-    0.9593079, 0.89791478, 0.89259122], [0.95635626, 0.89167908, 0.88621654</span>
<span class="gd">-    ], [0.95338303, 0.88540373, 0.87980238], [0.95040174, 0.87910333, </span>
<span class="gd">-    0.87336339], [0.94742246, 0.87278899, 0.86691076], [0.94445249, </span>
<span class="gd">-    0.86646893, 0.86045277], [0.94150476, 0.86014606, 0.85399191], [</span>
<span class="gd">-    0.93857394, 0.85382798, 0.84753642], [0.93566206, 0.84751766, </span>
<span class="gd">-    0.84108935], [0.93277194, 0.8412164, 0.83465197], [0.92990106, </span>
<span class="gd">-    0.83492672, 0.82822708], [0.92704736, 0.82865028, 0.82181656], [</span>
<span class="gd">-    0.92422703, 0.82238092, 0.81541333], [0.92142581, 0.81612448, </span>
<span class="gd">-    0.80902415], [0.91864501, 0.80988032, 0.80264838], [0.91587578, </span>
<span class="gd">-    0.80365187, 0.79629001], [0.9131367, 0.79743115, 0.78994], [0.91041602,</span>
<span class="gd">-    0.79122265, 0.78360361], [0.90771071, 0.78502727, 0.77728196], [</span>
<span class="gd">-    0.90501581, 0.77884674, 0.7709771], [0.90235365, 0.77267117, 0.76467793</span>
<span class="gd">-    ], [0.8997019, 0.76650962, 0.75839484], [0.89705346, 0.76036481, </span>
<span class="gd">-    0.752131], [0.89444021, 0.75422253, 0.74587047], [0.89183355, </span>
<span class="gd">-    0.74809474, 0.73962689], [0.88923216, 0.74198168, 0.73340061], [</span>
<span class="gd">-    0.88665892, 0.73587283, 0.72717995], [0.88408839, 0.72977904, </span>
<span class="gd">-    0.72097718], [0.88153537, 0.72369332, 0.71478461], [0.87899389, </span>
<span class="gd">-    0.7176179, 0.70860487], [0.87645157, 0.71155805, 0.7024439], [0.8739399,</span>
<span class="gd">-    0.70549893, 0.6962854], [0.87142626, 0.6994551, 0.69014561], [0.8689268,</span>
<span class="gd">-    0.69341868, 0.68401597], [0.86643562, 0.687392, 0.67789917], [</span>
<span class="gd">-    0.86394434, 0.68137863, 0.67179927], [0.86147586, 0.67536728, 0.665704],</span>
<span class="gd">-    [0.85899928, 0.66937226, 0.6596292], [0.85654668, 0.66337773, 0.6535577</span>
<span class="gd">-    ], [0.85408818, 0.65739772, 0.64750494], [0.85164413, 0.65142189, </span>
<span class="gd">-    0.64145983], [0.84920091, 0.6454565, 0.63542932], [0.84676427, </span>
<span class="gd">-    0.63949827, 0.62941], [0.84433231, 0.63354773, 0.62340261], [0.84190106,</span>
<span class="gd">-    0.62760645, 0.61740899], [0.83947935, 0.62166951, 0.61142404], [</span>
<span class="gd">-    0.8370538, 0.61574332, 0.60545478], [0.83463975, 0.60981951, 0.59949247</span>
<span class="gd">-    ], [0.83221877, 0.60390724, 0.593547], [0.82980985, 0.59799607, </span>
<span class="gd">-    0.58760751], [0.82740268, 0.59209095, 0.58167944], [0.82498638, </span>
<span class="gd">-    0.5861973, 0.57576866], [0.82258181, 0.5803034, 0.56986307], [</span>
<span class="gd">-    0.82016611, 0.57442123, 0.56397539], [0.81776305, 0.56853725, </span>
<span class="gd">-    0.55809173], [0.81534551, 0.56266602, 0.55222741], [0.81294293, </span>
<span class="gd">-    0.55679056, 0.5463651], [0.81052113, 0.55092973, 0.54052443], [</span>
<span class="gd">-    0.80811509, 0.54506305, 0.53468464], [0.80568952, 0.53921036, </span>
<span class="gd">-    0.52886622], [0.80327506, 0.53335335, 0.52305077], [0.80084727, </span>
<span class="gd">-    0.52750583, 0.51725256], [0.79842217, 0.5216578, 0.51146173], [</span>
<span class="gd">-    0.79599382, 0.51581223, 0.50568155], [0.79355781, 0.50997127, </span>
<span class="gd">-    0.49991444], [0.79112596, 0.50412707, 0.49415289], [0.78867442, </span>
<span class="gd">-    0.49829386, 0.48841129], [0.7862306, 0.49245398, 0.48267247], [</span>
<span class="gd">-    0.7837687, 0.48662309, 0.47695216], [0.78130809, 0.4807883, 0.47123805],</span>
<span class="gd">-    [0.77884467, 0.47495151, 0.46553236], [0.77636283, 0.46912235, </span>
<span class="gd">-    0.45984473], [0.77388383, 0.46328617, 0.45416141], [0.77138912, </span>
<span class="gd">-    0.45745466, 0.44849398], [0.76888874, 0.45162042, 0.44283573], [</span>
<span class="gd">-    0.76638802, 0.44577901, 0.43718292], [0.76386116, 0.43994762, </span>
<span class="gd">-    0.43155211], [0.76133542, 0.43410655, 0.42592523], [0.75880631, </span>
<span class="gd">-    0.42825801, 0.42030488], [0.75624913, 0.42241905, 0.41470727], [</span>
<span class="gd">-    0.7536919, 0.41656866, 0.40911347], [0.75112748, 0.41071104, 0.40352792</span>
<span class="gd">-    ], [0.74854331, 0.40485474, 0.3979589], [0.74594723, 0.39899309, </span>
<span class="gd">-    0.39240088], [0.74334332, 0.39312199, 0.38685075], [0.74073277, </span>
<span class="gd">-    0.38723941, 0.3813074], [0.73809409, 0.38136133, 0.37578553], [</span>
<span class="gd">-    0.73544692, 0.37547129, 0.37027123], [0.73278943, 0.36956954, </span>
<span class="gd">-    0.36476549], [0.73011829, 0.36365761, 0.35927038], [0.72743485, </span>
<span class="gd">-    0.35773314, 0.35378465], [0.72472722, 0.35180504, 0.34831662], [</span>
<span class="gd">-    0.72200473, 0.34586421, 0.34285937], [0.71927052, 0.33990649, </span>
<span class="gd">-    0.33741033], [0.71652049, 0.33393396, 0.33197219], [0.71375362, </span>
<span class="gd">-    0.32794602, 0.32654545], [0.71096951, 0.32194148, 0.32113016], [</span>
<span class="gd">-    0.70816772, 0.31591904, 0.31572637], [0.70534784, 0.30987734, </span>
<span class="gd">-    0.31033414], [0.70250944, 0.30381489, 0.30495353], [0.69965211, </span>
<span class="gd">-    0.2977301, 0.2995846], [0.6967754, 0.29162126, 0.29422741], [0.69388446,</span>
<span class="gd">-    0.28548074, 0.28887769], [0.69097561, 0.2793096, 0.28353795], [</span>
<span class="gd">-    0.68803513, 0.27311993, 0.27821876], [0.6850794, 0.26689144, 0.27290694</span>
<span class="gd">-    ], [0.682108, 0.26062114, 0.26760246], [0.67911013, 0.2543177, </span>
<span class="gd">-    0.26231367], [0.67609393, 0.24796818, 0.25703372], [0.67305921, </span>
<span class="gd">-    0.24156846, 0.25176238], [0.67000176, 0.23511902, 0.24650278], [</span>
<span class="gd">-    0.66693423, 0.22859879, 0.24124404], [0.6638441, 0.22201742, 0.2359961],</span>
<span class="gd">-    [0.66080672, 0.21526712, 0.23069468]]</span>
<span class="gd">-_icefire_lut = [[0.73936227, 0.90443867, 0.85757238], [0.72888063, </span>
<span class="gd">-    0.89639109, 0.85488394], [0.71834255, 0.88842162, 0.8521605], [</span>
<span class="gd">-    0.70773866, 0.88052939, 0.849422], [0.69706215, 0.87271313, 0.84668315],</span>
<span class="gd">-    [0.68629021, 0.86497329, 0.84398721], [0.67543654, 0.85730617, </span>
<span class="gd">-    0.84130969], [0.66448539, 0.84971123, 0.83868005], [0.65342679, </span>
<span class="gd">-    0.84218728, 0.83611512], [0.64231804, 0.83471867, 0.83358584], [</span>
<span class="gd">-    0.63117745, 0.827294, 0.83113431], [0.62000484, 0.81991069, 0.82876741],</span>
<span class="gd">-    [0.60879435, 0.81256797, 0.82648905], [0.59754118, 0.80526458, </span>
<span class="gd">-    0.82430414], [0.58624247, 0.79799884, 0.82221573], [0.57489525, </span>
<span class="gd">-    0.7907688, 0.82022901], [0.56349779, 0.78357215, 0.81834861], [</span>
<span class="gd">-    0.55204294, 0.77640827, 0.81657563], [0.54052516, 0.76927562, </span>
<span class="gd">-    0.81491462], [0.52894085, 0.76217215, 0.81336913], [0.51728854, </span>
<span class="gd">-    0.75509528, 0.81194156], [0.50555676, 0.74804469, 0.81063503], [</span>
<span class="gd">-    0.49373871, 0.7410187, 0.80945242], [0.48183174, 0.73401449, 0.80839675</span>
<span class="gd">-    ], [0.46982587, 0.72703075, 0.80747097], [0.45770893, 0.72006648, </span>
<span class="gd">-    0.80667756], [0.44547249, 0.71311941, 0.80601991], [0.43318643, </span>
<span class="gd">-    0.70617126, 0.80549278], [0.42110294, 0.69916972, 0.80506683], [</span>
<span class="gd">-    0.40925101, 0.69211059, 0.80473246], [0.3976693, 0.68498786, 0.80448272</span>
<span class="gd">-    ], [0.38632002, 0.67781125, 0.80431024], [0.37523981, 0.67057537, </span>
<span class="gd">-    0.80420832], [0.36442578, 0.66328229, 0.80417474], [0.35385939, </span>
<span class="gd">-    0.65593699, 0.80420591], [0.34358916, 0.64853177, 0.8043], [0.33355526,</span>
<span class="gd">-    0.64107876, 0.80445484], [0.32383062, 0.63356578, 0.80467091], [</span>
<span class="gd">-    0.31434372, 0.62600624, 0.8049475], [0.30516161, 0.618389, 0.80528692],</span>
<span class="gd">-    [0.29623491, 0.61072284, 0.80569021], [0.28759072, 0.60300319, </span>
<span class="gd">-    0.80616055], [0.27923924, 0.59522877, 0.80669803], [0.27114651, </span>
<span class="gd">-    0.5874047, 0.80730545], [0.26337153, 0.57952055, 0.80799113], [</span>
<span class="gd">-    0.25588696, 0.57157984, 0.80875922], [0.248686, 0.56358255, 0.80961366],</span>
<span class="gd">-    [0.24180668, 0.55552289, 0.81055123], [0.23526251, 0.54739477, </span>
<span class="gd">-    0.8115939], [0.22921445, 0.53918506, 0.81267292], [0.22397687, </span>
<span class="gd">-    0.53086094, 0.8137141], [0.21977058, 0.52241482, 0.81457651], [</span>
<span class="gd">-    0.21658989, 0.51384321, 0.81528511], [0.21452772, 0.50514155, </span>
<span class="gd">-    0.81577278], [0.21372783, 0.49630865, 0.81589566], [0.21409503, </span>
<span class="gd">-    0.48734861, 0.81566163], [0.2157176, 0.47827123, 0.81487615], [</span>
<span class="gd">-    0.21842857, 0.46909168, 0.81351614], [0.22211705, 0.45983212, </span>
<span class="gd">-    0.81146983], [0.22665681, 0.45052233, 0.80860217], [0.23176013, </span>
<span class="gd">-    0.44119137, 0.80494325], [0.23727775, 0.43187704, 0.80038017], [</span>
<span class="gd">-    0.24298285, 0.42261123, 0.79493267], [0.24865068, 0.41341842, </span>
<span class="gd">-    0.78869164], [0.25423116, 0.40433127, 0.78155831], [0.25950239, </span>
<span class="gd">-    0.39535521, 0.77376848], [0.2644736, 0.38651212, 0.76524809], [</span>
<span class="gd">-    0.26901584, 0.37779582, 0.75621942], [0.27318141, 0.36922056, 0.746605],</span>
<span class="gd">-    [0.27690355, 0.3607736, 0.73659374], [0.28023585, 0.35244234, </span>
<span class="gd">-    0.72622103], [0.28306009, 0.34438449, 0.71500731], [0.28535896, </span>
<span class="gd">-    0.33660243, 0.70303975], [0.28708711, 0.32912157, 0.69034504], [</span>
<span class="gd">-    0.28816354, 0.32200604, 0.67684067], [0.28862749, 0.31519824, </span>
<span class="gd">-    0.66278813], [0.28847904, 0.30869064, 0.6482815], [0.28770912, </span>
<span class="gd">-    0.30250126, 0.63331265], [0.28640325, 0.29655509, 0.61811374], [</span>
<span class="gd">-    0.28458943, 0.29082155, 0.60280913], [0.28233561, 0.28527482, </span>
<span class="gd">-    0.58742866], [0.27967038, 0.2798938, 0.57204225], [0.27665361, </span>
<span class="gd">-    0.27465357, 0.55667809], [0.27332564, 0.2695165, 0.54145387], [</span>
<span class="gd">-    0.26973851, 0.26447054, 0.52634916], [0.2659204, 0.25949691, 0.511417],</span>
<span class="gd">-    [0.26190145, 0.25458123, 0.49668768], [0.2577151, 0.24971691, </span>
<span class="gd">-    0.48214874], [0.25337618, 0.24490494, 0.46778758], [0.24890842, </span>
<span class="gd">-    0.24013332, 0.45363816], [0.24433654, 0.23539226, 0.4397245], [</span>
<span class="gd">-    0.23967922, 0.23067729, 0.4260591], [0.23495608, 0.22598894, 0.41262952</span>
<span class="gd">-    ], [0.23018113, 0.22132414, 0.39945577], [0.22534609, 0.21670847, </span>
<span class="gd">-    0.38645794], [0.22048761, 0.21211723, 0.37372555], [0.2156198, </span>
<span class="gd">-    0.20755389, 0.36125301], [0.21074637, 0.20302717, 0.34903192], [</span>
<span class="gd">-    0.20586893, 0.19855368, 0.33701661], [0.20101757, 0.19411573, </span>
<span class="gd">-    0.32529173], [0.19619947, 0.18972425, 0.31383846], [0.19140726, </span>
<span class="gd">-    0.18540157, 0.30260777], [0.1866769, 0.1811332, 0.29166583], [</span>
<span class="gd">-    0.18201285, 0.17694992, 0.28088776], [0.17745228, 0.17282141, </span>
<span class="gd">-    0.27044211], [0.17300684, 0.16876921, 0.26024893], [0.16868273, </span>
<span class="gd">-    0.16479861, 0.25034479], [0.16448691, 0.16091728, 0.24075373], [</span>
<span class="gd">-    0.16043195, 0.15714351, 0.23141745], [0.15652427, 0.15348248, </span>
<span class="gd">-    0.22238175], [0.15277065, 0.14994111, 0.21368395], [0.14918274, </span>
<span class="gd">-    0.14653431, 0.20529486], [0.14577095, 0.14327403, 0.19720829], [</span>
<span class="gd">-    0.14254381, 0.14016944, 0.18944326], [0.13951035, 0.13723063, </span>
<span class="gd">-    0.18201072], [0.13667798, 0.13446606, 0.17493774], [0.13405762, </span>
<span class="gd">-    0.13188822, 0.16820842], [0.13165767, 0.12950667, 0.16183275], [</span>
<span class="gd">-    0.12948748, 0.12733187, 0.15580631], [0.12755435, 0.1253723, 0.15014098</span>
<span class="gd">-    ], [0.12586516, 0.12363617, 0.1448459], [0.12442647, 0.12213143, </span>
<span class="gd">-    0.13992571], [0.12324241, 0.12086419, 0.13539995], [0.12232067, </span>
<span class="gd">-    0.11984278, 0.13124644], [0.12166209, 0.11907077, 0.12749671], [</span>
<span class="gd">-    0.12126982, 0.11855309, 0.12415079], [0.12114244, 0.11829179, 0.1212385</span>
<span class="gd">-    ], [0.12127766, 0.11828837, 0.11878534], [0.12284806, 0.1179729, </span>
<span class="gd">-    0.11772022], [0.12619498, 0.11721796, 0.11770203], [0.129968, </span>
<span class="gd">-    0.11663788, 0.11792377], [0.13410011, 0.11625146, 0.11839138], [</span>
<span class="gd">-    0.13855459, 0.11606618, 0.11910584], [0.14333775, 0.11607038, 0.1200606</span>
<span class="gd">-    ], [0.148417, 0.11626929, 0.12125453], [0.15377389, 0.11666192, </span>
<span class="gd">-    0.12268364], [0.15941427, 0.11723486, 0.12433911], [0.16533376, </span>
<span class="gd">-    0.11797856, 0.12621303], [0.17152547, 0.11888403, 0.12829735], [</span>
<span class="gd">-    0.17797765, 0.11994436, 0.13058435], [0.18468769, 0.12114722, </span>
<span class="gd">-    0.13306426], [0.19165663, 0.12247737, 0.13572616], [0.19884415, </span>
<span class="gd">-    0.12394381, 0.1385669], [0.20627181, 0.12551883, 0.14157124], [</span>
<span class="gd">-    0.21394877, 0.12718055, 0.14472604], [0.22184572, 0.12893119, </span>
<span class="gd">-    0.14802579], [0.22994394, 0.13076731, 0.15146314], [0.23823937, </span>
<span class="gd">-    0.13267611, 0.15502793], [0.24676041, 0.13462172, 0.15870321], [</span>
<span class="gd">-    0.25546457, 0.13661751, 0.16248722], [0.26433628, 0.13865956, </span>
<span class="gd">-    0.16637301], [0.27341345, 0.14070412, 0.17034221], [0.28264773, </span>
<span class="gd">-    0.14277192, 0.1743957], [0.29202272, 0.14486161, 0.17852793], [</span>
<span class="gd">-    0.30159648, 0.14691224, 0.1827169], [0.31129002, 0.14897583, 0.18695213</span>
<span class="gd">-    ], [0.32111555, 0.15103351, 0.19119629], [0.33107961, 0.1530674, </span>
<span class="gd">-    0.19543758], [0.34119892, 0.15504762, 0.1996803], [0.35142388, </span>
<span class="gd">-    0.15701131, 0.20389086], [0.36178937, 0.1589124, 0.20807639], [</span>
<span class="gd">-    0.37229381, 0.16073993, 0.21223189], [0.38288348, 0.16254006, 0.2163249</span>
<span class="gd">-    ], [0.39359592, 0.16426336, 0.22036577], [0.40444332, 0.16588767, </span>
<span class="gd">-    0.22434027], [0.41537995, 0.16745325, 0.2282297], [0.42640867, </span>
<span class="gd">-    0.16894939, 0.23202755], [0.43754706, 0.17034847, 0.23572899], [</span>
<span class="gd">-    0.44878564, 0.1716535, 0.23932344], [0.4601126, 0.17287365, 0.24278607],</span>
<span class="gd">-    [0.47151732, 0.17401641, 0.24610337], [0.48300689, 0.17506676, </span>
<span class="gd">-    0.2492737], [0.49458302, 0.17601892, 0.25227688], [0.50623876, </span>
<span class="gd">-    0.17687777, 0.255096], [0.5179623, 0.17765528, 0.2577162], [0.52975234,</span>
<span class="gd">-    0.17835232, 0.2601134], [0.54159776, 0.17898292, 0.26226847], [</span>
<span class="gd">-    0.55348804, 0.17956232, 0.26416003], [0.56541729, 0.18010175, </span>
<span class="gd">-    0.26575971], [0.57736669, 0.180631, 0.26704888], [0.58932081, </span>
<span class="gd">-    0.18117827, 0.26800409], [0.60127582, 0.18175888, 0.26858488], [</span>
<span class="gd">-    0.61319563, 0.1824336, 0.2687872], [0.62506376, 0.18324015, 0.26858301],</span>
<span class="gd">-    [0.63681202, 0.18430173, 0.26795276], [0.64842603, 0.18565472, </span>
<span class="gd">-    0.26689463], [0.65988195, 0.18734638, 0.26543435], [0.67111966, </span>
<span class="gd">-    0.18948885, 0.26357955], [0.68209194, 0.19216636, 0.26137175], [</span>
<span class="gd">-    0.69281185, 0.19535326, 0.25887063], [0.70335022, 0.19891271, </span>
<span class="gd">-    0.25617971], [0.71375229, 0.20276438, 0.25331365], [0.72401436, </span>
<span class="gd">-    0.20691287, 0.25027366], [0.73407638, 0.21145051, 0.24710661], [</span>
<span class="gd">-    0.74396983, 0.21631913, 0.24380715], [0.75361506, 0.22163653, </span>
<span class="gd">-    0.24043996], [0.7630579, 0.22731637, 0.23700095], [0.77222228, </span>
<span class="gd">-    0.23346231, 0.23356628], [0.78115441, 0.23998404, 0.23013825], [</span>
<span class="gd">-    0.78979746, 0.24694858, 0.22678822], [0.79819286, 0.25427223, </span>
<span class="gd">-    0.22352658], [0.80630444, 0.26198807, 0.22040877], [0.81417437, </span>
<span class="gd">-    0.27001406, 0.21744645], [0.82177364, 0.27837336, 0.21468316], [</span>
<span class="gd">-    0.82915955, 0.28696963, 0.21210766], [0.83628628, 0.2958499, 0.20977813</span>
<span class="gd">-    ], [0.84322168, 0.30491136, 0.20766435], [0.84995458, 0.31415945, </span>
<span class="gd">-    0.2057863], [0.85648867, 0.32358058, 0.20415327], [0.86286243, </span>
<span class="gd">-    0.33312058, 0.20274969], [0.86908321, 0.34276705, 0.20157271], [</span>
<span class="gd">-    0.87512876, 0.3525416, 0.20064949], [0.88100349, 0.36243385, 0.19999078</span>
<span class="gd">-    ], [0.8866469, 0.37249496, 0.1997976], [0.89203964, 0.38273475, </span>
<span class="gd">-    0.20013431], [0.89713496, 0.39318156, 0.20121514], [0.90195099, </span>
<span class="gd">-    0.40380687, 0.20301555], [0.90648379, 0.41460191, 0.20558847], [</span>
<span class="gd">-    0.9106967, 0.42557857, 0.20918529], [0.91463791, 0.43668557, 0.21367954</span>
<span class="gd">-    ], [0.91830723, 0.44790913, 0.21916352], [0.92171507, 0.45922856, </span>
<span class="gd">-    0.22568002], [0.92491786, 0.4705936, 0.23308207], [0.92790792, </span>
<span class="gd">-    0.48200153, 0.24145932], [0.93073701, 0.49341219, 0.25065486], [</span>
<span class="gd">-    0.93343918, 0.5048017, 0.26056148], [0.93602064, 0.51616486, 0.27118485</span>
<span class="gd">-    ], [0.93850535, 0.52748892, 0.28242464], [0.94092933, 0.53875462, </span>
<span class="gd">-    0.29416042], [0.94330011, 0.5499628, 0.30634189], [0.94563159, </span>
<span class="gd">-    0.56110987, 0.31891624], [0.94792955, 0.57219822, 0.33184256], [</span>
<span class="gd">-    0.95020929, 0.5832232, 0.34508419], [0.95247324, 0.59419035, 0.35859866</span>
<span class="gd">-    ], [0.95471709, 0.60510869, 0.37236035], [0.95698411, 0.61595766, </span>
<span class="gd">-    0.38629631], [0.95923863, 0.62676473, 0.40043317], [0.9615041, </span>
<span class="gd">-    0.6375203, 0.41474106], [0.96371553, 0.64826619, 0.42928335], [</span>
<span class="gd">-    0.96591497, 0.65899621, 0.44380444], [0.96809871, 0.66971662, </span>
<span class="gd">-    0.45830232], [0.9702495, 0.6804394, 0.47280492], [0.9723881, 0.69115622,</span>
<span class="gd">-    0.48729272], [0.97450723, 0.70187358, 0.50178034], [0.9766108, 0.712592,</span>
<span class="gd">-    0.51626837], [0.97871716, 0.72330511, 0.53074053], [0.98082222, </span>
<span class="gd">-    0.73401769, 0.54520694], [0.9829001, 0.74474445, 0.5597019], [</span>
<span class="gd">-    0.98497466, 0.75547635, 0.57420239], [0.98705581, 0.76621129, </span>
<span class="gd">-    0.58870185], [0.98913325, 0.77695637, 0.60321626], [0.99119918, </span>
<span class="gd">-    0.78771716, 0.61775821], [0.9932672, 0.79848979, 0.63231691], [</span>
<span class="gd">-    0.99535958, 0.80926704, 0.64687278], [0.99740544, 0.82008078, </span>
<span class="gd">-    0.66150571], [0.9992197, 0.83100723, 0.6764127]]</span>
<span class="gd">-_flare_lut = [[0.92907237, 0.68878959, 0.50411509], [0.92891402, 0.68494686,</span>
<span class="gd">-    0.50173994], [0.92864754, 0.68116207, 0.4993754], [0.92836112, </span>
<span class="gd">-    0.67738527, 0.49701572], [0.9280599, 0.67361354, 0.49466044], [</span>
<span class="gd">-    0.92775569, 0.66983999, 0.49230866], [0.9274375, 0.66607098, 0.48996097</span>
<span class="gd">-    ], [0.927111, 0.66230315, 0.48761688], [0.92677996, 0.6585342, 0.485276</span>
<span class="gd">-    ], [0.92644317, 0.65476476, 0.48293832], [0.92609759, 0.65099658, </span>
<span class="gd">-    0.48060392], [0.925747, 0.64722729, 0.47827244], [0.92539502, </span>
<span class="gd">-    0.64345456, 0.47594352], [0.92503106, 0.6396848, 0.47361782], [</span>
<span class="gd">-    0.92466877, 0.6359095, 0.47129427], [0.92429828, 0.63213463, 0.46897349</span>
<span class="gd">-    ], [0.92392172, 0.62835879, 0.46665526], [0.92354597, 0.62457749, </span>
<span class="gd">-    0.46433898], [0.9231622, 0.6207962, 0.46202524], [0.92277222, </span>
<span class="gd">-    0.61701365, 0.45971384], [0.92237978, 0.61322733, 0.45740444], [</span>
<span class="gd">-    0.92198615, 0.60943622, 0.45509686], [0.92158735, 0.60564276, </span>
<span class="gd">-    0.45279137], [0.92118373, 0.60184659, 0.45048789], [0.92077582, </span>
<span class="gd">-    0.59804722, 0.44818634], [0.92036413, 0.59424414, 0.44588663], [</span>
<span class="gd">-    0.91994924, 0.5904368, 0.44358868], [0.91952943, 0.58662619, 0.4412926],</span>
<span class="gd">-    [0.91910675, 0.58281075, 0.43899817], [0.91868096, 0.57899046, </span>
<span class="gd">-    0.4367054], [0.91825103, 0.57516584, 0.43441436], [0.91781857, </span>
<span class="gd">-    0.57133556, 0.43212486], [0.9173814, 0.56750099, 0.4298371], [</span>
<span class="gd">-    0.91694139, 0.56366058, 0.42755089], [0.91649756, 0.55981483, </span>
<span class="gd">-    0.42526631], [0.91604942, 0.55596387, 0.42298339], [0.9155979, </span>
<span class="gd">-    0.55210684, 0.42070204], [0.9151409, 0.54824485, 0.4184247], [</span>
<span class="gd">-    0.91466138, 0.54438817, 0.41617858], [0.91416896, 0.54052962, </span>
<span class="gd">-    0.41396347], [0.91366559, 0.53666778, 0.41177769], [0.91315173, </span>
<span class="gd">-    0.53280208, 0.40962196], [0.91262605, 0.52893336, 0.40749715], [</span>
<span class="gd">-    0.91208866, 0.52506133, 0.40540404], [0.91153952, 0.52118582, </span>
<span class="gd">-    0.40334346], [0.91097732, 0.51730767, 0.4013163], [0.910403, 0.51342591,</span>
<span class="gd">-    0.39932342], [0.90981494, 0.50954168, 0.39736571], [0.90921368, </span>
<span class="gd">-    0.5056543, 0.39544411], [0.90859797, 0.50176463, 0.39355952], [</span>
<span class="gd">-    0.90796841, 0.49787195, 0.39171297], [0.90732341, 0.4939774, 0.38990532</span>
<span class="gd">-    ], [0.90666382, 0.49008006, 0.38813773], [0.90598815, 0.486181, </span>
<span class="gd">-    0.38641107], [0.90529624, 0.48228017, 0.38472641], [0.90458808, </span>
<span class="gd">-    0.47837738, 0.38308489], [0.90386248, 0.47447348, 0.38148746], [</span>
<span class="gd">-    0.90311921, 0.4705685, 0.37993524], [0.90235809, 0.46666239, 0.37842943</span>
<span class="gd">-    ], [0.90157824, 0.46275577, 0.37697105], [0.90077904, 0.45884905, </span>
<span class="gd">-    0.37556121], [0.89995995, 0.45494253, 0.37420106], [0.89912041, </span>
<span class="gd">-    0.4510366, 0.37289175], [0.8982602, 0.44713126, 0.37163458], [</span>
<span class="gd">-    0.89737819, 0.44322747, 0.37043052], [0.89647387, 0.43932557, </span>
<span class="gd">-    0.36928078], [0.89554477, 0.43542759, 0.36818855], [0.89458871, </span>
<span class="gd">-    0.4315354, 0.36715654], [0.89360794, 0.42764714, 0.36618273], [</span>
<span class="gd">-    0.89260152, 0.42376366, 0.36526813], [0.8915687, 0.41988565, 0.36441384</span>
<span class="gd">-    ], [0.89050882, 0.41601371, 0.36362102], [0.8894159, 0.41215334, </span>
<span class="gd">-    0.36289639], [0.888292, 0.40830288, 0.36223756], [0.88713784, </span>
<span class="gd">-    0.40446193, 0.36164328], [0.88595253, 0.40063149, 0.36111438], [</span>
<span class="gd">-    0.88473115, 0.39681635, 0.3606566], [0.88347246, 0.39301805, 0.36027074</span>
<span class="gd">-    ], [0.88217931, 0.38923439, 0.35995244], [0.880851, 0.38546632, </span>
<span class="gd">-    0.35970244], [0.87947728, 0.38172422, 0.35953127], [0.87806542, </span>
<span class="gd">-    0.37800172, 0.35942941], [0.87661509, 0.37429964, 0.35939659], [</span>
<span class="gd">-    0.87511668, 0.37062819, 0.35944178], [0.87357554, 0.36698279, </span>
<span class="gd">-    0.35955811], [0.87199254, 0.3633634, 0.35974223], [0.87035691, </span>
<span class="gd">-    0.35978174, 0.36000516], [0.86867647, 0.35623087, 0.36033559], [</span>
<span class="gd">-    0.86694949, 0.35271349, 0.36073358], [0.86516775, 0.34923921, </span>
<span class="gd">-    0.36120624], [0.86333996, 0.34580008, 0.36174113], [0.86145909, </span>
<span class="gd">-    0.3424046, 0.36234402], [0.85952586, 0.33905327, 0.36301129], [</span>
<span class="gd">-    0.85754536, 0.33574168, 0.36373567], [0.855514, 0.33247568, 0.36451271],</span>
<span class="gd">-    [0.85344392, 0.32924217, 0.36533344], [0.8513284, 0.32604977, </span>
<span class="gd">-    0.36620106], [0.84916723, 0.32289973, 0.36711424], [0.84696243, </span>
<span class="gd">-    0.31979068, 0.36806976], [0.84470627, 0.31673295, 0.36907066], [</span>
<span class="gd">-    0.84240761, 0.31371695, 0.37010969], [0.84005337, 0.31075974, </span>
<span class="gd">-    0.37119284], [0.83765537, 0.30784814, 0.3723105], [0.83520234, </span>
<span class="gd">-    0.30499724, 0.37346726], [0.83270291, 0.30219766, 0.37465552], [</span>
<span class="gd">-    0.83014895, 0.29946081, 0.37587769], [0.82754694, 0.29677989, </span>
<span class="gd">-    0.37712733], [0.82489111, 0.29416352, 0.37840532], [0.82218644, </span>
<span class="gd">-    0.29160665, 0.37970606], [0.81942908, 0.28911553, 0.38102921], [</span>
<span class="gd">-    0.81662276, 0.28668665, 0.38236999], [0.81376555, 0.28432371, 0.383727],</span>
<span class="gd">-    [0.81085964, 0.28202508, 0.38509649], [0.8079055, 0.27979128, </span>
<span class="gd">-    0.38647583], [0.80490309, 0.27762348, 0.3878626], [0.80185613, </span>
<span class="gd">-    0.2755178, 0.38925253], [0.79876118, 0.27347974, 0.39064559], [</span>
<span class="gd">-    0.79562644, 0.27149928, 0.39203532], [0.79244362, 0.2695883, 0.39342447</span>
<span class="gd">-    ], [0.78922456, 0.26773176, 0.3948046], [0.78596161, 0.26594053, </span>
<span class="gd">-    0.39617873], [0.7826624, 0.26420493, 0.39754146], [0.77932717, </span>
<span class="gd">-    0.26252522, 0.39889102], [0.77595363, 0.2609049, 0.4002279], [</span>
<span class="gd">-    0.77254999, 0.25933319, 0.40154704], [0.76911107, 0.25781758, </span>
<span class="gd">-    0.40284959], [0.76564158, 0.25635173, 0.40413341], [0.76214598, </span>
<span class="gd">-    0.25492998, 0.40539471], [0.75861834, 0.25356035, 0.40663694], [</span>
<span class="gd">-    0.75506533, 0.25223402, 0.40785559], [0.75148963, 0.2509473, 0.40904966</span>
<span class="gd">-    ], [0.74788835, 0.24970413, 0.41022028], [0.74426345, 0.24850191, </span>
<span class="gd">-    0.41136599], [0.74061927, 0.24733457, 0.41248516], [0.73695678, </span>
<span class="gd">-    0.24620072, 0.41357737], [0.73327278, 0.24510469, 0.41464364], [</span>
<span class="gd">-    0.72957096, 0.24404127, 0.4156828], [0.72585394, 0.24300672, 0.41669383</span>
<span class="gd">-    ], [0.7221226, 0.24199971, 0.41767651], [0.71837612, 0.24102046, </span>
<span class="gd">-    0.41863486], [0.71463236, 0.24004289, 0.41956983], [0.7108932, </span>
<span class="gd">-    0.23906316, 0.42048681], [0.70715842, 0.23808142, 0.42138647], [</span>
<span class="gd">-    0.70342811, 0.2370976, 0.42226844], [0.69970218, 0.23611179, 0.42313282</span>
<span class="gd">-    ], [0.69598055, 0.2351247, 0.42397678], [0.69226314, 0.23413578, </span>
<span class="gd">-    0.42480327], [0.68854988, 0.23314511, 0.42561234], [0.68484064, </span>
<span class="gd">-    0.23215279, 0.42640419], [0.68113541, 0.23115942, 0.42717615], [</span>
<span class="gd">-    0.67743412, 0.23016472, 0.42792989], [0.67373662, 0.22916861, </span>
<span class="gd">-    0.42866642], [0.67004287, 0.22817117, 0.42938576], [0.66635279, </span>
<span class="gd">-    0.22717328, 0.43008427], [0.66266621, 0.22617435, 0.43076552], [</span>
<span class="gd">-    0.65898313, 0.22517434, 0.43142956], [0.65530349, 0.22417381, </span>
<span class="gd">-    0.43207427], [0.65162696, 0.22317307, 0.4327001], [0.64795375, </span>
<span class="gd">-    0.22217149, 0.43330852], [0.64428351, 0.22116972, 0.43389854], [</span>
<span class="gd">-    0.64061624, 0.22016818, 0.43446845], [0.63695183, 0.21916625, </span>
<span class="gd">-    0.43502123], [0.63329016, 0.21816454, 0.43555493], [0.62963102, </span>
<span class="gd">-    0.2171635, 0.43606881], [0.62597451, 0.21616235, 0.43656529], [</span>
<span class="gd">-    0.62232019, 0.21516239, 0.43704153], [0.61866821, 0.21416307, </span>
<span class="gd">-    0.43749868], [0.61501835, 0.21316435, 0.43793808], [0.61137029, </span>
<span class="gd">-    0.21216761, 0.4383556], [0.60772426, 0.2111715, 0.43875552], [</span>
<span class="gd">-    0.60407977, 0.21017746, 0.43913439], [0.60043678, 0.20918503, </span>
<span class="gd">-    0.43949412], [0.59679524, 0.20819447, 0.43983393], [0.59315487, </span>
<span class="gd">-    0.20720639, 0.44015254], [0.58951566, 0.20622027, 0.44045213], [</span>
<span class="gd">-    0.58587715, 0.20523751, 0.44072926], [0.5822395, 0.20425693, 0.44098758</span>
<span class="gd">-    ], [0.57860222, 0.20328034, 0.44122241], [0.57496549, 0.20230637, </span>
<span class="gd">-    0.44143805], [0.57132875, 0.20133689, 0.4416298], [0.56769215, </span>
<span class="gd">-    0.20037071, 0.44180142], [0.5640552, 0.19940936, 0.44194923], [</span>
<span class="gd">-    0.56041794, 0.19845221, 0.44207535], [0.55678004, 0.1975, 0.44217824],</span>
<span class="gd">-    [0.55314129, 0.19655316, 0.44225723], [0.54950166, 0.19561118, </span>
<span class="gd">-    0.44231412], [0.54585987, 0.19467771, 0.44234111], [0.54221157, </span>
<span class="gd">-    0.19375869, 0.44233698], [0.5385549, 0.19285696, 0.44229959], [</span>
<span class="gd">-    0.5348913, 0.19197036, 0.44222958], [0.53122177, 0.1910974, 0.44212735],</span>
<span class="gd">-    [0.52754464, 0.19024042, 0.44199159], [0.52386353, 0.18939409, </span>
<span class="gd">-    0.44182449], [0.52017476, 0.18856368, 0.44162345], [0.51648277, </span>
<span class="gd">-    0.18774266, 0.44139128], [0.51278481, 0.18693492, 0.44112605], [</span>
<span class="gd">-    0.50908361, 0.18613639, 0.4408295], [0.50537784, 0.18534893, 0.44050064</span>
<span class="gd">-    ], [0.50166912, 0.18457008, 0.44014054], [0.49795686, 0.18380056, </span>
<span class="gd">-    0.43974881], [0.49424218, 0.18303865, 0.43932623], [0.49052472, </span>
<span class="gd">-    0.18228477, 0.43887255], [0.48680565, 0.1815371, 0.43838867], [</span>
<span class="gd">-    0.48308419, 0.18079663, 0.43787408], [0.47936222, 0.18006056, </span>
<span class="gd">-    0.43733022], [0.47563799, 0.17933127, 0.43675585], [0.47191466, </span>
<span class="gd">-    0.17860416, 0.43615337], [0.46818879, 0.17788392, 0.43552047], [</span>
<span class="gd">-    0.46446454, 0.17716458, 0.43486036], [0.46073893, 0.17645017, </span>
<span class="gd">-    0.43417097], [0.45701462, 0.17573691, 0.43345429], [0.45329097, </span>
<span class="gd">-    0.17502549, 0.43271025], [0.44956744, 0.17431649, 0.4319386], [</span>
<span class="gd">-    0.44584668, 0.17360625, 0.43114133], [0.44212538, 0.17289906, </span>
<span class="gd">-    0.43031642], [0.43840678, 0.17219041, 0.42946642], [0.43469046, </span>
<span class="gd">-    0.17148074, 0.42859124], [0.4309749, 0.17077192, 0.42769008], [</span>
<span class="gd">-    0.42726297, 0.17006003, 0.42676519], [0.42355299, 0.16934709, </span>
<span class="gd">-    0.42581586], [0.41984535, 0.16863258, 0.42484219], [0.41614149, </span>
<span class="gd">-    0.16791429, 0.42384614], [0.41244029, 0.16719372, 0.42282661], [</span>
<span class="gd">-    0.40874177, 0.16647061, 0.42178429], [0.40504765, 0.16574261, </span>
<span class="gd">-    0.42072062], [0.401357, 0.16501079, 0.41963528], [0.397669, 0.16427607,</span>
<span class="gd">-    0.418528], [0.39398585, 0.16353554, 0.41740053], [0.39030735, </span>
<span class="gd">-    0.16278924, 0.41625344], [0.3866314, 0.16203977, 0.41508517], [</span>
<span class="gd">-    0.38295904, 0.16128519, 0.41389849], [0.37928736, 0.16052483, </span>
<span class="gd">-    0.41270599], [0.37562649, 0.15974704, 0.41151182], [0.37197803, </span>
<span class="gd">-    0.15895049, 0.41031532], [0.36833779, 0.15813871, 0.40911916], [</span>
<span class="gd">-    0.36470944, 0.15730861, 0.40792149], [0.36109117, 0.15646169, </span>
<span class="gd">-    0.40672362], [0.35748213, 0.15559861, 0.40552633], [0.353885, </span>
<span class="gd">-    0.15471714, 0.40432831], [0.35029682, 0.15381967, 0.4031316], [</span>
<span class="gd">-    0.34671861, 0.1529053, 0.40193587], [0.34315191, 0.15197275, 0.40074049</span>
<span class="gd">-    ], [0.33959331, 0.15102466, 0.3995478], [0.33604378, 0.15006017, </span>
<span class="gd">-    0.39835754], [0.33250529, 0.14907766, 0.39716879], [0.32897621, </span>
<span class="gd">-    0.14807831, 0.39598285], [0.3254559, 0.14706248, 0.39480044], [</span>
<span class="gd">-    0.32194567, 0.14602909, 0.39362106], [0.31844477, 0.14497857, </span>
<span class="gd">-    0.39244549], [0.31494974, 0.14391333, 0.39127626], [0.31146605, </span>
<span class="gd">-    0.14282918, 0.39011024], [0.30798857, 0.1417297, 0.38895105], [</span>
<span class="gd">-    0.30451661, 0.14061515, 0.38779953], [0.30105136, 0.13948445, </span>
<span class="gd">-    0.38665531], [0.2975886, 0.1383403, 0.38552159], [0.29408557, </span>
<span class="gd">-    0.13721193, 0.38442775]]</span>
<span class="gd">-_crest_lut = [[0.6468274, 0.80289262, 0.56592265], [0.64233318, 0.80081141,</span>
<span class="gd">-    0.56639461], [0.63791969, 0.7987162, 0.56674976], [0.6335316, </span>
<span class="gd">-    0.79661833, 0.56706128], [0.62915226, 0.7945212, 0.56735066], [</span>
<span class="gd">-    0.62477862, 0.79242543, 0.56762143], [0.62042003, 0.79032918, </span>
<span class="gd">-    0.56786129], [0.61606327, 0.78823508, 0.56808666], [0.61171322, </span>
<span class="gd">-    0.78614216, 0.56829092], [0.60736933, 0.78405055, 0.56847436], [</span>
<span class="gd">-    0.60302658, 0.78196121, 0.56864272], [0.59868708, 0.77987374, </span>
<span class="gd">-    0.56879289], [0.59435366, 0.77778758, 0.56892099], [0.59001953, </span>
<span class="gd">-    0.77570403, 0.56903477], [0.58568753, 0.77362254, 0.56913028], [</span>
<span class="gd">-    0.58135593, 0.77154342, 0.56920908], [0.57702623, 0.76946638, </span>
<span class="gd">-    0.56926895], [0.57269165, 0.76739266, 0.5693172], [0.56835934, </span>
<span class="gd">-    0.76532092, 0.56934507], [0.56402533, 0.76325185, 0.56935664], [</span>
<span class="gd">-    0.55968429, 0.76118643, 0.56935732], [0.55534159, 0.75912361, </span>
<span class="gd">-    0.56934052], [0.55099572, 0.75706366, 0.56930743], [0.54664626, </span>
<span class="gd">-    0.75500662, 0.56925799], [0.54228969, 0.75295306, 0.56919546], [</span>
<span class="gd">-    0.53792417, 0.75090328, 0.56912118], [0.53355172, 0.74885687, 0.5690324</span>
<span class="gd">-    ], [0.52917169, 0.74681387, 0.56892926], [0.52478243, 0.74477453, </span>
<span class="gd">-    0.56881287], [0.52038338, 0.74273888, 0.56868323], [0.5159739, </span>
<span class="gd">-    0.74070697, 0.56854039], [0.51155269, 0.73867895, 0.56838507], [</span>
<span class="gd">-    0.50711872, 0.73665492, 0.56821764], [0.50267118, 0.73463494, </span>
<span class="gd">-    0.56803826], [0.49822926, 0.73261388, 0.56785146], [0.49381422, </span>
<span class="gd">-    0.73058524, 0.56767484], [0.48942421, 0.72854938, 0.56751036], [</span>
<span class="gd">-    0.48505993, 0.72650623, 0.56735752], [0.48072207, 0.72445575, </span>
<span class="gd">-    0.56721583], [0.4764113, 0.72239788, 0.56708475], [0.47212827, </span>
<span class="gd">-    0.72033258, 0.56696376], [0.46787361, 0.71825983, 0.56685231], [</span>
<span class="gd">-    0.46364792, 0.71617961, 0.56674986], [0.45945271, 0.71409167, </span>
<span class="gd">-    0.56665625], [0.45528878, 0.71199595, 0.56657103], [0.45115557, </span>
<span class="gd">-    0.70989276, 0.5664931], [0.44705356, 0.70778212, 0.56642189], [</span>
<span class="gd">-    0.44298321, 0.70566406, 0.56635683], [0.43894492, 0.70353863, </span>
<span class="gd">-    0.56629734], [0.43493911, 0.70140588, 0.56624286], [0.43096612, </span>
<span class="gd">-    0.69926587, 0.5661928], [0.42702625, 0.69711868, 0.56614659], [</span>
<span class="gd">-    0.42311977, 0.69496438, 0.56610368], [0.41924689, 0.69280308, </span>
<span class="gd">-    0.56606355], [0.41540778, 0.69063486, 0.56602564], [0.41160259, </span>
<span class="gd">-    0.68845984, 0.56598944], [0.40783143, 0.68627814, 0.56595436], [</span>
<span class="gd">-    0.40409434, 0.68408988, 0.56591994], [0.40039134, 0.68189518, </span>
<span class="gd">-    0.56588564], [0.39672238, 0.6796942, 0.56585103], [0.39308781, </span>
<span class="gd">-    0.67748696, 0.56581581], [0.38949137, 0.67527276, 0.56578084], [</span>
<span class="gd">-    0.38592889, 0.67305266, 0.56574422], [0.38240013, 0.67082685, </span>
<span class="gd">-    0.56570561], [0.37890483, 0.66859548, 0.56566462], [0.37544276, </span>
<span class="gd">-    0.66635871, 0.56562081], [0.37201365, 0.66411673, 0.56557372], [</span>
<span class="gd">-    0.36861709, 0.6618697, 0.5655231], [0.36525264, 0.65961782, 0.56546873],</span>
<span class="gd">-    [0.36191986, 0.65736125, 0.56541032], [0.35861935, 0.65509998, </span>
<span class="gd">-    0.56534768], [0.35535621, 0.65283302, 0.56528211], [0.35212361, </span>
<span class="gd">-    0.65056188, 0.56521171], [0.34892097, 0.64828676, 0.56513633], [</span>
<span class="gd">-    0.34574785, 0.64600783, 0.56505539], [0.34260357, 0.64372528, 0.5649689</span>
<span class="gd">-    ], [0.33948744, 0.64143931, 0.56487679], [0.33639887, 0.6391501, </span>
<span class="gd">-    0.56477869], [0.33334501, 0.63685626, 0.56467661], [0.33031952, </span>
<span class="gd">-    0.63455911, 0.564569], [0.3273199, 0.63225924, 0.56445488], [0.32434526,</span>
<span class="gd">-    0.62995682, 0.56433457], [0.32139487, 0.62765201, 0.56420795], [</span>
<span class="gd">-    0.31846807, 0.62534504, 0.56407446], [0.3155731, 0.62303426, 0.56393695</span>
<span class="gd">-    ], [0.31270304, 0.62072111, 0.56379321], [0.30985436, 0.61840624, </span>
<span class="gd">-    0.56364307], [0.30702635, 0.61608984, 0.56348606], [0.30421803, </span>
<span class="gd">-    0.61377205, 0.56332267], [0.30143611, 0.61145167, 0.56315419], [</span>
<span class="gd">-    0.29867863, 0.60912907, 0.56298054], [0.29593872, 0.60680554, </span>
<span class="gd">-    0.56280022], [0.29321538, 0.60448121, 0.56261376], [0.2905079, </span>
<span class="gd">-    0.60215628, 0.56242036], [0.28782827, 0.5998285, 0.56222366], [</span>
<span class="gd">-    0.28516521, 0.59749996, 0.56202093], [0.28251558, 0.59517119, </span>
<span class="gd">-    0.56181204], [0.27987847, 0.59284232, 0.56159709], [0.27726216, </span>
<span class="gd">-    0.59051189, 0.56137785], [0.27466434, 0.58818027, 0.56115433], [</span>
<span class="gd">-    0.2720767, 0.58584893, 0.56092486], [0.26949829, 0.58351797, 0.56068983</span>
<span class="gd">-    ], [0.26693801, 0.58118582, 0.56045121], [0.26439366, 0.57885288, </span>
<span class="gd">-    0.56020858], [0.26185616, 0.57652063, 0.55996077], [0.25932459, </span>
<span class="gd">-    0.57418919, 0.55970795], [0.25681303, 0.57185614, 0.55945297], [</span>
<span class="gd">-    0.25431024, 0.56952337, 0.55919385], [0.25180492, 0.56719255, 0.5589305</span>
<span class="gd">-    ], [0.24929311, 0.56486397, 0.5586654], [0.24678356, 0.56253666, </span>
<span class="gd">-    0.55839491], [0.24426587, 0.56021153, 0.55812473], [0.24174022, </span>
<span class="gd">-    0.55788852, 0.55785448], [0.23921167, 0.55556705, 0.55758211], [</span>
<span class="gd">-    0.23668315, 0.55324675, 0.55730676], [0.23414742, 0.55092825, </span>
<span class="gd">-    0.55703167], [0.23160473, 0.54861143, 0.5567573], [0.22905996, </span>
<span class="gd">-    0.54629572, 0.55648168], [0.22651648, 0.54398082, 0.5562029], [</span>
<span class="gd">-    0.22396709, 0.54166721, 0.55592542], [0.22141221, 0.53935481, </span>
<span class="gd">-    0.55564885], [0.21885269, 0.53704347, 0.55537294], [0.21629986, </span>
<span class="gd">-    0.53473208, 0.55509319], [0.21374297, 0.53242154, 0.5548144], [</span>
<span class="gd">-    0.21118255, 0.53011166, 0.55453708], [0.2086192, 0.52780237, 0.55426067</span>
<span class="gd">-    ], [0.20605624, 0.52549322, 0.55398479], [0.20350004, 0.5231837, </span>
<span class="gd">-    0.55370601], [0.20094292, 0.52087429, 0.55342884], [0.19838567, </span>
<span class="gd">-    0.51856489, 0.55315283], [0.19582911, 0.51625531, 0.55287818], [</span>
<span class="gd">-    0.19327413, 0.51394542, 0.55260469], [0.19072933, 0.51163448, 0.5523289</span>
<span class="gd">-    ], [0.18819045, 0.50932268, 0.55205372], [0.18565609, 0.50701014, </span>
<span class="gd">-    0.55177937], [0.18312739, 0.50469666, 0.55150597], [0.18060561, </span>
<span class="gd">-    0.50238204, 0.55123374], [0.178092, 0.50006616, 0.55096224], [</span>
<span class="gd">-    0.17558808, 0.49774882, 0.55069118], [0.17310341, 0.49542924, 0.5504176</span>
<span class="gd">-    ], [0.17063111, 0.49310789, 0.55014445], [0.1681728, 0.49078458, </span>
<span class="gd">-    0.54987159], [0.1657302, 0.48845913, 0.54959882], [0.16330517, </span>
<span class="gd">-    0.48613135, 0.54932605], [0.16089963, 0.48380104, 0.54905306], [</span>
<span class="gd">-    0.15851561, 0.48146803, 0.54877953], [0.15615526, 0.47913212, </span>
<span class="gd">-    0.54850526], [0.15382083, 0.47679313, 0.54822991], [0.15151471, </span>
<span class="gd">-    0.47445087, 0.54795318], [0.14924112, 0.47210502, 0.54767411], [</span>
<span class="gd">-    0.1470032, 0.46975537, 0.54739226], [0.14480101, 0.46740187, 0.54710832</span>
<span class="gd">-    ], [0.14263736, 0.46504434, 0.54682188], [0.14051521, 0.46268258, </span>
<span class="gd">-    0.54653253], [0.13843761, 0.46031639, 0.54623985], [0.13640774, </span>
<span class="gd">-    0.45794558, 0.5459434], [0.13442887, 0.45556994, 0.54564272], [</span>
<span class="gd">-    0.1325044, 0.45318928, 0.54533736], [0.13063777, 0.4508034, 0.54502674],</span>
<span class="gd">-    [0.12883252, 0.44841211, 0.5447104], [0.12709242, 0.44601517, </span>
<span class="gd">-    0.54438795], [0.1254209, 0.44361244, 0.54405855], [0.12382162, </span>
<span class="gd">-    0.44120373, 0.54372156], [0.12229818, 0.43878887, 0.54337634], [</span>
<span class="gd">-    0.12085453, 0.4363676, 0.54302253], [0.11949938, 0.43393955, 0.54265715</span>
<span class="gd">-    ], [0.11823166, 0.43150478, 0.54228104], [0.11705496, 0.42906306, </span>
<span class="gd">-    0.54189388], [0.115972, 0.42661431, 0.54149449], [0.11498598, </span>
<span class="gd">-    0.42415835, 0.54108222], [0.11409965, 0.42169502, 0.54065622], [</span>
<span class="gd">-    0.11331533, 0.41922424, 0.5402155], [0.11263542, 0.41674582, 0.53975931</span>
<span class="gd">-    ], [0.1120615, 0.4142597, 0.53928656], [0.11159738, 0.41176567, </span>
<span class="gd">-    0.53879549], [0.11125248, 0.40926325, 0.53828203], [0.11101698, </span>
<span class="gd">-    0.40675289, 0.53774864], [0.11089152, 0.40423445, 0.53719455], [</span>
<span class="gd">-    0.11085121, 0.4017095, 0.53662425], [0.11087217, 0.39917938, 0.53604354</span>
<span class="gd">-    ], [0.11095515, 0.39664394, 0.53545166], [0.11110676, 0.39410282, </span>
<span class="gd">-    0.53484509], [0.11131735, 0.39155635, 0.53422678], [0.11158595, </span>
<span class="gd">-    0.38900446, 0.53359634], [0.11191139, 0.38644711, 0.5329534], [</span>
<span class="gd">-    0.11229224, 0.38388426, 0.53229748], [0.11273683, 0.38131546, </span>
<span class="gd">-    0.53162393], [0.11323438, 0.37874109, 0.53093619], [0.11378271, </span>
<span class="gd">-    0.37616112, 0.53023413], [0.11437992, 0.37357557, 0.52951727], [</span>
<span class="gd">-    0.11502681, 0.37098429, 0.52878396], [0.11572661, 0.36838709, </span>
<span class="gd">-    0.52803124], [0.11646936, 0.36578429, 0.52726234], [0.11725299, </span>
<span class="gd">-    0.3631759, 0.52647685], [0.1180755, 0.36056193, 0.52567436], [0.1189438,</span>
<span class="gd">-    0.35794203, 0.5248497], [0.11984752, 0.35531657, 0.52400649], [</span>
<span class="gd">-    0.1207833, 0.35268564, 0.52314492], [0.12174895, 0.35004927, 0.52226461</span>
<span class="gd">-    ], [0.12274959, 0.34740723, 0.52136104], [0.12377809, 0.34475975, </span>
<span class="gd">-    0.52043639], [0.12482961, 0.34210702, 0.51949179], [0.125902, </span>
<span class="gd">-    0.33944908, 0.51852688], [0.12699998, 0.33678574, 0.51753708], [</span>
<span class="gd">-    0.12811691, 0.33411727, 0.51652464], [0.12924811, 0.33144384, </span>
<span class="gd">-    0.51549084], [0.13039157, 0.32876552, 0.51443538], [0.13155228, </span>
<span class="gd">-    0.32608217, 0.51335321], [0.13272282, 0.32339407, 0.51224759], [</span>
<span class="gd">-    0.13389954, 0.32070138, 0.51111946], [0.13508064, 0.31800419, </span>
<span class="gd">-    0.50996862], [0.13627149, 0.31530238, 0.50878942], [0.13746376, </span>
<span class="gd">-    0.31259627, 0.50758645], [0.13865499, 0.30988598, 0.50636017], [</span>
<span class="gd">-    0.13984364, 0.30717161, 0.50511042], [0.14103515, 0.30445309, </span>
<span class="gd">-    0.50383119], [0.14222093, 0.30173071, 0.50252813], [0.14339946, </span>
<span class="gd">-    0.2990046, 0.50120127], [0.14456941, 0.29627483, 0.49985054], [</span>
<span class="gd">-    0.14573579, 0.29354139, 0.49847009], [0.14689091, 0.29080452, </span>
<span class="gd">-    0.49706566], [0.1480336, 0.28806432, 0.49563732], [0.1491628, </span>
<span class="gd">-    0.28532086, 0.49418508], [0.15028228, 0.28257418, 0.49270402], [</span>
<span class="gd">-    0.15138673, 0.27982444, 0.49119848], [0.15247457, 0.27707172, </span>
<span class="gd">-    0.48966925], [0.15354487, 0.2743161, 0.48811641], [0.15459955, </span>
<span class="gd">-    0.27155765, 0.4865371], [0.15563716, 0.26879642, 0.4849321], [0.1566572,</span>
<span class="gd">-    0.26603191, 0.48330429], [0.15765823, 0.26326032, 0.48167456], [</span>
<span class="gd">-    0.15862147, 0.26048295, 0.48005785], [0.15954301, 0.25770084, </span>
<span class="gd">-    0.47845341], [0.16043267, 0.25491144, 0.4768626], [0.16129262, </span>
<span class="gd">-    0.25211406, 0.4752857], [0.1621119, 0.24931169, 0.47372076], [</span>
<span class="gd">-    0.16290577, 0.24649998, 0.47217025], [0.16366819, 0.24368054, </span>
<span class="gd">-    0.47063302], [0.1644021, 0.24085237, 0.46910949], [0.16510882, </span>
<span class="gd">-    0.2380149, 0.46759982], [0.16579015, 0.23516739, 0.46610429], [</span>
<span class="gd">-    0.1664433, 0.2323105, 0.46462219], [0.16707586, 0.22944155, 0.46315508],</span>
<span class="gd">-    [0.16768475, 0.22656122, 0.46170223], [0.16826815, 0.22366984, </span>
<span class="gd">-    0.46026308], [0.16883174, 0.22076514, 0.45883891], [0.16937589, </span>
<span class="gd">-    0.21784655, 0.45742976], [0.16990129, 0.21491339, 0.45603578], [</span>
<span class="gd">-    0.1704074, 0.21196535, 0.45465677], [0.17089473, 0.20900176, 0.4532928],</span>
<span class="gd">-    [0.17136819, 0.20602012, 0.45194524], [0.17182683, 0.20302012, </span>
<span class="gd">-    0.45061386], [0.17227059, 0.20000106, 0.44929865], [0.17270583, </span>
<span class="gd">-    0.19695949, 0.44800165], [0.17313804, 0.19389201, 0.44672488], [</span>
<span class="gd">-    0.17363177, 0.19076859, 0.44549087]]</span>
<span class="gd">-_lut_dict = dict(rocket=_rocket_lut, mako=_mako_lut, icefire=_icefire_lut,</span>
<span class="gd">-    vlag=_vlag_lut, flare=_flare_lut, crest=_crest_lut)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_rocket_lut = [</span>
<span class="gi">+    [ 0.01060815, 0.01808215, 0.10018654],</span>
<span class="gi">+    [ 0.01428972, 0.02048237, 0.10374486],</span>
<span class="gi">+    [ 0.01831941, 0.0229766 , 0.10738511],</span>
<span class="gi">+    [ 0.02275049, 0.02554464, 0.11108639],</span>
<span class="gi">+    [ 0.02759119, 0.02818316, 0.11483751],</span>
<span class="gi">+    [ 0.03285175, 0.03088792, 0.11863035],</span>
<span class="gi">+    [ 0.03853466, 0.03365771, 0.12245873],</span>
<span class="gi">+    [ 0.04447016, 0.03648425, 0.12631831],</span>
<span class="gi">+    [ 0.05032105, 0.03936808, 0.13020508],</span>
<span class="gi">+    [ 0.05611171, 0.04224835, 0.13411624],</span>
<span class="gi">+    [ 0.0618531 , 0.04504866, 0.13804929],</span>
<span class="gi">+    [ 0.06755457, 0.04778179, 0.14200206],</span>
<span class="gi">+    [ 0.0732236 , 0.05045047, 0.14597263],</span>
<span class="gi">+    [ 0.0788708 , 0.05305461, 0.14995981],</span>
<span class="gi">+    [ 0.08450105, 0.05559631, 0.15396203],</span>
<span class="gi">+    [ 0.09011319, 0.05808059, 0.15797687],</span>
<span class="gi">+    [ 0.09572396, 0.06050127, 0.16200507],</span>
<span class="gi">+    [ 0.10132312, 0.06286782, 0.16604287],</span>
<span class="gi">+    [ 0.10692823, 0.06517224, 0.17009175],</span>
<span class="gi">+    [ 0.1125315 , 0.06742194, 0.17414848],</span>
<span class="gi">+    [ 0.11813947, 0.06961499, 0.17821272],</span>
<span class="gi">+    [ 0.12375803, 0.07174938, 0.18228425],</span>
<span class="gi">+    [ 0.12938228, 0.07383015, 0.18636053],</span>
<span class="gi">+    [ 0.13501631, 0.07585609, 0.19044109],</span>
<span class="gi">+    [ 0.14066867, 0.0778224 , 0.19452676],</span>
<span class="gi">+    [ 0.14633406, 0.07973393, 0.1986151 ],</span>
<span class="gi">+    [ 0.15201338, 0.08159108, 0.20270523],</span>
<span class="gi">+    [ 0.15770877, 0.08339312, 0.20679668],</span>
<span class="gi">+    [ 0.16342174, 0.0851396 , 0.21088893],</span>
<span class="gi">+    [ 0.16915387, 0.08682996, 0.21498104],</span>
<span class="gi">+    [ 0.17489524, 0.08848235, 0.2190294 ],</span>
<span class="gi">+    [ 0.18065495, 0.09009031, 0.22303512],</span>
<span class="gi">+    [ 0.18643324, 0.09165431, 0.22699705],</span>
<span class="gi">+    [ 0.19223028, 0.09317479, 0.23091409],</span>
<span class="gi">+    [ 0.19804623, 0.09465217, 0.23478512],</span>
<span class="gi">+    [ 0.20388117, 0.09608689, 0.23860907],</span>
<span class="gi">+    [ 0.20973515, 0.09747934, 0.24238489],</span>
<span class="gi">+    [ 0.21560818, 0.09882993, 0.24611154],</span>
<span class="gi">+    [ 0.22150014, 0.10013944, 0.2497868 ],</span>
<span class="gi">+    [ 0.22741085, 0.10140876, 0.25340813],</span>
<span class="gi">+    [ 0.23334047, 0.10263737, 0.25697736],</span>
<span class="gi">+    [ 0.23928891, 0.10382562, 0.2604936 ],</span>
<span class="gi">+    [ 0.24525608, 0.10497384, 0.26395596],</span>
<span class="gi">+    [ 0.25124182, 0.10608236, 0.26736359],</span>
<span class="gi">+    [ 0.25724602, 0.10715148, 0.27071569],</span>
<span class="gi">+    [ 0.26326851, 0.1081815 , 0.27401148],</span>
<span class="gi">+    [ 0.26930915, 0.1091727 , 0.2772502 ],</span>
<span class="gi">+    [ 0.27536766, 0.11012568, 0.28043021],</span>
<span class="gi">+    [ 0.28144375, 0.11104133, 0.2835489 ],</span>
<span class="gi">+    [ 0.2875374 , 0.11191896, 0.28660853],</span>
<span class="gi">+    [ 0.29364846, 0.11275876, 0.2896085 ],</span>
<span class="gi">+    [ 0.29977678, 0.11356089, 0.29254823],</span>
<span class="gi">+    [ 0.30592213, 0.11432553, 0.29542718],</span>
<span class="gi">+    [ 0.31208435, 0.11505284, 0.29824485],</span>
<span class="gi">+    [ 0.31826327, 0.1157429 , 0.30100076],</span>
<span class="gi">+    [ 0.32445869, 0.11639585, 0.30369448],</span>
<span class="gi">+    [ 0.33067031, 0.11701189, 0.30632563],</span>
<span class="gi">+    [ 0.33689808, 0.11759095, 0.3088938 ],</span>
<span class="gi">+    [ 0.34314168, 0.11813362, 0.31139721],</span>
<span class="gi">+    [ 0.34940101, 0.11863987, 0.3138355 ],</span>
<span class="gi">+    [ 0.355676  , 0.11910909, 0.31620996],</span>
<span class="gi">+    [ 0.36196644, 0.1195413 , 0.31852037],</span>
<span class="gi">+    [ 0.36827206, 0.11993653, 0.32076656],</span>
<span class="gi">+    [ 0.37459292, 0.12029443, 0.32294825],</span>
<span class="gi">+    [ 0.38092887, 0.12061482, 0.32506528],</span>
<span class="gi">+    [ 0.38727975, 0.12089756, 0.3271175 ],</span>
<span class="gi">+    [ 0.39364518, 0.12114272, 0.32910494],</span>
<span class="gi">+    [ 0.40002537, 0.12134964, 0.33102734],</span>
<span class="gi">+    [ 0.40642019, 0.12151801, 0.33288464],</span>
<span class="gi">+    [ 0.41282936, 0.12164769, 0.33467689],</span>
<span class="gi">+    [ 0.41925278, 0.12173833, 0.33640407],</span>
<span class="gi">+    [ 0.42569057, 0.12178916, 0.33806605],</span>
<span class="gi">+    [ 0.43214263, 0.12179973, 0.33966284],</span>
<span class="gi">+    [ 0.43860848, 0.12177004, 0.34119475],</span>
<span class="gi">+    [ 0.44508855, 0.12169883, 0.34266151],</span>
<span class="gi">+    [ 0.45158266, 0.12158557, 0.34406324],</span>
<span class="gi">+    [ 0.45809049, 0.12142996, 0.34540024],</span>
<span class="gi">+    [ 0.46461238, 0.12123063, 0.34667231],</span>
<span class="gi">+    [ 0.47114798, 0.12098721, 0.34787978],</span>
<span class="gi">+    [ 0.47769736, 0.12069864, 0.34902273],</span>
<span class="gi">+    [ 0.48426077, 0.12036349, 0.35010104],</span>
<span class="gi">+    [ 0.49083761, 0.11998161, 0.35111537],</span>
<span class="gi">+    [ 0.49742847, 0.11955087, 0.35206533],</span>
<span class="gi">+    [ 0.50403286, 0.11907081, 0.35295152],</span>
<span class="gi">+    [ 0.51065109, 0.11853959, 0.35377385],</span>
<span class="gi">+    [ 0.51728314, 0.1179558 , 0.35453252],</span>
<span class="gi">+    [ 0.52392883, 0.11731817, 0.35522789],</span>
<span class="gi">+    [ 0.53058853, 0.11662445, 0.35585982],</span>
<span class="gi">+    [ 0.53726173, 0.11587369, 0.35642903],</span>
<span class="gi">+    [ 0.54394898, 0.11506307, 0.35693521],</span>
<span class="gi">+    [ 0.5506426 , 0.11420757, 0.35737863],</span>
<span class="gi">+    [ 0.55734473, 0.11330456, 0.35775059],</span>
<span class="gi">+    [ 0.56405586, 0.11235265, 0.35804813],</span>
<span class="gi">+    [ 0.57077365, 0.11135597, 0.35827146],</span>
<span class="gi">+    [ 0.5774991 , 0.11031233, 0.35841679],</span>
<span class="gi">+    [ 0.58422945, 0.10922707, 0.35848469],</span>
<span class="gi">+    [ 0.59096382, 0.10810205, 0.35847347],</span>
<span class="gi">+    [ 0.59770215, 0.10693774, 0.35838029],</span>
<span class="gi">+    [ 0.60444226, 0.10573912, 0.35820487],</span>
<span class="gi">+    [ 0.61118304, 0.10450943, 0.35794557],</span>
<span class="gi">+    [ 0.61792306, 0.10325288, 0.35760108],</span>
<span class="gi">+    [ 0.62466162, 0.10197244, 0.35716891],</span>
<span class="gi">+    [ 0.63139686, 0.10067417, 0.35664819],</span>
<span class="gi">+    [ 0.63812122, 0.09938212, 0.35603757],</span>
<span class="gi">+    [ 0.64483795, 0.0980891 , 0.35533555],</span>
<span class="gi">+    [ 0.65154562, 0.09680192, 0.35454107],</span>
<span class="gi">+    [ 0.65824241, 0.09552918, 0.3536529 ],</span>
<span class="gi">+    [ 0.66492652, 0.09428017, 0.3526697 ],</span>
<span class="gi">+    [ 0.67159578, 0.09306598, 0.35159077],</span>
<span class="gi">+    [ 0.67824099, 0.09192342, 0.3504148 ],</span>
<span class="gi">+    [ 0.684863  , 0.09085633, 0.34914061],</span>
<span class="gi">+    [ 0.69146268, 0.0898675 , 0.34776864],</span>
<span class="gi">+    [ 0.69803757, 0.08897226, 0.3462986 ],</span>
<span class="gi">+    [ 0.70457834, 0.0882129 , 0.34473046],</span>
<span class="gi">+    [ 0.71108138, 0.08761223, 0.3430635 ],</span>
<span class="gi">+    [ 0.7175507 , 0.08716212, 0.34129974],</span>
<span class="gi">+    [ 0.72398193, 0.08688725, 0.33943958],</span>
<span class="gi">+    [ 0.73035829, 0.0868623 , 0.33748452],</span>
<span class="gi">+    [ 0.73669146, 0.08704683, 0.33543669],</span>
<span class="gi">+    [ 0.74297501, 0.08747196, 0.33329799],</span>
<span class="gi">+    [ 0.74919318, 0.08820542, 0.33107204],</span>
<span class="gi">+    [ 0.75535825, 0.08919792, 0.32876184],</span>
<span class="gi">+    [ 0.76145589, 0.09050716, 0.32637117],</span>
<span class="gi">+    [ 0.76748424, 0.09213602, 0.32390525],</span>
<span class="gi">+    [ 0.77344838, 0.09405684, 0.32136808],</span>
<span class="gi">+    [ 0.77932641, 0.09634794, 0.31876642],</span>
<span class="gi">+    [ 0.78513609, 0.09892473, 0.31610488],</span>
<span class="gi">+    [ 0.79085854, 0.10184672, 0.313391  ],</span>
<span class="gi">+    [ 0.7965014 , 0.10506637, 0.31063031],</span>
<span class="gi">+    [ 0.80205987, 0.10858333, 0.30783   ],</span>
<span class="gi">+    [ 0.80752799, 0.11239964, 0.30499738],</span>
<span class="gi">+    [ 0.81291606, 0.11645784, 0.30213802],</span>
<span class="gi">+    [ 0.81820481, 0.12080606, 0.29926105],</span>
<span class="gi">+    [ 0.82341472, 0.12535343, 0.2963705 ],</span>
<span class="gi">+    [ 0.82852822, 0.13014118, 0.29347474],</span>
<span class="gi">+    [ 0.83355779, 0.13511035, 0.29057852],</span>
<span class="gi">+    [ 0.83850183, 0.14025098, 0.2876878 ],</span>
<span class="gi">+    [ 0.84335441, 0.14556683, 0.28480819],</span>
<span class="gi">+    [ 0.84813096, 0.15099892, 0.281943  ],</span>
<span class="gi">+    [ 0.85281737, 0.15657772, 0.27909826],</span>
<span class="gi">+    [ 0.85742602, 0.1622583 , 0.27627462],</span>
<span class="gi">+    [ 0.86196552, 0.16801239, 0.27346473],</span>
<span class="gi">+    [ 0.86641628, 0.17387796, 0.27070818],</span>
<span class="gi">+    [ 0.87079129, 0.17982114, 0.26797378],</span>
<span class="gi">+    [ 0.87507281, 0.18587368, 0.26529697],</span>
<span class="gi">+    [ 0.87925878, 0.19203259, 0.26268136],</span>
<span class="gi">+    [ 0.8833417 , 0.19830556, 0.26014181],</span>
<span class="gi">+    [ 0.88731387, 0.20469941, 0.25769539],</span>
<span class="gi">+    [ 0.89116859, 0.21121788, 0.2553592 ],</span>
<span class="gi">+    [ 0.89490337, 0.21785614, 0.25314362],</span>
<span class="gi">+    [ 0.8985026 , 0.22463251, 0.25108745],</span>
<span class="gi">+    [ 0.90197527, 0.23152063, 0.24918223],</span>
<span class="gi">+    [ 0.90530097, 0.23854541, 0.24748098],</span>
<span class="gi">+    [ 0.90848638, 0.24568473, 0.24598324],</span>
<span class="gi">+    [ 0.911533  , 0.25292623, 0.24470258],</span>
<span class="gi">+    [ 0.9144225 , 0.26028902, 0.24369359],</span>
<span class="gi">+    [ 0.91717106, 0.26773821, 0.24294137],</span>
<span class="gi">+    [ 0.91978131, 0.27526191, 0.24245973],</span>
<span class="gi">+    [ 0.92223947, 0.28287251, 0.24229568],</span>
<span class="gi">+    [ 0.92456587, 0.29053388, 0.24242622],</span>
<span class="gi">+    [ 0.92676657, 0.29823282, 0.24285536],</span>
<span class="gi">+    [ 0.92882964, 0.30598085, 0.24362274],</span>
<span class="gi">+    [ 0.93078135, 0.31373977, 0.24468803],</span>
<span class="gi">+    [ 0.93262051, 0.3215093 , 0.24606461],</span>
<span class="gi">+    [ 0.93435067, 0.32928362, 0.24775328],</span>
<span class="gi">+    [ 0.93599076, 0.33703942, 0.24972157],</span>
<span class="gi">+    [ 0.93752831, 0.34479177, 0.25199928],</span>
<span class="gi">+    [ 0.93899289, 0.35250734, 0.25452808],</span>
<span class="gi">+    [ 0.94036561, 0.36020899, 0.25734661],</span>
<span class="gi">+    [ 0.94167588, 0.36786594, 0.2603949 ],</span>
<span class="gi">+    [ 0.94291042, 0.37549479, 0.26369821],</span>
<span class="gi">+    [ 0.94408513, 0.3830811 , 0.26722004],</span>
<span class="gi">+    [ 0.94520419, 0.39062329, 0.27094924],</span>
<span class="gi">+    [ 0.94625977, 0.39813168, 0.27489742],</span>
<span class="gi">+    [ 0.94727016, 0.4055909 , 0.27902322],</span>
<span class="gi">+    [ 0.94823505, 0.41300424, 0.28332283],</span>
<span class="gi">+    [ 0.94914549, 0.42038251, 0.28780969],</span>
<span class="gi">+    [ 0.95001704, 0.42771398, 0.29244728],</span>
<span class="gi">+    [ 0.95085121, 0.43500005, 0.29722817],</span>
<span class="gi">+    [ 0.95165009, 0.44224144, 0.30214494],</span>
<span class="gi">+    [ 0.9524044 , 0.44944853, 0.3072105 ],</span>
<span class="gi">+    [ 0.95312556, 0.45661389, 0.31239776],</span>
<span class="gi">+    [ 0.95381595, 0.46373781, 0.31769923],</span>
<span class="gi">+    [ 0.95447591, 0.47082238, 0.32310953],</span>
<span class="gi">+    [ 0.95510255, 0.47787236, 0.32862553],</span>
<span class="gi">+    [ 0.95569679, 0.48489115, 0.33421404],</span>
<span class="gi">+    [ 0.95626788, 0.49187351, 0.33985601],</span>
<span class="gi">+    [ 0.95681685, 0.49882008, 0.34555431],</span>
<span class="gi">+    [ 0.9573439 , 0.50573243, 0.35130912],</span>
<span class="gi">+    [ 0.95784842, 0.51261283, 0.35711942],</span>
<span class="gi">+    [ 0.95833051, 0.51946267, 0.36298589],</span>
<span class="gi">+    [ 0.95879054, 0.52628305, 0.36890904],</span>
<span class="gi">+    [ 0.95922872, 0.53307513, 0.3748895 ],</span>
<span class="gi">+    [ 0.95964538, 0.53983991, 0.38092784],</span>
<span class="gi">+    [ 0.96004345, 0.54657593, 0.3870292 ],</span>
<span class="gi">+    [ 0.96042097, 0.55328624, 0.39319057],</span>
<span class="gi">+    [ 0.96077819, 0.55997184, 0.39941173],</span>
<span class="gi">+    [ 0.9611152 , 0.5666337 , 0.40569343],</span>
<span class="gi">+    [ 0.96143273, 0.57327231, 0.41203603],</span>
<span class="gi">+    [ 0.96173392, 0.57988594, 0.41844491],</span>
<span class="gi">+    [ 0.96201757, 0.58647675, 0.42491751],</span>
<span class="gi">+    [ 0.96228344, 0.59304598, 0.43145271],</span>
<span class="gi">+    [ 0.96253168, 0.5995944 , 0.43805131],</span>
<span class="gi">+    [ 0.96276513, 0.60612062, 0.44471698],</span>
<span class="gi">+    [ 0.96298491, 0.6126247 , 0.45145074],</span>
<span class="gi">+    [ 0.96318967, 0.61910879, 0.45824902],</span>
<span class="gi">+    [ 0.96337949, 0.6255736 , 0.46511271],</span>
<span class="gi">+    [ 0.96355923, 0.63201624, 0.47204746],</span>
<span class="gi">+    [ 0.96372785, 0.63843852, 0.47905028],</span>
<span class="gi">+    [ 0.96388426, 0.64484214, 0.4861196 ],</span>
<span class="gi">+    [ 0.96403203, 0.65122535, 0.4932578 ],</span>
<span class="gi">+    [ 0.96417332, 0.65758729, 0.50046894],</span>
<span class="gi">+    [ 0.9643063 , 0.66393045, 0.5077467 ],</span>
<span class="gi">+    [ 0.96443322, 0.67025402, 0.51509334],</span>
<span class="gi">+    [ 0.96455845, 0.67655564, 0.52251447],</span>
<span class="gi">+    [ 0.96467922, 0.68283846, 0.53000231],</span>
<span class="gi">+    [ 0.96479861, 0.68910113, 0.53756026],</span>
<span class="gi">+    [ 0.96492035, 0.69534192, 0.5451917 ],</span>
<span class="gi">+    [ 0.96504223, 0.7015636 , 0.5528892 ],</span>
<span class="gi">+    [ 0.96516917, 0.70776351, 0.5606593 ],</span>
<span class="gi">+    [ 0.96530224, 0.71394212, 0.56849894],</span>
<span class="gi">+    [ 0.96544032, 0.72010124, 0.57640375],</span>
<span class="gi">+    [ 0.96559206, 0.72623592, 0.58438387],</span>
<span class="gi">+    [ 0.96575293, 0.73235058, 0.59242739],</span>
<span class="gi">+    [ 0.96592829, 0.73844258, 0.60053991],</span>
<span class="gi">+    [ 0.96612013, 0.74451182, 0.60871954],</span>
<span class="gi">+    [ 0.96632832, 0.75055966, 0.61696136],</span>
<span class="gi">+    [ 0.96656022, 0.75658231, 0.62527295],</span>
<span class="gi">+    [ 0.96681185, 0.76258381, 0.63364277],</span>
<span class="gi">+    [ 0.96709183, 0.76855969, 0.64207921],</span>
<span class="gi">+    [ 0.96739773, 0.77451297, 0.65057302],</span>
<span class="gi">+    [ 0.96773482, 0.78044149, 0.65912731],</span>
<span class="gi">+    [ 0.96810471, 0.78634563, 0.66773889],</span>
<span class="gi">+    [ 0.96850919, 0.79222565, 0.6764046 ],</span>
<span class="gi">+    [ 0.96893132, 0.79809112, 0.68512266],</span>
<span class="gi">+    [ 0.96935926, 0.80395415, 0.69383201],</span>
<span class="gi">+    [ 0.9698028 , 0.80981139, 0.70252255],</span>
<span class="gi">+    [ 0.97025511, 0.81566605, 0.71120296],</span>
<span class="gi">+    [ 0.97071849, 0.82151775, 0.71987163],</span>
<span class="gi">+    [ 0.97120159, 0.82736371, 0.72851999],</span>
<span class="gi">+    [ 0.97169389, 0.83320847, 0.73716071],</span>
<span class="gi">+    [ 0.97220061, 0.83905052, 0.74578903],</span>
<span class="gi">+    [ 0.97272597, 0.84488881, 0.75440141],</span>
<span class="gi">+    [ 0.97327085, 0.85072354, 0.76299805],</span>
<span class="gi">+    [ 0.97383206, 0.85655639, 0.77158353],</span>
<span class="gi">+    [ 0.97441222, 0.86238689, 0.78015619],</span>
<span class="gi">+    [ 0.97501782, 0.86821321, 0.78871034],</span>
<span class="gi">+    [ 0.97564391, 0.87403763, 0.79725261],</span>
<span class="gi">+    [ 0.97628674, 0.87986189, 0.8057883 ],</span>
<span class="gi">+    [ 0.97696114, 0.88568129, 0.81430324],</span>
<span class="gi">+    [ 0.97765722, 0.89149971, 0.82280948],</span>
<span class="gi">+    [ 0.97837585, 0.89731727, 0.83130786],</span>
<span class="gi">+    [ 0.97912374, 0.90313207, 0.83979337],</span>
<span class="gi">+    [ 0.979891  , 0.90894778, 0.84827858],</span>
<span class="gi">+    [ 0.98067764, 0.91476465, 0.85676611],</span>
<span class="gi">+    [ 0.98137749, 0.92061729, 0.86536915]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_mako_lut = [</span>
<span class="gi">+    [ 0.04503935, 0.01482344, 0.02092227],</span>
<span class="gi">+    [ 0.04933018, 0.01709292, 0.02535719],</span>
<span class="gi">+    [ 0.05356262, 0.01950702, 0.03018802],</span>
<span class="gi">+    [ 0.05774337, 0.02205989, 0.03545515],</span>
<span class="gi">+    [ 0.06188095, 0.02474764, 0.04115287],</span>
<span class="gi">+    [ 0.06598247, 0.0275665 , 0.04691409],</span>
<span class="gi">+    [ 0.07005374, 0.03051278, 0.05264306],</span>
<span class="gi">+    [ 0.07409947, 0.03358324, 0.05834631],</span>
<span class="gi">+    [ 0.07812339, 0.03677446, 0.06403249],</span>
<span class="gi">+    [ 0.08212852, 0.0400833 , 0.06970862],</span>
<span class="gi">+    [ 0.08611731, 0.04339148, 0.07538208],</span>
<span class="gi">+    [ 0.09009161, 0.04664706, 0.08105568],</span>
<span class="gi">+    [ 0.09405308, 0.04985685, 0.08673591],</span>
<span class="gi">+    [ 0.09800301, 0.05302279, 0.09242646],</span>
<span class="gi">+    [ 0.10194255, 0.05614641, 0.09813162],</span>
<span class="gi">+    [ 0.10587261, 0.05922941, 0.103854  ],</span>
<span class="gi">+    [ 0.1097942 , 0.06227277, 0.10959847],</span>
<span class="gi">+    [ 0.11370826, 0.06527747, 0.11536893],</span>
<span class="gi">+    [ 0.11761516, 0.06824548, 0.12116393],</span>
<span class="gi">+    [ 0.12151575, 0.07117741, 0.12698763],</span>
<span class="gi">+    [ 0.12541095, 0.07407363, 0.1328442 ],</span>
<span class="gi">+    [ 0.12930083, 0.07693611, 0.13873064],</span>
<span class="gi">+    [ 0.13317849, 0.07976988, 0.14465095],</span>
<span class="gi">+    [ 0.13701138, 0.08259683, 0.15060265],</span>
<span class="gi">+    [ 0.14079223, 0.08542126, 0.15659379],</span>
<span class="gi">+    [ 0.14452486, 0.08824175, 0.16262484],</span>
<span class="gi">+    [ 0.14820351, 0.09106304, 0.16869476],</span>
<span class="gi">+    [ 0.15183185, 0.09388372, 0.17480366],</span>
<span class="gi">+    [ 0.15540398, 0.09670855, 0.18094993],</span>
<span class="gi">+    [ 0.15892417, 0.09953561, 0.18713384],</span>
<span class="gi">+    [ 0.16238588, 0.10236998, 0.19335329],</span>
<span class="gi">+    [ 0.16579435, 0.10520905, 0.19960847],</span>
<span class="gi">+    [ 0.16914226, 0.10805832, 0.20589698],</span>
<span class="gi">+    [ 0.17243586, 0.11091443, 0.21221911],</span>
<span class="gi">+    [ 0.17566717, 0.11378321, 0.21857219],</span>
<span class="gi">+    [ 0.17884322, 0.11666074, 0.2249565 ],</span>
<span class="gi">+    [ 0.18195582, 0.11955283, 0.23136943],</span>
<span class="gi">+    [ 0.18501213, 0.12245547, 0.23781116],</span>
<span class="gi">+    [ 0.18800459, 0.12537395, 0.24427914],</span>
<span class="gi">+    [ 0.19093944, 0.1283047 , 0.25077369],</span>
<span class="gi">+    [ 0.19381092, 0.13125179, 0.25729255],</span>
<span class="gi">+    [ 0.19662307, 0.13421303, 0.26383543],</span>
<span class="gi">+    [ 0.19937337, 0.13719028, 0.27040111],</span>
<span class="gi">+    [ 0.20206187, 0.14018372, 0.27698891],</span>
<span class="gi">+    [ 0.20469116, 0.14319196, 0.28359861],</span>
<span class="gi">+    [ 0.20725547, 0.14621882, 0.29022775],</span>
<span class="gi">+    [ 0.20976258, 0.14925954, 0.29687795],</span>
<span class="gi">+    [ 0.21220409, 0.15231929, 0.30354703],</span>
<span class="gi">+    [ 0.21458611, 0.15539445, 0.31023563],</span>
<span class="gi">+    [ 0.21690827, 0.15848519, 0.31694355],</span>
<span class="gi">+    [ 0.21916481, 0.16159489, 0.32366939],</span>
<span class="gi">+    [ 0.2213631 , 0.16471913, 0.33041431],</span>
<span class="gi">+    [ 0.22349947, 0.1678599 , 0.33717781],</span>
<span class="gi">+    [ 0.2255714 , 0.1710185 , 0.34395925],</span>
<span class="gi">+    [ 0.22758415, 0.17419169, 0.35075983],</span>
<span class="gi">+    [ 0.22953569, 0.17738041, 0.35757941],</span>
<span class="gi">+    [ 0.23142077, 0.18058733, 0.3644173 ],</span>
<span class="gi">+    [ 0.2332454 , 0.18380872, 0.37127514],</span>
<span class="gi">+    [ 0.2350092 , 0.18704459, 0.3781528 ],</span>
<span class="gi">+    [ 0.23670785, 0.190297  , 0.38504973],</span>
<span class="gi">+    [ 0.23834119, 0.19356547, 0.39196711],</span>
<span class="gi">+    [ 0.23991189, 0.19684817, 0.39890581],</span>
<span class="gi">+    [ 0.24141903, 0.20014508, 0.4058667 ],</span>
<span class="gi">+    [ 0.24286214, 0.20345642, 0.4128484 ],</span>
<span class="gi">+    [ 0.24423453, 0.20678459, 0.41985299],</span>
<span class="gi">+    [ 0.24554109, 0.21012669, 0.42688124],</span>
<span class="gi">+    [ 0.2467815 , 0.21348266, 0.43393244],</span>
<span class="gi">+    [ 0.24795393, 0.21685249, 0.4410088 ],</span>
<span class="gi">+    [ 0.24905614, 0.22023618, 0.448113  ],</span>
<span class="gi">+    [ 0.25007383, 0.22365053, 0.45519562],</span>
<span class="gi">+    [ 0.25098926, 0.22710664, 0.46223892],</span>
<span class="gi">+    [ 0.25179696, 0.23060342, 0.46925447],</span>
<span class="gi">+    [ 0.25249346, 0.23414353, 0.47623196],</span>
<span class="gi">+    [ 0.25307401, 0.23772973, 0.48316271],</span>
<span class="gi">+    [ 0.25353152, 0.24136961, 0.49001976],</span>
<span class="gi">+    [ 0.25386167, 0.24506548, 0.49679407],</span>
<span class="gi">+    [ 0.25406082, 0.2488164 , 0.50348932],</span>
<span class="gi">+    [ 0.25412435, 0.25262843, 0.51007843],</span>
<span class="gi">+    [ 0.25404842, 0.25650743, 0.51653282],</span>
<span class="gi">+    [ 0.25383134, 0.26044852, 0.52286845],</span>
<span class="gi">+    [ 0.2534705 , 0.26446165, 0.52903422],</span>
<span class="gi">+    [ 0.25296722, 0.2685428 , 0.53503572],</span>
<span class="gi">+    [ 0.2523226 , 0.27269346, 0.54085315],</span>
<span class="gi">+    [ 0.25153974, 0.27691629, 0.54645752],</span>
<span class="gi">+    [ 0.25062402, 0.28120467, 0.55185939],</span>
<span class="gi">+    [ 0.24958205, 0.28556371, 0.55701246],</span>
<span class="gi">+    [ 0.24842386, 0.28998148, 0.56194601],</span>
<span class="gi">+    [ 0.24715928, 0.29446327, 0.56660884],</span>
<span class="gi">+    [ 0.24580099, 0.29899398, 0.57104399],</span>
<span class="gi">+    [ 0.24436202, 0.30357852, 0.57519929],</span>
<span class="gi">+    [ 0.24285591, 0.30819938, 0.57913247],</span>
<span class="gi">+    [ 0.24129828, 0.31286235, 0.58278615],</span>
<span class="gi">+    [ 0.23970131, 0.3175495 , 0.5862272 ],</span>
<span class="gi">+    [ 0.23807973, 0.32226344, 0.58941872],</span>
<span class="gi">+    [ 0.23644557, 0.32699241, 0.59240198],</span>
<span class="gi">+    [ 0.2348113 , 0.33173196, 0.59518282],</span>
<span class="gi">+    [ 0.23318874, 0.33648036, 0.59775543],</span>
<span class="gi">+    [ 0.2315855 , 0.34122763, 0.60016456],</span>
<span class="gi">+    [ 0.23001121, 0.34597357, 0.60240251],</span>
<span class="gi">+    [ 0.2284748 , 0.35071512, 0.6044784 ],</span>
<span class="gi">+    [ 0.22698081, 0.35544612, 0.60642528],</span>
<span class="gi">+    [ 0.22553305, 0.36016515, 0.60825252],</span>
<span class="gi">+    [ 0.22413977, 0.36487341, 0.60994938],</span>
<span class="gi">+    [ 0.22280246, 0.36956728, 0.61154118],</span>
<span class="gi">+    [ 0.22152555, 0.37424409, 0.61304472],</span>
<span class="gi">+    [ 0.22030752, 0.37890437, 0.61446646],</span>
<span class="gi">+    [ 0.2191538 , 0.38354668, 0.61581561],</span>
<span class="gi">+    [ 0.21806257, 0.38817169, 0.61709794],</span>
<span class="gi">+    [ 0.21703799, 0.39277882, 0.61831922],</span>
<span class="gi">+    [ 0.21607792, 0.39736958, 0.61948028],</span>
<span class="gi">+    [ 0.21518463, 0.40194196, 0.62059763],</span>
<span class="gi">+    [ 0.21435467, 0.40649717, 0.62167507],</span>
<span class="gi">+    [ 0.21358663, 0.41103579, 0.62271724],</span>
<span class="gi">+    [ 0.21288172, 0.41555771, 0.62373011],</span>
<span class="gi">+    [ 0.21223835, 0.42006355, 0.62471794],</span>
<span class="gi">+    [ 0.21165312, 0.42455441, 0.62568371],</span>
<span class="gi">+    [ 0.21112526, 0.42903064, 0.6266318 ],</span>
<span class="gi">+    [ 0.21065161, 0.43349321, 0.62756504],</span>
<span class="gi">+    [ 0.21023306, 0.43794288, 0.62848279],</span>
<span class="gi">+    [ 0.20985996, 0.44238227, 0.62938329],</span>
<span class="gi">+    [ 0.20951045, 0.44680966, 0.63030696],</span>
<span class="gi">+    [ 0.20916709, 0.45122981, 0.63124483],</span>
<span class="gi">+    [ 0.20882976, 0.45564335, 0.63219599],</span>
<span class="gi">+    [ 0.20849798, 0.46005094, 0.63315928],</span>
<span class="gi">+    [ 0.20817199, 0.46445309, 0.63413391],</span>
<span class="gi">+    [ 0.20785149, 0.46885041, 0.63511876],</span>
<span class="gi">+    [ 0.20753716, 0.47324327, 0.63611321],</span>
<span class="gi">+    [ 0.20722876, 0.47763224, 0.63711608],</span>
<span class="gi">+    [ 0.20692679, 0.48201774, 0.63812656],</span>
<span class="gi">+    [ 0.20663156, 0.48640018, 0.63914367],</span>
<span class="gi">+    [ 0.20634336, 0.49078002, 0.64016638],</span>
<span class="gi">+    [ 0.20606303, 0.49515755, 0.6411939 ],</span>
<span class="gi">+    [ 0.20578999, 0.49953341, 0.64222457],</span>
<span class="gi">+    [ 0.20552612, 0.50390766, 0.64325811],</span>
<span class="gi">+    [ 0.20527189, 0.50828072, 0.64429331],</span>
<span class="gi">+    [ 0.20502868, 0.51265277, 0.64532947],</span>
<span class="gi">+    [ 0.20479718, 0.51702417, 0.64636539],</span>
<span class="gi">+    [ 0.20457804, 0.52139527, 0.64739979],</span>
<span class="gi">+    [ 0.20437304, 0.52576622, 0.64843198],</span>
<span class="gi">+    [ 0.20418396, 0.53013715, 0.64946117],</span>
<span class="gi">+    [ 0.20401238, 0.53450825, 0.65048638],</span>
<span class="gi">+    [ 0.20385896, 0.53887991, 0.65150606],</span>
<span class="gi">+    [ 0.20372653, 0.54325208, 0.65251978],</span>
<span class="gi">+    [ 0.20361709, 0.5476249 , 0.6535266 ],</span>
<span class="gi">+    [ 0.20353258, 0.55199854, 0.65452542],</span>
<span class="gi">+    [ 0.20347472, 0.55637318, 0.655515  ],</span>
<span class="gi">+    [ 0.20344718, 0.56074869, 0.65649508],</span>
<span class="gi">+    [ 0.20345161, 0.56512531, 0.65746419],</span>
<span class="gi">+    [ 0.20349089, 0.56950304, 0.65842151],</span>
<span class="gi">+    [ 0.20356842, 0.57388184, 0.65936642],</span>
<span class="gi">+    [ 0.20368663, 0.57826181, 0.66029768],</span>
<span class="gi">+    [ 0.20384884, 0.58264293, 0.6612145 ],</span>
<span class="gi">+    [ 0.20405904, 0.58702506, 0.66211645],</span>
<span class="gi">+    [ 0.20431921, 0.59140842, 0.66300179],</span>
<span class="gi">+    [ 0.20463464, 0.59579264, 0.66387079],</span>
<span class="gi">+    [ 0.20500731, 0.60017798, 0.66472159],</span>
<span class="gi">+    [ 0.20544449, 0.60456387, 0.66555409],</span>
<span class="gi">+    [ 0.20596097, 0.60894927, 0.66636568],</span>
<span class="gi">+    [ 0.20654832, 0.61333521, 0.66715744],</span>
<span class="gi">+    [ 0.20721003, 0.61772167, 0.66792838],</span>
<span class="gi">+    [ 0.20795035, 0.62210845, 0.66867802],</span>
<span class="gi">+    [ 0.20877302, 0.62649546, 0.66940555],</span>
<span class="gi">+    [ 0.20968223, 0.63088252, 0.6701105 ],</span>
<span class="gi">+    [ 0.21068163, 0.63526951, 0.67079211],</span>
<span class="gi">+    [ 0.21177544, 0.63965621, 0.67145005],</span>
<span class="gi">+    [ 0.21298582, 0.64404072, 0.67208182],</span>
<span class="gi">+    [ 0.21430361, 0.64842404, 0.67268861],</span>
<span class="gi">+    [ 0.21572716, 0.65280655, 0.67326978],</span>
<span class="gi">+    [ 0.21726052, 0.65718791, 0.6738255 ],</span>
<span class="gi">+    [ 0.21890636, 0.66156803, 0.67435491],</span>
<span class="gi">+    [ 0.220668  , 0.66594665, 0.67485792],</span>
<span class="gi">+    [ 0.22255447, 0.67032297, 0.67533374],</span>
<span class="gi">+    [ 0.22458372, 0.67469531, 0.67578061],</span>
<span class="gi">+    [ 0.22673713, 0.67906542, 0.67620044],</span>
<span class="gi">+    [ 0.22901625, 0.6834332 , 0.67659251],</span>
<span class="gi">+    [ 0.23142316, 0.68779836, 0.67695703],</span>
<span class="gi">+    [ 0.23395924, 0.69216072, 0.67729378],</span>
<span class="gi">+    [ 0.23663857, 0.69651881, 0.67760151],</span>
<span class="gi">+    [ 0.23946645, 0.70087194, 0.67788018],</span>
<span class="gi">+    [ 0.24242624, 0.70522162, 0.67813088],</span>
<span class="gi">+    [ 0.24549008, 0.70957083, 0.67835215],</span>
<span class="gi">+    [ 0.24863372, 0.71392166, 0.67854868],</span>
<span class="gi">+    [ 0.25187832, 0.71827158, 0.67872193],</span>
<span class="gi">+    [ 0.25524083, 0.72261873, 0.67887024],</span>
<span class="gi">+    [ 0.25870947, 0.72696469, 0.67898912],</span>
<span class="gi">+    [ 0.26229238, 0.73130855, 0.67907645],</span>
<span class="gi">+    [ 0.26604085, 0.73564353, 0.67914062],</span>
<span class="gi">+    [ 0.26993099, 0.73997282, 0.67917264],</span>
<span class="gi">+    [ 0.27397488, 0.74429484, 0.67917096],</span>
<span class="gi">+    [ 0.27822463, 0.74860229, 0.67914468],</span>
<span class="gi">+    [ 0.28264201, 0.75290034, 0.67907959],</span>
<span class="gi">+    [ 0.2873016 , 0.75717817, 0.67899164],</span>
<span class="gi">+    [ 0.29215894, 0.76144162, 0.67886578],</span>
<span class="gi">+    [ 0.29729823, 0.76567816, 0.67871894],</span>
<span class="gi">+    [ 0.30268199, 0.76989232, 0.67853896],</span>
<span class="gi">+    [ 0.30835665, 0.77407636, 0.67833512],</span>
<span class="gi">+    [ 0.31435139, 0.77822478, 0.67811118],</span>
<span class="gi">+    [ 0.3206671 , 0.78233575, 0.67786729],</span>
<span class="gi">+    [ 0.32733158, 0.78640315, 0.67761027],</span>
<span class="gi">+    [ 0.33437168, 0.79042043, 0.67734882],</span>
<span class="gi">+    [ 0.34182112, 0.79437948, 0.67709394],</span>
<span class="gi">+    [ 0.34968889, 0.79827511, 0.67685638],</span>
<span class="gi">+    [ 0.35799244, 0.80210037, 0.67664969],</span>
<span class="gi">+    [ 0.36675371, 0.80584651, 0.67649539],</span>
<span class="gi">+    [ 0.3759816 , 0.80950627, 0.67641393],</span>
<span class="gi">+    [ 0.38566792, 0.81307432, 0.67642947],</span>
<span class="gi">+    [ 0.39579804, 0.81654592, 0.67656899],</span>
<span class="gi">+    [ 0.40634556, 0.81991799, 0.67686215],</span>
<span class="gi">+    [ 0.41730243, 0.82318339, 0.67735255],</span>
<span class="gi">+    [ 0.4285828 , 0.82635051, 0.6780564 ],</span>
<span class="gi">+    [ 0.44012728, 0.82942353, 0.67900049],</span>
<span class="gi">+    [ 0.45189421, 0.83240398, 0.68021733],</span>
<span class="gi">+    [ 0.46378379, 0.83530763, 0.6817062 ],</span>
<span class="gi">+    [ 0.47573199, 0.83814472, 0.68347352],</span>
<span class="gi">+    [ 0.48769865, 0.84092197, 0.68552698],</span>
<span class="gi">+    [ 0.49962354, 0.84365379, 0.68783929],</span>
<span class="gi">+    [ 0.5114027 , 0.8463718 , 0.69029789],</span>
<span class="gi">+    [ 0.52301693, 0.84908401, 0.69288545],</span>
<span class="gi">+    [ 0.53447549, 0.85179048, 0.69561066],</span>
<span class="gi">+    [ 0.54578602, 0.8544913 , 0.69848331],</span>
<span class="gi">+    [ 0.55695565, 0.85718723, 0.70150427],</span>
<span class="gi">+    [ 0.56798832, 0.85987893, 0.70468261],</span>
<span class="gi">+    [ 0.57888639, 0.86256715, 0.70802931],</span>
<span class="gi">+    [ 0.5896541 , 0.8652532 , 0.71154204],</span>
<span class="gi">+    [ 0.60028928, 0.86793835, 0.71523675],</span>
<span class="gi">+    [ 0.61079441, 0.87062438, 0.71910895],</span>
<span class="gi">+    [ 0.62116633, 0.87331311, 0.72317003],</span>
<span class="gi">+    [ 0.63140509, 0.87600675, 0.72741689],</span>
<span class="gi">+    [ 0.64150735, 0.87870746, 0.73185717],</span>
<span class="gi">+    [ 0.65147219, 0.8814179 , 0.73648495],</span>
<span class="gi">+    [ 0.66129632, 0.8841403 , 0.74130658],</span>
<span class="gi">+    [ 0.67097934, 0.88687758, 0.74631123],</span>
<span class="gi">+    [ 0.68051833, 0.88963189, 0.75150483],</span>
<span class="gi">+    [ 0.68991419, 0.89240612, 0.75687187],</span>
<span class="gi">+    [ 0.69916533, 0.89520211, 0.76241714],</span>
<span class="gi">+    [ 0.70827373, 0.89802257, 0.76812286],</span>
<span class="gi">+    [ 0.71723995, 0.90086891, 0.77399039],</span>
<span class="gi">+    [ 0.72606665, 0.90374337, 0.7800041 ],</span>
<span class="gi">+    [ 0.73475675, 0.90664718, 0.78615802],</span>
<span class="gi">+    [ 0.74331358, 0.90958151, 0.79244474],</span>
<span class="gi">+    [ 0.75174143, 0.91254787, 0.79884925],</span>
<span class="gi">+    [ 0.76004473, 0.91554656, 0.80536823],</span>
<span class="gi">+    [ 0.76827704, 0.91856549, 0.81196513],</span>
<span class="gi">+    [ 0.77647029, 0.921603  , 0.81855729],</span>
<span class="gi">+    [ 0.78462009, 0.92466151, 0.82514119],</span>
<span class="gi">+    [ 0.79273542, 0.92773848, 0.83172131],</span>
<span class="gi">+    [ 0.8008109 , 0.93083672, 0.83829355],</span>
<span class="gi">+    [ 0.80885107, 0.93395528, 0.84485982],</span>
<span class="gi">+    [ 0.81685878, 0.9370938 , 0.85142101],</span>
<span class="gi">+    [ 0.82483206, 0.94025378, 0.8579751 ],</span>
<span class="gi">+    [ 0.83277661, 0.94343371, 0.86452477],</span>
<span class="gi">+    [ 0.84069127, 0.94663473, 0.87106853],</span>
<span class="gi">+    [ 0.84857662, 0.9498573 , 0.8776059 ],</span>
<span class="gi">+    [ 0.8564431 , 0.95309792, 0.88414253],</span>
<span class="gi">+    [ 0.86429066, 0.95635719, 0.89067759],</span>
<span class="gi">+    [ 0.87218969, 0.95960708, 0.89725384]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_vlag_lut = [</span>
<span class="gi">+    [ 0.13850039, 0.41331206, 0.74052025],</span>
<span class="gi">+    [ 0.15077609, 0.41762684, 0.73970427],</span>
<span class="gi">+    [ 0.16235219, 0.4219191 , 0.7389667 ],</span>
<span class="gi">+    [ 0.1733322 , 0.42619024, 0.73832537],</span>
<span class="gi">+    [ 0.18382538, 0.43044226, 0.73776764],</span>
<span class="gi">+    [ 0.19394034, 0.4346772 , 0.73725867],</span>
<span class="gi">+    [ 0.20367115, 0.43889576, 0.73685314],</span>
<span class="gi">+    [ 0.21313625, 0.44310003, 0.73648045],</span>
<span class="gi">+    [ 0.22231173, 0.44729079, 0.73619681],</span>
<span class="gi">+    [ 0.23125148, 0.45146945, 0.73597803],</span>
<span class="gi">+    [ 0.23998101, 0.45563715, 0.7358223 ],</span>
<span class="gi">+    [ 0.24853358, 0.45979489, 0.73571524],</span>
<span class="gi">+    [ 0.25691416, 0.4639437 , 0.73566943],</span>
<span class="gi">+    [ 0.26513894, 0.46808455, 0.73568319],</span>
<span class="gi">+    [ 0.27322194, 0.47221835, 0.73575497],</span>
<span class="gi">+    [ 0.28117543, 0.47634598, 0.73588332],</span>
<span class="gi">+    [ 0.28901021, 0.48046826, 0.73606686],</span>
<span class="gi">+    [ 0.2967358 , 0.48458597, 0.73630433],</span>
<span class="gi">+    [ 0.30436071, 0.48869986, 0.73659451],</span>
<span class="gi">+    [ 0.3118955 , 0.49281055, 0.73693255],</span>
<span class="gi">+    [ 0.31935389, 0.49691847, 0.73730851],</span>
<span class="gi">+    [ 0.32672701, 0.5010247 , 0.73774013],</span>
<span class="gi">+    [ 0.33402607, 0.50512971, 0.73821941],</span>
<span class="gi">+    [ 0.34125337, 0.50923419, 0.73874905],</span>
<span class="gi">+    [ 0.34840921, 0.51333892, 0.73933402],</span>
<span class="gi">+    [ 0.35551826, 0.51744353, 0.73994642],</span>
<span class="gi">+    [ 0.3625676 , 0.52154929, 0.74060763],</span>
<span class="gi">+    [ 0.36956356, 0.52565656, 0.74131327],</span>
<span class="gi">+    [ 0.37649902, 0.52976642, 0.74207698],</span>
<span class="gi">+    [ 0.38340273, 0.53387791, 0.74286286],</span>
<span class="gi">+    [ 0.39025859, 0.53799253, 0.7436962 ],</span>
<span class="gi">+    [ 0.39706821, 0.54211081, 0.744578  ],</span>
<span class="gi">+    [ 0.40384046, 0.54623277, 0.74549872],</span>
<span class="gi">+    [ 0.41058241, 0.55035849, 0.74645094],</span>
<span class="gi">+    [ 0.41728385, 0.55448919, 0.74745174],</span>
<span class="gi">+    [ 0.42395178, 0.55862494, 0.74849357],</span>
<span class="gi">+    [ 0.4305964 , 0.56276546, 0.74956387],</span>
<span class="gi">+    [ 0.4372044 , 0.56691228, 0.75068412],</span>
<span class="gi">+    [ 0.4437909 , 0.57106468, 0.75183427],</span>
<span class="gi">+    [ 0.45035117, 0.5752235 , 0.75302312],</span>
<span class="gi">+    [ 0.45687824, 0.57938983, 0.75426297],</span>
<span class="gi">+    [ 0.46339713, 0.58356191, 0.75551816],</span>
<span class="gi">+    [ 0.46988778, 0.58774195, 0.75682037],</span>
<span class="gi">+    [ 0.47635605, 0.59192986, 0.75816245],</span>
<span class="gi">+    [ 0.48281101, 0.5961252 , 0.75953212],</span>
<span class="gi">+    [ 0.4892374 , 0.60032986, 0.76095418],</span>
<span class="gi">+    [ 0.49566225, 0.60454154, 0.76238852],</span>
<span class="gi">+    [ 0.50206137, 0.60876307, 0.76387371],</span>
<span class="gi">+    [ 0.50845128, 0.61299312, 0.76538551],</span>
<span class="gi">+    [ 0.5148258 , 0.61723272, 0.76693475],</span>
<span class="gi">+    [ 0.52118385, 0.62148236, 0.76852436],</span>
<span class="gi">+    [ 0.52753571, 0.62574126, 0.77013939],</span>
<span class="gi">+    [ 0.53386831, 0.63001125, 0.77180152],</span>
<span class="gi">+    [ 0.54020159, 0.63429038, 0.7734803 ],</span>
<span class="gi">+    [ 0.54651272, 0.63858165, 0.77521306],</span>
<span class="gi">+    [ 0.55282975, 0.64288207, 0.77695608],</span>
<span class="gi">+    [ 0.55912585, 0.64719519, 0.77875327],</span>
<span class="gi">+    [ 0.56542599, 0.65151828, 0.78056551],</span>
<span class="gi">+    [ 0.57170924, 0.65585426, 0.78242747],</span>
<span class="gi">+    [ 0.57799572, 0.6602009 , 0.78430751],</span>
<span class="gi">+    [ 0.58426817, 0.66456073, 0.78623458],</span>
<span class="gi">+    [ 0.590544  , 0.66893178, 0.78818117],</span>
<span class="gi">+    [ 0.59680758, 0.67331643, 0.79017369],</span>
<span class="gi">+    [ 0.60307553, 0.67771273, 0.79218572],</span>
<span class="gi">+    [ 0.60934065, 0.68212194, 0.79422987],</span>
<span class="gi">+    [ 0.61559495, 0.68654548, 0.7963202 ],</span>
<span class="gi">+    [ 0.62185554, 0.69098125, 0.79842918],</span>
<span class="gi">+    [ 0.62810662, 0.69543176, 0.80058381],</span>
<span class="gi">+    [ 0.63436425, 0.69989499, 0.80275812],</span>
<span class="gi">+    [ 0.64061445, 0.70437326, 0.80497621],</span>
<span class="gi">+    [ 0.6468706 , 0.70886488, 0.80721641],</span>
<span class="gi">+    [ 0.65312213, 0.7133717 , 0.80949719],</span>
<span class="gi">+    [ 0.65937818, 0.71789261, 0.81180392],</span>
<span class="gi">+    [ 0.66563334, 0.72242871, 0.81414642],</span>
<span class="gi">+    [ 0.67189155, 0.72697967, 0.81651872],</span>
<span class="gi">+    [ 0.67815314, 0.73154569, 0.81892097],</span>
<span class="gi">+    [ 0.68441395, 0.73612771, 0.82136094],</span>
<span class="gi">+    [ 0.69068321, 0.74072452, 0.82382353],</span>
<span class="gi">+    [ 0.69694776, 0.7453385 , 0.82633199],</span>
<span class="gi">+    [ 0.70322431, 0.74996721, 0.8288583 ],</span>
<span class="gi">+    [ 0.70949595, 0.75461368, 0.83143221],</span>
<span class="gi">+    [ 0.7157774 , 0.75927574, 0.83402904],</span>
<span class="gi">+    [ 0.72206299, 0.76395461, 0.83665922],</span>
<span class="gi">+    [ 0.72835227, 0.76865061, 0.8393242 ],</span>
<span class="gi">+    [ 0.73465238, 0.7733628 , 0.84201224],</span>
<span class="gi">+    [ 0.74094862, 0.77809393, 0.84474951],</span>
<span class="gi">+    [ 0.74725683, 0.78284158, 0.84750915],</span>
<span class="gi">+    [ 0.75357103, 0.78760701, 0.85030217],</span>
<span class="gi">+    [ 0.75988961, 0.79239077, 0.85313207],</span>
<span class="gi">+    [ 0.76621987, 0.79719185, 0.85598668],</span>
<span class="gi">+    [ 0.77255045, 0.8020125 , 0.85888658],</span>
<span class="gi">+    [ 0.77889241, 0.80685102, 0.86181298],</span>
<span class="gi">+    [ 0.78524572, 0.81170768, 0.86476656],</span>
<span class="gi">+    [ 0.79159841, 0.81658489, 0.86776906],</span>
<span class="gi">+    [ 0.79796459, 0.82148036, 0.8707962 ],</span>
<span class="gi">+    [ 0.80434168, 0.82639479, 0.87385315],</span>
<span class="gi">+    [ 0.8107221 , 0.83132983, 0.87695392],</span>
<span class="gi">+    [ 0.81711301, 0.8362844 , 0.88008641],</span>
<span class="gi">+    [ 0.82351479, 0.84125863, 0.88325045],</span>
<span class="gi">+    [ 0.82992772, 0.84625263, 0.88644594],</span>
<span class="gi">+    [ 0.83634359, 0.85126806, 0.8896878 ],</span>
<span class="gi">+    [ 0.84277295, 0.85630293, 0.89295721],</span>
<span class="gi">+    [ 0.84921192, 0.86135782, 0.89626076],</span>
<span class="gi">+    [ 0.85566206, 0.866432  , 0.89959467],</span>
<span class="gi">+    [ 0.86211514, 0.87152627, 0.90297183],</span>
<span class="gi">+    [ 0.86857483, 0.87663856, 0.90638248],</span>
<span class="gi">+    [ 0.87504231, 0.88176648, 0.90981938],</span>
<span class="gi">+    [ 0.88151194, 0.88690782, 0.91328493],</span>
<span class="gi">+    [ 0.88797938, 0.89205857, 0.91677544],</span>
<span class="gi">+    [ 0.89443865, 0.89721298, 0.9202854 ],</span>
<span class="gi">+    [ 0.90088204, 0.90236294, 0.92380601],</span>
<span class="gi">+    [ 0.90729768, 0.90749778, 0.92732797],</span>
<span class="gi">+    [ 0.91367037, 0.91260329, 0.93083814],</span>
<span class="gi">+    [ 0.91998105, 0.91766106, 0.93431861],</span>
<span class="gi">+    [ 0.92620596, 0.92264789, 0.93774647],</span>
<span class="gi">+    [ 0.93231683, 0.9275351 , 0.94109192],</span>
<span class="gi">+    [ 0.93827772, 0.9322888 , 0.94432312],</span>
<span class="gi">+    [ 0.94404755, 0.93686925, 0.94740137],</span>
<span class="gi">+    [ 0.94958284, 0.94123072, 0.95027696],</span>
<span class="gi">+    [ 0.95482682, 0.9453245 , 0.95291103],</span>
<span class="gi">+    [ 0.9597248 , 0.94909728, 0.95525103],</span>
<span class="gi">+    [ 0.96422552, 0.95249273, 0.95723271],</span>
<span class="gi">+    [ 0.96826161, 0.95545812, 0.95882188],</span>
<span class="gi">+    [ 0.97178458, 0.95793984, 0.95995705],</span>
<span class="gi">+    [ 0.97474105, 0.95989142, 0.96059997],</span>
<span class="gi">+    [ 0.97708604, 0.96127366, 0.96071853],</span>
<span class="gi">+    [ 0.97877855, 0.96205832, 0.96030095],</span>
<span class="gi">+    [ 0.97978484, 0.96222949, 0.95935496],</span>
<span class="gi">+    [ 0.9805997 , 0.96155216, 0.95813083],</span>
<span class="gi">+    [ 0.98152619, 0.95993719, 0.95639322],</span>
<span class="gi">+    [ 0.9819726 , 0.95766608, 0.95399269],</span>
<span class="gi">+    [ 0.98191855, 0.9547873 , 0.95098107],</span>
<span class="gi">+    [ 0.98138514, 0.95134771, 0.94740644],</span>
<span class="gi">+    [ 0.98040845, 0.94739906, 0.94332125],</span>
<span class="gi">+    [ 0.97902107, 0.94300131, 0.93878672],</span>
<span class="gi">+    [ 0.97729348, 0.93820409, 0.93385135],</span>
<span class="gi">+    [ 0.9752533 , 0.933073  , 0.92858252],</span>
<span class="gi">+    [ 0.97297834, 0.92765261, 0.92302309],</span>
<span class="gi">+    [ 0.97049104, 0.92200317, 0.91723505],</span>
<span class="gi">+    [ 0.96784372, 0.91616744, 0.91126063],</span>
<span class="gi">+    [ 0.96507281, 0.91018664, 0.90514124],</span>
<span class="gi">+    [ 0.96222034, 0.90409203, 0.89890756],</span>
<span class="gi">+    [ 0.9593079 , 0.89791478, 0.89259122],</span>
<span class="gi">+    [ 0.95635626, 0.89167908, 0.88621654],</span>
<span class="gi">+    [ 0.95338303, 0.88540373, 0.87980238],</span>
<span class="gi">+    [ 0.95040174, 0.87910333, 0.87336339],</span>
<span class="gi">+    [ 0.94742246, 0.87278899, 0.86691076],</span>
<span class="gi">+    [ 0.94445249, 0.86646893, 0.86045277],</span>
<span class="gi">+    [ 0.94150476, 0.86014606, 0.85399191],</span>
<span class="gi">+    [ 0.93857394, 0.85382798, 0.84753642],</span>
<span class="gi">+    [ 0.93566206, 0.84751766, 0.84108935],</span>
<span class="gi">+    [ 0.93277194, 0.8412164 , 0.83465197],</span>
<span class="gi">+    [ 0.92990106, 0.83492672, 0.82822708],</span>
<span class="gi">+    [ 0.92704736, 0.82865028, 0.82181656],</span>
<span class="gi">+    [ 0.92422703, 0.82238092, 0.81541333],</span>
<span class="gi">+    [ 0.92142581, 0.81612448, 0.80902415],</span>
<span class="gi">+    [ 0.91864501, 0.80988032, 0.80264838],</span>
<span class="gi">+    [ 0.91587578, 0.80365187, 0.79629001],</span>
<span class="gi">+    [ 0.9131367 , 0.79743115, 0.78994   ],</span>
<span class="gi">+    [ 0.91041602, 0.79122265, 0.78360361],</span>
<span class="gi">+    [ 0.90771071, 0.78502727, 0.77728196],</span>
<span class="gi">+    [ 0.90501581, 0.77884674, 0.7709771 ],</span>
<span class="gi">+    [ 0.90235365, 0.77267117, 0.76467793],</span>
<span class="gi">+    [ 0.8997019 , 0.76650962, 0.75839484],</span>
<span class="gi">+    [ 0.89705346, 0.76036481, 0.752131  ],</span>
<span class="gi">+    [ 0.89444021, 0.75422253, 0.74587047],</span>
<span class="gi">+    [ 0.89183355, 0.74809474, 0.73962689],</span>
<span class="gi">+    [ 0.88923216, 0.74198168, 0.73340061],</span>
<span class="gi">+    [ 0.88665892, 0.73587283, 0.72717995],</span>
<span class="gi">+    [ 0.88408839, 0.72977904, 0.72097718],</span>
<span class="gi">+    [ 0.88153537, 0.72369332, 0.71478461],</span>
<span class="gi">+    [ 0.87899389, 0.7176179 , 0.70860487],</span>
<span class="gi">+    [ 0.87645157, 0.71155805, 0.7024439 ],</span>
<span class="gi">+    [ 0.8739399 , 0.70549893, 0.6962854 ],</span>
<span class="gi">+    [ 0.87142626, 0.6994551 , 0.69014561],</span>
<span class="gi">+    [ 0.8689268 , 0.69341868, 0.68401597],</span>
<span class="gi">+    [ 0.86643562, 0.687392  , 0.67789917],</span>
<span class="gi">+    [ 0.86394434, 0.68137863, 0.67179927],</span>
<span class="gi">+    [ 0.86147586, 0.67536728, 0.665704  ],</span>
<span class="gi">+    [ 0.85899928, 0.66937226, 0.6596292 ],</span>
<span class="gi">+    [ 0.85654668, 0.66337773, 0.6535577 ],</span>
<span class="gi">+    [ 0.85408818, 0.65739772, 0.64750494],</span>
<span class="gi">+    [ 0.85164413, 0.65142189, 0.64145983],</span>
<span class="gi">+    [ 0.84920091, 0.6454565 , 0.63542932],</span>
<span class="gi">+    [ 0.84676427, 0.63949827, 0.62941   ],</span>
<span class="gi">+    [ 0.84433231, 0.63354773, 0.62340261],</span>
<span class="gi">+    [ 0.84190106, 0.62760645, 0.61740899],</span>
<span class="gi">+    [ 0.83947935, 0.62166951, 0.61142404],</span>
<span class="gi">+    [ 0.8370538 , 0.61574332, 0.60545478],</span>
<span class="gi">+    [ 0.83463975, 0.60981951, 0.59949247],</span>
<span class="gi">+    [ 0.83221877, 0.60390724, 0.593547  ],</span>
<span class="gi">+    [ 0.82980985, 0.59799607, 0.58760751],</span>
<span class="gi">+    [ 0.82740268, 0.59209095, 0.58167944],</span>
<span class="gi">+    [ 0.82498638, 0.5861973 , 0.57576866],</span>
<span class="gi">+    [ 0.82258181, 0.5803034 , 0.56986307],</span>
<span class="gi">+    [ 0.82016611, 0.57442123, 0.56397539],</span>
<span class="gi">+    [ 0.81776305, 0.56853725, 0.55809173],</span>
<span class="gi">+    [ 0.81534551, 0.56266602, 0.55222741],</span>
<span class="gi">+    [ 0.81294293, 0.55679056, 0.5463651 ],</span>
<span class="gi">+    [ 0.81052113, 0.55092973, 0.54052443],</span>
<span class="gi">+    [ 0.80811509, 0.54506305, 0.53468464],</span>
<span class="gi">+    [ 0.80568952, 0.53921036, 0.52886622],</span>
<span class="gi">+    [ 0.80327506, 0.53335335, 0.52305077],</span>
<span class="gi">+    [ 0.80084727, 0.52750583, 0.51725256],</span>
<span class="gi">+    [ 0.79842217, 0.5216578 , 0.51146173],</span>
<span class="gi">+    [ 0.79599382, 0.51581223, 0.50568155],</span>
<span class="gi">+    [ 0.79355781, 0.50997127, 0.49991444],</span>
<span class="gi">+    [ 0.79112596, 0.50412707, 0.49415289],</span>
<span class="gi">+    [ 0.78867442, 0.49829386, 0.48841129],</span>
<span class="gi">+    [ 0.7862306 , 0.49245398, 0.48267247],</span>
<span class="gi">+    [ 0.7837687 , 0.48662309, 0.47695216],</span>
<span class="gi">+    [ 0.78130809, 0.4807883 , 0.47123805],</span>
<span class="gi">+    [ 0.77884467, 0.47495151, 0.46553236],</span>
<span class="gi">+    [ 0.77636283, 0.46912235, 0.45984473],</span>
<span class="gi">+    [ 0.77388383, 0.46328617, 0.45416141],</span>
<span class="gi">+    [ 0.77138912, 0.45745466, 0.44849398],</span>
<span class="gi">+    [ 0.76888874, 0.45162042, 0.44283573],</span>
<span class="gi">+    [ 0.76638802, 0.44577901, 0.43718292],</span>
<span class="gi">+    [ 0.76386116, 0.43994762, 0.43155211],</span>
<span class="gi">+    [ 0.76133542, 0.43410655, 0.42592523],</span>
<span class="gi">+    [ 0.75880631, 0.42825801, 0.42030488],</span>
<span class="gi">+    [ 0.75624913, 0.42241905, 0.41470727],</span>
<span class="gi">+    [ 0.7536919 , 0.41656866, 0.40911347],</span>
<span class="gi">+    [ 0.75112748, 0.41071104, 0.40352792],</span>
<span class="gi">+    [ 0.74854331, 0.40485474, 0.3979589 ],</span>
<span class="gi">+    [ 0.74594723, 0.39899309, 0.39240088],</span>
<span class="gi">+    [ 0.74334332, 0.39312199, 0.38685075],</span>
<span class="gi">+    [ 0.74073277, 0.38723941, 0.3813074 ],</span>
<span class="gi">+    [ 0.73809409, 0.38136133, 0.37578553],</span>
<span class="gi">+    [ 0.73544692, 0.37547129, 0.37027123],</span>
<span class="gi">+    [ 0.73278943, 0.36956954, 0.36476549],</span>
<span class="gi">+    [ 0.73011829, 0.36365761, 0.35927038],</span>
<span class="gi">+    [ 0.72743485, 0.35773314, 0.35378465],</span>
<span class="gi">+    [ 0.72472722, 0.35180504, 0.34831662],</span>
<span class="gi">+    [ 0.72200473, 0.34586421, 0.34285937],</span>
<span class="gi">+    [ 0.71927052, 0.33990649, 0.33741033],</span>
<span class="gi">+    [ 0.71652049, 0.33393396, 0.33197219],</span>
<span class="gi">+    [ 0.71375362, 0.32794602, 0.32654545],</span>
<span class="gi">+    [ 0.71096951, 0.32194148, 0.32113016],</span>
<span class="gi">+    [ 0.70816772, 0.31591904, 0.31572637],</span>
<span class="gi">+    [ 0.70534784, 0.30987734, 0.31033414],</span>
<span class="gi">+    [ 0.70250944, 0.30381489, 0.30495353],</span>
<span class="gi">+    [ 0.69965211, 0.2977301 , 0.2995846 ],</span>
<span class="gi">+    [ 0.6967754 , 0.29162126, 0.29422741],</span>
<span class="gi">+    [ 0.69388446, 0.28548074, 0.28887769],</span>
<span class="gi">+    [ 0.69097561, 0.2793096 , 0.28353795],</span>
<span class="gi">+    [ 0.68803513, 0.27311993, 0.27821876],</span>
<span class="gi">+    [ 0.6850794 , 0.26689144, 0.27290694],</span>
<span class="gi">+    [ 0.682108  , 0.26062114, 0.26760246],</span>
<span class="gi">+    [ 0.67911013, 0.2543177 , 0.26231367],</span>
<span class="gi">+    [ 0.67609393, 0.24796818, 0.25703372],</span>
<span class="gi">+    [ 0.67305921, 0.24156846, 0.25176238],</span>
<span class="gi">+    [ 0.67000176, 0.23511902, 0.24650278],</span>
<span class="gi">+    [ 0.66693423, 0.22859879, 0.24124404],</span>
<span class="gi">+    [ 0.6638441 , 0.22201742, 0.2359961 ],</span>
<span class="gi">+    [ 0.66080672, 0.21526712, 0.23069468]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_icefire_lut = [</span>
<span class="gi">+    [ 0.73936227, 0.90443867, 0.85757238],</span>
<span class="gi">+    [ 0.72888063, 0.89639109, 0.85488394],</span>
<span class="gi">+    [ 0.71834255, 0.88842162, 0.8521605 ],</span>
<span class="gi">+    [ 0.70773866, 0.88052939, 0.849422  ],</span>
<span class="gi">+    [ 0.69706215, 0.87271313, 0.84668315],</span>
<span class="gi">+    [ 0.68629021, 0.86497329, 0.84398721],</span>
<span class="gi">+    [ 0.67543654, 0.85730617, 0.84130969],</span>
<span class="gi">+    [ 0.66448539, 0.84971123, 0.83868005],</span>
<span class="gi">+    [ 0.65342679, 0.84218728, 0.83611512],</span>
<span class="gi">+    [ 0.64231804, 0.83471867, 0.83358584],</span>
<span class="gi">+    [ 0.63117745, 0.827294  , 0.83113431],</span>
<span class="gi">+    [ 0.62000484, 0.81991069, 0.82876741],</span>
<span class="gi">+    [ 0.60879435, 0.81256797, 0.82648905],</span>
<span class="gi">+    [ 0.59754118, 0.80526458, 0.82430414],</span>
<span class="gi">+    [ 0.58624247, 0.79799884, 0.82221573],</span>
<span class="gi">+    [ 0.57489525, 0.7907688 , 0.82022901],</span>
<span class="gi">+    [ 0.56349779, 0.78357215, 0.81834861],</span>
<span class="gi">+    [ 0.55204294, 0.77640827, 0.81657563],</span>
<span class="gi">+    [ 0.54052516, 0.76927562, 0.81491462],</span>
<span class="gi">+    [ 0.52894085, 0.76217215, 0.81336913],</span>
<span class="gi">+    [ 0.51728854, 0.75509528, 0.81194156],</span>
<span class="gi">+    [ 0.50555676, 0.74804469, 0.81063503],</span>
<span class="gi">+    [ 0.49373871, 0.7410187 , 0.80945242],</span>
<span class="gi">+    [ 0.48183174, 0.73401449, 0.80839675],</span>
<span class="gi">+    [ 0.46982587, 0.72703075, 0.80747097],</span>
<span class="gi">+    [ 0.45770893, 0.72006648, 0.80667756],</span>
<span class="gi">+    [ 0.44547249, 0.71311941, 0.80601991],</span>
<span class="gi">+    [ 0.43318643, 0.70617126, 0.80549278],</span>
<span class="gi">+    [ 0.42110294, 0.69916972, 0.80506683],</span>
<span class="gi">+    [ 0.40925101, 0.69211059, 0.80473246],</span>
<span class="gi">+    [ 0.3976693 , 0.68498786, 0.80448272],</span>
<span class="gi">+    [ 0.38632002, 0.67781125, 0.80431024],</span>
<span class="gi">+    [ 0.37523981, 0.67057537, 0.80420832],</span>
<span class="gi">+    [ 0.36442578, 0.66328229, 0.80417474],</span>
<span class="gi">+    [ 0.35385939, 0.65593699, 0.80420591],</span>
<span class="gi">+    [ 0.34358916, 0.64853177, 0.8043    ],</span>
<span class="gi">+    [ 0.33355526, 0.64107876, 0.80445484],</span>
<span class="gi">+    [ 0.32383062, 0.63356578, 0.80467091],</span>
<span class="gi">+    [ 0.31434372, 0.62600624, 0.8049475 ],</span>
<span class="gi">+    [ 0.30516161, 0.618389  , 0.80528692],</span>
<span class="gi">+    [ 0.29623491, 0.61072284, 0.80569021],</span>
<span class="gi">+    [ 0.28759072, 0.60300319, 0.80616055],</span>
<span class="gi">+    [ 0.27923924, 0.59522877, 0.80669803],</span>
<span class="gi">+    [ 0.27114651, 0.5874047 , 0.80730545],</span>
<span class="gi">+    [ 0.26337153, 0.57952055, 0.80799113],</span>
<span class="gi">+    [ 0.25588696, 0.57157984, 0.80875922],</span>
<span class="gi">+    [ 0.248686  , 0.56358255, 0.80961366],</span>
<span class="gi">+    [ 0.24180668, 0.55552289, 0.81055123],</span>
<span class="gi">+    [ 0.23526251, 0.54739477, 0.8115939 ],</span>
<span class="gi">+    [ 0.22921445, 0.53918506, 0.81267292],</span>
<span class="gi">+    [ 0.22397687, 0.53086094, 0.8137141 ],</span>
<span class="gi">+    [ 0.21977058, 0.52241482, 0.81457651],</span>
<span class="gi">+    [ 0.21658989, 0.51384321, 0.81528511],</span>
<span class="gi">+    [ 0.21452772, 0.50514155, 0.81577278],</span>
<span class="gi">+    [ 0.21372783, 0.49630865, 0.81589566],</span>
<span class="gi">+    [ 0.21409503, 0.48734861, 0.81566163],</span>
<span class="gi">+    [ 0.2157176 , 0.47827123, 0.81487615],</span>
<span class="gi">+    [ 0.21842857, 0.46909168, 0.81351614],</span>
<span class="gi">+    [ 0.22211705, 0.45983212, 0.81146983],</span>
<span class="gi">+    [ 0.22665681, 0.45052233, 0.80860217],</span>
<span class="gi">+    [ 0.23176013, 0.44119137, 0.80494325],</span>
<span class="gi">+    [ 0.23727775, 0.43187704, 0.80038017],</span>
<span class="gi">+    [ 0.24298285, 0.42261123, 0.79493267],</span>
<span class="gi">+    [ 0.24865068, 0.41341842, 0.78869164],</span>
<span class="gi">+    [ 0.25423116, 0.40433127, 0.78155831],</span>
<span class="gi">+    [ 0.25950239, 0.39535521, 0.77376848],</span>
<span class="gi">+    [ 0.2644736 , 0.38651212, 0.76524809],</span>
<span class="gi">+    [ 0.26901584, 0.37779582, 0.75621942],</span>
<span class="gi">+    [ 0.27318141, 0.36922056, 0.746605  ],</span>
<span class="gi">+    [ 0.27690355, 0.3607736 , 0.73659374],</span>
<span class="gi">+    [ 0.28023585, 0.35244234, 0.72622103],</span>
<span class="gi">+    [ 0.28306009, 0.34438449, 0.71500731],</span>
<span class="gi">+    [ 0.28535896, 0.33660243, 0.70303975],</span>
<span class="gi">+    [ 0.28708711, 0.32912157, 0.69034504],</span>
<span class="gi">+    [ 0.28816354, 0.32200604, 0.67684067],</span>
<span class="gi">+    [ 0.28862749, 0.31519824, 0.66278813],</span>
<span class="gi">+    [ 0.28847904, 0.30869064, 0.6482815 ],</span>
<span class="gi">+    [ 0.28770912, 0.30250126, 0.63331265],</span>
<span class="gi">+    [ 0.28640325, 0.29655509, 0.61811374],</span>
<span class="gi">+    [ 0.28458943, 0.29082155, 0.60280913],</span>
<span class="gi">+    [ 0.28233561, 0.28527482, 0.58742866],</span>
<span class="gi">+    [ 0.27967038, 0.2798938 , 0.57204225],</span>
<span class="gi">+    [ 0.27665361, 0.27465357, 0.55667809],</span>
<span class="gi">+    [ 0.27332564, 0.2695165 , 0.54145387],</span>
<span class="gi">+    [ 0.26973851, 0.26447054, 0.52634916],</span>
<span class="gi">+    [ 0.2659204 , 0.25949691, 0.511417  ],</span>
<span class="gi">+    [ 0.26190145, 0.25458123, 0.49668768],</span>
<span class="gi">+    [ 0.2577151 , 0.24971691, 0.48214874],</span>
<span class="gi">+    [ 0.25337618, 0.24490494, 0.46778758],</span>
<span class="gi">+    [ 0.24890842, 0.24013332, 0.45363816],</span>
<span class="gi">+    [ 0.24433654, 0.23539226, 0.4397245 ],</span>
<span class="gi">+    [ 0.23967922, 0.23067729, 0.4260591 ],</span>
<span class="gi">+    [ 0.23495608, 0.22598894, 0.41262952],</span>
<span class="gi">+    [ 0.23018113, 0.22132414, 0.39945577],</span>
<span class="gi">+    [ 0.22534609, 0.21670847, 0.38645794],</span>
<span class="gi">+    [ 0.22048761, 0.21211723, 0.37372555],</span>
<span class="gi">+    [ 0.2156198 , 0.20755389, 0.36125301],</span>
<span class="gi">+    [ 0.21074637, 0.20302717, 0.34903192],</span>
<span class="gi">+    [ 0.20586893, 0.19855368, 0.33701661],</span>
<span class="gi">+    [ 0.20101757, 0.19411573, 0.32529173],</span>
<span class="gi">+    [ 0.19619947, 0.18972425, 0.31383846],</span>
<span class="gi">+    [ 0.19140726, 0.18540157, 0.30260777],</span>
<span class="gi">+    [ 0.1866769 , 0.1811332 , 0.29166583],</span>
<span class="gi">+    [ 0.18201285, 0.17694992, 0.28088776],</span>
<span class="gi">+    [ 0.17745228, 0.17282141, 0.27044211],</span>
<span class="gi">+    [ 0.17300684, 0.16876921, 0.26024893],</span>
<span class="gi">+    [ 0.16868273, 0.16479861, 0.25034479],</span>
<span class="gi">+    [ 0.16448691, 0.16091728, 0.24075373],</span>
<span class="gi">+    [ 0.16043195, 0.15714351, 0.23141745],</span>
<span class="gi">+    [ 0.15652427, 0.15348248, 0.22238175],</span>
<span class="gi">+    [ 0.15277065, 0.14994111, 0.21368395],</span>
<span class="gi">+    [ 0.14918274, 0.14653431, 0.20529486],</span>
<span class="gi">+    [ 0.14577095, 0.14327403, 0.19720829],</span>
<span class="gi">+    [ 0.14254381, 0.14016944, 0.18944326],</span>
<span class="gi">+    [ 0.13951035, 0.13723063, 0.18201072],</span>
<span class="gi">+    [ 0.13667798, 0.13446606, 0.17493774],</span>
<span class="gi">+    [ 0.13405762, 0.13188822, 0.16820842],</span>
<span class="gi">+    [ 0.13165767, 0.12950667, 0.16183275],</span>
<span class="gi">+    [ 0.12948748, 0.12733187, 0.15580631],</span>
<span class="gi">+    [ 0.12755435, 0.1253723 , 0.15014098],</span>
<span class="gi">+    [ 0.12586516, 0.12363617, 0.1448459 ],</span>
<span class="gi">+    [ 0.12442647, 0.12213143, 0.13992571],</span>
<span class="gi">+    [ 0.12324241, 0.12086419, 0.13539995],</span>
<span class="gi">+    [ 0.12232067, 0.11984278, 0.13124644],</span>
<span class="gi">+    [ 0.12166209, 0.11907077, 0.12749671],</span>
<span class="gi">+    [ 0.12126982, 0.11855309, 0.12415079],</span>
<span class="gi">+    [ 0.12114244, 0.11829179, 0.1212385 ],</span>
<span class="gi">+    [ 0.12127766, 0.11828837, 0.11878534],</span>
<span class="gi">+    [ 0.12284806, 0.1179729 , 0.11772022],</span>
<span class="gi">+    [ 0.12619498, 0.11721796, 0.11770203],</span>
<span class="gi">+    [ 0.129968  , 0.11663788, 0.11792377],</span>
<span class="gi">+    [ 0.13410011, 0.11625146, 0.11839138],</span>
<span class="gi">+    [ 0.13855459, 0.11606618, 0.11910584],</span>
<span class="gi">+    [ 0.14333775, 0.11607038, 0.1200606 ],</span>
<span class="gi">+    [ 0.148417  , 0.11626929, 0.12125453],</span>
<span class="gi">+    [ 0.15377389, 0.11666192, 0.12268364],</span>
<span class="gi">+    [ 0.15941427, 0.11723486, 0.12433911],</span>
<span class="gi">+    [ 0.16533376, 0.11797856, 0.12621303],</span>
<span class="gi">+    [ 0.17152547, 0.11888403, 0.12829735],</span>
<span class="gi">+    [ 0.17797765, 0.11994436, 0.13058435],</span>
<span class="gi">+    [ 0.18468769, 0.12114722, 0.13306426],</span>
<span class="gi">+    [ 0.19165663, 0.12247737, 0.13572616],</span>
<span class="gi">+    [ 0.19884415, 0.12394381, 0.1385669 ],</span>
<span class="gi">+    [ 0.20627181, 0.12551883, 0.14157124],</span>
<span class="gi">+    [ 0.21394877, 0.12718055, 0.14472604],</span>
<span class="gi">+    [ 0.22184572, 0.12893119, 0.14802579],</span>
<span class="gi">+    [ 0.22994394, 0.13076731, 0.15146314],</span>
<span class="gi">+    [ 0.23823937, 0.13267611, 0.15502793],</span>
<span class="gi">+    [ 0.24676041, 0.13462172, 0.15870321],</span>
<span class="gi">+    [ 0.25546457, 0.13661751, 0.16248722],</span>
<span class="gi">+    [ 0.26433628, 0.13865956, 0.16637301],</span>
<span class="gi">+    [ 0.27341345, 0.14070412, 0.17034221],</span>
<span class="gi">+    [ 0.28264773, 0.14277192, 0.1743957 ],</span>
<span class="gi">+    [ 0.29202272, 0.14486161, 0.17852793],</span>
<span class="gi">+    [ 0.30159648, 0.14691224, 0.1827169 ],</span>
<span class="gi">+    [ 0.31129002, 0.14897583, 0.18695213],</span>
<span class="gi">+    [ 0.32111555, 0.15103351, 0.19119629],</span>
<span class="gi">+    [ 0.33107961, 0.1530674 , 0.19543758],</span>
<span class="gi">+    [ 0.34119892, 0.15504762, 0.1996803 ],</span>
<span class="gi">+    [ 0.35142388, 0.15701131, 0.20389086],</span>
<span class="gi">+    [ 0.36178937, 0.1589124 , 0.20807639],</span>
<span class="gi">+    [ 0.37229381, 0.16073993, 0.21223189],</span>
<span class="gi">+    [ 0.38288348, 0.16254006, 0.2163249 ],</span>
<span class="gi">+    [ 0.39359592, 0.16426336, 0.22036577],</span>
<span class="gi">+    [ 0.40444332, 0.16588767, 0.22434027],</span>
<span class="gi">+    [ 0.41537995, 0.16745325, 0.2282297 ],</span>
<span class="gi">+    [ 0.42640867, 0.16894939, 0.23202755],</span>
<span class="gi">+    [ 0.43754706, 0.17034847, 0.23572899],</span>
<span class="gi">+    [ 0.44878564, 0.1716535 , 0.23932344],</span>
<span class="gi">+    [ 0.4601126 , 0.17287365, 0.24278607],</span>
<span class="gi">+    [ 0.47151732, 0.17401641, 0.24610337],</span>
<span class="gi">+    [ 0.48300689, 0.17506676, 0.2492737 ],</span>
<span class="gi">+    [ 0.49458302, 0.17601892, 0.25227688],</span>
<span class="gi">+    [ 0.50623876, 0.17687777, 0.255096  ],</span>
<span class="gi">+    [ 0.5179623 , 0.17765528, 0.2577162 ],</span>
<span class="gi">+    [ 0.52975234, 0.17835232, 0.2601134 ],</span>
<span class="gi">+    [ 0.54159776, 0.17898292, 0.26226847],</span>
<span class="gi">+    [ 0.55348804, 0.17956232, 0.26416003],</span>
<span class="gi">+    [ 0.56541729, 0.18010175, 0.26575971],</span>
<span class="gi">+    [ 0.57736669, 0.180631  , 0.26704888],</span>
<span class="gi">+    [ 0.58932081, 0.18117827, 0.26800409],</span>
<span class="gi">+    [ 0.60127582, 0.18175888, 0.26858488],</span>
<span class="gi">+    [ 0.61319563, 0.1824336 , 0.2687872 ],</span>
<span class="gi">+    [ 0.62506376, 0.18324015, 0.26858301],</span>
<span class="gi">+    [ 0.63681202, 0.18430173, 0.26795276],</span>
<span class="gi">+    [ 0.64842603, 0.18565472, 0.26689463],</span>
<span class="gi">+    [ 0.65988195, 0.18734638, 0.26543435],</span>
<span class="gi">+    [ 0.67111966, 0.18948885, 0.26357955],</span>
<span class="gi">+    [ 0.68209194, 0.19216636, 0.26137175],</span>
<span class="gi">+    [ 0.69281185, 0.19535326, 0.25887063],</span>
<span class="gi">+    [ 0.70335022, 0.19891271, 0.25617971],</span>
<span class="gi">+    [ 0.71375229, 0.20276438, 0.25331365],</span>
<span class="gi">+    [ 0.72401436, 0.20691287, 0.25027366],</span>
<span class="gi">+    [ 0.73407638, 0.21145051, 0.24710661],</span>
<span class="gi">+    [ 0.74396983, 0.21631913, 0.24380715],</span>
<span class="gi">+    [ 0.75361506, 0.22163653, 0.24043996],</span>
<span class="gi">+    [ 0.7630579 , 0.22731637, 0.23700095],</span>
<span class="gi">+    [ 0.77222228, 0.23346231, 0.23356628],</span>
<span class="gi">+    [ 0.78115441, 0.23998404, 0.23013825],</span>
<span class="gi">+    [ 0.78979746, 0.24694858, 0.22678822],</span>
<span class="gi">+    [ 0.79819286, 0.25427223, 0.22352658],</span>
<span class="gi">+    [ 0.80630444, 0.26198807, 0.22040877],</span>
<span class="gi">+    [ 0.81417437, 0.27001406, 0.21744645],</span>
<span class="gi">+    [ 0.82177364, 0.27837336, 0.21468316],</span>
<span class="gi">+    [ 0.82915955, 0.28696963, 0.21210766],</span>
<span class="gi">+    [ 0.83628628, 0.2958499 , 0.20977813],</span>
<span class="gi">+    [ 0.84322168, 0.30491136, 0.20766435],</span>
<span class="gi">+    [ 0.84995458, 0.31415945, 0.2057863 ],</span>
<span class="gi">+    [ 0.85648867, 0.32358058, 0.20415327],</span>
<span class="gi">+    [ 0.86286243, 0.33312058, 0.20274969],</span>
<span class="gi">+    [ 0.86908321, 0.34276705, 0.20157271],</span>
<span class="gi">+    [ 0.87512876, 0.3525416 , 0.20064949],</span>
<span class="gi">+    [ 0.88100349, 0.36243385, 0.19999078],</span>
<span class="gi">+    [ 0.8866469 , 0.37249496, 0.1997976 ],</span>
<span class="gi">+    [ 0.89203964, 0.38273475, 0.20013431],</span>
<span class="gi">+    [ 0.89713496, 0.39318156, 0.20121514],</span>
<span class="gi">+    [ 0.90195099, 0.40380687, 0.20301555],</span>
<span class="gi">+    [ 0.90648379, 0.41460191, 0.20558847],</span>
<span class="gi">+    [ 0.9106967 , 0.42557857, 0.20918529],</span>
<span class="gi">+    [ 0.91463791, 0.43668557, 0.21367954],</span>
<span class="gi">+    [ 0.91830723, 0.44790913, 0.21916352],</span>
<span class="gi">+    [ 0.92171507, 0.45922856, 0.22568002],</span>
<span class="gi">+    [ 0.92491786, 0.4705936 , 0.23308207],</span>
<span class="gi">+    [ 0.92790792, 0.48200153, 0.24145932],</span>
<span class="gi">+    [ 0.93073701, 0.49341219, 0.25065486],</span>
<span class="gi">+    [ 0.93343918, 0.5048017 , 0.26056148],</span>
<span class="gi">+    [ 0.93602064, 0.51616486, 0.27118485],</span>
<span class="gi">+    [ 0.93850535, 0.52748892, 0.28242464],</span>
<span class="gi">+    [ 0.94092933, 0.53875462, 0.29416042],</span>
<span class="gi">+    [ 0.94330011, 0.5499628 , 0.30634189],</span>
<span class="gi">+    [ 0.94563159, 0.56110987, 0.31891624],</span>
<span class="gi">+    [ 0.94792955, 0.57219822, 0.33184256],</span>
<span class="gi">+    [ 0.95020929, 0.5832232 , 0.34508419],</span>
<span class="gi">+    [ 0.95247324, 0.59419035, 0.35859866],</span>
<span class="gi">+    [ 0.95471709, 0.60510869, 0.37236035],</span>
<span class="gi">+    [ 0.95698411, 0.61595766, 0.38629631],</span>
<span class="gi">+    [ 0.95923863, 0.62676473, 0.40043317],</span>
<span class="gi">+    [ 0.9615041 , 0.6375203 , 0.41474106],</span>
<span class="gi">+    [ 0.96371553, 0.64826619, 0.42928335],</span>
<span class="gi">+    [ 0.96591497, 0.65899621, 0.44380444],</span>
<span class="gi">+    [ 0.96809871, 0.66971662, 0.45830232],</span>
<span class="gi">+    [ 0.9702495 , 0.6804394 , 0.47280492],</span>
<span class="gi">+    [ 0.9723881 , 0.69115622, 0.48729272],</span>
<span class="gi">+    [ 0.97450723, 0.70187358, 0.50178034],</span>
<span class="gi">+    [ 0.9766108 , 0.712592  , 0.51626837],</span>
<span class="gi">+    [ 0.97871716, 0.72330511, 0.53074053],</span>
<span class="gi">+    [ 0.98082222, 0.73401769, 0.54520694],</span>
<span class="gi">+    [ 0.9829001 , 0.74474445, 0.5597019 ],</span>
<span class="gi">+    [ 0.98497466, 0.75547635, 0.57420239],</span>
<span class="gi">+    [ 0.98705581, 0.76621129, 0.58870185],</span>
<span class="gi">+    [ 0.98913325, 0.77695637, 0.60321626],</span>
<span class="gi">+    [ 0.99119918, 0.78771716, 0.61775821],</span>
<span class="gi">+    [ 0.9932672 , 0.79848979, 0.63231691],</span>
<span class="gi">+    [ 0.99535958, 0.80926704, 0.64687278],</span>
<span class="gi">+    [ 0.99740544, 0.82008078, 0.66150571],</span>
<span class="gi">+    [ 0.9992197 , 0.83100723, 0.6764127 ]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_flare_lut = [</span>
<span class="gi">+    [0.92907237, 0.68878959, 0.50411509],</span>
<span class="gi">+    [0.92891402, 0.68494686, 0.50173994],</span>
<span class="gi">+    [0.92864754, 0.68116207, 0.4993754],</span>
<span class="gi">+    [0.92836112, 0.67738527, 0.49701572],</span>
<span class="gi">+    [0.9280599, 0.67361354, 0.49466044],</span>
<span class="gi">+    [0.92775569, 0.66983999, 0.49230866],</span>
<span class="gi">+    [0.9274375, 0.66607098, 0.48996097],</span>
<span class="gi">+    [0.927111, 0.66230315, 0.48761688],</span>
<span class="gi">+    [0.92677996, 0.6585342, 0.485276],</span>
<span class="gi">+    [0.92644317, 0.65476476, 0.48293832],</span>
<span class="gi">+    [0.92609759, 0.65099658, 0.48060392],</span>
<span class="gi">+    [0.925747, 0.64722729, 0.47827244],</span>
<span class="gi">+    [0.92539502, 0.64345456, 0.47594352],</span>
<span class="gi">+    [0.92503106, 0.6396848, 0.47361782],</span>
<span class="gi">+    [0.92466877, 0.6359095, 0.47129427],</span>
<span class="gi">+    [0.92429828, 0.63213463, 0.46897349],</span>
<span class="gi">+    [0.92392172, 0.62835879, 0.46665526],</span>
<span class="gi">+    [0.92354597, 0.62457749, 0.46433898],</span>
<span class="gi">+    [0.9231622, 0.6207962, 0.46202524],</span>
<span class="gi">+    [0.92277222, 0.61701365, 0.45971384],</span>
<span class="gi">+    [0.92237978, 0.61322733, 0.45740444],</span>
<span class="gi">+    [0.92198615, 0.60943622, 0.45509686],</span>
<span class="gi">+    [0.92158735, 0.60564276, 0.45279137],</span>
<span class="gi">+    [0.92118373, 0.60184659, 0.45048789],</span>
<span class="gi">+    [0.92077582, 0.59804722, 0.44818634],</span>
<span class="gi">+    [0.92036413, 0.59424414, 0.44588663],</span>
<span class="gi">+    [0.91994924, 0.5904368, 0.44358868],</span>
<span class="gi">+    [0.91952943, 0.58662619, 0.4412926],</span>
<span class="gi">+    [0.91910675, 0.58281075, 0.43899817],</span>
<span class="gi">+    [0.91868096, 0.57899046, 0.4367054],</span>
<span class="gi">+    [0.91825103, 0.57516584, 0.43441436],</span>
<span class="gi">+    [0.91781857, 0.57133556, 0.43212486],</span>
<span class="gi">+    [0.9173814, 0.56750099, 0.4298371],</span>
<span class="gi">+    [0.91694139, 0.56366058, 0.42755089],</span>
<span class="gi">+    [0.91649756, 0.55981483, 0.42526631],</span>
<span class="gi">+    [0.91604942, 0.55596387, 0.42298339],</span>
<span class="gi">+    [0.9155979, 0.55210684, 0.42070204],</span>
<span class="gi">+    [0.9151409, 0.54824485, 0.4184247],</span>
<span class="gi">+    [0.91466138, 0.54438817, 0.41617858],</span>
<span class="gi">+    [0.91416896, 0.54052962, 0.41396347],</span>
<span class="gi">+    [0.91366559, 0.53666778, 0.41177769],</span>
<span class="gi">+    [0.91315173, 0.53280208, 0.40962196],</span>
<span class="gi">+    [0.91262605, 0.52893336, 0.40749715],</span>
<span class="gi">+    [0.91208866, 0.52506133, 0.40540404],</span>
<span class="gi">+    [0.91153952, 0.52118582, 0.40334346],</span>
<span class="gi">+    [0.91097732, 0.51730767, 0.4013163],</span>
<span class="gi">+    [0.910403, 0.51342591, 0.39932342],</span>
<span class="gi">+    [0.90981494, 0.50954168, 0.39736571],</span>
<span class="gi">+    [0.90921368, 0.5056543, 0.39544411],</span>
<span class="gi">+    [0.90859797, 0.50176463, 0.39355952],</span>
<span class="gi">+    [0.90796841, 0.49787195, 0.39171297],</span>
<span class="gi">+    [0.90732341, 0.4939774, 0.38990532],</span>
<span class="gi">+    [0.90666382, 0.49008006, 0.38813773],</span>
<span class="gi">+    [0.90598815, 0.486181, 0.38641107],</span>
<span class="gi">+    [0.90529624, 0.48228017, 0.38472641],</span>
<span class="gi">+    [0.90458808, 0.47837738, 0.38308489],</span>
<span class="gi">+    [0.90386248, 0.47447348, 0.38148746],</span>
<span class="gi">+    [0.90311921, 0.4705685, 0.37993524],</span>
<span class="gi">+    [0.90235809, 0.46666239, 0.37842943],</span>
<span class="gi">+    [0.90157824, 0.46275577, 0.37697105],</span>
<span class="gi">+    [0.90077904, 0.45884905, 0.37556121],</span>
<span class="gi">+    [0.89995995, 0.45494253, 0.37420106],</span>
<span class="gi">+    [0.89912041, 0.4510366, 0.37289175],</span>
<span class="gi">+    [0.8982602, 0.44713126, 0.37163458],</span>
<span class="gi">+    [0.89737819, 0.44322747, 0.37043052],</span>
<span class="gi">+    [0.89647387, 0.43932557, 0.36928078],</span>
<span class="gi">+    [0.89554477, 0.43542759, 0.36818855],</span>
<span class="gi">+    [0.89458871, 0.4315354, 0.36715654],</span>
<span class="gi">+    [0.89360794, 0.42764714, 0.36618273],</span>
<span class="gi">+    [0.89260152, 0.42376366, 0.36526813],</span>
<span class="gi">+    [0.8915687, 0.41988565, 0.36441384],</span>
<span class="gi">+    [0.89050882, 0.41601371, 0.36362102],</span>
<span class="gi">+    [0.8894159, 0.41215334, 0.36289639],</span>
<span class="gi">+    [0.888292, 0.40830288, 0.36223756],</span>
<span class="gi">+    [0.88713784, 0.40446193, 0.36164328],</span>
<span class="gi">+    [0.88595253, 0.40063149, 0.36111438],</span>
<span class="gi">+    [0.88473115, 0.39681635, 0.3606566],</span>
<span class="gi">+    [0.88347246, 0.39301805, 0.36027074],</span>
<span class="gi">+    [0.88217931, 0.38923439, 0.35995244],</span>
<span class="gi">+    [0.880851, 0.38546632, 0.35970244],</span>
<span class="gi">+    [0.87947728, 0.38172422, 0.35953127],</span>
<span class="gi">+    [0.87806542, 0.37800172, 0.35942941],</span>
<span class="gi">+    [0.87661509, 0.37429964, 0.35939659],</span>
<span class="gi">+    [0.87511668, 0.37062819, 0.35944178],</span>
<span class="gi">+    [0.87357554, 0.36698279, 0.35955811],</span>
<span class="gi">+    [0.87199254, 0.3633634, 0.35974223],</span>
<span class="gi">+    [0.87035691, 0.35978174, 0.36000516],</span>
<span class="gi">+    [0.86867647, 0.35623087, 0.36033559],</span>
<span class="gi">+    [0.86694949, 0.35271349, 0.36073358],</span>
<span class="gi">+    [0.86516775, 0.34923921, 0.36120624],</span>
<span class="gi">+    [0.86333996, 0.34580008, 0.36174113],</span>
<span class="gi">+    [0.86145909, 0.3424046, 0.36234402],</span>
<span class="gi">+    [0.85952586, 0.33905327, 0.36301129],</span>
<span class="gi">+    [0.85754536, 0.33574168, 0.36373567],</span>
<span class="gi">+    [0.855514, 0.33247568, 0.36451271],</span>
<span class="gi">+    [0.85344392, 0.32924217, 0.36533344],</span>
<span class="gi">+    [0.8513284, 0.32604977, 0.36620106],</span>
<span class="gi">+    [0.84916723, 0.32289973, 0.36711424],</span>
<span class="gi">+    [0.84696243, 0.31979068, 0.36806976],</span>
<span class="gi">+    [0.84470627, 0.31673295, 0.36907066],</span>
<span class="gi">+    [0.84240761, 0.31371695, 0.37010969],</span>
<span class="gi">+    [0.84005337, 0.31075974, 0.37119284],</span>
<span class="gi">+    [0.83765537, 0.30784814, 0.3723105],</span>
<span class="gi">+    [0.83520234, 0.30499724, 0.37346726],</span>
<span class="gi">+    [0.83270291, 0.30219766, 0.37465552],</span>
<span class="gi">+    [0.83014895, 0.29946081, 0.37587769],</span>
<span class="gi">+    [0.82754694, 0.29677989, 0.37712733],</span>
<span class="gi">+    [0.82489111, 0.29416352, 0.37840532],</span>
<span class="gi">+    [0.82218644, 0.29160665, 0.37970606],</span>
<span class="gi">+    [0.81942908, 0.28911553, 0.38102921],</span>
<span class="gi">+    [0.81662276, 0.28668665, 0.38236999],</span>
<span class="gi">+    [0.81376555, 0.28432371, 0.383727],</span>
<span class="gi">+    [0.81085964, 0.28202508, 0.38509649],</span>
<span class="gi">+    [0.8079055, 0.27979128, 0.38647583],</span>
<span class="gi">+    [0.80490309, 0.27762348, 0.3878626],</span>
<span class="gi">+    [0.80185613, 0.2755178, 0.38925253],</span>
<span class="gi">+    [0.79876118, 0.27347974, 0.39064559],</span>
<span class="gi">+    [0.79562644, 0.27149928, 0.39203532],</span>
<span class="gi">+    [0.79244362, 0.2695883, 0.39342447],</span>
<span class="gi">+    [0.78922456, 0.26773176, 0.3948046],</span>
<span class="gi">+    [0.78596161, 0.26594053, 0.39617873],</span>
<span class="gi">+    [0.7826624, 0.26420493, 0.39754146],</span>
<span class="gi">+    [0.77932717, 0.26252522, 0.39889102],</span>
<span class="gi">+    [0.77595363, 0.2609049, 0.4002279],</span>
<span class="gi">+    [0.77254999, 0.25933319, 0.40154704],</span>
<span class="gi">+    [0.76911107, 0.25781758, 0.40284959],</span>
<span class="gi">+    [0.76564158, 0.25635173, 0.40413341],</span>
<span class="gi">+    [0.76214598, 0.25492998, 0.40539471],</span>
<span class="gi">+    [0.75861834, 0.25356035, 0.40663694],</span>
<span class="gi">+    [0.75506533, 0.25223402, 0.40785559],</span>
<span class="gi">+    [0.75148963, 0.2509473, 0.40904966],</span>
<span class="gi">+    [0.74788835, 0.24970413, 0.41022028],</span>
<span class="gi">+    [0.74426345, 0.24850191, 0.41136599],</span>
<span class="gi">+    [0.74061927, 0.24733457, 0.41248516],</span>
<span class="gi">+    [0.73695678, 0.24620072, 0.41357737],</span>
<span class="gi">+    [0.73327278, 0.24510469, 0.41464364],</span>
<span class="gi">+    [0.72957096, 0.24404127, 0.4156828],</span>
<span class="gi">+    [0.72585394, 0.24300672, 0.41669383],</span>
<span class="gi">+    [0.7221226, 0.24199971, 0.41767651],</span>
<span class="gi">+    [0.71837612, 0.24102046, 0.41863486],</span>
<span class="gi">+    [0.71463236, 0.24004289, 0.41956983],</span>
<span class="gi">+    [0.7108932, 0.23906316, 0.42048681],</span>
<span class="gi">+    [0.70715842, 0.23808142, 0.42138647],</span>
<span class="gi">+    [0.70342811, 0.2370976, 0.42226844],</span>
<span class="gi">+    [0.69970218, 0.23611179, 0.42313282],</span>
<span class="gi">+    [0.69598055, 0.2351247, 0.42397678],</span>
<span class="gi">+    [0.69226314, 0.23413578, 0.42480327],</span>
<span class="gi">+    [0.68854988, 0.23314511, 0.42561234],</span>
<span class="gi">+    [0.68484064, 0.23215279, 0.42640419],</span>
<span class="gi">+    [0.68113541, 0.23115942, 0.42717615],</span>
<span class="gi">+    [0.67743412, 0.23016472, 0.42792989],</span>
<span class="gi">+    [0.67373662, 0.22916861, 0.42866642],</span>
<span class="gi">+    [0.67004287, 0.22817117, 0.42938576],</span>
<span class="gi">+    [0.66635279, 0.22717328, 0.43008427],</span>
<span class="gi">+    [0.66266621, 0.22617435, 0.43076552],</span>
<span class="gi">+    [0.65898313, 0.22517434, 0.43142956],</span>
<span class="gi">+    [0.65530349, 0.22417381, 0.43207427],</span>
<span class="gi">+    [0.65162696, 0.22317307, 0.4327001],</span>
<span class="gi">+    [0.64795375, 0.22217149, 0.43330852],</span>
<span class="gi">+    [0.64428351, 0.22116972, 0.43389854],</span>
<span class="gi">+    [0.64061624, 0.22016818, 0.43446845],</span>
<span class="gi">+    [0.63695183, 0.21916625, 0.43502123],</span>
<span class="gi">+    [0.63329016, 0.21816454, 0.43555493],</span>
<span class="gi">+    [0.62963102, 0.2171635, 0.43606881],</span>
<span class="gi">+    [0.62597451, 0.21616235, 0.43656529],</span>
<span class="gi">+    [0.62232019, 0.21516239, 0.43704153],</span>
<span class="gi">+    [0.61866821, 0.21416307, 0.43749868],</span>
<span class="gi">+    [0.61501835, 0.21316435, 0.43793808],</span>
<span class="gi">+    [0.61137029, 0.21216761, 0.4383556],</span>
<span class="gi">+    [0.60772426, 0.2111715, 0.43875552],</span>
<span class="gi">+    [0.60407977, 0.21017746, 0.43913439],</span>
<span class="gi">+    [0.60043678, 0.20918503, 0.43949412],</span>
<span class="gi">+    [0.59679524, 0.20819447, 0.43983393],</span>
<span class="gi">+    [0.59315487, 0.20720639, 0.44015254],</span>
<span class="gi">+    [0.58951566, 0.20622027, 0.44045213],</span>
<span class="gi">+    [0.58587715, 0.20523751, 0.44072926],</span>
<span class="gi">+    [0.5822395, 0.20425693, 0.44098758],</span>
<span class="gi">+    [0.57860222, 0.20328034, 0.44122241],</span>
<span class="gi">+    [0.57496549, 0.20230637, 0.44143805],</span>
<span class="gi">+    [0.57132875, 0.20133689, 0.4416298],</span>
<span class="gi">+    [0.56769215, 0.20037071, 0.44180142],</span>
<span class="gi">+    [0.5640552, 0.19940936, 0.44194923],</span>
<span class="gi">+    [0.56041794, 0.19845221, 0.44207535],</span>
<span class="gi">+    [0.55678004, 0.1975, 0.44217824],</span>
<span class="gi">+    [0.55314129, 0.19655316, 0.44225723],</span>
<span class="gi">+    [0.54950166, 0.19561118, 0.44231412],</span>
<span class="gi">+    [0.54585987, 0.19467771, 0.44234111],</span>
<span class="gi">+    [0.54221157, 0.19375869, 0.44233698],</span>
<span class="gi">+    [0.5385549, 0.19285696, 0.44229959],</span>
<span class="gi">+    [0.5348913, 0.19197036, 0.44222958],</span>
<span class="gi">+    [0.53122177, 0.1910974, 0.44212735],</span>
<span class="gi">+    [0.52754464, 0.19024042, 0.44199159],</span>
<span class="gi">+    [0.52386353, 0.18939409, 0.44182449],</span>
<span class="gi">+    [0.52017476, 0.18856368, 0.44162345],</span>
<span class="gi">+    [0.51648277, 0.18774266, 0.44139128],</span>
<span class="gi">+    [0.51278481, 0.18693492, 0.44112605],</span>
<span class="gi">+    [0.50908361, 0.18613639, 0.4408295],</span>
<span class="gi">+    [0.50537784, 0.18534893, 0.44050064],</span>
<span class="gi">+    [0.50166912, 0.18457008, 0.44014054],</span>
<span class="gi">+    [0.49795686, 0.18380056, 0.43974881],</span>
<span class="gi">+    [0.49424218, 0.18303865, 0.43932623],</span>
<span class="gi">+    [0.49052472, 0.18228477, 0.43887255],</span>
<span class="gi">+    [0.48680565, 0.1815371, 0.43838867],</span>
<span class="gi">+    [0.48308419, 0.18079663, 0.43787408],</span>
<span class="gi">+    [0.47936222, 0.18006056, 0.43733022],</span>
<span class="gi">+    [0.47563799, 0.17933127, 0.43675585],</span>
<span class="gi">+    [0.47191466, 0.17860416, 0.43615337],</span>
<span class="gi">+    [0.46818879, 0.17788392, 0.43552047],</span>
<span class="gi">+    [0.46446454, 0.17716458, 0.43486036],</span>
<span class="gi">+    [0.46073893, 0.17645017, 0.43417097],</span>
<span class="gi">+    [0.45701462, 0.17573691, 0.43345429],</span>
<span class="gi">+    [0.45329097, 0.17502549, 0.43271025],</span>
<span class="gi">+    [0.44956744, 0.17431649, 0.4319386],</span>
<span class="gi">+    [0.44584668, 0.17360625, 0.43114133],</span>
<span class="gi">+    [0.44212538, 0.17289906, 0.43031642],</span>
<span class="gi">+    [0.43840678, 0.17219041, 0.42946642],</span>
<span class="gi">+    [0.43469046, 0.17148074, 0.42859124],</span>
<span class="gi">+    [0.4309749, 0.17077192, 0.42769008],</span>
<span class="gi">+    [0.42726297, 0.17006003, 0.42676519],</span>
<span class="gi">+    [0.42355299, 0.16934709, 0.42581586],</span>
<span class="gi">+    [0.41984535, 0.16863258, 0.42484219],</span>
<span class="gi">+    [0.41614149, 0.16791429, 0.42384614],</span>
<span class="gi">+    [0.41244029, 0.16719372, 0.42282661],</span>
<span class="gi">+    [0.40874177, 0.16647061, 0.42178429],</span>
<span class="gi">+    [0.40504765, 0.16574261, 0.42072062],</span>
<span class="gi">+    [0.401357, 0.16501079, 0.41963528],</span>
<span class="gi">+    [0.397669, 0.16427607, 0.418528],</span>
<span class="gi">+    [0.39398585, 0.16353554, 0.41740053],</span>
<span class="gi">+    [0.39030735, 0.16278924, 0.41625344],</span>
<span class="gi">+    [0.3866314, 0.16203977, 0.41508517],</span>
<span class="gi">+    [0.38295904, 0.16128519, 0.41389849],</span>
<span class="gi">+    [0.37928736, 0.16052483, 0.41270599],</span>
<span class="gi">+    [0.37562649, 0.15974704, 0.41151182],</span>
<span class="gi">+    [0.37197803, 0.15895049, 0.41031532],</span>
<span class="gi">+    [0.36833779, 0.15813871, 0.40911916],</span>
<span class="gi">+    [0.36470944, 0.15730861, 0.40792149],</span>
<span class="gi">+    [0.36109117, 0.15646169, 0.40672362],</span>
<span class="gi">+    [0.35748213, 0.15559861, 0.40552633],</span>
<span class="gi">+    [0.353885, 0.15471714, 0.40432831],</span>
<span class="gi">+    [0.35029682, 0.15381967, 0.4031316],</span>
<span class="gi">+    [0.34671861, 0.1529053, 0.40193587],</span>
<span class="gi">+    [0.34315191, 0.15197275, 0.40074049],</span>
<span class="gi">+    [0.33959331, 0.15102466, 0.3995478],</span>
<span class="gi">+    [0.33604378, 0.15006017, 0.39835754],</span>
<span class="gi">+    [0.33250529, 0.14907766, 0.39716879],</span>
<span class="gi">+    [0.32897621, 0.14807831, 0.39598285],</span>
<span class="gi">+    [0.3254559, 0.14706248, 0.39480044],</span>
<span class="gi">+    [0.32194567, 0.14602909, 0.39362106],</span>
<span class="gi">+    [0.31844477, 0.14497857, 0.39244549],</span>
<span class="gi">+    [0.31494974, 0.14391333, 0.39127626],</span>
<span class="gi">+    [0.31146605, 0.14282918, 0.39011024],</span>
<span class="gi">+    [0.30798857, 0.1417297, 0.38895105],</span>
<span class="gi">+    [0.30451661, 0.14061515, 0.38779953],</span>
<span class="gi">+    [0.30105136, 0.13948445, 0.38665531],</span>
<span class="gi">+    [0.2975886, 0.1383403, 0.38552159],</span>
<span class="gi">+    [0.29408557, 0.13721193, 0.38442775]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_crest_lut = [</span>
<span class="gi">+    [0.6468274, 0.80289262, 0.56592265],</span>
<span class="gi">+    [0.64233318, 0.80081141, 0.56639461],</span>
<span class="gi">+    [0.63791969, 0.7987162, 0.56674976],</span>
<span class="gi">+    [0.6335316, 0.79661833, 0.56706128],</span>
<span class="gi">+    [0.62915226, 0.7945212, 0.56735066],</span>
<span class="gi">+    [0.62477862, 0.79242543, 0.56762143],</span>
<span class="gi">+    [0.62042003, 0.79032918, 0.56786129],</span>
<span class="gi">+    [0.61606327, 0.78823508, 0.56808666],</span>
<span class="gi">+    [0.61171322, 0.78614216, 0.56829092],</span>
<span class="gi">+    [0.60736933, 0.78405055, 0.56847436],</span>
<span class="gi">+    [0.60302658, 0.78196121, 0.56864272],</span>
<span class="gi">+    [0.59868708, 0.77987374, 0.56879289],</span>
<span class="gi">+    [0.59435366, 0.77778758, 0.56892099],</span>
<span class="gi">+    [0.59001953, 0.77570403, 0.56903477],</span>
<span class="gi">+    [0.58568753, 0.77362254, 0.56913028],</span>
<span class="gi">+    [0.58135593, 0.77154342, 0.56920908],</span>
<span class="gi">+    [0.57702623, 0.76946638, 0.56926895],</span>
<span class="gi">+    [0.57269165, 0.76739266, 0.5693172],</span>
<span class="gi">+    [0.56835934, 0.76532092, 0.56934507],</span>
<span class="gi">+    [0.56402533, 0.76325185, 0.56935664],</span>
<span class="gi">+    [0.55968429, 0.76118643, 0.56935732],</span>
<span class="gi">+    [0.55534159, 0.75912361, 0.56934052],</span>
<span class="gi">+    [0.55099572, 0.75706366, 0.56930743],</span>
<span class="gi">+    [0.54664626, 0.75500662, 0.56925799],</span>
<span class="gi">+    [0.54228969, 0.75295306, 0.56919546],</span>
<span class="gi">+    [0.53792417, 0.75090328, 0.56912118],</span>
<span class="gi">+    [0.53355172, 0.74885687, 0.5690324],</span>
<span class="gi">+    [0.52917169, 0.74681387, 0.56892926],</span>
<span class="gi">+    [0.52478243, 0.74477453, 0.56881287],</span>
<span class="gi">+    [0.52038338, 0.74273888, 0.56868323],</span>
<span class="gi">+    [0.5159739, 0.74070697, 0.56854039],</span>
<span class="gi">+    [0.51155269, 0.73867895, 0.56838507],</span>
<span class="gi">+    [0.50711872, 0.73665492, 0.56821764],</span>
<span class="gi">+    [0.50267118, 0.73463494, 0.56803826],</span>
<span class="gi">+    [0.49822926, 0.73261388, 0.56785146],</span>
<span class="gi">+    [0.49381422, 0.73058524, 0.56767484],</span>
<span class="gi">+    [0.48942421, 0.72854938, 0.56751036],</span>
<span class="gi">+    [0.48505993, 0.72650623, 0.56735752],</span>
<span class="gi">+    [0.48072207, 0.72445575, 0.56721583],</span>
<span class="gi">+    [0.4764113, 0.72239788, 0.56708475],</span>
<span class="gi">+    [0.47212827, 0.72033258, 0.56696376],</span>
<span class="gi">+    [0.46787361, 0.71825983, 0.56685231],</span>
<span class="gi">+    [0.46364792, 0.71617961, 0.56674986],</span>
<span class="gi">+    [0.45945271, 0.71409167, 0.56665625],</span>
<span class="gi">+    [0.45528878, 0.71199595, 0.56657103],</span>
<span class="gi">+    [0.45115557, 0.70989276, 0.5664931],</span>
<span class="gi">+    [0.44705356, 0.70778212, 0.56642189],</span>
<span class="gi">+    [0.44298321, 0.70566406, 0.56635683],</span>
<span class="gi">+    [0.43894492, 0.70353863, 0.56629734],</span>
<span class="gi">+    [0.43493911, 0.70140588, 0.56624286],</span>
<span class="gi">+    [0.43096612, 0.69926587, 0.5661928],</span>
<span class="gi">+    [0.42702625, 0.69711868, 0.56614659],</span>
<span class="gi">+    [0.42311977, 0.69496438, 0.56610368],</span>
<span class="gi">+    [0.41924689, 0.69280308, 0.56606355],</span>
<span class="gi">+    [0.41540778, 0.69063486, 0.56602564],</span>
<span class="gi">+    [0.41160259, 0.68845984, 0.56598944],</span>
<span class="gi">+    [0.40783143, 0.68627814, 0.56595436],</span>
<span class="gi">+    [0.40409434, 0.68408988, 0.56591994],</span>
<span class="gi">+    [0.40039134, 0.68189518, 0.56588564],</span>
<span class="gi">+    [0.39672238, 0.6796942, 0.56585103],</span>
<span class="gi">+    [0.39308781, 0.67748696, 0.56581581],</span>
<span class="gi">+    [0.38949137, 0.67527276, 0.56578084],</span>
<span class="gi">+    [0.38592889, 0.67305266, 0.56574422],</span>
<span class="gi">+    [0.38240013, 0.67082685, 0.56570561],</span>
<span class="gi">+    [0.37890483, 0.66859548, 0.56566462],</span>
<span class="gi">+    [0.37544276, 0.66635871, 0.56562081],</span>
<span class="gi">+    [0.37201365, 0.66411673, 0.56557372],</span>
<span class="gi">+    [0.36861709, 0.6618697, 0.5655231],</span>
<span class="gi">+    [0.36525264, 0.65961782, 0.56546873],</span>
<span class="gi">+    [0.36191986, 0.65736125, 0.56541032],</span>
<span class="gi">+    [0.35861935, 0.65509998, 0.56534768],</span>
<span class="gi">+    [0.35535621, 0.65283302, 0.56528211],</span>
<span class="gi">+    [0.35212361, 0.65056188, 0.56521171],</span>
<span class="gi">+    [0.34892097, 0.64828676, 0.56513633],</span>
<span class="gi">+    [0.34574785, 0.64600783, 0.56505539],</span>
<span class="gi">+    [0.34260357, 0.64372528, 0.5649689],</span>
<span class="gi">+    [0.33948744, 0.64143931, 0.56487679],</span>
<span class="gi">+    [0.33639887, 0.6391501, 0.56477869],</span>
<span class="gi">+    [0.33334501, 0.63685626, 0.56467661],</span>
<span class="gi">+    [0.33031952, 0.63455911, 0.564569],</span>
<span class="gi">+    [0.3273199, 0.63225924, 0.56445488],</span>
<span class="gi">+    [0.32434526, 0.62995682, 0.56433457],</span>
<span class="gi">+    [0.32139487, 0.62765201, 0.56420795],</span>
<span class="gi">+    [0.31846807, 0.62534504, 0.56407446],</span>
<span class="gi">+    [0.3155731, 0.62303426, 0.56393695],</span>
<span class="gi">+    [0.31270304, 0.62072111, 0.56379321],</span>
<span class="gi">+    [0.30985436, 0.61840624, 0.56364307],</span>
<span class="gi">+    [0.30702635, 0.61608984, 0.56348606],</span>
<span class="gi">+    [0.30421803, 0.61377205, 0.56332267],</span>
<span class="gi">+    [0.30143611, 0.61145167, 0.56315419],</span>
<span class="gi">+    [0.29867863, 0.60912907, 0.56298054],</span>
<span class="gi">+    [0.29593872, 0.60680554, 0.56280022],</span>
<span class="gi">+    [0.29321538, 0.60448121, 0.56261376],</span>
<span class="gi">+    [0.2905079, 0.60215628, 0.56242036],</span>
<span class="gi">+    [0.28782827, 0.5998285, 0.56222366],</span>
<span class="gi">+    [0.28516521, 0.59749996, 0.56202093],</span>
<span class="gi">+    [0.28251558, 0.59517119, 0.56181204],</span>
<span class="gi">+    [0.27987847, 0.59284232, 0.56159709],</span>
<span class="gi">+    [0.27726216, 0.59051189, 0.56137785],</span>
<span class="gi">+    [0.27466434, 0.58818027, 0.56115433],</span>
<span class="gi">+    [0.2720767, 0.58584893, 0.56092486],</span>
<span class="gi">+    [0.26949829, 0.58351797, 0.56068983],</span>
<span class="gi">+    [0.26693801, 0.58118582, 0.56045121],</span>
<span class="gi">+    [0.26439366, 0.57885288, 0.56020858],</span>
<span class="gi">+    [0.26185616, 0.57652063, 0.55996077],</span>
<span class="gi">+    [0.25932459, 0.57418919, 0.55970795],</span>
<span class="gi">+    [0.25681303, 0.57185614, 0.55945297],</span>
<span class="gi">+    [0.25431024, 0.56952337, 0.55919385],</span>
<span class="gi">+    [0.25180492, 0.56719255, 0.5589305],</span>
<span class="gi">+    [0.24929311, 0.56486397, 0.5586654],</span>
<span class="gi">+    [0.24678356, 0.56253666, 0.55839491],</span>
<span class="gi">+    [0.24426587, 0.56021153, 0.55812473],</span>
<span class="gi">+    [0.24174022, 0.55788852, 0.55785448],</span>
<span class="gi">+    [0.23921167, 0.55556705, 0.55758211],</span>
<span class="gi">+    [0.23668315, 0.55324675, 0.55730676],</span>
<span class="gi">+    [0.23414742, 0.55092825, 0.55703167],</span>
<span class="gi">+    [0.23160473, 0.54861143, 0.5567573],</span>
<span class="gi">+    [0.22905996, 0.54629572, 0.55648168],</span>
<span class="gi">+    [0.22651648, 0.54398082, 0.5562029],</span>
<span class="gi">+    [0.22396709, 0.54166721, 0.55592542],</span>
<span class="gi">+    [0.22141221, 0.53935481, 0.55564885],</span>
<span class="gi">+    [0.21885269, 0.53704347, 0.55537294],</span>
<span class="gi">+    [0.21629986, 0.53473208, 0.55509319],</span>
<span class="gi">+    [0.21374297, 0.53242154, 0.5548144],</span>
<span class="gi">+    [0.21118255, 0.53011166, 0.55453708],</span>
<span class="gi">+    [0.2086192, 0.52780237, 0.55426067],</span>
<span class="gi">+    [0.20605624, 0.52549322, 0.55398479],</span>
<span class="gi">+    [0.20350004, 0.5231837, 0.55370601],</span>
<span class="gi">+    [0.20094292, 0.52087429, 0.55342884],</span>
<span class="gi">+    [0.19838567, 0.51856489, 0.55315283],</span>
<span class="gi">+    [0.19582911, 0.51625531, 0.55287818],</span>
<span class="gi">+    [0.19327413, 0.51394542, 0.55260469],</span>
<span class="gi">+    [0.19072933, 0.51163448, 0.5523289],</span>
<span class="gi">+    [0.18819045, 0.50932268, 0.55205372],</span>
<span class="gi">+    [0.18565609, 0.50701014, 0.55177937],</span>
<span class="gi">+    [0.18312739, 0.50469666, 0.55150597],</span>
<span class="gi">+    [0.18060561, 0.50238204, 0.55123374],</span>
<span class="gi">+    [0.178092, 0.50006616, 0.55096224],</span>
<span class="gi">+    [0.17558808, 0.49774882, 0.55069118],</span>
<span class="gi">+    [0.17310341, 0.49542924, 0.5504176],</span>
<span class="gi">+    [0.17063111, 0.49310789, 0.55014445],</span>
<span class="gi">+    [0.1681728, 0.49078458, 0.54987159],</span>
<span class="gi">+    [0.1657302, 0.48845913, 0.54959882],</span>
<span class="gi">+    [0.16330517, 0.48613135, 0.54932605],</span>
<span class="gi">+    [0.16089963, 0.48380104, 0.54905306],</span>
<span class="gi">+    [0.15851561, 0.48146803, 0.54877953],</span>
<span class="gi">+    [0.15615526, 0.47913212, 0.54850526],</span>
<span class="gi">+    [0.15382083, 0.47679313, 0.54822991],</span>
<span class="gi">+    [0.15151471, 0.47445087, 0.54795318],</span>
<span class="gi">+    [0.14924112, 0.47210502, 0.54767411],</span>
<span class="gi">+    [0.1470032, 0.46975537, 0.54739226],</span>
<span class="gi">+    [0.14480101, 0.46740187, 0.54710832],</span>
<span class="gi">+    [0.14263736, 0.46504434, 0.54682188],</span>
<span class="gi">+    [0.14051521, 0.46268258, 0.54653253],</span>
<span class="gi">+    [0.13843761, 0.46031639, 0.54623985],</span>
<span class="gi">+    [0.13640774, 0.45794558, 0.5459434],</span>
<span class="gi">+    [0.13442887, 0.45556994, 0.54564272],</span>
<span class="gi">+    [0.1325044, 0.45318928, 0.54533736],</span>
<span class="gi">+    [0.13063777, 0.4508034, 0.54502674],</span>
<span class="gi">+    [0.12883252, 0.44841211, 0.5447104],</span>
<span class="gi">+    [0.12709242, 0.44601517, 0.54438795],</span>
<span class="gi">+    [0.1254209, 0.44361244, 0.54405855],</span>
<span class="gi">+    [0.12382162, 0.44120373, 0.54372156],</span>
<span class="gi">+    [0.12229818, 0.43878887, 0.54337634],</span>
<span class="gi">+    [0.12085453, 0.4363676, 0.54302253],</span>
<span class="gi">+    [0.11949938, 0.43393955, 0.54265715],</span>
<span class="gi">+    [0.11823166, 0.43150478, 0.54228104],</span>
<span class="gi">+    [0.11705496, 0.42906306, 0.54189388],</span>
<span class="gi">+    [0.115972, 0.42661431, 0.54149449],</span>
<span class="gi">+    [0.11498598, 0.42415835, 0.54108222],</span>
<span class="gi">+    [0.11409965, 0.42169502, 0.54065622],</span>
<span class="gi">+    [0.11331533, 0.41922424, 0.5402155],</span>
<span class="gi">+    [0.11263542, 0.41674582, 0.53975931],</span>
<span class="gi">+    [0.1120615, 0.4142597, 0.53928656],</span>
<span class="gi">+    [0.11159738, 0.41176567, 0.53879549],</span>
<span class="gi">+    [0.11125248, 0.40926325, 0.53828203],</span>
<span class="gi">+    [0.11101698, 0.40675289, 0.53774864],</span>
<span class="gi">+    [0.11089152, 0.40423445, 0.53719455],</span>
<span class="gi">+    [0.11085121, 0.4017095, 0.53662425],</span>
<span class="gi">+    [0.11087217, 0.39917938, 0.53604354],</span>
<span class="gi">+    [0.11095515, 0.39664394, 0.53545166],</span>
<span class="gi">+    [0.11110676, 0.39410282, 0.53484509],</span>
<span class="gi">+    [0.11131735, 0.39155635, 0.53422678],</span>
<span class="gi">+    [0.11158595, 0.38900446, 0.53359634],</span>
<span class="gi">+    [0.11191139, 0.38644711, 0.5329534],</span>
<span class="gi">+    [0.11229224, 0.38388426, 0.53229748],</span>
<span class="gi">+    [0.11273683, 0.38131546, 0.53162393],</span>
<span class="gi">+    [0.11323438, 0.37874109, 0.53093619],</span>
<span class="gi">+    [0.11378271, 0.37616112, 0.53023413],</span>
<span class="gi">+    [0.11437992, 0.37357557, 0.52951727],</span>
<span class="gi">+    [0.11502681, 0.37098429, 0.52878396],</span>
<span class="gi">+    [0.11572661, 0.36838709, 0.52803124],</span>
<span class="gi">+    [0.11646936, 0.36578429, 0.52726234],</span>
<span class="gi">+    [0.11725299, 0.3631759, 0.52647685],</span>
<span class="gi">+    [0.1180755, 0.36056193, 0.52567436],</span>
<span class="gi">+    [0.1189438, 0.35794203, 0.5248497],</span>
<span class="gi">+    [0.11984752, 0.35531657, 0.52400649],</span>
<span class="gi">+    [0.1207833, 0.35268564, 0.52314492],</span>
<span class="gi">+    [0.12174895, 0.35004927, 0.52226461],</span>
<span class="gi">+    [0.12274959, 0.34740723, 0.52136104],</span>
<span class="gi">+    [0.12377809, 0.34475975, 0.52043639],</span>
<span class="gi">+    [0.12482961, 0.34210702, 0.51949179],</span>
<span class="gi">+    [0.125902, 0.33944908, 0.51852688],</span>
<span class="gi">+    [0.12699998, 0.33678574, 0.51753708],</span>
<span class="gi">+    [0.12811691, 0.33411727, 0.51652464],</span>
<span class="gi">+    [0.12924811, 0.33144384, 0.51549084],</span>
<span class="gi">+    [0.13039157, 0.32876552, 0.51443538],</span>
<span class="gi">+    [0.13155228, 0.32608217, 0.51335321],</span>
<span class="gi">+    [0.13272282, 0.32339407, 0.51224759],</span>
<span class="gi">+    [0.13389954, 0.32070138, 0.51111946],</span>
<span class="gi">+    [0.13508064, 0.31800419, 0.50996862],</span>
<span class="gi">+    [0.13627149, 0.31530238, 0.50878942],</span>
<span class="gi">+    [0.13746376, 0.31259627, 0.50758645],</span>
<span class="gi">+    [0.13865499, 0.30988598, 0.50636017],</span>
<span class="gi">+    [0.13984364, 0.30717161, 0.50511042],</span>
<span class="gi">+    [0.14103515, 0.30445309, 0.50383119],</span>
<span class="gi">+    [0.14222093, 0.30173071, 0.50252813],</span>
<span class="gi">+    [0.14339946, 0.2990046, 0.50120127],</span>
<span class="gi">+    [0.14456941, 0.29627483, 0.49985054],</span>
<span class="gi">+    [0.14573579, 0.29354139, 0.49847009],</span>
<span class="gi">+    [0.14689091, 0.29080452, 0.49706566],</span>
<span class="gi">+    [0.1480336, 0.28806432, 0.49563732],</span>
<span class="gi">+    [0.1491628, 0.28532086, 0.49418508],</span>
<span class="gi">+    [0.15028228, 0.28257418, 0.49270402],</span>
<span class="gi">+    [0.15138673, 0.27982444, 0.49119848],</span>
<span class="gi">+    [0.15247457, 0.27707172, 0.48966925],</span>
<span class="gi">+    [0.15354487, 0.2743161, 0.48811641],</span>
<span class="gi">+    [0.15459955, 0.27155765, 0.4865371],</span>
<span class="gi">+    [0.15563716, 0.26879642, 0.4849321],</span>
<span class="gi">+    [0.1566572, 0.26603191, 0.48330429],</span>
<span class="gi">+    [0.15765823, 0.26326032, 0.48167456],</span>
<span class="gi">+    [0.15862147, 0.26048295, 0.48005785],</span>
<span class="gi">+    [0.15954301, 0.25770084, 0.47845341],</span>
<span class="gi">+    [0.16043267, 0.25491144, 0.4768626],</span>
<span class="gi">+    [0.16129262, 0.25211406, 0.4752857],</span>
<span class="gi">+    [0.1621119, 0.24931169, 0.47372076],</span>
<span class="gi">+    [0.16290577, 0.24649998, 0.47217025],</span>
<span class="gi">+    [0.16366819, 0.24368054, 0.47063302],</span>
<span class="gi">+    [0.1644021, 0.24085237, 0.46910949],</span>
<span class="gi">+    [0.16510882, 0.2380149, 0.46759982],</span>
<span class="gi">+    [0.16579015, 0.23516739, 0.46610429],</span>
<span class="gi">+    [0.1664433, 0.2323105, 0.46462219],</span>
<span class="gi">+    [0.16707586, 0.22944155, 0.46315508],</span>
<span class="gi">+    [0.16768475, 0.22656122, 0.46170223],</span>
<span class="gi">+    [0.16826815, 0.22366984, 0.46026308],</span>
<span class="gi">+    [0.16883174, 0.22076514, 0.45883891],</span>
<span class="gi">+    [0.16937589, 0.21784655, 0.45742976],</span>
<span class="gi">+    [0.16990129, 0.21491339, 0.45603578],</span>
<span class="gi">+    [0.1704074, 0.21196535, 0.45465677],</span>
<span class="gi">+    [0.17089473, 0.20900176, 0.4532928],</span>
<span class="gi">+    [0.17136819, 0.20602012, 0.45194524],</span>
<span class="gi">+    [0.17182683, 0.20302012, 0.45061386],</span>
<span class="gi">+    [0.17227059, 0.20000106, 0.44929865],</span>
<span class="gi">+    [0.17270583, 0.19695949, 0.44800165],</span>
<span class="gi">+    [0.17313804, 0.19389201, 0.44672488],</span>
<span class="gi">+    [0.17363177, 0.19076859, 0.44549087]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_lut_dict = dict(</span>
<span class="gi">+    rocket=_rocket_lut,</span>
<span class="gi">+    mako=_mako_lut,</span>
<span class="gi">+    icefire=_icefire_lut,</span>
<span class="gi">+    vlag=_vlag_lut,</span>
<span class="gi">+    flare=_flare_lut,</span>
<span class="gi">+    crest=_crest_lut,</span>
<span class="gi">+</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>for _name, _lut in _lut_dict.items():
<span class="gi">+</span>
<span class="w"> </span>    _cmap = colors.ListedColormap(_lut, _name)
<span class="w"> </span>    locals()[_name] = _cmap
<span class="gd">-    _cmap_r = colors.ListedColormap(_lut[::-1], _name + &#39;_r&#39;)</span>
<span class="gd">-    locals()[_name + &#39;_r&#39;] = _cmap_r</span>
<span class="gi">+</span>
<span class="gi">+    _cmap_r = colors.ListedColormap(_lut[::-1], _name + &quot;_r&quot;)</span>
<span class="gi">+    locals()[_name + &quot;_r&quot;] = _cmap_r</span>
<span class="gi">+</span>
<span class="w"> </span>    register_colormap(_name, _cmap)
<span class="gd">-    register_colormap(_name + &#39;_r&#39;, _cmap_r)</span>
<span class="gi">+    register_colormap(_name + &quot;_r&quot;, _cmap_r)</span>
<span class="gi">+</span>
<span class="w"> </span>del colors, register_colormap
<span class="gh">diff --git a/seaborn/colors/crayons.py b/seaborn/colors/crayons.py</span>
<span class="gh">index b6a4ae39..548af1f1 100644</span>
<span class="gd">--- a/seaborn/colors/crayons.py</span>
<span class="gi">+++ b/seaborn/colors/crayons.py</span>
<span class="gu">@@ -1,46 +1,120 @@</span>
<span class="gd">-crayons = {&#39;Almond&#39;: &#39;#EFDECD&#39;, &#39;Antique Brass&#39;: &#39;#CD9575&#39;, &#39;Apricot&#39;:</span>
<span class="gd">-    &#39;#FDD9B5&#39;, &#39;Aquamarine&#39;: &#39;#78DBE2&#39;, &#39;Asparagus&#39;: &#39;#87A96B&#39;,</span>
<span class="gd">-    &#39;Atomic Tangerine&#39;: &#39;#FFA474&#39;, &#39;Banana Mania&#39;: &#39;#FAE7B5&#39;, &#39;Beaver&#39;:</span>
<span class="gd">-    &#39;#9F8170&#39;, &#39;Bittersweet&#39;: &#39;#FD7C6E&#39;, &#39;Black&#39;: &#39;#000000&#39;, &#39;Blue&#39;:</span>
<span class="gd">-    &#39;#1F75FE&#39;, &#39;Blue Bell&#39;: &#39;#A2A2D0&#39;, &#39;Blue Green&#39;: &#39;#0D98BA&#39;,</span>
<span class="gd">-    &#39;Blue Violet&#39;: &#39;#7366BD&#39;, &#39;Blush&#39;: &#39;#DE5D83&#39;, &#39;Brick Red&#39;: &#39;#CB4154&#39;,</span>
<span class="gd">-    &#39;Brown&#39;: &#39;#B4674D&#39;, &#39;Burnt Orange&#39;: &#39;#FF7F49&#39;, &#39;Burnt Sienna&#39;:</span>
<span class="gd">-    &#39;#EA7E5D&#39;, &#39;Cadet Blue&#39;: &#39;#B0B7C6&#39;, &#39;Canary&#39;: &#39;#FFFF99&#39;,</span>
<span class="gd">-    &#39;Caribbean Green&#39;: &#39;#00CC99&#39;, &#39;Carnation Pink&#39;: &#39;#FFAACC&#39;, &#39;Cerise&#39;:</span>
<span class="gd">-    &#39;#DD4492&#39;, &#39;Cerulean&#39;: &#39;#1DACD6&#39;, &#39;Chestnut&#39;: &#39;#BC5D58&#39;, &#39;Copper&#39;:</span>
<span class="gd">-    &#39;#DD9475&#39;, &#39;Cornflower&#39;: &#39;#9ACEEB&#39;, &#39;Cotton Candy&#39;: &#39;#FFBCD9&#39;,</span>
<span class="gd">-    &#39;Dandelion&#39;: &#39;#FDDB6D&#39;, &#39;Denim&#39;: &#39;#2B6CC4&#39;, &#39;Desert Sand&#39;: &#39;#EFCDB8&#39;,</span>
<span class="gd">-    &#39;Eggplant&#39;: &#39;#6E5160&#39;, &#39;Electric Lime&#39;: &#39;#CEFF1D&#39;, &#39;Fern&#39;: &#39;#71BC78&#39;,</span>
<span class="gd">-    &#39;Forest Green&#39;: &#39;#6DAE81&#39;, &#39;Fuchsia&#39;: &#39;#C364C5&#39;, &#39;Fuzzy Wuzzy&#39;:</span>
<span class="gd">-    &#39;#CC6666&#39;, &#39;Gold&#39;: &#39;#E7C697&#39;, &#39;Goldenrod&#39;: &#39;#FCD975&#39;,</span>
<span class="gd">-    &#39;Granny Smith Apple&#39;: &#39;#A8E4A0&#39;, &#39;Gray&#39;: &#39;#95918C&#39;, &#39;Green&#39;: &#39;#1CAC78&#39;,</span>
<span class="gd">-    &#39;Green Yellow&#39;: &#39;#F0E891&#39;, &#39;Hot Magenta&#39;: &#39;#FF1DCE&#39;, &#39;Inchworm&#39;:</span>
<span class="gd">-    &#39;#B2EC5D&#39;, &#39;Indigo&#39;: &#39;#5D76CB&#39;, &#39;Jazzberry Jam&#39;: &#39;#CA3767&#39;,</span>
<span class="gd">-    &#39;Jungle Green&#39;: &#39;#3BB08F&#39;, &#39;Laser Lemon&#39;: &#39;#FEFE22&#39;, &#39;Lavender&#39;:</span>
<span class="gd">-    &#39;#FCB4D5&#39;, &#39;Macaroni and Cheese&#39;: &#39;#FFBD88&#39;, &#39;Magenta&#39;: &#39;#F664AF&#39;,</span>
<span class="gd">-    &#39;Mahogany&#39;: &#39;#CD4A4C&#39;, &#39;Manatee&#39;: &#39;#979AAA&#39;, &#39;Mango Tango&#39;: &#39;#FF8243&#39;,</span>
<span class="gd">-    &#39;Maroon&#39;: &#39;#C8385A&#39;, &#39;Mauvelous&#39;: &#39;#EF98AA&#39;, &#39;Melon&#39;: &#39;#FDBCB4&#39;,</span>
<span class="gd">-    &#39;Midnight Blue&#39;: &#39;#1A4876&#39;, &#39;Mountain Meadow&#39;: &#39;#30BA8F&#39;, &#39;Navy Blue&#39;:</span>
<span class="gd">-    &#39;#1974D2&#39;, &#39;Neon Carrot&#39;: &#39;#FFA343&#39;, &#39;Olive Green&#39;: &#39;#BAB86C&#39;, &#39;Orange&#39;:</span>
<span class="gd">-    &#39;#FF7538&#39;, &#39;Orchid&#39;: &#39;#E6A8D7&#39;, &#39;Outer Space&#39;: &#39;#414A4C&#39;,</span>
<span class="gd">-    &#39;Outrageous Orange&#39;: &#39;#FF6E4A&#39;, &#39;Pacific Blue&#39;: &#39;#1CA9C9&#39;, &#39;Peach&#39;:</span>
<span class="gd">-    &#39;#FFCFAB&#39;, &#39;Periwinkle&#39;: &#39;#C5D0E6&#39;, &#39;Piggy Pink&#39;: &#39;#FDDDE6&#39;,</span>
<span class="gd">-    &#39;Pine Green&#39;: &#39;#158078&#39;, &#39;Pink Flamingo&#39;: &#39;#FC74FD&#39;, &#39;Pink Sherbert&#39;:</span>
<span class="gd">-    &#39;#F78FA7&#39;, &#39;Plum&#39;: &#39;#8E4585&#39;, &#39;Purple Heart&#39;: &#39;#7442C8&#39;,</span>
<span class="gd">-    &quot;Purple Mountains&#39; Majesty&quot;: &#39;#9D81BA&#39;, &#39;Purple Pizzazz&#39;: &#39;#FE4EDA&#39;,</span>
<span class="gd">-    &#39;Radical Red&#39;: &#39;#FF496C&#39;, &#39;Raw Sienna&#39;: &#39;#D68A59&#39;, &#39;Razzle Dazzle Rose&#39;:</span>
<span class="gd">-    &#39;#FF48D0&#39;, &#39;Razzmatazz&#39;: &#39;#E3256B&#39;, &#39;Red&#39;: &#39;#EE204D&#39;, &#39;Red Orange&#39;:</span>
<span class="gd">-    &#39;#FF5349&#39;, &#39;Red Violet&#39;: &#39;#C0448F&#39;, &quot;Robin&#39;s Egg Blue&quot;: &#39;#1FCECB&#39;,</span>
<span class="gd">-    &#39;Royal Purple&#39;: &#39;#7851A9&#39;, &#39;Salmon&#39;: &#39;#FF9BAA&#39;, &#39;Scarlet&#39;: &#39;#FC2847&#39;,</span>
<span class="gd">-    &quot;Screamin&#39; Green&quot;: &#39;#76FF7A&#39;, &#39;Sea Green&#39;: &#39;#93DFB8&#39;, &#39;Sepia&#39;:</span>
<span class="gd">-    &#39;#A5694F&#39;, &#39;Shadow&#39;: &#39;#8A795D&#39;, &#39;Shamrock&#39;: &#39;#45CEA2&#39;, &#39;Shocking Pink&#39;:</span>
<span class="gd">-    &#39;#FB7EFD&#39;, &#39;Silver&#39;: &#39;#CDC5C2&#39;, &#39;Sky Blue&#39;: &#39;#80DAEB&#39;, &#39;Spring Green&#39;:</span>
<span class="gd">-    &#39;#ECEABE&#39;, &#39;Sunglow&#39;: &#39;#FFCF48&#39;, &#39;Sunset Orange&#39;: &#39;#FD5E53&#39;, &#39;Tan&#39;:</span>
<span class="gd">-    &#39;#FAA76C&#39;, &#39;Tickle Me Pink&#39;: &#39;#FC89AC&#39;, &#39;Timberwolf&#39;: &#39;#DBD7D2&#39;,</span>
<span class="gd">-    &#39;Tropical Rain Forest&#39;: &#39;#17806D&#39;, &#39;Tumbleweed&#39;: &#39;#DEAA88&#39;,</span>
<span class="gd">-    &#39;Turquoise Blue&#39;: &#39;#77DDE7&#39;, &#39;Unmellow Yellow&#39;: &#39;#FFFF66&#39;,</span>
<span class="gd">-    &#39;Violet (Purple)&#39;: &#39;#926EAE&#39;, &#39;Violet Red&#39;: &#39;#F75394&#39;,</span>
<span class="gd">-    &#39;Vivid Tangerine&#39;: &#39;#FFA089&#39;, &#39;Vivid Violet&#39;: &#39;#8F509D&#39;, &#39;White&#39;:</span>
<span class="gd">-    &#39;#FFFFFF&#39;, &#39;Wild Blue Yonder&#39;: &#39;#A2ADD0&#39;, &#39;Wild Strawberry&#39;: &#39;#FF43A4&#39;,</span>
<span class="gd">-    &#39;Wild Watermelon&#39;: &#39;#FC6C85&#39;, &#39;Wisteria&#39;: &#39;#CDA4DE&#39;, &#39;Yellow&#39;:</span>
<span class="gd">-    &#39;#FCE883&#39;, &#39;Yellow Green&#39;: &#39;#C5E384&#39;, &#39;Yellow Orange&#39;: &#39;#FFAE42&#39;}</span>
<span class="gi">+crayons = {&#39;Almond&#39;: &#39;#EFDECD&#39;,</span>
<span class="gi">+           &#39;Antique Brass&#39;: &#39;#CD9575&#39;,</span>
<span class="gi">+           &#39;Apricot&#39;: &#39;#FDD9B5&#39;,</span>
<span class="gi">+           &#39;Aquamarine&#39;: &#39;#78DBE2&#39;,</span>
<span class="gi">+           &#39;Asparagus&#39;: &#39;#87A96B&#39;,</span>
<span class="gi">+           &#39;Atomic Tangerine&#39;: &#39;#FFA474&#39;,</span>
<span class="gi">+           &#39;Banana Mania&#39;: &#39;#FAE7B5&#39;,</span>
<span class="gi">+           &#39;Beaver&#39;: &#39;#9F8170&#39;,</span>
<span class="gi">+           &#39;Bittersweet&#39;: &#39;#FD7C6E&#39;,</span>
<span class="gi">+           &#39;Black&#39;: &#39;#000000&#39;,</span>
<span class="gi">+           &#39;Blue&#39;: &#39;#1F75FE&#39;,</span>
<span class="gi">+           &#39;Blue Bell&#39;: &#39;#A2A2D0&#39;,</span>
<span class="gi">+           &#39;Blue Green&#39;: &#39;#0D98BA&#39;,</span>
<span class="gi">+           &#39;Blue Violet&#39;: &#39;#7366BD&#39;,</span>
<span class="gi">+           &#39;Blush&#39;: &#39;#DE5D83&#39;,</span>
<span class="gi">+           &#39;Brick Red&#39;: &#39;#CB4154&#39;,</span>
<span class="gi">+           &#39;Brown&#39;: &#39;#B4674D&#39;,</span>
<span class="gi">+           &#39;Burnt Orange&#39;: &#39;#FF7F49&#39;,</span>
<span class="gi">+           &#39;Burnt Sienna&#39;: &#39;#EA7E5D&#39;,</span>
<span class="gi">+           &#39;Cadet Blue&#39;: &#39;#B0B7C6&#39;,</span>
<span class="gi">+           &#39;Canary&#39;: &#39;#FFFF99&#39;,</span>
<span class="gi">+           &#39;Caribbean Green&#39;: &#39;#00CC99&#39;,</span>
<span class="gi">+           &#39;Carnation Pink&#39;: &#39;#FFAACC&#39;,</span>
<span class="gi">+           &#39;Cerise&#39;: &#39;#DD4492&#39;,</span>
<span class="gi">+           &#39;Cerulean&#39;: &#39;#1DACD6&#39;,</span>
<span class="gi">+           &#39;Chestnut&#39;: &#39;#BC5D58&#39;,</span>
<span class="gi">+           &#39;Copper&#39;: &#39;#DD9475&#39;,</span>
<span class="gi">+           &#39;Cornflower&#39;: &#39;#9ACEEB&#39;,</span>
<span class="gi">+           &#39;Cotton Candy&#39;: &#39;#FFBCD9&#39;,</span>
<span class="gi">+           &#39;Dandelion&#39;: &#39;#FDDB6D&#39;,</span>
<span class="gi">+           &#39;Denim&#39;: &#39;#2B6CC4&#39;,</span>
<span class="gi">+           &#39;Desert Sand&#39;: &#39;#EFCDB8&#39;,</span>
<span class="gi">+           &#39;Eggplant&#39;: &#39;#6E5160&#39;,</span>
<span class="gi">+           &#39;Electric Lime&#39;: &#39;#CEFF1D&#39;,</span>
<span class="gi">+           &#39;Fern&#39;: &#39;#71BC78&#39;,</span>
<span class="gi">+           &#39;Forest Green&#39;: &#39;#6DAE81&#39;,</span>
<span class="gi">+           &#39;Fuchsia&#39;: &#39;#C364C5&#39;,</span>
<span class="gi">+           &#39;Fuzzy Wuzzy&#39;: &#39;#CC6666&#39;,</span>
<span class="gi">+           &#39;Gold&#39;: &#39;#E7C697&#39;,</span>
<span class="gi">+           &#39;Goldenrod&#39;: &#39;#FCD975&#39;,</span>
<span class="gi">+           &#39;Granny Smith Apple&#39;: &#39;#A8E4A0&#39;,</span>
<span class="gi">+           &#39;Gray&#39;: &#39;#95918C&#39;,</span>
<span class="gi">+           &#39;Green&#39;: &#39;#1CAC78&#39;,</span>
<span class="gi">+           &#39;Green Yellow&#39;: &#39;#F0E891&#39;,</span>
<span class="gi">+           &#39;Hot Magenta&#39;: &#39;#FF1DCE&#39;,</span>
<span class="gi">+           &#39;Inchworm&#39;: &#39;#B2EC5D&#39;,</span>
<span class="gi">+           &#39;Indigo&#39;: &#39;#5D76CB&#39;,</span>
<span class="gi">+           &#39;Jazzberry Jam&#39;: &#39;#CA3767&#39;,</span>
<span class="gi">+           &#39;Jungle Green&#39;: &#39;#3BB08F&#39;,</span>
<span class="gi">+           &#39;Laser Lemon&#39;: &#39;#FEFE22&#39;,</span>
<span class="gi">+           &#39;Lavender&#39;: &#39;#FCB4D5&#39;,</span>
<span class="gi">+           &#39;Macaroni and Cheese&#39;: &#39;#FFBD88&#39;,</span>
<span class="gi">+           &#39;Magenta&#39;: &#39;#F664AF&#39;,</span>
<span class="gi">+           &#39;Mahogany&#39;: &#39;#CD4A4C&#39;,</span>
<span class="gi">+           &#39;Manatee&#39;: &#39;#979AAA&#39;,</span>
<span class="gi">+           &#39;Mango Tango&#39;: &#39;#FF8243&#39;,</span>
<span class="gi">+           &#39;Maroon&#39;: &#39;#C8385A&#39;,</span>
<span class="gi">+           &#39;Mauvelous&#39;: &#39;#EF98AA&#39;,</span>
<span class="gi">+           &#39;Melon&#39;: &#39;#FDBCB4&#39;,</span>
<span class="gi">+           &#39;Midnight Blue&#39;: &#39;#1A4876&#39;,</span>
<span class="gi">+           &#39;Mountain Meadow&#39;: &#39;#30BA8F&#39;,</span>
<span class="gi">+           &#39;Navy Blue&#39;: &#39;#1974D2&#39;,</span>
<span class="gi">+           &#39;Neon Carrot&#39;: &#39;#FFA343&#39;,</span>
<span class="gi">+           &#39;Olive Green&#39;: &#39;#BAB86C&#39;,</span>
<span class="gi">+           &#39;Orange&#39;: &#39;#FF7538&#39;,</span>
<span class="gi">+           &#39;Orchid&#39;: &#39;#E6A8D7&#39;,</span>
<span class="gi">+           &#39;Outer Space&#39;: &#39;#414A4C&#39;,</span>
<span class="gi">+           &#39;Outrageous Orange&#39;: &#39;#FF6E4A&#39;,</span>
<span class="gi">+           &#39;Pacific Blue&#39;: &#39;#1CA9C9&#39;,</span>
<span class="gi">+           &#39;Peach&#39;: &#39;#FFCFAB&#39;,</span>
<span class="gi">+           &#39;Periwinkle&#39;: &#39;#C5D0E6&#39;,</span>
<span class="gi">+           &#39;Piggy Pink&#39;: &#39;#FDDDE6&#39;,</span>
<span class="gi">+           &#39;Pine Green&#39;: &#39;#158078&#39;,</span>
<span class="gi">+           &#39;Pink Flamingo&#39;: &#39;#FC74FD&#39;,</span>
<span class="gi">+           &#39;Pink Sherbert&#39;: &#39;#F78FA7&#39;,</span>
<span class="gi">+           &#39;Plum&#39;: &#39;#8E4585&#39;,</span>
<span class="gi">+           &#39;Purple Heart&#39;: &#39;#7442C8&#39;,</span>
<span class="gi">+           &quot;Purple Mountains&#39; Majesty&quot;: &#39;#9D81BA&#39;,</span>
<span class="gi">+           &#39;Purple Pizzazz&#39;: &#39;#FE4EDA&#39;,</span>
<span class="gi">+           &#39;Radical Red&#39;: &#39;#FF496C&#39;,</span>
<span class="gi">+           &#39;Raw Sienna&#39;: &#39;#D68A59&#39;,</span>
<span class="gi">+           &#39;Razzle Dazzle Rose&#39;: &#39;#FF48D0&#39;,</span>
<span class="gi">+           &#39;Razzmatazz&#39;: &#39;#E3256B&#39;,</span>
<span class="gi">+           &#39;Red&#39;: &#39;#EE204D&#39;,</span>
<span class="gi">+           &#39;Red Orange&#39;: &#39;#FF5349&#39;,</span>
<span class="gi">+           &#39;Red Violet&#39;: &#39;#C0448F&#39;,</span>
<span class="gi">+           &quot;Robin&#39;s Egg Blue&quot;: &#39;#1FCECB&#39;,</span>
<span class="gi">+           &#39;Royal Purple&#39;: &#39;#7851A9&#39;,</span>
<span class="gi">+           &#39;Salmon&#39;: &#39;#FF9BAA&#39;,</span>
<span class="gi">+           &#39;Scarlet&#39;: &#39;#FC2847&#39;,</span>
<span class="gi">+           &quot;Screamin&#39; Green&quot;: &#39;#76FF7A&#39;,</span>
<span class="gi">+           &#39;Sea Green&#39;: &#39;#93DFB8&#39;,</span>
<span class="gi">+           &#39;Sepia&#39;: &#39;#A5694F&#39;,</span>
<span class="gi">+           &#39;Shadow&#39;: &#39;#8A795D&#39;,</span>
<span class="gi">+           &#39;Shamrock&#39;: &#39;#45CEA2&#39;,</span>
<span class="gi">+           &#39;Shocking Pink&#39;: &#39;#FB7EFD&#39;,</span>
<span class="gi">+           &#39;Silver&#39;: &#39;#CDC5C2&#39;,</span>
<span class="gi">+           &#39;Sky Blue&#39;: &#39;#80DAEB&#39;,</span>
<span class="gi">+           &#39;Spring Green&#39;: &#39;#ECEABE&#39;,</span>
<span class="gi">+           &#39;Sunglow&#39;: &#39;#FFCF48&#39;,</span>
<span class="gi">+           &#39;Sunset Orange&#39;: &#39;#FD5E53&#39;,</span>
<span class="gi">+           &#39;Tan&#39;: &#39;#FAA76C&#39;,</span>
<span class="gi">+           &#39;Tickle Me Pink&#39;: &#39;#FC89AC&#39;,</span>
<span class="gi">+           &#39;Timberwolf&#39;: &#39;#DBD7D2&#39;,</span>
<span class="gi">+           &#39;Tropical Rain Forest&#39;: &#39;#17806D&#39;,</span>
<span class="gi">+           &#39;Tumbleweed&#39;: &#39;#DEAA88&#39;,</span>
<span class="gi">+           &#39;Turquoise Blue&#39;: &#39;#77DDE7&#39;,</span>
<span class="gi">+           &#39;Unmellow Yellow&#39;: &#39;#FFFF66&#39;,</span>
<span class="gi">+           &#39;Violet (Purple)&#39;: &#39;#926EAE&#39;,</span>
<span class="gi">+           &#39;Violet Red&#39;: &#39;#F75394&#39;,</span>
<span class="gi">+           &#39;Vivid Tangerine&#39;: &#39;#FFA089&#39;,</span>
<span class="gi">+           &#39;Vivid Violet&#39;: &#39;#8F509D&#39;,</span>
<span class="gi">+           &#39;White&#39;: &#39;#FFFFFF&#39;,</span>
<span class="gi">+           &#39;Wild Blue Yonder&#39;: &#39;#A2ADD0&#39;,</span>
<span class="gi">+           &#39;Wild Strawberry&#39;: &#39;#FF43A4&#39;,</span>
<span class="gi">+           &#39;Wild Watermelon&#39;: &#39;#FC6C85&#39;,</span>
<span class="gi">+           &#39;Wisteria&#39;: &#39;#CDA4DE&#39;,</span>
<span class="gi">+           &#39;Yellow&#39;: &#39;#FCE883&#39;,</span>
<span class="gi">+           &#39;Yellow Green&#39;: &#39;#C5E384&#39;,</span>
<span class="gi">+           &#39;Yellow Orange&#39;: &#39;#FFAE42&#39;}</span>
<span class="gh">diff --git a/seaborn/colors/xkcd_rgb.py b/seaborn/colors/xkcd_rgb.py</span>
<span class="gh">index 66ddf31a..0f775cf6 100644</span>
<span class="gd">--- a/seaborn/colors/xkcd_rgb.py</span>
<span class="gi">+++ b/seaborn/colors/xkcd_rgb.py</span>
<span class="gu">@@ -1,362 +1,949 @@</span>
<span class="gd">-xkcd_rgb = {&#39;acid green&#39;: &#39;#8ffe09&#39;, &#39;adobe&#39;: &#39;#bd6c48&#39;, &#39;algae&#39;: &#39;#54ac68&#39;,</span>
<span class="gd">-    &#39;algae green&#39;: &#39;#21c36f&#39;, &#39;almost black&#39;: &#39;#070d0d&#39;, &#39;amber&#39;: &#39;#feb308&#39;,</span>
<span class="gd">-    &#39;amethyst&#39;: &#39;#9b5fc0&#39;, &#39;apple&#39;: &#39;#6ecb3c&#39;, &#39;apple green&#39;: &#39;#76cd26&#39;,</span>
<span class="gd">-    &#39;apricot&#39;: &#39;#ffb16d&#39;, &#39;aqua&#39;: &#39;#13eac9&#39;, &#39;aqua blue&#39;: &#39;#02d8e9&#39;,</span>
<span class="gd">-    &#39;aqua green&#39;: &#39;#12e193&#39;, &#39;aqua marine&#39;: &#39;#2ee8bb&#39;, &#39;aquamarine&#39;:</span>
<span class="gd">-    &#39;#04d8b2&#39;, &#39;army green&#39;: &#39;#4b5d16&#39;, &#39;asparagus&#39;: &#39;#77ab56&#39;, &#39;aubergine&#39;:</span>
<span class="gd">-    &#39;#3d0734&#39;, &#39;auburn&#39;: &#39;#9a3001&#39;, &#39;avocado&#39;: &#39;#90b134&#39;, &#39;avocado green&#39;:</span>
<span class="gd">-    &#39;#87a922&#39;, &#39;azul&#39;: &#39;#1d5dec&#39;, &#39;azure&#39;: &#39;#069af3&#39;, &#39;baby blue&#39;:</span>
<span class="gd">-    &#39;#a2cffe&#39;, &#39;baby green&#39;: &#39;#8cff9e&#39;, &#39;baby pink&#39;: &#39;#ffb7ce&#39;, &#39;baby poo&#39;:</span>
<span class="gd">-    &#39;#ab9004&#39;, &#39;baby poop&#39;: &#39;#937c00&#39;, &#39;baby poop green&#39;: &#39;#8f9805&#39;,</span>
<span class="gd">-    &#39;baby puke green&#39;: &#39;#b6c406&#39;, &#39;baby purple&#39;: &#39;#ca9bf7&#39;,</span>
<span class="gd">-    &#39;baby shit brown&#39;: &#39;#ad900d&#39;, &#39;baby shit green&#39;: &#39;#889717&#39;, &#39;banana&#39;:</span>
<span class="gd">-    &#39;#ffff7e&#39;, &#39;banana yellow&#39;: &#39;#fafe4b&#39;, &#39;barbie pink&#39;: &#39;#fe46a5&#39;,</span>
<span class="gd">-    &#39;barf green&#39;: &#39;#94ac02&#39;, &#39;barney&#39;: &#39;#ac1db8&#39;, &#39;barney purple&#39;:</span>
<span class="gd">-    &#39;#a00498&#39;, &#39;battleship grey&#39;: &#39;#6b7c85&#39;, &#39;beige&#39;: &#39;#e6daa6&#39;, &#39;berry&#39;:</span>
<span class="gd">-    &#39;#990f4b&#39;, &#39;bile&#39;: &#39;#b5c306&#39;, &#39;black&#39;: &#39;#000000&#39;, &#39;bland&#39;: &#39;#afa88b&#39;,</span>
<span class="gd">-    &#39;blood&#39;: &#39;#770001&#39;, &#39;blood orange&#39;: &#39;#fe4b03&#39;, &#39;blood red&#39;: &#39;#980002&#39;,</span>
<span class="gd">-    &#39;blue&#39;: &#39;#0343df&#39;, &#39;blue blue&#39;: &#39;#2242c7&#39;, &#39;blue green&#39;: &#39;#137e6d&#39;,</span>
<span class="gd">-    &#39;blue grey&#39;: &#39;#607c8e&#39;, &#39;blue purple&#39;: &#39;#5729ce&#39;, &#39;blue violet&#39;:</span>
<span class="gd">-    &#39;#5d06e9&#39;, &#39;blue with a hint of purple&#39;: &#39;#533cc6&#39;, &#39;blue/green&#39;:</span>
<span class="gd">-    &#39;#0f9b8e&#39;, &#39;blue/grey&#39;: &#39;#758da3&#39;, &#39;blue/purple&#39;: &#39;#5a06ef&#39;,</span>
<span class="gd">-    &#39;blueberry&#39;: &#39;#464196&#39;, &#39;bluegreen&#39;: &#39;#017a79&#39;, &#39;bluegrey&#39;: &#39;#85a3b2&#39;,</span>
<span class="gd">-    &#39;bluey green&#39;: &#39;#2bb179&#39;, &#39;bluey grey&#39;: &#39;#89a0b0&#39;, &#39;bluey purple&#39;:</span>
<span class="gd">-    &#39;#6241c7&#39;, &#39;bluish&#39;: &#39;#2976bb&#39;, &#39;bluish green&#39;: &#39;#10a674&#39;,</span>
<span class="gd">-    &#39;bluish grey&#39;: &#39;#748b97&#39;, &#39;bluish purple&#39;: &#39;#703be7&#39;, &#39;blurple&#39;:</span>
<span class="gd">-    &#39;#5539cc&#39;, &#39;blush&#39;: &#39;#f29e8e&#39;, &#39;blush pink&#39;: &#39;#fe828c&#39;, &#39;booger&#39;:</span>
<span class="gd">-    &#39;#9bb53c&#39;, &#39;booger green&#39;: &#39;#96b403&#39;, &#39;bordeaux&#39;: &#39;#7b002c&#39;,</span>
<span class="gd">-    &#39;boring green&#39;: &#39;#63b365&#39;, &#39;bottle green&#39;: &#39;#044a05&#39;, &#39;brick&#39;:</span>
<span class="gd">-    &#39;#a03623&#39;, &#39;brick orange&#39;: &#39;#c14a09&#39;, &#39;brick red&#39;: &#39;#8f1402&#39;,</span>
<span class="gd">-    &#39;bright aqua&#39;: &#39;#0bf9ea&#39;, &#39;bright blue&#39;: &#39;#0165fc&#39;, &#39;bright cyan&#39;:</span>
<span class="gd">-    &#39;#41fdfe&#39;, &#39;bright green&#39;: &#39;#01ff07&#39;, &#39;bright lavender&#39;: &#39;#c760ff&#39;,</span>
<span class="gd">-    &#39;bright light blue&#39;: &#39;#26f7fd&#39;, &#39;bright light green&#39;: &#39;#2dfe54&#39;,</span>
<span class="gd">-    &#39;bright lilac&#39;: &#39;#c95efb&#39;, &#39;bright lime&#39;: &#39;#87fd05&#39;,</span>
<span class="gd">-    &#39;bright lime green&#39;: &#39;#65fe08&#39;, &#39;bright magenta&#39;: &#39;#ff08e8&#39;,</span>
<span class="gd">-    &#39;bright olive&#39;: &#39;#9cbb04&#39;, &#39;bright orange&#39;: &#39;#ff5b00&#39;, &#39;bright pink&#39;:</span>
<span class="gd">-    &#39;#fe01b1&#39;, &#39;bright purple&#39;: &#39;#be03fd&#39;, &#39;bright red&#39;: &#39;#ff000d&#39;,</span>
<span class="gd">-    &#39;bright sea green&#39;: &#39;#05ffa6&#39;, &#39;bright sky blue&#39;: &#39;#02ccfe&#39;,</span>
<span class="gd">-    &#39;bright teal&#39;: &#39;#01f9c6&#39;, &#39;bright turquoise&#39;: &#39;#0ffef9&#39;,</span>
<span class="gd">-    &#39;bright violet&#39;: &#39;#ad0afd&#39;, &#39;bright yellow&#39;: &#39;#fffd01&#39;,</span>
<span class="gd">-    &#39;bright yellow green&#39;: &#39;#9dff00&#39;, &#39;british racing green&#39;: &#39;#05480d&#39;,</span>
<span class="gd">-    &#39;bronze&#39;: &#39;#a87900&#39;, &#39;brown&#39;: &#39;#653700&#39;, &#39;brown green&#39;: &#39;#706c11&#39;,</span>
<span class="gd">-    &#39;brown grey&#39;: &#39;#8d8468&#39;, &#39;brown orange&#39;: &#39;#b96902&#39;, &#39;brown red&#39;:</span>
<span class="gd">-    &#39;#922b05&#39;, &#39;brown yellow&#39;: &#39;#b29705&#39;, &#39;brownish&#39;: &#39;#9c6d57&#39;,</span>
<span class="gd">-    &#39;brownish green&#39;: &#39;#6a6e09&#39;, &#39;brownish grey&#39;: &#39;#86775f&#39;,</span>
<span class="gd">-    &#39;brownish orange&#39;: &#39;#cb7723&#39;, &#39;brownish pink&#39;: &#39;#c27e79&#39;,</span>
<span class="gd">-    &#39;brownish purple&#39;: &#39;#76424e&#39;, &#39;brownish red&#39;: &#39;#9e3623&#39;,</span>
<span class="gd">-    &#39;brownish yellow&#39;: &#39;#c9b003&#39;, &#39;browny green&#39;: &#39;#6f6c0a&#39;,</span>
<span class="gd">-    &#39;browny orange&#39;: &#39;#ca6b02&#39;, &#39;bruise&#39;: &#39;#7e4071&#39;, &#39;bubble gum pink&#39;:</span>
<span class="gd">-    &#39;#ff69af&#39;, &#39;bubblegum&#39;: &#39;#ff6cb5&#39;, &#39;bubblegum pink&#39;: &#39;#fe83cc&#39;, &#39;buff&#39;:</span>
<span class="gd">-    &#39;#fef69e&#39;, &#39;burgundy&#39;: &#39;#610023&#39;, &#39;burnt orange&#39;: &#39;#c04e01&#39;,</span>
<span class="gd">-    &#39;burnt red&#39;: &#39;#9f2305&#39;, &#39;burnt siena&#39;: &#39;#b75203&#39;, &#39;burnt sienna&#39;:</span>
<span class="gd">-    &#39;#b04e0f&#39;, &#39;burnt umber&#39;: &#39;#a0450e&#39;, &#39;burnt yellow&#39;: &#39;#d5ab09&#39;,</span>
<span class="gd">-    &#39;burple&#39;: &#39;#6832e3&#39;, &#39;butter&#39;: &#39;#ffff81&#39;, &#39;butter yellow&#39;: &#39;#fffd74&#39;,</span>
<span class="gd">-    &#39;butterscotch&#39;: &#39;#fdb147&#39;, &#39;cadet blue&#39;: &#39;#4e7496&#39;, &#39;camel&#39;: &#39;#c69f59&#39;,</span>
<span class="gd">-    &#39;camo&#39;: &#39;#7f8f4e&#39;, &#39;camo green&#39;: &#39;#526525&#39;, &#39;camouflage green&#39;:</span>
<span class="gd">-    &#39;#4b6113&#39;, &#39;canary&#39;: &#39;#fdff63&#39;, &#39;canary yellow&#39;: &#39;#fffe40&#39;,</span>
<span class="gd">-    &#39;candy pink&#39;: &#39;#ff63e9&#39;, &#39;caramel&#39;: &#39;#af6f09&#39;, &#39;carmine&#39;: &#39;#9d0216&#39;,</span>
<span class="gd">-    &#39;carnation&#39;: &#39;#fd798f&#39;, &#39;carnation pink&#39;: &#39;#ff7fa7&#39;, &#39;carolina blue&#39;:</span>
<span class="gd">-    &#39;#8ab8fe&#39;, &#39;celadon&#39;: &#39;#befdb7&#39;, &#39;celery&#39;: &#39;#c1fd95&#39;, &#39;cement&#39;:</span>
<span class="gd">-    &#39;#a5a391&#39;, &#39;cerise&#39;: &#39;#de0c62&#39;, &#39;cerulean&#39;: &#39;#0485d1&#39;, &#39;cerulean blue&#39;:</span>
<span class="gd">-    &#39;#056eee&#39;, &#39;charcoal&#39;: &#39;#343837&#39;, &#39;charcoal grey&#39;: &#39;#3c4142&#39;,</span>
<span class="gd">-    &#39;chartreuse&#39;: &#39;#c1f80a&#39;, &#39;cherry&#39;: &#39;#cf0234&#39;, &#39;cherry red&#39;: &#39;#f7022a&#39;,</span>
<span class="gd">-    &#39;chestnut&#39;: &#39;#742802&#39;, &#39;chocolate&#39;: &#39;#3d1c02&#39;, &#39;chocolate brown&#39;:</span>
<span class="gd">-    &#39;#411900&#39;, &#39;cinnamon&#39;: &#39;#ac4f06&#39;, &#39;claret&#39;: &#39;#680018&#39;, &#39;clay&#39;:</span>
<span class="gd">-    &#39;#b66a50&#39;, &#39;clay brown&#39;: &#39;#b2713d&#39;, &#39;clear blue&#39;: &#39;#247afd&#39;,</span>
<span class="gd">-    &#39;cloudy blue&#39;: &#39;#acc2d9&#39;, &#39;cobalt&#39;: &#39;#1e488f&#39;, &#39;cobalt blue&#39;: &#39;#030aa7&#39;,</span>
<span class="gd">-    &#39;cocoa&#39;: &#39;#875f42&#39;, &#39;coffee&#39;: &#39;#a6814c&#39;, &#39;cool blue&#39;: &#39;#4984b8&#39;,</span>
<span class="gd">-    &#39;cool green&#39;: &#39;#33b864&#39;, &#39;cool grey&#39;: &#39;#95a3a6&#39;, &#39;copper&#39;: &#39;#b66325&#39;,</span>
<span class="gd">-    &#39;coral&#39;: &#39;#fc5a50&#39;, &#39;coral pink&#39;: &#39;#ff6163&#39;, &#39;cornflower&#39;: &#39;#6a79f7&#39;,</span>
<span class="gd">-    &#39;cornflower blue&#39;: &#39;#5170d7&#39;, &#39;cranberry&#39;: &#39;#9e003a&#39;, &#39;cream&#39;:</span>
<span class="gd">-    &#39;#ffffc2&#39;, &#39;creme&#39;: &#39;#ffffb6&#39;, &#39;crimson&#39;: &#39;#8c000f&#39;, &#39;custard&#39;:</span>
<span class="gd">-    &#39;#fffd78&#39;, &#39;cyan&#39;: &#39;#00ffff&#39;, &#39;dandelion&#39;: &#39;#fedf08&#39;, &#39;dark&#39;: &#39;#1b2431&#39;,</span>
<span class="gd">-    &#39;dark aqua&#39;: &#39;#05696b&#39;, &#39;dark aquamarine&#39;: &#39;#017371&#39;, &#39;dark beige&#39;:</span>
<span class="gd">-    &#39;#ac9362&#39;, &#39;dark blue&#39;: &#39;#00035b&#39;, &#39;dark blue green&#39;: &#39;#005249&#39;,</span>
<span class="gd">-    &#39;dark blue grey&#39;: &#39;#1f3b4d&#39;, &#39;dark brown&#39;: &#39;#341c02&#39;, &#39;dark coral&#39;:</span>
<span class="gd">-    &#39;#cf524e&#39;, &#39;dark cream&#39;: &#39;#fff39a&#39;, &#39;dark cyan&#39;: &#39;#0a888a&#39;,</span>
<span class="gd">-    &#39;dark forest green&#39;: &#39;#002d04&#39;, &#39;dark fuchsia&#39;: &#39;#9d0759&#39;, &#39;dark gold&#39;:</span>
<span class="gd">-    &#39;#b59410&#39;, &#39;dark grass green&#39;: &#39;#388004&#39;, &#39;dark green&#39;: &#39;#033500&#39;,</span>
<span class="gd">-    &#39;dark green blue&#39;: &#39;#1f6357&#39;, &#39;dark grey&#39;: &#39;#363737&#39;, &#39;dark grey blue&#39;:</span>
<span class="gd">-    &#39;#29465b&#39;, &#39;dark hot pink&#39;: &#39;#d90166&#39;, &#39;dark indigo&#39;: &#39;#1f0954&#39;,</span>
<span class="gd">-    &#39;dark khaki&#39;: &#39;#9b8f55&#39;, &#39;dark lavender&#39;: &#39;#856798&#39;, &#39;dark lilac&#39;:</span>
<span class="gd">-    &#39;#9c6da5&#39;, &#39;dark lime&#39;: &#39;#84b701&#39;, &#39;dark lime green&#39;: &#39;#7ebd01&#39;,</span>
<span class="gd">-    &#39;dark magenta&#39;: &#39;#960056&#39;, &#39;dark maroon&#39;: &#39;#3c0008&#39;, &#39;dark mauve&#39;:</span>
<span class="gd">-    &#39;#874c62&#39;, &#39;dark mint&#39;: &#39;#48c072&#39;, &#39;dark mint green&#39;: &#39;#20c073&#39;,</span>
<span class="gd">-    &#39;dark mustard&#39;: &#39;#a88905&#39;, &#39;dark navy&#39;: &#39;#000435&#39;, &#39;dark navy blue&#39;:</span>
<span class="gd">-    &#39;#00022e&#39;, &#39;dark olive&#39;: &#39;#373e02&#39;, &#39;dark olive green&#39;: &#39;#3c4d03&#39;,</span>
<span class="gd">-    &#39;dark orange&#39;: &#39;#c65102&#39;, &#39;dark pastel green&#39;: &#39;#56ae57&#39;, &#39;dark peach&#39;:</span>
<span class="gd">-    &#39;#de7e5d&#39;, &#39;dark periwinkle&#39;: &#39;#665fd1&#39;, &#39;dark pink&#39;: &#39;#cb416b&#39;,</span>
<span class="gd">-    &#39;dark plum&#39;: &#39;#3f012c&#39;, &#39;dark purple&#39;: &#39;#35063e&#39;, &#39;dark red&#39;: &#39;#840000&#39;,</span>
<span class="gd">-    &#39;dark rose&#39;: &#39;#b5485d&#39;, &#39;dark royal blue&#39;: &#39;#02066f&#39;, &#39;dark sage&#39;:</span>
<span class="gd">-    &#39;#598556&#39;, &#39;dark salmon&#39;: &#39;#c85a53&#39;, &#39;dark sand&#39;: &#39;#a88f59&#39;,</span>
<span class="gd">-    &#39;dark sea green&#39;: &#39;#11875d&#39;, &#39;dark seafoam&#39;: &#39;#1fb57a&#39;,</span>
<span class="gd">-    &#39;dark seafoam green&#39;: &#39;#3eaf76&#39;, &#39;dark sky blue&#39;: &#39;#448ee4&#39;,</span>
<span class="gd">-    &#39;dark slate blue&#39;: &#39;#214761&#39;, &#39;dark tan&#39;: &#39;#af884a&#39;, &#39;dark taupe&#39;:</span>
<span class="gd">-    &#39;#7f684e&#39;, &#39;dark teal&#39;: &#39;#014d4e&#39;, &#39;dark turquoise&#39;: &#39;#045c5a&#39;,</span>
<span class="gd">-    &#39;dark violet&#39;: &#39;#34013f&#39;, &#39;dark yellow&#39;: &#39;#d5b60a&#39;, &#39;dark yellow green&#39;:</span>
<span class="gd">-    &#39;#728f02&#39;, &#39;darkblue&#39;: &#39;#030764&#39;, &#39;darkgreen&#39;: &#39;#054907&#39;,</span>
<span class="gd">-    &#39;darkish blue&#39;: &#39;#014182&#39;, &#39;darkish green&#39;: &#39;#287c37&#39;, &#39;darkish pink&#39;:</span>
<span class="gd">-    &#39;#da467d&#39;, &#39;darkish purple&#39;: &#39;#751973&#39;, &#39;darkish red&#39;: &#39;#a90308&#39;,</span>
<span class="gd">-    &#39;deep aqua&#39;: &#39;#08787f&#39;, &#39;deep blue&#39;: &#39;#040273&#39;, &#39;deep brown&#39;: &#39;#410200&#39;,</span>
<span class="gd">-    &#39;deep green&#39;: &#39;#02590f&#39;, &#39;deep lavender&#39;: &#39;#8d5eb7&#39;, &#39;deep lilac&#39;:</span>
<span class="gd">-    &#39;#966ebd&#39;, &#39;deep magenta&#39;: &#39;#a0025c&#39;, &#39;deep orange&#39;: &#39;#dc4d01&#39;,</span>
<span class="gd">-    &#39;deep pink&#39;: &#39;#cb0162&#39;, &#39;deep purple&#39;: &#39;#36013f&#39;, &#39;deep red&#39;: &#39;#9a0200&#39;,</span>
<span class="gd">-    &#39;deep rose&#39;: &#39;#c74767&#39;, &#39;deep sea blue&#39;: &#39;#015482&#39;, &#39;deep sky blue&#39;:</span>
<span class="gd">-    &#39;#0d75f8&#39;, &#39;deep teal&#39;: &#39;#00555a&#39;, &#39;deep turquoise&#39;: &#39;#017374&#39;,</span>
<span class="gd">-    &#39;deep violet&#39;: &#39;#490648&#39;, &#39;denim&#39;: &#39;#3b638c&#39;, &#39;denim blue&#39;: &#39;#3b5b92&#39;,</span>
<span class="gd">-    &#39;desert&#39;: &#39;#ccad60&#39;, &#39;diarrhea&#39;: &#39;#9f8303&#39;, &#39;dirt&#39;: &#39;#8a6e45&#39;,</span>
<span class="gd">-    &#39;dirt brown&#39;: &#39;#836539&#39;, &#39;dirty blue&#39;: &#39;#3f829d&#39;, &#39;dirty green&#39;:</span>
<span class="gd">-    &#39;#667e2c&#39;, &#39;dirty orange&#39;: &#39;#c87606&#39;, &#39;dirty pink&#39;: &#39;#ca7b80&#39;,</span>
<span class="gd">-    &#39;dirty purple&#39;: &#39;#734a65&#39;, &#39;dirty yellow&#39;: &#39;#cdc50a&#39;, &#39;dodger blue&#39;:</span>
<span class="gd">-    &#39;#3e82fc&#39;, &#39;drab&#39;: &#39;#828344&#39;, &#39;drab green&#39;: &#39;#749551&#39;, &#39;dried blood&#39;:</span>
<span class="gd">-    &#39;#4b0101&#39;, &#39;duck egg blue&#39;: &#39;#c3fbf4&#39;, &#39;dull blue&#39;: &#39;#49759c&#39;,</span>
<span class="gd">-    &#39;dull brown&#39;: &#39;#876e4b&#39;, &#39;dull green&#39;: &#39;#74a662&#39;, &#39;dull orange&#39;:</span>
<span class="gd">-    &#39;#d8863b&#39;, &#39;dull pink&#39;: &#39;#d5869d&#39;, &#39;dull purple&#39;: &#39;#84597e&#39;, &#39;dull red&#39;:</span>
<span class="gd">-    &#39;#bb3f3f&#39;, &#39;dull teal&#39;: &#39;#5f9e8f&#39;, &#39;dull yellow&#39;: &#39;#eedc5b&#39;, &#39;dusk&#39;:</span>
<span class="gd">-    &#39;#4e5481&#39;, &#39;dusk blue&#39;: &#39;#26538d&#39;, &#39;dusky blue&#39;: &#39;#475f94&#39;,</span>
<span class="gd">-    &#39;dusky pink&#39;: &#39;#cc7a8b&#39;, &#39;dusky purple&#39;: &#39;#895b7b&#39;, &#39;dusky rose&#39;:</span>
<span class="gd">-    &#39;#ba6873&#39;, &#39;dust&#39;: &#39;#b2996e&#39;, &#39;dusty blue&#39;: &#39;#5a86ad&#39;, &#39;dusty green&#39;:</span>
<span class="gd">-    &#39;#76a973&#39;, &#39;dusty lavender&#39;: &#39;#ac86a8&#39;, &#39;dusty orange&#39;: &#39;#f0833a&#39;,</span>
<span class="gd">-    &#39;dusty pink&#39;: &#39;#d58a94&#39;, &#39;dusty purple&#39;: &#39;#825f87&#39;, &#39;dusty red&#39;:</span>
<span class="gd">-    &#39;#b9484e&#39;, &#39;dusty rose&#39;: &#39;#c0737a&#39;, &#39;dusty teal&#39;: &#39;#4c9085&#39;, &#39;earth&#39;:</span>
<span class="gd">-    &#39;#a2653e&#39;, &#39;easter green&#39;: &#39;#8cfd7e&#39;, &#39;easter purple&#39;: &#39;#c071fe&#39;,</span>
<span class="gd">-    &#39;ecru&#39;: &#39;#feffca&#39;, &#39;egg shell&#39;: &#39;#fffcc4&#39;, &#39;eggplant&#39;: &#39;#380835&#39;,</span>
<span class="gd">-    &#39;eggplant purple&#39;: &#39;#430541&#39;, &#39;eggshell&#39;: &#39;#ffffd4&#39;, &#39;eggshell blue&#39;:</span>
<span class="gd">-    &#39;#c4fff7&#39;, &#39;electric blue&#39;: &#39;#0652ff&#39;, &#39;electric green&#39;: &#39;#21fc0d&#39;,</span>
<span class="gd">-    &#39;electric lime&#39;: &#39;#a8ff04&#39;, &#39;electric pink&#39;: &#39;#ff0490&#39;,</span>
<span class="gd">-    &#39;electric purple&#39;: &#39;#aa23ff&#39;, &#39;emerald&#39;: &#39;#01a049&#39;, &#39;emerald green&#39;:</span>
<span class="gd">-    &#39;#028f1e&#39;, &#39;evergreen&#39;: &#39;#05472a&#39;, &#39;faded blue&#39;: &#39;#658cbb&#39;,</span>
<span class="gd">-    &#39;faded green&#39;: &#39;#7bb274&#39;, &#39;faded orange&#39;: &#39;#f0944d&#39;, &#39;faded pink&#39;:</span>
<span class="gd">-    &#39;#de9dac&#39;, &#39;faded purple&#39;: &#39;#916e99&#39;, &#39;faded red&#39;: &#39;#d3494e&#39;,</span>
<span class="gd">-    &#39;faded yellow&#39;: &#39;#feff7f&#39;, &#39;fawn&#39;: &#39;#cfaf7b&#39;, &#39;fern&#39;: &#39;#63a950&#39;,</span>
<span class="gd">-    &#39;fern green&#39;: &#39;#548d44&#39;, &#39;fire engine red&#39;: &#39;#fe0002&#39;, &#39;flat blue&#39;:</span>
<span class="gd">-    &#39;#3c73a8&#39;, &#39;flat green&#39;: &#39;#699d4c&#39;, &#39;fluorescent green&#39;: &#39;#08ff08&#39;,</span>
<span class="gd">-    &#39;fluro green&#39;: &#39;#0aff02&#39;, &#39;foam green&#39;: &#39;#90fda9&#39;, &#39;forest&#39;: &#39;#0b5509&#39;,</span>
<span class="gd">-    &#39;forest green&#39;: &#39;#06470c&#39;, &#39;forrest green&#39;: &#39;#154406&#39;, &#39;french blue&#39;:</span>
<span class="gd">-    &#39;#436bad&#39;, &#39;fresh green&#39;: &#39;#69d84f&#39;, &#39;frog green&#39;: &#39;#58bc08&#39;, &#39;fuchsia&#39;:</span>
<span class="gd">-    &#39;#ed0dd9&#39;, &#39;gold&#39;: &#39;#dbb40c&#39;, &#39;golden&#39;: &#39;#f5bf03&#39;, &#39;golden brown&#39;:</span>
<span class="gd">-    &#39;#b27a01&#39;, &#39;golden rod&#39;: &#39;#f9bc08&#39;, &#39;golden yellow&#39;: &#39;#fec615&#39;,</span>
<span class="gd">-    &#39;goldenrod&#39;: &#39;#fac205&#39;, &#39;grape&#39;: &#39;#6c3461&#39;, &#39;grape purple&#39;: &#39;#5d1451&#39;,</span>
<span class="gd">-    &#39;grapefruit&#39;: &#39;#fd5956&#39;, &#39;grass&#39;: &#39;#5cac2d&#39;, &#39;grass green&#39;: &#39;#3f9b0b&#39;,</span>
<span class="gd">-    &#39;grassy green&#39;: &#39;#419c03&#39;, &#39;green&#39;: &#39;#15b01a&#39;, &#39;green apple&#39;: &#39;#5edc1f&#39;,</span>
<span class="gd">-    &#39;green blue&#39;: &#39;#06b48b&#39;, &#39;green brown&#39;: &#39;#544e03&#39;, &#39;green grey&#39;:</span>
<span class="gd">-    &#39;#77926f&#39;, &#39;green teal&#39;: &#39;#0cb577&#39;, &#39;green yellow&#39;: &#39;#c9ff27&#39;,</span>
<span class="gd">-    &#39;green/blue&#39;: &#39;#01c08d&#39;, &#39;green/yellow&#39;: &#39;#b5ce08&#39;, &#39;greenblue&#39;:</span>
<span class="gd">-    &#39;#23c48b&#39;, &#39;greenish&#39;: &#39;#40a368&#39;, &#39;greenish beige&#39;: &#39;#c9d179&#39;,</span>
<span class="gd">-    &#39;greenish blue&#39;: &#39;#0b8b87&#39;, &#39;greenish brown&#39;: &#39;#696112&#39;,</span>
<span class="gd">-    &#39;greenish cyan&#39;: &#39;#2afeb7&#39;, &#39;greenish grey&#39;: &#39;#96ae8d&#39;, &#39;greenish tan&#39;:</span>
<span class="gd">-    &#39;#bccb7a&#39;, &#39;greenish teal&#39;: &#39;#32bf84&#39;, &#39;greenish turquoise&#39;: &#39;#00fbb0&#39;,</span>
<span class="gd">-    &#39;greenish yellow&#39;: &#39;#cdfd02&#39;, &#39;greeny blue&#39;: &#39;#42b395&#39;, &#39;greeny brown&#39;:</span>
<span class="gd">-    &#39;#696006&#39;, &#39;greeny grey&#39;: &#39;#7ea07a&#39;, &#39;greeny yellow&#39;: &#39;#c6f808&#39;, &#39;grey&#39;:</span>
<span class="gd">-    &#39;#929591&#39;, &#39;grey blue&#39;: &#39;#6b8ba4&#39;, &#39;grey brown&#39;: &#39;#7f7053&#39;,</span>
<span class="gd">-    &#39;grey green&#39;: &#39;#789b73&#39;, &#39;grey pink&#39;: &#39;#c3909b&#39;, &#39;grey purple&#39;:</span>
<span class="gd">-    &#39;#826d8c&#39;, &#39;grey teal&#39;: &#39;#5e9b8a&#39;, &#39;grey/blue&#39;: &#39;#647d8e&#39;, &#39;grey/green&#39;:</span>
<span class="gd">-    &#39;#86a17d&#39;, &#39;greyblue&#39;: &#39;#77a1b5&#39;, &#39;greyish&#39;: &#39;#a8a495&#39;, &#39;greyish blue&#39;:</span>
<span class="gd">-    &#39;#5e819d&#39;, &#39;greyish brown&#39;: &#39;#7a6a4f&#39;, &#39;greyish green&#39;: &#39;#82a67d&#39;,</span>
<span class="gd">-    &#39;greyish pink&#39;: &#39;#c88d94&#39;, &#39;greyish purple&#39;: &#39;#887191&#39;, &#39;greyish teal&#39;:</span>
<span class="gd">-    &#39;#719f91&#39;, &#39;gross green&#39;: &#39;#a0bf16&#39;, &#39;gunmetal&#39;: &#39;#536267&#39;, &#39;hazel&#39;:</span>
<span class="gd">-    &#39;#8e7618&#39;, &#39;heather&#39;: &#39;#a484ac&#39;, &#39;heliotrope&#39;: &#39;#d94ff5&#39;,</span>
<span class="gd">-    &#39;highlighter green&#39;: &#39;#1bfc06&#39;, &#39;hospital green&#39;: &#39;#9be5aa&#39;,</span>
<span class="gd">-    &#39;hot green&#39;: &#39;#25ff29&#39;, &#39;hot magenta&#39;: &#39;#f504c9&#39;, &#39;hot pink&#39;: &#39;#ff028d&#39;,</span>
<span class="gd">-    &#39;hot purple&#39;: &#39;#cb00f5&#39;, &#39;hunter green&#39;: &#39;#0b4008&#39;, &#39;ice&#39;: &#39;#d6fffa&#39;,</span>
<span class="gd">-    &#39;ice blue&#39;: &#39;#d7fffe&#39;, &#39;icky green&#39;: &#39;#8fae22&#39;, &#39;indian red&#39;: &#39;#850e04&#39;,</span>
<span class="gd">-    &#39;indigo&#39;: &#39;#380282&#39;, &#39;indigo blue&#39;: &#39;#3a18b1&#39;, &#39;iris&#39;: &#39;#6258c4&#39;,</span>
<span class="gd">-    &#39;irish green&#39;: &#39;#019529&#39;, &#39;ivory&#39;: &#39;#ffffcb&#39;, &#39;jade&#39;: &#39;#1fa774&#39;,</span>
<span class="gd">-    &#39;jade green&#39;: &#39;#2baf6a&#39;, &#39;jungle green&#39;: &#39;#048243&#39;, &#39;kelley green&#39;:</span>
<span class="gd">-    &#39;#009337&#39;, &#39;kelly green&#39;: &#39;#02ab2e&#39;, &#39;kermit green&#39;: &#39;#5cb200&#39;,</span>
<span class="gd">-    &#39;key lime&#39;: &#39;#aeff6e&#39;, &#39;khaki&#39;: &#39;#aaa662&#39;, &#39;khaki green&#39;: &#39;#728639&#39;,</span>
<span class="gd">-    &#39;kiwi&#39;: &#39;#9cef43&#39;, &#39;kiwi green&#39;: &#39;#8ee53f&#39;, &#39;lavender&#39;: &#39;#c79fef&#39;,</span>
<span class="gd">-    &#39;lavender blue&#39;: &#39;#8b88f8&#39;, &#39;lavender pink&#39;: &#39;#dd85d7&#39;, &#39;lawn green&#39;:</span>
<span class="gd">-    &#39;#4da409&#39;, &#39;leaf&#39;: &#39;#71aa34&#39;, &#39;leaf green&#39;: &#39;#5ca904&#39;, &#39;leafy green&#39;:</span>
<span class="gd">-    &#39;#51b73b&#39;, &#39;leather&#39;: &#39;#ac7434&#39;, &#39;lemon&#39;: &#39;#fdff52&#39;, &#39;lemon green&#39;:</span>
<span class="gd">-    &#39;#adf802&#39;, &#39;lemon lime&#39;: &#39;#bffe28&#39;, &#39;lemon yellow&#39;: &#39;#fdff38&#39;, &#39;lichen&#39;:</span>
<span class="gd">-    &#39;#8fb67b&#39;, &#39;light aqua&#39;: &#39;#8cffdb&#39;, &#39;light aquamarine&#39;: &#39;#7bfdc7&#39;,</span>
<span class="gd">-    &#39;light beige&#39;: &#39;#fffeb6&#39;, &#39;light blue&#39;: &#39;#95d0fc&#39;, &#39;light blue green&#39;:</span>
<span class="gd">-    &#39;#7efbb3&#39;, &#39;light blue grey&#39;: &#39;#b7c9e2&#39;, &#39;light bluish green&#39;:</span>
<span class="gd">-    &#39;#76fda8&#39;, &#39;light bright green&#39;: &#39;#53fe5c&#39;, &#39;light brown&#39;: &#39;#ad8150&#39;,</span>
<span class="gd">-    &#39;light burgundy&#39;: &#39;#a8415b&#39;, &#39;light cyan&#39;: &#39;#acfffc&#39;, &#39;light eggplant&#39;:</span>
<span class="gd">-    &#39;#894585&#39;, &#39;light forest green&#39;: &#39;#4f9153&#39;, &#39;light gold&#39;: &#39;#fddc5c&#39;,</span>
<span class="gd">-    &#39;light grass green&#39;: &#39;#9af764&#39;, &#39;light green&#39;: &#39;#96f97b&#39;,</span>
<span class="gd">-    &#39;light green blue&#39;: &#39;#56fca2&#39;, &#39;light greenish blue&#39;: &#39;#63f7b4&#39;,</span>
<span class="gd">-    &#39;light grey&#39;: &#39;#d8dcd6&#39;, &#39;light grey blue&#39;: &#39;#9dbcd4&#39;,</span>
<span class="gd">-    &#39;light grey green&#39;: &#39;#b7e1a1&#39;, &#39;light indigo&#39;: &#39;#6d5acf&#39;, &#39;light khaki&#39;:</span>
<span class="gd">-    &#39;#e6f2a2&#39;, &#39;light lavendar&#39;: &#39;#efc0fe&#39;, &#39;light lavender&#39;: &#39;#dfc5fe&#39;,</span>
<span class="gd">-    &#39;light light blue&#39;: &#39;#cafffb&#39;, &#39;light light green&#39;: &#39;#c8ffb0&#39;,</span>
<span class="gd">-    &#39;light lilac&#39;: &#39;#edc8ff&#39;, &#39;light lime&#39;: &#39;#aefd6c&#39;, &#39;light lime green&#39;:</span>
<span class="gd">-    &#39;#b9ff66&#39;, &#39;light magenta&#39;: &#39;#fa5ff7&#39;, &#39;light maroon&#39;: &#39;#a24857&#39;,</span>
<span class="gd">-    &#39;light mauve&#39;: &#39;#c292a1&#39;, &#39;light mint&#39;: &#39;#b6ffbb&#39;, &#39;light mint green&#39;:</span>
<span class="gd">-    &#39;#a6fbb2&#39;, &#39;light moss green&#39;: &#39;#a6c875&#39;, &#39;light mustard&#39;: &#39;#f7d560&#39;,</span>
<span class="gd">-    &#39;light navy&#39;: &#39;#155084&#39;, &#39;light navy blue&#39;: &#39;#2e5a88&#39;,</span>
<span class="gd">-    &#39;light neon green&#39;: &#39;#4efd54&#39;, &#39;light olive&#39;: &#39;#acbf69&#39;,</span>
<span class="gd">-    &#39;light olive green&#39;: &#39;#a4be5c&#39;, &#39;light orange&#39;: &#39;#fdaa48&#39;,</span>
<span class="gd">-    &#39;light pastel green&#39;: &#39;#b2fba5&#39;, &#39;light pea green&#39;: &#39;#c4fe82&#39;,</span>
<span class="gd">-    &#39;light peach&#39;: &#39;#ffd8b1&#39;, &#39;light periwinkle&#39;: &#39;#c1c6fc&#39;, &#39;light pink&#39;:</span>
<span class="gd">-    &#39;#ffd1df&#39;, &#39;light plum&#39;: &#39;#9d5783&#39;, &#39;light purple&#39;: &#39;#bf77f6&#39;,</span>
<span class="gd">-    &#39;light red&#39;: &#39;#ff474c&#39;, &#39;light rose&#39;: &#39;#ffc5cb&#39;, &#39;light royal blue&#39;:</span>
<span class="gd">-    &#39;#3a2efe&#39;, &#39;light sage&#39;: &#39;#bcecac&#39;, &#39;light salmon&#39;: &#39;#fea993&#39;,</span>
<span class="gd">-    &#39;light sea green&#39;: &#39;#98f6b0&#39;, &#39;light seafoam&#39;: &#39;#a0febf&#39;,</span>
<span class="gd">-    &#39;light seafoam green&#39;: &#39;#a7ffb5&#39;, &#39;light sky blue&#39;: &#39;#c6fcff&#39;,</span>
<span class="gd">-    &#39;light tan&#39;: &#39;#fbeeac&#39;, &#39;light teal&#39;: &#39;#90e4c1&#39;, &#39;light turquoise&#39;:</span>
<span class="gd">-    &#39;#7ef4cc&#39;, &#39;light urple&#39;: &#39;#b36ff6&#39;, &#39;light violet&#39;: &#39;#d6b4fc&#39;,</span>
<span class="gd">-    &#39;light yellow&#39;: &#39;#fffe7a&#39;, &#39;light yellow green&#39;: &#39;#ccfd7f&#39;,</span>
<span class="gd">-    &#39;light yellowish green&#39;: &#39;#c2ff89&#39;, &#39;lightblue&#39;: &#39;#7bc8f6&#39;,</span>
<span class="gd">-    &#39;lighter green&#39;: &#39;#75fd63&#39;, &#39;lighter purple&#39;: &#39;#a55af4&#39;, &#39;lightgreen&#39;:</span>
<span class="gd">-    &#39;#76ff7b&#39;, &#39;lightish blue&#39;: &#39;#3d7afd&#39;, &#39;lightish green&#39;: &#39;#61e160&#39;,</span>
<span class="gd">-    &#39;lightish purple&#39;: &#39;#a552e6&#39;, &#39;lightish red&#39;: &#39;#fe2f4a&#39;, &#39;lilac&#39;:</span>
<span class="gd">-    &#39;#cea2fd&#39;, &#39;liliac&#39;: &#39;#c48efd&#39;, &#39;lime&#39;: &#39;#aaff32&#39;, &#39;lime green&#39;:</span>
<span class="gd">-    &#39;#89fe05&#39;, &#39;lime yellow&#39;: &#39;#d0fe1d&#39;, &#39;lipstick&#39;: &#39;#d5174e&#39;,</span>
<span class="gd">-    &#39;lipstick red&#39;: &#39;#c0022f&#39;, &#39;macaroni and cheese&#39;: &#39;#efb435&#39;, &#39;magenta&#39;:</span>
<span class="gd">-    &#39;#c20078&#39;, &#39;mahogany&#39;: &#39;#4a0100&#39;, &#39;maize&#39;: &#39;#f4d054&#39;, &#39;mango&#39;:</span>
<span class="gd">-    &#39;#ffa62b&#39;, &#39;manilla&#39;: &#39;#fffa86&#39;, &#39;marigold&#39;: &#39;#fcc006&#39;, &#39;marine&#39;:</span>
<span class="gd">-    &#39;#042e60&#39;, &#39;marine blue&#39;: &#39;#01386a&#39;, &#39;maroon&#39;: &#39;#650021&#39;, &#39;mauve&#39;:</span>
<span class="gd">-    &#39;#ae7181&#39;, &#39;medium blue&#39;: &#39;#2c6fbb&#39;, &#39;medium brown&#39;: &#39;#7f5112&#39;,</span>
<span class="gd">-    &#39;medium green&#39;: &#39;#39ad48&#39;, &#39;medium grey&#39;: &#39;#7d7f7c&#39;, &#39;medium pink&#39;:</span>
<span class="gd">-    &#39;#f36196&#39;, &#39;medium purple&#39;: &#39;#9e43a2&#39;, &#39;melon&#39;: &#39;#ff7855&#39;, &#39;merlot&#39;:</span>
<span class="gd">-    &#39;#730039&#39;, &#39;metallic blue&#39;: &#39;#4f738e&#39;, &#39;mid blue&#39;: &#39;#276ab3&#39;,</span>
<span class="gd">-    &#39;mid green&#39;: &#39;#50a747&#39;, &#39;midnight&#39;: &#39;#03012d&#39;, &#39;midnight blue&#39;:</span>
<span class="gd">-    &#39;#020035&#39;, &#39;midnight purple&#39;: &#39;#280137&#39;, &#39;military green&#39;: &#39;#667c3e&#39;,</span>
<span class="gd">-    &#39;milk chocolate&#39;: &#39;#7f4e1e&#39;, &#39;mint&#39;: &#39;#9ffeb0&#39;, &#39;mint green&#39;: &#39;#8fff9f&#39;,</span>
<span class="gd">-    &#39;minty green&#39;: &#39;#0bf77d&#39;, &#39;mocha&#39;: &#39;#9d7651&#39;, &#39;moss&#39;: &#39;#769958&#39;,</span>
<span class="gd">-    &#39;moss green&#39;: &#39;#658b38&#39;, &#39;mossy green&#39;: &#39;#638b27&#39;, &#39;mud&#39;: &#39;#735c12&#39;,</span>
<span class="gd">-    &#39;mud brown&#39;: &#39;#60460f&#39;, &#39;mud green&#39;: &#39;#606602&#39;, &#39;muddy brown&#39;:</span>
<span class="gd">-    &#39;#886806&#39;, &#39;muddy green&#39;: &#39;#657432&#39;, &#39;muddy yellow&#39;: &#39;#bfac05&#39;,</span>
<span class="gd">-    &#39;mulberry&#39;: &#39;#920a4e&#39;, &#39;murky green&#39;: &#39;#6c7a0e&#39;, &#39;mushroom&#39;: &#39;#ba9e88&#39;,</span>
<span class="gd">-    &#39;mustard&#39;: &#39;#ceb301&#39;, &#39;mustard brown&#39;: &#39;#ac7e04&#39;, &#39;mustard green&#39;:</span>
<span class="gd">-    &#39;#a8b504&#39;, &#39;mustard yellow&#39;: &#39;#d2bd0a&#39;, &#39;muted blue&#39;: &#39;#3b719f&#39;,</span>
<span class="gd">-    &#39;muted green&#39;: &#39;#5fa052&#39;, &#39;muted pink&#39;: &#39;#d1768f&#39;, &#39;muted purple&#39;:</span>
<span class="gd">-    &#39;#805b87&#39;, &#39;nasty green&#39;: &#39;#70b23f&#39;, &#39;navy&#39;: &#39;#01153e&#39;, &#39;navy blue&#39;:</span>
<span class="gd">-    &#39;#001146&#39;, &#39;navy green&#39;: &#39;#35530a&#39;, &#39;neon blue&#39;: &#39;#04d9ff&#39;,</span>
<span class="gd">-    &#39;neon green&#39;: &#39;#0cff0c&#39;, &#39;neon pink&#39;: &#39;#fe019a&#39;, &#39;neon purple&#39;:</span>
<span class="gd">-    &#39;#bc13fe&#39;, &#39;neon red&#39;: &#39;#ff073a&#39;, &#39;neon yellow&#39;: &#39;#cfff04&#39;, &#39;nice blue&#39;:</span>
<span class="gd">-    &#39;#107ab0&#39;, &#39;night blue&#39;: &#39;#040348&#39;, &#39;ocean&#39;: &#39;#017b92&#39;, &#39;ocean blue&#39;:</span>
<span class="gd">-    &#39;#03719c&#39;, &#39;ocean green&#39;: &#39;#3d9973&#39;, &#39;ocher&#39;: &#39;#bf9b0c&#39;, &#39;ochre&#39;:</span>
<span class="gd">-    &#39;#bf9005&#39;, &#39;ocre&#39;: &#39;#c69c04&#39;, &#39;off blue&#39;: &#39;#5684ae&#39;, &#39;off green&#39;:</span>
<span class="gd">-    &#39;#6ba353&#39;, &#39;off white&#39;: &#39;#ffffe4&#39;, &#39;off yellow&#39;: &#39;#f1f33f&#39;, &#39;old pink&#39;:</span>
<span class="gd">-    &#39;#c77986&#39;, &#39;old rose&#39;: &#39;#c87f89&#39;, &#39;olive&#39;: &#39;#6e750e&#39;, &#39;olive brown&#39;:</span>
<span class="gd">-    &#39;#645403&#39;, &#39;olive drab&#39;: &#39;#6f7632&#39;, &#39;olive green&#39;: &#39;#677a04&#39;,</span>
<span class="gd">-    &#39;olive yellow&#39;: &#39;#c2b709&#39;, &#39;orange&#39;: &#39;#f97306&#39;, &#39;orange brown&#39;:</span>
<span class="gd">-    &#39;#be6400&#39;, &#39;orange pink&#39;: &#39;#ff6f52&#39;, &#39;orange red&#39;: &#39;#fd411e&#39;,</span>
<span class="gd">-    &#39;orange yellow&#39;: &#39;#ffad01&#39;, &#39;orangeish&#39;: &#39;#fd8d49&#39;, &#39;orangered&#39;:</span>
<span class="gd">-    &#39;#fe420f&#39;, &#39;orangey brown&#39;: &#39;#b16002&#39;, &#39;orangey red&#39;: &#39;#fa4224&#39;,</span>
<span class="gd">-    &#39;orangey yellow&#39;: &#39;#fdb915&#39;, &#39;orangish&#39;: &#39;#fc824a&#39;, &#39;orangish brown&#39;:</span>
<span class="gd">-    &#39;#b25f03&#39;, &#39;orangish red&#39;: &#39;#f43605&#39;, &#39;orchid&#39;: &#39;#c875c4&#39;, &#39;pale&#39;:</span>
<span class="gd">-    &#39;#fff9d0&#39;, &#39;pale aqua&#39;: &#39;#b8ffeb&#39;, &#39;pale blue&#39;: &#39;#d0fefe&#39;, &#39;pale brown&#39;:</span>
<span class="gd">-    &#39;#b1916e&#39;, &#39;pale cyan&#39;: &#39;#b7fffa&#39;, &#39;pale gold&#39;: &#39;#fdde6c&#39;, &#39;pale green&#39;:</span>
<span class="gd">-    &#39;#c7fdb5&#39;, &#39;pale grey&#39;: &#39;#fdfdfe&#39;, &#39;pale lavender&#39;: &#39;#eecffe&#39;,</span>
<span class="gd">-    &#39;pale light green&#39;: &#39;#b1fc99&#39;, &#39;pale lilac&#39;: &#39;#e4cbff&#39;, &#39;pale lime&#39;:</span>
<span class="gd">-    &#39;#befd73&#39;, &#39;pale lime green&#39;: &#39;#b1ff65&#39;, &#39;pale magenta&#39;: &#39;#d767ad&#39;,</span>
<span class="gd">-    &#39;pale mauve&#39;: &#39;#fed0fc&#39;, &#39;pale olive&#39;: &#39;#b9cc81&#39;, &#39;pale olive green&#39;:</span>
<span class="gd">-    &#39;#b1d27b&#39;, &#39;pale orange&#39;: &#39;#ffa756&#39;, &#39;pale peach&#39;: &#39;#ffe5ad&#39;,</span>
<span class="gd">-    &#39;pale pink&#39;: &#39;#ffcfdc&#39;, &#39;pale purple&#39;: &#39;#b790d4&#39;, &#39;pale red&#39;: &#39;#d9544d&#39;,</span>
<span class="gd">-    &#39;pale rose&#39;: &#39;#fdc1c5&#39;, &#39;pale salmon&#39;: &#39;#ffb19a&#39;, &#39;pale sky blue&#39;:</span>
<span class="gd">-    &#39;#bdf6fe&#39;, &#39;pale teal&#39;: &#39;#82cbb2&#39;, &#39;pale turquoise&#39;: &#39;#a5fbd5&#39;,</span>
<span class="gd">-    &#39;pale violet&#39;: &#39;#ceaefa&#39;, &#39;pale yellow&#39;: &#39;#ffff84&#39;, &#39;parchment&#39;:</span>
<span class="gd">-    &#39;#fefcaf&#39;, &#39;pastel blue&#39;: &#39;#a2bffe&#39;, &#39;pastel green&#39;: &#39;#b0ff9d&#39;,</span>
<span class="gd">-    &#39;pastel orange&#39;: &#39;#ff964f&#39;, &#39;pastel pink&#39;: &#39;#ffbacd&#39;, &#39;pastel purple&#39;:</span>
<span class="gd">-    &#39;#caa0ff&#39;, &#39;pastel red&#39;: &#39;#db5856&#39;, &#39;pastel yellow&#39;: &#39;#fffe71&#39;, &#39;pea&#39;:</span>
<span class="gd">-    &#39;#a4bf20&#39;, &#39;pea green&#39;: &#39;#8eab12&#39;, &#39;pea soup&#39;: &#39;#929901&#39;,</span>
<span class="gd">-    &#39;pea soup green&#39;: &#39;#94a617&#39;, &#39;peach&#39;: &#39;#ffb07c&#39;, &#39;peachy pink&#39;:</span>
<span class="gd">-    &#39;#ff9a8a&#39;, &#39;peacock blue&#39;: &#39;#016795&#39;, &#39;pear&#39;: &#39;#cbf85f&#39;, &#39;periwinkle&#39;:</span>
<span class="gd">-    &#39;#8e82fe&#39;, &#39;periwinkle blue&#39;: &#39;#8f99fb&#39;, &#39;perrywinkle&#39;: &#39;#8f8ce7&#39;,</span>
<span class="gd">-    &#39;petrol&#39;: &#39;#005f6a&#39;, &#39;pig pink&#39;: &#39;#e78ea5&#39;, &#39;pine&#39;: &#39;#2b5d34&#39;,</span>
<span class="gd">-    &#39;pine green&#39;: &#39;#0a481e&#39;, &#39;pink&#39;: &#39;#ff81c0&#39;, &#39;pink purple&#39;: &#39;#db4bda&#39;,</span>
<span class="gd">-    &#39;pink red&#39;: &#39;#f5054f&#39;, &#39;pink/purple&#39;: &#39;#ef1de7&#39;, &#39;pinkish&#39;: &#39;#d46a7e&#39;,</span>
<span class="gd">-    &#39;pinkish brown&#39;: &#39;#b17261&#39;, &#39;pinkish grey&#39;: &#39;#c8aca9&#39;, &#39;pinkish orange&#39;:</span>
<span class="gd">-    &#39;#ff724c&#39;, &#39;pinkish purple&#39;: &#39;#d648d7&#39;, &#39;pinkish red&#39;: &#39;#f10c45&#39;,</span>
<span class="gd">-    &#39;pinkish tan&#39;: &#39;#d99b82&#39;, &#39;pinky&#39;: &#39;#fc86aa&#39;, &#39;pinky purple&#39;: &#39;#c94cbe&#39;,</span>
<span class="gd">-    &#39;pinky red&#39;: &#39;#fc2647&#39;, &#39;piss yellow&#39;: &#39;#ddd618&#39;, &#39;pistachio&#39;:</span>
<span class="gd">-    &#39;#c0fa8b&#39;, &#39;plum&#39;: &#39;#580f41&#39;, &#39;plum purple&#39;: &#39;#4e0550&#39;, &#39;poison green&#39;:</span>
<span class="gd">-    &#39;#40fd14&#39;, &#39;poo&#39;: &#39;#8f7303&#39;, &#39;poo brown&#39;: &#39;#885f01&#39;, &#39;poop&#39;: &#39;#7f5e00&#39;,</span>
<span class="gd">-    &#39;poop brown&#39;: &#39;#7a5901&#39;, &#39;poop green&#39;: &#39;#6f7c00&#39;, &#39;powder blue&#39;:</span>
<span class="gd">-    &#39;#b1d1fc&#39;, &#39;powder pink&#39;: &#39;#ffb2d0&#39;, &#39;primary blue&#39;: &#39;#0804f9&#39;,</span>
<span class="gd">-    &#39;prussian blue&#39;: &#39;#004577&#39;, &#39;puce&#39;: &#39;#a57e52&#39;, &#39;puke&#39;: &#39;#a5a502&#39;,</span>
<span class="gd">-    &#39;puke brown&#39;: &#39;#947706&#39;, &#39;puke green&#39;: &#39;#9aae07&#39;, &#39;puke yellow&#39;:</span>
<span class="gd">-    &#39;#c2be0e&#39;, &#39;pumpkin&#39;: &#39;#e17701&#39;, &#39;pumpkin orange&#39;: &#39;#fb7d07&#39;,</span>
<span class="gd">-    &#39;pure blue&#39;: &#39;#0203e2&#39;, &#39;purple&#39;: &#39;#7e1e9c&#39;, &#39;purple blue&#39;: &#39;#632de9&#39;,</span>
<span class="gd">-    &#39;purple brown&#39;: &#39;#673a3f&#39;, &#39;purple grey&#39;: &#39;#866f85&#39;, &#39;purple pink&#39;:</span>
<span class="gd">-    &#39;#e03fd8&#39;, &#39;purple red&#39;: &#39;#990147&#39;, &#39;purple/blue&#39;: &#39;#5d21d0&#39;,</span>
<span class="gd">-    &#39;purple/pink&#39;: &#39;#d725de&#39;, &#39;purpleish&#39;: &#39;#98568d&#39;, &#39;purpleish blue&#39;:</span>
<span class="gd">-    &#39;#6140ef&#39;, &#39;purpleish pink&#39;: &#39;#df4ec8&#39;, &#39;purpley&#39;: &#39;#8756e4&#39;,</span>
<span class="gd">-    &#39;purpley blue&#39;: &#39;#5f34e7&#39;, &#39;purpley grey&#39;: &#39;#947e94&#39;, &#39;purpley pink&#39;:</span>
<span class="gd">-    &#39;#c83cb9&#39;, &#39;purplish&#39;: &#39;#94568c&#39;, &#39;purplish blue&#39;: &#39;#601ef9&#39;,</span>
<span class="gd">-    &#39;purplish brown&#39;: &#39;#6b4247&#39;, &#39;purplish grey&#39;: &#39;#7a687f&#39;,</span>
<span class="gd">-    &#39;purplish pink&#39;: &#39;#ce5dae&#39;, &#39;purplish red&#39;: &#39;#b0054b&#39;, &#39;purply&#39;:</span>
<span class="gd">-    &#39;#983fb2&#39;, &#39;purply blue&#39;: &#39;#661aee&#39;, &#39;purply pink&#39;: &#39;#f075e6&#39;, &#39;putty&#39;:</span>
<span class="gd">-    &#39;#beae8a&#39;, &#39;racing green&#39;: &#39;#014600&#39;, &#39;radioactive green&#39;: &#39;#2cfa1f&#39;,</span>
<span class="gd">-    &#39;raspberry&#39;: &#39;#b00149&#39;, &#39;raw sienna&#39;: &#39;#9a6200&#39;, &#39;raw umber&#39;: &#39;#a75e09&#39;,</span>
<span class="gd">-    &#39;really light blue&#39;: &#39;#d4ffff&#39;, &#39;red&#39;: &#39;#e50000&#39;, &#39;red brown&#39;:</span>
<span class="gd">-    &#39;#8b2e16&#39;, &#39;red orange&#39;: &#39;#fd3c06&#39;, &#39;red pink&#39;: &#39;#fa2a55&#39;, &#39;red purple&#39;:</span>
<span class="gd">-    &#39;#820747&#39;, &#39;red violet&#39;: &#39;#9e0168&#39;, &#39;red wine&#39;: &#39;#8c0034&#39;, &#39;reddish&#39;:</span>
<span class="gd">-    &#39;#c44240&#39;, &#39;reddish brown&#39;: &#39;#7f2b0a&#39;, &#39;reddish grey&#39;: &#39;#997570&#39;,</span>
<span class="gd">-    &#39;reddish orange&#39;: &#39;#f8481c&#39;, &#39;reddish pink&#39;: &#39;#fe2c54&#39;,</span>
<span class="gd">-    &#39;reddish purple&#39;: &#39;#910951&#39;, &#39;reddy brown&#39;: &#39;#6e1005&#39;, &#39;rich blue&#39;:</span>
<span class="gd">-    &#39;#021bf9&#39;, &#39;rich purple&#39;: &#39;#720058&#39;, &#39;robin egg blue&#39;: &#39;#8af1fe&#39;,</span>
<span class="gd">-    &quot;robin&#39;s egg&quot;: &#39;#6dedfd&#39;, &quot;robin&#39;s egg blue&quot;: &#39;#98eff9&#39;, &#39;rosa&#39;:</span>
<span class="gd">-    &#39;#fe86a4&#39;, &#39;rose&#39;: &#39;#cf6275&#39;, &#39;rose pink&#39;: &#39;#f7879a&#39;, &#39;rose red&#39;:</span>
<span class="gd">-    &#39;#be013c&#39;, &#39;rosy pink&#39;: &#39;#f6688e&#39;, &#39;rouge&#39;: &#39;#ab1239&#39;, &#39;royal&#39;:</span>
<span class="gd">-    &#39;#0c1793&#39;, &#39;royal blue&#39;: &#39;#0504aa&#39;, &#39;royal purple&#39;: &#39;#4b006e&#39;, &#39;ruby&#39;:</span>
<span class="gd">-    &#39;#ca0147&#39;, &#39;russet&#39;: &#39;#a13905&#39;, &#39;rust&#39;: &#39;#a83c09&#39;, &#39;rust brown&#39;:</span>
<span class="gd">-    &#39;#8b3103&#39;, &#39;rust orange&#39;: &#39;#c45508&#39;, &#39;rust red&#39;: &#39;#aa2704&#39;,</span>
<span class="gd">-    &#39;rusty orange&#39;: &#39;#cd5909&#39;, &#39;rusty red&#39;: &#39;#af2f0d&#39;, &#39;saffron&#39;: &#39;#feb209&#39;,</span>
<span class="gd">-    &#39;sage&#39;: &#39;#87ae73&#39;, &#39;sage green&#39;: &#39;#88b378&#39;, &#39;salmon&#39;: &#39;#ff796c&#39;,</span>
<span class="gd">-    &#39;salmon pink&#39;: &#39;#fe7b7c&#39;, &#39;sand&#39;: &#39;#e2ca76&#39;, &#39;sand brown&#39;: &#39;#cba560&#39;,</span>
<span class="gd">-    &#39;sand yellow&#39;: &#39;#fce166&#39;, &#39;sandstone&#39;: &#39;#c9ae74&#39;, &#39;sandy&#39;: &#39;#f1da7a&#39;,</span>
<span class="gd">-    &#39;sandy brown&#39;: &#39;#c4a661&#39;, &#39;sandy yellow&#39;: &#39;#fdee73&#39;, &#39;sap green&#39;:</span>
<span class="gd">-    &#39;#5c8b15&#39;, &#39;sapphire&#39;: &#39;#2138ab&#39;, &#39;scarlet&#39;: &#39;#be0119&#39;, &#39;sea&#39;:</span>
<span class="gd">-    &#39;#3c9992&#39;, &#39;sea blue&#39;: &#39;#047495&#39;, &#39;sea green&#39;: &#39;#53fca1&#39;, &#39;seafoam&#39;:</span>
<span class="gd">-    &#39;#80f9ad&#39;, &#39;seafoam blue&#39;: &#39;#78d1b6&#39;, &#39;seafoam green&#39;: &#39;#7af9ab&#39;,</span>
<span class="gd">-    &#39;seaweed&#39;: &#39;#18d17b&#39;, &#39;seaweed green&#39;: &#39;#35ad6b&#39;, &#39;sepia&#39;: &#39;#985e2b&#39;,</span>
<span class="gd">-    &#39;shamrock&#39;: &#39;#01b44c&#39;, &#39;shamrock green&#39;: &#39;#02c14d&#39;, &#39;shit&#39;: &#39;#7f5f00&#39;,</span>
<span class="gd">-    &#39;shit brown&#39;: &#39;#7b5804&#39;, &#39;shit green&#39;: &#39;#758000&#39;, &#39;shocking pink&#39;:</span>
<span class="gd">-    &#39;#fe02a2&#39;, &#39;sick green&#39;: &#39;#9db92c&#39;, &#39;sickly green&#39;: &#39;#94b21c&#39;,</span>
<span class="gd">-    &#39;sickly yellow&#39;: &#39;#d0e429&#39;, &#39;sienna&#39;: &#39;#a9561e&#39;, &#39;silver&#39;: &#39;#c5c9c7&#39;,</span>
<span class="gd">-    &#39;sky&#39;: &#39;#82cafc&#39;, &#39;sky blue&#39;: &#39;#75bbfd&#39;, &#39;slate&#39;: &#39;#516572&#39;,</span>
<span class="gd">-    &#39;slate blue&#39;: &#39;#5b7c99&#39;, &#39;slate green&#39;: &#39;#658d6d&#39;, &#39;slate grey&#39;:</span>
<span class="gd">-    &#39;#59656d&#39;, &#39;slime green&#39;: &#39;#99cc04&#39;, &#39;snot&#39;: &#39;#acbb0d&#39;, &#39;snot green&#39;:</span>
<span class="gd">-    &#39;#9dc100&#39;, &#39;soft blue&#39;: &#39;#6488ea&#39;, &#39;soft green&#39;: &#39;#6fc276&#39;, &#39;soft pink&#39;:</span>
<span class="gd">-    &#39;#fdb0c0&#39;, &#39;soft purple&#39;: &#39;#a66fb5&#39;, &#39;spearmint&#39;: &#39;#1ef876&#39;,</span>
<span class="gd">-    &#39;spring green&#39;: &#39;#a9f971&#39;, &#39;spruce&#39;: &#39;#0a5f38&#39;, &#39;squash&#39;: &#39;#f2ab15&#39;,</span>
<span class="gd">-    &#39;steel&#39;: &#39;#738595&#39;, &#39;steel blue&#39;: &#39;#5a7d9a&#39;, &#39;steel grey&#39;: &#39;#6f828a&#39;,</span>
<span class="gd">-    &#39;stone&#39;: &#39;#ada587&#39;, &#39;stormy blue&#39;: &#39;#507b9c&#39;, &#39;straw&#39;: &#39;#fcf679&#39;,</span>
<span class="gd">-    &#39;strawberry&#39;: &#39;#fb2943&#39;, &#39;strong blue&#39;: &#39;#0c06f7&#39;, &#39;strong pink&#39;:</span>
<span class="gd">-    &#39;#ff0789&#39;, &#39;sun yellow&#39;: &#39;#ffdf22&#39;, &#39;sunflower&#39;: &#39;#ffc512&#39;,</span>
<span class="gd">-    &#39;sunflower yellow&#39;: &#39;#ffda03&#39;, &#39;sunny yellow&#39;: &#39;#fff917&#39;,</span>
<span class="gd">-    &#39;sunshine yellow&#39;: &#39;#fffd37&#39;, &#39;swamp&#39;: &#39;#698339&#39;, &#39;swamp green&#39;:</span>
<span class="gd">-    &#39;#748500&#39;, &#39;tan&#39;: &#39;#d1b26f&#39;, &#39;tan brown&#39;: &#39;#ab7e4c&#39;, &#39;tan green&#39;:</span>
<span class="gd">-    &#39;#a9be70&#39;, &#39;tangerine&#39;: &#39;#ff9408&#39;, &#39;taupe&#39;: &#39;#b9a281&#39;, &#39;tea&#39;: &#39;#65ab7c&#39;,</span>
<span class="gd">-    &#39;tea green&#39;: &#39;#bdf8a3&#39;, &#39;teal&#39;: &#39;#029386&#39;, &#39;teal blue&#39;: &#39;#01889f&#39;,</span>
<span class="gd">-    &#39;teal green&#39;: &#39;#25a36f&#39;, &#39;tealish&#39;: &#39;#24bca8&#39;, &#39;tealish green&#39;:</span>
<span class="gd">-    &#39;#0cdc73&#39;, &#39;terra cotta&#39;: &#39;#c9643b&#39;, &#39;terracota&#39;: &#39;#cb6843&#39;,</span>
<span class="gd">-    &#39;terracotta&#39;: &#39;#ca6641&#39;, &#39;tiffany blue&#39;: &#39;#7bf2da&#39;, &#39;tomato&#39;: &#39;#ef4026&#39;,</span>
<span class="gd">-    &#39;tomato red&#39;: &#39;#ec2d01&#39;, &#39;topaz&#39;: &#39;#13bbaf&#39;, &#39;toupe&#39;: &#39;#c7ac7d&#39;,</span>
<span class="gd">-    &#39;toxic green&#39;: &#39;#61de2a&#39;, &#39;tree green&#39;: &#39;#2a7e19&#39;, &#39;true blue&#39;:</span>
<span class="gd">-    &#39;#010fcc&#39;, &#39;true green&#39;: &#39;#089404&#39;, &#39;turquoise&#39;: &#39;#06c2ac&#39;,</span>
<span class="gd">-    &#39;turquoise blue&#39;: &#39;#06b1c4&#39;, &#39;turquoise green&#39;: &#39;#04f489&#39;,</span>
<span class="gd">-    &#39;turtle green&#39;: &#39;#75b84f&#39;, &#39;twilight&#39;: &#39;#4e518b&#39;, &#39;twilight blue&#39;:</span>
<span class="gd">-    &#39;#0a437a&#39;, &#39;ugly blue&#39;: &#39;#31668a&#39;, &#39;ugly brown&#39;: &#39;#7d7103&#39;,</span>
<span class="gd">-    &#39;ugly green&#39;: &#39;#7a9703&#39;, &#39;ugly pink&#39;: &#39;#cd7584&#39;, &#39;ugly purple&#39;:</span>
<span class="gd">-    &#39;#a442a0&#39;, &#39;ugly yellow&#39;: &#39;#d0c101&#39;, &#39;ultramarine&#39;: &#39;#2000b1&#39;,</span>
<span class="gd">-    &#39;ultramarine blue&#39;: &#39;#1805db&#39;, &#39;umber&#39;: &#39;#b26400&#39;, &#39;velvet&#39;: &#39;#750851&#39;,</span>
<span class="gd">-    &#39;vermillion&#39;: &#39;#f4320c&#39;, &#39;very dark blue&#39;: &#39;#000133&#39;, &#39;very dark brown&#39;:</span>
<span class="gd">-    &#39;#1d0200&#39;, &#39;very dark green&#39;: &#39;#062e03&#39;, &#39;very dark purple&#39;: &#39;#2a0134&#39;,</span>
<span class="gd">-    &#39;very light blue&#39;: &#39;#d5ffff&#39;, &#39;very light brown&#39;: &#39;#d3b683&#39;,</span>
<span class="gd">-    &#39;very light green&#39;: &#39;#d1ffbd&#39;, &#39;very light pink&#39;: &#39;#fff4f2&#39;,</span>
<span class="gd">-    &#39;very light purple&#39;: &#39;#f6cefc&#39;, &#39;very pale blue&#39;: &#39;#d6fffe&#39;,</span>
<span class="gd">-    &#39;very pale green&#39;: &#39;#cffdbc&#39;, &#39;vibrant blue&#39;: &#39;#0339f8&#39;,</span>
<span class="gd">-    &#39;vibrant green&#39;: &#39;#0add08&#39;, &#39;vibrant purple&#39;: &#39;#ad03de&#39;, &#39;violet&#39;:</span>
<span class="gd">-    &#39;#9a0eea&#39;, &#39;violet blue&#39;: &#39;#510ac9&#39;, &#39;violet pink&#39;: &#39;#fb5ffc&#39;,</span>
<span class="gd">-    &#39;violet red&#39;: &#39;#a50055&#39;, &#39;viridian&#39;: &#39;#1e9167&#39;, &#39;vivid blue&#39;: &#39;#152eff&#39;,</span>
<span class="gd">-    &#39;vivid green&#39;: &#39;#2fef10&#39;, &#39;vivid purple&#39;: &#39;#9900fa&#39;, &#39;vomit&#39;: &#39;#a2a415&#39;,</span>
<span class="gd">-    &#39;vomit green&#39;: &#39;#89a203&#39;, &#39;vomit yellow&#39;: &#39;#c7c10c&#39;, &#39;warm blue&#39;:</span>
<span class="gd">-    &#39;#4b57db&#39;, &#39;warm brown&#39;: &#39;#964e02&#39;, &#39;warm grey&#39;: &#39;#978a84&#39;, &#39;warm pink&#39;:</span>
<span class="gd">-    &#39;#fb5581&#39;, &#39;warm purple&#39;: &#39;#952e8f&#39;, &#39;washed out green&#39;: &#39;#bcf5a6&#39;,</span>
<span class="gd">-    &#39;water blue&#39;: &#39;#0e87cc&#39;, &#39;watermelon&#39;: &#39;#fd4659&#39;, &#39;weird green&#39;:</span>
<span class="gd">-    &#39;#3ae57f&#39;, &#39;wheat&#39;: &#39;#fbdd7e&#39;, &#39;white&#39;: &#39;#ffffff&#39;, &#39;windows blue&#39;:</span>
<span class="gd">-    &#39;#3778bf&#39;, &#39;wine&#39;: &#39;#80013f&#39;, &#39;wine red&#39;: &#39;#7b0323&#39;, &#39;wintergreen&#39;:</span>
<span class="gd">-    &#39;#20f986&#39;, &#39;wisteria&#39;: &#39;#a87dc2&#39;, &#39;yellow&#39;: &#39;#ffff14&#39;, &#39;yellow brown&#39;:</span>
<span class="gd">-    &#39;#b79400&#39;, &#39;yellow green&#39;: &#39;#c0fb2d&#39;, &#39;yellow ochre&#39;: &#39;#cb9d06&#39;,</span>
<span class="gd">-    &#39;yellow orange&#39;: &#39;#fcb001&#39;, &#39;yellow tan&#39;: &#39;#ffe36e&#39;, &#39;yellow/green&#39;:</span>
<span class="gd">-    &#39;#c8fd3d&#39;, &#39;yellowgreen&#39;: &#39;#bbf90f&#39;, &#39;yellowish&#39;: &#39;#faee66&#39;,</span>
<span class="gd">-    &#39;yellowish brown&#39;: &#39;#9b7a01&#39;, &#39;yellowish green&#39;: &#39;#b0dd16&#39;,</span>
<span class="gd">-    &#39;yellowish orange&#39;: &#39;#ffab0f&#39;, &#39;yellowish tan&#39;: &#39;#fcfc81&#39;,</span>
<span class="gd">-    &#39;yellowy brown&#39;: &#39;#ae8b0c&#39;, &#39;yellowy green&#39;: &#39;#bff128&#39;}</span>
<span class="gi">+xkcd_rgb = {&#39;acid green&#39;: &#39;#8ffe09&#39;,</span>
<span class="gi">+            &#39;adobe&#39;: &#39;#bd6c48&#39;,</span>
<span class="gi">+            &#39;algae&#39;: &#39;#54ac68&#39;,</span>
<span class="gi">+            &#39;algae green&#39;: &#39;#21c36f&#39;,</span>
<span class="gi">+            &#39;almost black&#39;: &#39;#070d0d&#39;,</span>
<span class="gi">+            &#39;amber&#39;: &#39;#feb308&#39;,</span>
<span class="gi">+            &#39;amethyst&#39;: &#39;#9b5fc0&#39;,</span>
<span class="gi">+            &#39;apple&#39;: &#39;#6ecb3c&#39;,</span>
<span class="gi">+            &#39;apple green&#39;: &#39;#76cd26&#39;,</span>
<span class="gi">+            &#39;apricot&#39;: &#39;#ffb16d&#39;,</span>
<span class="gi">+            &#39;aqua&#39;: &#39;#13eac9&#39;,</span>
<span class="gi">+            &#39;aqua blue&#39;: &#39;#02d8e9&#39;,</span>
<span class="gi">+            &#39;aqua green&#39;: &#39;#12e193&#39;,</span>
<span class="gi">+            &#39;aqua marine&#39;: &#39;#2ee8bb&#39;,</span>
<span class="gi">+            &#39;aquamarine&#39;: &#39;#04d8b2&#39;,</span>
<span class="gi">+            &#39;army green&#39;: &#39;#4b5d16&#39;,</span>
<span class="gi">+            &#39;asparagus&#39;: &#39;#77ab56&#39;,</span>
<span class="gi">+            &#39;aubergine&#39;: &#39;#3d0734&#39;,</span>
<span class="gi">+            &#39;auburn&#39;: &#39;#9a3001&#39;,</span>
<span class="gi">+            &#39;avocado&#39;: &#39;#90b134&#39;,</span>
<span class="gi">+            &#39;avocado green&#39;: &#39;#87a922&#39;,</span>
<span class="gi">+            &#39;azul&#39;: &#39;#1d5dec&#39;,</span>
<span class="gi">+            &#39;azure&#39;: &#39;#069af3&#39;,</span>
<span class="gi">+            &#39;baby blue&#39;: &#39;#a2cffe&#39;,</span>
<span class="gi">+            &#39;baby green&#39;: &#39;#8cff9e&#39;,</span>
<span class="gi">+            &#39;baby pink&#39;: &#39;#ffb7ce&#39;,</span>
<span class="gi">+            &#39;baby poo&#39;: &#39;#ab9004&#39;,</span>
<span class="gi">+            &#39;baby poop&#39;: &#39;#937c00&#39;,</span>
<span class="gi">+            &#39;baby poop green&#39;: &#39;#8f9805&#39;,</span>
<span class="gi">+            &#39;baby puke green&#39;: &#39;#b6c406&#39;,</span>
<span class="gi">+            &#39;baby purple&#39;: &#39;#ca9bf7&#39;,</span>
<span class="gi">+            &#39;baby shit brown&#39;: &#39;#ad900d&#39;,</span>
<span class="gi">+            &#39;baby shit green&#39;: &#39;#889717&#39;,</span>
<span class="gi">+            &#39;banana&#39;: &#39;#ffff7e&#39;,</span>
<span class="gi">+            &#39;banana yellow&#39;: &#39;#fafe4b&#39;,</span>
<span class="gi">+            &#39;barbie pink&#39;: &#39;#fe46a5&#39;,</span>
<span class="gi">+            &#39;barf green&#39;: &#39;#94ac02&#39;,</span>
<span class="gi">+            &#39;barney&#39;: &#39;#ac1db8&#39;,</span>
<span class="gi">+            &#39;barney purple&#39;: &#39;#a00498&#39;,</span>
<span class="gi">+            &#39;battleship grey&#39;: &#39;#6b7c85&#39;,</span>
<span class="gi">+            &#39;beige&#39;: &#39;#e6daa6&#39;,</span>
<span class="gi">+            &#39;berry&#39;: &#39;#990f4b&#39;,</span>
<span class="gi">+            &#39;bile&#39;: &#39;#b5c306&#39;,</span>
<span class="gi">+            &#39;black&#39;: &#39;#000000&#39;,</span>
<span class="gi">+            &#39;bland&#39;: &#39;#afa88b&#39;,</span>
<span class="gi">+            &#39;blood&#39;: &#39;#770001&#39;,</span>
<span class="gi">+            &#39;blood orange&#39;: &#39;#fe4b03&#39;,</span>
<span class="gi">+            &#39;blood red&#39;: &#39;#980002&#39;,</span>
<span class="gi">+            &#39;blue&#39;: &#39;#0343df&#39;,</span>
<span class="gi">+            &#39;blue blue&#39;: &#39;#2242c7&#39;,</span>
<span class="gi">+            &#39;blue green&#39;: &#39;#137e6d&#39;,</span>
<span class="gi">+            &#39;blue grey&#39;: &#39;#607c8e&#39;,</span>
<span class="gi">+            &#39;blue purple&#39;: &#39;#5729ce&#39;,</span>
<span class="gi">+            &#39;blue violet&#39;: &#39;#5d06e9&#39;,</span>
<span class="gi">+            &#39;blue with a hint of purple&#39;: &#39;#533cc6&#39;,</span>
<span class="gi">+            &#39;blue/green&#39;: &#39;#0f9b8e&#39;,</span>
<span class="gi">+            &#39;blue/grey&#39;: &#39;#758da3&#39;,</span>
<span class="gi">+            &#39;blue/purple&#39;: &#39;#5a06ef&#39;,</span>
<span class="gi">+            &#39;blueberry&#39;: &#39;#464196&#39;,</span>
<span class="gi">+            &#39;bluegreen&#39;: &#39;#017a79&#39;,</span>
<span class="gi">+            &#39;bluegrey&#39;: &#39;#85a3b2&#39;,</span>
<span class="gi">+            &#39;bluey green&#39;: &#39;#2bb179&#39;,</span>
<span class="gi">+            &#39;bluey grey&#39;: &#39;#89a0b0&#39;,</span>
<span class="gi">+            &#39;bluey purple&#39;: &#39;#6241c7&#39;,</span>
<span class="gi">+            &#39;bluish&#39;: &#39;#2976bb&#39;,</span>
<span class="gi">+            &#39;bluish green&#39;: &#39;#10a674&#39;,</span>
<span class="gi">+            &#39;bluish grey&#39;: &#39;#748b97&#39;,</span>
<span class="gi">+            &#39;bluish purple&#39;: &#39;#703be7&#39;,</span>
<span class="gi">+            &#39;blurple&#39;: &#39;#5539cc&#39;,</span>
<span class="gi">+            &#39;blush&#39;: &#39;#f29e8e&#39;,</span>
<span class="gi">+            &#39;blush pink&#39;: &#39;#fe828c&#39;,</span>
<span class="gi">+            &#39;booger&#39;: &#39;#9bb53c&#39;,</span>
<span class="gi">+            &#39;booger green&#39;: &#39;#96b403&#39;,</span>
<span class="gi">+            &#39;bordeaux&#39;: &#39;#7b002c&#39;,</span>
<span class="gi">+            &#39;boring green&#39;: &#39;#63b365&#39;,</span>
<span class="gi">+            &#39;bottle green&#39;: &#39;#044a05&#39;,</span>
<span class="gi">+            &#39;brick&#39;: &#39;#a03623&#39;,</span>
<span class="gi">+            &#39;brick orange&#39;: &#39;#c14a09&#39;,</span>
<span class="gi">+            &#39;brick red&#39;: &#39;#8f1402&#39;,</span>
<span class="gi">+            &#39;bright aqua&#39;: &#39;#0bf9ea&#39;,</span>
<span class="gi">+            &#39;bright blue&#39;: &#39;#0165fc&#39;,</span>
<span class="gi">+            &#39;bright cyan&#39;: &#39;#41fdfe&#39;,</span>
<span class="gi">+            &#39;bright green&#39;: &#39;#01ff07&#39;,</span>
<span class="gi">+            &#39;bright lavender&#39;: &#39;#c760ff&#39;,</span>
<span class="gi">+            &#39;bright light blue&#39;: &#39;#26f7fd&#39;,</span>
<span class="gi">+            &#39;bright light green&#39;: &#39;#2dfe54&#39;,</span>
<span class="gi">+            &#39;bright lilac&#39;: &#39;#c95efb&#39;,</span>
<span class="gi">+            &#39;bright lime&#39;: &#39;#87fd05&#39;,</span>
<span class="gi">+            &#39;bright lime green&#39;: &#39;#65fe08&#39;,</span>
<span class="gi">+            &#39;bright magenta&#39;: &#39;#ff08e8&#39;,</span>
<span class="gi">+            &#39;bright olive&#39;: &#39;#9cbb04&#39;,</span>
<span class="gi">+            &#39;bright orange&#39;: &#39;#ff5b00&#39;,</span>
<span class="gi">+            &#39;bright pink&#39;: &#39;#fe01b1&#39;,</span>
<span class="gi">+            &#39;bright purple&#39;: &#39;#be03fd&#39;,</span>
<span class="gi">+            &#39;bright red&#39;: &#39;#ff000d&#39;,</span>
<span class="gi">+            &#39;bright sea green&#39;: &#39;#05ffa6&#39;,</span>
<span class="gi">+            &#39;bright sky blue&#39;: &#39;#02ccfe&#39;,</span>
<span class="gi">+            &#39;bright teal&#39;: &#39;#01f9c6&#39;,</span>
<span class="gi">+            &#39;bright turquoise&#39;: &#39;#0ffef9&#39;,</span>
<span class="gi">+            &#39;bright violet&#39;: &#39;#ad0afd&#39;,</span>
<span class="gi">+            &#39;bright yellow&#39;: &#39;#fffd01&#39;,</span>
<span class="gi">+            &#39;bright yellow green&#39;: &#39;#9dff00&#39;,</span>
<span class="gi">+            &#39;british racing green&#39;: &#39;#05480d&#39;,</span>
<span class="gi">+            &#39;bronze&#39;: &#39;#a87900&#39;,</span>
<span class="gi">+            &#39;brown&#39;: &#39;#653700&#39;,</span>
<span class="gi">+            &#39;brown green&#39;: &#39;#706c11&#39;,</span>
<span class="gi">+            &#39;brown grey&#39;: &#39;#8d8468&#39;,</span>
<span class="gi">+            &#39;brown orange&#39;: &#39;#b96902&#39;,</span>
<span class="gi">+            &#39;brown red&#39;: &#39;#922b05&#39;,</span>
<span class="gi">+            &#39;brown yellow&#39;: &#39;#b29705&#39;,</span>
<span class="gi">+            &#39;brownish&#39;: &#39;#9c6d57&#39;,</span>
<span class="gi">+            &#39;brownish green&#39;: &#39;#6a6e09&#39;,</span>
<span class="gi">+            &#39;brownish grey&#39;: &#39;#86775f&#39;,</span>
<span class="gi">+            &#39;brownish orange&#39;: &#39;#cb7723&#39;,</span>
<span class="gi">+            &#39;brownish pink&#39;: &#39;#c27e79&#39;,</span>
<span class="gi">+            &#39;brownish purple&#39;: &#39;#76424e&#39;,</span>
<span class="gi">+            &#39;brownish red&#39;: &#39;#9e3623&#39;,</span>
<span class="gi">+            &#39;brownish yellow&#39;: &#39;#c9b003&#39;,</span>
<span class="gi">+            &#39;browny green&#39;: &#39;#6f6c0a&#39;,</span>
<span class="gi">+            &#39;browny orange&#39;: &#39;#ca6b02&#39;,</span>
<span class="gi">+            &#39;bruise&#39;: &#39;#7e4071&#39;,</span>
<span class="gi">+            &#39;bubble gum pink&#39;: &#39;#ff69af&#39;,</span>
<span class="gi">+            &#39;bubblegum&#39;: &#39;#ff6cb5&#39;,</span>
<span class="gi">+            &#39;bubblegum pink&#39;: &#39;#fe83cc&#39;,</span>
<span class="gi">+            &#39;buff&#39;: &#39;#fef69e&#39;,</span>
<span class="gi">+            &#39;burgundy&#39;: &#39;#610023&#39;,</span>
<span class="gi">+            &#39;burnt orange&#39;: &#39;#c04e01&#39;,</span>
<span class="gi">+            &#39;burnt red&#39;: &#39;#9f2305&#39;,</span>
<span class="gi">+            &#39;burnt siena&#39;: &#39;#b75203&#39;,</span>
<span class="gi">+            &#39;burnt sienna&#39;: &#39;#b04e0f&#39;,</span>
<span class="gi">+            &#39;burnt umber&#39;: &#39;#a0450e&#39;,</span>
<span class="gi">+            &#39;burnt yellow&#39;: &#39;#d5ab09&#39;,</span>
<span class="gi">+            &#39;burple&#39;: &#39;#6832e3&#39;,</span>
<span class="gi">+            &#39;butter&#39;: &#39;#ffff81&#39;,</span>
<span class="gi">+            &#39;butter yellow&#39;: &#39;#fffd74&#39;,</span>
<span class="gi">+            &#39;butterscotch&#39;: &#39;#fdb147&#39;,</span>
<span class="gi">+            &#39;cadet blue&#39;: &#39;#4e7496&#39;,</span>
<span class="gi">+            &#39;camel&#39;: &#39;#c69f59&#39;,</span>
<span class="gi">+            &#39;camo&#39;: &#39;#7f8f4e&#39;,</span>
<span class="gi">+            &#39;camo green&#39;: &#39;#526525&#39;,</span>
<span class="gi">+            &#39;camouflage green&#39;: &#39;#4b6113&#39;,</span>
<span class="gi">+            &#39;canary&#39;: &#39;#fdff63&#39;,</span>
<span class="gi">+            &#39;canary yellow&#39;: &#39;#fffe40&#39;,</span>
<span class="gi">+            &#39;candy pink&#39;: &#39;#ff63e9&#39;,</span>
<span class="gi">+            &#39;caramel&#39;: &#39;#af6f09&#39;,</span>
<span class="gi">+            &#39;carmine&#39;: &#39;#9d0216&#39;,</span>
<span class="gi">+            &#39;carnation&#39;: &#39;#fd798f&#39;,</span>
<span class="gi">+            &#39;carnation pink&#39;: &#39;#ff7fa7&#39;,</span>
<span class="gi">+            &#39;carolina blue&#39;: &#39;#8ab8fe&#39;,</span>
<span class="gi">+            &#39;celadon&#39;: &#39;#befdb7&#39;,</span>
<span class="gi">+            &#39;celery&#39;: &#39;#c1fd95&#39;,</span>
<span class="gi">+            &#39;cement&#39;: &#39;#a5a391&#39;,</span>
<span class="gi">+            &#39;cerise&#39;: &#39;#de0c62&#39;,</span>
<span class="gi">+            &#39;cerulean&#39;: &#39;#0485d1&#39;,</span>
<span class="gi">+            &#39;cerulean blue&#39;: &#39;#056eee&#39;,</span>
<span class="gi">+            &#39;charcoal&#39;: &#39;#343837&#39;,</span>
<span class="gi">+            &#39;charcoal grey&#39;: &#39;#3c4142&#39;,</span>
<span class="gi">+            &#39;chartreuse&#39;: &#39;#c1f80a&#39;,</span>
<span class="gi">+            &#39;cherry&#39;: &#39;#cf0234&#39;,</span>
<span class="gi">+            &#39;cherry red&#39;: &#39;#f7022a&#39;,</span>
<span class="gi">+            &#39;chestnut&#39;: &#39;#742802&#39;,</span>
<span class="gi">+            &#39;chocolate&#39;: &#39;#3d1c02&#39;,</span>
<span class="gi">+            &#39;chocolate brown&#39;: &#39;#411900&#39;,</span>
<span class="gi">+            &#39;cinnamon&#39;: &#39;#ac4f06&#39;,</span>
<span class="gi">+            &#39;claret&#39;: &#39;#680018&#39;,</span>
<span class="gi">+            &#39;clay&#39;: &#39;#b66a50&#39;,</span>
<span class="gi">+            &#39;clay brown&#39;: &#39;#b2713d&#39;,</span>
<span class="gi">+            &#39;clear blue&#39;: &#39;#247afd&#39;,</span>
<span class="gi">+            &#39;cloudy blue&#39;: &#39;#acc2d9&#39;,</span>
<span class="gi">+            &#39;cobalt&#39;: &#39;#1e488f&#39;,</span>
<span class="gi">+            &#39;cobalt blue&#39;: &#39;#030aa7&#39;,</span>
<span class="gi">+            &#39;cocoa&#39;: &#39;#875f42&#39;,</span>
<span class="gi">+            &#39;coffee&#39;: &#39;#a6814c&#39;,</span>
<span class="gi">+            &#39;cool blue&#39;: &#39;#4984b8&#39;,</span>
<span class="gi">+            &#39;cool green&#39;: &#39;#33b864&#39;,</span>
<span class="gi">+            &#39;cool grey&#39;: &#39;#95a3a6&#39;,</span>
<span class="gi">+            &#39;copper&#39;: &#39;#b66325&#39;,</span>
<span class="gi">+            &#39;coral&#39;: &#39;#fc5a50&#39;,</span>
<span class="gi">+            &#39;coral pink&#39;: &#39;#ff6163&#39;,</span>
<span class="gi">+            &#39;cornflower&#39;: &#39;#6a79f7&#39;,</span>
<span class="gi">+            &#39;cornflower blue&#39;: &#39;#5170d7&#39;,</span>
<span class="gi">+            &#39;cranberry&#39;: &#39;#9e003a&#39;,</span>
<span class="gi">+            &#39;cream&#39;: &#39;#ffffc2&#39;,</span>
<span class="gi">+            &#39;creme&#39;: &#39;#ffffb6&#39;,</span>
<span class="gi">+            &#39;crimson&#39;: &#39;#8c000f&#39;,</span>
<span class="gi">+            &#39;custard&#39;: &#39;#fffd78&#39;,</span>
<span class="gi">+            &#39;cyan&#39;: &#39;#00ffff&#39;,</span>
<span class="gi">+            &#39;dandelion&#39;: &#39;#fedf08&#39;,</span>
<span class="gi">+            &#39;dark&#39;: &#39;#1b2431&#39;,</span>
<span class="gi">+            &#39;dark aqua&#39;: &#39;#05696b&#39;,</span>
<span class="gi">+            &#39;dark aquamarine&#39;: &#39;#017371&#39;,</span>
<span class="gi">+            &#39;dark beige&#39;: &#39;#ac9362&#39;,</span>
<span class="gi">+            &#39;dark blue&#39;: &#39;#00035b&#39;,</span>
<span class="gi">+            &#39;dark blue green&#39;: &#39;#005249&#39;,</span>
<span class="gi">+            &#39;dark blue grey&#39;: &#39;#1f3b4d&#39;,</span>
<span class="gi">+            &#39;dark brown&#39;: &#39;#341c02&#39;,</span>
<span class="gi">+            &#39;dark coral&#39;: &#39;#cf524e&#39;,</span>
<span class="gi">+            &#39;dark cream&#39;: &#39;#fff39a&#39;,</span>
<span class="gi">+            &#39;dark cyan&#39;: &#39;#0a888a&#39;,</span>
<span class="gi">+            &#39;dark forest green&#39;: &#39;#002d04&#39;,</span>
<span class="gi">+            &#39;dark fuchsia&#39;: &#39;#9d0759&#39;,</span>
<span class="gi">+            &#39;dark gold&#39;: &#39;#b59410&#39;,</span>
<span class="gi">+            &#39;dark grass green&#39;: &#39;#388004&#39;,</span>
<span class="gi">+            &#39;dark green&#39;: &#39;#033500&#39;,</span>
<span class="gi">+            &#39;dark green blue&#39;: &#39;#1f6357&#39;,</span>
<span class="gi">+            &#39;dark grey&#39;: &#39;#363737&#39;,</span>
<span class="gi">+            &#39;dark grey blue&#39;: &#39;#29465b&#39;,</span>
<span class="gi">+            &#39;dark hot pink&#39;: &#39;#d90166&#39;,</span>
<span class="gi">+            &#39;dark indigo&#39;: &#39;#1f0954&#39;,</span>
<span class="gi">+            &#39;dark khaki&#39;: &#39;#9b8f55&#39;,</span>
<span class="gi">+            &#39;dark lavender&#39;: &#39;#856798&#39;,</span>
<span class="gi">+            &#39;dark lilac&#39;: &#39;#9c6da5&#39;,</span>
<span class="gi">+            &#39;dark lime&#39;: &#39;#84b701&#39;,</span>
<span class="gi">+            &#39;dark lime green&#39;: &#39;#7ebd01&#39;,</span>
<span class="gi">+            &#39;dark magenta&#39;: &#39;#960056&#39;,</span>
<span class="gi">+            &#39;dark maroon&#39;: &#39;#3c0008&#39;,</span>
<span class="gi">+            &#39;dark mauve&#39;: &#39;#874c62&#39;,</span>
<span class="gi">+            &#39;dark mint&#39;: &#39;#48c072&#39;,</span>
<span class="gi">+            &#39;dark mint green&#39;: &#39;#20c073&#39;,</span>
<span class="gi">+            &#39;dark mustard&#39;: &#39;#a88905&#39;,</span>
<span class="gi">+            &#39;dark navy&#39;: &#39;#000435&#39;,</span>
<span class="gi">+            &#39;dark navy blue&#39;: &#39;#00022e&#39;,</span>
<span class="gi">+            &#39;dark olive&#39;: &#39;#373e02&#39;,</span>
<span class="gi">+            &#39;dark olive green&#39;: &#39;#3c4d03&#39;,</span>
<span class="gi">+            &#39;dark orange&#39;: &#39;#c65102&#39;,</span>
<span class="gi">+            &#39;dark pastel green&#39;: &#39;#56ae57&#39;,</span>
<span class="gi">+            &#39;dark peach&#39;: &#39;#de7e5d&#39;,</span>
<span class="gi">+            &#39;dark periwinkle&#39;: &#39;#665fd1&#39;,</span>
<span class="gi">+            &#39;dark pink&#39;: &#39;#cb416b&#39;,</span>
<span class="gi">+            &#39;dark plum&#39;: &#39;#3f012c&#39;,</span>
<span class="gi">+            &#39;dark purple&#39;: &#39;#35063e&#39;,</span>
<span class="gi">+            &#39;dark red&#39;: &#39;#840000&#39;,</span>
<span class="gi">+            &#39;dark rose&#39;: &#39;#b5485d&#39;,</span>
<span class="gi">+            &#39;dark royal blue&#39;: &#39;#02066f&#39;,</span>
<span class="gi">+            &#39;dark sage&#39;: &#39;#598556&#39;,</span>
<span class="gi">+            &#39;dark salmon&#39;: &#39;#c85a53&#39;,</span>
<span class="gi">+            &#39;dark sand&#39;: &#39;#a88f59&#39;,</span>
<span class="gi">+            &#39;dark sea green&#39;: &#39;#11875d&#39;,</span>
<span class="gi">+            &#39;dark seafoam&#39;: &#39;#1fb57a&#39;,</span>
<span class="gi">+            &#39;dark seafoam green&#39;: &#39;#3eaf76&#39;,</span>
<span class="gi">+            &#39;dark sky blue&#39;: &#39;#448ee4&#39;,</span>
<span class="gi">+            &#39;dark slate blue&#39;: &#39;#214761&#39;,</span>
<span class="gi">+            &#39;dark tan&#39;: &#39;#af884a&#39;,</span>
<span class="gi">+            &#39;dark taupe&#39;: &#39;#7f684e&#39;,</span>
<span class="gi">+            &#39;dark teal&#39;: &#39;#014d4e&#39;,</span>
<span class="gi">+            &#39;dark turquoise&#39;: &#39;#045c5a&#39;,</span>
<span class="gi">+            &#39;dark violet&#39;: &#39;#34013f&#39;,</span>
<span class="gi">+            &#39;dark yellow&#39;: &#39;#d5b60a&#39;,</span>
<span class="gi">+            &#39;dark yellow green&#39;: &#39;#728f02&#39;,</span>
<span class="gi">+            &#39;darkblue&#39;: &#39;#030764&#39;,</span>
<span class="gi">+            &#39;darkgreen&#39;: &#39;#054907&#39;,</span>
<span class="gi">+            &#39;darkish blue&#39;: &#39;#014182&#39;,</span>
<span class="gi">+            &#39;darkish green&#39;: &#39;#287c37&#39;,</span>
<span class="gi">+            &#39;darkish pink&#39;: &#39;#da467d&#39;,</span>
<span class="gi">+            &#39;darkish purple&#39;: &#39;#751973&#39;,</span>
<span class="gi">+            &#39;darkish red&#39;: &#39;#a90308&#39;,</span>
<span class="gi">+            &#39;deep aqua&#39;: &#39;#08787f&#39;,</span>
<span class="gi">+            &#39;deep blue&#39;: &#39;#040273&#39;,</span>
<span class="gi">+            &#39;deep brown&#39;: &#39;#410200&#39;,</span>
<span class="gi">+            &#39;deep green&#39;: &#39;#02590f&#39;,</span>
<span class="gi">+            &#39;deep lavender&#39;: &#39;#8d5eb7&#39;,</span>
<span class="gi">+            &#39;deep lilac&#39;: &#39;#966ebd&#39;,</span>
<span class="gi">+            &#39;deep magenta&#39;: &#39;#a0025c&#39;,</span>
<span class="gi">+            &#39;deep orange&#39;: &#39;#dc4d01&#39;,</span>
<span class="gi">+            &#39;deep pink&#39;: &#39;#cb0162&#39;,</span>
<span class="gi">+            &#39;deep purple&#39;: &#39;#36013f&#39;,</span>
<span class="gi">+            &#39;deep red&#39;: &#39;#9a0200&#39;,</span>
<span class="gi">+            &#39;deep rose&#39;: &#39;#c74767&#39;,</span>
<span class="gi">+            &#39;deep sea blue&#39;: &#39;#015482&#39;,</span>
<span class="gi">+            &#39;deep sky blue&#39;: &#39;#0d75f8&#39;,</span>
<span class="gi">+            &#39;deep teal&#39;: &#39;#00555a&#39;,</span>
<span class="gi">+            &#39;deep turquoise&#39;: &#39;#017374&#39;,</span>
<span class="gi">+            &#39;deep violet&#39;: &#39;#490648&#39;,</span>
<span class="gi">+            &#39;denim&#39;: &#39;#3b638c&#39;,</span>
<span class="gi">+            &#39;denim blue&#39;: &#39;#3b5b92&#39;,</span>
<span class="gi">+            &#39;desert&#39;: &#39;#ccad60&#39;,</span>
<span class="gi">+            &#39;diarrhea&#39;: &#39;#9f8303&#39;,</span>
<span class="gi">+            &#39;dirt&#39;: &#39;#8a6e45&#39;,</span>
<span class="gi">+            &#39;dirt brown&#39;: &#39;#836539&#39;,</span>
<span class="gi">+            &#39;dirty blue&#39;: &#39;#3f829d&#39;,</span>
<span class="gi">+            &#39;dirty green&#39;: &#39;#667e2c&#39;,</span>
<span class="gi">+            &#39;dirty orange&#39;: &#39;#c87606&#39;,</span>
<span class="gi">+            &#39;dirty pink&#39;: &#39;#ca7b80&#39;,</span>
<span class="gi">+            &#39;dirty purple&#39;: &#39;#734a65&#39;,</span>
<span class="gi">+            &#39;dirty yellow&#39;: &#39;#cdc50a&#39;,</span>
<span class="gi">+            &#39;dodger blue&#39;: &#39;#3e82fc&#39;,</span>
<span class="gi">+            &#39;drab&#39;: &#39;#828344&#39;,</span>
<span class="gi">+            &#39;drab green&#39;: &#39;#749551&#39;,</span>
<span class="gi">+            &#39;dried blood&#39;: &#39;#4b0101&#39;,</span>
<span class="gi">+            &#39;duck egg blue&#39;: &#39;#c3fbf4&#39;,</span>
<span class="gi">+            &#39;dull blue&#39;: &#39;#49759c&#39;,</span>
<span class="gi">+            &#39;dull brown&#39;: &#39;#876e4b&#39;,</span>
<span class="gi">+            &#39;dull green&#39;: &#39;#74a662&#39;,</span>
<span class="gi">+            &#39;dull orange&#39;: &#39;#d8863b&#39;,</span>
<span class="gi">+            &#39;dull pink&#39;: &#39;#d5869d&#39;,</span>
<span class="gi">+            &#39;dull purple&#39;: &#39;#84597e&#39;,</span>
<span class="gi">+            &#39;dull red&#39;: &#39;#bb3f3f&#39;,</span>
<span class="gi">+            &#39;dull teal&#39;: &#39;#5f9e8f&#39;,</span>
<span class="gi">+            &#39;dull yellow&#39;: &#39;#eedc5b&#39;,</span>
<span class="gi">+            &#39;dusk&#39;: &#39;#4e5481&#39;,</span>
<span class="gi">+            &#39;dusk blue&#39;: &#39;#26538d&#39;,</span>
<span class="gi">+            &#39;dusky blue&#39;: &#39;#475f94&#39;,</span>
<span class="gi">+            &#39;dusky pink&#39;: &#39;#cc7a8b&#39;,</span>
<span class="gi">+            &#39;dusky purple&#39;: &#39;#895b7b&#39;,</span>
<span class="gi">+            &#39;dusky rose&#39;: &#39;#ba6873&#39;,</span>
<span class="gi">+            &#39;dust&#39;: &#39;#b2996e&#39;,</span>
<span class="gi">+            &#39;dusty blue&#39;: &#39;#5a86ad&#39;,</span>
<span class="gi">+            &#39;dusty green&#39;: &#39;#76a973&#39;,</span>
<span class="gi">+            &#39;dusty lavender&#39;: &#39;#ac86a8&#39;,</span>
<span class="gi">+            &#39;dusty orange&#39;: &#39;#f0833a&#39;,</span>
<span class="gi">+            &#39;dusty pink&#39;: &#39;#d58a94&#39;,</span>
<span class="gi">+            &#39;dusty purple&#39;: &#39;#825f87&#39;,</span>
<span class="gi">+            &#39;dusty red&#39;: &#39;#b9484e&#39;,</span>
<span class="gi">+            &#39;dusty rose&#39;: &#39;#c0737a&#39;,</span>
<span class="gi">+            &#39;dusty teal&#39;: &#39;#4c9085&#39;,</span>
<span class="gi">+            &#39;earth&#39;: &#39;#a2653e&#39;,</span>
<span class="gi">+            &#39;easter green&#39;: &#39;#8cfd7e&#39;,</span>
<span class="gi">+            &#39;easter purple&#39;: &#39;#c071fe&#39;,</span>
<span class="gi">+            &#39;ecru&#39;: &#39;#feffca&#39;,</span>
<span class="gi">+            &#39;egg shell&#39;: &#39;#fffcc4&#39;,</span>
<span class="gi">+            &#39;eggplant&#39;: &#39;#380835&#39;,</span>
<span class="gi">+            &#39;eggplant purple&#39;: &#39;#430541&#39;,</span>
<span class="gi">+            &#39;eggshell&#39;: &#39;#ffffd4&#39;,</span>
<span class="gi">+            &#39;eggshell blue&#39;: &#39;#c4fff7&#39;,</span>
<span class="gi">+            &#39;electric blue&#39;: &#39;#0652ff&#39;,</span>
<span class="gi">+            &#39;electric green&#39;: &#39;#21fc0d&#39;,</span>
<span class="gi">+            &#39;electric lime&#39;: &#39;#a8ff04&#39;,</span>
<span class="gi">+            &#39;electric pink&#39;: &#39;#ff0490&#39;,</span>
<span class="gi">+            &#39;electric purple&#39;: &#39;#aa23ff&#39;,</span>
<span class="gi">+            &#39;emerald&#39;: &#39;#01a049&#39;,</span>
<span class="gi">+            &#39;emerald green&#39;: &#39;#028f1e&#39;,</span>
<span class="gi">+            &#39;evergreen&#39;: &#39;#05472a&#39;,</span>
<span class="gi">+            &#39;faded blue&#39;: &#39;#658cbb&#39;,</span>
<span class="gi">+            &#39;faded green&#39;: &#39;#7bb274&#39;,</span>
<span class="gi">+            &#39;faded orange&#39;: &#39;#f0944d&#39;,</span>
<span class="gi">+            &#39;faded pink&#39;: &#39;#de9dac&#39;,</span>
<span class="gi">+            &#39;faded purple&#39;: &#39;#916e99&#39;,</span>
<span class="gi">+            &#39;faded red&#39;: &#39;#d3494e&#39;,</span>
<span class="gi">+            &#39;faded yellow&#39;: &#39;#feff7f&#39;,</span>
<span class="gi">+            &#39;fawn&#39;: &#39;#cfaf7b&#39;,</span>
<span class="gi">+            &#39;fern&#39;: &#39;#63a950&#39;,</span>
<span class="gi">+            &#39;fern green&#39;: &#39;#548d44&#39;,</span>
<span class="gi">+            &#39;fire engine red&#39;: &#39;#fe0002&#39;,</span>
<span class="gi">+            &#39;flat blue&#39;: &#39;#3c73a8&#39;,</span>
<span class="gi">+            &#39;flat green&#39;: &#39;#699d4c&#39;,</span>
<span class="gi">+            &#39;fluorescent green&#39;: &#39;#08ff08&#39;,</span>
<span class="gi">+            &#39;fluro green&#39;: &#39;#0aff02&#39;,</span>
<span class="gi">+            &#39;foam green&#39;: &#39;#90fda9&#39;,</span>
<span class="gi">+            &#39;forest&#39;: &#39;#0b5509&#39;,</span>
<span class="gi">+            &#39;forest green&#39;: &#39;#06470c&#39;,</span>
<span class="gi">+            &#39;forrest green&#39;: &#39;#154406&#39;,</span>
<span class="gi">+            &#39;french blue&#39;: &#39;#436bad&#39;,</span>
<span class="gi">+            &#39;fresh green&#39;: &#39;#69d84f&#39;,</span>
<span class="gi">+            &#39;frog green&#39;: &#39;#58bc08&#39;,</span>
<span class="gi">+            &#39;fuchsia&#39;: &#39;#ed0dd9&#39;,</span>
<span class="gi">+            &#39;gold&#39;: &#39;#dbb40c&#39;,</span>
<span class="gi">+            &#39;golden&#39;: &#39;#f5bf03&#39;,</span>
<span class="gi">+            &#39;golden brown&#39;: &#39;#b27a01&#39;,</span>
<span class="gi">+            &#39;golden rod&#39;: &#39;#f9bc08&#39;,</span>
<span class="gi">+            &#39;golden yellow&#39;: &#39;#fec615&#39;,</span>
<span class="gi">+            &#39;goldenrod&#39;: &#39;#fac205&#39;,</span>
<span class="gi">+            &#39;grape&#39;: &#39;#6c3461&#39;,</span>
<span class="gi">+            &#39;grape purple&#39;: &#39;#5d1451&#39;,</span>
<span class="gi">+            &#39;grapefruit&#39;: &#39;#fd5956&#39;,</span>
<span class="gi">+            &#39;grass&#39;: &#39;#5cac2d&#39;,</span>
<span class="gi">+            &#39;grass green&#39;: &#39;#3f9b0b&#39;,</span>
<span class="gi">+            &#39;grassy green&#39;: &#39;#419c03&#39;,</span>
<span class="gi">+            &#39;green&#39;: &#39;#15b01a&#39;,</span>
<span class="gi">+            &#39;green apple&#39;: &#39;#5edc1f&#39;,</span>
<span class="gi">+            &#39;green blue&#39;: &#39;#06b48b&#39;,</span>
<span class="gi">+            &#39;green brown&#39;: &#39;#544e03&#39;,</span>
<span class="gi">+            &#39;green grey&#39;: &#39;#77926f&#39;,</span>
<span class="gi">+            &#39;green teal&#39;: &#39;#0cb577&#39;,</span>
<span class="gi">+            &#39;green yellow&#39;: &#39;#c9ff27&#39;,</span>
<span class="gi">+            &#39;green/blue&#39;: &#39;#01c08d&#39;,</span>
<span class="gi">+            &#39;green/yellow&#39;: &#39;#b5ce08&#39;,</span>
<span class="gi">+            &#39;greenblue&#39;: &#39;#23c48b&#39;,</span>
<span class="gi">+            &#39;greenish&#39;: &#39;#40a368&#39;,</span>
<span class="gi">+            &#39;greenish beige&#39;: &#39;#c9d179&#39;,</span>
<span class="gi">+            &#39;greenish blue&#39;: &#39;#0b8b87&#39;,</span>
<span class="gi">+            &#39;greenish brown&#39;: &#39;#696112&#39;,</span>
<span class="gi">+            &#39;greenish cyan&#39;: &#39;#2afeb7&#39;,</span>
<span class="gi">+            &#39;greenish grey&#39;: &#39;#96ae8d&#39;,</span>
<span class="gi">+            &#39;greenish tan&#39;: &#39;#bccb7a&#39;,</span>
<span class="gi">+            &#39;greenish teal&#39;: &#39;#32bf84&#39;,</span>
<span class="gi">+            &#39;greenish turquoise&#39;: &#39;#00fbb0&#39;,</span>
<span class="gi">+            &#39;greenish yellow&#39;: &#39;#cdfd02&#39;,</span>
<span class="gi">+            &#39;greeny blue&#39;: &#39;#42b395&#39;,</span>
<span class="gi">+            &#39;greeny brown&#39;: &#39;#696006&#39;,</span>
<span class="gi">+            &#39;greeny grey&#39;: &#39;#7ea07a&#39;,</span>
<span class="gi">+            &#39;greeny yellow&#39;: &#39;#c6f808&#39;,</span>
<span class="gi">+            &#39;grey&#39;: &#39;#929591&#39;,</span>
<span class="gi">+            &#39;grey blue&#39;: &#39;#6b8ba4&#39;,</span>
<span class="gi">+            &#39;grey brown&#39;: &#39;#7f7053&#39;,</span>
<span class="gi">+            &#39;grey green&#39;: &#39;#789b73&#39;,</span>
<span class="gi">+            &#39;grey pink&#39;: &#39;#c3909b&#39;,</span>
<span class="gi">+            &#39;grey purple&#39;: &#39;#826d8c&#39;,</span>
<span class="gi">+            &#39;grey teal&#39;: &#39;#5e9b8a&#39;,</span>
<span class="gi">+            &#39;grey/blue&#39;: &#39;#647d8e&#39;,</span>
<span class="gi">+            &#39;grey/green&#39;: &#39;#86a17d&#39;,</span>
<span class="gi">+            &#39;greyblue&#39;: &#39;#77a1b5&#39;,</span>
<span class="gi">+            &#39;greyish&#39;: &#39;#a8a495&#39;,</span>
<span class="gi">+            &#39;greyish blue&#39;: &#39;#5e819d&#39;,</span>
<span class="gi">+            &#39;greyish brown&#39;: &#39;#7a6a4f&#39;,</span>
<span class="gi">+            &#39;greyish green&#39;: &#39;#82a67d&#39;,</span>
<span class="gi">+            &#39;greyish pink&#39;: &#39;#c88d94&#39;,</span>
<span class="gi">+            &#39;greyish purple&#39;: &#39;#887191&#39;,</span>
<span class="gi">+            &#39;greyish teal&#39;: &#39;#719f91&#39;,</span>
<span class="gi">+            &#39;gross green&#39;: &#39;#a0bf16&#39;,</span>
<span class="gi">+            &#39;gunmetal&#39;: &#39;#536267&#39;,</span>
<span class="gi">+            &#39;hazel&#39;: &#39;#8e7618&#39;,</span>
<span class="gi">+            &#39;heather&#39;: &#39;#a484ac&#39;,</span>
<span class="gi">+            &#39;heliotrope&#39;: &#39;#d94ff5&#39;,</span>
<span class="gi">+            &#39;highlighter green&#39;: &#39;#1bfc06&#39;,</span>
<span class="gi">+            &#39;hospital green&#39;: &#39;#9be5aa&#39;,</span>
<span class="gi">+            &#39;hot green&#39;: &#39;#25ff29&#39;,</span>
<span class="gi">+            &#39;hot magenta&#39;: &#39;#f504c9&#39;,</span>
<span class="gi">+            &#39;hot pink&#39;: &#39;#ff028d&#39;,</span>
<span class="gi">+            &#39;hot purple&#39;: &#39;#cb00f5&#39;,</span>
<span class="gi">+            &#39;hunter green&#39;: &#39;#0b4008&#39;,</span>
<span class="gi">+            &#39;ice&#39;: &#39;#d6fffa&#39;,</span>
<span class="gi">+            &#39;ice blue&#39;: &#39;#d7fffe&#39;,</span>
<span class="gi">+            &#39;icky green&#39;: &#39;#8fae22&#39;,</span>
<span class="gi">+            &#39;indian red&#39;: &#39;#850e04&#39;,</span>
<span class="gi">+            &#39;indigo&#39;: &#39;#380282&#39;,</span>
<span class="gi">+            &#39;indigo blue&#39;: &#39;#3a18b1&#39;,</span>
<span class="gi">+            &#39;iris&#39;: &#39;#6258c4&#39;,</span>
<span class="gi">+            &#39;irish green&#39;: &#39;#019529&#39;,</span>
<span class="gi">+            &#39;ivory&#39;: &#39;#ffffcb&#39;,</span>
<span class="gi">+            &#39;jade&#39;: &#39;#1fa774&#39;,</span>
<span class="gi">+            &#39;jade green&#39;: &#39;#2baf6a&#39;,</span>
<span class="gi">+            &#39;jungle green&#39;: &#39;#048243&#39;,</span>
<span class="gi">+            &#39;kelley green&#39;: &#39;#009337&#39;,</span>
<span class="gi">+            &#39;kelly green&#39;: &#39;#02ab2e&#39;,</span>
<span class="gi">+            &#39;kermit green&#39;: &#39;#5cb200&#39;,</span>
<span class="gi">+            &#39;key lime&#39;: &#39;#aeff6e&#39;,</span>
<span class="gi">+            &#39;khaki&#39;: &#39;#aaa662&#39;,</span>
<span class="gi">+            &#39;khaki green&#39;: &#39;#728639&#39;,</span>
<span class="gi">+            &#39;kiwi&#39;: &#39;#9cef43&#39;,</span>
<span class="gi">+            &#39;kiwi green&#39;: &#39;#8ee53f&#39;,</span>
<span class="gi">+            &#39;lavender&#39;: &#39;#c79fef&#39;,</span>
<span class="gi">+            &#39;lavender blue&#39;: &#39;#8b88f8&#39;,</span>
<span class="gi">+            &#39;lavender pink&#39;: &#39;#dd85d7&#39;,</span>
<span class="gi">+            &#39;lawn green&#39;: &#39;#4da409&#39;,</span>
<span class="gi">+            &#39;leaf&#39;: &#39;#71aa34&#39;,</span>
<span class="gi">+            &#39;leaf green&#39;: &#39;#5ca904&#39;,</span>
<span class="gi">+            &#39;leafy green&#39;: &#39;#51b73b&#39;,</span>
<span class="gi">+            &#39;leather&#39;: &#39;#ac7434&#39;,</span>
<span class="gi">+            &#39;lemon&#39;: &#39;#fdff52&#39;,</span>
<span class="gi">+            &#39;lemon green&#39;: &#39;#adf802&#39;,</span>
<span class="gi">+            &#39;lemon lime&#39;: &#39;#bffe28&#39;,</span>
<span class="gi">+            &#39;lemon yellow&#39;: &#39;#fdff38&#39;,</span>
<span class="gi">+            &#39;lichen&#39;: &#39;#8fb67b&#39;,</span>
<span class="gi">+            &#39;light aqua&#39;: &#39;#8cffdb&#39;,</span>
<span class="gi">+            &#39;light aquamarine&#39;: &#39;#7bfdc7&#39;,</span>
<span class="gi">+            &#39;light beige&#39;: &#39;#fffeb6&#39;,</span>
<span class="gi">+            &#39;light blue&#39;: &#39;#95d0fc&#39;,</span>
<span class="gi">+            &#39;light blue green&#39;: &#39;#7efbb3&#39;,</span>
<span class="gi">+            &#39;light blue grey&#39;: &#39;#b7c9e2&#39;,</span>
<span class="gi">+            &#39;light bluish green&#39;: &#39;#76fda8&#39;,</span>
<span class="gi">+            &#39;light bright green&#39;: &#39;#53fe5c&#39;,</span>
<span class="gi">+            &#39;light brown&#39;: &#39;#ad8150&#39;,</span>
<span class="gi">+            &#39;light burgundy&#39;: &#39;#a8415b&#39;,</span>
<span class="gi">+            &#39;light cyan&#39;: &#39;#acfffc&#39;,</span>
<span class="gi">+            &#39;light eggplant&#39;: &#39;#894585&#39;,</span>
<span class="gi">+            &#39;light forest green&#39;: &#39;#4f9153&#39;,</span>
<span class="gi">+            &#39;light gold&#39;: &#39;#fddc5c&#39;,</span>
<span class="gi">+            &#39;light grass green&#39;: &#39;#9af764&#39;,</span>
<span class="gi">+            &#39;light green&#39;: &#39;#96f97b&#39;,</span>
<span class="gi">+            &#39;light green blue&#39;: &#39;#56fca2&#39;,</span>
<span class="gi">+            &#39;light greenish blue&#39;: &#39;#63f7b4&#39;,</span>
<span class="gi">+            &#39;light grey&#39;: &#39;#d8dcd6&#39;,</span>
<span class="gi">+            &#39;light grey blue&#39;: &#39;#9dbcd4&#39;,</span>
<span class="gi">+            &#39;light grey green&#39;: &#39;#b7e1a1&#39;,</span>
<span class="gi">+            &#39;light indigo&#39;: &#39;#6d5acf&#39;,</span>
<span class="gi">+            &#39;light khaki&#39;: &#39;#e6f2a2&#39;,</span>
<span class="gi">+            &#39;light lavendar&#39;: &#39;#efc0fe&#39;,</span>
<span class="gi">+            &#39;light lavender&#39;: &#39;#dfc5fe&#39;,</span>
<span class="gi">+            &#39;light light blue&#39;: &#39;#cafffb&#39;,</span>
<span class="gi">+            &#39;light light green&#39;: &#39;#c8ffb0&#39;,</span>
<span class="gi">+            &#39;light lilac&#39;: &#39;#edc8ff&#39;,</span>
<span class="gi">+            &#39;light lime&#39;: &#39;#aefd6c&#39;,</span>
<span class="gi">+            &#39;light lime green&#39;: &#39;#b9ff66&#39;,</span>
<span class="gi">+            &#39;light magenta&#39;: &#39;#fa5ff7&#39;,</span>
<span class="gi">+            &#39;light maroon&#39;: &#39;#a24857&#39;,</span>
<span class="gi">+            &#39;light mauve&#39;: &#39;#c292a1&#39;,</span>
<span class="gi">+            &#39;light mint&#39;: &#39;#b6ffbb&#39;,</span>
<span class="gi">+            &#39;light mint green&#39;: &#39;#a6fbb2&#39;,</span>
<span class="gi">+            &#39;light moss green&#39;: &#39;#a6c875&#39;,</span>
<span class="gi">+            &#39;light mustard&#39;: &#39;#f7d560&#39;,</span>
<span class="gi">+            &#39;light navy&#39;: &#39;#155084&#39;,</span>
<span class="gi">+            &#39;light navy blue&#39;: &#39;#2e5a88&#39;,</span>
<span class="gi">+            &#39;light neon green&#39;: &#39;#4efd54&#39;,</span>
<span class="gi">+            &#39;light olive&#39;: &#39;#acbf69&#39;,</span>
<span class="gi">+            &#39;light olive green&#39;: &#39;#a4be5c&#39;,</span>
<span class="gi">+            &#39;light orange&#39;: &#39;#fdaa48&#39;,</span>
<span class="gi">+            &#39;light pastel green&#39;: &#39;#b2fba5&#39;,</span>
<span class="gi">+            &#39;light pea green&#39;: &#39;#c4fe82&#39;,</span>
<span class="gi">+            &#39;light peach&#39;: &#39;#ffd8b1&#39;,</span>
<span class="gi">+            &#39;light periwinkle&#39;: &#39;#c1c6fc&#39;,</span>
<span class="gi">+            &#39;light pink&#39;: &#39;#ffd1df&#39;,</span>
<span class="gi">+            &#39;light plum&#39;: &#39;#9d5783&#39;,</span>
<span class="gi">+            &#39;light purple&#39;: &#39;#bf77f6&#39;,</span>
<span class="gi">+            &#39;light red&#39;: &#39;#ff474c&#39;,</span>
<span class="gi">+            &#39;light rose&#39;: &#39;#ffc5cb&#39;,</span>
<span class="gi">+            &#39;light royal blue&#39;: &#39;#3a2efe&#39;,</span>
<span class="gi">+            &#39;light sage&#39;: &#39;#bcecac&#39;,</span>
<span class="gi">+            &#39;light salmon&#39;: &#39;#fea993&#39;,</span>
<span class="gi">+            &#39;light sea green&#39;: &#39;#98f6b0&#39;,</span>
<span class="gi">+            &#39;light seafoam&#39;: &#39;#a0febf&#39;,</span>
<span class="gi">+            &#39;light seafoam green&#39;: &#39;#a7ffb5&#39;,</span>
<span class="gi">+            &#39;light sky blue&#39;: &#39;#c6fcff&#39;,</span>
<span class="gi">+            &#39;light tan&#39;: &#39;#fbeeac&#39;,</span>
<span class="gi">+            &#39;light teal&#39;: &#39;#90e4c1&#39;,</span>
<span class="gi">+            &#39;light turquoise&#39;: &#39;#7ef4cc&#39;,</span>
<span class="gi">+            &#39;light urple&#39;: &#39;#b36ff6&#39;,</span>
<span class="gi">+            &#39;light violet&#39;: &#39;#d6b4fc&#39;,</span>
<span class="gi">+            &#39;light yellow&#39;: &#39;#fffe7a&#39;,</span>
<span class="gi">+            &#39;light yellow green&#39;: &#39;#ccfd7f&#39;,</span>
<span class="gi">+            &#39;light yellowish green&#39;: &#39;#c2ff89&#39;,</span>
<span class="gi">+            &#39;lightblue&#39;: &#39;#7bc8f6&#39;,</span>
<span class="gi">+            &#39;lighter green&#39;: &#39;#75fd63&#39;,</span>
<span class="gi">+            &#39;lighter purple&#39;: &#39;#a55af4&#39;,</span>
<span class="gi">+            &#39;lightgreen&#39;: &#39;#76ff7b&#39;,</span>
<span class="gi">+            &#39;lightish blue&#39;: &#39;#3d7afd&#39;,</span>
<span class="gi">+            &#39;lightish green&#39;: &#39;#61e160&#39;,</span>
<span class="gi">+            &#39;lightish purple&#39;: &#39;#a552e6&#39;,</span>
<span class="gi">+            &#39;lightish red&#39;: &#39;#fe2f4a&#39;,</span>
<span class="gi">+            &#39;lilac&#39;: &#39;#cea2fd&#39;,</span>
<span class="gi">+            &#39;liliac&#39;: &#39;#c48efd&#39;,</span>
<span class="gi">+            &#39;lime&#39;: &#39;#aaff32&#39;,</span>
<span class="gi">+            &#39;lime green&#39;: &#39;#89fe05&#39;,</span>
<span class="gi">+            &#39;lime yellow&#39;: &#39;#d0fe1d&#39;,</span>
<span class="gi">+            &#39;lipstick&#39;: &#39;#d5174e&#39;,</span>
<span class="gi">+            &#39;lipstick red&#39;: &#39;#c0022f&#39;,</span>
<span class="gi">+            &#39;macaroni and cheese&#39;: &#39;#efb435&#39;,</span>
<span class="gi">+            &#39;magenta&#39;: &#39;#c20078&#39;,</span>
<span class="gi">+            &#39;mahogany&#39;: &#39;#4a0100&#39;,</span>
<span class="gi">+            &#39;maize&#39;: &#39;#f4d054&#39;,</span>
<span class="gi">+            &#39;mango&#39;: &#39;#ffa62b&#39;,</span>
<span class="gi">+            &#39;manilla&#39;: &#39;#fffa86&#39;,</span>
<span class="gi">+            &#39;marigold&#39;: &#39;#fcc006&#39;,</span>
<span class="gi">+            &#39;marine&#39;: &#39;#042e60&#39;,</span>
<span class="gi">+            &#39;marine blue&#39;: &#39;#01386a&#39;,</span>
<span class="gi">+            &#39;maroon&#39;: &#39;#650021&#39;,</span>
<span class="gi">+            &#39;mauve&#39;: &#39;#ae7181&#39;,</span>
<span class="gi">+            &#39;medium blue&#39;: &#39;#2c6fbb&#39;,</span>
<span class="gi">+            &#39;medium brown&#39;: &#39;#7f5112&#39;,</span>
<span class="gi">+            &#39;medium green&#39;: &#39;#39ad48&#39;,</span>
<span class="gi">+            &#39;medium grey&#39;: &#39;#7d7f7c&#39;,</span>
<span class="gi">+            &#39;medium pink&#39;: &#39;#f36196&#39;,</span>
<span class="gi">+            &#39;medium purple&#39;: &#39;#9e43a2&#39;,</span>
<span class="gi">+            &#39;melon&#39;: &#39;#ff7855&#39;,</span>
<span class="gi">+            &#39;merlot&#39;: &#39;#730039&#39;,</span>
<span class="gi">+            &#39;metallic blue&#39;: &#39;#4f738e&#39;,</span>
<span class="gi">+            &#39;mid blue&#39;: &#39;#276ab3&#39;,</span>
<span class="gi">+            &#39;mid green&#39;: &#39;#50a747&#39;,</span>
<span class="gi">+            &#39;midnight&#39;: &#39;#03012d&#39;,</span>
<span class="gi">+            &#39;midnight blue&#39;: &#39;#020035&#39;,</span>
<span class="gi">+            &#39;midnight purple&#39;: &#39;#280137&#39;,</span>
<span class="gi">+            &#39;military green&#39;: &#39;#667c3e&#39;,</span>
<span class="gi">+            &#39;milk chocolate&#39;: &#39;#7f4e1e&#39;,</span>
<span class="gi">+            &#39;mint&#39;: &#39;#9ffeb0&#39;,</span>
<span class="gi">+            &#39;mint green&#39;: &#39;#8fff9f&#39;,</span>
<span class="gi">+            &#39;minty green&#39;: &#39;#0bf77d&#39;,</span>
<span class="gi">+            &#39;mocha&#39;: &#39;#9d7651&#39;,</span>
<span class="gi">+            &#39;moss&#39;: &#39;#769958&#39;,</span>
<span class="gi">+            &#39;moss green&#39;: &#39;#658b38&#39;,</span>
<span class="gi">+            &#39;mossy green&#39;: &#39;#638b27&#39;,</span>
<span class="gi">+            &#39;mud&#39;: &#39;#735c12&#39;,</span>
<span class="gi">+            &#39;mud brown&#39;: &#39;#60460f&#39;,</span>
<span class="gi">+            &#39;mud green&#39;: &#39;#606602&#39;,</span>
<span class="gi">+            &#39;muddy brown&#39;: &#39;#886806&#39;,</span>
<span class="gi">+            &#39;muddy green&#39;: &#39;#657432&#39;,</span>
<span class="gi">+            &#39;muddy yellow&#39;: &#39;#bfac05&#39;,</span>
<span class="gi">+            &#39;mulberry&#39;: &#39;#920a4e&#39;,</span>
<span class="gi">+            &#39;murky green&#39;: &#39;#6c7a0e&#39;,</span>
<span class="gi">+            &#39;mushroom&#39;: &#39;#ba9e88&#39;,</span>
<span class="gi">+            &#39;mustard&#39;: &#39;#ceb301&#39;,</span>
<span class="gi">+            &#39;mustard brown&#39;: &#39;#ac7e04&#39;,</span>
<span class="gi">+            &#39;mustard green&#39;: &#39;#a8b504&#39;,</span>
<span class="gi">+            &#39;mustard yellow&#39;: &#39;#d2bd0a&#39;,</span>
<span class="gi">+            &#39;muted blue&#39;: &#39;#3b719f&#39;,</span>
<span class="gi">+            &#39;muted green&#39;: &#39;#5fa052&#39;,</span>
<span class="gi">+            &#39;muted pink&#39;: &#39;#d1768f&#39;,</span>
<span class="gi">+            &#39;muted purple&#39;: &#39;#805b87&#39;,</span>
<span class="gi">+            &#39;nasty green&#39;: &#39;#70b23f&#39;,</span>
<span class="gi">+            &#39;navy&#39;: &#39;#01153e&#39;,</span>
<span class="gi">+            &#39;navy blue&#39;: &#39;#001146&#39;,</span>
<span class="gi">+            &#39;navy green&#39;: &#39;#35530a&#39;,</span>
<span class="gi">+            &#39;neon blue&#39;: &#39;#04d9ff&#39;,</span>
<span class="gi">+            &#39;neon green&#39;: &#39;#0cff0c&#39;,</span>
<span class="gi">+            &#39;neon pink&#39;: &#39;#fe019a&#39;,</span>
<span class="gi">+            &#39;neon purple&#39;: &#39;#bc13fe&#39;,</span>
<span class="gi">+            &#39;neon red&#39;: &#39;#ff073a&#39;,</span>
<span class="gi">+            &#39;neon yellow&#39;: &#39;#cfff04&#39;,</span>
<span class="gi">+            &#39;nice blue&#39;: &#39;#107ab0&#39;,</span>
<span class="gi">+            &#39;night blue&#39;: &#39;#040348&#39;,</span>
<span class="gi">+            &#39;ocean&#39;: &#39;#017b92&#39;,</span>
<span class="gi">+            &#39;ocean blue&#39;: &#39;#03719c&#39;,</span>
<span class="gi">+            &#39;ocean green&#39;: &#39;#3d9973&#39;,</span>
<span class="gi">+            &#39;ocher&#39;: &#39;#bf9b0c&#39;,</span>
<span class="gi">+            &#39;ochre&#39;: &#39;#bf9005&#39;,</span>
<span class="gi">+            &#39;ocre&#39;: &#39;#c69c04&#39;,</span>
<span class="gi">+            &#39;off blue&#39;: &#39;#5684ae&#39;,</span>
<span class="gi">+            &#39;off green&#39;: &#39;#6ba353&#39;,</span>
<span class="gi">+            &#39;off white&#39;: &#39;#ffffe4&#39;,</span>
<span class="gi">+            &#39;off yellow&#39;: &#39;#f1f33f&#39;,</span>
<span class="gi">+            &#39;old pink&#39;: &#39;#c77986&#39;,</span>
<span class="gi">+            &#39;old rose&#39;: &#39;#c87f89&#39;,</span>
<span class="gi">+            &#39;olive&#39;: &#39;#6e750e&#39;,</span>
<span class="gi">+            &#39;olive brown&#39;: &#39;#645403&#39;,</span>
<span class="gi">+            &#39;olive drab&#39;: &#39;#6f7632&#39;,</span>
<span class="gi">+            &#39;olive green&#39;: &#39;#677a04&#39;,</span>
<span class="gi">+            &#39;olive yellow&#39;: &#39;#c2b709&#39;,</span>
<span class="gi">+            &#39;orange&#39;: &#39;#f97306&#39;,</span>
<span class="gi">+            &#39;orange brown&#39;: &#39;#be6400&#39;,</span>
<span class="gi">+            &#39;orange pink&#39;: &#39;#ff6f52&#39;,</span>
<span class="gi">+            &#39;orange red&#39;: &#39;#fd411e&#39;,</span>
<span class="gi">+            &#39;orange yellow&#39;: &#39;#ffad01&#39;,</span>
<span class="gi">+            &#39;orangeish&#39;: &#39;#fd8d49&#39;,</span>
<span class="gi">+            &#39;orangered&#39;: &#39;#fe420f&#39;,</span>
<span class="gi">+            &#39;orangey brown&#39;: &#39;#b16002&#39;,</span>
<span class="gi">+            &#39;orangey red&#39;: &#39;#fa4224&#39;,</span>
<span class="gi">+            &#39;orangey yellow&#39;: &#39;#fdb915&#39;,</span>
<span class="gi">+            &#39;orangish&#39;: &#39;#fc824a&#39;,</span>
<span class="gi">+            &#39;orangish brown&#39;: &#39;#b25f03&#39;,</span>
<span class="gi">+            &#39;orangish red&#39;: &#39;#f43605&#39;,</span>
<span class="gi">+            &#39;orchid&#39;: &#39;#c875c4&#39;,</span>
<span class="gi">+            &#39;pale&#39;: &#39;#fff9d0&#39;,</span>
<span class="gi">+            &#39;pale aqua&#39;: &#39;#b8ffeb&#39;,</span>
<span class="gi">+            &#39;pale blue&#39;: &#39;#d0fefe&#39;,</span>
<span class="gi">+            &#39;pale brown&#39;: &#39;#b1916e&#39;,</span>
<span class="gi">+            &#39;pale cyan&#39;: &#39;#b7fffa&#39;,</span>
<span class="gi">+            &#39;pale gold&#39;: &#39;#fdde6c&#39;,</span>
<span class="gi">+            &#39;pale green&#39;: &#39;#c7fdb5&#39;,</span>
<span class="gi">+            &#39;pale grey&#39;: &#39;#fdfdfe&#39;,</span>
<span class="gi">+            &#39;pale lavender&#39;: &#39;#eecffe&#39;,</span>
<span class="gi">+            &#39;pale light green&#39;: &#39;#b1fc99&#39;,</span>
<span class="gi">+            &#39;pale lilac&#39;: &#39;#e4cbff&#39;,</span>
<span class="gi">+            &#39;pale lime&#39;: &#39;#befd73&#39;,</span>
<span class="gi">+            &#39;pale lime green&#39;: &#39;#b1ff65&#39;,</span>
<span class="gi">+            &#39;pale magenta&#39;: &#39;#d767ad&#39;,</span>
<span class="gi">+            &#39;pale mauve&#39;: &#39;#fed0fc&#39;,</span>
<span class="gi">+            &#39;pale olive&#39;: &#39;#b9cc81&#39;,</span>
<span class="gi">+            &#39;pale olive green&#39;: &#39;#b1d27b&#39;,</span>
<span class="gi">+            &#39;pale orange&#39;: &#39;#ffa756&#39;,</span>
<span class="gi">+            &#39;pale peach&#39;: &#39;#ffe5ad&#39;,</span>
<span class="gi">+            &#39;pale pink&#39;: &#39;#ffcfdc&#39;,</span>
<span class="gi">+            &#39;pale purple&#39;: &#39;#b790d4&#39;,</span>
<span class="gi">+            &#39;pale red&#39;: &#39;#d9544d&#39;,</span>
<span class="gi">+            &#39;pale rose&#39;: &#39;#fdc1c5&#39;,</span>
<span class="gi">+            &#39;pale salmon&#39;: &#39;#ffb19a&#39;,</span>
<span class="gi">+            &#39;pale sky blue&#39;: &#39;#bdf6fe&#39;,</span>
<span class="gi">+            &#39;pale teal&#39;: &#39;#82cbb2&#39;,</span>
<span class="gi">+            &#39;pale turquoise&#39;: &#39;#a5fbd5&#39;,</span>
<span class="gi">+            &#39;pale violet&#39;: &#39;#ceaefa&#39;,</span>
<span class="gi">+            &#39;pale yellow&#39;: &#39;#ffff84&#39;,</span>
<span class="gi">+            &#39;parchment&#39;: &#39;#fefcaf&#39;,</span>
<span class="gi">+            &#39;pastel blue&#39;: &#39;#a2bffe&#39;,</span>
<span class="gi">+            &#39;pastel green&#39;: &#39;#b0ff9d&#39;,</span>
<span class="gi">+            &#39;pastel orange&#39;: &#39;#ff964f&#39;,</span>
<span class="gi">+            &#39;pastel pink&#39;: &#39;#ffbacd&#39;,</span>
<span class="gi">+            &#39;pastel purple&#39;: &#39;#caa0ff&#39;,</span>
<span class="gi">+            &#39;pastel red&#39;: &#39;#db5856&#39;,</span>
<span class="gi">+            &#39;pastel yellow&#39;: &#39;#fffe71&#39;,</span>
<span class="gi">+            &#39;pea&#39;: &#39;#a4bf20&#39;,</span>
<span class="gi">+            &#39;pea green&#39;: &#39;#8eab12&#39;,</span>
<span class="gi">+            &#39;pea soup&#39;: &#39;#929901&#39;,</span>
<span class="gi">+            &#39;pea soup green&#39;: &#39;#94a617&#39;,</span>
<span class="gi">+            &#39;peach&#39;: &#39;#ffb07c&#39;,</span>
<span class="gi">+            &#39;peachy pink&#39;: &#39;#ff9a8a&#39;,</span>
<span class="gi">+            &#39;peacock blue&#39;: &#39;#016795&#39;,</span>
<span class="gi">+            &#39;pear&#39;: &#39;#cbf85f&#39;,</span>
<span class="gi">+            &#39;periwinkle&#39;: &#39;#8e82fe&#39;,</span>
<span class="gi">+            &#39;periwinkle blue&#39;: &#39;#8f99fb&#39;,</span>
<span class="gi">+            &#39;perrywinkle&#39;: &#39;#8f8ce7&#39;,</span>
<span class="gi">+            &#39;petrol&#39;: &#39;#005f6a&#39;,</span>
<span class="gi">+            &#39;pig pink&#39;: &#39;#e78ea5&#39;,</span>
<span class="gi">+            &#39;pine&#39;: &#39;#2b5d34&#39;,</span>
<span class="gi">+            &#39;pine green&#39;: &#39;#0a481e&#39;,</span>
<span class="gi">+            &#39;pink&#39;: &#39;#ff81c0&#39;,</span>
<span class="gi">+            &#39;pink purple&#39;: &#39;#db4bda&#39;,</span>
<span class="gi">+            &#39;pink red&#39;: &#39;#f5054f&#39;,</span>
<span class="gi">+            &#39;pink/purple&#39;: &#39;#ef1de7&#39;,</span>
<span class="gi">+            &#39;pinkish&#39;: &#39;#d46a7e&#39;,</span>
<span class="gi">+            &#39;pinkish brown&#39;: &#39;#b17261&#39;,</span>
<span class="gi">+            &#39;pinkish grey&#39;: &#39;#c8aca9&#39;,</span>
<span class="gi">+            &#39;pinkish orange&#39;: &#39;#ff724c&#39;,</span>
<span class="gi">+            &#39;pinkish purple&#39;: &#39;#d648d7&#39;,</span>
<span class="gi">+            &#39;pinkish red&#39;: &#39;#f10c45&#39;,</span>
<span class="gi">+            &#39;pinkish tan&#39;: &#39;#d99b82&#39;,</span>
<span class="gi">+            &#39;pinky&#39;: &#39;#fc86aa&#39;,</span>
<span class="gi">+            &#39;pinky purple&#39;: &#39;#c94cbe&#39;,</span>
<span class="gi">+            &#39;pinky red&#39;: &#39;#fc2647&#39;,</span>
<span class="gi">+            &#39;piss yellow&#39;: &#39;#ddd618&#39;,</span>
<span class="gi">+            &#39;pistachio&#39;: &#39;#c0fa8b&#39;,</span>
<span class="gi">+            &#39;plum&#39;: &#39;#580f41&#39;,</span>
<span class="gi">+            &#39;plum purple&#39;: &#39;#4e0550&#39;,</span>
<span class="gi">+            &#39;poison green&#39;: &#39;#40fd14&#39;,</span>
<span class="gi">+            &#39;poo&#39;: &#39;#8f7303&#39;,</span>
<span class="gi">+            &#39;poo brown&#39;: &#39;#885f01&#39;,</span>
<span class="gi">+            &#39;poop&#39;: &#39;#7f5e00&#39;,</span>
<span class="gi">+            &#39;poop brown&#39;: &#39;#7a5901&#39;,</span>
<span class="gi">+            &#39;poop green&#39;: &#39;#6f7c00&#39;,</span>
<span class="gi">+            &#39;powder blue&#39;: &#39;#b1d1fc&#39;,</span>
<span class="gi">+            &#39;powder pink&#39;: &#39;#ffb2d0&#39;,</span>
<span class="gi">+            &#39;primary blue&#39;: &#39;#0804f9&#39;,</span>
<span class="gi">+            &#39;prussian blue&#39;: &#39;#004577&#39;,</span>
<span class="gi">+            &#39;puce&#39;: &#39;#a57e52&#39;,</span>
<span class="gi">+            &#39;puke&#39;: &#39;#a5a502&#39;,</span>
<span class="gi">+            &#39;puke brown&#39;: &#39;#947706&#39;,</span>
<span class="gi">+            &#39;puke green&#39;: &#39;#9aae07&#39;,</span>
<span class="gi">+            &#39;puke yellow&#39;: &#39;#c2be0e&#39;,</span>
<span class="gi">+            &#39;pumpkin&#39;: &#39;#e17701&#39;,</span>
<span class="gi">+            &#39;pumpkin orange&#39;: &#39;#fb7d07&#39;,</span>
<span class="gi">+            &#39;pure blue&#39;: &#39;#0203e2&#39;,</span>
<span class="gi">+            &#39;purple&#39;: &#39;#7e1e9c&#39;,</span>
<span class="gi">+            &#39;purple blue&#39;: &#39;#632de9&#39;,</span>
<span class="gi">+            &#39;purple brown&#39;: &#39;#673a3f&#39;,</span>
<span class="gi">+            &#39;purple grey&#39;: &#39;#866f85&#39;,</span>
<span class="gi">+            &#39;purple pink&#39;: &#39;#e03fd8&#39;,</span>
<span class="gi">+            &#39;purple red&#39;: &#39;#990147&#39;,</span>
<span class="gi">+            &#39;purple/blue&#39;: &#39;#5d21d0&#39;,</span>
<span class="gi">+            &#39;purple/pink&#39;: &#39;#d725de&#39;,</span>
<span class="gi">+            &#39;purpleish&#39;: &#39;#98568d&#39;,</span>
<span class="gi">+            &#39;purpleish blue&#39;: &#39;#6140ef&#39;,</span>
<span class="gi">+            &#39;purpleish pink&#39;: &#39;#df4ec8&#39;,</span>
<span class="gi">+            &#39;purpley&#39;: &#39;#8756e4&#39;,</span>
<span class="gi">+            &#39;purpley blue&#39;: &#39;#5f34e7&#39;,</span>
<span class="gi">+            &#39;purpley grey&#39;: &#39;#947e94&#39;,</span>
<span class="gi">+            &#39;purpley pink&#39;: &#39;#c83cb9&#39;,</span>
<span class="gi">+            &#39;purplish&#39;: &#39;#94568c&#39;,</span>
<span class="gi">+            &#39;purplish blue&#39;: &#39;#601ef9&#39;,</span>
<span class="gi">+            &#39;purplish brown&#39;: &#39;#6b4247&#39;,</span>
<span class="gi">+            &#39;purplish grey&#39;: &#39;#7a687f&#39;,</span>
<span class="gi">+            &#39;purplish pink&#39;: &#39;#ce5dae&#39;,</span>
<span class="gi">+            &#39;purplish red&#39;: &#39;#b0054b&#39;,</span>
<span class="gi">+            &#39;purply&#39;: &#39;#983fb2&#39;,</span>
<span class="gi">+            &#39;purply blue&#39;: &#39;#661aee&#39;,</span>
<span class="gi">+            &#39;purply pink&#39;: &#39;#f075e6&#39;,</span>
<span class="gi">+            &#39;putty&#39;: &#39;#beae8a&#39;,</span>
<span class="gi">+            &#39;racing green&#39;: &#39;#014600&#39;,</span>
<span class="gi">+            &#39;radioactive green&#39;: &#39;#2cfa1f&#39;,</span>
<span class="gi">+            &#39;raspberry&#39;: &#39;#b00149&#39;,</span>
<span class="gi">+            &#39;raw sienna&#39;: &#39;#9a6200&#39;,</span>
<span class="gi">+            &#39;raw umber&#39;: &#39;#a75e09&#39;,</span>
<span class="gi">+            &#39;really light blue&#39;: &#39;#d4ffff&#39;,</span>
<span class="gi">+            &#39;red&#39;: &#39;#e50000&#39;,</span>
<span class="gi">+            &#39;red brown&#39;: &#39;#8b2e16&#39;,</span>
<span class="gi">+            &#39;red orange&#39;: &#39;#fd3c06&#39;,</span>
<span class="gi">+            &#39;red pink&#39;: &#39;#fa2a55&#39;,</span>
<span class="gi">+            &#39;red purple&#39;: &#39;#820747&#39;,</span>
<span class="gi">+            &#39;red violet&#39;: &#39;#9e0168&#39;,</span>
<span class="gi">+            &#39;red wine&#39;: &#39;#8c0034&#39;,</span>
<span class="gi">+            &#39;reddish&#39;: &#39;#c44240&#39;,</span>
<span class="gi">+            &#39;reddish brown&#39;: &#39;#7f2b0a&#39;,</span>
<span class="gi">+            &#39;reddish grey&#39;: &#39;#997570&#39;,</span>
<span class="gi">+            &#39;reddish orange&#39;: &#39;#f8481c&#39;,</span>
<span class="gi">+            &#39;reddish pink&#39;: &#39;#fe2c54&#39;,</span>
<span class="gi">+            &#39;reddish purple&#39;: &#39;#910951&#39;,</span>
<span class="gi">+            &#39;reddy brown&#39;: &#39;#6e1005&#39;,</span>
<span class="gi">+            &#39;rich blue&#39;: &#39;#021bf9&#39;,</span>
<span class="gi">+            &#39;rich purple&#39;: &#39;#720058&#39;,</span>
<span class="gi">+            &#39;robin egg blue&#39;: &#39;#8af1fe&#39;,</span>
<span class="gi">+            &quot;robin&#39;s egg&quot;: &#39;#6dedfd&#39;,</span>
<span class="gi">+            &quot;robin&#39;s egg blue&quot;: &#39;#98eff9&#39;,</span>
<span class="gi">+            &#39;rosa&#39;: &#39;#fe86a4&#39;,</span>
<span class="gi">+            &#39;rose&#39;: &#39;#cf6275&#39;,</span>
<span class="gi">+            &#39;rose pink&#39;: &#39;#f7879a&#39;,</span>
<span class="gi">+            &#39;rose red&#39;: &#39;#be013c&#39;,</span>
<span class="gi">+            &#39;rosy pink&#39;: &#39;#f6688e&#39;,</span>
<span class="gi">+            &#39;rouge&#39;: &#39;#ab1239&#39;,</span>
<span class="gi">+            &#39;royal&#39;: &#39;#0c1793&#39;,</span>
<span class="gi">+            &#39;royal blue&#39;: &#39;#0504aa&#39;,</span>
<span class="gi">+            &#39;royal purple&#39;: &#39;#4b006e&#39;,</span>
<span class="gi">+            &#39;ruby&#39;: &#39;#ca0147&#39;,</span>
<span class="gi">+            &#39;russet&#39;: &#39;#a13905&#39;,</span>
<span class="gi">+            &#39;rust&#39;: &#39;#a83c09&#39;,</span>
<span class="gi">+            &#39;rust brown&#39;: &#39;#8b3103&#39;,</span>
<span class="gi">+            &#39;rust orange&#39;: &#39;#c45508&#39;,</span>
<span class="gi">+            &#39;rust red&#39;: &#39;#aa2704&#39;,</span>
<span class="gi">+            &#39;rusty orange&#39;: &#39;#cd5909&#39;,</span>
<span class="gi">+            &#39;rusty red&#39;: &#39;#af2f0d&#39;,</span>
<span class="gi">+            &#39;saffron&#39;: &#39;#feb209&#39;,</span>
<span class="gi">+            &#39;sage&#39;: &#39;#87ae73&#39;,</span>
<span class="gi">+            &#39;sage green&#39;: &#39;#88b378&#39;,</span>
<span class="gi">+            &#39;salmon&#39;: &#39;#ff796c&#39;,</span>
<span class="gi">+            &#39;salmon pink&#39;: &#39;#fe7b7c&#39;,</span>
<span class="gi">+            &#39;sand&#39;: &#39;#e2ca76&#39;,</span>
<span class="gi">+            &#39;sand brown&#39;: &#39;#cba560&#39;,</span>
<span class="gi">+            &#39;sand yellow&#39;: &#39;#fce166&#39;,</span>
<span class="gi">+            &#39;sandstone&#39;: &#39;#c9ae74&#39;,</span>
<span class="gi">+            &#39;sandy&#39;: &#39;#f1da7a&#39;,</span>
<span class="gi">+            &#39;sandy brown&#39;: &#39;#c4a661&#39;,</span>
<span class="gi">+            &#39;sandy yellow&#39;: &#39;#fdee73&#39;,</span>
<span class="gi">+            &#39;sap green&#39;: &#39;#5c8b15&#39;,</span>
<span class="gi">+            &#39;sapphire&#39;: &#39;#2138ab&#39;,</span>
<span class="gi">+            &#39;scarlet&#39;: &#39;#be0119&#39;,</span>
<span class="gi">+            &#39;sea&#39;: &#39;#3c9992&#39;,</span>
<span class="gi">+            &#39;sea blue&#39;: &#39;#047495&#39;,</span>
<span class="gi">+            &#39;sea green&#39;: &#39;#53fca1&#39;,</span>
<span class="gi">+            &#39;seafoam&#39;: &#39;#80f9ad&#39;,</span>
<span class="gi">+            &#39;seafoam blue&#39;: &#39;#78d1b6&#39;,</span>
<span class="gi">+            &#39;seafoam green&#39;: &#39;#7af9ab&#39;,</span>
<span class="gi">+            &#39;seaweed&#39;: &#39;#18d17b&#39;,</span>
<span class="gi">+            &#39;seaweed green&#39;: &#39;#35ad6b&#39;,</span>
<span class="gi">+            &#39;sepia&#39;: &#39;#985e2b&#39;,</span>
<span class="gi">+            &#39;shamrock&#39;: &#39;#01b44c&#39;,</span>
<span class="gi">+            &#39;shamrock green&#39;: &#39;#02c14d&#39;,</span>
<span class="gi">+            &#39;shit&#39;: &#39;#7f5f00&#39;,</span>
<span class="gi">+            &#39;shit brown&#39;: &#39;#7b5804&#39;,</span>
<span class="gi">+            &#39;shit green&#39;: &#39;#758000&#39;,</span>
<span class="gi">+            &#39;shocking pink&#39;: &#39;#fe02a2&#39;,</span>
<span class="gi">+            &#39;sick green&#39;: &#39;#9db92c&#39;,</span>
<span class="gi">+            &#39;sickly green&#39;: &#39;#94b21c&#39;,</span>
<span class="gi">+            &#39;sickly yellow&#39;: &#39;#d0e429&#39;,</span>
<span class="gi">+            &#39;sienna&#39;: &#39;#a9561e&#39;,</span>
<span class="gi">+            &#39;silver&#39;: &#39;#c5c9c7&#39;,</span>
<span class="gi">+            &#39;sky&#39;: &#39;#82cafc&#39;,</span>
<span class="gi">+            &#39;sky blue&#39;: &#39;#75bbfd&#39;,</span>
<span class="gi">+            &#39;slate&#39;: &#39;#516572&#39;,</span>
<span class="gi">+            &#39;slate blue&#39;: &#39;#5b7c99&#39;,</span>
<span class="gi">+            &#39;slate green&#39;: &#39;#658d6d&#39;,</span>
<span class="gi">+            &#39;slate grey&#39;: &#39;#59656d&#39;,</span>
<span class="gi">+            &#39;slime green&#39;: &#39;#99cc04&#39;,</span>
<span class="gi">+            &#39;snot&#39;: &#39;#acbb0d&#39;,</span>
<span class="gi">+            &#39;snot green&#39;: &#39;#9dc100&#39;,</span>
<span class="gi">+            &#39;soft blue&#39;: &#39;#6488ea&#39;,</span>
<span class="gi">+            &#39;soft green&#39;: &#39;#6fc276&#39;,</span>
<span class="gi">+            &#39;soft pink&#39;: &#39;#fdb0c0&#39;,</span>
<span class="gi">+            &#39;soft purple&#39;: &#39;#a66fb5&#39;,</span>
<span class="gi">+            &#39;spearmint&#39;: &#39;#1ef876&#39;,</span>
<span class="gi">+            &#39;spring green&#39;: &#39;#a9f971&#39;,</span>
<span class="gi">+            &#39;spruce&#39;: &#39;#0a5f38&#39;,</span>
<span class="gi">+            &#39;squash&#39;: &#39;#f2ab15&#39;,</span>
<span class="gi">+            &#39;steel&#39;: &#39;#738595&#39;,</span>
<span class="gi">+            &#39;steel blue&#39;: &#39;#5a7d9a&#39;,</span>
<span class="gi">+            &#39;steel grey&#39;: &#39;#6f828a&#39;,</span>
<span class="gi">+            &#39;stone&#39;: &#39;#ada587&#39;,</span>
<span class="gi">+            &#39;stormy blue&#39;: &#39;#507b9c&#39;,</span>
<span class="gi">+            &#39;straw&#39;: &#39;#fcf679&#39;,</span>
<span class="gi">+            &#39;strawberry&#39;: &#39;#fb2943&#39;,</span>
<span class="gi">+            &#39;strong blue&#39;: &#39;#0c06f7&#39;,</span>
<span class="gi">+            &#39;strong pink&#39;: &#39;#ff0789&#39;,</span>
<span class="gi">+            &#39;sun yellow&#39;: &#39;#ffdf22&#39;,</span>
<span class="gi">+            &#39;sunflower&#39;: &#39;#ffc512&#39;,</span>
<span class="gi">+            &#39;sunflower yellow&#39;: &#39;#ffda03&#39;,</span>
<span class="gi">+            &#39;sunny yellow&#39;: &#39;#fff917&#39;,</span>
<span class="gi">+            &#39;sunshine yellow&#39;: &#39;#fffd37&#39;,</span>
<span class="gi">+            &#39;swamp&#39;: &#39;#698339&#39;,</span>
<span class="gi">+            &#39;swamp green&#39;: &#39;#748500&#39;,</span>
<span class="gi">+            &#39;tan&#39;: &#39;#d1b26f&#39;,</span>
<span class="gi">+            &#39;tan brown&#39;: &#39;#ab7e4c&#39;,</span>
<span class="gi">+            &#39;tan green&#39;: &#39;#a9be70&#39;,</span>
<span class="gi">+            &#39;tangerine&#39;: &#39;#ff9408&#39;,</span>
<span class="gi">+            &#39;taupe&#39;: &#39;#b9a281&#39;,</span>
<span class="gi">+            &#39;tea&#39;: &#39;#65ab7c&#39;,</span>
<span class="gi">+            &#39;tea green&#39;: &#39;#bdf8a3&#39;,</span>
<span class="gi">+            &#39;teal&#39;: &#39;#029386&#39;,</span>
<span class="gi">+            &#39;teal blue&#39;: &#39;#01889f&#39;,</span>
<span class="gi">+            &#39;teal green&#39;: &#39;#25a36f&#39;,</span>
<span class="gi">+            &#39;tealish&#39;: &#39;#24bca8&#39;,</span>
<span class="gi">+            &#39;tealish green&#39;: &#39;#0cdc73&#39;,</span>
<span class="gi">+            &#39;terra cotta&#39;: &#39;#c9643b&#39;,</span>
<span class="gi">+            &#39;terracota&#39;: &#39;#cb6843&#39;,</span>
<span class="gi">+            &#39;terracotta&#39;: &#39;#ca6641&#39;,</span>
<span class="gi">+            &#39;tiffany blue&#39;: &#39;#7bf2da&#39;,</span>
<span class="gi">+            &#39;tomato&#39;: &#39;#ef4026&#39;,</span>
<span class="gi">+            &#39;tomato red&#39;: &#39;#ec2d01&#39;,</span>
<span class="gi">+            &#39;topaz&#39;: &#39;#13bbaf&#39;,</span>
<span class="gi">+            &#39;toupe&#39;: &#39;#c7ac7d&#39;,</span>
<span class="gi">+            &#39;toxic green&#39;: &#39;#61de2a&#39;,</span>
<span class="gi">+            &#39;tree green&#39;: &#39;#2a7e19&#39;,</span>
<span class="gi">+            &#39;true blue&#39;: &#39;#010fcc&#39;,</span>
<span class="gi">+            &#39;true green&#39;: &#39;#089404&#39;,</span>
<span class="gi">+            &#39;turquoise&#39;: &#39;#06c2ac&#39;,</span>
<span class="gi">+            &#39;turquoise blue&#39;: &#39;#06b1c4&#39;,</span>
<span class="gi">+            &#39;turquoise green&#39;: &#39;#04f489&#39;,</span>
<span class="gi">+            &#39;turtle green&#39;: &#39;#75b84f&#39;,</span>
<span class="gi">+            &#39;twilight&#39;: &#39;#4e518b&#39;,</span>
<span class="gi">+            &#39;twilight blue&#39;: &#39;#0a437a&#39;,</span>
<span class="gi">+            &#39;ugly blue&#39;: &#39;#31668a&#39;,</span>
<span class="gi">+            &#39;ugly brown&#39;: &#39;#7d7103&#39;,</span>
<span class="gi">+            &#39;ugly green&#39;: &#39;#7a9703&#39;,</span>
<span class="gi">+            &#39;ugly pink&#39;: &#39;#cd7584&#39;,</span>
<span class="gi">+            &#39;ugly purple&#39;: &#39;#a442a0&#39;,</span>
<span class="gi">+            &#39;ugly yellow&#39;: &#39;#d0c101&#39;,</span>
<span class="gi">+            &#39;ultramarine&#39;: &#39;#2000b1&#39;,</span>
<span class="gi">+            &#39;ultramarine blue&#39;: &#39;#1805db&#39;,</span>
<span class="gi">+            &#39;umber&#39;: &#39;#b26400&#39;,</span>
<span class="gi">+            &#39;velvet&#39;: &#39;#750851&#39;,</span>
<span class="gi">+            &#39;vermillion&#39;: &#39;#f4320c&#39;,</span>
<span class="gi">+            &#39;very dark blue&#39;: &#39;#000133&#39;,</span>
<span class="gi">+            &#39;very dark brown&#39;: &#39;#1d0200&#39;,</span>
<span class="gi">+            &#39;very dark green&#39;: &#39;#062e03&#39;,</span>
<span class="gi">+            &#39;very dark purple&#39;: &#39;#2a0134&#39;,</span>
<span class="gi">+            &#39;very light blue&#39;: &#39;#d5ffff&#39;,</span>
<span class="gi">+            &#39;very light brown&#39;: &#39;#d3b683&#39;,</span>
<span class="gi">+            &#39;very light green&#39;: &#39;#d1ffbd&#39;,</span>
<span class="gi">+            &#39;very light pink&#39;: &#39;#fff4f2&#39;,</span>
<span class="gi">+            &#39;very light purple&#39;: &#39;#f6cefc&#39;,</span>
<span class="gi">+            &#39;very pale blue&#39;: &#39;#d6fffe&#39;,</span>
<span class="gi">+            &#39;very pale green&#39;: &#39;#cffdbc&#39;,</span>
<span class="gi">+            &#39;vibrant blue&#39;: &#39;#0339f8&#39;,</span>
<span class="gi">+            &#39;vibrant green&#39;: &#39;#0add08&#39;,</span>
<span class="gi">+            &#39;vibrant purple&#39;: &#39;#ad03de&#39;,</span>
<span class="gi">+            &#39;violet&#39;: &#39;#9a0eea&#39;,</span>
<span class="gi">+            &#39;violet blue&#39;: &#39;#510ac9&#39;,</span>
<span class="gi">+            &#39;violet pink&#39;: &#39;#fb5ffc&#39;,</span>
<span class="gi">+            &#39;violet red&#39;: &#39;#a50055&#39;,</span>
<span class="gi">+            &#39;viridian&#39;: &#39;#1e9167&#39;,</span>
<span class="gi">+            &#39;vivid blue&#39;: &#39;#152eff&#39;,</span>
<span class="gi">+            &#39;vivid green&#39;: &#39;#2fef10&#39;,</span>
<span class="gi">+            &#39;vivid purple&#39;: &#39;#9900fa&#39;,</span>
<span class="gi">+            &#39;vomit&#39;: &#39;#a2a415&#39;,</span>
<span class="gi">+            &#39;vomit green&#39;: &#39;#89a203&#39;,</span>
<span class="gi">+            &#39;vomit yellow&#39;: &#39;#c7c10c&#39;,</span>
<span class="gi">+            &#39;warm blue&#39;: &#39;#4b57db&#39;,</span>
<span class="gi">+            &#39;warm brown&#39;: &#39;#964e02&#39;,</span>
<span class="gi">+            &#39;warm grey&#39;: &#39;#978a84&#39;,</span>
<span class="gi">+            &#39;warm pink&#39;: &#39;#fb5581&#39;,</span>
<span class="gi">+            &#39;warm purple&#39;: &#39;#952e8f&#39;,</span>
<span class="gi">+            &#39;washed out green&#39;: &#39;#bcf5a6&#39;,</span>
<span class="gi">+            &#39;water blue&#39;: &#39;#0e87cc&#39;,</span>
<span class="gi">+            &#39;watermelon&#39;: &#39;#fd4659&#39;,</span>
<span class="gi">+            &#39;weird green&#39;: &#39;#3ae57f&#39;,</span>
<span class="gi">+            &#39;wheat&#39;: &#39;#fbdd7e&#39;,</span>
<span class="gi">+            &#39;white&#39;: &#39;#ffffff&#39;,</span>
<span class="gi">+            &#39;windows blue&#39;: &#39;#3778bf&#39;,</span>
<span class="gi">+            &#39;wine&#39;: &#39;#80013f&#39;,</span>
<span class="gi">+            &#39;wine red&#39;: &#39;#7b0323&#39;,</span>
<span class="gi">+            &#39;wintergreen&#39;: &#39;#20f986&#39;,</span>
<span class="gi">+            &#39;wisteria&#39;: &#39;#a87dc2&#39;,</span>
<span class="gi">+            &#39;yellow&#39;: &#39;#ffff14&#39;,</span>
<span class="gi">+            &#39;yellow brown&#39;: &#39;#b79400&#39;,</span>
<span class="gi">+            &#39;yellow green&#39;: &#39;#c0fb2d&#39;,</span>
<span class="gi">+            &#39;yellow ochre&#39;: &#39;#cb9d06&#39;,</span>
<span class="gi">+            &#39;yellow orange&#39;: &#39;#fcb001&#39;,</span>
<span class="gi">+            &#39;yellow tan&#39;: &#39;#ffe36e&#39;,</span>
<span class="gi">+            &#39;yellow/green&#39;: &#39;#c8fd3d&#39;,</span>
<span class="gi">+            &#39;yellowgreen&#39;: &#39;#bbf90f&#39;,</span>
<span class="gi">+            &#39;yellowish&#39;: &#39;#faee66&#39;,</span>
<span class="gi">+            &#39;yellowish brown&#39;: &#39;#9b7a01&#39;,</span>
<span class="gi">+            &#39;yellowish green&#39;: &#39;#b0dd16&#39;,</span>
<span class="gi">+            &#39;yellowish orange&#39;: &#39;#ffab0f&#39;,</span>
<span class="gi">+            &#39;yellowish tan&#39;: &#39;#fcfc81&#39;,</span>
<span class="gi">+            &#39;yellowy brown&#39;: &#39;#ae8b0c&#39;,</span>
<span class="gi">+            &#39;yellowy green&#39;: &#39;#bff128&#39;}</span>
<span class="gh">diff --git a/seaborn/distributions.py b/seaborn/distributions.py</span>
<span class="gh">index 36572494..f8ec166c 100644</span>
<span class="gd">--- a/seaborn/distributions.py</span>
<span class="gi">+++ b/seaborn/distributions.py</span>
<span class="gu">@@ -4,6 +4,7 @@ from functools import partial</span>
<span class="w"> </span>import math
<span class="w"> </span>import textwrap
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="gu">@@ -12,111 +13,1444 @@ import matplotlib.transforms as tx</span>
<span class="w"> </span>from matplotlib.cbook import normalize_kwargs
<span class="w"> </span>from matplotlib.colors import to_rgba
<span class="w"> </span>from matplotlib.collections import LineCollection
<span class="gi">+</span>
<span class="w"> </span>from ._base import VectorPlotter
<span class="gi">+</span>
<span class="gi">+# We have moved univariate histogram computation over to the new Hist class,</span>
<span class="gi">+# but still use the older Histogram for bivariate computation.</span>
<span class="w"> </span>from ._statistics import ECDF, Histogram, KDE
<span class="w"> </span>from ._stats.counting import Hist
<span class="gd">-from .axisgrid import FacetGrid, _facet_docs</span>
<span class="gd">-from .utils import remove_na, _get_transform_functions, _kde_support, _check_argument, _assign_default_kwargs, _default_color</span>
<span class="gi">+</span>
<span class="gi">+from .axisgrid import (</span>
<span class="gi">+    FacetGrid,</span>
<span class="gi">+    _facet_docs,</span>
<span class="gi">+)</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    remove_na,</span>
<span class="gi">+    _get_transform_functions,</span>
<span class="gi">+    _kde_support,</span>
<span class="gi">+    _check_argument,</span>
<span class="gi">+    _assign_default_kwargs,</span>
<span class="gi">+    _default_color,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .palettes import color_palette
<span class="w"> </span>from .external import husl
<span class="w"> </span>from .external.kde import gaussian_kde
<span class="gd">-from ._docstrings import DocstringComponents, _core_docs</span>
<span class="gd">-__all__ = [&#39;displot&#39;, &#39;histplot&#39;, &#39;kdeplot&#39;, &#39;ecdfplot&#39;, &#39;rugplot&#39;, &#39;distplot&#39;]</span>
<span class="gd">-_dist_params = dict(multiple=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+from ._docstrings import (</span>
<span class="gi">+    DocstringComponents,</span>
<span class="gi">+    _core_docs,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;displot&quot;, &quot;histplot&quot;, &quot;kdeplot&quot;, &quot;ecdfplot&quot;, &quot;rugplot&quot;, &quot;distplot&quot;]</span>
<span class="gi">+</span>
<span class="gi">+# ==================================================================================== #</span>
<span class="gi">+# Module documentation</span>
<span class="gi">+# ==================================================================================== #</span>
<span class="gi">+</span>
<span class="gi">+_dist_params = dict(</span>
<span class="gi">+</span>
<span class="gi">+    multiple=&quot;&quot;&quot;</span>
<span class="w"> </span>multiple : {{&quot;layer&quot;, &quot;stack&quot;, &quot;fill&quot;}}
<span class="w"> </span>    Method for drawing multiple elements when semantic mapping creates subsets.
<span class="w"> </span>    Only relevant with univariate data.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , log_scale=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    log_scale=&quot;&quot;&quot;</span>
<span class="w"> </span>log_scale : bool or number, or pair of bools or numbers
<span class="w"> </span>    Set axis scale(s) to log. A single value sets the data axis for any numeric
<span class="w"> </span>    axes in the plot. A pair of values sets each axis independently.
<span class="w"> </span>    Numeric values are interpreted as the desired base (default 10).
<span class="w"> </span>    When `None` or `False`, seaborn defers to the existing Axes scale.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , legend=</span>
<span class="gd">-    &#39;\nlegend : bool\n    If False, suppress the legend for semantic variables.\n    &#39;</span>
<span class="gd">-    , cbar=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    legend=&quot;&quot;&quot;</span>
<span class="gi">+legend : bool</span>
<span class="gi">+    If False, suppress the legend for semantic variables.</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    cbar=&quot;&quot;&quot;</span>
<span class="w"> </span>cbar : bool
<span class="w"> </span>    If True, add a colorbar to annotate the color mapping in a bivariate plot.
<span class="w"> </span>    Note: Does not currently support plots with a ``hue`` variable well.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , cbar_ax=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    cbar_ax=&quot;&quot;&quot;</span>
<span class="w"> </span>cbar_ax : :class:`matplotlib.axes.Axes`
<span class="w"> </span>    Pre-existing axes for the colorbar.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , cbar_kws=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    cbar_kws=&quot;&quot;&quot;</span>
<span class="w"> </span>cbar_kws : dict
<span class="w"> </span>    Additional parameters passed to :meth:`matplotlib.figure.Figure.colorbar`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-_param_docs = DocstringComponents.from_nested_components(core=_core_docs[</span>
<span class="gd">-    &#39;params&#39;], facets=DocstringComponents(_facet_docs), dist=</span>
<span class="gd">-    DocstringComponents(_dist_params), kde=DocstringComponents.</span>
<span class="gd">-    from_function_params(KDE.__init__), hist=DocstringComponents.</span>
<span class="gd">-    from_function_params(Histogram.__init__), ecdf=DocstringComponents.</span>
<span class="gd">-    from_function_params(ECDF.__init__))</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_param_docs = DocstringComponents.from_nested_components(</span>
<span class="gi">+    core=_core_docs[&quot;params&quot;],</span>
<span class="gi">+    facets=DocstringComponents(_facet_docs),</span>
<span class="gi">+    dist=DocstringComponents(_dist_params),</span>
<span class="gi">+    kde=DocstringComponents.from_function_params(KDE.__init__),</span>
<span class="gi">+    hist=DocstringComponents.from_function_params(Histogram.__init__),</span>
<span class="gi">+    ecdf=DocstringComponents.from_function_params(ECDF.__init__),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ==================================================================================== #</span>
<span class="gi">+# Internal API</span>
<span class="gi">+# ==================================================================================== #</span>


<span class="w"> </span>class _DistributionPlotter(VectorPlotter):
<span class="gd">-    wide_structure = {&#39;x&#39;: &#39;@values&#39;, &#39;hue&#39;: &#39;@columns&#39;}</span>
<span class="gd">-    flat_structure = {&#39;x&#39;: &#39;@values&#39;}</span>

<span class="gd">-    def __init__(self, data=None, variables={}):</span>
<span class="gi">+    wide_structure = {&quot;x&quot;: &quot;@values&quot;, &quot;hue&quot;: &quot;@columns&quot;}</span>
<span class="gi">+    flat_structure = {&quot;x&quot;: &quot;@values&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        variables={},</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(data=data, variables=variables)

<span class="w"> </span>    @property
<span class="w"> </span>    def univariate(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if only x or y are used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO this could go down to core, but putting it here now.</span>
<span class="gi">+        # We&#39;d want to be conceptually clear that univariate only applies</span>
<span class="gi">+        # to x/y and not to other semantics, which can exist.</span>
<span class="gi">+        # We haven&#39;t settled on a good conceptual name for x/y.</span>
<span class="gi">+        return bool({&quot;x&quot;, &quot;y&quot;} - set(self.variables))</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def data_variable(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the variable with data for univariate plots.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO This could also be in core, but it should have a better name.</span>
<span class="gi">+        if not self.univariate:</span>
<span class="gi">+            raise AttributeError(&quot;This is not a univariate plot&quot;)</span>
<span class="gi">+        return {&quot;x&quot;, &quot;y&quot;}.intersection(self.variables).pop()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def has_xy_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO see above points about where this should go</span>
<span class="gi">+        return bool({&quot;x&quot;, &quot;y&quot;} &amp; set(self.variables))</span>

<span class="gd">-    def _add_legend(self, ax_obj, artist, fill, element, multiple, alpha,</span>
<span class="gd">-        artist_kws, legend_kws):</span>
<span class="gi">+    def _add_legend(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ax_obj, artist, fill, element, multiple, alpha, artist_kws, legend_kws,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add artists that reflect semantic mappings and put then in a legend.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO note that this doesn&#39;t handle numeric mappings like the relational plots</span>
<span class="gi">+        handles = []</span>
<span class="gi">+        labels = []</span>
<span class="gi">+        for level in self._hue_map.levels:</span>
<span class="gi">+            color = self._hue_map(level)</span>
<span class="gi">+</span>
<span class="gi">+            kws = self._artist_kws(</span>
<span class="gi">+                artist_kws, fill, element, multiple, color, alpha</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # color gets added to the kws to workaround an issue with barplot&#39;s color</span>
<span class="gi">+            # cycle integration but it causes problems in this context where we are</span>
<span class="gi">+            # setting artist properties directly, so pop it off here</span>
<span class="gi">+            if &quot;facecolor&quot; in kws:</span>
<span class="gi">+                kws.pop(&quot;color&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            handles.append(artist(**kws))</span>
<span class="gi">+            labels.append(level)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(ax_obj, mpl.axes.Axes):</span>
<span class="gi">+            ax_obj.legend(handles, labels, title=self.variables[&quot;hue&quot;], **legend_kws)</span>
<span class="gi">+        else:  # i.e. a FacetGrid. TODO make this better</span>
<span class="gi">+            legend_data = dict(zip(labels, handles))</span>
<span class="gi">+            ax_obj.add_legend(</span>
<span class="gi">+                legend_data,</span>
<span class="gi">+                title=self.variables[&quot;hue&quot;],</span>
<span class="gi">+                label_order=self.var_levels[&quot;hue&quot;],</span>
<span class="gi">+                **legend_kws</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _artist_kws(self, kws, fill, element, multiple, color, alpha):
<span class="w"> </span>        &quot;&quot;&quot;Handle differences between artists in filled/unfilled plots.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kws = kws.copy()</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            kws = normalize_kwargs(kws, mpl.collections.PolyCollection)</span>
<span class="gi">+            kws.setdefault(&quot;facecolor&quot;, to_rgba(color, alpha))</span>
<span class="gi">+</span>
<span class="gi">+            if element == &quot;bars&quot;:</span>
<span class="gi">+                # Make bar() interface with property cycle correctly</span>
<span class="gi">+                # https://github.com/matplotlib/matplotlib/issues/19385</span>
<span class="gi">+                kws[&quot;color&quot;] = &quot;none&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if multiple in [&quot;stack&quot;, &quot;fill&quot;] or element == &quot;bars&quot;:</span>
<span class="gi">+                kws.setdefault(&quot;edgecolor&quot;, mpl.rcParams[&quot;patch.edgecolor&quot;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                kws.setdefault(&quot;edgecolor&quot;, to_rgba(color, 1))</span>
<span class="gi">+        elif element == &quot;bars&quot;:</span>
<span class="gi">+            kws[&quot;facecolor&quot;] = &quot;none&quot;</span>
<span class="gi">+            kws[&quot;edgecolor&quot;] = to_rgba(color, alpha)</span>
<span class="gi">+        else:</span>
<span class="gi">+            kws[&quot;color&quot;] = to_rgba(color, alpha)</span>
<span class="gi">+        return kws</span>

<span class="w"> </span>    def _quantile_to_level(self, data, quantile):
<span class="w"> </span>        &quot;&quot;&quot;Return data levels corresponding to quantile cuts of mass.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        isoprop = np.asarray(quantile)</span>
<span class="gi">+        values = np.ravel(data)</span>
<span class="gi">+        sorted_values = np.sort(values)[::-1]</span>
<span class="gi">+        normalized_values = np.cumsum(sorted_values) / values.sum()</span>
<span class="gi">+        idx = np.searchsorted(normalized_values, 1 - isoprop)</span>
<span class="gi">+        levels = np.take(sorted_values, idx, mode=&quot;clip&quot;)</span>
<span class="gi">+        return levels</span>

<span class="w"> </span>    def _cmap_from_color(self, color):
<span class="w"> </span>        &quot;&quot;&quot;Return a sequential colormap given a color seed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Like so much else here, this is broadly useful, but keeping it</span>
<span class="gi">+        # in this class to signify that I haven&#39;t thought overly hard about it...</span>
<span class="gi">+        r, g, b, _ = to_rgba(color)</span>
<span class="gi">+        h, s, _ = husl.rgb_to_husl(r, g, b)</span>
<span class="gi">+        xx = np.linspace(-1, 1, int(1.15 * 256))[:256]</span>
<span class="gi">+        ramp = np.zeros((256, 3))</span>
<span class="gi">+        ramp[:, 0] = h</span>
<span class="gi">+        ramp[:, 1] = s * np.cos(xx)</span>
<span class="gi">+        ramp[:, 2] = np.linspace(35, 80, 256)</span>
<span class="gi">+        colors = np.clip([husl.husl_to_rgb(*hsl) for hsl in ramp], 0, 1)</span>
<span class="gi">+        return mpl.colors.ListedColormap(colors[::-1])</span>

<span class="w"> </span>    def _default_discrete(self):
<span class="w"> </span>        &quot;&quot;&quot;Find default values for discrete hist estimation based on variable type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.univariate:</span>
<span class="gi">+            discrete = self.var_types[self.data_variable] == &quot;categorical&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            discrete_x = self.var_types[&quot;x&quot;] == &quot;categorical&quot;</span>
<span class="gi">+            discrete_y = self.var_types[&quot;y&quot;] == &quot;categorical&quot;</span>
<span class="gi">+            discrete = discrete_x, discrete_y</span>
<span class="gi">+        return discrete</span>

<span class="w"> </span>    def _resolve_multiple(self, curves, multiple):
<span class="w"> </span>        &quot;&quot;&quot;Modify the density data structure to handle multiple densities.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Default baselines have all densities starting at 0</span>
<span class="gi">+        baselines = {k: np.zeros_like(v) for k, v in curves.items()}</span>
<span class="gi">+</span>
<span class="gi">+        # TODO we should have some central clearinghouse for checking if any</span>
<span class="gi">+        # &quot;grouping&quot; (terminnology?) semantics have been assigned</span>
<span class="gi">+        if &quot;hue&quot; not in self.variables:</span>
<span class="gi">+            return curves, baselines</span>
<span class="gi">+</span>
<span class="gi">+        if multiple in (&quot;stack&quot;, &quot;fill&quot;):</span>
<span class="gi">+</span>
<span class="gi">+            # Setting stack or fill means that the curves share a</span>
<span class="gi">+            # support grid / set of bin edges, so we can make a dataframe</span>
<span class="gi">+            # Reverse the column order to plot from top to bottom</span>
<span class="gi">+            curves = pd.DataFrame(curves).iloc[:, ::-1]</span>
<span class="gi">+</span>
<span class="gi">+            # Find column groups that are nested within col/row variables</span>
<span class="gi">+            column_groups = {}</span>
<span class="gi">+            for i, keyd in enumerate(map(dict, curves.columns)):</span>
<span class="gi">+                facet_key = keyd.get(&quot;col&quot;, None), keyd.get(&quot;row&quot;, None)</span>
<span class="gi">+                column_groups.setdefault(facet_key, [])</span>
<span class="gi">+                column_groups[facet_key].append(i)</span>
<span class="gi">+</span>
<span class="gi">+            baselines = curves.copy()</span>
<span class="gi">+</span>
<span class="gi">+            for col_idxs in column_groups.values():</span>
<span class="gi">+                cols = curves.columns[col_idxs]</span>
<span class="gi">+</span>
<span class="gi">+                norm_constant = curves[cols].sum(axis=&quot;columns&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Take the cumulative sum to stack</span>
<span class="gi">+                curves[cols] = curves[cols].cumsum(axis=&quot;columns&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Normalize by row sum to fill</span>
<span class="gi">+                if multiple == &quot;fill&quot;:</span>
<span class="gi">+                    curves[cols] = curves[cols].div(norm_constant, axis=&quot;index&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Define where each segment starts</span>
<span class="gi">+                baselines[cols] = curves[cols].shift(1, axis=1).fillna(0)</span>
<span class="gi">+</span>
<span class="gi">+        if multiple == &quot;dodge&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            # Account for the unique semantic (non-faceting) levels</span>
<span class="gi">+            # This will require rethiniking if we add other semantics!</span>
<span class="gi">+            hue_levels = self.var_levels[&quot;hue&quot;]</span>
<span class="gi">+            n = len(hue_levels)</span>
<span class="gi">+            f_fwd, f_inv = self._get_scale_transforms(self.data_variable)</span>
<span class="gi">+            for key in curves:</span>
<span class="gi">+</span>
<span class="gi">+                level = dict(key)[&quot;hue&quot;]</span>
<span class="gi">+                hist = curves[key].reset_index(name=&quot;heights&quot;)</span>
<span class="gi">+                level_idx = hue_levels.index(level)</span>
<span class="gi">+</span>
<span class="gi">+                a = f_fwd(hist[&quot;edges&quot;])</span>
<span class="gi">+                b = f_fwd(hist[&quot;edges&quot;] + hist[&quot;widths&quot;])</span>
<span class="gi">+                w = (b - a) / n</span>
<span class="gi">+                new_min = f_inv(a + level_idx * w)</span>
<span class="gi">+                new_max = f_inv(a + (level_idx + 1) * w)</span>
<span class="gi">+                hist[&quot;widths&quot;] = new_max - new_min</span>
<span class="gi">+                hist[&quot;edges&quot;] = new_min</span>
<span class="gi">+</span>
<span class="gi">+                curves[key] = hist.set_index([&quot;edges&quot;, &quot;widths&quot;])[&quot;heights&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        return curves, baselines</span>
<span class="gi">+</span>
<span class="gi">+    # -------------------------------------------------------------------------------- #</span>
<span class="gi">+    # Computation</span>
<span class="gi">+    # -------------------------------------------------------------------------------- #</span>
<span class="gi">+</span>
<span class="gi">+    def _compute_univariate_density(</span>
<span class="gi">+        self,</span>
<span class="gi">+        data_variable,</span>
<span class="gi">+        common_norm,</span>
<span class="gi">+        common_grid,</span>
<span class="gi">+        estimate_kws,</span>
<span class="gi">+        warn_singular=True,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize the estimator object</span>
<span class="gi">+        estimator = KDE(**estimate_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if set(self.variables) - {&quot;x&quot;, &quot;y&quot;}:</span>
<span class="gi">+            if common_grid:</span>
<span class="gi">+                all_observations = self.comp_data.dropna()</span>
<span class="gi">+                estimator.define_support(all_observations[data_variable])</span>
<span class="gi">+        else:</span>
<span class="gi">+            common_norm = False</span>
<span class="gi">+</span>
<span class="gi">+        all_data = self.plot_data.dropna()</span>
<span class="gi">+        if common_norm and &quot;weights&quot; in all_data:</span>
<span class="gi">+            whole_weight = all_data[&quot;weights&quot;].sum()</span>
<span class="gi">+        else:</span>
<span class="gi">+            whole_weight = len(all_data)</span>
<span class="gi">+</span>
<span class="gi">+        densities = {}</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(&quot;hue&quot;, from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            # Extract the data points from this sub set and remove nulls</span>
<span class="gi">+            observations = sub_data[data_variable]</span>
<span class="gi">+</span>
<span class="gi">+            # Extract the weights for this subset of observations</span>
<span class="gi">+            if &quot;weights&quot; in self.variables:</span>
<span class="gi">+                weights = sub_data[&quot;weights&quot;]</span>
<span class="gi">+                part_weight = weights.sum()</span>
<span class="gi">+            else:</span>
<span class="gi">+                weights = None</span>
<span class="gi">+                part_weight = len(sub_data)</span>
<span class="gi">+</span>
<span class="gi">+            # Estimate the density of observations at this level</span>
<span class="gi">+            variance = np.nan_to_num(observations.var())</span>
<span class="gi">+            singular = len(observations) &lt; 2 or math.isclose(variance, 0)</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not singular:</span>
<span class="gi">+                    # Convoluted approach needed because numerical failures</span>
<span class="gi">+                    # can manifest in a few different ways.</span>
<span class="gi">+                    density, support = estimator(observations, weights=weights)</span>
<span class="gi">+            except np.linalg.LinAlgError:</span>
<span class="gi">+                singular = True</span>
<span class="gi">+</span>
<span class="gi">+            if singular:</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    &quot;Dataset has 0 variance; skipping density estimate. &quot;</span>
<span class="gi">+                    &quot;Pass `warn_singular=False` to disable this warning.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                if warn_singular:</span>
<span class="gi">+                    warnings.warn(msg, UserWarning, stacklevel=4)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Invert the scaling of the support points</span>
<span class="gi">+            _, f_inv = self._get_scale_transforms(self.data_variable)</span>
<span class="gi">+            support = f_inv(support)</span>
<span class="gi">+</span>
<span class="gi">+            # Apply a scaling factor so that the integral over all subsets is 1</span>
<span class="gi">+            if common_norm:</span>
<span class="gi">+                density *= part_weight / whole_weight</span>
<span class="gi">+</span>
<span class="gi">+            # Store the density for this level</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            densities[key] = pd.Series(density, index=support)</span>
<span class="gi">+</span>
<span class="gi">+        return densities</span>
<span class="gi">+</span>
<span class="gi">+    # -------------------------------------------------------------------------------- #</span>
<span class="gi">+    # Plotting</span>
<span class="gi">+    # -------------------------------------------------------------------------------- #</span>
<span class="gi">+</span>
<span class="gi">+    def plot_univariate_histogram(</span>
<span class="gi">+        self,</span>
<span class="gi">+        multiple,</span>
<span class="gi">+        element,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        common_norm,</span>
<span class="gi">+        common_bins,</span>
<span class="gi">+        shrink,</span>
<span class="gi">+        kde,</span>
<span class="gi">+        kde_kws,</span>
<span class="gi">+        color,</span>
<span class="gi">+        legend,</span>
<span class="gi">+        line_kws,</span>
<span class="gi">+        estimate_kws,</span>
<span class="gi">+        **plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # -- Default keyword dicts</span>
<span class="gi">+        kde_kws = {} if kde_kws is None else kde_kws.copy()</span>
<span class="gi">+        line_kws = {} if line_kws is None else line_kws.copy()</span>
<span class="gi">+        estimate_kws = {} if estimate_kws is None else estimate_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # --  Input checking</span>
<span class="gi">+        _check_argument(&quot;multiple&quot;, [&quot;layer&quot;, &quot;stack&quot;, &quot;fill&quot;, &quot;dodge&quot;], multiple)</span>
<span class="gi">+        _check_argument(&quot;element&quot;, [&quot;bars&quot;, &quot;step&quot;, &quot;poly&quot;], element)</span>
<span class="gi">+</span>
<span class="gi">+        auto_bins_with_weights = (</span>
<span class="gi">+            &quot;weights&quot; in self.variables</span>
<span class="gi">+            and estimate_kws[&quot;bins&quot;] == &quot;auto&quot;</span>
<span class="gi">+            and estimate_kws[&quot;binwidth&quot;] is None</span>
<span class="gi">+            and not estimate_kws[&quot;discrete&quot;]</span>
<span class="gi">+        )</span>
<span class="gi">+        if auto_bins_with_weights:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;`bins` cannot be &#39;auto&#39; when using weights. &quot;</span>
<span class="gi">+                &quot;Setting `bins=10`, but you will likely want to adjust.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            warnings.warn(msg, UserWarning)</span>
<span class="gi">+            estimate_kws[&quot;bins&quot;] = 10</span>
<span class="gi">+</span>
<span class="gi">+        # Simplify downstream code if we are not normalizing</span>
<span class="gi">+        if estimate_kws[&quot;stat&quot;] == &quot;count&quot;:</span>
<span class="gi">+            common_norm = False</span>
<span class="gi">+</span>
<span class="gi">+        orient = self.data_variable</span>
<span class="gi">+</span>
<span class="gi">+        # Now initialize the Histogram estimator</span>
<span class="gi">+        estimator = Hist(**estimate_kws)</span>
<span class="gi">+        histograms = {}</span>
<span class="gi">+</span>
<span class="gi">+        # Do pre-compute housekeeping related to multiple groups</span>
<span class="gi">+        all_data = self.comp_data.dropna()</span>
<span class="gi">+        all_weights = all_data.get(&quot;weights&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        multiple_histograms = set(self.variables) - {&quot;x&quot;, &quot;y&quot;}</span>
<span class="gi">+        if multiple_histograms:</span>
<span class="gi">+            if common_bins:</span>
<span class="gi">+                bin_kws = estimator._define_bin_params(all_data, orient, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            common_norm = False</span>
<span class="gi">+</span>
<span class="gi">+        if common_norm and all_weights is not None:</span>
<span class="gi">+            whole_weight = all_weights.sum()</span>
<span class="gi">+        else:</span>
<span class="gi">+            whole_weight = len(all_data)</span>
<span class="gi">+</span>
<span class="gi">+        # Estimate the smoothed kernel densities, for use later</span>
<span class="gi">+        if kde:</span>
<span class="gi">+            # TODO alternatively, clip at min/max bins?</span>
<span class="gi">+            kde_kws.setdefault(&quot;cut&quot;, 0)</span>
<span class="gi">+            kde_kws[&quot;cumulative&quot;] = estimate_kws[&quot;cumulative&quot;]</span>
<span class="gi">+            densities = self._compute_univariate_density(</span>
<span class="gi">+                self.data_variable,</span>
<span class="gi">+                common_norm,</span>
<span class="gi">+                common_bins,</span>
<span class="gi">+                kde_kws,</span>
<span class="gi">+                warn_singular=False,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # First pass through the data to compute the histograms</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(&quot;hue&quot;, from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            # Prepare the relevant data</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            orient = self.data_variable</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;weights&quot; in self.variables:</span>
<span class="gi">+                sub_data[&quot;weight&quot;] = sub_data.pop(&quot;weights&quot;)</span>
<span class="gi">+                part_weight = sub_data[&quot;weight&quot;].sum()</span>
<span class="gi">+            else:</span>
<span class="gi">+                part_weight = len(sub_data)</span>
<span class="gi">+</span>
<span class="gi">+            # Do the histogram computation</span>
<span class="gi">+            if not (multiple_histograms and common_bins):</span>
<span class="gi">+                bin_kws = estimator._define_bin_params(sub_data, orient, None)</span>
<span class="gi">+            res = estimator._normalize(estimator._eval(sub_data, orient, bin_kws))</span>
<span class="gi">+            heights = res[estimator.stat].to_numpy()</span>
<span class="gi">+            widths = res[&quot;space&quot;].to_numpy()</span>
<span class="gi">+            edges = res[orient].to_numpy() - widths / 2</span>
<span class="gi">+</span>
<span class="gi">+            # Rescale the smoothed curve to match the histogram</span>
<span class="gi">+            if kde and key in densities:</span>
<span class="gi">+                density = densities[key]</span>
<span class="gi">+                if estimator.cumulative:</span>
<span class="gi">+                    hist_norm = heights.max()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    hist_norm = (heights * widths).sum()</span>
<span class="gi">+                densities[key] *= hist_norm</span>
<span class="gi">+</span>
<span class="gi">+            # Convert edges back to original units for plotting</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+            _, inv = _get_transform_functions(ax, self.data_variable)</span>
<span class="gi">+            widths = inv(edges + widths) - inv(edges)</span>
<span class="gi">+            edges = inv(edges)</span>
<span class="gi">+</span>
<span class="gi">+            # Pack the histogram data and metadata together</span>
<span class="gi">+            edges = edges + (1 - shrink) / 2 * widths</span>
<span class="gi">+            widths *= shrink</span>
<span class="gi">+            index = pd.MultiIndex.from_arrays([</span>
<span class="gi">+                pd.Index(edges, name=&quot;edges&quot;),</span>
<span class="gi">+                pd.Index(widths, name=&quot;widths&quot;),</span>
<span class="gi">+            ])</span>
<span class="gi">+            hist = pd.Series(heights, index=index, name=&quot;heights&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # Apply scaling to normalize across groups</span>
<span class="gi">+            if common_norm:</span>
<span class="gi">+                hist *= part_weight / whole_weight</span>
<span class="gi">+</span>
<span class="gi">+            # Store the finalized histogram data for future plotting</span>
<span class="gi">+            histograms[key] = hist</span>
<span class="gi">+</span>
<span class="gi">+        # Modify the histogram and density data to resolve multiple groups</span>
<span class="gi">+        histograms, baselines = self._resolve_multiple(histograms, multiple)</span>
<span class="gi">+        if kde:</span>
<span class="gi">+            densities, _ = self._resolve_multiple(</span>
<span class="gi">+                densities, None if multiple == &quot;dodge&quot; else multiple</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Set autoscaling-related meta</span>
<span class="gi">+        sticky_stat = (0, 1) if multiple == &quot;fill&quot; else (0, np.inf)</span>
<span class="gi">+        if multiple == &quot;fill&quot;:</span>
<span class="gi">+            # Filled plots should not have any margins</span>
<span class="gi">+            bin_vals = histograms.index.to_frame()</span>
<span class="gi">+            edges = bin_vals[&quot;edges&quot;]</span>
<span class="gi">+            widths = bin_vals[&quot;widths&quot;]</span>
<span class="gi">+            sticky_data = (</span>
<span class="gi">+                edges.min(),</span>
<span class="gi">+                edges.max() + widths.loc[edges.idxmax()]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            sticky_data = []</span>
<span class="gi">+</span>
<span class="gi">+        # --- Handle default visual attributes</span>
<span class="gi">+</span>
<span class="gi">+        # Note: default linewidth is determined after plotting</span>
<span class="gi">+</span>
<span class="gi">+        # Default alpha should depend on other parameters</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            # Note: will need to account for other grouping semantics if added</span>
<span class="gi">+            if &quot;hue&quot; in self.variables and multiple == &quot;layer&quot;:</span>
<span class="gi">+                default_alpha = .5 if element == &quot;bars&quot; else .25</span>
<span class="gi">+            elif kde:</span>
<span class="gi">+                default_alpha = .5</span>
<span class="gi">+            else:</span>
<span class="gi">+                default_alpha = .75</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_alpha = 1</span>
<span class="gi">+        alpha = plot_kws.pop(&quot;alpha&quot;, default_alpha)  # TODO make parameter?</span>
<span class="gi">+</span>
<span class="gi">+        hist_artists = []</span>
<span class="gi">+</span>
<span class="gi">+        # Go back through the dataset and draw the plots</span>
<span class="gi">+        for sub_vars, _ in self.iter_data(&quot;hue&quot;, reverse=True):</span>
<span class="gi">+</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            hist = histograms[key].rename(&quot;heights&quot;).reset_index()</span>
<span class="gi">+            bottom = np.asarray(baselines[key])</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            # Define the matplotlib attributes that depend on semantic mapping</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                sub_color = self._hue_map(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                sub_color = color</span>
<span class="gi">+</span>
<span class="gi">+            artist_kws = self._artist_kws(</span>
<span class="gi">+                plot_kws, fill, element, multiple, sub_color, alpha</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if element == &quot;bars&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                # Use matplotlib bar plotting</span>
<span class="gi">+</span>
<span class="gi">+                plot_func = ax.bar if self.data_variable == &quot;x&quot; else ax.barh</span>
<span class="gi">+                artists = plot_func(</span>
<span class="gi">+                    hist[&quot;edges&quot;],</span>
<span class="gi">+                    hist[&quot;heights&quot;] - bottom,</span>
<span class="gi">+                    hist[&quot;widths&quot;],</span>
<span class="gi">+                    bottom,</span>
<span class="gi">+                    align=&quot;edge&quot;,</span>
<span class="gi">+                    **artist_kws,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                for bar in artists:</span>
<span class="gi">+                    if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+                        bar.sticky_edges.x[:] = sticky_data</span>
<span class="gi">+                        bar.sticky_edges.y[:] = sticky_stat</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        bar.sticky_edges.x[:] = sticky_stat</span>
<span class="gi">+                        bar.sticky_edges.y[:] = sticky_data</span>
<span class="gi">+</span>
<span class="gi">+                hist_artists.extend(artists)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                # Use either fill_between or plot to draw hull of histogram</span>
<span class="gi">+                if element == &quot;step&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                    final = hist.iloc[-1]</span>
<span class="gi">+                    x = np.append(hist[&quot;edges&quot;], final[&quot;edges&quot;] + final[&quot;widths&quot;])</span>
<span class="gi">+                    y = np.append(hist[&quot;heights&quot;], final[&quot;heights&quot;])</span>
<span class="gi">+                    b = np.append(bottom, bottom[-1])</span>
<span class="gi">+</span>
<span class="gi">+                    if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+                        step = &quot;post&quot;</span>
<span class="gi">+                        drawstyle = &quot;steps-post&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        step = &quot;post&quot;  # fillbetweenx handles mapping internally</span>
<span class="gi">+                        drawstyle = &quot;steps-pre&quot;</span>
<span class="gi">+</span>
<span class="gi">+                elif element == &quot;poly&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                    x = hist[&quot;edges&quot;] + hist[&quot;widths&quot;] / 2</span>
<span class="gi">+                    y = hist[&quot;heights&quot;]</span>
<span class="gi">+                    b = bottom</span>
<span class="gi">+</span>
<span class="gi">+                    step = None</span>
<span class="gi">+                    drawstyle = None</span>
<span class="gi">+</span>
<span class="gi">+                if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+                    if fill:</span>
<span class="gi">+                        artist = ax.fill_between(x, b, y, step=step, **artist_kws)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        artist, = ax.plot(x, y, drawstyle=drawstyle, **artist_kws)</span>
<span class="gi">+                    artist.sticky_edges.x[:] = sticky_data</span>
<span class="gi">+                    artist.sticky_edges.y[:] = sticky_stat</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if fill:</span>
<span class="gi">+                        artist = ax.fill_betweenx(x, b, y, step=step, **artist_kws)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        artist, = ax.plot(y, x, drawstyle=drawstyle, **artist_kws)</span>
<span class="gi">+                    artist.sticky_edges.x[:] = sticky_stat</span>
<span class="gi">+                    artist.sticky_edges.y[:] = sticky_data</span>
<span class="gi">+</span>
<span class="gi">+                hist_artists.append(artist)</span>
<span class="gi">+</span>
<span class="gi">+            if kde:</span>
<span class="gi">+</span>
<span class="gi">+                # Add in the density curves</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    density = densities[key]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                support = density.index</span>
<span class="gi">+</span>
<span class="gi">+                if &quot;x&quot; in self.variables:</span>
<span class="gi">+                    line_args = support, density</span>
<span class="gi">+                    sticky_x, sticky_y = None, (0, np.inf)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    line_args = density, support</span>
<span class="gi">+                    sticky_x, sticky_y = (0, np.inf), None</span>
<span class="gi">+</span>
<span class="gi">+                line_kws[&quot;color&quot;] = to_rgba(sub_color, 1)</span>
<span class="gi">+                line, = ax.plot(</span>
<span class="gi">+                    *line_args, **line_kws,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if sticky_x is not None:</span>
<span class="gi">+                    line.sticky_edges.x[:] = sticky_x</span>
<span class="gi">+                if sticky_y is not None:</span>
<span class="gi">+                    line.sticky_edges.y[:] = sticky_y</span>
<span class="gi">+</span>
<span class="gi">+        if element == &quot;bars&quot; and &quot;linewidth&quot; not in plot_kws:</span>
<span class="gi">+</span>
<span class="gi">+            # Now we handle linewidth, which depends on the scaling of the plot</span>
<span class="gi">+</span>
<span class="gi">+            # We will base everything on the minimum bin width</span>
<span class="gi">+            hist_metadata = pd.concat([</span>
<span class="gi">+                # Use .items for generality over dict or df</span>
<span class="gi">+                h.index.to_frame() for _, h in histograms.items()</span>
<span class="gi">+            ]).reset_index(drop=True)</span>
<span class="gi">+            thin_bar_idx = hist_metadata[&quot;widths&quot;].idxmin()</span>
<span class="gi">+            binwidth = hist_metadata.loc[thin_bar_idx, &quot;widths&quot;]</span>
<span class="gi">+            left_edge = hist_metadata.loc[thin_bar_idx, &quot;edges&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            # Set initial value</span>
<span class="gi">+            default_linewidth = math.inf</span>
<span class="gi">+</span>
<span class="gi">+            # Loop through subsets based only on facet variables</span>
<span class="gi">+            for sub_vars, _ in self.iter_data():</span>
<span class="gi">+</span>
<span class="gi">+                ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+                # Needed in some cases to get valid transforms.</span>
<span class="gi">+                # Innocuous in other cases?</span>
<span class="gi">+                ax.autoscale_view()</span>
<span class="gi">+</span>
<span class="gi">+                # Convert binwidth from data coordinates to pixels</span>
<span class="gi">+                pts_x, pts_y = 72 / ax.figure.dpi * abs(</span>
<span class="gi">+                    ax.transData.transform([left_edge + binwidth] * 2)</span>
<span class="gi">+                    - ax.transData.transform([left_edge] * 2)</span>
<span class="gi">+                )</span>
<span class="gi">+                if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+                    binwidth_points = pts_x</span>
<span class="gi">+                else:</span>
<span class="gi">+                    binwidth_points = pts_y</span>
<span class="gi">+</span>
<span class="gi">+                # The relative size of the lines depends on the appearance</span>
<span class="gi">+                # This is a provisional value and may need more tweaking</span>
<span class="gi">+                default_linewidth = min(.1 * binwidth_points, default_linewidth)</span>
<span class="gi">+</span>
<span class="gi">+            # Set the attributes</span>
<span class="gi">+            for bar in hist_artists:</span>
<span class="gi">+</span>
<span class="gi">+                # Don&#39;t let the lines get too thick</span>
<span class="gi">+                max_linewidth = bar.get_linewidth()</span>
<span class="gi">+                if not fill:</span>
<span class="gi">+                    max_linewidth *= 1.5</span>
<span class="gi">+</span>
<span class="gi">+                linewidth = min(default_linewidth, max_linewidth)</span>
<span class="gi">+</span>
<span class="gi">+                # If not filling, don&#39;t let lines disappear</span>
<span class="gi">+                if not fill:</span>
<span class="gi">+                    min_linewidth = .5</span>
<span class="gi">+                    linewidth = max(linewidth, min_linewidth)</span>
<span class="gi">+</span>
<span class="gi">+                bar.set_linewidth(linewidth)</span>
<span class="gi">+</span>
<span class="gi">+        # --- Finalize the plot ----</span>
<span class="gi">+</span>
<span class="gi">+        # Axis labels</span>
<span class="gi">+        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]</span>
<span class="gi">+        default_x = default_y = &quot;&quot;</span>
<span class="gi">+        if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+            default_y = estimator.stat.capitalize()</span>
<span class="gi">+        if self.data_variable == &quot;y&quot;:</span>
<span class="gi">+            default_x = estimator.stat.capitalize()</span>
<span class="gi">+        self._add_axis_labels(ax, default_x, default_y)</span>
<span class="gi">+</span>
<span class="gi">+        # Legend for semantic variables</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+</span>
<span class="gi">+            if fill or element == &quot;bars&quot;:</span>
<span class="gi">+                artist = partial(mpl.patches.Patch)</span>
<span class="gi">+            else:</span>
<span class="gi">+                artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+</span>
<span class="gi">+            ax_obj = self.ax if self.ax is not None else self.facets</span>
<span class="gi">+            self._add_legend(</span>
<span class="gi">+                ax_obj, artist, fill, element, multiple, alpha, plot_kws, {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def plot_bivariate_histogram(</span>
<span class="gi">+        self,</span>
<span class="gi">+        common_bins, common_norm,</span>
<span class="gi">+        thresh, pthresh, pmax,</span>
<span class="gi">+        color, legend,</span>
<span class="gi">+        cbar, cbar_ax, cbar_kws,</span>
<span class="gi">+        estimate_kws,</span>
<span class="gi">+        **plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # Default keyword dicts</span>
<span class="gi">+        cbar_kws = {} if cbar_kws is None else cbar_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # Now initialize the Histogram estimator</span>
<span class="gi">+        estimator = Histogram(**estimate_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Do pre-compute housekeeping related to multiple groups</span>
<span class="gi">+        if set(self.variables) - {&quot;x&quot;, &quot;y&quot;}:</span>
<span class="gi">+            all_data = self.comp_data.dropna()</span>
<span class="gi">+            if common_bins:</span>
<span class="gi">+                estimator.define_bin_params(</span>
<span class="gi">+                    all_data[&quot;x&quot;],</span>
<span class="gi">+                    all_data[&quot;y&quot;],</span>
<span class="gi">+                    all_data.get(&quot;weights&quot;, None),</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            common_norm = False</span>
<span class="gi">+</span>
<span class="gi">+        # -- Determine colormap threshold and norm based on the full data</span>
<span class="gi">+</span>
<span class="gi">+        full_heights = []</span>
<span class="gi">+        for _, sub_data in self.iter_data(from_comp_data=True):</span>
<span class="gi">+            sub_heights, _ = estimator(</span>
<span class="gi">+                sub_data[&quot;x&quot;], sub_data[&quot;y&quot;], sub_data.get(&quot;weights&quot;, None)</span>
<span class="gi">+            )</span>
<span class="gi">+            full_heights.append(sub_heights)</span>
<span class="gi">+</span>
<span class="gi">+        common_color_norm = not set(self.variables) - {&quot;x&quot;, &quot;y&quot;} or common_norm</span>
<span class="gi">+</span>
<span class="gi">+        if pthresh is not None and common_color_norm:</span>
<span class="gi">+            thresh = self._quantile_to_level(full_heights, pthresh)</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws.setdefault(&quot;vmin&quot;, 0)</span>
<span class="gi">+        if common_color_norm:</span>
<span class="gi">+            if pmax is not None:</span>
<span class="gi">+                vmax = self._quantile_to_level(full_heights, pmax)</span>
<span class="gi">+            else:</span>
<span class="gi">+                vmax = plot_kws.pop(&quot;vmax&quot;, max(map(np.max, full_heights)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            vmax = None</span>
<span class="gi">+</span>
<span class="gi">+        # Get a default color</span>
<span class="gi">+        # (We won&#39;t follow the color cycle here, as multiple plots are unlikely)</span>
<span class="gi">+        if color is None:</span>
<span class="gi">+            color = &quot;C0&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # --- Loop over data (subsets) and draw the histograms</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(&quot;hue&quot;, from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            if sub_data.empty:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Do the histogram computation</span>
<span class="gi">+            heights, (x_edges, y_edges) = estimator(</span>
<span class="gi">+                sub_data[&quot;x&quot;],</span>
<span class="gi">+                sub_data[&quot;y&quot;],</span>
<span class="gi">+                weights=sub_data.get(&quot;weights&quot;, None),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Get the axes for this plot</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            # Invert the scale for the edges</span>
<span class="gi">+            _, inv_x = _get_transform_functions(ax, &quot;x&quot;)</span>
<span class="gi">+            _, inv_y = _get_transform_functions(ax, &quot;y&quot;)</span>
<span class="gi">+            x_edges = inv_x(x_edges)</span>
<span class="gi">+            y_edges = inv_y(y_edges)</span>
<span class="gi">+</span>
<span class="gi">+            # Apply scaling to normalize across groups</span>
<span class="gi">+            if estimator.stat != &quot;count&quot; and common_norm:</span>
<span class="gi">+                heights *= len(sub_data) / len(all_data)</span>
<span class="gi">+</span>
<span class="gi">+            # Define the specific kwargs for this artist</span>
<span class="gi">+            artist_kws = plot_kws.copy()</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                color = self._hue_map(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+                cmap = self._cmap_from_color(color)</span>
<span class="gi">+                artist_kws[&quot;cmap&quot;] = cmap</span>
<span class="gi">+            else:</span>
<span class="gi">+                cmap = artist_kws.pop(&quot;cmap&quot;, None)</span>
<span class="gi">+                if isinstance(cmap, str):</span>
<span class="gi">+                    cmap = color_palette(cmap, as_cmap=True)</span>
<span class="gi">+                elif cmap is None:</span>
<span class="gi">+                    cmap = self._cmap_from_color(color)</span>
<span class="gi">+                artist_kws[&quot;cmap&quot;] = cmap</span>
<span class="gi">+</span>
<span class="gi">+            # Set the upper norm on the colormap</span>
<span class="gi">+            if not common_color_norm and pmax is not None:</span>
<span class="gi">+                vmax = self._quantile_to_level(heights, pmax)</span>
<span class="gi">+            if vmax is not None:</span>
<span class="gi">+                artist_kws[&quot;vmax&quot;] = vmax</span>
<span class="gi">+</span>
<span class="gi">+            # Make cells at or below the threshold transparent</span>
<span class="gi">+            if not common_color_norm and pthresh:</span>
<span class="gi">+                thresh = self._quantile_to_level(heights, pthresh)</span>
<span class="gi">+            if thresh is not None:</span>
<span class="gi">+                heights = np.ma.masked_less_equal(heights, thresh)</span>
<span class="gi">+</span>
<span class="gi">+            # pcolormesh is going to turn the grid off, but we want to keep it</span>
<span class="gi">+            # I&#39;m not sure if there&#39;s a better way to get the grid state</span>
<span class="gi">+            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])</span>
<span class="gi">+            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])</span>
<span class="gi">+</span>
<span class="gi">+            mesh = ax.pcolormesh(</span>
<span class="gi">+                x_edges,</span>
<span class="gi">+                y_edges,</span>
<span class="gi">+                heights.T,</span>
<span class="gi">+                **artist_kws,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # pcolormesh sets sticky edges, but we only want them if not thresholding</span>
<span class="gi">+            if thresh is not None:</span>
<span class="gi">+                mesh.sticky_edges.x[:] = []</span>
<span class="gi">+                mesh.sticky_edges.y[:] = []</span>
<span class="gi">+</span>
<span class="gi">+            # Add an optional colorbar</span>
<span class="gi">+            # Note, we want to improve this. When hue is used, it will stack</span>
<span class="gi">+            # multiple colorbars with redundant ticks in an ugly way.</span>
<span class="gi">+            # But it&#39;s going to take some work to have multiple colorbars that</span>
<span class="gi">+            # share ticks nicely.</span>
<span class="gi">+            if cbar:</span>
<span class="gi">+                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)</span>
<span class="gi">+</span>
<span class="gi">+            # Reset the grid state</span>
<span class="gi">+            if x_grid:</span>
<span class="gi">+                ax.grid(True, axis=&quot;x&quot;)</span>
<span class="gi">+            if y_grid:</span>
<span class="gi">+                ax.grid(True, axis=&quot;y&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # --- Finalize the plot</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]</span>
<span class="gi">+        self._add_axis_labels(ax)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+</span>
<span class="gi">+            # TODO if possible, I would like to move the contour</span>
<span class="gi">+            # intensity information into the legend too and label the</span>
<span class="gi">+            # iso proportions rather than the raw density values</span>
<span class="gi">+</span>
<span class="gi">+            artist_kws = {}</span>
<span class="gi">+            artist = partial(mpl.patches.Patch)</span>
<span class="gi">+            ax_obj = self.ax if self.ax is not None else self.facets</span>
<span class="gi">+            self._add_legend(</span>
<span class="gi">+                ax_obj, artist, True, False, &quot;layer&quot;, 1, artist_kws, {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def plot_univariate_density(</span>
<span class="gi">+        self,</span>
<span class="gi">+        multiple,</span>
<span class="gi">+        common_norm,</span>
<span class="gi">+        common_grid,</span>
<span class="gi">+        warn_singular,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        color,</span>
<span class="gi">+        legend,</span>
<span class="gi">+        estimate_kws,</span>
<span class="gi">+        **plot_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # Handle conditional defaults</span>
<span class="gi">+        if fill is None:</span>
<span class="gi">+            fill = multiple in (&quot;stack&quot;, &quot;fill&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Preprocess the matplotlib keyword dictionaries</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            artist = mpl.collections.PolyCollection</span>
<span class="gi">+        else:</span>
<span class="gi">+            artist = mpl.lines.Line2D</span>
<span class="gi">+        plot_kws = normalize_kwargs(plot_kws, artist)</span>
<span class="gi">+</span>
<span class="gi">+        # Input checking</span>
<span class="gi">+        _check_argument(&quot;multiple&quot;, [&quot;layer&quot;, &quot;stack&quot;, &quot;fill&quot;], multiple)</span>
<span class="gi">+</span>
<span class="gi">+        # Always share the evaluation grid when stacking</span>
<span class="gi">+        subsets = bool(set(self.variables) - {&quot;x&quot;, &quot;y&quot;})</span>
<span class="gi">+        if subsets and multiple in (&quot;stack&quot;, &quot;fill&quot;):</span>
<span class="gi">+            common_grid = True</span>
<span class="gi">+</span>
<span class="gi">+        # Do the computation</span>
<span class="gi">+        densities = self._compute_univariate_density(</span>
<span class="gi">+            self.data_variable,</span>
<span class="gi">+            common_norm,</span>
<span class="gi">+            common_grid,</span>
<span class="gi">+            estimate_kws,</span>
<span class="gi">+            warn_singular,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust densities based on the `multiple` rule</span>
<span class="gi">+        densities, baselines = self._resolve_multiple(densities, multiple)</span>
<span class="gi">+</span>
<span class="gi">+        # Control the interaction with autoscaling by defining sticky_edges</span>
<span class="gi">+        # i.e. we don&#39;t want autoscale margins below the density curve</span>
<span class="gi">+        sticky_density = (0, 1) if multiple == &quot;fill&quot; else (0, np.inf)</span>
<span class="gi">+</span>
<span class="gi">+        if multiple == &quot;fill&quot;:</span>
<span class="gi">+            # Filled plots should not have any margins</span>
<span class="gi">+            sticky_support = densities.index.min(), densities.index.max()</span>
<span class="gi">+        else:</span>
<span class="gi">+            sticky_support = []</span>
<span class="gi">+</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            if multiple == &quot;layer&quot;:</span>
<span class="gi">+                default_alpha = .25</span>
<span class="gi">+            else:</span>
<span class="gi">+                default_alpha = .75</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_alpha = 1</span>
<span class="gi">+        alpha = plot_kws.pop(&quot;alpha&quot;, default_alpha)  # TODO make parameter?</span>
<span class="gi">+</span>
<span class="gi">+        # Now iterate through the subsets and draw the densities</span>
<span class="gi">+        # We go backwards so stacked densities read from top-to-bottom</span>
<span class="gi">+        for sub_vars, _ in self.iter_data(&quot;hue&quot;, reverse=True):</span>
<span class="gi">+</span>
<span class="gi">+            # Extract the support grid and density curve for this level</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            try:</span>
<span class="gi">+                density = densities[key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            support = density.index</span>
<span class="gi">+            fill_from = baselines[key]</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                sub_color = self._hue_map(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                sub_color = color</span>
<span class="gi">+</span>
<span class="gi">+            artist_kws = self._artist_kws(</span>
<span class="gi">+                plot_kws, fill, False, multiple, sub_color, alpha</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Either plot a curve with observation values on the x axis</span>
<span class="gi">+            if &quot;x&quot; in self.variables:</span>
<span class="gi">+</span>
<span class="gi">+                if fill:</span>
<span class="gi">+                    artist = ax.fill_between(support, fill_from, density, **artist_kws)</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    artist, = ax.plot(support, density, **artist_kws)</span>
<span class="gi">+</span>
<span class="gi">+                artist.sticky_edges.x[:] = sticky_support</span>
<span class="gi">+                artist.sticky_edges.y[:] = sticky_density</span>
<span class="gi">+</span>
<span class="gi">+            # Or plot a curve with observation values on the y axis</span>
<span class="gi">+            else:</span>
<span class="gi">+                if fill:</span>
<span class="gi">+                    artist = ax.fill_betweenx(support, fill_from, density, **artist_kws)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    artist, = ax.plot(density, support, **artist_kws)</span>
<span class="gi">+</span>
<span class="gi">+                artist.sticky_edges.x[:] = sticky_density</span>
<span class="gi">+                artist.sticky_edges.y[:] = sticky_support</span>
<span class="gi">+</span>
<span class="gi">+        # --- Finalize the plot ----</span>
<span class="gi">+</span>
<span class="gi">+        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]</span>
<span class="gi">+        default_x = default_y = &quot;&quot;</span>
<span class="gi">+        if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+            default_y = &quot;Density&quot;</span>
<span class="gi">+        if self.data_variable == &quot;y&quot;:</span>
<span class="gi">+            default_x = &quot;Density&quot;</span>
<span class="gi">+        self._add_axis_labels(ax, default_x, default_y)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                artist = partial(mpl.patches.Patch)</span>
<span class="gi">+            else:</span>
<span class="gi">+                artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+</span>
<span class="gi">+            ax_obj = self.ax if self.ax is not None else self.facets</span>
<span class="gi">+            self._add_legend(</span>
<span class="gi">+                ax_obj, artist, fill, False, multiple, alpha, plot_kws, {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def plot_bivariate_density(</span>
<span class="gi">+        self,</span>
<span class="gi">+        common_norm,</span>
<span class="gi">+        fill,</span>
<span class="gi">+        levels,</span>
<span class="gi">+        thresh,</span>
<span class="gi">+        color,</span>
<span class="gi">+        legend,</span>
<span class="gi">+        cbar,</span>
<span class="gi">+        warn_singular,</span>
<span class="gi">+        cbar_ax,</span>
<span class="gi">+        cbar_kws,</span>
<span class="gi">+        estimate_kws,</span>
<span class="gi">+        **contour_kws,</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        contour_kws = contour_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+        estimator = KDE(**estimate_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if not set(self.variables) - {&quot;x&quot;, &quot;y&quot;}:</span>
<span class="gi">+            common_norm = False</span>
<span class="gi">+</span>
<span class="gi">+        all_data = self.plot_data.dropna()</span>
<span class="gi">+</span>
<span class="gi">+        # Loop through the subsets and estimate the KDEs</span>
<span class="gi">+        densities, supports = {}, {}</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(&quot;hue&quot;, from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            # Extract the data points from this sub set</span>
<span class="gi">+            observations = sub_data[[&quot;x&quot;, &quot;y&quot;]]</span>
<span class="gi">+            min_variance = observations.var().fillna(0).min()</span>
<span class="gi">+            observations = observations[&quot;x&quot;], observations[&quot;y&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            # Extract the weights for this subset of observations</span>
<span class="gi">+            if &quot;weights&quot; in self.variables:</span>
<span class="gi">+                weights = sub_data[&quot;weights&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                weights = None</span>
<span class="gi">+</span>
<span class="gi">+            # Estimate the density of observations at this level</span>
<span class="gi">+            singular = math.isclose(min_variance, 0)</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not singular:</span>
<span class="gi">+                    density, support = estimator(*observations, weights=weights)</span>
<span class="gi">+            except np.linalg.LinAlgError:</span>
<span class="gi">+                # Testing for 0 variance doesn&#39;t catch all cases where scipy raises,</span>
<span class="gi">+                # but we can also get a ValueError, so we need this convoluted approach</span>
<span class="gi">+                singular = True</span>
<span class="gi">+</span>
<span class="gi">+            if singular:</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    &quot;KDE cannot be estimated (0 variance or perfect covariance). &quot;</span>
<span class="gi">+                    &quot;Pass `warn_singular=False` to disable this warning.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                if warn_singular:</span>
<span class="gi">+                    warnings.warn(msg, UserWarning, stacklevel=3)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Transform the support grid back to the original scale</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+            _, inv_x = _get_transform_functions(ax, &quot;x&quot;)</span>
<span class="gi">+            _, inv_y = _get_transform_functions(ax, &quot;y&quot;)</span>
<span class="gi">+            support = inv_x(support[0]), inv_y(support[1])</span>
<span class="gi">+</span>
<span class="gi">+            # Apply a scaling factor so that the integral over all subsets is 1</span>
<span class="gi">+            if common_norm:</span>
<span class="gi">+                density *= len(sub_data) / len(all_data)</span>
<span class="gi">+</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            densities[key] = density</span>
<span class="gi">+            supports[key] = support</span>
<span class="gi">+</span>
<span class="gi">+        # Define a grid of iso-proportion levels</span>
<span class="gi">+        if thresh is None:</span>
<span class="gi">+            thresh = 0</span>
<span class="gi">+        if isinstance(levels, Number):</span>
<span class="gi">+            levels = np.linspace(thresh, 1, levels)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if min(levels) &lt; 0 or max(levels) &gt; 1:</span>
<span class="gi">+                raise ValueError(&quot;levels must be in [0, 1]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Transform from iso-proportions to iso-densities</span>
<span class="gi">+        if common_norm:</span>
<span class="gi">+            common_levels = self._quantile_to_level(</span>
<span class="gi">+                list(densities.values()), levels,</span>
<span class="gi">+            )</span>
<span class="gi">+            draw_levels = {k: common_levels for k in densities}</span>
<span class="gi">+        else:</span>
<span class="gi">+            draw_levels = {</span>
<span class="gi">+                k: self._quantile_to_level(d, levels)</span>
<span class="gi">+                for k, d in densities.items()</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        # Define the coloring of the contours</span>
<span class="gi">+        if &quot;hue&quot; in self.variables:</span>
<span class="gi">+            for param in [&quot;cmap&quot;, &quot;colors&quot;]:</span>
<span class="gi">+                if param in contour_kws:</span>
<span class="gi">+                    msg = f&quot;{param} parameter ignored when using hue mapping.&quot;</span>
<span class="gi">+                    warnings.warn(msg, UserWarning)</span>
<span class="gi">+                    contour_kws.pop(param)</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            # Work out a default coloring of the contours</span>
<span class="gi">+            coloring_given = set(contour_kws) &amp; {&quot;cmap&quot;, &quot;colors&quot;}</span>
<span class="gi">+            if fill and not coloring_given:</span>
<span class="gi">+                cmap = self._cmap_from_color(color)</span>
<span class="gi">+                contour_kws[&quot;cmap&quot;] = cmap</span>
<span class="gi">+            if not fill and not coloring_given:</span>
<span class="gi">+                contour_kws[&quot;colors&quot;] = [color]</span>
<span class="gi">+</span>
<span class="gi">+            # Use our internal colormap lookup</span>
<span class="gi">+            cmap = contour_kws.pop(&quot;cmap&quot;, None)</span>
<span class="gi">+            if isinstance(cmap, str):</span>
<span class="gi">+                cmap = color_palette(cmap, as_cmap=True)</span>
<span class="gi">+            if cmap is not None:</span>
<span class="gi">+                contour_kws[&quot;cmap&quot;] = cmap</span>
<span class="gi">+</span>
<span class="gi">+        # Loop through the subsets again and plot the data</span>
<span class="gi">+        for sub_vars, _ in self.iter_data(&quot;hue&quot;):</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;hue&quot; in sub_vars:</span>
<span class="gi">+                color = self._hue_map(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+                if fill:</span>
<span class="gi">+                    contour_kws[&quot;cmap&quot;] = self._cmap_from_color(color)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    contour_kws[&quot;colors&quot;] = [color]</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            # Choose the function to plot with</span>
<span class="gi">+            # TODO could add a pcolormesh based option as well</span>
<span class="gi">+            # Which would look something like element=&quot;raster&quot;</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                contour_func = ax.contourf</span>
<span class="gi">+            else:</span>
<span class="gi">+                contour_func = ax.contour</span>
<span class="gi">+</span>
<span class="gi">+            key = tuple(sub_vars.items())</span>
<span class="gi">+            if key not in densities:</span>
<span class="gi">+                continue</span>
<span class="gi">+            density = densities[key]</span>
<span class="gi">+            xx, yy = supports[key]</span>
<span class="gi">+</span>
<span class="gi">+            # Pop the label kwarg which is unused by contour_func (but warns)</span>
<span class="gi">+            contour_kws.pop(&quot;label&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            cset = contour_func(</span>
<span class="gi">+                xx, yy, density,</span>
<span class="gi">+                levels=draw_levels[key],</span>
<span class="gi">+                **contour_kws,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Add a color bar representing the contour heights</span>
<span class="gi">+            # Note: this shows iso densities, not iso proportions</span>
<span class="gi">+            # See more notes in histplot about how this could be improved</span>
<span class="gi">+            if cbar:</span>
<span class="gi">+                cbar_kws = {} if cbar_kws is None else cbar_kws</span>
<span class="gi">+                ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # --- Finalize the plot</span>
<span class="gi">+        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]</span>
<span class="gi">+        self._add_axis_labels(ax)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+</span>
<span class="gi">+            # TODO if possible, I would like to move the contour</span>
<span class="gi">+            # intensity information into the legend too and label the</span>
<span class="gi">+            # iso proportions rather than the raw density values</span>
<span class="gi">+</span>
<span class="gi">+            artist_kws = {}</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                artist = partial(mpl.patches.Patch)</span>
<span class="gi">+            else:</span>
<span class="gi">+                artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+</span>
<span class="gi">+            ax_obj = self.ax if self.ax is not None else self.facets</span>
<span class="gi">+            self._add_legend(</span>
<span class="gi">+                ax_obj, artist, fill, False, &quot;layer&quot;, 1, artist_kws, {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):</span>
<span class="gi">+</span>
<span class="gi">+        estimator = ECDF(**estimate_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the draw style to step the right way for the data variable</span>
<span class="gi">+        drawstyles = dict(x=&quot;steps-post&quot;, y=&quot;steps-pre&quot;)</span>
<span class="gi">+        plot_kws[&quot;drawstyle&quot;] = drawstyles[self.data_variable]</span>
<span class="gi">+</span>
<span class="gi">+        # Loop through the subsets, transform and plot the data</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(</span>
<span class="gi">+            &quot;hue&quot;, reverse=True, from_comp_data=True,</span>
<span class="gi">+        ):</span>
<span class="gi">+</span>
<span class="gi">+            # Compute the ECDF</span>
<span class="gi">+            if sub_data.empty:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            observations = sub_data[self.data_variable]</span>
<span class="gi">+            weights = sub_data.get(&quot;weights&quot;, None)</span>
<span class="gi">+            stat, vals = estimator(observations, weights=weights)</span>
<span class="gi">+</span>
<span class="gi">+            # Assign attributes based on semantic mapping</span>
<span class="gi">+            artist_kws = plot_kws.copy()</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                artist_kws[&quot;color&quot;] = self._hue_map(sub_vars[&quot;hue&quot;])</span>
<span class="gi">+</span>
<span class="gi">+            # Return the data variable to the linear domain</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+            _, inv = _get_transform_functions(ax, self.data_variable)</span>
<span class="gi">+            vals = inv(vals)</span>
<span class="gi">+</span>
<span class="gi">+            # Manually set the minimum value on a &quot;log&quot; scale</span>
<span class="gi">+            if isinstance(inv.__self__, mpl.scale.LogTransform):</span>
<span class="gi">+                vals[0] = -np.inf</span>
<span class="gi">+</span>
<span class="gi">+            # Work out the orientation of the plot</span>
<span class="gi">+            if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+                plot_args = vals, stat</span>
<span class="gi">+                stat_variable = &quot;y&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                plot_args = stat, vals</span>
<span class="gi">+                stat_variable = &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if estimator.stat == &quot;count&quot;:</span>
<span class="gi">+                top_edge = len(observations)</span>
<span class="gi">+            else:</span>
<span class="gi">+                top_edge = 1</span>
<span class="gi">+</span>
<span class="gi">+            # Draw the line for this subset</span>
<span class="gi">+            artist, = ax.plot(*plot_args, **artist_kws)</span>
<span class="gi">+            sticky_edges = getattr(artist.sticky_edges, stat_variable)</span>
<span class="gi">+            sticky_edges[:] = 0, top_edge</span>
<span class="gi">+</span>
<span class="gi">+        # --- Finalize the plot ----</span>
<span class="gi">+        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]</span>
<span class="gi">+        stat = estimator.stat.capitalize()</span>
<span class="gi">+        default_x = default_y = &quot;&quot;</span>
<span class="gi">+        if self.data_variable == &quot;x&quot;:</span>
<span class="gi">+            default_y = stat</span>
<span class="gi">+        if self.data_variable == &quot;y&quot;:</span>
<span class="gi">+            default_x = stat</span>
<span class="gi">+        self._add_axis_labels(ax, default_x, default_y)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+            artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+            alpha = plot_kws.get(&quot;alpha&quot;, 1)</span>
<span class="gi">+            ax_obj = self.ax if self.ax is not None else self.facets</span>
<span class="gi">+            self._add_legend(</span>
<span class="gi">+                ax_obj, artist, False, False, None, alpha, plot_kws, {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def plot_rug(self, height, expand_margins, legend, **kws):</span>
<span class="gi">+</span>
<span class="gi">+        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            ax = self._get_axes(sub_vars)</span>
<span class="gi">+</span>
<span class="gi">+            kws.setdefault(&quot;linewidth&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+            if expand_margins:</span>
<span class="gi">+                xmarg, ymarg = ax.margins()</span>
<span class="gi">+                if &quot;x&quot; in self.variables:</span>
<span class="gi">+                    ymarg += height * 2</span>
<span class="gi">+                if &quot;y&quot; in self.variables:</span>
<span class="gi">+                    xmarg += height * 2</span>
<span class="gi">+                ax.margins(x=xmarg, y=ymarg)</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;hue&quot; in self.variables:</span>
<span class="gi">+                kws.pop(&quot;c&quot;, None)</span>
<span class="gi">+                kws.pop(&quot;color&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;x&quot; in self.variables:</span>
<span class="gi">+                self._plot_single_rug(sub_data, &quot;x&quot;, height, ax, kws)</span>
<span class="gi">+            if &quot;y&quot; in self.variables:</span>
<span class="gi">+                self._plot_single_rug(sub_data, &quot;y&quot;, height, ax, kws)</span>
<span class="gi">+</span>
<span class="gi">+            # --- Finalize the plot</span>
<span class="gi">+            self._add_axis_labels(ax)</span>
<span class="gi">+            if &quot;hue&quot; in self.variables and legend:</span>
<span class="gi">+                # TODO ideally i&#39;d like the legend artist to look like a rug</span>
<span class="gi">+                legend_artist = partial(mpl.lines.Line2D, [], [])</span>
<span class="gi">+                self._add_legend(</span>
<span class="gi">+                    ax, legend_artist, False, False, None, 1, {}, {},</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def _plot_single_rug(self, sub_data, var, height, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw a rugplot along one axis of the plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vector = sub_data[var]</span>
<span class="gi">+        n = len(vector)</span>
<span class="gi">+</span>
<span class="gi">+        # Return data to linear domain</span>
<span class="gi">+        _, inv = _get_transform_functions(ax, var)</span>
<span class="gi">+        vector = inv(vector)</span>
<span class="gi">+</span>
<span class="gi">+        # We&#39;ll always add a single collection with varying colors</span>
<span class="gi">+        if &quot;hue&quot; in self.variables:</span>
<span class="gi">+            colors = self._hue_map(sub_data[&quot;hue&quot;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            colors = None</span>
<span class="gi">+</span>
<span class="gi">+        # Build the array of values for the LineCollection</span>
<span class="gi">+        if var == &quot;x&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)</span>
<span class="gi">+            xy_pairs = np.column_stack([</span>
<span class="gi">+                np.repeat(vector, 2), np.tile([0, height], n)</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="gi">+        if var == &quot;y&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)</span>
<span class="gi">+            xy_pairs = np.column_stack([</span>
<span class="gi">+                np.tile([0, height], n), np.repeat(vector, 2)</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the lines on the plot</span>
<span class="gi">+        line_segs = xy_pairs.reshape([n, 2, 2])</span>
<span class="gi">+        ax.add_collection(LineCollection(</span>
<span class="gi">+            line_segs, transform=trans, colors=colors, **kws</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+        ax.autoscale_view(scalex=var == &quot;x&quot;, scaley=var == &quot;y&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ==================================================================================== #</span>
<span class="gi">+# External API</span>
<span class="gi">+# ==================================================================================== #</span>
<span class="gi">+</span>
<span class="gi">+def histplot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    # Vector variables</span>
<span class="gi">+    x=None, y=None, hue=None, weights=None,</span>
<span class="gi">+    # Histogram computation parameters</span>
<span class="gi">+    stat=&quot;count&quot;, bins=&quot;auto&quot;, binwidth=None, binrange=None,</span>
<span class="gi">+    discrete=None, cumulative=False, common_bins=True, common_norm=True,</span>
<span class="gi">+    # Histogram appearance parameters</span>
<span class="gi">+    multiple=&quot;layer&quot;, element=&quot;bars&quot;, fill=True, shrink=1,</span>
<span class="gi">+    # Histogram smoothing with a kernel density estimate</span>
<span class="gi">+    kde=False, kde_kws=None, line_kws=None,</span>
<span class="gi">+    # Bivariate histogram parameters</span>
<span class="gi">+    thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None, cbar_kws=None,</span>
<span class="gi">+    # Hue mapping parameters</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None, color=None,</span>
<span class="gi">+    # Axes information</span>
<span class="gi">+    log_scale=None, legend=True, ax=None,</span>
<span class="gi">+    # Other appearance keywords</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _DistributionPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, weights=weights),</span>
<span class="gi">+    )</span>

<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>

<span class="gd">-histplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Plot univariate or bivariate histograms to show distributions of datasets.</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    if p.univariate:  # Note, bivariate plots won&#39;t cycle</span>
<span class="gi">+        if fill:</span>
<span class="gi">+            method = ax.bar if element == &quot;bars&quot; else ax.fill_between</span>
<span class="gi">+        else:</span>
<span class="gi">+            method = ax.plot</span>
<span class="gi">+        color = _default_color(method, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    # Default to discrete bins for categorical variables</span>
<span class="gi">+    if discrete is None:</span>
<span class="gi">+        discrete = p._default_discrete()</span>
<span class="gi">+</span>
<span class="gi">+    estimate_kws = dict(</span>
<span class="gi">+        stat=stat,</span>
<span class="gi">+        bins=bins,</span>
<span class="gi">+        binwidth=binwidth,</span>
<span class="gi">+        binrange=binrange,</span>
<span class="gi">+        discrete=discrete,</span>
<span class="gi">+        cumulative=cumulative,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if p.univariate:</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_univariate_histogram(</span>
<span class="gi">+            multiple=multiple,</span>
<span class="gi">+            element=element,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            shrink=shrink,</span>
<span class="gi">+            common_norm=common_norm,</span>
<span class="gi">+            common_bins=common_bins,</span>
<span class="gi">+            kde=kde,</span>
<span class="gi">+            kde_kws=kde_kws,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            legend=legend,</span>
<span class="gi">+            estimate_kws=estimate_kws,</span>
<span class="gi">+            line_kws=line_kws,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_bivariate_histogram(</span>
<span class="gi">+            common_bins=common_bins,</span>
<span class="gi">+            common_norm=common_norm,</span>
<span class="gi">+            thresh=thresh,</span>
<span class="gi">+            pthresh=pthresh,</span>
<span class="gi">+            pmax=pmax,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            legend=legend,</span>
<span class="gi">+            cbar=cbar,</span>
<span class="gi">+            cbar_ax=cbar_ax,</span>
<span class="gi">+            cbar_kws=cbar_kws,</span>
<span class="gi">+            estimate_kws=estimate_kws,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+histplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Plot univariate or bivariate histograms to show distributions of datasets.</span>

<span class="w"> </span>A histogram is a classic visualization tool that represents the distribution
<span class="w"> </span>of one or more variables by counting the number of observations that fall within
<span class="gu">@@ -237,11 +1571,167 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/histplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;], seealso=</span>
<span class="gd">-    _core_docs[&#39;seealso&#39;]))</span>
<span class="gd">-kdeplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Plot univariate or bivariate distributions using kernel density estimation.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def kdeplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, weights=None,</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None, color=None, fill=None,</span>
<span class="gi">+    multiple=&quot;layer&quot;, common_norm=True, common_grid=False, cumulative=False,</span>
<span class="gi">+    bw_method=&quot;scott&quot;, bw_adjust=1, warn_singular=True, log_scale=None,</span>
<span class="gi">+    levels=10, thresh=.05, gridsize=200, cut=3, clip=None,</span>
<span class="gi">+    legend=True, cbar=False, cbar_ax=None, cbar_kws=None, ax=None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    # --- Start with backwards compatability for versions &lt; 0.11.0 ----------------</span>
<span class="gi">+</span>
<span class="gi">+    # Handle (past) deprecation of `data2`</span>
<span class="gi">+    if &quot;data2&quot; in kwargs:</span>
<span class="gi">+        msg = &quot;`data2` has been removed (replaced by `y`); please update your code.&quot;</span>
<span class="gi">+        raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecation of `vertical`</span>
<span class="gi">+    vertical = kwargs.pop(&quot;vertical&quot;, None)</span>
<span class="gi">+    if vertical is not None:</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            action_taken = &quot;assigning data to `y`.&quot;</span>
<span class="gi">+            if x is None:</span>
<span class="gi">+                data, y = y, data</span>
<span class="gi">+            else:</span>
<span class="gi">+                x, y = y, x</span>
<span class="gi">+        else:</span>
<span class="gi">+            action_taken = &quot;assigning data to `x`.&quot;</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        The `vertical` parameter is deprecated; {action_taken}</span>
<span class="gi">+        This will become an error in seaborn v0.14.0; please update your code.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecation of `bw`</span>
<span class="gi">+    bw = kwargs.pop(&quot;bw&quot;, None)</span>
<span class="gi">+    if bw is not None:</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.</span>
<span class="gi">+        Setting `bw_method={bw}`, but please see the docs for the new parameters</span>
<span class="gi">+        and update your code. This will become an error in seaborn v0.14.0.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+        bw_method = bw</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecation of `kernel`</span>
<span class="gi">+    if kwargs.pop(&quot;kernel&quot;, None) is not None:</span>
<span class="gi">+        msg = textwrap.dedent(&quot;&quot;&quot;\n</span>
<span class="gi">+        Support for alternate kernels has been removed; using Gaussian kernel.</span>
<span class="gi">+        This will become an error in seaborn v0.14.0; please update your code.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecation of shade_lowest</span>
<span class="gi">+    shade_lowest = kwargs.pop(&quot;shade_lowest&quot;, None)</span>
<span class="gi">+    if shade_lowest is not None:</span>
<span class="gi">+        if shade_lowest:</span>
<span class="gi">+            thresh = 0</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.</span>
<span class="gi">+        This will become an error in seaborn v0.14.0; please update your code.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle &quot;soft&quot; deprecation of shade `shade` is not really the right</span>
<span class="gi">+    # terminology here, but unlike some of the other deprecated parameters it</span>
<span class="gi">+    # is probably very commonly used and much hard to remove. This is therefore</span>
<span class="gi">+    # going to be a longer process where, first, `fill` will be introduced and</span>
<span class="gi">+    # be used throughout the documentation. In 0.12, when kwarg-only</span>
<span class="gi">+    # enforcement hits, we can remove the shade/shade_lowest out of the</span>
<span class="gi">+    # function signature all together and pull them out of the kwargs. Then we</span>
<span class="gi">+    # can actually fire a FutureWarning, and eventually remove.</span>
<span class="gi">+    shade = kwargs.pop(&quot;shade&quot;, None)</span>
<span class="gi">+    if shade is not None:</span>
<span class="gi">+        fill = shade</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.</span>
<span class="gi">+        This will become an error in seaborn v0.14.0; please update your code.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, FutureWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle `n_levels`</span>
<span class="gi">+    # This was never in the formal API but it was processed, and appeared in an</span>
<span class="gi">+    # example. We can treat as an alias for `levels` now and deprecate later.</span>
<span class="gi">+    levels = kwargs.pop(&quot;n_levels&quot;, levels)</span>
<span class="gi">+</span>
<span class="gi">+    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #</span>
<span class="gi">+</span>
<span class="gi">+    p = _DistributionPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, weights=weights),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, allowed_types=[&quot;numeric&quot;, &quot;datetime&quot;], log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    method = ax.fill_between if fill else ax.plot</span>
<span class="gi">+    color = _default_color(method, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    # Pack the kwargs for statistics.KDE</span>
<span class="gi">+    estimate_kws = dict(</span>
<span class="gi">+        bw_method=bw_method,</span>
<span class="gi">+        bw_adjust=bw_adjust,</span>
<span class="gi">+        gridsize=gridsize,</span>
<span class="gi">+        cut=cut,</span>
<span class="gi">+        clip=clip,</span>
<span class="gi">+        cumulative=cumulative,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if p.univariate:</span>
<span class="gi">+</span>
<span class="gi">+        plot_kws = kwargs.copy()</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_univariate_density(</span>
<span class="gi">+            multiple=multiple,</span>
<span class="gi">+            common_norm=common_norm,</span>
<span class="gi">+            common_grid=common_grid,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            legend=legend,</span>
<span class="gi">+            warn_singular=warn_singular,</span>
<span class="gi">+            estimate_kws=estimate_kws,</span>
<span class="gi">+            **plot_kws,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        p.plot_bivariate_density(</span>
<span class="gi">+            common_norm=common_norm,</span>
<span class="gi">+            fill=fill,</span>
<span class="gi">+            levels=levels,</span>
<span class="gi">+            thresh=thresh,</span>
<span class="gi">+            legend=legend,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            warn_singular=warn_singular,</span>
<span class="gi">+            cbar=cbar,</span>
<span class="gi">+            cbar_ax=cbar_ax,</span>
<span class="gi">+            cbar_kws=cbar_kws,</span>
<span class="gi">+            estimate_kws=estimate_kws,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+kdeplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Plot univariate or bivariate distributions using kernel density estimation.</span>

<span class="w"> </span>A kernel density estimate (KDE) plot is a method for visualizing the
<span class="w"> </span>distribution of observations in a dataset, analogous to a histogram. KDE
<span class="gu">@@ -361,11 +1851,71 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/kdeplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;], seealso=</span>
<span class="gd">-    _core_docs[&#39;seealso&#39;]))</span>
<span class="gd">-ecdfplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Plot empirical cumulative distribution functions.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ecdfplot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    # Vector variables</span>
<span class="gi">+    x=None, y=None, hue=None, weights=None,</span>
<span class="gi">+    # Computation parameters</span>
<span class="gi">+    stat=&quot;proportion&quot;, complementary=False,</span>
<span class="gi">+    # Hue mapping parameters</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None,</span>
<span class="gi">+    # Axes information</span>
<span class="gi">+    log_scale=None, legend=True, ax=None,</span>
<span class="gi">+    # Other appearance keywords</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _DistributionPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, weights=weights),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+    # We could support other semantics (size, style) here fairly easily</span>
<span class="gi">+    # But it would make distplot a bit more complicated.</span>
<span class="gi">+    # It&#39;s always possible to add features like that later, so I am going to defer.</span>
<span class="gi">+    # It will be even easier to wait until after there is a more general/abstract</span>
<span class="gi">+    # way to go from semantic specs to artist attributes.</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    color = kwargs.pop(&quot;color&quot;, kwargs.pop(&quot;c&quot;, None))</span>
<span class="gi">+    kwargs[&quot;color&quot;] = _default_color(ax.plot, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    # We could add this one day, but it&#39;s of dubious value</span>
<span class="gi">+    if not p.univariate:</span>
<span class="gi">+        raise NotImplementedError(&quot;Bivariate ECDF plots are not implemented&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    estimate_kws = dict(</span>
<span class="gi">+        stat=stat,</span>
<span class="gi">+        complementary=complementary,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_univariate_ecdf(</span>
<span class="gi">+        estimate_kws=estimate_kws,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+        **kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ecdfplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Plot empirical cumulative distribution functions.</span>

<span class="w"> </span>An ECDF represents the proportion or count of observations falling below each
<span class="w"> </span>unique value in a dataset. Compared to a histogram or density plot, it has the
<span class="gu">@@ -413,11 +1963,95 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/ecdfplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;], seealso=</span>
<span class="gd">-    _core_docs[&#39;seealso&#39;]))</span>
<span class="gd">-rugplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Plot marginal distributions by drawing ticks along the x and y axes.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rugplot(</span>
<span class="gi">+    data=None, *, x=None, y=None, hue=None, height=.025, expand_margins=True,</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None, legend=True, ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    # A note: I think it would make sense to add multiple= to rugplot and allow</span>
<span class="gi">+    # rugs for different hue variables to be shifted orthogonal to the data axis</span>
<span class="gi">+    # But is this stacking, or dodging?</span>
<span class="gi">+</span>
<span class="gi">+    # A note: if we want to add a style semantic to rugplot,</span>
<span class="gi">+    # we could make an option that draws the rug using scatterplot</span>
<span class="gi">+</span>
<span class="gi">+    # A note, it would also be nice to offer some kind of histogram/density</span>
<span class="gi">+    # rugplot, since alpha blending doesn&#39;t work great in the large n regime</span>
<span class="gi">+</span>
<span class="gi">+    # --- Start with backwards compatability for versions &lt; 0.11.0 ----------------</span>
<span class="gi">+</span>
<span class="gi">+    a = kwargs.pop(&quot;a&quot;, None)</span>
<span class="gi">+    axis = kwargs.pop(&quot;axis&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if a is not None:</span>
<span class="gi">+        data = a</span>
<span class="gi">+        msg = textwrap.dedent(&quot;&quot;&quot;\n</span>
<span class="gi">+        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.</span>
<span class="gi">+        Please update your code; This will become an error in seaborn v0.14.0.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    if axis is not None:</span>
<span class="gi">+        if axis == &quot;x&quot;:</span>
<span class="gi">+            x = data</span>
<span class="gi">+        elif axis == &quot;y&quot;:</span>
<span class="gi">+            y = data</span>
<span class="gi">+        data = None</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.</span>
<span class="gi">+        Please update your code; this will become an error in seaborn v0.14.0.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    vertical = kwargs.pop(&quot;vertical&quot;, None)</span>
<span class="gi">+    if vertical is not None:</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            action_taken = &quot;assigning data to `y`.&quot;</span>
<span class="gi">+            if x is None:</span>
<span class="gi">+                data, y = y, data</span>
<span class="gi">+            else:</span>
<span class="gi">+                x, y = y, x</span>
<span class="gi">+        else:</span>
<span class="gi">+            action_taken = &quot;assigning data to `x`.&quot;</span>
<span class="gi">+        msg = textwrap.dedent(f&quot;&quot;&quot;\n</span>
<span class="gi">+        The `vertical` parameter is deprecated; {action_taken}</span>
<span class="gi">+        This will become an error in seaborn v0.14.0; please update your code.</span>
<span class="gi">+        &quot;&quot;&quot;)</span>
<span class="gi">+        warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #</span>
<span class="gi">+</span>
<span class="gi">+    p = _DistributionPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue),</span>
<span class="gi">+    )</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax)</span>
<span class="gi">+</span>
<span class="gi">+    color = kwargs.pop(&quot;color&quot;, kwargs.pop(&quot;c&quot;, None))</span>
<span class="gi">+    kwargs[&quot;color&quot;] = _default_color(ax.plot, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    p.plot_rug(height, expand_margins, legend, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+rugplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Plot marginal distributions by drawing ticks along the x and y axes.</span>

<span class="w"> </span>This function is intended to complement other plots by showing the location
<span class="w"> </span>of individual observations in an unobtrusive way.
<span class="gu">@@ -451,10 +2085,206 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/rugplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;]))</span>
<span class="gd">-displot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Figure-level interface for drawing distribution plots onto a FacetGrid.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def displot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    # Vector variables</span>
<span class="gi">+    x=None, y=None, hue=None, row=None, col=None, weights=None,</span>
<span class="gi">+    # Other plot parameters</span>
<span class="gi">+    kind=&quot;hist&quot;, rug=False, rug_kws=None, log_scale=None, legend=True,</span>
<span class="gi">+    # Hue-mapping parameters</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None, color=None,</span>
<span class="gi">+    # Faceting parameters</span>
<span class="gi">+    col_wrap=None, row_order=None, col_order=None,</span>
<span class="gi">+    height=5, aspect=1, facet_kws=None,</span>
<span class="gi">+    **kwargs,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _DistributionPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, weights=weights, row=row, col=col),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+</span>
<span class="gi">+    _check_argument(&quot;kind&quot;, [&quot;hist&quot;, &quot;kde&quot;, &quot;ecdf&quot;], kind)</span>
<span class="gi">+</span>
<span class="gi">+    # --- Initialize the FacetGrid object</span>
<span class="gi">+</span>
<span class="gi">+    # Check for attempt to plot onto specific axes and warn</span>
<span class="gi">+    if &quot;ax&quot; in kwargs:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;`displot` is a figure-level function and does not accept &quot;</span>
<span class="gi">+            &quot;the ax= parameter. You may wish to try {}plot.&quot;.format(kind)</span>
<span class="gi">+        )</span>
<span class="gi">+        warnings.warn(msg, UserWarning)</span>
<span class="gi">+        kwargs.pop(&quot;ax&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for var in [&quot;row&quot;, &quot;col&quot;]:</span>
<span class="gi">+        # Handle faceting variables that lack name information</span>
<span class="gi">+        if var in p.variables and p.variables[var] is None:</span>
<span class="gi">+            p.variables[var] = f&quot;_{var}_&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Adapt the plot_data dataframe for use with FacetGrid</span>
<span class="gi">+    grid_data = p.plot_data.rename(columns=p.variables)</span>
<span class="gi">+    grid_data = grid_data.loc[:, ~grid_data.columns.duplicated()]</span>
<span class="gi">+</span>
<span class="gi">+    col_name = p.variables.get(&quot;col&quot;)</span>
<span class="gi">+    row_name = p.variables.get(&quot;row&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if facet_kws is None:</span>
<span class="gi">+        facet_kws = {}</span>
<span class="gi">+</span>
<span class="gi">+    g = FacetGrid(</span>
<span class="gi">+        data=grid_data, row=row_name, col=col_name,</span>
<span class="gi">+        col_wrap=col_wrap, row_order=row_order,</span>
<span class="gi">+        col_order=col_order, height=height,</span>
<span class="gi">+        aspect=aspect,</span>
<span class="gi">+        **facet_kws,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Now attach the axes object to the plotter object</span>
<span class="gi">+    if kind == &quot;kde&quot;:</span>
<span class="gi">+        allowed_types = [&quot;numeric&quot;, &quot;datetime&quot;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        allowed_types = None</span>
<span class="gi">+    p._attach(g, allowed_types=allowed_types, log_scale=log_scale)</span>
<span class="gi">+</span>
<span class="gi">+    # Check for a specification that lacks x/y data and return early</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return g</span>
<span class="gi">+</span>
<span class="gi">+    if color is None and hue is None:</span>
<span class="gi">+        color = &quot;C0&quot;</span>
<span class="gi">+    # XXX else warn if hue is not None?</span>
<span class="gi">+</span>
<span class="gi">+    kwargs[&quot;legend&quot;] = legend</span>
<span class="gi">+</span>
<span class="gi">+    # --- Draw the plots</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;hist&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        hist_kws = kwargs.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # Extract the parameters that will go directly to Histogram</span>
<span class="gi">+        estimate_defaults = {}</span>
<span class="gi">+        _assign_default_kwargs(estimate_defaults, Histogram.__init__, histplot)</span>
<span class="gi">+</span>
<span class="gi">+        estimate_kws = {}</span>
<span class="gi">+        for key, default_val in estimate_defaults.items():</span>
<span class="gi">+            estimate_kws[key] = hist_kws.pop(key, default_val)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle derivative defaults</span>
<span class="gi">+        if estimate_kws[&quot;discrete&quot;] is None:</span>
<span class="gi">+            estimate_kws[&quot;discrete&quot;] = p._default_discrete()</span>
<span class="gi">+</span>
<span class="gi">+        hist_kws[&quot;estimate_kws&quot;] = estimate_kws</span>
<span class="gi">+</span>
<span class="gi">+        hist_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+</span>
<span class="gi">+        if p.univariate:</span>
<span class="gi">+</span>
<span class="gi">+            _assign_default_kwargs(hist_kws, p.plot_univariate_histogram, histplot)</span>
<span class="gi">+            p.plot_univariate_histogram(**hist_kws)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            _assign_default_kwargs(hist_kws, p.plot_bivariate_histogram, histplot)</span>
<span class="gi">+            p.plot_bivariate_histogram(**hist_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;kde&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        kde_kws = kwargs.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # Extract the parameters that will go directly to KDE</span>
<span class="gi">+        estimate_defaults = {}</span>
<span class="gi">+        _assign_default_kwargs(estimate_defaults, KDE.__init__, kdeplot)</span>
<span class="gi">+</span>
<span class="gi">+        estimate_kws = {}</span>
<span class="gi">+        for key, default_val in estimate_defaults.items():</span>
<span class="gi">+            estimate_kws[key] = kde_kws.pop(key, default_val)</span>
<span class="gi">+</span>
<span class="gi">+        kde_kws[&quot;estimate_kws&quot;] = estimate_kws</span>
<span class="gi">+        kde_kws[&quot;color&quot;] = color</span>
<span class="gi">+</span>
<span class="gi">+        if p.univariate:</span>
<span class="gi">+</span>
<span class="gi">+            _assign_default_kwargs(kde_kws, p.plot_univariate_density, kdeplot)</span>
<span class="gi">+            p.plot_univariate_density(**kde_kws)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            _assign_default_kwargs(kde_kws, p.plot_bivariate_density, kdeplot)</span>
<span class="gi">+            p.plot_bivariate_density(**kde_kws)</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;ecdf&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        ecdf_kws = kwargs.copy()</span>
<span class="gi">+</span>
<span class="gi">+        # Extract the parameters that will go directly to the estimator</span>
<span class="gi">+        estimate_kws = {}</span>
<span class="gi">+        estimate_defaults = {}</span>
<span class="gi">+        _assign_default_kwargs(estimate_defaults, ECDF.__init__, ecdfplot)</span>
<span class="gi">+        for key, default_val in estimate_defaults.items():</span>
<span class="gi">+            estimate_kws[key] = ecdf_kws.pop(key, default_val)</span>
<span class="gi">+</span>
<span class="gi">+        ecdf_kws[&quot;estimate_kws&quot;] = estimate_kws</span>
<span class="gi">+        ecdf_kws[&quot;color&quot;] = color</span>
<span class="gi">+</span>
<span class="gi">+        if p.univariate:</span>
<span class="gi">+</span>
<span class="gi">+            _assign_default_kwargs(ecdf_kws, p.plot_univariate_ecdf, ecdfplot)</span>
<span class="gi">+            p.plot_univariate_ecdf(**ecdf_kws)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            raise NotImplementedError(&quot;Bivariate ECDF plots are not implemented&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # All plot kinds can include a rug</span>
<span class="gi">+    if rug:</span>
<span class="gi">+        # TODO with expand_margins=True, each facet expands margins... annoying!</span>
<span class="gi">+        if rug_kws is None:</span>
<span class="gi">+            rug_kws = {}</span>
<span class="gi">+        _assign_default_kwargs(rug_kws, p.plot_rug, rugplot)</span>
<span class="gi">+        rug_kws[&quot;legend&quot;] = False</span>
<span class="gi">+        if color is not None:</span>
<span class="gi">+            rug_kws[&quot;color&quot;] = color</span>
<span class="gi">+        p.plot_rug(**rug_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Call FacetGrid annotation methods</span>
<span class="gi">+    # Note that the legend is currently set inside the plotting method</span>
<span class="gi">+    g.set_axis_labels(</span>
<span class="gi">+        x_var=p.variables.get(&quot;x&quot;, g.axes.flat[0].get_xlabel()),</span>
<span class="gi">+        y_var=p.variables.get(&quot;y&quot;, g.axes.flat[0].get_ylabel()),</span>
<span class="gi">+    )</span>
<span class="gi">+    g.set_titles()</span>
<span class="gi">+    g.tight_layout()</span>
<span class="gi">+</span>
<span class="gi">+    if data is not None and (x is not None or y is not None):</span>
<span class="gi">+        if not isinstance(data, pd.DataFrame):</span>
<span class="gi">+            data = pd.DataFrame(data)</span>
<span class="gi">+        g.data = pd.merge(</span>
<span class="gi">+            data,</span>
<span class="gi">+            g.data[g.data.columns.difference(data.columns)],</span>
<span class="gi">+            left_index=True,</span>
<span class="gi">+            right_index=True,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        wide_cols = {</span>
<span class="gi">+            k: f&quot;_{k}_&quot; if v is None else v for k, v in p.variables.items()</span>
<span class="gi">+        }</span>
<span class="gi">+        g.data = p.plot_data.rename(columns=wide_cols)</span>
<span class="gi">+</span>
<span class="gi">+    return g</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+displot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Figure-level interface for drawing distribution plots onto a FacetGrid.</span>

<span class="w"> </span>This function provides access to several approaches for visualizing the
<span class="w"> </span>univariate or bivariate distribution of data, including subsets of data
<span class="gu">@@ -530,20 +2360,37 @@ about the breadth of options available for each plot kind.</span>

<span class="w"> </span>.. include:: ../docstrings/displot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(params=_param_docs, returns=_core_docs[&#39;returns&#39;], seealso=</span>
<span class="gd">-    _core_docs[&#39;seealso&#39;]))</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# =========================================================================== #</span>
<span class="gi">+# DEPRECATED FUNCTIONS LIVE BELOW HERE</span>
<span class="gi">+# =========================================================================== #</span>


<span class="w"> </span>def _freedman_diaconis_bins(a):
<span class="w"> </span>    &quot;&quot;&quot;Calculate number of hist bins using Freedman-Diaconis rule.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # From https://stats.stackexchange.com/questions/798/</span>
<span class="gi">+    a = np.asarray(a)</span>
<span class="gi">+    if len(a) &lt; 2:</span>
<span class="gi">+        return 1</span>
<span class="gi">+    iqr = np.subtract.reduce(np.nanpercentile(a, [75, 25]))</span>
<span class="gi">+    h = 2 * iqr / (len(a) ** (1 / 3))</span>
<span class="gi">+    # fall back to sqrt(a) bins if iqr is 0</span>
<span class="gi">+    if h == 0:</span>
<span class="gi">+        return int(np.sqrt(a.size))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return int(np.ceil((a.max() - a.min()) / h))</span>


<span class="w"> </span>def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,
<span class="gd">-    hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None, color=None,</span>
<span class="gd">-    vertical=False, norm_hist=False, axlabel=None, label=None, ax=None, x=None</span>
<span class="gd">-    ):</span>
<span class="gi">+             hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None,</span>
<span class="gi">+             color=None, vertical=False, norm_hist=False, axlabel=None,</span>
<span class="gi">+             label=None, ax=None, x=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    DEPRECATED

<span class="gu">@@ -556,4 +2403,129 @@ def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,</span>
<span class="w"> </span>    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if kde and not hist:</span>
<span class="gi">+        axes_level_suggestion = (</span>
<span class="gi">+            &quot;`kdeplot` (an axes-level function for kernel density plots)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        axes_level_suggestion = (</span>
<span class="gi">+            &quot;`histplot` (an axes-level function for histograms)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    msg = textwrap.dedent(f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    `distplot` is a deprecated function and will be removed in seaborn v0.14.0.</span>
<span class="gi">+</span>
<span class="gi">+    Please adapt your code to use either `displot` (a figure-level function with</span>
<span class="gi">+    similar flexibility) or {axes_level_suggestion}.</span>
<span class="gi">+</span>
<span class="gi">+    For a guide to updating your code to use the new functions, please see</span>
<span class="gi">+    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751</span>
<span class="gi">+    &quot;&quot;&quot;)</span>
<span class="gi">+    warnings.warn(msg, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    # Intelligently label the support axis</span>
<span class="gi">+    label_ax = bool(axlabel)</span>
<span class="gi">+    if axlabel is None and hasattr(a, &quot;name&quot;):</span>
<span class="gi">+        axlabel = a.name</span>
<span class="gi">+        if axlabel is not None:</span>
<span class="gi">+            label_ax = True</span>
<span class="gi">+</span>
<span class="gi">+    # Support new-style API</span>
<span class="gi">+    if x is not None:</span>
<span class="gi">+        a = x</span>
<span class="gi">+</span>
<span class="gi">+    # Make a a 1-d float array</span>
<span class="gi">+    a = np.asarray(a, float)</span>
<span class="gi">+    if a.ndim &gt; 1:</span>
<span class="gi">+        a = a.squeeze()</span>
<span class="gi">+</span>
<span class="gi">+    # Drop null values from array</span>
<span class="gi">+    a = remove_na(a)</span>
<span class="gi">+</span>
<span class="gi">+    # Decide if the hist is normed</span>
<span class="gi">+    norm_hist = norm_hist or kde or (fit is not None)</span>
<span class="gi">+</span>
<span class="gi">+    # Handle dictionary defaults</span>
<span class="gi">+    hist_kws = {} if hist_kws is None else hist_kws.copy()</span>
<span class="gi">+    kde_kws = {} if kde_kws is None else kde_kws.copy()</span>
<span class="gi">+    rug_kws = {} if rug_kws is None else rug_kws.copy()</span>
<span class="gi">+    fit_kws = {} if fit_kws is None else fit_kws.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Get the color from the current color cycle</span>
<span class="gi">+    if color is None:</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            line, = ax.plot(0, a.mean())</span>
<span class="gi">+        else:</span>
<span class="gi">+            line, = ax.plot(a.mean(), 0)</span>
<span class="gi">+        color = line.get_color()</span>
<span class="gi">+        line.remove()</span>
<span class="gi">+</span>
<span class="gi">+    # Plug the label into the right kwarg dictionary</span>
<span class="gi">+    if label is not None:</span>
<span class="gi">+        if hist:</span>
<span class="gi">+            hist_kws[&quot;label&quot;] = label</span>
<span class="gi">+        elif kde:</span>
<span class="gi">+            kde_kws[&quot;label&quot;] = label</span>
<span class="gi">+        elif rug:</span>
<span class="gi">+            rug_kws[&quot;label&quot;] = label</span>
<span class="gi">+        elif fit:</span>
<span class="gi">+            fit_kws[&quot;label&quot;] = label</span>
<span class="gi">+</span>
<span class="gi">+    if hist:</span>
<span class="gi">+        if bins is None:</span>
<span class="gi">+            bins = min(_freedman_diaconis_bins(a), 50)</span>
<span class="gi">+        hist_kws.setdefault(&quot;alpha&quot;, 0.4)</span>
<span class="gi">+        hist_kws.setdefault(&quot;density&quot;, norm_hist)</span>
<span class="gi">+</span>
<span class="gi">+        orientation = &quot;horizontal&quot; if vertical else &quot;vertical&quot;</span>
<span class="gi">+        hist_color = hist_kws.pop(&quot;color&quot;, color)</span>
<span class="gi">+        ax.hist(a, bins, orientation=orientation,</span>
<span class="gi">+                color=hist_color, **hist_kws)</span>
<span class="gi">+        if hist_color != color:</span>
<span class="gi">+            hist_kws[&quot;color&quot;] = hist_color</span>
<span class="gi">+</span>
<span class="gi">+    axis = &quot;y&quot; if vertical else &quot;x&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if kde:</span>
<span class="gi">+        kde_color = kde_kws.pop(&quot;color&quot;, color)</span>
<span class="gi">+        kdeplot(**{axis: a}, ax=ax, color=kde_color, **kde_kws)</span>
<span class="gi">+        if kde_color != color:</span>
<span class="gi">+            kde_kws[&quot;color&quot;] = kde_color</span>
<span class="gi">+</span>
<span class="gi">+    if rug:</span>
<span class="gi">+        rug_color = rug_kws.pop(&quot;color&quot;, color)</span>
<span class="gi">+        rugplot(**{axis: a}, ax=ax, color=rug_color, **rug_kws)</span>
<span class="gi">+        if rug_color != color:</span>
<span class="gi">+            rug_kws[&quot;color&quot;] = rug_color</span>
<span class="gi">+</span>
<span class="gi">+    if fit is not None:</span>
<span class="gi">+</span>
<span class="gi">+        def pdf(x):</span>
<span class="gi">+            return fit.pdf(x, *params)</span>
<span class="gi">+</span>
<span class="gi">+        fit_color = fit_kws.pop(&quot;color&quot;, &quot;#282828&quot;)</span>
<span class="gi">+        gridsize = fit_kws.pop(&quot;gridsize&quot;, 200)</span>
<span class="gi">+        cut = fit_kws.pop(&quot;cut&quot;, 3)</span>
<span class="gi">+        clip = fit_kws.pop(&quot;clip&quot;, (-np.inf, np.inf))</span>
<span class="gi">+        bw = gaussian_kde(a).scotts_factor() * a.std(ddof=1)</span>
<span class="gi">+        x = _kde_support(a, bw, gridsize, cut, clip)</span>
<span class="gi">+        params = fit.fit(a)</span>
<span class="gi">+        y = pdf(x)</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            x, y = y, x</span>
<span class="gi">+        ax.plot(x, y, color=fit_color, **fit_kws)</span>
<span class="gi">+        if fit_color != &quot;#282828&quot;:</span>
<span class="gi">+            fit_kws[&quot;color&quot;] = fit_color</span>
<span class="gi">+</span>
<span class="gi">+    if label_ax:</span>
<span class="gi">+        if vertical:</span>
<span class="gi">+            ax.set_ylabel(axlabel)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax.set_xlabel(axlabel)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gh">diff --git a/seaborn/external/appdirs.py b/seaborn/external/appdirs.py</span>
<span class="gh">index dc520cd6..70c38296 100644</span>
<span class="gd">--- a/seaborn/external/appdirs.py</span>
<span class="gi">+++ b/seaborn/external/appdirs.py</span>
<span class="gu">@@ -1,3 +1,9 @@</span>
<span class="gi">+#!/usr/bin/env python3</span>
<span class="gi">+# Copyright (c) 2005-2010 ActiveState Software Inc.</span>
<span class="gi">+# Copyright (c) 2013 Eddy Petrișor</span>
<span class="gi">+</span>
<span class="gi">+# flake8: noqa</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This file is directly from
<span class="w"> </span>https://github.com/ActiveState/appdirs/blob/3fe6a83776843a46f20c2e5587afcffe05e03b39/appdirs.py
<span class="gu">@@ -28,30 +34,44 @@ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="w"> </span>TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
<span class="w"> </span>SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for determining application-specific dirs.

<span class="w"> </span>See &lt;https://github.com/ActiveState/appdirs&gt; for details and usage.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__version__ = &#39;1.4.4&#39;</span>
<span class="gd">-__version_info__ = tuple(int(segment) for segment in __version__.split(&#39;.&#39;))</span>
<span class="gi">+# Dev Notes:</span>
<span class="gi">+# - MSDN on where to store app data files:</span>
<span class="gi">+#   http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120</span>
<span class="gi">+# - Mac OS X: http://developer.apple.com/documentation/MacOSX/Conceptual/BPFileSystem/index.html</span>
<span class="gi">+# - XDG spec for Un*x: https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html</span>
<span class="gi">+</span>
<span class="gi">+__version__ = &quot;1.4.4&quot;</span>
<span class="gi">+__version_info__ = tuple(int(segment) for segment in __version__.split(&quot;.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>unicode = str
<span class="gi">+</span>
<span class="w"> </span>if sys.platform.startswith(&#39;java&#39;):
<span class="w"> </span>    import platform
<span class="w"> </span>    os_name = platform.java_ver()[3][0]
<span class="gd">-    if os_name.startswith(&#39;Windows&#39;):</span>
<span class="gi">+    if os_name.startswith(&#39;Windows&#39;): # &quot;Windows XP&quot;, &quot;Windows 7&quot;, etc.</span>
<span class="w"> </span>        system = &#39;win32&#39;
<span class="gd">-    elif os_name.startswith(&#39;Mac&#39;):</span>
<span class="gi">+    elif os_name.startswith(&#39;Mac&#39;): # &quot;Mac OS X&quot;, etc.</span>
<span class="w"> </span>        system = &#39;darwin&#39;
<span class="gd">-    else:</span>
<span class="gi">+    else: # &quot;Linux&quot;, &quot;SunOS&quot;, &quot;FreeBSD&quot;, etc.</span>
<span class="gi">+        # Setting this to &quot;linux2&quot; is not ideal, but only Windows or Mac</span>
<span class="gi">+        # are actually checked for and the rest of the module expects</span>
<span class="gi">+        # *sys.platform* style strings.</span>
<span class="w"> </span>        system = &#39;linux2&#39;
<span class="w"> </span>else:
<span class="w"> </span>    system = sys.platform


<span class="w"> </span>def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):
<span class="gd">-    &quot;&quot;&quot;Return full path to the user-specific cache dir for this application.</span>
<span class="gi">+    r&quot;&quot;&quot;Return full path to the user-specific cache dir for this application.</span>

<span class="w"> </span>        &quot;appname&quot; is the name of application.
<span class="w"> </span>            If None, just the system directory is returned.
<span class="gu">@@ -71,30 +91,145 @@ def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):</span>
<span class="w"> </span>    Typical user cache directories are:
<span class="w"> </span>        Mac OS X:   ~/Library/Caches/&lt;AppName&gt;
<span class="w"> </span>        Unix:       ~/.cache/&lt;AppName&gt; (XDG default)
<span class="gd">-        Win XP:     C:\\Documents and Settings\\&lt;username&gt;\\Local Settings\\Application Data\\&lt;AppAuthor&gt;\\&lt;AppName&gt;\\Cache</span>
<span class="gd">-        Vista:      C:\\Users\\&lt;username&gt;\\AppData\\Local\\&lt;AppAuthor&gt;\\&lt;AppName&gt;\\Cache</span>
<span class="gi">+        Win XP:     C:\Documents and Settings\&lt;username&gt;\Local Settings\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt;\Cache</span>
<span class="gi">+        Vista:      C:\Users\&lt;username&gt;\AppData\Local\&lt;AppAuthor&gt;\&lt;AppName&gt;\Cache</span>

<span class="w"> </span>    On Windows the only suggestion in the MSDN docs is that local settings go in
<span class="w"> </span>    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming
<span class="w"> </span>    app data dir (the default returned by `user_data_dir` above). Apps typically
<span class="w"> </span>    put cache data somewhere *under* the given dir here. Some examples:
<span class="gd">-        ...\\Mozilla\\Firefox\\Profiles\\&lt;ProfileName&gt;\\Cache</span>
<span class="gd">-        ...\\Acme\\SuperApp\\Cache\\1.0</span>
<span class="gi">+        ...\Mozilla\Firefox\Profiles\&lt;ProfileName&gt;\Cache</span>
<span class="gi">+        ...\Acme\SuperApp\Cache\1.0</span>
<span class="w"> </span>    OPINION: This function appends &quot;Cache&quot; to the `CSIDL_LOCAL_APPDATA` value.
<span class="w"> </span>    This can be disabled with the `opinion=False` option.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if system == &quot;win32&quot;:</span>
<span class="gi">+        if appauthor is None:</span>
<span class="gi">+            appauthor = appname</span>
<span class="gi">+        path = os.path.normpath(_get_win_folder(&quot;CSIDL_LOCAL_APPDATA&quot;))</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            if appauthor is not False:</span>
<span class="gi">+                path = os.path.join(path, appauthor, appname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                path = os.path.join(path, appname)</span>
<span class="gi">+            if opinion:</span>
<span class="gi">+                path = os.path.join(path, &quot;Cache&quot;)</span>
<span class="gi">+    elif system == &#39;darwin&#39;:</span>
<span class="gi">+        path = os.path.expanduser(&#39;~/Library/Caches&#39;)</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            path = os.path.join(path, appname)</span>
<span class="gi">+    else:</span>
<span class="gi">+        path = os.getenv(&#39;XDG_CACHE_HOME&#39;, os.path.expanduser(&#39;~/.cache&#39;))</span>
<span class="gi">+        if appname:</span>
<span class="gi">+            path = os.path.join(path, appname)</span>
<span class="gi">+    if appname and version:</span>
<span class="gi">+        path = os.path.join(path, version)</span>
<span class="gi">+    return path</span>


<span class="gi">+#---- internal support stuff</span>
<span class="gi">+</span>
<span class="w"> </span>def _get_win_folder_from_registry(csidl_name):
<span class="w"> </span>    &quot;&quot;&quot;This is a fallback technique at best. I&#39;m not sure if using the
<span class="w"> </span>    registry for this guarantees us the correct answer for all CSIDL_*
<span class="w"> </span>    names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-if system == &#39;win32&#39;:</span>
<span class="gi">+    import winreg as _winreg</span>
<span class="gi">+</span>
<span class="gi">+    shell_folder_name = {</span>
<span class="gi">+        &quot;CSIDL_APPDATA&quot;: &quot;AppData&quot;,</span>
<span class="gi">+        &quot;CSIDL_COMMON_APPDATA&quot;: &quot;Common AppData&quot;,</span>
<span class="gi">+        &quot;CSIDL_LOCAL_APPDATA&quot;: &quot;Local AppData&quot;,</span>
<span class="gi">+    }[csidl_name]</span>
<span class="gi">+</span>
<span class="gi">+    key = _winreg.OpenKey(</span>
<span class="gi">+        _winreg.HKEY_CURRENT_USER,</span>
<span class="gi">+        r&quot;Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    dir, type = _winreg.QueryValueEx(key, shell_folder_name)</span>
<span class="gi">+    return dir</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_win_folder_with_pywin32(csidl_name):</span>
<span class="gi">+    from win32com.shell import shellcon, shell</span>
<span class="gi">+    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)</span>
<span class="gi">+    # Try to make this a unicode path because SHGetFolderPath does</span>
<span class="gi">+    # not return unicode strings when there is unicode data in the</span>
<span class="gi">+    # path.</span>
<span class="gi">+    try:</span>
<span class="gi">+        dir = unicode(dir)</span>
<span class="gi">+</span>
<span class="gi">+        # Downgrade to short path name if have highbit chars. See</span>
<span class="gi">+        # &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
<span class="gi">+        has_high_char = False</span>
<span class="gi">+        for c in dir:</span>
<span class="gi">+            if ord(c) &gt; 255:</span>
<span class="gi">+                has_high_char = True</span>
<span class="gi">+                break</span>
<span class="gi">+        if has_high_char:</span>
<span class="gi">+            try:</span>
<span class="gi">+                import win32api</span>
<span class="gi">+                dir = win32api.GetShortPathName(dir)</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    except UnicodeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return dir</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_win_folder_with_ctypes(csidl_name):</span>
<span class="gi">+    import ctypes</span>
<span class="gi">+</span>
<span class="gi">+    csidl_const = {</span>
<span class="gi">+        &quot;CSIDL_APPDATA&quot;: 26,</span>
<span class="gi">+        &quot;CSIDL_COMMON_APPDATA&quot;: 35,</span>
<span class="gi">+        &quot;CSIDL_LOCAL_APPDATA&quot;: 28,</span>
<span class="gi">+    }[csidl_name]</span>
<span class="gi">+</span>
<span class="gi">+    buf = ctypes.create_unicode_buffer(1024)</span>
<span class="gi">+    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)</span>
<span class="gi">+</span>
<span class="gi">+    # Downgrade to short path name if have highbit chars. See</span>
<span class="gi">+    # &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
<span class="gi">+    has_high_char = False</span>
<span class="gi">+    for c in buf:</span>
<span class="gi">+        if ord(c) &gt; 255:</span>
<span class="gi">+            has_high_char = True</span>
<span class="gi">+            break</span>
<span class="gi">+    if has_high_char:</span>
<span class="gi">+        buf2 = ctypes.create_unicode_buffer(1024)</span>
<span class="gi">+        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):</span>
<span class="gi">+            buf = buf2</span>
<span class="gi">+</span>
<span class="gi">+    return buf.value</span>
<span class="gi">+</span>
<span class="gi">+def _get_win_folder_with_jna(csidl_name):</span>
<span class="gi">+    import array</span>
<span class="gi">+    from com.sun import jna</span>
<span class="gi">+    from com.sun.jna.platform import win32</span>
<span class="gi">+</span>
<span class="gi">+    buf_size = win32.WinDef.MAX_PATH * 2</span>
<span class="gi">+    buf = array.zeros(&#39;c&#39;, buf_size)</span>
<span class="gi">+    shell = win32.Shell32.INSTANCE</span>
<span class="gi">+    shell.SHGetFolderPath(None, getattr(win32.ShlObj, csidl_name), None, win32.ShlObj.SHGFP_TYPE_CURRENT, buf)</span>
<span class="gi">+    dir = jna.Native.toString(buf.tostring()).rstrip(&quot;\0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Downgrade to short path name if have highbit chars. See</span>
<span class="gi">+    # &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
<span class="gi">+    has_high_char = False</span>
<span class="gi">+    for c in dir:</span>
<span class="gi">+        if ord(c) &gt; 255:</span>
<span class="gi">+            has_high_char = True</span>
<span class="gi">+            break</span>
<span class="gi">+    if has_high_char:</span>
<span class="gi">+        buf = array.zeros(&#39;c&#39;, buf_size)</span>
<span class="gi">+        kernel = win32.Kernel32.INSTANCE</span>
<span class="gi">+        if kernel.GetShortPathName(dir, buf, buf_size):</span>
<span class="gi">+            dir = jna.Native.toString(buf.tostring()).rstrip(&quot;\0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return dir</span>
<span class="gi">+</span>
<span class="gi">+if system == &quot;win32&quot;:</span>
<span class="w"> </span>    try:
<span class="w"> </span>        import win32com.shell
<span class="w"> </span>        _get_win_folder = _get_win_folder_with_pywin32
<span class="gh">diff --git a/seaborn/external/docscrape.py b/seaborn/external/docscrape.py</span>
<span class="gh">index c3814e10..99dc3ff7 100644</span>
<span class="gd">--- a/seaborn/external/docscrape.py</span>
<span class="gi">+++ b/seaborn/external/docscrape.py</span>
<span class="gu">@@ -38,40 +38,95 @@ import sys</span>


<span class="w"> </span>def strip_blank_lines(l):
<span class="gd">-    &quot;&quot;&quot;Remove leading and trailing blank lines from a list of lines&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;Remove leading and trailing blank lines from a list of lines&quot;</span>
<span class="gi">+    while l and not l[0].strip():</span>
<span class="gi">+        del l[0]</span>
<span class="gi">+    while l and not l[-1].strip():</span>
<span class="gi">+        del l[-1]</span>
<span class="gi">+    return l</span>


<span class="w"> </span>class Reader:
<span class="w"> </span>    &quot;&quot;&quot;A line-based string reader.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parameters
<span class="w"> </span>        ----------
<span class="w"> </span>        data : str
<span class="gd">-           String with lines separated by &#39;</span>
<span class="gd">-&#39;.</span>
<span class="gi">+           String with lines separated by &#39;\n&#39;.</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if isinstance(data, list):
<span class="w"> </span>            self._str = data
<span class="w"> </span>        else:
<span class="gd">-            self._str = data.split(&#39;\n&#39;)</span>
<span class="gi">+            self._str = data.split(&#39;\n&#39;)  # store string as list of lines</span>
<span class="gi">+</span>
<span class="w"> </span>        self.reset()

<span class="w"> </span>    def __getitem__(self, n):
<span class="w"> </span>        return self._str[n]

<span class="gi">+    def reset(self):</span>
<span class="gi">+        self._l = 0  # current line nr</span>

<span class="gd">-class ParseError(Exception):</span>
<span class="gi">+    def read(self):</span>
<span class="gi">+        if not self.eof():</span>
<span class="gi">+            out = self[self._l]</span>
<span class="gi">+            self._l += 1</span>
<span class="gi">+            return out</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def seek_next_non_empty_line(self):</span>
<span class="gi">+        for l in self[self._l:]:</span>
<span class="gi">+            if l.strip():</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._l += 1</span>
<span class="gi">+</span>
<span class="gi">+    def eof(self):</span>
<span class="gi">+        return self._l &gt;= len(self._str)</span>
<span class="gi">+</span>
<span class="gi">+    def read_to_condition(self, condition_func):</span>
<span class="gi">+        start = self._l</span>
<span class="gi">+        for line in self[start:]:</span>
<span class="gi">+            if condition_func(line):</span>
<span class="gi">+                return self[start:self._l]</span>
<span class="gi">+            self._l += 1</span>
<span class="gi">+            if self.eof():</span>
<span class="gi">+                return self[start:self._l+1]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def read_to_next_empty_line(self):</span>
<span class="gi">+        self.seek_next_non_empty_line()</span>
<span class="gi">+</span>
<span class="gi">+        def is_empty(line):</span>
<span class="gi">+            return not line.strip()</span>
<span class="gi">+</span>
<span class="gi">+        return self.read_to_condition(is_empty)</span>
<span class="gi">+</span>
<span class="gi">+    def read_to_next_unindented_line(self):</span>
<span class="gi">+        def is_unindented(line):</span>
<span class="gi">+            return (line.strip() and (len(line.lstrip()) == len(line)))</span>
<span class="gi">+        return self.read_to_condition(is_unindented)</span>
<span class="gi">+</span>
<span class="gi">+    def peek(self, n=0):</span>
<span class="gi">+        if self._l + n &lt; len(self._str):</span>
<span class="gi">+            return self[self._l + n]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>

<span class="gi">+    def is_empty(self):</span>
<span class="gi">+        return not &#39;&#39;.join(self._str).strip()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ParseError(Exception):</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        message = self.args[0]
<span class="w"> </span>        if hasattr(self, &#39;docstring&#39;):
<span class="gd">-            message = f&#39;{message} in {self.docstring!r}&#39;</span>
<span class="gi">+            message = f&quot;{message} in {self.docstring!r}&quot;</span>
<span class="w"> </span>        return message


<span class="gu">@@ -84,17 +139,35 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>    Instances define a mapping from section title to structured data.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    sections = {&#39;Signature&#39;: &#39;&#39;, &#39;Summary&#39;: [&#39;&#39;], &#39;Extended Summary&#39;: [],</span>
<span class="gd">-        &#39;Parameters&#39;: [], &#39;Returns&#39;: [], &#39;Yields&#39;: [], &#39;Receives&#39;: [],</span>
<span class="gd">-        &#39;Raises&#39;: [], &#39;Warns&#39;: [], &#39;Other Parameters&#39;: [], &#39;Attributes&#39;: [],</span>
<span class="gd">-        &#39;Methods&#39;: [], &#39;See Also&#39;: [], &#39;Notes&#39;: [], &#39;Warnings&#39;: [],</span>
<span class="gd">-        &#39;References&#39;: &#39;&#39;, &#39;Examples&#39;: &#39;&#39;, &#39;index&#39;: {}}</span>
<span class="gi">+</span>
<span class="gi">+    sections = {</span>
<span class="gi">+        &#39;Signature&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;Summary&#39;: [&#39;&#39;],</span>
<span class="gi">+        &#39;Extended Summary&#39;: [],</span>
<span class="gi">+        &#39;Parameters&#39;: [],</span>
<span class="gi">+        &#39;Returns&#39;: [],</span>
<span class="gi">+        &#39;Yields&#39;: [],</span>
<span class="gi">+        &#39;Receives&#39;: [],</span>
<span class="gi">+        &#39;Raises&#39;: [],</span>
<span class="gi">+        &#39;Warns&#39;: [],</span>
<span class="gi">+        &#39;Other Parameters&#39;: [],</span>
<span class="gi">+        &#39;Attributes&#39;: [],</span>
<span class="gi">+        &#39;Methods&#39;: [],</span>
<span class="gi">+        &#39;See Also&#39;: [],</span>
<span class="gi">+        &#39;Notes&#39;: [],</span>
<span class="gi">+        &#39;Warnings&#39;: [],</span>
<span class="gi">+        &#39;References&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;Examples&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;index&#39;: {}</span>
<span class="gi">+    }</span>

<span class="w"> </span>    def __init__(self, docstring, config={}):
<span class="w"> </span>        orig_docstring = docstring
<span class="w"> </span>        docstring = textwrap.dedent(docstring).split(&#39;\n&#39;)
<span class="gi">+</span>
<span class="w"> </span>        self._doc = Reader(docstring)
<span class="w"> </span>        self._parsed_data = copy.deepcopy(self.sections)
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self._parse()
<span class="w"> </span>        except ParseError as e:
<span class="gu">@@ -106,7 +179,7 @@ class NumpyDocString(Mapping):</span>

<span class="w"> </span>    def __setitem__(self, key, val):
<span class="w"> </span>        if key not in self._parsed_data:
<span class="gd">-            self._error_location(f&#39;Unknown section {key}&#39;, error=False)</span>
<span class="gi">+            self._error_location(f&quot;Unknown section {key}&quot;, error=False)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._parsed_data[key] = val

<span class="gu">@@ -115,17 +188,112 @@ class NumpyDocString(Mapping):</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._parsed_data)
<span class="gd">-    _role = &#39;:(?P&lt;role&gt;\\w+):&#39;</span>
<span class="gd">-    _funcbacktick = &#39;`(?P&lt;name&gt;(?:~\\w+\\.)?[a-zA-Z0-9_\\.-]+)`&#39;</span>
<span class="gd">-    _funcplain = &#39;(?P&lt;name2&gt;[a-zA-Z0-9_\\.-]+)&#39;</span>
<span class="gd">-    _funcname = &#39;(&#39; + _role + _funcbacktick + &#39;|&#39; + _funcplain + &#39;)&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _is_at_section(self):</span>
<span class="gi">+        self._doc.seek_next_non_empty_line()</span>
<span class="gi">+</span>
<span class="gi">+        if self._doc.eof():</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        l1 = self._doc.peek().strip()  # e.g. Parameters</span>
<span class="gi">+</span>
<span class="gi">+        if l1.startswith(&#39;.. index::&#39;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        l2 = self._doc.peek(1).strip()  # ---------- or ==========</span>
<span class="gi">+        return l2.startswith(&#39;-&#39;*len(l1)) or l2.startswith(&#39;=&#39;*len(l1))</span>
<span class="gi">+</span>
<span class="gi">+    def _strip(self, doc):</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        j = 0</span>
<span class="gi">+        for i, line in enumerate(doc):</span>
<span class="gi">+            if line.strip():</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        for j, line in enumerate(doc[::-1]):</span>
<span class="gi">+            if line.strip():</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return doc[i:len(doc)-j]</span>
<span class="gi">+</span>
<span class="gi">+    def _read_to_next_section(self):</span>
<span class="gi">+        section = self._doc.read_to_next_empty_line()</span>
<span class="gi">+</span>
<span class="gi">+        while not self._is_at_section() and not self._doc.eof():</span>
<span class="gi">+            if not self._doc.peek(-1).strip():  # previous line was empty</span>
<span class="gi">+                section += [&#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            section += self._doc.read_to_next_empty_line()</span>
<span class="gi">+</span>
<span class="gi">+        return section</span>
<span class="gi">+</span>
<span class="gi">+    def _read_sections(self):</span>
<span class="gi">+        while not self._doc.eof():</span>
<span class="gi">+            data = self._read_to_next_section()</span>
<span class="gi">+            name = data[0].strip()</span>
<span class="gi">+</span>
<span class="gi">+            if name.startswith(&#39;..&#39;):  # index section</span>
<span class="gi">+                yield name, data[1:]</span>
<span class="gi">+            elif len(data) &lt; 2:</span>
<span class="gi">+                yield StopIteration</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield name, self._strip(data[2:])</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_param_list(self, content, single_element_is_type=False):</span>
<span class="gi">+        r = Reader(content)</span>
<span class="gi">+        params = []</span>
<span class="gi">+        while not r.eof():</span>
<span class="gi">+            header = r.read().strip()</span>
<span class="gi">+            if &#39; : &#39; in header:</span>
<span class="gi">+                arg_name, arg_type = header.split(&#39; : &#39;)[:2]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if single_element_is_type:</span>
<span class="gi">+                    arg_name, arg_type = &#39;&#39;, header</span>
<span class="gi">+                else:</span>
<span class="gi">+                    arg_name, arg_type = header, &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+            desc = r.read_to_next_unindented_line()</span>
<span class="gi">+            desc = dedent_lines(desc)</span>
<span class="gi">+            desc = strip_blank_lines(desc)</span>
<span class="gi">+</span>
<span class="gi">+            params.append(Parameter(arg_name, arg_type, desc))</span>
<span class="gi">+</span>
<span class="gi">+        return params</span>
<span class="gi">+</span>
<span class="gi">+    # See also supports the following formats.</span>
<span class="gi">+    #</span>
<span class="gi">+    # &lt;FUNCNAME&gt;</span>
<span class="gi">+    # &lt;FUNCNAME&gt; SPACE* COLON SPACE+ &lt;DESC&gt; SPACE*</span>
<span class="gi">+    # &lt;FUNCNAME&gt; ( COMMA SPACE+ &lt;FUNCNAME&gt;)+ (COMMA | PERIOD)? SPACE*</span>
<span class="gi">+    # &lt;FUNCNAME&gt; ( COMMA SPACE+ &lt;FUNCNAME&gt;)* SPACE* COLON SPACE+ &lt;DESC&gt; SPACE*</span>
<span class="gi">+</span>
<span class="gi">+    # &lt;FUNCNAME&gt; is one of</span>
<span class="gi">+    #   &lt;PLAIN_FUNCNAME&gt;</span>
<span class="gi">+    #   COLON &lt;ROLE&gt; COLON BACKTICK &lt;PLAIN_FUNCNAME&gt; BACKTICK</span>
<span class="gi">+    # where</span>
<span class="gi">+    #   &lt;PLAIN_FUNCNAME&gt; is a legal function name, and</span>
<span class="gi">+    #   &lt;ROLE&gt; is any nonempty sequence of word characters.</span>
<span class="gi">+    # Examples: func_f1  :meth:`func_h1` :obj:`~baz.obj_r` :class:`class_j`</span>
<span class="gi">+    # &lt;DESC&gt; is a string describing the function.</span>
<span class="gi">+</span>
<span class="gi">+    _role = r&quot;:(?P&lt;role&gt;\w+):&quot;</span>
<span class="gi">+    _funcbacktick = r&quot;`(?P&lt;name&gt;(?:~\w+\.)?[a-zA-Z0-9_\.-]+)`&quot;</span>
<span class="gi">+    _funcplain = r&quot;(?P&lt;name2&gt;[a-zA-Z0-9_\.-]+)&quot;</span>
<span class="gi">+    _funcname = r&quot;(&quot; + _role + _funcbacktick + r&quot;|&quot; + _funcplain + r&quot;)&quot;</span>
<span class="w"> </span>    _funcnamenext = _funcname.replace(&#39;role&#39;, &#39;rolenext&#39;)
<span class="w"> </span>    _funcnamenext = _funcnamenext.replace(&#39;name&#39;, &#39;namenext&#39;)
<span class="gd">-    _description = &#39;(?P&lt;description&gt;\\s*:(\\s+(?P&lt;desc&gt;\\S+.*))?)?\\s*$&#39;</span>
<span class="gd">-    _func_rgx = re.compile(&#39;^\\s*&#39; + _funcname + &#39;\\s*&#39;)</span>
<span class="gd">-    _line_rgx = re.compile(&#39;^\\s*&#39; + &#39;(?P&lt;allfuncs&gt;&#39; + _funcname +</span>
<span class="gd">-        &#39;(?P&lt;morefuncs&gt;([,]\\s+&#39; + _funcnamenext + &#39;)*)&#39; + &#39;)&#39; +</span>
<span class="gd">-        &#39;(?P&lt;trailing&gt;[,\\.])?&#39; + _description)</span>
<span class="gi">+    _description = r&quot;(?P&lt;description&gt;\s*:(\s+(?P&lt;desc&gt;\S+.*))?)?\s*$&quot;</span>
<span class="gi">+    _func_rgx = re.compile(r&quot;^\s*&quot; + _funcname + r&quot;\s*&quot;)</span>
<span class="gi">+    _line_rgx = re.compile(</span>
<span class="gi">+        r&quot;^\s*&quot; +</span>
<span class="gi">+        r&quot;(?P&lt;allfuncs&gt;&quot; +        # group for all function names</span>
<span class="gi">+        _funcname +</span>
<span class="gi">+        r&quot;(?P&lt;morefuncs&gt;([,]\s+&quot; + _funcnamenext + r&quot;)*)&quot; +</span>
<span class="gi">+        r&quot;)&quot; +                     # end of &quot;allfuncs&quot;</span>
<span class="gi">+        r&quot;(?P&lt;trailing&gt;[,\.])?&quot; +   # Some function lists have a trailing comma (or period)  &#39;\s*&#39;</span>
<span class="gi">+        _description)</span>
<span class="gi">+</span>
<span class="gi">+    # Empty &lt;DESC&gt; elements are replaced with &#39;..&#39;</span>
<span class="w"> </span>    empty_description = &#39;..&#39;

<span class="w"> </span>    def _parse_see_also(self, content):
<span class="gu">@@ -136,7 +304,50 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>        func_name1, func_name2, :meth:`func_name`, func_name3

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        items = []</span>
<span class="gi">+</span>
<span class="gi">+        def parse_item_name(text):</span>
<span class="gi">+            &quot;&quot;&quot;Match &#39;:role:`name`&#39; or &#39;name&#39;.&quot;&quot;&quot;</span>
<span class="gi">+            m = self._func_rgx.match(text)</span>
<span class="gi">+            if not m:</span>
<span class="gi">+                raise ParseError(f&quot;{text} is not a item name&quot;)</span>
<span class="gi">+            role = m.group(&#39;role&#39;)</span>
<span class="gi">+            name = m.group(&#39;name&#39;) if role else m.group(&#39;name2&#39;)</span>
<span class="gi">+            return name, role, m.end()</span>
<span class="gi">+</span>
<span class="gi">+        rest = []</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            if not line.strip():</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            line_match = self._line_rgx.match(line)</span>
<span class="gi">+            description = None</span>
<span class="gi">+            if line_match:</span>
<span class="gi">+                description = line_match.group(&#39;desc&#39;)</span>
<span class="gi">+                if line_match.group(&#39;trailing&#39;) and description:</span>
<span class="gi">+                    self._error_location(</span>
<span class="gi">+                        &#39;Unexpected comma or period after function list at index %d of &#39;</span>
<span class="gi">+                        &#39;line &quot;%s&quot;&#39; % (line_match.end(&#39;trailing&#39;), line),</span>
<span class="gi">+                        error=False)</span>
<span class="gi">+            if not description and line.startswith(&#39; &#39;):</span>
<span class="gi">+                rest.append(line.strip())</span>
<span class="gi">+            elif line_match:</span>
<span class="gi">+                funcs = []</span>
<span class="gi">+                text = line_match.group(&#39;allfuncs&#39;)</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    if not text.strip():</span>
<span class="gi">+                        break</span>
<span class="gi">+                    name, role, match_end = parse_item_name(text)</span>
<span class="gi">+                    funcs.append((name, role))</span>
<span class="gi">+                    text = text[match_end:].strip()</span>
<span class="gi">+                    if text and text[0] == &#39;,&#39;:</span>
<span class="gi">+                        text = text[1:].strip()</span>
<span class="gi">+                rest = list(filter(None, [description]))</span>
<span class="gi">+                items.append((funcs, rest))</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ParseError(f&quot;{line} is not a item name&quot;)</span>
<span class="gi">+        return items</span>

<span class="w"> </span>    def _parse_index(self, section, content):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,11 +355,193 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>           :refguide: something, else, and more

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def strip_each_in(lst):</span>
<span class="gi">+            return [s.strip() for s in lst]</span>
<span class="gi">+</span>
<span class="gi">+        out = {}</span>
<span class="gi">+        section = section.split(&#39;::&#39;)</span>
<span class="gi">+        if len(section) &gt; 1:</span>
<span class="gi">+            out[&#39;default&#39;] = strip_each_in(section[1].split(&#39;,&#39;))[0]</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            line = line.split(&#39;:&#39;)</span>
<span class="gi">+            if len(line) &gt; 2:</span>
<span class="gi">+                out[line[1]] = strip_each_in(line[2].split(&#39;,&#39;))</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def _parse_summary(self):
<span class="w"> </span>        &quot;&quot;&quot;Grab signature (if given) and summary&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_at_section():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If several signatures present, take the last one</span>
<span class="gi">+        while True:</span>
<span class="gi">+            summary = self._doc.read_to_next_empty_line()</span>
<span class="gi">+            summary_str = &quot; &quot;.join([s.strip() for s in summary]).strip()</span>
<span class="gi">+            compiled = re.compile(r&#39;^([\w., ]+=)?\s*[\w\.]+\(.*\)$&#39;)</span>
<span class="gi">+            if compiled.match(summary_str):</span>
<span class="gi">+                self[&#39;Signature&#39;] = summary_str</span>
<span class="gi">+                if not self._is_at_section():</span>
<span class="gi">+                    continue</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        if summary is not None:</span>
<span class="gi">+            self[&#39;Summary&#39;] = summary</span>
<span class="gi">+</span>
<span class="gi">+        if not self._is_at_section():</span>
<span class="gi">+            self[&#39;Extended Summary&#39;] = self._read_to_next_section()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse(self):</span>
<span class="gi">+        self._doc.reset()</span>
<span class="gi">+        self._parse_summary()</span>
<span class="gi">+</span>
<span class="gi">+        sections = list(self._read_sections())</span>
<span class="gi">+        section_names = {section for section, content in sections}</span>
<span class="gi">+</span>
<span class="gi">+        has_returns = &#39;Returns&#39; in section_names</span>
<span class="gi">+        has_yields = &#39;Yields&#39; in section_names</span>
<span class="gi">+        # We could do more tests, but we are not. Arbitrarily.</span>
<span class="gi">+        if has_returns and has_yields:</span>
<span class="gi">+            msg = &#39;Docstring contains both a Returns and Yields section.&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        if not has_yields and &#39;Receives&#39; in section_names:</span>
<span class="gi">+            msg = &#39;Docstring contains a Receives section but not Yields.&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        for (section, content) in sections:</span>
<span class="gi">+            if not section.startswith(&#39;..&#39;):</span>
<span class="gi">+                section = (s.capitalize() for s in section.split(&#39; &#39;))</span>
<span class="gi">+                section = &#39; &#39;.join(section)</span>
<span class="gi">+                if self.get(section):</span>
<span class="gi">+                    self._error_location(f&quot;The section {section} appears twice&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if section in (&#39;Parameters&#39;, &#39;Other Parameters&#39;, &#39;Attributes&#39;,</span>
<span class="gi">+                           &#39;Methods&#39;):</span>
<span class="gi">+                self[section] = self._parse_param_list(content)</span>
<span class="gi">+            elif section in (&#39;Returns&#39;, &#39;Yields&#39;, &#39;Raises&#39;, &#39;Warns&#39;, &#39;Receives&#39;):</span>
<span class="gi">+                self[section] = self._parse_param_list(</span>
<span class="gi">+                    content, single_element_is_type=True)</span>
<span class="gi">+            elif section.startswith(&#39;.. index::&#39;):</span>
<span class="gi">+                self[&#39;index&#39;] = self._parse_index(section, content)</span>
<span class="gi">+            elif section == &#39;See Also&#39;:</span>
<span class="gi">+                self[&#39;See Also&#39;] = self._parse_see_also(content)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self[section] = content</span>
<span class="gi">+</span>
<span class="gi">+    def _error_location(self, msg, error=True):</span>
<span class="gi">+        if hasattr(self, &#39;_obj&#39;):</span>
<span class="gi">+            # we know where the docs came from:</span>
<span class="gi">+            try:</span>
<span class="gi">+                filename = inspect.getsourcefile(self._obj)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                filename = None</span>
<span class="gi">+            msg = msg + f&quot; in the docstring of {self._obj} in {filename}.&quot;</span>
<span class="gi">+        if error:</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            warn(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # string conversion routines</span>
<span class="gi">+</span>
<span class="gi">+    def _str_header(self, name, symbol=&#39;-&#39;):</span>
<span class="gi">+        return [name, len(name)*symbol]</span>
<span class="gi">+</span>
<span class="gi">+    def _str_indent(self, doc, indent=4):</span>
<span class="gi">+        out = []</span>
<span class="gi">+        for line in doc:</span>
<span class="gi">+            out += [&#39; &#39;*indent + line]</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _str_signature(self):</span>
<span class="gi">+        if self[&#39;Signature&#39;]:</span>
<span class="gi">+            return [self[&#39;Signature&#39;].replace(&#39;*&#39;, r&#39;\*&#39;)] + [&#39;&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [&#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def _str_summary(self):</span>
<span class="gi">+        if self[&#39;Summary&#39;]:</span>
<span class="gi">+            return self[&#39;Summary&#39;] + [&#39;&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    def _str_extended_summary(self):</span>
<span class="gi">+        if self[&#39;Extended Summary&#39;]:</span>
<span class="gi">+            return self[&#39;Extended Summary&#39;] + [&#39;&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    def _str_param_list(self, name):</span>
<span class="gi">+        out = []</span>
<span class="gi">+        if self[name]:</span>
<span class="gi">+            out += self._str_header(name)</span>
<span class="gi">+            for param in self[name]:</span>
<span class="gi">+                parts = []</span>
<span class="gi">+                if param.name:</span>
<span class="gi">+                    parts.append(param.name)</span>
<span class="gi">+                if param.type:</span>
<span class="gi">+                    parts.append(param.type)</span>
<span class="gi">+                out += [&#39; : &#39;.join(parts)]</span>
<span class="gi">+                if param.desc and &#39;&#39;.join(param.desc).strip():</span>
<span class="gi">+                    out += self._str_indent(param.desc)</span>
<span class="gi">+            out += [&#39;&#39;]</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _str_section(self, name):</span>
<span class="gi">+        out = []</span>
<span class="gi">+        if self[name]:</span>
<span class="gi">+            out += self._str_header(name)</span>
<span class="gi">+            out += self[name]</span>
<span class="gi">+            out += [&#39;&#39;]</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _str_see_also(self, func_role):</span>
<span class="gi">+        if not self[&#39;See Also&#39;]:</span>
<span class="gi">+            return []</span>
<span class="gi">+        out = []</span>
<span class="gi">+        out += self._str_header(&quot;See Also&quot;)</span>
<span class="gi">+        out += [&#39;&#39;]</span>
<span class="gi">+        last_had_desc = True</span>
<span class="gi">+        for funcs, desc in self[&#39;See Also&#39;]:</span>
<span class="gi">+            assert isinstance(funcs, list)</span>
<span class="gi">+            links = []</span>
<span class="gi">+            for func, role in funcs:</span>
<span class="gi">+                if role:</span>
<span class="gi">+                    link = f&#39;:{role}:`{func}`&#39;</span>
<span class="gi">+                elif func_role:</span>
<span class="gi">+                    link = f&#39;:{func_role}:`{func}`&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    link = f&quot;`{func}`_&quot;</span>
<span class="gi">+                links.append(link)</span>
<span class="gi">+            link = &#39;, &#39;.join(links)</span>
<span class="gi">+            out += [link]</span>
<span class="gi">+            if desc:</span>
<span class="gi">+                out += self._str_indent([&#39; &#39;.join(desc)])</span>
<span class="gi">+                last_had_desc = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                last_had_desc = False</span>
<span class="gi">+                out += self._str_indent([self.empty_description])</span>
<span class="gi">+</span>
<span class="gi">+        if last_had_desc:</span>
<span class="gi">+            out += [&#39;&#39;]</span>
<span class="gi">+        out += [&#39;&#39;]</span>
<span class="gi">+        return out</span>
<span class="gi">+</span>
<span class="gi">+    def _str_index(self):</span>
<span class="gi">+        idx = self[&#39;index&#39;]</span>
<span class="gi">+        out = []</span>
<span class="gi">+        output_index = False</span>
<span class="gi">+        default_index = idx.get(&#39;default&#39;, &#39;&#39;)</span>
<span class="gi">+        if default_index:</span>
<span class="gi">+            output_index = True</span>
<span class="gi">+        out += [f&#39;.. index:: {default_index}&#39;]</span>
<span class="gi">+        for section, references in idx.items():</span>
<span class="gi">+            if section == &#39;default&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            output_index = True</span>
<span class="gi">+            out += [f&quot;   :{section}: {&#39;, &#39;.join(references)}&quot;]</span>
<span class="gi">+        if output_index:</span>
<span class="gi">+            return out</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>

<span class="w"> </span>    def __str__(self, func_role=&#39;&#39;):
<span class="w"> </span>        out = []
<span class="gu">@@ -156,7 +549,7 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>        out += self._str_summary()
<span class="w"> </span>        out += self._str_extended_summary()
<span class="w"> </span>        for param_list in (&#39;Parameters&#39;, &#39;Returns&#39;, &#39;Yields&#39;, &#39;Receives&#39;,
<span class="gd">-            &#39;Other Parameters&#39;, &#39;Raises&#39;, &#39;Warns&#39;):</span>
<span class="gi">+                           &#39;Other Parameters&#39;, &#39;Raises&#39;, &#39;Warns&#39;):</span>
<span class="w"> </span>            out += self._str_param_list(param_list)
<span class="w"> </span>        out += self._str_section(&#39;Warnings&#39;)
<span class="w"> </span>        out += self._str_see_also(func_role)
<span class="gu">@@ -168,27 +561,41 @@ class NumpyDocString(Mapping):</span>
<span class="w"> </span>        return &#39;\n&#39;.join(out)


<span class="gi">+def indent(str, indent=4):</span>
<span class="gi">+    indent_str = &#39; &#39;*indent</span>
<span class="gi">+    if str is None:</span>
<span class="gi">+        return indent_str</span>
<span class="gi">+    lines = str.split(&#39;\n&#39;)</span>
<span class="gi">+    return &#39;\n&#39;.join(indent_str + l for l in lines)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>def dedent_lines(lines):
<span class="w"> </span>    &quot;&quot;&quot;Deindent a list of lines maximally&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return textwrap.dedent(&quot;\n&quot;.join(lines)).split(&quot;\n&quot;)</span>


<span class="gd">-class FunctionDoc(NumpyDocString):</span>
<span class="gi">+def header(text, style=&#39;-&#39;):</span>
<span class="gi">+    return text + &#39;\n&#39; + style*len(text) + &#39;\n&#39;</span>
<span class="gi">+</span>

<span class="gi">+class FunctionDoc(NumpyDocString):</span>
<span class="w"> </span>    def __init__(self, func, role=&#39;func&#39;, doc=None, config={}):
<span class="w"> </span>        self._f = func
<span class="gd">-        self._role = role</span>
<span class="gi">+        self._role = role  # e.g. &quot;func&quot; or &quot;meth&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        if doc is None:
<span class="w"> </span>            if func is None:
<span class="gd">-                raise ValueError(&#39;No function or docstring given&#39;)</span>
<span class="gi">+                raise ValueError(&quot;No function or docstring given&quot;)</span>
<span class="w"> </span>            doc = inspect.getdoc(func) or &#39;&#39;
<span class="w"> </span>        NumpyDocString.__init__(self, doc, config)
<span class="gi">+</span>
<span class="w"> </span>        if not self[&#39;Signature&#39;] and func is not None:
<span class="w"> </span>            func, func_name = self.get_func()
<span class="w"> </span>            try:
<span class="w"> </span>                try:
<span class="w"> </span>                    signature = str(inspect.signature(func))
<span class="w"> </span>                except (AttributeError, ValueError):
<span class="gi">+                    # try to read signature, backward compat for older Python</span>
<span class="w"> </span>                    if sys.version_info[0] &gt;= 3:
<span class="w"> </span>                        argspec = inspect.getfullargspec(func)
<span class="w"> </span>                    else:
<span class="gu">@@ -199,63 +606,110 @@ class FunctionDoc(NumpyDocString):</span>
<span class="w"> </span>                signature = f&#39;{func_name}()&#39;
<span class="w"> </span>            self[&#39;Signature&#39;] = signature

<span class="gi">+    def get_func(self):</span>
<span class="gi">+        func_name = getattr(self._f, &#39;__name__&#39;, self.__class__.__name__)</span>
<span class="gi">+        if inspect.isclass(self._f):</span>
<span class="gi">+            func = getattr(self._f, &#39;__call__&#39;, self._f.__init__)</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = self._f</span>
<span class="gi">+        return func, func_name</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        out = &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>        func, func_name = self.get_func()
<span class="gd">-        roles = {&#39;func&#39;: &#39;function&#39;, &#39;meth&#39;: &#39;method&#39;}</span>
<span class="gi">+</span>
<span class="gi">+        roles = {&#39;func&#39;: &#39;function&#39;,</span>
<span class="gi">+                 &#39;meth&#39;: &#39;method&#39;}</span>
<span class="gi">+</span>
<span class="w"> </span>        if self._role:
<span class="w"> </span>            if self._role not in roles:
<span class="gd">-                print(f&#39;Warning: invalid role {self._role}&#39;)</span>
<span class="gi">+                print(f&quot;Warning: invalid role {self._role}&quot;)</span>
<span class="w"> </span>            out += f&quot;.. {roles.get(self._role, &#39;&#39;)}:: {func_name}\n    \n\n&quot;
<span class="gi">+</span>
<span class="w"> </span>        out += super().__str__(func_role=self._role)
<span class="w"> </span>        return out


<span class="w"> </span>class ClassDoc(NumpyDocString):
<span class="gi">+</span>
<span class="w"> </span>    extra_public_methods = [&#39;__call__&#39;]

<span class="w"> </span>    def __init__(self, cls, doc=None, modulename=&#39;&#39;, func_doc=FunctionDoc,
<span class="gd">-        config={}):</span>
<span class="gi">+                 config={}):</span>
<span class="w"> </span>        if not inspect.isclass(cls) and cls is not None:
<span class="gd">-            raise ValueError(f&#39;Expected a class or None, but got {cls!r}&#39;)</span>
<span class="gi">+            raise ValueError(f&quot;Expected a class or None, but got {cls!r}&quot;)</span>
<span class="w"> </span>        self._cls = cls
<span class="gi">+</span>
<span class="w"> </span>        if &#39;sphinx&#39; in sys.modules:
<span class="w"> </span>            from sphinx.ext.autodoc import ALL
<span class="w"> </span>        else:
<span class="w"> </span>            ALL = object()
<span class="gd">-        self.show_inherited_members = config.get(&#39;show_inherited_class_members&#39;</span>
<span class="gd">-            , True)</span>
<span class="gi">+</span>
<span class="gi">+        self.show_inherited_members = config.get(</span>
<span class="gi">+                    &#39;show_inherited_class_members&#39;, True)</span>
<span class="gi">+</span>
<span class="w"> </span>        if modulename and not modulename.endswith(&#39;.&#39;):
<span class="w"> </span>            modulename += &#39;.&#39;
<span class="w"> </span>        self._mod = modulename
<span class="gi">+</span>
<span class="w"> </span>        if doc is None:
<span class="w"> </span>            if cls is None:
<span class="gd">-                raise ValueError(&#39;No class or documentation string given&#39;)</span>
<span class="gi">+                raise ValueError(&quot;No class or documentation string given&quot;)</span>
<span class="w"> </span>            doc = pydoc.getdoc(cls)
<span class="gi">+</span>
<span class="w"> </span>        NumpyDocString.__init__(self, doc)
<span class="gi">+</span>
<span class="w"> </span>        _members = config.get(&#39;members&#39;, [])
<span class="w"> </span>        if _members is ALL:
<span class="w"> </span>            _members = None
<span class="w"> </span>        _exclude = config.get(&#39;exclude-members&#39;, [])
<span class="gd">-        if config.get(&#39;show_class_members&#39;, True) and _exclude is not ALL:</span>

<span class="gi">+        if config.get(&#39;show_class_members&#39;, True) and _exclude is not ALL:</span>
<span class="w"> </span>            def splitlines_x(s):
<span class="w"> </span>                if not s:
<span class="w"> </span>                    return []
<span class="w"> </span>                else:
<span class="w"> </span>                    return s.splitlines()
<span class="gd">-            for field, items in [(&#39;Methods&#39;, self.methods), (&#39;Attributes&#39;,</span>
<span class="gd">-                self.properties)]:</span>
<span class="gi">+            for field, items in [(&#39;Methods&#39;, self.methods),</span>
<span class="gi">+                                 (&#39;Attributes&#39;, self.properties)]:</span>
<span class="w"> </span>                if not self[field]:
<span class="w"> </span>                    doc_list = []
<span class="w"> </span>                    for name in sorted(items):
<span class="gd">-                        if (name in _exclude or _members and name not in</span>
<span class="gd">-                            _members):</span>
<span class="gi">+                        if (name in _exclude or</span>
<span class="gi">+                                (_members and name not in _members)):</span>
<span class="w"> </span>                            continue
<span class="w"> </span>                        try:
<span class="w"> </span>                            doc_item = pydoc.getdoc(getattr(self._cls, name))
<span class="gd">-                            doc_list.append(Parameter(name, &#39;&#39;,</span>
<span class="gd">-                                splitlines_x(doc_item)))</span>
<span class="gi">+                            doc_list.append(</span>
<span class="gi">+                                Parameter(name, &#39;&#39;, splitlines_x(doc_item)))</span>
<span class="w"> </span>                        except AttributeError:
<span class="gd">-                            pass</span>
<span class="gi">+                            pass  # method doesn&#39;t exist</span>
<span class="w"> </span>                    self[field] = doc_list
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def methods(self):</span>
<span class="gi">+        if self._cls is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [name for name, func in inspect.getmembers(self._cls)</span>
<span class="gi">+                if ((not name.startswith(&#39;_&#39;)</span>
<span class="gi">+                     or name in self.extra_public_methods)</span>
<span class="gi">+                    and isinstance(func, Callable)</span>
<span class="gi">+                    and self._is_show_member(name))]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def properties(self):</span>
<span class="gi">+        if self._cls is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [name for name, func in inspect.getmembers(self._cls)</span>
<span class="gi">+                if (not name.startswith(&#39;_&#39;) and</span>
<span class="gi">+                    (func is None or isinstance(func, property) or</span>
<span class="gi">+                     inspect.isdatadescriptor(func))</span>
<span class="gi">+                    and self._is_show_member(name))]</span>
<span class="gi">+</span>
<span class="gi">+    def _is_show_member(self, name):</span>
<span class="gi">+        if self.show_inherited_members:</span>
<span class="gi">+            return True  # show all class members</span>
<span class="gi">+        if name not in self._cls.__dict__:</span>
<span class="gi">+            return False  # class member is inherited, we do not show it</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/seaborn/external/husl.py b/seaborn/external/husl.py</span>
<span class="gh">index f2d85a4d..63e98cbb 100644</span>
<span class="gd">--- a/seaborn/external/husl.py</span>
<span class="gi">+++ b/seaborn/external/husl.py</span>
<span class="gu">@@ -1,14 +1,313 @@</span>
<span class="w"> </span>import operator
<span class="w"> </span>import math
<span class="gd">-__version__ = &#39;2.1.0&#39;</span>
<span class="gd">-m = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204,</span>
<span class="gd">-    1.057]]</span>
<span class="gd">-m_inv = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, </span>
<span class="gd">-    0.1192, 0.9505]]</span>
<span class="gi">+</span>
<span class="gi">+__version__ = &quot;2.1.0&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+m = [</span>
<span class="gi">+    [3.2406, -1.5372, -0.4986],</span>
<span class="gi">+    [-0.9689, 1.8758, 0.0415],</span>
<span class="gi">+    [0.0557, -0.2040, 1.0570]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+m_inv = [</span>
<span class="gi">+    [0.4124, 0.3576, 0.1805],</span>
<span class="gi">+    [0.2126, 0.7152, 0.0722],</span>
<span class="gi">+    [0.0193, 0.1192, 0.9505]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# Hard-coded D65 illuminant</span>
<span class="w"> </span>refX = 0.95047
<span class="gd">-refY = 1.0</span>
<span class="gi">+refY = 1.00000</span>
<span class="w"> </span>refZ = 1.08883
<span class="w"> </span>refU = 0.19784
<span class="w"> </span>refV = 0.46834
<span class="w"> </span>lab_e = 0.008856
<span class="w"> </span>lab_k = 903.3
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Public API</span>
<span class="gi">+</span>
<span class="gi">+def husl_to_rgb(h, s, l):</span>
<span class="gi">+    return lch_to_rgb(*husl_to_lch([h, s, l]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def husl_to_hex(h, s, l):</span>
<span class="gi">+    return rgb_to_hex(husl_to_rgb(h, s, l))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_to_husl(r, g, b):</span>
<span class="gi">+    return lch_to_husl(rgb_to_lch(r, g, b))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hex_to_husl(hex):</span>
<span class="gi">+    return rgb_to_husl(*hex_to_rgb(hex))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def huslp_to_rgb(h, s, l):</span>
<span class="gi">+    return lch_to_rgb(*huslp_to_lch([h, s, l]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def huslp_to_hex(h, s, l):</span>
<span class="gi">+    return rgb_to_hex(huslp_to_rgb(h, s, l))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_to_huslp(r, g, b):</span>
<span class="gi">+    return lch_to_huslp(rgb_to_lch(r, g, b))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hex_to_huslp(hex):</span>
<span class="gi">+    return rgb_to_huslp(*hex_to_rgb(hex))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lch_to_rgb(l, c, h):</span>
<span class="gi">+    return xyz_to_rgb(luv_to_xyz(lch_to_luv([l, c, h])))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_to_lch(r, g, b):</span>
<span class="gi">+    return luv_to_lch(xyz_to_luv(rgb_to_xyz([r, g, b])))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def max_chroma(L, H):</span>
<span class="gi">+    hrad = math.radians(H)</span>
<span class="gi">+    sinH = (math.sin(hrad))</span>
<span class="gi">+    cosH = (math.cos(hrad))</span>
<span class="gi">+    sub1 = (math.pow(L + 16, 3.0) / 1560896.0)</span>
<span class="gi">+    sub2 = sub1 if sub1 &gt; 0.008856 else (L / 903.3)</span>
<span class="gi">+    result = float(&quot;inf&quot;)</span>
<span class="gi">+    for row in m:</span>
<span class="gi">+        m1 = row[0]</span>
<span class="gi">+        m2 = row[1]</span>
<span class="gi">+        m3 = row[2]</span>
<span class="gi">+        top = ((0.99915 * m1 + 1.05122 * m2 + 1.14460 * m3) * sub2)</span>
<span class="gi">+        rbottom = (0.86330 * m3 - 0.17266 * m2)</span>
<span class="gi">+        lbottom = (0.12949 * m3 - 0.38848 * m1)</span>
<span class="gi">+        bottom = (rbottom * sinH + lbottom * cosH) * sub2</span>
<span class="gi">+</span>
<span class="gi">+        for t in (0.0, 1.0):</span>
<span class="gi">+            C = (L * (top - 1.05122 * t) / (bottom + 0.17266 * sinH * t))</span>
<span class="gi">+            if C &gt; 0.0 and C &lt; result:</span>
<span class="gi">+                result = C</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hrad_extremum(L):</span>
<span class="gi">+    lhs = (math.pow(L, 3.0) + 48.0 * math.pow(L, 2.0) + 768.0 * L + 4096.0) / 1560896.0</span>
<span class="gi">+    rhs = 1107.0 / 125000.0</span>
<span class="gi">+    sub = lhs if lhs &gt; rhs else 10.0 * L / 9033.0</span>
<span class="gi">+    chroma = float(&quot;inf&quot;)</span>
<span class="gi">+    result = None</span>
<span class="gi">+    for row in m:</span>
<span class="gi">+        for limit in (0.0, 1.0):</span>
<span class="gi">+            [m1, m2, m3] = row</span>
<span class="gi">+            top = -3015466475.0 * m3 * sub + 603093295.0 * m2 * sub - 603093295.0 * limit</span>
<span class="gi">+            bottom = 1356959916.0 * m1 * sub - 452319972.0 * m3 * sub</span>
<span class="gi">+            hrad = math.atan2(top, bottom)</span>
<span class="gi">+            # This is a math hack to deal with tan quadrants, I&#39;m too lazy to figure</span>
<span class="gi">+            # out how to do this properly</span>
<span class="gi">+            if limit == 0.0:</span>
<span class="gi">+                hrad += math.pi</span>
<span class="gi">+            test = max_chroma(L, math.degrees(hrad))</span>
<span class="gi">+            if test &lt; chroma:</span>
<span class="gi">+                chroma = test</span>
<span class="gi">+                result = hrad</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def max_chroma_pastel(L):</span>
<span class="gi">+    H = math.degrees(_hrad_extremum(L))</span>
<span class="gi">+    return max_chroma(L, H)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dot_product(a, b):</span>
<span class="gi">+    return sum(map(operator.mul, a, b))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def f(t):</span>
<span class="gi">+    if t &gt; lab_e:</span>
<span class="gi">+        return (math.pow(t, 1.0 / 3.0))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (7.787 * t + 16.0 / 116.0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def f_inv(t):</span>
<span class="gi">+    if math.pow(t, 3.0) &gt; lab_e:</span>
<span class="gi">+        return (math.pow(t, 3.0))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (116.0 * t - 16.0) / lab_k</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def from_linear(c):</span>
<span class="gi">+    if c &lt;= 0.0031308:</span>
<span class="gi">+        return 12.92 * c</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (1.055 * math.pow(c, 1.0 / 2.4) - 0.055)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_linear(c):</span>
<span class="gi">+    a = 0.055</span>
<span class="gi">+</span>
<span class="gi">+    if c &gt; 0.04045:</span>
<span class="gi">+        return (math.pow((c + a) / (1.0 + a), 2.4))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (c / 12.92)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_prepare(triple):</span>
<span class="gi">+    ret = []</span>
<span class="gi">+    for ch in triple:</span>
<span class="gi">+        ch = round(ch, 3)</span>
<span class="gi">+</span>
<span class="gi">+        if ch &lt; -0.0001 or ch &gt; 1.0001:</span>
<span class="gi">+            raise Exception(f&quot;Illegal RGB value {ch:f}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if ch &lt; 0:</span>
<span class="gi">+            ch = 0</span>
<span class="gi">+        if ch &gt; 1:</span>
<span class="gi">+            ch = 1</span>
<span class="gi">+</span>
<span class="gi">+        # Fix for Python 3 which by default rounds 4.5 down to 4.0</span>
<span class="gi">+        # instead of Python 2 which is rounded to 5.0 which caused</span>
<span class="gi">+        # a couple off by one errors in the tests. Tests now all pass</span>
<span class="gi">+        # in Python 2 and Python 3</span>
<span class="gi">+        ret.append(int(round(ch * 255 + 0.001, 0)))</span>
<span class="gi">+</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hex_to_rgb(hex):</span>
<span class="gi">+    if hex.startswith(&#39;#&#39;):</span>
<span class="gi">+        hex = hex[1:]</span>
<span class="gi">+    r = int(hex[0:2], 16) / 255.0</span>
<span class="gi">+    g = int(hex[2:4], 16) / 255.0</span>
<span class="gi">+    b = int(hex[4:6], 16) / 255.0</span>
<span class="gi">+    return [r, g, b]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_to_hex(triple):</span>
<span class="gi">+    [r, g, b] = triple</span>
<span class="gi">+    return &#39;#%02x%02x%02x&#39; % tuple(rgb_prepare([r, g, b]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def xyz_to_rgb(triple):</span>
<span class="gi">+    xyz = map(lambda row: dot_product(row, triple), m)</span>
<span class="gi">+    return list(map(from_linear, xyz))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rgb_to_xyz(triple):</span>
<span class="gi">+    rgbl = list(map(to_linear, triple))</span>
<span class="gi">+    return list(map(lambda row: dot_product(row, rgbl), m_inv))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def xyz_to_luv(triple):</span>
<span class="gi">+    X, Y, Z = triple</span>
<span class="gi">+</span>
<span class="gi">+    if X == Y == Z == 0.0:</span>
<span class="gi">+        return [0.0, 0.0, 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    varU = (4.0 * X) / (X + (15.0 * Y) + (3.0 * Z))</span>
<span class="gi">+    varV = (9.0 * Y) / (X + (15.0 * Y) + (3.0 * Z))</span>
<span class="gi">+    L = 116.0 * f(Y / refY) - 16.0</span>
<span class="gi">+</span>
<span class="gi">+    # Black will create a divide-by-zero error</span>
<span class="gi">+    if L == 0.0:</span>
<span class="gi">+        return [0.0, 0.0, 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    U = 13.0 * L * (varU - refU)</span>
<span class="gi">+    V = 13.0 * L * (varV - refV)</span>
<span class="gi">+</span>
<span class="gi">+    return [L, U, V]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def luv_to_xyz(triple):</span>
<span class="gi">+    L, U, V = triple</span>
<span class="gi">+</span>
<span class="gi">+    if L == 0:</span>
<span class="gi">+        return [0.0, 0.0, 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    varY = f_inv((L + 16.0) / 116.0)</span>
<span class="gi">+    varU = U / (13.0 * L) + refU</span>
<span class="gi">+    varV = V / (13.0 * L) + refV</span>
<span class="gi">+    Y = varY * refY</span>
<span class="gi">+    X = 0.0 - (9.0 * Y * varU) / ((varU - 4.0) * varV - varU * varV)</span>
<span class="gi">+    Z = (9.0 * Y - (15.0 * varV * Y) - (varV * X)) / (3.0 * varV)</span>
<span class="gi">+</span>
<span class="gi">+    return [X, Y, Z]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def luv_to_lch(triple):</span>
<span class="gi">+    L, U, V = triple</span>
<span class="gi">+</span>
<span class="gi">+    C = (math.pow(math.pow(U, 2) + math.pow(V, 2), (1.0 / 2.0)))</span>
<span class="gi">+    hrad = (math.atan2(V, U))</span>
<span class="gi">+    H = math.degrees(hrad)</span>
<span class="gi">+    if H &lt; 0.0:</span>
<span class="gi">+        H = 360.0 + H</span>
<span class="gi">+</span>
<span class="gi">+    return [L, C, H]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lch_to_luv(triple):</span>
<span class="gi">+    L, C, H = triple</span>
<span class="gi">+</span>
<span class="gi">+    Hrad = math.radians(H)</span>
<span class="gi">+    U = (math.cos(Hrad) * C)</span>
<span class="gi">+    V = (math.sin(Hrad) * C)</span>
<span class="gi">+</span>
<span class="gi">+    return [L, U, V]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def husl_to_lch(triple):</span>
<span class="gi">+    H, S, L = triple</span>
<span class="gi">+</span>
<span class="gi">+    if L &gt; 99.9999999:</span>
<span class="gi">+        return [100, 0.0, H]</span>
<span class="gi">+    if L &lt; 0.00000001:</span>
<span class="gi">+        return [0.0, 0.0, H]</span>
<span class="gi">+</span>
<span class="gi">+    mx = max_chroma(L, H)</span>
<span class="gi">+    C = mx / 100.0 * S</span>
<span class="gi">+</span>
<span class="gi">+    return [L, C, H]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lch_to_husl(triple):</span>
<span class="gi">+    L, C, H = triple</span>
<span class="gi">+</span>
<span class="gi">+    if L &gt; 99.9999999:</span>
<span class="gi">+        return [H, 0.0, 100.0]</span>
<span class="gi">+    if L &lt; 0.00000001:</span>
<span class="gi">+        return [H, 0.0, 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    mx = max_chroma(L, H)</span>
<span class="gi">+    S = C / mx * 100.0</span>
<span class="gi">+</span>
<span class="gi">+    return [H, S, L]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def huslp_to_lch(triple):</span>
<span class="gi">+    H, S, L = triple</span>
<span class="gi">+</span>
<span class="gi">+    if L &gt; 99.9999999:</span>
<span class="gi">+        return [100, 0.0, H]</span>
<span class="gi">+    if L &lt; 0.00000001:</span>
<span class="gi">+        return [0.0, 0.0, H]</span>
<span class="gi">+</span>
<span class="gi">+    mx = max_chroma_pastel(L)</span>
<span class="gi">+    C = mx / 100.0 * S</span>
<span class="gi">+</span>
<span class="gi">+    return [L, C, H]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lch_to_huslp(triple):</span>
<span class="gi">+    L, C, H = triple</span>
<span class="gi">+</span>
<span class="gi">+    if L &gt; 99.9999999:</span>
<span class="gi">+        return [H, 0.0, 100.0]</span>
<span class="gi">+    if L &lt; 0.00000001:</span>
<span class="gi">+        return [H, 0.0, 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    mx = max_chroma_pastel(L)</span>
<span class="gi">+    S = C / mx * 100.0</span>
<span class="gi">+</span>
<span class="gi">+    return [H, S, L]</span>
<span class="gh">diff --git a/seaborn/external/kde.py b/seaborn/external/kde.py</span>
<span class="gh">index 4765f446..6add4e19 100644</span>
<span class="gd">--- a/seaborn/external/kde.py</span>
<span class="gi">+++ b/seaborn/external/kde.py</span>
<span class="gu">@@ -49,9 +49,32 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="w"> </span>OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# -------------------------------------------------------------------------------</span>
<span class="gi">+#</span>
<span class="gi">+#  Define classes for (uni/multi)-variate kernel density estimation.</span>
<span class="gi">+#</span>
<span class="gi">+#  Currently, only Gaussian kernels are implemented.</span>
<span class="gi">+#</span>
<span class="gi">+#  Written by: Robert Kern</span>
<span class="gi">+#</span>
<span class="gi">+#  Date: 2004-08-09</span>
<span class="gi">+#</span>
<span class="gi">+#  Modified: 2005-02-10 by Robert Kern.</span>
<span class="gi">+#              Contributed to SciPy</span>
<span class="gi">+#            2005-10-07 by Robert Kern.</span>
<span class="gi">+#              Some fixes to match the new scipy_core</span>
<span class="gi">+#</span>
<span class="gi">+#  Copyright 2004-2005 by Enthought, Inc.</span>
<span class="gi">+#</span>
<span class="gi">+# -------------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="gd">-from numpy import asarray, atleast_2d, reshape, zeros, newaxis, dot, exp, pi, sqrt, power, atleast_1d, sum, ones, cov</span>
<span class="gi">+from numpy import (asarray, atleast_2d, reshape, zeros, newaxis, dot, exp, pi,</span>
<span class="gi">+                   sqrt, power, atleast_1d, sum, ones, cov)</span>
<span class="w"> </span>from numpy import linalg
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>__all__ = [&#39;gaussian_kde&#39;]


<span class="gu">@@ -168,20 +191,22 @@ class gaussian_kde:</span>
<span class="w"> </span>           Series A (General), 132, 272

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, dataset, bw_method=None, weights=None):
<span class="w"> </span>        self.dataset = atleast_2d(asarray(dataset))
<span class="w"> </span>        if not self.dataset.size &gt; 1:
<span class="gd">-            raise ValueError(&#39;`dataset` input should have multiple elements.&#39;)</span>
<span class="gi">+            raise ValueError(&quot;`dataset` input should have multiple elements.&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.d, self.n = self.dataset.shape
<span class="gi">+</span>
<span class="w"> </span>        if weights is not None:
<span class="w"> </span>            self._weights = atleast_1d(weights).astype(float)
<span class="w"> </span>            self._weights /= sum(self._weights)
<span class="w"> </span>            if self.weights.ndim != 1:
<span class="gd">-                raise ValueError(&#39;`weights` input should be one-dimensional.&#39;)</span>
<span class="gi">+                raise ValueError(&quot;`weights` input should be one-dimensional.&quot;)</span>
<span class="w"> </span>            if len(self._weights) != self.n:
<span class="gd">-                raise ValueError(&#39;`weights` input should be of length n&#39;)</span>
<span class="gd">-            self._neff = 1 / sum(self._weights ** 2)</span>
<span class="gi">+                raise ValueError(&quot;`weights` input should be of length n&quot;)</span>
<span class="gi">+            self._neff = 1/sum(self._weights**2)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.set_bandwidth(bw_method=bw_method)

<span class="w"> </span>    def evaluate(self, points):
<span class="gu">@@ -204,7 +229,42 @@ class gaussian_kde:</span>
<span class="w"> </span>                     the dimensionality of the KDE.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        points = atleast_2d(asarray(points))</span>
<span class="gi">+</span>
<span class="gi">+        d, m = points.shape</span>
<span class="gi">+        if d != self.d:</span>
<span class="gi">+            if d == 1 and m == self.d:</span>
<span class="gi">+                # points was passed in as a row vector</span>
<span class="gi">+                points = reshape(points, (self.d, 1))</span>
<span class="gi">+                m = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;points have dimension {d}, dataset has dimension {self.d}&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        output_dtype = np.common_type(self.covariance, points)</span>
<span class="gi">+        result = zeros((m,), dtype=output_dtype)</span>
<span class="gi">+</span>
<span class="gi">+        whitening = linalg.cholesky(self.inv_cov)</span>
<span class="gi">+        scaled_dataset = dot(whitening, self.dataset)</span>
<span class="gi">+        scaled_points = dot(whitening, points)</span>
<span class="gi">+</span>
<span class="gi">+        if m &gt;= self.n:</span>
<span class="gi">+            # there are more points than data, so loop over data</span>
<span class="gi">+            for i in range(self.n):</span>
<span class="gi">+                diff = scaled_dataset[:, i, newaxis] - scaled_points</span>
<span class="gi">+                energy = sum(diff * diff, axis=0) / 2.0</span>
<span class="gi">+                result += self.weights[i]*exp(-energy)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # loop over points</span>
<span class="gi">+            for i in range(m):</span>
<span class="gi">+                diff = scaled_dataset - scaled_points[:, i, newaxis]</span>
<span class="gi">+                energy = sum(diff * diff, axis=0) / 2.0</span>
<span class="gi">+                result[i] = sum(exp(-energy)*self.weights, axis=0)</span>
<span class="gi">+</span>
<span class="gi">+        result = result / self._norm_factor</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="w"> </span>    __call__ = evaluate

<span class="w"> </span>    def scotts_factor(self):
<span class="gu">@@ -215,7 +275,7 @@ class gaussian_kde:</span>
<span class="w"> </span>        s : float
<span class="w"> </span>            Scott&#39;s factor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return power(self.neff, -1./(self.d+4))</span>

<span class="w"> </span>    def silverman_factor(self):
<span class="w"> </span>        &quot;&quot;&quot;Compute the Silverman factor.
<span class="gu">@@ -225,7 +285,9 @@ class gaussian_kde:</span>
<span class="w"> </span>        s : float
<span class="w"> </span>            The silverman factor.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return power(self.neff*(self.d+2.0)/4.0, -1./(self.d+4))</span>
<span class="gi">+</span>
<span class="gi">+    #  Default method to calculate bandwidth, can be overwritten by subclass</span>
<span class="w"> </span>    covariance_factor = scotts_factor
<span class="w"> </span>    covariance_factor.__doc__ = &quot;&quot;&quot;Computes the coefficient (`kde.factor`) that
<span class="w"> </span>        multiplies the data covariance matrix to obtain the kernel covariance
<span class="gu">@@ -254,13 +316,40 @@ class gaussian_kde:</span>
<span class="w"> </span>        .. versionadded:: 0.11

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if bw_method is None:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif bw_method == &#39;scott&#39;:</span>
<span class="gi">+            self.covariance_factor = self.scotts_factor</span>
<span class="gi">+        elif bw_method == &#39;silverman&#39;:</span>
<span class="gi">+            self.covariance_factor = self.silverman_factor</span>
<span class="gi">+        elif np.isscalar(bw_method) and not isinstance(bw_method, str):</span>
<span class="gi">+            self._bw_method = &#39;use constant&#39;</span>
<span class="gi">+            self.covariance_factor = lambda: bw_method</span>
<span class="gi">+        elif callable(bw_method):</span>
<span class="gi">+            self._bw_method = bw_method</span>
<span class="gi">+            self.covariance_factor = lambda: self._bw_method(self)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot;`bw_method` should be &#39;scott&#39;, &#39;silverman&#39;, a scalar &quot; \</span>
<span class="gi">+                  &quot;or a callable.&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        self._compute_covariance()</span>

<span class="w"> </span>    def _compute_covariance(self):
<span class="w"> </span>        &quot;&quot;&quot;Computes the covariance matrix for each Gaussian kernel using
<span class="w"> </span>        covariance_factor().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.factor = self.covariance_factor()</span>
<span class="gi">+        # Cache covariance and inverse covariance of the data</span>
<span class="gi">+        if not hasattr(self, &#39;_data_inv_cov&#39;):</span>
<span class="gi">+            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,</span>
<span class="gi">+                                               bias=False,</span>
<span class="gi">+                                               aweights=self.weights))</span>
<span class="gi">+            self._data_inv_cov = linalg.inv(self._data_covariance)</span>
<span class="gi">+</span>
<span class="gi">+        self.covariance = self._data_covariance * self.factor**2</span>
<span class="gi">+        self.inv_cov = self._data_inv_cov / self.factor**2</span>
<span class="gi">+        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance))</span>

<span class="w"> </span>    def pdf(self, x):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -272,4 +361,20 @@ class gaussian_kde:</span>
<span class="w"> </span>        docstring for more details.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.evaluate(x)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def weights(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._weights</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            self._weights = ones(self.n)/self.n</span>
<span class="gi">+            return self._weights</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def neff(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._neff</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            self._neff = 1/sum(self.weights**2)</span>
<span class="gi">+            return self._neff</span>
<span class="gh">diff --git a/seaborn/external/version.py b/seaborn/external/version.py</span>
<span class="gh">index 1dfe1611..7eb57d32 100644</span>
<span class="gd">--- a/seaborn/external/version.py</span>
<span class="gi">+++ b/seaborn/external/version.py</span>
<span class="gu">@@ -14,40 +14,49 @@ Vendored from:</span>
<span class="w"> </span>- https://github.com/pypa/packaging/
<span class="w"> </span>- commit ba07d8287b4554754ac7178d177033ea3f75d489 (09/09/2021)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# This file is dual licensed under the terms of the Apache License, Version</span>
<span class="gi">+# 2.0, and the BSD License. See the LICENSE file in the root of this repository</span>
<span class="gi">+# for complete details.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import itertools
<span class="w"> </span>import re
<span class="w"> </span>from typing import Callable, Optional, SupportsInt, Tuple, Union
<span class="gd">-__all__ = [&#39;Version&#39;, &#39;InvalidVersion&#39;, &#39;VERSION_PATTERN&#39;]</span>

<span class="gi">+__all__ = [&quot;Version&quot;, &quot;InvalidVersion&quot;, &quot;VERSION_PATTERN&quot;]</span>

<span class="gd">-class InfinityType:</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Infinity&#39;</span>
<span class="gi">+# Vendored from https://github.com/pypa/packaging/blob/main/packaging/_structures.py</span>
<span class="gi">+</span>
<span class="gi">+class InfinityType:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Infinity&quot;</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(repr(self))

<span class="gd">-    def __lt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __le__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, self.__class__)

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return not isinstance(other, self.__class__)

<span class="gd">-    def __gt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return True

<span class="gd">-    def __ge__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return True

<span class="gd">-    def __neg__(self: object) -&gt;&#39;NegativeInfinityType&#39;:</span>
<span class="gi">+    def __neg__(self: object) -&gt; &quot;NegativeInfinityType&quot;:</span>
<span class="w"> </span>        return NegativeInfinity


<span class="gu">@@ -55,48 +64,65 @@ Infinity = InfinityType()</span>


<span class="w"> </span>class NegativeInfinityType:
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;-Infinity&quot;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;-Infinity&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(repr(self))

<span class="gd">-    def __lt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return True

<span class="gd">-    def __le__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return True

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, self.__class__)

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return not isinstance(other, self.__class__)

<span class="gd">-    def __gt__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __ge__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __neg__(self: object) -&gt;InfinityType:</span>
<span class="gi">+    def __neg__(self: object) -&gt; InfinityType:</span>
<span class="w"> </span>        return Infinity


<span class="w"> </span>NegativeInfinity = NegativeInfinityType()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Vendored from https://github.com/pypa/packaging/blob/main/packaging/version.py</span>
<span class="gi">+</span>
<span class="w"> </span>InfiniteTypes = Union[InfinityType, NegativeInfinityType]
<span class="w"> </span>PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]
<span class="w"> </span>SubLocalType = Union[InfiniteTypes, int, str]
<span class="gd">-LocalType = Union[NegativeInfinityType, Tuple[Union[SubLocalType, Tuple[</span>
<span class="gd">-    SubLocalType, str], Tuple[NegativeInfinityType, SubLocalType]], ...]]</span>
<span class="gd">-CmpKey = Tuple[int, Tuple[int, ...], PrePostDevType, PrePostDevType,</span>
<span class="gd">-    PrePostDevType, LocalType]</span>
<span class="gi">+LocalType = Union[</span>
<span class="gi">+    NegativeInfinityType,</span>
<span class="gi">+    Tuple[</span>
<span class="gi">+        Union[</span>
<span class="gi">+            SubLocalType,</span>
<span class="gi">+            Tuple[SubLocalType, str],</span>
<span class="gi">+            Tuple[NegativeInfinityType, SubLocalType],</span>
<span class="gi">+        ],</span>
<span class="gi">+        ...,</span>
<span class="gi">+    ],</span>
<span class="gi">+]</span>
<span class="gi">+CmpKey = Tuple[</span>
<span class="gi">+    int, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType</span>
<span class="gi">+]</span>
<span class="w"> </span>LegacyCmpKey = Tuple[int, Tuple[str, ...]]
<span class="gd">-VersionComparisonMethod = Callable[[Union[CmpKey, LegacyCmpKey], Union[</span>
<span class="gd">-    CmpKey, LegacyCmpKey]], bool]</span>
<span class="gd">-_Version = collections.namedtuple(&#39;_Version&#39;, [&#39;epoch&#39;, &#39;release&#39;, &#39;dev&#39;,</span>
<span class="gd">-    &#39;pre&#39;, &#39;post&#39;, &#39;local&#39;])</span>
<span class="gi">+VersionComparisonMethod = Callable[</span>
<span class="gi">+    [Union[CmpKey, LegacyCmpKey], Union[CmpKey, LegacyCmpKey]], bool</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_Version = collections.namedtuple(</span>
<span class="gi">+    &quot;_Version&quot;, [&quot;epoch&quot;, &quot;release&quot;, &quot;dev&quot;, &quot;pre&quot;, &quot;post&quot;, &quot;local&quot;]</span>
<span class="gi">+)</span>
<span class="gi">+</span>


<span class="w"> </span>class InvalidVersion(ValueError):
<span class="gu">@@ -108,116 +134,328 @@ class InvalidVersion(ValueError):</span>
<span class="w"> </span>class _BaseVersion:
<span class="w"> </span>    _key: Union[CmpKey, LegacyCmpKey]

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self._key)

<span class="gd">-    def __lt__(self, other: &#39;_BaseVersion&#39;) -&gt;bool:</span>
<span class="gi">+    # Please keep the duplicated `isinstance` check</span>
<span class="gi">+    # in the six comparisons hereunder</span>
<span class="gi">+    # unless you find a way to avoid adding overhead function calls.</span>
<span class="gi">+    def __lt__(self, other: &quot;_BaseVersion&quot;) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key &lt; other._key

<span class="gd">-    def __le__(self, other: &#39;_BaseVersion&#39;) -&gt;bool:</span>
<span class="gi">+    def __le__(self, other: &quot;_BaseVersion&quot;) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key &lt;= other._key

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key == other._key

<span class="gd">-    def __ge__(self, other: &#39;_BaseVersion&#39;) -&gt;bool:</span>
<span class="gi">+    def __ge__(self, other: &quot;_BaseVersion&quot;) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key &gt;= other._key

<span class="gd">-    def __gt__(self, other: &#39;_BaseVersion&#39;) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: &quot;_BaseVersion&quot;) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key &gt; other._key

<span class="gd">-    def __ne__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _BaseVersion):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return self._key != other._key


<span class="gd">-VERSION_PATTERN = &quot;&quot;&quot;</span>
<span class="gi">+# Deliberately not anchored to the start and end of the string, to make it</span>
<span class="gi">+# easier for 3rd party code to reuse</span>
<span class="gi">+VERSION_PATTERN = r&quot;&quot;&quot;</span>
<span class="w"> </span>    v?
<span class="w"> </span>    (?:
<span class="w"> </span>        (?:(?P&lt;epoch&gt;[0-9]+)!)?                           # epoch
<span class="gd">-        (?P&lt;release&gt;[0-9]+(?:\\.[0-9]+)*)                  # release segment</span>
<span class="gi">+        (?P&lt;release&gt;[0-9]+(?:\.[0-9]+)*)                  # release segment</span>
<span class="w"> </span>        (?P&lt;pre&gt;                                          # pre-release
<span class="gd">-            [-_\\.]?</span>
<span class="gi">+            [-_\.]?</span>
<span class="w"> </span>            (?P&lt;pre_l&gt;(a|b|c|rc|alpha|beta|pre|preview))
<span class="gd">-            [-_\\.]?</span>
<span class="gi">+            [-_\.]?</span>
<span class="w"> </span>            (?P&lt;pre_n&gt;[0-9]+)?
<span class="w"> </span>        )?
<span class="w"> </span>        (?P&lt;post&gt;                                         # post release
<span class="w"> </span>            (?:-(?P&lt;post_n1&gt;[0-9]+))
<span class="w"> </span>            |
<span class="w"> </span>            (?:
<span class="gd">-                [-_\\.]?</span>
<span class="gi">+                [-_\.]?</span>
<span class="w"> </span>                (?P&lt;post_l&gt;post|rev|r)
<span class="gd">-                [-_\\.]?</span>
<span class="gi">+                [-_\.]?</span>
<span class="w"> </span>                (?P&lt;post_n2&gt;[0-9]+)?
<span class="w"> </span>            )
<span class="w"> </span>        )?
<span class="w"> </span>        (?P&lt;dev&gt;                                          # dev release
<span class="gd">-            [-_\\.]?</span>
<span class="gi">+            [-_\.]?</span>
<span class="w"> </span>            (?P&lt;dev_l&gt;dev)
<span class="gd">-            [-_\\.]?</span>
<span class="gi">+            [-_\.]?</span>
<span class="w"> </span>            (?P&lt;dev_n&gt;[0-9]+)?
<span class="w"> </span>        )?
<span class="w"> </span>    )
<span class="gd">-    (?:\\+(?P&lt;local&gt;[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version</span>
<span class="gi">+    (?:\+(?P&lt;local&gt;[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="w"> </span>class Version(_BaseVersion):
<span class="gd">-    _regex = re.compile(&#39;^\\s*&#39; + VERSION_PATTERN + &#39;\\s*$&#39;, re.VERBOSE |</span>
<span class="gd">-        re.IGNORECASE)</span>

<span class="gd">-    def __init__(self, version: str) -&gt;None:</span>
<span class="gi">+    _regex = re.compile(r&quot;^\s*&quot; + VERSION_PATTERN + r&quot;\s*$&quot;, re.VERBOSE | re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, version: str) -&gt; None:</span>
<span class="gi">+</span>
<span class="gi">+        # Validate the version and parse it into pieces</span>
<span class="w"> </span>        match = self._regex.search(version)
<span class="w"> </span>        if not match:
<span class="w"> </span>            raise InvalidVersion(f&quot;Invalid version: &#39;{version}&#39;&quot;)
<span class="gd">-        self._version = _Version(epoch=int(match.group(&#39;epoch&#39;)) if match.</span>
<span class="gd">-            group(&#39;epoch&#39;) else 0, release=tuple(int(i) for i in match.</span>
<span class="gd">-            group(&#39;release&#39;).split(&#39;.&#39;)), pre=_parse_letter_version(match.</span>
<span class="gd">-            group(&#39;pre_l&#39;), match.group(&#39;pre_n&#39;)), post=</span>
<span class="gd">-            _parse_letter_version(match.group(&#39;post_l&#39;), match.group(</span>
<span class="gd">-            &#39;post_n1&#39;) or match.group(&#39;post_n2&#39;)), dev=</span>
<span class="gd">-            _parse_letter_version(match.group(&#39;dev_l&#39;), match.group(&#39;dev_n&#39;</span>
<span class="gd">-            )), local=_parse_local_version(match.group(&#39;local&#39;)))</span>
<span class="gd">-        self._key = _cmpkey(self._version.epoch, self._version.release,</span>
<span class="gd">-            self._version.pre, self._version.post, self._version.dev, self.</span>
<span class="gd">-            _version.local)</span>
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+        # Store the parsed out pieces of the version</span>
<span class="gi">+        self._version = _Version(</span>
<span class="gi">+            epoch=int(match.group(&quot;epoch&quot;)) if match.group(&quot;epoch&quot;) else 0,</span>
<span class="gi">+            release=tuple(int(i) for i in match.group(&quot;release&quot;).split(&quot;.&quot;)),</span>
<span class="gi">+            pre=_parse_letter_version(match.group(&quot;pre_l&quot;), match.group(&quot;pre_n&quot;)),</span>
<span class="gi">+            post=_parse_letter_version(</span>
<span class="gi">+                match.group(&quot;post_l&quot;), match.group(&quot;post_n1&quot;) or match.group(&quot;post_n2&quot;)</span>
<span class="gi">+            ),</span>
<span class="gi">+            dev=_parse_letter_version(match.group(&quot;dev_l&quot;), match.group(&quot;dev_n&quot;)),</span>
<span class="gi">+            local=_parse_local_version(match.group(&quot;local&quot;)),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Generate a key which will be used for sorting</span>
<span class="gi">+        self._key = _cmpkey(</span>
<span class="gi">+            self._version.epoch,</span>
<span class="gi">+            self._version.release,</span>
<span class="gi">+            self._version.pre,</span>
<span class="gi">+            self._version.post,</span>
<span class="gi">+            self._version.dev,</span>
<span class="gi">+            self._version.local,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&quot;&lt;Version(&#39;{self}&#39;)&gt;&quot;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        parts = []
<span class="gi">+</span>
<span class="gi">+        # Epoch</span>
<span class="w"> </span>        if self.epoch != 0:
<span class="gd">-            parts.append(f&#39;{self.epoch}!&#39;)</span>
<span class="gd">-        parts.append(&#39;.&#39;.join(str(x) for x in self.release))</span>
<span class="gi">+            parts.append(f&quot;{self.epoch}!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Release segment</span>
<span class="gi">+        parts.append(&quot;.&quot;.join(str(x) for x in self.release))</span>
<span class="gi">+</span>
<span class="gi">+        # Pre-release</span>
<span class="w"> </span>        if self.pre is not None:
<span class="gd">-            parts.append(&#39;&#39;.join(str(x) for x in self.pre))</span>
<span class="gi">+            parts.append(&quot;&quot;.join(str(x) for x in self.pre))</span>
<span class="gi">+</span>
<span class="gi">+        # Post-release</span>
<span class="w"> </span>        if self.post is not None:
<span class="gd">-            parts.append(f&#39;.post{self.post}&#39;)</span>
<span class="gi">+            parts.append(f&quot;.post{self.post}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Development release</span>
<span class="w"> </span>        if self.dev is not None:
<span class="gd">-            parts.append(f&#39;.dev{self.dev}&#39;)</span>
<span class="gi">+            parts.append(f&quot;.dev{self.dev}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Local version segment</span>
<span class="w"> </span>        if self.local is not None:
<span class="gd">-            parts.append(f&#39;+{self.local}&#39;)</span>
<span class="gd">-        return &#39;&#39;.join(parts)</span>
<span class="gi">+            parts.append(f&quot;+{self.local}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;&quot;.join(parts)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def epoch(self) -&gt; int:</span>
<span class="gi">+        _epoch: int = self._version.epoch</span>
<span class="gi">+        return _epoch</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def release(self) -&gt; Tuple[int, ...]:</span>
<span class="gi">+        _release: Tuple[int, ...] = self._version.release</span>
<span class="gi">+        return _release</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def pre(self) -&gt; Optional[Tuple[str, int]]:</span>
<span class="gi">+        _pre: Optional[Tuple[str, int]] = self._version.pre</span>
<span class="gi">+        return _pre</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def post(self) -&gt; Optional[int]:</span>
<span class="gi">+        return self._version.post[1] if self._version.post else None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def dev(self) -&gt; Optional[int]:</span>
<span class="gi">+        return self._version.dev[1] if self._version.dev else None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def local(self) -&gt; Optional[str]:</span>
<span class="gi">+        if self._version.local:</span>
<span class="gi">+            return &quot;.&quot;.join(str(x) for x in self._version.local)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def public(self) -&gt; str:</span>
<span class="gi">+        return str(self).split(&quot;+&quot;, 1)[0]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def base_version(self) -&gt; str:</span>
<span class="gi">+        parts = []</span>
<span class="gi">+</span>
<span class="gi">+        # Epoch</span>
<span class="gi">+        if self.epoch != 0:</span>
<span class="gi">+            parts.append(f&quot;{self.epoch}!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Release segment</span>
<span class="gi">+        parts.append(&quot;.&quot;.join(str(x) for x in self.release))</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;&quot;.join(parts)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_prerelease(self) -&gt; bool:</span>
<span class="gi">+        return self.dev is not None or self.pre is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_postrelease(self) -&gt; bool:</span>
<span class="gi">+        return self.post is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_devrelease(self) -&gt; bool:</span>
<span class="gi">+        return self.dev is not None</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def major(self) -&gt; int:</span>
<span class="gi">+        return self.release[0] if len(self.release) &gt;= 1 else 0</span>

<span class="gi">+    @property</span>
<span class="gi">+    def minor(self) -&gt; int:</span>
<span class="gi">+        return self.release[1] if len(self.release) &gt;= 2 else 0</span>

<span class="gd">-_local_version_separators = re.compile(&#39;[\\._-]&#39;)</span>
<span class="gi">+    @property</span>
<span class="gi">+    def micro(self) -&gt; int:</span>
<span class="gi">+        return self.release[2] if len(self.release) &gt;= 3 else 0</span>


<span class="gd">-def _parse_local_version(local: str) -&gt;Optional[LocalType]:</span>
<span class="gi">+def _parse_letter_version(</span>
<span class="gi">+    letter: str, number: Union[str, bytes, SupportsInt]</span>
<span class="gi">+) -&gt; Optional[Tuple[str, int]]:</span>
<span class="gi">+</span>
<span class="gi">+    if letter:</span>
<span class="gi">+        # We consider there to be an implicit 0 in a pre-release if there is</span>
<span class="gi">+        # not a numeral associated with it.</span>
<span class="gi">+        if number is None:</span>
<span class="gi">+            number = 0</span>
<span class="gi">+</span>
<span class="gi">+        # We normalize any letters to their lower case form</span>
<span class="gi">+        letter = letter.lower()</span>
<span class="gi">+</span>
<span class="gi">+        # We consider some words to be alternate spellings of other words and</span>
<span class="gi">+        # in those cases we want to normalize the spellings to our preferred</span>
<span class="gi">+        # spelling.</span>
<span class="gi">+        if letter == &quot;alpha&quot;:</span>
<span class="gi">+            letter = &quot;a&quot;</span>
<span class="gi">+        elif letter == &quot;beta&quot;:</span>
<span class="gi">+            letter = &quot;b&quot;</span>
<span class="gi">+        elif letter in [&quot;c&quot;, &quot;pre&quot;, &quot;preview&quot;]:</span>
<span class="gi">+            letter = &quot;rc&quot;</span>
<span class="gi">+        elif letter in [&quot;rev&quot;, &quot;r&quot;]:</span>
<span class="gi">+            letter = &quot;post&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return letter, int(number)</span>
<span class="gi">+    if not letter and number:</span>
<span class="gi">+        # We assume if we are given a number, but we are not given a letter</span>
<span class="gi">+        # then this is using the implicit post release syntax (e.g. 1.0-1)</span>
<span class="gi">+        letter = &quot;post&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return letter, int(number)</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_local_version_separators = re.compile(r&quot;[\._-]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_local_version(local: str) -&gt; Optional[LocalType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Takes a string like abc.1.twelve and turns it into (&quot;abc&quot;, 1, &quot;twelve&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if local is not None:</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            part.lower() if not part.isdigit() else int(part)</span>
<span class="gi">+            for part in _local_version_separators.split(local)</span>
<span class="gi">+        )</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _cmpkey(</span>
<span class="gi">+    epoch: int,</span>
<span class="gi">+    release: Tuple[int, ...],</span>
<span class="gi">+    pre: Optional[Tuple[str, int]],</span>
<span class="gi">+    post: Optional[Tuple[str, int]],</span>
<span class="gi">+    dev: Optional[Tuple[str, int]],</span>
<span class="gi">+    local: Optional[Tuple[SubLocalType]],</span>
<span class="gi">+) -&gt; CmpKey:</span>
<span class="gi">+</span>
<span class="gi">+    # When we compare a release version, we want to compare it with all of the</span>
<span class="gi">+    # trailing zeros removed. So we&#39;ll use a reverse the list, drop all the now</span>
<span class="gi">+    # leading zeros until we come to something non zero, then take the rest</span>
<span class="gi">+    # re-reverse it back into the correct order and make it a tuple and use</span>
<span class="gi">+    # that for our sorting key.</span>
<span class="gi">+    _release = tuple(</span>
<span class="gi">+        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # We need to &quot;trick&quot; the sorting algorithm to put 1.0.dev0 before 1.0a0.</span>
<span class="gi">+    # We&#39;ll do this by abusing the pre segment, but we _only_ want to do this</span>
<span class="gi">+    # if there is not a pre or a post segment. If we have one of those then</span>
<span class="gi">+    # the normal sorting rules will handle this case correctly.</span>
<span class="gi">+    if pre is None and post is None and dev is not None:</span>
<span class="gi">+        _pre: PrePostDevType = NegativeInfinity</span>
<span class="gi">+    # Versions without a pre-release (except as noted above) should sort after</span>
<span class="gi">+    # those with one.</span>
<span class="gi">+    elif pre is None:</span>
<span class="gi">+        _pre = Infinity</span>
<span class="gi">+    else:</span>
<span class="gi">+        _pre = pre</span>
<span class="gi">+</span>
<span class="gi">+    # Versions without a post segment should sort before those with one.</span>
<span class="gi">+    if post is None:</span>
<span class="gi">+        _post: PrePostDevType = NegativeInfinity</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        _post = post</span>
<span class="gi">+</span>
<span class="gi">+    # Versions without a development segment should sort after those with one.</span>
<span class="gi">+    if dev is None:</span>
<span class="gi">+        _dev: PrePostDevType = Infinity</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        _dev = dev</span>
<span class="gi">+</span>
<span class="gi">+    if local is None:</span>
<span class="gi">+        # Versions without a local segment should sort before those with one.</span>
<span class="gi">+        _local: LocalType = NegativeInfinity</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Versions with a local segment need that segment parsed to implement</span>
<span class="gi">+        # the sorting rules in PEP440.</span>
<span class="gi">+        # - Alpha numeric segments sort before numeric segments</span>
<span class="gi">+        # - Alpha numeric segments sort lexicographically</span>
<span class="gi">+        # - Numeric segments sort numerically</span>
<span class="gi">+        # - Shorter versions sort before longer versions when the prefixes</span>
<span class="gi">+        #   match exactly</span>
<span class="gi">+        _local = tuple(</span>
<span class="gi">+            (i, &quot;&quot;) if isinstance(i, int) else (NegativeInfinity, i) for i in local</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return epoch, _release, _pre, _post, _dev, _local</span>
<span class="gh">diff --git a/seaborn/matrix.py b/seaborn/matrix.py</span>
<span class="gh">index c8e407f8..6b99c118 100644</span>
<span class="gd">--- a/seaborn/matrix.py</span>
<span class="gi">+++ b/seaborn/matrix.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions to visualize matrices of data.&quot;&quot;&quot;
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from matplotlib.collections import LineCollection
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="gu">@@ -11,26 +12,49 @@ try:</span>
<span class="w"> </span>    _no_scipy = False
<span class="w"> </span>except ImportError:
<span class="w"> </span>    _no_scipy = True
<span class="gi">+</span>
<span class="w"> </span>from . import cm
<span class="w"> </span>from .axisgrid import Grid
<span class="w"> </span>from ._compat import get_colormap
<span class="gd">-from .utils import despine, axis_ticklabels_overlap, relative_luminance, to_utf8, _draw_figure</span>
<span class="gd">-__all__ = [&#39;heatmap&#39;, &#39;clustermap&#39;]</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    despine,</span>
<span class="gi">+    axis_ticklabels_overlap,</span>
<span class="gi">+    relative_luminance,</span>
<span class="gi">+    to_utf8,</span>
<span class="gi">+    _draw_figure,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;heatmap&quot;, &quot;clustermap&quot;]</span>


<span class="w"> </span>def _index_to_label(index):
<span class="w"> </span>    &quot;&quot;&quot;Convert a pandas index or multiindex to an axis label.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(index, pd.MultiIndex):</span>
<span class="gi">+        return &quot;-&quot;.join(map(to_utf8, index.names))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return index.name</span>


<span class="w"> </span>def _index_to_ticklabels(index):
<span class="w"> </span>    &quot;&quot;&quot;Convert a pandas index or multiindex into ticklabels.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(index, pd.MultiIndex):</span>
<span class="gi">+        return [&quot;-&quot;.join(map(to_utf8, i)) for i in index.values]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return index.values</span>


<span class="w"> </span>def _convert_colors(colors):
<span class="w"> </span>    &quot;&quot;&quot;Convert either a list of colors or nested lists of colors to RGB.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    to_rgb = mpl.colors.to_rgb</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        to_rgb(colors[0])</span>
<span class="gi">+        # If this works, there is only one level of colors</span>
<span class="gi">+        return list(map(to_rgb, colors))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # If we get here, we have nested lists</span>
<span class="gi">+        return [list(map(to_rgb, color_list)) for color_list in colors]</span>


<span class="w"> </span>def _matrix_mask(data, mask):
<span class="gu">@@ -42,23 +66,55 @@ def _matrix_mask(data, mask):</span>
<span class="w"> </span>    a DataFrame.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mask is None:</span>
<span class="gi">+        mask = np.zeros(data.shape, bool)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(mask, np.ndarray):</span>
<span class="gi">+        # For array masks, ensure that shape matches data then convert</span>
<span class="gi">+        if mask.shape != data.shape:</span>
<span class="gi">+            raise ValueError(&quot;Mask must have the same shape as data.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        mask = pd.DataFrame(mask,</span>
<span class="gi">+                            index=data.index,</span>
<span class="gi">+                            columns=data.columns,</span>
<span class="gi">+                            dtype=bool)</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(mask, pd.DataFrame):</span>
<span class="gi">+        # For DataFrame masks, ensure that semantic labels match data</span>
<span class="gi">+        if not mask.index.equals(data.index) \</span>
<span class="gi">+           and mask.columns.equals(data.columns):</span>
<span class="gi">+            err = &quot;Mask must have the same index and columns as data.&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+    # Add any cells with missing data to the mask</span>
<span class="gi">+    # This works around an issue where `plt.pcolormesh` doesn&#39;t represent</span>
<span class="gi">+    # missing data properly</span>
<span class="gi">+    mask = mask | pd.isnull(data)</span>
<span class="gi">+</span>
<span class="gi">+    return mask</span>


<span class="w"> </span>class _HeatMapper:
<span class="w"> </span>    &quot;&quot;&quot;Draw a heatmap plot of a matrix with nice labels and colormaps.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,
<span class="gd">-        annot_kws, cbar, cbar_kws, xticklabels=True, yticklabels=True, mask</span>
<span class="gd">-        =None):</span>
<span class="gi">+                 annot_kws, cbar, cbar_kws,</span>
<span class="gi">+                 xticklabels=True, yticklabels=True, mask=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the plotting object.&quot;&quot;&quot;
<span class="gi">+        # We always want to have a DataFrame with semantic information</span>
<span class="gi">+        # and an ndarray to pass to matplotlib</span>
<span class="w"> </span>        if isinstance(data, pd.DataFrame):
<span class="w"> </span>            plot_data = data.values
<span class="w"> </span>        else:
<span class="w"> </span>            plot_data = np.asarray(data)
<span class="w"> </span>            data = pd.DataFrame(plot_data)
<span class="gi">+</span>
<span class="gi">+        # Validate the mask and convert to DataFrame</span>
<span class="w"> </span>        mask = _matrix_mask(data, mask)
<span class="gi">+</span>
<span class="w"> </span>        plot_data = np.ma.masked_where(np.asarray(mask), plot_data)
<span class="gi">+</span>
<span class="gi">+        # Get good names for the rows and columns</span>
<span class="w"> </span>        xtickevery = 1
<span class="w"> </span>        if isinstance(xticklabels, int):
<span class="w"> </span>            xtickevery = xticklabels
<span class="gu">@@ -67,6 +123,7 @@ class _HeatMapper:</span>
<span class="w"> </span>            xticklabels = _index_to_ticklabels(data.columns)
<span class="w"> </span>        elif xticklabels is False:
<span class="w"> </span>            xticklabels = []
<span class="gi">+</span>
<span class="w"> </span>        ytickevery = 1
<span class="w"> </span>        if isinstance(yticklabels, int):
<span class="w"> </span>            ytickevery = yticklabels
<span class="gu">@@ -75,30 +132,38 @@ class _HeatMapper:</span>
<span class="w"> </span>            yticklabels = _index_to_ticklabels(data.index)
<span class="w"> </span>        elif yticklabels is False:
<span class="w"> </span>            yticklabels = []
<span class="gi">+</span>
<span class="w"> </span>        if not len(xticklabels):
<span class="w"> </span>            self.xticks = []
<span class="w"> </span>            self.xticklabels = []
<span class="gd">-        elif isinstance(xticklabels, str) and xticklabels == &#39;auto&#39;:</span>
<span class="gd">-            self.xticks = &#39;auto&#39;</span>
<span class="gi">+        elif isinstance(xticklabels, str) and xticklabels == &quot;auto&quot;:</span>
<span class="gi">+            self.xticks = &quot;auto&quot;</span>
<span class="w"> </span>            self.xticklabels = _index_to_ticklabels(data.columns)
<span class="w"> </span>        else:
<span class="w"> </span>            self.xticks, self.xticklabels = self._skip_ticks(xticklabels,
<span class="gd">-                xtickevery)</span>
<span class="gi">+                                                             xtickevery)</span>
<span class="gi">+</span>
<span class="w"> </span>        if not len(yticklabels):
<span class="w"> </span>            self.yticks = []
<span class="w"> </span>            self.yticklabels = []
<span class="gd">-        elif isinstance(yticklabels, str) and yticklabels == &#39;auto&#39;:</span>
<span class="gd">-            self.yticks = &#39;auto&#39;</span>
<span class="gi">+        elif isinstance(yticklabels, str) and yticklabels == &quot;auto&quot;:</span>
<span class="gi">+            self.yticks = &quot;auto&quot;</span>
<span class="w"> </span>            self.yticklabels = _index_to_ticklabels(data.index)
<span class="w"> </span>        else:
<span class="w"> </span>            self.yticks, self.yticklabels = self._skip_ticks(yticklabels,
<span class="gd">-                ytickevery)</span>
<span class="gi">+                                                             ytickevery)</span>
<span class="gi">+</span>
<span class="gi">+        # Get good names for the axis labels</span>
<span class="w"> </span>        xlabel = _index_to_label(data.columns)
<span class="w"> </span>        ylabel = _index_to_label(data.index)
<span class="gd">-        self.xlabel = xlabel if xlabel is not None else &#39;&#39;</span>
<span class="gd">-        self.ylabel = ylabel if ylabel is not None else &#39;&#39;</span>
<span class="gd">-        self._determine_cmap_params(plot_data, vmin, vmax, cmap, center, robust</span>
<span class="gd">-            )</span>
<span class="gi">+        self.xlabel = xlabel if xlabel is not None else &quot;&quot;</span>
<span class="gi">+        self.ylabel = ylabel if ylabel is not None else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Determine good default values for the colormapping</span>
<span class="gi">+        self._determine_cmap_params(plot_data, vmin, vmax,</span>
<span class="gi">+                                    cmap, center, robust)</span>
<span class="gi">+</span>
<span class="gi">+        # Sort out the annotations</span>
<span class="w"> </span>        if annot is None or annot is False:
<span class="w"> </span>            annot = False
<span class="w"> </span>            annot_data = None
<span class="gu">@@ -108,44 +173,195 @@ class _HeatMapper:</span>
<span class="w"> </span>            else:
<span class="w"> </span>                annot_data = np.asarray(annot)
<span class="w"> </span>                if annot_data.shape != plot_data.shape:
<span class="gd">-                    err = &#39;`data` and `annot` must have same shape.&#39;</span>
<span class="gi">+                    err = &quot;`data` and `annot` must have same shape.&quot;</span>
<span class="w"> </span>                    raise ValueError(err)
<span class="w"> </span>            annot = True
<span class="gi">+</span>
<span class="gi">+        # Save other attributes to the object</span>
<span class="w"> </span>        self.data = data
<span class="w"> </span>        self.plot_data = plot_data
<span class="gi">+</span>
<span class="w"> </span>        self.annot = annot
<span class="w"> </span>        self.annot_data = annot_data
<span class="gi">+</span>
<span class="w"> </span>        self.fmt = fmt
<span class="w"> </span>        self.annot_kws = {} if annot_kws is None else annot_kws.copy()
<span class="w"> </span>        self.cbar = cbar
<span class="w"> </span>        self.cbar_kws = {} if cbar_kws is None else cbar_kws.copy()

<span class="gd">-    def _determine_cmap_params(self, plot_data, vmin, vmax, cmap, center,</span>
<span class="gd">-        robust):</span>
<span class="gi">+    def _determine_cmap_params(self, plot_data, vmin, vmax,</span>
<span class="gi">+                               cmap, center, robust):</span>
<span class="w"> </span>        &quot;&quot;&quot;Use some heuristics to set good defaults for colorbar and range.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # plot_data is a np.ma.array instance</span>
<span class="gi">+        calc_data = plot_data.astype(float).filled(np.nan)</span>
<span class="gi">+        if vmin is None:</span>
<span class="gi">+            if robust:</span>
<span class="gi">+                vmin = np.nanpercentile(calc_data, 2)</span>
<span class="gi">+            else:</span>
<span class="gi">+                vmin = np.nanmin(calc_data)</span>
<span class="gi">+        if vmax is None:</span>
<span class="gi">+            if robust:</span>
<span class="gi">+                vmax = np.nanpercentile(calc_data, 98)</span>
<span class="gi">+            else:</span>
<span class="gi">+                vmax = np.nanmax(calc_data)</span>
<span class="gi">+        self.vmin, self.vmax = vmin, vmax</span>
<span class="gi">+</span>
<span class="gi">+        # Choose default colormaps if not provided</span>
<span class="gi">+        if cmap is None:</span>
<span class="gi">+            if center is None:</span>
<span class="gi">+                self.cmap = cm.rocket</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.cmap = cm.icefire</span>
<span class="gi">+        elif isinstance(cmap, str):</span>
<span class="gi">+            self.cmap = get_colormap(cmap)</span>
<span class="gi">+        elif isinstance(cmap, list):</span>
<span class="gi">+            self.cmap = mpl.colors.ListedColormap(cmap)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.cmap = cmap</span>
<span class="gi">+</span>
<span class="gi">+        # Recenter a divergent colormap</span>
<span class="gi">+        if center is not None:</span>
<span class="gi">+</span>
<span class="gi">+            # Copy bad values</span>
<span class="gi">+            # in mpl&lt;3.2 only masked values are honored with &quot;bad&quot; color spec</span>
<span class="gi">+            # (see https://github.com/matplotlib/matplotlib/pull/14257)</span>
<span class="gi">+            bad = self.cmap(np.ma.masked_invalid([np.nan]))[0]</span>
<span class="gi">+</span>
<span class="gi">+            # under/over values are set for sure when cmap extremes</span>
<span class="gi">+            # do not map to the same color as +-inf</span>
<span class="gi">+            under = self.cmap(-np.inf)</span>
<span class="gi">+            over = self.cmap(np.inf)</span>
<span class="gi">+            under_set = under != self.cmap(0)</span>
<span class="gi">+            over_set = over != self.cmap(self.cmap.N - 1)</span>
<span class="gi">+</span>
<span class="gi">+            vrange = max(vmax - center, center - vmin)</span>
<span class="gi">+            normlize = mpl.colors.Normalize(center - vrange, center + vrange)</span>
<span class="gi">+            cmin, cmax = normlize([vmin, vmax])</span>
<span class="gi">+            cc = np.linspace(cmin, cmax, 256)</span>
<span class="gi">+            self.cmap = mpl.colors.ListedColormap(self.cmap(cc))</span>
<span class="gi">+            self.cmap.set_bad(bad)</span>
<span class="gi">+            if under_set:</span>
<span class="gi">+                self.cmap.set_under(under)</span>
<span class="gi">+            if over_set:</span>
<span class="gi">+                self.cmap.set_over(over)</span>

<span class="w"> </span>    def _annotate_heatmap(self, ax, mesh):
<span class="w"> </span>        &quot;&quot;&quot;Add textual labels with the value in each cell.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mesh.update_scalarmappable()</span>
<span class="gi">+        height, width = self.annot_data.shape</span>
<span class="gi">+        xpos, ypos = np.meshgrid(np.arange(width) + .5, np.arange(height) + .5)</span>
<span class="gi">+        for x, y, m, color, val in zip(xpos.flat, ypos.flat,</span>
<span class="gi">+                                       mesh.get_array().flat, mesh.get_facecolors(),</span>
<span class="gi">+                                       self.annot_data.flat):</span>
<span class="gi">+            if m is not np.ma.masked:</span>
<span class="gi">+                lum = relative_luminance(color)</span>
<span class="gi">+                text_color = &quot;.15&quot; if lum &gt; .408 else &quot;w&quot;</span>
<span class="gi">+                annotation = (&quot;{:&quot; + self.fmt + &quot;}&quot;).format(val)</span>
<span class="gi">+                text_kwargs = dict(color=text_color, ha=&quot;center&quot;, va=&quot;center&quot;)</span>
<span class="gi">+                text_kwargs.update(self.annot_kws)</span>
<span class="gi">+                ax.text(x, y, annotation, **text_kwargs)</span>

<span class="w"> </span>    def _skip_ticks(self, labels, tickevery):
<span class="w"> </span>        &quot;&quot;&quot;Return ticks and labels at evenly spaced intervals.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        n = len(labels)</span>
<span class="gi">+        if tickevery == 0:</span>
<span class="gi">+            ticks, labels = [], []</span>
<span class="gi">+        elif tickevery == 1:</span>
<span class="gi">+            ticks, labels = np.arange(n) + .5, labels</span>
<span class="gi">+        else:</span>
<span class="gi">+            start, end, step = 0, n, tickevery</span>
<span class="gi">+            ticks = np.arange(start, end, step) + .5</span>
<span class="gi">+            labels = labels[start:end:step]</span>
<span class="gi">+        return ticks, labels</span>

<span class="w"> </span>    def _auto_ticks(self, ax, labels, axis):
<span class="w"> </span>        &quot;&quot;&quot;Determine ticks and ticklabels that minimize overlap.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        transform = ax.figure.dpi_scale_trans.inverted()</span>
<span class="gi">+        bbox = ax.get_window_extent().transformed(transform)</span>
<span class="gi">+        size = [bbox.width, bbox.height][axis]</span>
<span class="gi">+        axis = [ax.xaxis, ax.yaxis][axis]</span>
<span class="gi">+        tick, = axis.set_ticks([0])</span>
<span class="gi">+        fontsize = tick.label1.get_size()</span>
<span class="gi">+        max_ticks = int(size // (fontsize / 72))</span>
<span class="gi">+        if max_ticks &lt; 1:</span>
<span class="gi">+            return [], []</span>
<span class="gi">+        tick_every = len(labels) // max_ticks + 1</span>
<span class="gi">+        tick_every = 1 if tick_every == 0 else tick_every</span>
<span class="gi">+        ticks, labels = self._skip_ticks(labels, tick_every)</span>
<span class="gi">+        return ticks, labels</span>

<span class="w"> </span>    def plot(self, ax, cax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the heatmap on the provided Axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        # Remove all the Axes spines</span>
<span class="gi">+        despine(ax=ax, left=True, bottom=True)</span>
<span class="gi">+</span>
<span class="gi">+        # setting vmin/vmax in addition to norm is deprecated</span>
<span class="gi">+        # so avoid setting if norm is set</span>
<span class="gi">+        if kws.get(&quot;norm&quot;) is None:</span>
<span class="gi">+            kws.setdefault(&quot;vmin&quot;, self.vmin)</span>
<span class="gi">+            kws.setdefault(&quot;vmax&quot;, self.vmax)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the heatmap</span>
<span class="gi">+        mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the axis limits</span>
<span class="gi">+        ax.set(xlim=(0, self.data.shape[1]), ylim=(0, self.data.shape[0]))</span>
<span class="gi">+</span>
<span class="gi">+        # Invert the y axis to show the plot in matrix form</span>
<span class="gi">+        ax.invert_yaxis()</span>
<span class="gi">+</span>
<span class="gi">+        # Possibly add a colorbar</span>
<span class="gi">+        if self.cbar:</span>
<span class="gi">+            cb = ax.figure.colorbar(mesh, cax, ax, **self.cbar_kws)</span>
<span class="gi">+            cb.outline.set_linewidth(0)</span>
<span class="gi">+            # If rasterized is passed to pcolormesh, also rasterize the</span>
<span class="gi">+            # colorbar to avoid white lines on the PDF rendering</span>
<span class="gi">+            if kws.get(&#39;rasterized&#39;, False):</span>
<span class="gi">+                cb.solids.set_rasterized(True)</span>
<span class="gi">+</span>
<span class="gi">+        # Add row and column labels</span>
<span class="gi">+        if isinstance(self.xticks, str) and self.xticks == &quot;auto&quot;:</span>
<span class="gi">+            xticks, xticklabels = self._auto_ticks(ax, self.xticklabels, 0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            xticks, xticklabels = self.xticks, self.xticklabels</span>

<span class="gd">-def heatmap(data, *, vmin=None, vmax=None, cmap=None, center=None, robust=</span>
<span class="gd">-    False, annot=None, fmt=&#39;.2g&#39;, annot_kws=None, linewidths=0, linecolor=</span>
<span class="gd">-    &#39;white&#39;, cbar=True, cbar_kws=None, cbar_ax=None, square=False,</span>
<span class="gd">-    xticklabels=&#39;auto&#39;, yticklabels=&#39;auto&#39;, mask=None, ax=None, **kwargs):</span>
<span class="gi">+        if isinstance(self.yticks, str) and self.yticks == &quot;auto&quot;:</span>
<span class="gi">+            yticks, yticklabels = self._auto_ticks(ax, self.yticklabels, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yticks, yticklabels = self.yticks, self.yticklabels</span>
<span class="gi">+</span>
<span class="gi">+        ax.set(xticks=xticks, yticks=yticks)</span>
<span class="gi">+        xtl = ax.set_xticklabels(xticklabels)</span>
<span class="gi">+        ytl = ax.set_yticklabels(yticklabels, rotation=&quot;vertical&quot;)</span>
<span class="gi">+        plt.setp(ytl, va=&quot;center&quot;)  # GH2484</span>
<span class="gi">+</span>
<span class="gi">+        # Possibly rotate them if they overlap</span>
<span class="gi">+        _draw_figure(ax.figure)</span>
<span class="gi">+</span>
<span class="gi">+        if axis_ticklabels_overlap(xtl):</span>
<span class="gi">+            plt.setp(xtl, rotation=&quot;vertical&quot;)</span>
<span class="gi">+        if axis_ticklabels_overlap(ytl):</span>
<span class="gi">+            plt.setp(ytl, rotation=&quot;horizontal&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Add the axis labels</span>
<span class="gi">+        ax.set(xlabel=self.xlabel, ylabel=self.ylabel)</span>
<span class="gi">+</span>
<span class="gi">+        # Annotate the cells with the formatted values</span>
<span class="gi">+        if self.annot:</span>
<span class="gi">+            self._annotate_heatmap(ax, mesh)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def heatmap(</span>
<span class="gi">+    data, *,</span>
<span class="gi">+    vmin=None, vmax=None, cmap=None, center=None, robust=False,</span>
<span class="gi">+    annot=None, fmt=&quot;.2g&quot;, annot_kws=None,</span>
<span class="gi">+    linewidths=0, linecolor=&quot;white&quot;,</span>
<span class="gi">+    cbar=True, cbar_kws=None, cbar_ax=None,</span>
<span class="gi">+    square=False, xticklabels=&quot;auto&quot;, yticklabels=&quot;auto&quot;,</span>
<span class="gi">+    mask=None, ax=None,</span>
<span class="gi">+    **kwargs</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Plot rectangular data as a color-encoded matrix.

<span class="w"> </span>    This is an Axes-level function and will draw the heatmap into the
<span class="gu">@@ -226,7 +442,22 @@ def heatmap(data, *, vmin=None, vmax=None, cmap=None, center=None, robust=</span>
<span class="w"> </span>    .. include:: ../docstrings/heatmap.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Initialize the plotter object</span>
<span class="gi">+    plotter = _HeatMapper(data, vmin, vmax, cmap, center, robust, annot, fmt,</span>
<span class="gi">+                          annot_kws, cbar, cbar_kws, xticklabels,</span>
<span class="gi">+                          yticklabels, mask)</span>
<span class="gi">+</span>
<span class="gi">+    # Add the pcolormesh kwargs here</span>
<span class="gi">+    kwargs[&quot;linewidths&quot;] = linewidths</span>
<span class="gi">+    kwargs[&quot;edgecolor&quot;] = linecolor</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the plot and return the Axes</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+    if square:</span>
<span class="gi">+        ax.set_aspect(&quot;equal&quot;)</span>
<span class="gi">+    plotter.plot(ax, cbar_ax, kwargs)</span>
<span class="gi">+    return ax</span>


<span class="w"> </span>class _DendrogramPlotter:
<span class="gu">@@ -243,25 +474,32 @@ class _DendrogramPlotter:</span>
<span class="w"> </span>        self.axis = axis
<span class="w"> </span>        if self.axis == 1:
<span class="w"> </span>            data = data.T
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(data, pd.DataFrame):
<span class="w"> </span>            array = data.values
<span class="w"> </span>        else:
<span class="w"> </span>            array = np.asarray(data)
<span class="w"> </span>            data = pd.DataFrame(array)
<span class="gi">+</span>
<span class="w"> </span>        self.array = array
<span class="w"> </span>        self.data = data
<span class="gi">+</span>
<span class="w"> </span>        self.shape = self.data.shape
<span class="w"> </span>        self.metric = metric
<span class="w"> </span>        self.method = method
<span class="w"> </span>        self.axis = axis
<span class="w"> </span>        self.label = label
<span class="w"> </span>        self.rotate = rotate
<span class="gi">+</span>
<span class="w"> </span>        if linkage is None:
<span class="w"> </span>            self.linkage = self.calculated_linkage
<span class="w"> </span>        else:
<span class="w"> </span>            self.linkage = linkage
<span class="w"> </span>        self.dendrogram = self.calculate_dendrogram()
<span class="gi">+</span>
<span class="gi">+        # Dendrogram ends are always at multiples of 5, who knows why</span>
<span class="w"> </span>        ticks = 10 * np.arange(self.data.shape[0]) + 5
<span class="gi">+</span>
<span class="w"> </span>        if self.label:
<span class="w"> </span>            ticklabels = _index_to_ticklabels(self.data.index)
<span class="w"> </span>            ticklabels = [ticklabels[i] for i in self.reordered_ind]
<span class="gu">@@ -269,6 +507,7 @@ class _DendrogramPlotter:</span>
<span class="w"> </span>                self.xticks = []
<span class="w"> </span>                self.yticks = ticks
<span class="w"> </span>                self.xticklabels = []
<span class="gi">+</span>
<span class="w"> </span>                self.yticklabels = ticklabels
<span class="w"> </span>                self.ylabel = _index_to_label(self.data.index)
<span class="w"> </span>                self.xlabel = &#39;&#39;
<span class="gu">@@ -283,9 +522,45 @@ class _DendrogramPlotter:</span>
<span class="w"> </span>            self.xticks, self.yticks = [], []
<span class="w"> </span>            self.yticklabels, self.xticklabels = [], []
<span class="w"> </span>            self.xlabel, self.ylabel = &#39;&#39;, &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>        self.dependent_coord = self.dendrogram[&#39;dcoord&#39;]
<span class="w"> </span>        self.independent_coord = self.dendrogram[&#39;icoord&#39;]

<span class="gi">+    def _calculate_linkage_scipy(self):</span>
<span class="gi">+        linkage = hierarchy.linkage(self.array, method=self.method,</span>
<span class="gi">+                                    metric=self.metric)</span>
<span class="gi">+        return linkage</span>
<span class="gi">+</span>
<span class="gi">+    def _calculate_linkage_fastcluster(self):</span>
<span class="gi">+        import fastcluster</span>
<span class="gi">+        # Fastcluster has a memory-saving vectorized version, but only</span>
<span class="gi">+        # with certain linkage methods, and mostly with euclidean metric</span>
<span class="gi">+        # vector_methods = (&#39;single&#39;, &#39;centroid&#39;, &#39;median&#39;, &#39;ward&#39;)</span>
<span class="gi">+        euclidean_methods = (&#39;centroid&#39;, &#39;median&#39;, &#39;ward&#39;)</span>
<span class="gi">+        euclidean = self.metric == &#39;euclidean&#39; and self.method in \</span>
<span class="gi">+            euclidean_methods</span>
<span class="gi">+        if euclidean or self.method == &#39;single&#39;:</span>
<span class="gi">+            return fastcluster.linkage_vector(self.array,</span>
<span class="gi">+                                              method=self.method,</span>
<span class="gi">+                                              metric=self.metric)</span>
<span class="gi">+        else:</span>
<span class="gi">+            linkage = fastcluster.linkage(self.array, method=self.method,</span>
<span class="gi">+                                          metric=self.metric)</span>
<span class="gi">+            return linkage</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def calculated_linkage(self):</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._calculate_linkage_fastcluster()</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            if np.prod(self.shape) &gt;= 10000:</span>
<span class="gi">+                msg = (&quot;Clustering large matrix with scipy. Installing &quot;</span>
<span class="gi">+                       &quot;`fastcluster` may give better performance.&quot;)</span>
<span class="gi">+                warnings.warn(msg)</span>
<span class="gi">+</span>
<span class="gi">+        return self._calculate_linkage_scipy()</span>
<span class="gi">+</span>
<span class="w"> </span>    def calculate_dendrogram(self):
<span class="w"> </span>        &quot;&quot;&quot;Calculates a dendrogram based on the linkage matrix

<span class="gu">@@ -299,12 +574,13 @@ class _DendrogramPlotter:</span>
<span class="w"> </span>            .dendrogram. The important key-value pairing is
<span class="w"> </span>            &quot;reordered_ind&quot; which indicates the re-ordering of the matrix
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return hierarchy.dendrogram(self.linkage, no_plot=True,</span>
<span class="gi">+                                    color_threshold=-np.inf)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def reordered_ind(self):
<span class="w"> </span>        &quot;&quot;&quot;Indices of the matrix, reordered by the dendrogram&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.dendrogram[&#39;leaves&#39;]</span>

<span class="w"> </span>    def plot(self, ax, tree_kws):
<span class="w"> </span>        &quot;&quot;&quot;Plots a dendrogram of the similarities between data on the axes
<span class="gu">@@ -315,11 +591,59 @@ class _DendrogramPlotter:</span>
<span class="w"> </span>            Axes object upon which the dendrogram is plotted

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tree_kws = {} if tree_kws is None else tree_kws.copy()</span>
<span class="gi">+        tree_kws.setdefault(&quot;linewidths&quot;, .5)</span>
<span class="gi">+        tree_kws.setdefault(&quot;colors&quot;, tree_kws.pop(&quot;color&quot;, (.2, .2, .2)))</span>
<span class="gi">+</span>
<span class="gi">+        if self.rotate and self.axis == 0:</span>
<span class="gi">+            coords = zip(self.dependent_coord, self.independent_coord)</span>
<span class="gi">+        else:</span>
<span class="gi">+            coords = zip(self.independent_coord, self.dependent_coord)</span>
<span class="gi">+        lines = LineCollection([list(zip(x, y)) for x, y in coords],</span>
<span class="gi">+                               **tree_kws)</span>
<span class="gi">+</span>
<span class="gi">+        ax.add_collection(lines)</span>
<span class="gi">+        number_of_leaves = len(self.reordered_ind)</span>
<span class="gi">+        max_dependent_coord = max(map(max, self.dependent_coord))</span>
<span class="gi">+</span>
<span class="gi">+        if self.rotate:</span>
<span class="gi">+            ax.yaxis.set_ticks_position(&#39;right&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # Constants 10 and 1.05 come from</span>
<span class="gi">+            # `scipy.cluster.hierarchy._plot_dendrogram`</span>
<span class="gi">+            ax.set_ylim(0, number_of_leaves * 10)</span>
<span class="gi">+            ax.set_xlim(0, max_dependent_coord * 1.05)</span>
<span class="gi">+</span>
<span class="gi">+            ax.invert_xaxis()</span>
<span class="gi">+            ax.invert_yaxis()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Constants 10 and 1.05 come from</span>
<span class="gi">+            # `scipy.cluster.hierarchy._plot_dendrogram`</span>
<span class="gi">+            ax.set_xlim(0, number_of_leaves * 10)</span>
<span class="gi">+            ax.set_ylim(0, max_dependent_coord * 1.05)</span>
<span class="gi">+</span>
<span class="gi">+        despine(ax=ax, bottom=True, left=True)</span>
<span class="gi">+</span>
<span class="gi">+        ax.set(xticks=self.xticks, yticks=self.yticks,</span>
<span class="gi">+               xlabel=self.xlabel, ylabel=self.ylabel)</span>
<span class="gi">+        xtl = ax.set_xticklabels(self.xticklabels)</span>
<span class="gi">+        ytl = ax.set_yticklabels(self.yticklabels, rotation=&#39;vertical&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Force a draw of the plot to avoid matplotlib window error</span>
<span class="gi">+        _draw_figure(ax.figure)</span>

<span class="gi">+        if len(ytl) &gt; 0 and axis_ticklabels_overlap(ytl):</span>
<span class="gi">+            plt.setp(ytl, rotation=&quot;horizontal&quot;)</span>
<span class="gi">+        if len(xtl) &gt; 0 and axis_ticklabels_overlap(xtl):</span>
<span class="gi">+            plt.setp(xtl, rotation=&quot;vertical&quot;)</span>
<span class="gi">+        return self</span>

<span class="gd">-def dendrogram(data, *, linkage=None, axis=1, label=True, metric=</span>
<span class="gd">-    &#39;euclidean&#39;, method=&#39;average&#39;, rotate=False, tree_kws=None, ax=None):</span>
<span class="gi">+</span>
<span class="gi">+def dendrogram(</span>
<span class="gi">+    data, *,</span>
<span class="gi">+    linkage=None, axis=1, label=True, metric=&#39;euclidean&#39;,</span>
<span class="gi">+    method=&#39;average&#39;, rotate=False, tree_kws=None, ax=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Draw a tree diagram of relationships within a matrix

<span class="w"> </span>    Parameters
<span class="gu">@@ -357,72 +681,157 @@ def dendrogram(data, *, linkage=None, axis=1, label=True, metric=</span>
<span class="w"> </span>    dendrogramplotter.reordered_ind

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _no_scipy:</span>
<span class="gi">+        raise RuntimeError(&quot;dendrogram requires scipy to be installed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    plotter = _DendrogramPlotter(data, linkage=linkage, axis=axis,</span>
<span class="gi">+                                 metric=metric, method=method,</span>
<span class="gi">+                                 label=label, rotate=rotate)</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    return plotter.plot(ax=ax, tree_kws=tree_kws)</span>


<span class="w"> </span>class ClusterGrid(Grid):

<span class="gd">-    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=</span>
<span class="gd">-        None, figsize=None, row_colors=None, col_colors=None, mask=None,</span>
<span class="gd">-        dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):</span>
<span class="gi">+    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=None,</span>
<span class="gi">+                 figsize=None, row_colors=None, col_colors=None, mask=None,</span>
<span class="gi">+                 dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Grid object for organizing clustered heatmap input on to axes&quot;&quot;&quot;
<span class="w"> </span>        if _no_scipy:
<span class="gd">-            raise RuntimeError(&#39;ClusterGrid requires scipy to be available&#39;)</span>
<span class="gi">+            raise RuntimeError(&quot;ClusterGrid requires scipy to be available&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(data, pd.DataFrame):
<span class="w"> </span>            self.data = data
<span class="w"> </span>        else:
<span class="w"> </span>            self.data = pd.DataFrame(data)
<span class="gi">+</span>
<span class="w"> </span>        self.data2d = self.format_data(self.data, pivot_kws, z_score,
<span class="gd">-            standard_scale)</span>
<span class="gi">+                                       standard_scale)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.mask = _matrix_mask(self.data2d, mask)
<span class="gi">+</span>
<span class="w"> </span>        self._figure = plt.figure(figsize=figsize)
<span class="gd">-        self.row_colors, self.row_color_labels = self._preprocess_colors(data,</span>
<span class="gd">-            row_colors, axis=0)</span>
<span class="gd">-        self.col_colors, self.col_color_labels = self._preprocess_colors(data,</span>
<span class="gd">-            col_colors, axis=1)</span>
<span class="gi">+</span>
<span class="gi">+        self.row_colors, self.row_color_labels = \</span>
<span class="gi">+            self._preprocess_colors(data, row_colors, axis=0)</span>
<span class="gi">+        self.col_colors, self.col_color_labels = \</span>
<span class="gi">+            self._preprocess_colors(data, col_colors, axis=1)</span>
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            row_dendrogram_ratio, col_dendrogram_ratio = dendrogram_ratio
<span class="w"> </span>        except TypeError:
<span class="w"> </span>            row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="w"> </span>            row_colors_ratio, col_colors_ratio = colors_ratio
<span class="w"> </span>        except TypeError:
<span class="w"> </span>            row_colors_ratio = col_colors_ratio = colors_ratio
<span class="gi">+</span>
<span class="w"> </span>        width_ratios = self.dim_ratios(self.row_colors,
<span class="gd">-            row_dendrogram_ratio, row_colors_ratio)</span>
<span class="gi">+                                       row_dendrogram_ratio,</span>
<span class="gi">+                                       row_colors_ratio)</span>
<span class="w"> </span>        height_ratios = self.dim_ratios(self.col_colors,
<span class="gd">-            col_dendrogram_ratio, col_colors_ratio)</span>
<span class="gi">+                                        col_dendrogram_ratio,</span>
<span class="gi">+                                        col_colors_ratio)</span>
<span class="gi">+</span>
<span class="w"> </span>        nrows = 2 if self.col_colors is None else 3
<span class="w"> </span>        ncols = 2 if self.row_colors is None else 3
<span class="gd">-        self.gs = gridspec.GridSpec(nrows, ncols, width_ratios=width_ratios,</span>
<span class="gd">-            height_ratios=height_ratios)</span>
<span class="gi">+</span>
<span class="gi">+        self.gs = gridspec.GridSpec(nrows, ncols,</span>
<span class="gi">+                                    width_ratios=width_ratios,</span>
<span class="gi">+                                    height_ratios=height_ratios)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-1, 0])
<span class="w"> </span>        self.ax_col_dendrogram = self._figure.add_subplot(self.gs[0, -1])
<span class="w"> </span>        self.ax_row_dendrogram.set_axis_off()
<span class="w"> </span>        self.ax_col_dendrogram.set_axis_off()
<span class="gi">+</span>
<span class="w"> </span>        self.ax_row_colors = None
<span class="w"> </span>        self.ax_col_colors = None
<span class="gi">+</span>
<span class="w"> </span>        if self.row_colors is not None:
<span class="gd">-            self.ax_row_colors = self._figure.add_subplot(self.gs[-1, 1])</span>
<span class="gi">+            self.ax_row_colors = self._figure.add_subplot(</span>
<span class="gi">+                self.gs[-1, 1])</span>
<span class="w"> </span>        if self.col_colors is not None:
<span class="gd">-            self.ax_col_colors = self._figure.add_subplot(self.gs[1, -1])</span>
<span class="gi">+            self.ax_col_colors = self._figure.add_subplot(</span>
<span class="gi">+                self.gs[1, -1])</span>
<span class="gi">+</span>
<span class="w"> </span>        self.ax_heatmap = self._figure.add_subplot(self.gs[-1, -1])
<span class="w"> </span>        if cbar_pos is None:
<span class="w"> </span>            self.ax_cbar = self.cax = None
<span class="w"> </span>        else:
<span class="gi">+            # Initialize the colorbar axes in the gridspec so that tight_layout</span>
<span class="gi">+            # works. We will move it where it belongs later. This is a hack.</span>
<span class="w"> </span>            self.ax_cbar = self._figure.add_subplot(self.gs[0, 0])
<span class="gd">-            self.cax = self.ax_cbar</span>
<span class="gi">+            self.cax = self.ax_cbar  # Backwards compatibility</span>
<span class="w"> </span>        self.cbar_pos = cbar_pos
<span class="gi">+</span>
<span class="w"> </span>        self.dendrogram_row = None
<span class="w"> </span>        self.dendrogram_col = None

<span class="w"> </span>    def _preprocess_colors(self, data, colors, axis):
<span class="w"> </span>        &quot;&quot;&quot;Preprocess {row/col}_colors to extract labels and convert colors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def format_data(self, data, pivot_kws, z_score=None, standard_scale=None):</span>
<span class="gi">+        labels = None</span>
<span class="gi">+</span>
<span class="gi">+        if colors is not None:</span>
<span class="gi">+            if isinstance(colors, (pd.DataFrame, pd.Series)):</span>
<span class="gi">+</span>
<span class="gi">+                # If data is unindexed, raise</span>
<span class="gi">+                if (not hasattr(data, &quot;index&quot;) and axis == 0) or (</span>
<span class="gi">+                    not hasattr(data, &quot;columns&quot;) and axis == 1</span>
<span class="gi">+                ):</span>
<span class="gi">+                    axis_name = &quot;col&quot; if axis else &quot;row&quot;</span>
<span class="gi">+                    msg = (f&quot;{axis_name}_colors indices can&#39;t be matched with data &quot;</span>
<span class="gi">+                           f&quot;indices. Provide {axis_name}_colors as a non-indexed &quot;</span>
<span class="gi">+                           &quot;datatype, e.g. by using `.to_numpy()``&quot;)</span>
<span class="gi">+                    raise TypeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+                # Ensure colors match data indices</span>
<span class="gi">+                if axis == 0:</span>
<span class="gi">+                    colors = colors.reindex(data.index)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    colors = colors.reindex(data.columns)</span>
<span class="gi">+</span>
<span class="gi">+                # Replace na&#39;s with white color</span>
<span class="gi">+                # TODO We should set these to transparent instead</span>
<span class="gi">+                colors = colors.astype(object).fillna(&#39;white&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                # Extract color values and labels from frame/series</span>
<span class="gi">+                if isinstance(colors, pd.DataFrame):</span>
<span class="gi">+                    labels = list(colors.columns)</span>
<span class="gi">+                    colors = colors.T.values</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if colors.name is None:</span>
<span class="gi">+                        labels = [&quot;&quot;]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        labels = [colors.name]</span>
<span class="gi">+                    colors = colors.values</span>
<span class="gi">+</span>
<span class="gi">+            colors = _convert_colors(colors)</span>
<span class="gi">+</span>
<span class="gi">+        return colors, labels</span>
<span class="gi">+</span>
<span class="gi">+    def format_data(self, data, pivot_kws, z_score=None,</span>
<span class="gi">+                    standard_scale=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract variables from data or use directly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Either the data is already in 2d matrix format, or need to do a pivot</span>
<span class="gi">+        if pivot_kws is not None:</span>
<span class="gi">+            data2d = data.pivot(**pivot_kws)</span>
<span class="gi">+        else:</span>
<span class="gi">+            data2d = data</span>
<span class="gi">+</span>
<span class="gi">+        if z_score is not None and standard_scale is not None:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &#39;Cannot perform both z-scoring and standard-scaling on data&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if z_score is not None:</span>
<span class="gi">+            data2d = self.z_score(data2d, z_score)</span>
<span class="gi">+        if standard_scale is not None:</span>
<span class="gi">+            data2d = self.standard_scale(data2d, standard_scale)</span>
<span class="gi">+        return data2d</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def z_score(data2d, axis=1):
<span class="gu">@@ -442,7 +851,17 @@ class ClusterGrid(Grid):</span>
<span class="w"> </span>            Noramlized data with a mean of 0 and variance of 1 across the
<span class="w"> </span>            specified axis.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if axis == 1:</span>
<span class="gi">+            z_scored = data2d</span>
<span class="gi">+        else:</span>
<span class="gi">+            z_scored = data2d.T</span>
<span class="gi">+</span>
<span class="gi">+        z_scored = (z_scored - z_scored.mean()) / z_scored.std()</span>
<span class="gi">+</span>
<span class="gi">+        if axis == 1:</span>
<span class="gi">+            return z_scored</span>
<span class="gi">+        else:</span>
<span class="gi">+            return z_scored.T</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def standard_scale(data2d, axis=1):
<span class="gu">@@ -463,11 +882,38 @@ class ClusterGrid(Grid):</span>
<span class="w"> </span>            specified axis.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Normalize these values to range from 0 to 1</span>
<span class="gi">+        if axis == 1:</span>
<span class="gi">+            standardized = data2d</span>
<span class="gi">+        else:</span>
<span class="gi">+            standardized = data2d.T</span>
<span class="gi">+</span>
<span class="gi">+        subtract = standardized.min()</span>
<span class="gi">+        standardized = (standardized - subtract) / (</span>
<span class="gi">+            standardized.max() - standardized.min())</span>
<span class="gi">+</span>
<span class="gi">+        if axis == 1:</span>
<span class="gi">+            return standardized</span>
<span class="gi">+        else:</span>
<span class="gi">+            return standardized.T</span>

<span class="w"> </span>    def dim_ratios(self, colors, dendrogram_ratio, colors_ratio):
<span class="w"> </span>        &quot;&quot;&quot;Get the proportions of the figure taken up by each axes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ratios = [dendrogram_ratio]</span>
<span class="gi">+</span>
<span class="gi">+        if colors is not None:</span>
<span class="gi">+            # Colors are encoded as rgb, so there is an extra dimension</span>
<span class="gi">+            if np.ndim(colors) &gt; 2:</span>
<span class="gi">+                n_colors = len(colors)</span>
<span class="gi">+            else:</span>
<span class="gi">+                n_colors = 1</span>
<span class="gi">+</span>
<span class="gi">+            ratios += [n_colors * colors_ratio]</span>
<span class="gi">+</span>
<span class="gi">+        # Add the ratio for the heatmap itself</span>
<span class="gi">+        ratios.append(1 - sum(ratios))</span>
<span class="gi">+</span>
<span class="gi">+        return ratios</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def color_list_to_matrix_and_cmap(colors, ind, axis=0):
<span class="gu">@@ -493,7 +939,58 @@ class ClusterGrid(Grid):</span>
<span class="w"> </span>        cmap : matplotlib.colors.ListedColormap

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            mpl.colors.to_rgb(colors[0])</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # We have a 2D color structure</span>
<span class="gi">+            m, n = len(colors), len(colors[0])</span>
<span class="gi">+            if not all(len(c) == n for c in colors[1:]):</span>
<span class="gi">+                raise ValueError(&quot;Multiple side color vectors must have same size&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We have one vector of colors</span>
<span class="gi">+            m, n = 1, len(colors)</span>
<span class="gi">+            colors = [colors]</span>
<span class="gi">+</span>
<span class="gi">+        # Map from unique colors to colormap index value</span>
<span class="gi">+        unique_colors = {}</span>
<span class="gi">+        matrix = np.zeros((m, n), int)</span>
<span class="gi">+        for i, inner in enumerate(colors):</span>
<span class="gi">+            for j, color in enumerate(inner):</span>
<span class="gi">+                idx = unique_colors.setdefault(color, len(unique_colors))</span>
<span class="gi">+                matrix[i, j] = idx</span>
<span class="gi">+</span>
<span class="gi">+        # Reorder for clustering and transpose for axis</span>
<span class="gi">+        matrix = matrix[:, ind]</span>
<span class="gi">+        if axis == 0:</span>
<span class="gi">+            matrix = matrix.T</span>
<span class="gi">+</span>
<span class="gi">+        cmap = mpl.colors.ListedColormap(list(unique_colors))</span>
<span class="gi">+        return matrix, cmap</span>
<span class="gi">+</span>
<span class="gi">+    def plot_dendrograms(self, row_cluster, col_cluster, metric, method,</span>
<span class="gi">+                         row_linkage, col_linkage, tree_kws):</span>
<span class="gi">+        # Plot the row dendrogram</span>
<span class="gi">+        if row_cluster:</span>
<span class="gi">+            self.dendrogram_row = dendrogram(</span>
<span class="gi">+                self.data2d, metric=metric, method=method, label=False, axis=0,</span>
<span class="gi">+                ax=self.ax_row_dendrogram, rotate=True, linkage=row_linkage,</span>
<span class="gi">+                tree_kws=tree_kws</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.ax_row_dendrogram.set_xticks([])</span>
<span class="gi">+            self.ax_row_dendrogram.set_yticks([])</span>
<span class="gi">+        # PLot the column dendrogram</span>
<span class="gi">+        if col_cluster:</span>
<span class="gi">+            self.dendrogram_col = dendrogram(</span>
<span class="gi">+                self.data2d, metric=metric, method=method, label=False,</span>
<span class="gi">+                axis=1, ax=self.ax_col_dendrogram, linkage=col_linkage,</span>
<span class="gi">+                tree_kws=tree_kws</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.ax_col_dendrogram.set_xticks([])</span>
<span class="gi">+            self.ax_col_dendrogram.set_yticks([])</span>
<span class="gi">+        despine(ax=self.ax_row_dendrogram, bottom=True, left=True)</span>
<span class="gi">+        despine(ax=self.ax_col_dendrogram, bottom=True, left=True)</span>

<span class="w"> </span>    def plot_colors(self, xind, yind, **kws):
<span class="w"> </span>        &quot;&quot;&quot;Plots color labels between the dendrogram and the heatmap
<span class="gu">@@ -504,15 +1001,159 @@ class ClusterGrid(Grid):</span>
<span class="w"> </span>            Keyword arguments heatmap

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Remove any custom colormap and centering</span>
<span class="gi">+        # TODO this code has consistently caused problems when we</span>
<span class="gi">+        # have missed kwargs that need to be excluded that it might</span>
<span class="gi">+        # be better to rewrite *in*clusively.</span>
<span class="gi">+        kws = kws.copy()</span>
<span class="gi">+        kws.pop(&#39;cmap&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;norm&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;center&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;annot&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;vmin&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;vmax&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;robust&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;xticklabels&#39;, None)</span>
<span class="gi">+        kws.pop(&#39;yticklabels&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Plot the row colors</span>
<span class="gi">+        if self.row_colors is not None:</span>
<span class="gi">+            matrix, cmap = self.color_list_to_matrix_and_cmap(</span>
<span class="gi">+                self.row_colors, yind, axis=0)</span>
<span class="gi">+</span>
<span class="gi">+            # Get row_color labels</span>
<span class="gi">+            if self.row_color_labels is not None:</span>
<span class="gi">+                row_color_labels = self.row_color_labels</span>
<span class="gi">+            else:</span>
<span class="gi">+                row_color_labels = False</span>
<span class="gi">+</span>
<span class="gi">+            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_row_colors,</span>
<span class="gi">+                    xticklabels=row_color_labels, yticklabels=False, **kws)</span>
<span class="gi">+</span>
<span class="gi">+            # Adjust rotation of labels</span>
<span class="gi">+            if row_color_labels is not False:</span>
<span class="gi">+                plt.setp(self.ax_row_colors.get_xticklabels(), rotation=90)</span>
<span class="gi">+        else:</span>
<span class="gi">+            despine(self.ax_row_colors, left=True, bottom=True)</span>
<span class="gi">+</span>
<span class="gi">+        # Plot the column colors</span>
<span class="gi">+        if self.col_colors is not None:</span>
<span class="gi">+            matrix, cmap = self.color_list_to_matrix_and_cmap(</span>
<span class="gi">+                self.col_colors, xind, axis=1)</span>
<span class="gi">+</span>
<span class="gi">+            # Get col_color labels</span>
<span class="gi">+            if self.col_color_labels is not None:</span>
<span class="gi">+                col_color_labels = self.col_color_labels</span>
<span class="gi">+            else:</span>
<span class="gi">+                col_color_labels = False</span>

<span class="gi">+            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_col_colors,</span>
<span class="gi">+                    xticklabels=False, yticklabels=col_color_labels, **kws)</span>

<span class="gd">-def clustermap(data, *, pivot_kws=None, method=&#39;average&#39;, metric=</span>
<span class="gd">-    &#39;euclidean&#39;, z_score=None, standard_scale=None, figsize=(10, 10),</span>
<span class="gd">-    cbar_kws=None, row_cluster=True, col_cluster=True, row_linkage=None,</span>
<span class="gd">-    col_linkage=None, row_colors=None, col_colors=None, mask=None,</span>
<span class="gd">-    dendrogram_ratio=0.2, colors_ratio=0.03, cbar_pos=(0.02, 0.8, 0.05, </span>
<span class="gd">-    0.18), tree_kws=None, **kwargs):</span>
<span class="gi">+            # Adjust rotation of labels, place on right side</span>
<span class="gi">+            if col_color_labels is not False:</span>
<span class="gi">+                self.ax_col_colors.yaxis.tick_right()</span>
<span class="gi">+                plt.setp(self.ax_col_colors.get_yticklabels(), rotation=0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            despine(self.ax_col_colors, left=True, bottom=True)</span>
<span class="gi">+</span>
<span class="gi">+    def plot_matrix(self, colorbar_kws, xind, yind, **kws):</span>
<span class="gi">+        self.data2d = self.data2d.iloc[yind, xind]</span>
<span class="gi">+        self.mask = self.mask.iloc[yind, xind]</span>
<span class="gi">+</span>
<span class="gi">+        # Try to reorganize specified tick labels, if provided</span>
<span class="gi">+        xtl = kws.pop(&quot;xticklabels&quot;, &quot;auto&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            xtl = np.asarray(xtl)[xind]</span>
<span class="gi">+        except (TypeError, IndexError):</span>
<span class="gi">+            pass</span>
<span class="gi">+        ytl = kws.pop(&quot;yticklabels&quot;, &quot;auto&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            ytl = np.asarray(ytl)[yind]</span>
<span class="gi">+        except (TypeError, IndexError):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # Reorganize the annotations to match the heatmap</span>
<span class="gi">+        annot = kws.pop(&quot;annot&quot;, None)</span>
<span class="gi">+        if annot is None or annot is False:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(annot, bool):</span>
<span class="gi">+                annot_data = self.data2d</span>
<span class="gi">+            else:</span>
<span class="gi">+                annot_data = np.asarray(annot)</span>
<span class="gi">+                if annot_data.shape != self.data2d.shape:</span>
<span class="gi">+                    err = &quot;`data` and `annot` must have same shape.&quot;</span>
<span class="gi">+                    raise ValueError(err)</span>
<span class="gi">+                annot_data = annot_data[yind][:, xind]</span>
<span class="gi">+            annot = annot_data</span>
<span class="gi">+</span>
<span class="gi">+        # Setting ax_cbar=None in clustermap call implies no colorbar</span>
<span class="gi">+        kws.setdefault(&quot;cbar&quot;, self.ax_cbar is not None)</span>
<span class="gi">+        heatmap(self.data2d, ax=self.ax_heatmap, cbar_ax=self.ax_cbar,</span>
<span class="gi">+                cbar_kws=colorbar_kws, mask=self.mask,</span>
<span class="gi">+                xticklabels=xtl, yticklabels=ytl, annot=annot, **kws)</span>
<span class="gi">+</span>
<span class="gi">+        ytl = self.ax_heatmap.get_yticklabels()</span>
<span class="gi">+        ytl_rot = None if not ytl else ytl[0].get_rotation()</span>
<span class="gi">+        self.ax_heatmap.yaxis.set_ticks_position(&#39;right&#39;)</span>
<span class="gi">+        self.ax_heatmap.yaxis.set_label_position(&#39;right&#39;)</span>
<span class="gi">+        if ytl_rot is not None:</span>
<span class="gi">+            ytl = self.ax_heatmap.get_yticklabels()</span>
<span class="gi">+            plt.setp(ytl, rotation=ytl_rot)</span>
<span class="gi">+</span>
<span class="gi">+        tight_params = dict(h_pad=.02, w_pad=.02)</span>
<span class="gi">+        if self.ax_cbar is None:</span>
<span class="gi">+            self._figure.tight_layout(**tight_params)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Turn the colorbar axes off for tight layout so that its</span>
<span class="gi">+            # ticks don&#39;t interfere with the rest of the plot layout.</span>
<span class="gi">+            # Then move it.</span>
<span class="gi">+            self.ax_cbar.set_axis_off()</span>
<span class="gi">+            self._figure.tight_layout(**tight_params)</span>
<span class="gi">+            self.ax_cbar.set_axis_on()</span>
<span class="gi">+            self.ax_cbar.set_position(self.cbar_pos)</span>
<span class="gi">+</span>
<span class="gi">+    def plot(self, metric, method, colorbar_kws, row_cluster, col_cluster,</span>
<span class="gi">+             row_linkage, col_linkage, tree_kws, **kws):</span>
<span class="gi">+</span>
<span class="gi">+        # heatmap square=True sets the aspect ratio on the axes, but that is</span>
<span class="gi">+        # not compatible with the multi-axes layout of clustergrid</span>
<span class="gi">+        if kws.get(&quot;square&quot;, False):</span>
<span class="gi">+            msg = &quot;``square=True`` ignored in clustermap&quot;</span>
<span class="gi">+            warnings.warn(msg)</span>
<span class="gi">+            kws.pop(&quot;square&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        colorbar_kws = {} if colorbar_kws is None else colorbar_kws</span>
<span class="gi">+</span>
<span class="gi">+        self.plot_dendrograms(row_cluster, col_cluster, metric, method,</span>
<span class="gi">+                              row_linkage=row_linkage, col_linkage=col_linkage,</span>
<span class="gi">+                              tree_kws=tree_kws)</span>
<span class="gi">+        try:</span>
<span class="gi">+            xind = self.dendrogram_col.reordered_ind</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            xind = np.arange(self.data2d.shape[1])</span>
<span class="gi">+        try:</span>
<span class="gi">+            yind = self.dendrogram_row.reordered_ind</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            yind = np.arange(self.data2d.shape[0])</span>
<span class="gi">+</span>
<span class="gi">+        self.plot_colors(xind, yind, **kws)</span>
<span class="gi">+        self.plot_matrix(colorbar_kws, xind, yind, **kws)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clustermap(</span>
<span class="gi">+    data, *,</span>
<span class="gi">+    pivot_kws=None, method=&#39;average&#39;, metric=&#39;euclidean&#39;,</span>
<span class="gi">+    z_score=None, standard_scale=None, figsize=(10, 10),</span>
<span class="gi">+    cbar_kws=None, row_cluster=True, col_cluster=True,</span>
<span class="gi">+    row_linkage=None, col_linkage=None,</span>
<span class="gi">+    row_colors=None, col_colors=None, mask=None,</span>
<span class="gi">+    dendrogram_ratio=.2, colors_ratio=0.03,</span>
<span class="gi">+    cbar_pos=(.02, .8, .05, .18), tree_kws=None,</span>
<span class="gi">+    **kwargs</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Plot a matrix dataset as a hierarchically-clustered heatmap.

<span class="gu">@@ -605,4 +1246,17 @@ def clustermap(data, *, pivot_kws=None, method=&#39;average&#39;, metric=</span>
<span class="w"> </span>    .. include:: ../docstrings/clustermap.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _no_scipy:</span>
<span class="gi">+        raise RuntimeError(&quot;clustermap requires scipy to be available&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    plotter = ClusterGrid(data, pivot_kws=pivot_kws, figsize=figsize,</span>
<span class="gi">+                          row_colors=row_colors, col_colors=col_colors,</span>
<span class="gi">+                          z_score=z_score, standard_scale=standard_scale,</span>
<span class="gi">+                          mask=mask, dendrogram_ratio=dendrogram_ratio,</span>
<span class="gi">+                          colors_ratio=colors_ratio, cbar_pos=cbar_pos)</span>
<span class="gi">+</span>
<span class="gi">+    return plotter.plot(metric=metric, method=method,</span>
<span class="gi">+                        colorbar_kws=cbar_kws,</span>
<span class="gi">+                        row_cluster=row_cluster, col_cluster=col_cluster,</span>
<span class="gi">+                        row_linkage=row_linkage, col_linkage=col_linkage,</span>
<span class="gi">+                        tree_kws=tree_kws, **kwargs)</span>
<span class="gh">diff --git a/seaborn/miscplot.py b/seaborn/miscplot.py</span>
<span class="gh">index 3bbc63a0..3fb290c8 100644</span>
<span class="gd">--- a/seaborn/miscplot.py</span>
<span class="gi">+++ b/seaborn/miscplot.py</span>
<span class="gu">@@ -2,7 +2,8 @@ import numpy as np</span>
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="w"> </span>import matplotlib.ticker as ticker
<span class="gd">-__all__ = [&#39;palplot&#39;, &#39;dogplot&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;palplot&quot;, &quot;dogplot&quot;]</span>


<span class="w"> </span>def palplot(pal, size=1):
<span class="gu">@@ -16,9 +17,29 @@ def palplot(pal, size=1):</span>
<span class="w"> </span>        scaling factor for size of plot

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(pal)</span>
<span class="gi">+    _, ax = plt.subplots(1, 1, figsize=(n * size, size))</span>
<span class="gi">+    ax.imshow(np.arange(n).reshape(1, n),</span>
<span class="gi">+              cmap=mpl.colors.ListedColormap(list(pal)),</span>
<span class="gi">+              interpolation=&quot;nearest&quot;, aspect=&quot;auto&quot;)</span>
<span class="gi">+    ax.set_xticks(np.arange(n) - .5)</span>
<span class="gi">+    ax.set_yticks([-.5, .5])</span>
<span class="gi">+    # Ensure nice border between colors</span>
<span class="gi">+    ax.set_xticklabels([&quot;&quot; for _ in range(n)])</span>
<span class="gi">+    # The proper way to set no ticks</span>
<span class="gi">+    ax.yaxis.set_major_locator(ticker.NullLocator())</span>


<span class="w"> </span>def dogplot(*_, **__):
<span class="w"> </span>    &quot;&quot;&quot;Who&#39;s a good boy?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from urllib.request import urlopen</span>
<span class="gi">+    from io import BytesIO</span>
<span class="gi">+</span>
<span class="gi">+    url = &quot;https://github.com/mwaskom/seaborn-data/raw/master/png/img{}.png&quot;</span>
<span class="gi">+    pic = np.random.randint(2, 7)</span>
<span class="gi">+    data = BytesIO(urlopen(url.format(pic)).read())</span>
<span class="gi">+    img = plt.imread(data)</span>
<span class="gi">+    f, ax = plt.subplots(figsize=(5, 5), dpi=100)</span>
<span class="gi">+    f.subplots_adjust(0, 0, 1, 1)</span>
<span class="gi">+    ax.imshow(img)</span>
<span class="gi">+    ax.set_axis_off()</span>
<span class="gh">diff --git a/seaborn/objects.py b/seaborn/objects.py</span>
<span class="gh">index 45349c24..123e57f0 100644</span>
<span class="gd">--- a/seaborn/objects.py</span>
<span class="gi">+++ b/seaborn/objects.py</span>
<span class="gu">@@ -26,18 +26,24 @@ See the documentation for other :class:`Plot` methods to learn about the many</span>
<span class="w"> </span>ways that a plot can be enhanced and customized.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-from seaborn._core.plot import Plot</span>
<span class="gd">-from seaborn._marks.base import Mark</span>
<span class="gd">-from seaborn._marks.area import Area, Band</span>
<span class="gd">-from seaborn._marks.bar import Bar, Bars</span>
<span class="gd">-from seaborn._marks.dot import Dot, Dots</span>
<span class="gd">-from seaborn._marks.line import Dash, Line, Lines, Path, Paths, Range</span>
<span class="gd">-from seaborn._marks.text import Text</span>
<span class="gd">-from seaborn._stats.base import Stat</span>
<span class="gd">-from seaborn._stats.aggregation import Agg, Est</span>
<span class="gd">-from seaborn._stats.counting import Count, Hist</span>
<span class="gd">-from seaborn._stats.density import KDE</span>
<span class="gd">-from seaborn._stats.order import Perc</span>
<span class="gd">-from seaborn._stats.regression import PolyFit</span>
<span class="gd">-from seaborn._core.moves import Dodge, Jitter, Norm, Shift, Stack, Move</span>
<span class="gd">-from seaborn._core.scales import Boolean, Continuous, Nominal, Temporal, Scale</span>
<span class="gi">+from seaborn._core.plot import Plot  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._marks.base import Mark  # noqa: F401</span>
<span class="gi">+from seaborn._marks.area import Area, Band  # noqa: F401</span>
<span class="gi">+from seaborn._marks.bar import Bar, Bars  # noqa: F401</span>
<span class="gi">+from seaborn._marks.dot import Dot, Dots  # noqa: F401</span>
<span class="gi">+from seaborn._marks.line import Dash, Line, Lines, Path, Paths, Range  # noqa: F401</span>
<span class="gi">+from seaborn._marks.text import Text  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._stats.base import Stat  # noqa: F401</span>
<span class="gi">+from seaborn._stats.aggregation import Agg, Est  # noqa: F401</span>
<span class="gi">+from seaborn._stats.counting import Count, Hist  # noqa: F401</span>
<span class="gi">+from seaborn._stats.density import KDE  # noqa: F401</span>
<span class="gi">+from seaborn._stats.order import Perc  # noqa: F401</span>
<span class="gi">+from seaborn._stats.regression import PolyFit  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._core.moves import Dodge, Jitter, Norm, Shift, Stack, Move  # noqa: F401</span>
<span class="gi">+</span>
<span class="gi">+from seaborn._core.scales import (  # noqa: F401</span>
<span class="gi">+    Boolean, Continuous, Nominal, Temporal, Scale</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/seaborn/palettes.py b/seaborn/palettes.py</span>
<span class="gh">index 6447384e..f7f42984 100644</span>
<span class="gd">--- a/seaborn/palettes.py</span>
<span class="gi">+++ b/seaborn/palettes.py</span>
<span class="gu">@@ -1,35 +1,58 @@</span>
<span class="w"> </span>import colorsys
<span class="w"> </span>from itertools import cycle
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib as mpl
<span class="gi">+</span>
<span class="w"> </span>from .external import husl
<span class="gi">+</span>
<span class="w"> </span>from .utils import desaturate, get_color_cycle
<span class="w"> </span>from .colors import xkcd_rgb, crayons
<span class="w"> </span>from ._compat import get_colormap
<span class="gd">-__all__ = [&#39;color_palette&#39;, &#39;hls_palette&#39;, &#39;husl_palette&#39;, &#39;mpl_palette&#39;,</span>
<span class="gd">-    &#39;dark_palette&#39;, &#39;light_palette&#39;, &#39;diverging_palette&#39;, &#39;blend_palette&#39;,</span>
<span class="gd">-    &#39;xkcd_palette&#39;, &#39;crayon_palette&#39;, &#39;cubehelix_palette&#39;, &#39;set_color_codes&#39;]</span>
<span class="gd">-SEABORN_PALETTES = dict(deep=[&#39;#4C72B0&#39;, &#39;#DD8452&#39;, &#39;#55A868&#39;, &#39;#C44E52&#39;,</span>
<span class="gd">-    &#39;#8172B3&#39;, &#39;#937860&#39;, &#39;#DA8BC3&#39;, &#39;#8C8C8C&#39;, &#39;#CCB974&#39;, &#39;#64B5CD&#39;],</span>
<span class="gd">-    deep6=[&#39;#4C72B0&#39;, &#39;#55A868&#39;, &#39;#C44E52&#39;, &#39;#8172B3&#39;, &#39;#CCB974&#39;, &#39;#64B5CD&#39;</span>
<span class="gd">-    ], muted=[&#39;#4878D0&#39;, &#39;#EE854A&#39;, &#39;#6ACC64&#39;, &#39;#D65F5F&#39;, &#39;#956CB4&#39;,</span>
<span class="gd">-    &#39;#8C613C&#39;, &#39;#DC7EC0&#39;, &#39;#797979&#39;, &#39;#D5BB67&#39;, &#39;#82C6E2&#39;], muted6=[</span>
<span class="gd">-    &#39;#4878D0&#39;, &#39;#6ACC64&#39;, &#39;#D65F5F&#39;, &#39;#956CB4&#39;, &#39;#D5BB67&#39;, &#39;#82C6E2&#39;],</span>
<span class="gd">-    pastel=[&#39;#A1C9F4&#39;, &#39;#FFB482&#39;, &#39;#8DE5A1&#39;, &#39;#FF9F9B&#39;, &#39;#D0BBFF&#39;,</span>
<span class="gd">-    &#39;#DEBB9B&#39;, &#39;#FAB0E4&#39;, &#39;#CFCFCF&#39;, &#39;#FFFEA3&#39;, &#39;#B9F2F0&#39;], pastel6=[</span>
<span class="gd">-    &#39;#A1C9F4&#39;, &#39;#8DE5A1&#39;, &#39;#FF9F9B&#39;, &#39;#D0BBFF&#39;, &#39;#FFFEA3&#39;, &#39;#B9F2F0&#39;],</span>
<span class="gd">-    bright=[&#39;#023EFF&#39;, &#39;#FF7C00&#39;, &#39;#1AC938&#39;, &#39;#E8000B&#39;, &#39;#8B2BE2&#39;,</span>
<span class="gd">-    &#39;#9F4800&#39;, &#39;#F14CC1&#39;, &#39;#A3A3A3&#39;, &#39;#FFC400&#39;, &#39;#00D7FF&#39;], bright6=[</span>
<span class="gd">-    &#39;#023EFF&#39;, &#39;#1AC938&#39;, &#39;#E8000B&#39;, &#39;#8B2BE2&#39;, &#39;#FFC400&#39;, &#39;#00D7FF&#39;], dark</span>
<span class="gd">-    =[&#39;#001C7F&#39;, &#39;#B1400D&#39;, &#39;#12711C&#39;, &#39;#8C0800&#39;, &#39;#591E71&#39;, &#39;#592F0D&#39;,</span>
<span class="gd">-    &#39;#A23582&#39;, &#39;#3C3C3C&#39;, &#39;#B8850A&#39;, &#39;#006374&#39;], dark6=[&#39;#001C7F&#39;,</span>
<span class="gd">-    &#39;#12711C&#39;, &#39;#8C0800&#39;, &#39;#591E71&#39;, &#39;#B8850A&#39;, &#39;#006374&#39;], colorblind=[</span>
<span class="gd">-    &#39;#0173B2&#39;, &#39;#DE8F05&#39;, &#39;#029E73&#39;, &#39;#D55E00&#39;, &#39;#CC78BC&#39;, &#39;#CA9161&#39;,</span>
<span class="gd">-    &#39;#FBAFE4&#39;, &#39;#949494&#39;, &#39;#ECE133&#39;, &#39;#56B4E9&#39;], colorblind6=[&#39;#0173B2&#39;,</span>
<span class="gd">-    &#39;#029E73&#39;, &#39;#D55E00&#39;, &#39;#CC78BC&#39;, &#39;#ECE133&#39;, &#39;#56B4E9&#39;])</span>
<span class="gd">-MPL_QUAL_PALS = {&#39;tab10&#39;: 10, &#39;tab20&#39;: 20, &#39;tab20b&#39;: 20, &#39;tab20c&#39;: 20,</span>
<span class="gd">-    &#39;Set1&#39;: 9, &#39;Set2&#39;: 8, &#39;Set3&#39;: 12, &#39;Accent&#39;: 8, &#39;Paired&#39;: 12, &#39;Pastel1&#39;:</span>
<span class="gd">-    9, &#39;Pastel2&#39;: 8, &#39;Dark2&#39;: 8}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;color_palette&quot;, &quot;hls_palette&quot;, &quot;husl_palette&quot;, &quot;mpl_palette&quot;,</span>
<span class="gi">+           &quot;dark_palette&quot;, &quot;light_palette&quot;, &quot;diverging_palette&quot;,</span>
<span class="gi">+           &quot;blend_palette&quot;, &quot;xkcd_palette&quot;, &quot;crayon_palette&quot;,</span>
<span class="gi">+           &quot;cubehelix_palette&quot;, &quot;set_color_codes&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+SEABORN_PALETTES = dict(</span>
<span class="gi">+    deep=[&quot;#4C72B0&quot;, &quot;#DD8452&quot;, &quot;#55A868&quot;, &quot;#C44E52&quot;, &quot;#8172B3&quot;,</span>
<span class="gi">+          &quot;#937860&quot;, &quot;#DA8BC3&quot;, &quot;#8C8C8C&quot;, &quot;#CCB974&quot;, &quot;#64B5CD&quot;],</span>
<span class="gi">+    deep6=[&quot;#4C72B0&quot;, &quot;#55A868&quot;, &quot;#C44E52&quot;,</span>
<span class="gi">+           &quot;#8172B3&quot;, &quot;#CCB974&quot;, &quot;#64B5CD&quot;],</span>
<span class="gi">+    muted=[&quot;#4878D0&quot;, &quot;#EE854A&quot;, &quot;#6ACC64&quot;, &quot;#D65F5F&quot;, &quot;#956CB4&quot;,</span>
<span class="gi">+           &quot;#8C613C&quot;, &quot;#DC7EC0&quot;, &quot;#797979&quot;, &quot;#D5BB67&quot;, &quot;#82C6E2&quot;],</span>
<span class="gi">+    muted6=[&quot;#4878D0&quot;, &quot;#6ACC64&quot;, &quot;#D65F5F&quot;,</span>
<span class="gi">+            &quot;#956CB4&quot;, &quot;#D5BB67&quot;, &quot;#82C6E2&quot;],</span>
<span class="gi">+    pastel=[&quot;#A1C9F4&quot;, &quot;#FFB482&quot;, &quot;#8DE5A1&quot;, &quot;#FF9F9B&quot;, &quot;#D0BBFF&quot;,</span>
<span class="gi">+            &quot;#DEBB9B&quot;, &quot;#FAB0E4&quot;, &quot;#CFCFCF&quot;, &quot;#FFFEA3&quot;, &quot;#B9F2F0&quot;],</span>
<span class="gi">+    pastel6=[&quot;#A1C9F4&quot;, &quot;#8DE5A1&quot;, &quot;#FF9F9B&quot;,</span>
<span class="gi">+             &quot;#D0BBFF&quot;, &quot;#FFFEA3&quot;, &quot;#B9F2F0&quot;],</span>
<span class="gi">+    bright=[&quot;#023EFF&quot;, &quot;#FF7C00&quot;, &quot;#1AC938&quot;, &quot;#E8000B&quot;, &quot;#8B2BE2&quot;,</span>
<span class="gi">+            &quot;#9F4800&quot;, &quot;#F14CC1&quot;, &quot;#A3A3A3&quot;, &quot;#FFC400&quot;, &quot;#00D7FF&quot;],</span>
<span class="gi">+    bright6=[&quot;#023EFF&quot;, &quot;#1AC938&quot;, &quot;#E8000B&quot;,</span>
<span class="gi">+             &quot;#8B2BE2&quot;, &quot;#FFC400&quot;, &quot;#00D7FF&quot;],</span>
<span class="gi">+    dark=[&quot;#001C7F&quot;, &quot;#B1400D&quot;, &quot;#12711C&quot;, &quot;#8C0800&quot;, &quot;#591E71&quot;,</span>
<span class="gi">+          &quot;#592F0D&quot;, &quot;#A23582&quot;, &quot;#3C3C3C&quot;, &quot;#B8850A&quot;, &quot;#006374&quot;],</span>
<span class="gi">+    dark6=[&quot;#001C7F&quot;, &quot;#12711C&quot;, &quot;#8C0800&quot;,</span>
<span class="gi">+           &quot;#591E71&quot;, &quot;#B8850A&quot;, &quot;#006374&quot;],</span>
<span class="gi">+    colorblind=[&quot;#0173B2&quot;, &quot;#DE8F05&quot;, &quot;#029E73&quot;, &quot;#D55E00&quot;, &quot;#CC78BC&quot;,</span>
<span class="gi">+                &quot;#CA9161&quot;, &quot;#FBAFE4&quot;, &quot;#949494&quot;, &quot;#ECE133&quot;, &quot;#56B4E9&quot;],</span>
<span class="gi">+    colorblind6=[&quot;#0173B2&quot;, &quot;#029E73&quot;, &quot;#D55E00&quot;,</span>
<span class="gi">+                 &quot;#CC78BC&quot;, &quot;#ECE133&quot;, &quot;#56B4E9&quot;]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MPL_QUAL_PALS = {</span>
<span class="gi">+    &quot;tab10&quot;: 10, &quot;tab20&quot;: 20, &quot;tab20b&quot;: 20, &quot;tab20c&quot;: 20,</span>
<span class="gi">+    &quot;Set1&quot;: 9, &quot;Set2&quot;: 8, &quot;Set3&quot;: 12,</span>
<span class="gi">+    &quot;Accent&quot;: 8, &quot;Paired&quot;: 12,</span>
<span class="gi">+    &quot;Pastel1&quot;: 9, &quot;Pastel2&quot;: 8, &quot;Dark2&quot;: 8,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>QUAL_PALETTE_SIZES = MPL_QUAL_PALS.copy()
<span class="w"> </span>QUAL_PALETTE_SIZES.update({k: len(v) for k, v in SEABORN_PALETTES.items()})
<span class="w"> </span>QUAL_PALETTES = list(QUAL_PALETTE_SIZES.keys())
<span class="gu">@@ -37,7 +60,6 @@ QUAL_PALETTES = list(QUAL_PALETTE_SIZES.keys())</span>

<span class="w"> </span>class _ColorPalette(list):
<span class="w"> </span>    &quot;&quot;&quot;Set the color palette in a with statement, otherwise be a list.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        &quot;&quot;&quot;Open the context.&quot;&quot;&quot;
<span class="w"> </span>        from .rcmod import set_palette
<span class="gu">@@ -52,16 +74,49 @@ class _ColorPalette(list):</span>

<span class="w"> </span>    def as_hex(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a color palette with hex codes instead of RGB values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]</span>
<span class="gi">+        return _ColorPalette(hex)</span>

<span class="w"> </span>    def _repr_html_(self):
<span class="w"> </span>        &quot;&quot;&quot;Rich display of the color palette in an HTML frontend.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = 55</span>
<span class="gi">+        n = len(self)</span>
<span class="gi">+        html = f&#39;&lt;svg  width=&quot;{n * s}&quot; height=&quot;{s}&quot;&gt;&#39;</span>
<span class="gi">+        for i, c in enumerate(self.as_hex()):</span>
<span class="gi">+            html += (</span>
<span class="gi">+                f&#39;&lt;rect x=&quot;{i * s}&quot; y=&quot;0&quot; width=&quot;{s}&quot; height=&quot;{s}&quot; style=&quot;fill:{c};&#39;</span>
<span class="gi">+                &#39;stroke-width:2;stroke:rgb(255,255,255)&quot;/&gt;&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        html += &#39;&lt;/svg&gt;&#39;</span>
<span class="gi">+        return html</span>


<span class="w"> </span>def _patch_colormap_display():
<span class="w"> </span>    &quot;&quot;&quot;Simplify the rich display of matplotlib color maps in a notebook.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _repr_png_(self):</span>
<span class="gi">+        &quot;&quot;&quot;Generate a PNG representation of the Colormap.&quot;&quot;&quot;</span>
<span class="gi">+        import io</span>
<span class="gi">+        from PIL import Image</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+        IMAGE_SIZE = (400, 50)</span>
<span class="gi">+        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))</span>
<span class="gi">+        pixels = self(X, bytes=True)</span>
<span class="gi">+        png_bytes = io.BytesIO()</span>
<span class="gi">+        Image.fromarray(pixels).save(png_bytes, format=&#39;png&#39;)</span>
<span class="gi">+        return png_bytes.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+    def _repr_html_(self):</span>
<span class="gi">+        &quot;&quot;&quot;Generate an HTML representation of the Colormap.&quot;&quot;&quot;</span>
<span class="gi">+        import base64</span>
<span class="gi">+        png_bytes = self._repr_png_()</span>
<span class="gi">+        png_base64 = base64.b64encode(png_bytes).decode(&#39;ascii&#39;)</span>
<span class="gi">+        return (&#39;&lt;img &#39;</span>
<span class="gi">+                + &#39;alt=&quot;&#39; + self.name + &#39; color map&quot; &#39;</span>
<span class="gi">+                + &#39;title=&quot;&#39; + self.name + &#39;&quot;&#39;</span>
<span class="gi">+                + &#39;src=&quot;data:image/png;base64,&#39; + png_base64 + &#39;&quot;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    mpl.colors.Colormap._repr_png_ = _repr_png_</span>
<span class="gi">+    mpl.colors.Colormap._repr_html_ = _repr_html_</span>


<span class="w"> </span>def color_palette(palette=None, n_colors=None, desat=None, as_cmap=False):
<span class="gu">@@ -116,10 +171,91 @@ def color_palette(palette=None, n_colors=None, desat=None, as_cmap=False):</span>
<span class="w"> </span>    .. include:: ../docstrings/color_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):</span>
<span class="gi">+    if palette is None:</span>
<span class="gi">+        palette = get_color_cycle()</span>
<span class="gi">+        if n_colors is None:</span>
<span class="gi">+            n_colors = len(palette)</span>
<span class="gi">+</span>
<span class="gi">+    elif not isinstance(palette, str):</span>
<span class="gi">+        palette = palette</span>
<span class="gi">+        if n_colors is None:</span>
<span class="gi">+            n_colors = len(palette)</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        if n_colors is None:</span>
<span class="gi">+            # Use all colors in a qualitative palette or 6 of another kind</span>
<span class="gi">+            n_colors = QUAL_PALETTE_SIZES.get(palette, 6)</span>
<span class="gi">+</span>
<span class="gi">+        if palette in SEABORN_PALETTES:</span>
<span class="gi">+            # Named &quot;seaborn variant&quot; of matplotlib default color cycle</span>
<span class="gi">+            palette = SEABORN_PALETTES[palette]</span>
<span class="gi">+</span>
<span class="gi">+        elif palette == &quot;hls&quot;:</span>
<span class="gi">+            # Evenly spaced colors in cylindrical RGB space</span>
<span class="gi">+            palette = hls_palette(n_colors, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette == &quot;husl&quot;:</span>
<span class="gi">+            # Evenly spaced colors in cylindrical Lab space</span>
<span class="gi">+            palette = husl_palette(n_colors, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette.lower() == &quot;jet&quot;:</span>
<span class="gi">+            # Paternalism</span>
<span class="gi">+            raise ValueError(&quot;No.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette.startswith(&quot;ch:&quot;):</span>
<span class="gi">+            # Cubehelix palette with params specified in string</span>
<span class="gi">+            args, kwargs = _parse_cubehelix_args(palette)</span>
<span class="gi">+            palette = cubehelix_palette(n_colors, *args, **kwargs, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette.startswith(&quot;light:&quot;):</span>
<span class="gi">+            # light palette to color specified in string</span>
<span class="gi">+            _, color = palette.split(&quot;:&quot;)</span>
<span class="gi">+            reverse = color.endswith(&quot;_r&quot;)</span>
<span class="gi">+            if reverse:</span>
<span class="gi">+                color = color[:-2]</span>
<span class="gi">+            palette = light_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette.startswith(&quot;dark:&quot;):</span>
<span class="gi">+            # light palette to color specified in string</span>
<span class="gi">+            _, color = palette.split(&quot;:&quot;)</span>
<span class="gi">+            reverse = color.endswith(&quot;_r&quot;)</span>
<span class="gi">+            if reverse:</span>
<span class="gi">+                color = color[:-2]</span>
<span class="gi">+            palette = dark_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        elif palette.startswith(&quot;blend:&quot;):</span>
<span class="gi">+            # blend palette between colors specified in string</span>
<span class="gi">+            _, colors = palette.split(&quot;:&quot;)</span>
<span class="gi">+            colors = colors.split(&quot;,&quot;)</span>
<span class="gi">+            palette = blend_palette(colors, n_colors, as_cmap=as_cmap)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Perhaps a named matplotlib colormap?</span>
<span class="gi">+                palette = mpl_palette(palette, n_colors, as_cmap=as_cmap)</span>
<span class="gi">+            except (ValueError, KeyError):  # Error class changed in mpl36</span>
<span class="gi">+                raise ValueError(f&quot;{palette!r} is not a valid palette name&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if desat is not None:</span>
<span class="gi">+        palette = [desaturate(c, desat) for c in palette]</span>
<span class="gi">+</span>
<span class="gi">+    if not as_cmap:</span>
<span class="gi">+</span>
<span class="gi">+        # Always return as many colors as we asked for</span>
<span class="gi">+        pal_cycle = cycle(palette)</span>
<span class="gi">+        palette = [next(pal_cycle) for _ in range(n_colors)]</span>
<span class="gi">+</span>
<span class="gi">+        # Always return in r, g, b tuple format</span>
<span class="gi">+        try:</span>
<span class="gi">+            palette = map(mpl.colors.colorConverter.to_rgb, palette)</span>
<span class="gi">+            palette = _ColorPalette(palette)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ValueError(f&quot;Could not generate a palette for {palette}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return palette</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def hls_palette(n_colors=6, h=.01, l=.6, s=.65, as_cmap=False):  # noqa</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return hues with constant lightness and saturation in the HLS system.

<span class="gu">@@ -160,10 +296,20 @@ def hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):</span>
<span class="w"> </span>    .. include:: ../docstrings/hls_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        n_colors = 256</span>
<span class="gi">+    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]</span>
<span class="gi">+    hues += h</span>
<span class="gi">+    hues %= 1</span>
<span class="gi">+    hues -= hues.astype(int)</span>
<span class="gi">+    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return mpl.colors.ListedColormap(palette, &quot;hls&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _ColorPalette(palette)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def husl_palette(n_colors=6, h=.01, s=.9, l=.65, as_cmap=False):  # noqa</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return hues with constant lightness and saturation in the HUSL system.

<span class="gu">@@ -202,7 +348,19 @@ def husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):</span>
<span class="w"> </span>    .. include:: ../docstrings/husl_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        n_colors = 256</span>
<span class="gi">+    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]</span>
<span class="gi">+    hues += h</span>
<span class="gi">+    hues %= 1</span>
<span class="gi">+    hues *= 359</span>
<span class="gi">+    s *= 99</span>
<span class="gi">+    l *= 99  # noqa</span>
<span class="gi">+    palette = [_color_to_rgb((h_i, s, l), input=&quot;husl&quot;) for h_i in hues]</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return mpl.colors.ListedColormap(palette, &quot;hsl&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _ColorPalette(palette)</span>


<span class="w"> </span>def mpl_palette(name, n_colors=6, as_cmap=False):
<span class="gu">@@ -233,15 +391,46 @@ def mpl_palette(name, n_colors=6, as_cmap=False):</span>
<span class="w"> </span>    .. include:: ../docstrings/mpl_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.endswith(&quot;_d&quot;):</span>
<span class="gi">+        sub_name = name[:-2]</span>
<span class="gi">+        if sub_name.endswith(&quot;_r&quot;):</span>
<span class="gi">+            reverse = True</span>
<span class="gi">+            sub_name = sub_name[:-2]</span>
<span class="gi">+        else:</span>
<span class="gi">+            reverse = False</span>
<span class="gi">+        pal = color_palette(sub_name, 2) + [&quot;#333333&quot;]</span>
<span class="gi">+        if reverse:</span>
<span class="gi">+            pal = pal[::-1]</span>
<span class="gi">+        cmap = blend_palette(pal, n_colors, as_cmap=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cmap = get_colormap(name)</span>
<span class="gi">+</span>
<span class="gi">+    if name in MPL_QUAL_PALS:</span>
<span class="gi">+        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]</span>
<span class="gi">+    else:</span>
<span class="gi">+        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]</span>
<span class="gi">+    palette = list(map(tuple, cmap(bins)[:, :3]))</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _ColorPalette(palette)</span>


<span class="w"> </span>def _color_to_rgb(color, input):
<span class="w"> </span>    &quot;&quot;&quot;Add some more flexibility to color choices.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if input == &quot;hls&quot;:</span>
<span class="gi">+        color = colorsys.hls_to_rgb(*color)</span>
<span class="gi">+    elif input == &quot;husl&quot;:</span>
<span class="gi">+        color = husl.husl_to_rgb(*color)</span>
<span class="gi">+        color = tuple(np.clip(color, 0, 1))</span>
<span class="gi">+    elif input == &quot;xkcd&quot;:</span>
<span class="gi">+        color = xkcd_rgb[color]</span>

<span class="gi">+    return mpl.colors.to_rgb(color)</span>

<span class="gd">-def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;):</span>
<span class="gi">+</span>
<span class="gi">+def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&quot;rgb&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a sequential palette that blends from dark to ``color``.

<span class="w"> </span>    This kind of palette is good for data that range between relatively
<span class="gu">@@ -284,11 +473,15 @@ def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;):</span>
<span class="w"> </span>    .. include:: ../docstrings/dark_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rgb = _color_to_rgb(color, input)</span>
<span class="gi">+    hue, sat, _ = husl.rgb_to_husl(*rgb)</span>
<span class="gi">+    gray_s, gray_l = .15 * sat, 15</span>
<span class="gi">+    gray = _color_to_rgb((hue, gray_s, gray_l), input=&quot;husl&quot;)</span>
<span class="gi">+    colors = [rgb, gray] if reverse else [gray, rgb]</span>
<span class="gi">+    return blend_palette(colors, n_colors, as_cmap)</span>


<span class="gd">-def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;</span>
<span class="gd">-    ):</span>
<span class="gi">+def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&quot;rgb&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a sequential palette that blends from light to ``color``.

<span class="w"> </span>    The ``color`` parameter can be specified in a number of ways, including
<span class="gu">@@ -328,11 +521,16 @@ def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=&#39;rgb&#39;</span>
<span class="w"> </span>    .. include:: ../docstrings/light_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rgb = _color_to_rgb(color, input)</span>
<span class="gi">+    hue, sat, _ = husl.rgb_to_husl(*rgb)</span>
<span class="gi">+    gray_s, gray_l = .15 * sat, 95</span>
<span class="gi">+    gray = _color_to_rgb((hue, gray_s, gray_l), input=&quot;husl&quot;)</span>
<span class="gi">+    colors = [rgb, gray] if reverse else [gray, rgb]</span>
<span class="gi">+    return blend_palette(colors, n_colors, as_cmap)</span>


<span class="gd">-def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6, center=&#39;light&#39;,</span>
<span class="gd">-    as_cmap=False):</span>
<span class="gi">+def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6,  # noqa</span>
<span class="gi">+                      center=&quot;light&quot;, as_cmap=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a diverging palette between two HUSL colors.

<span class="w"> </span>    If you are using the IPython notebook, you can also choose this palette
<span class="gu">@@ -370,10 +568,17 @@ def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6, center=&#39;light&#39;,</span>
<span class="w"> </span>    .. include: ../docstrings/diverging_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    palfunc = dict(dark=dark_palette, light=light_palette)[center]</span>
<span class="gi">+    n_half = int(128 - (sep // 2))</span>
<span class="gi">+    neg = palfunc((h_neg, s, l), n_half, reverse=True, input=&quot;husl&quot;)</span>
<span class="gi">+    pos = palfunc((h_pos, s, l), n_half, input=&quot;husl&quot;)</span>
<span class="gi">+    midpoint = dict(light=[(.95, .95, .95)], dark=[(.133, .133, .133)])[center]</span>
<span class="gi">+    mid = midpoint * sep</span>
<span class="gi">+    pal = blend_palette(np.concatenate([neg, mid, pos]), n, as_cmap=as_cmap)</span>
<span class="gi">+    return pal</span>


<span class="gd">-def blend_palette(colors, n_colors=6, as_cmap=False, input=&#39;rgb&#39;):</span>
<span class="gi">+def blend_palette(colors, n_colors=6, as_cmap=False, input=&quot;rgb&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a palette that blends between a list of colors.

<span class="w"> </span>    Parameters
<span class="gu">@@ -395,7 +600,13 @@ def blend_palette(colors, n_colors=6, as_cmap=False, input=&#39;rgb&#39;):</span>
<span class="w"> </span>    .. include: ../docstrings/blend_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    colors = [_color_to_rgb(color, input) for color in colors]</span>
<span class="gi">+    name = &quot;blend&quot;</span>
<span class="gi">+    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)</span>
<span class="gi">+    if not as_cmap:</span>
<span class="gi">+        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]  # no alpha</span>
<span class="gi">+        pal = _ColorPalette(map(tuple, rgb_array))</span>
<span class="gi">+    return pal</span>


<span class="w"> </span>def xkcd_palette(colors):
<span class="gu">@@ -420,7 +631,8 @@ def xkcd_palette(colors):</span>
<span class="w"> </span>    crayon_palette : Make a palette with Crayola crayon colors.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    palette = [xkcd_rgb[name] for name in colors]</span>
<span class="gi">+    return color_palette(palette, len(palette))</span>


<span class="w"> </span>def crayon_palette(colors):
<span class="gu">@@ -446,11 +658,12 @@ def crayon_palette(colors):</span>
<span class="w"> </span>    xkcd_palette : Make a palette with named colors from the XKCD color survey.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    palette = [crayons[name] for name in colors]</span>
<span class="gi">+    return color_palette(palette, len(palette))</span>


<span class="gd">-def cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,</span>
<span class="gd">-    light=0.85, dark=0.15, reverse=False, as_cmap=False):</span>
<span class="gi">+def cubehelix_palette(n_colors=6, start=0, rot=.4, gamma=1.0, hue=0.8,</span>
<span class="gi">+                      light=.85, dark=.15, reverse=False, as_cmap=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a sequential palette from the cubehelix system.

<span class="w"> </span>    This produces a colormap with linearly-decreasing (or increasing)
<span class="gu">@@ -508,15 +721,82 @@ def cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,</span>
<span class="w"> </span>    .. include:: ../docstrings/cubehelix_palette.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def get_color_function(p0, p1):</span>
<span class="gi">+        # Copied from matplotlib because it lives in private module</span>
<span class="gi">+        def color(x):</span>
<span class="gi">+            # Apply gamma factor to emphasise low or high intensity values</span>
<span class="gi">+            xg = x ** gamma</span>
<span class="gi">+</span>
<span class="gi">+            # Calculate amplitude and angle of deviation from the black</span>
<span class="gi">+            # to white diagonal in the plane of constant</span>
<span class="gi">+            # perceived intensity.</span>
<span class="gi">+            a = hue * xg * (1 - xg) / 2</span>
<span class="gi">+</span>
<span class="gi">+            phi = 2 * np.pi * (start / 3 + rot * x)</span>
<span class="gi">+</span>
<span class="gi">+            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))</span>
<span class="gi">+        return color</span>
<span class="gi">+</span>
<span class="gi">+    cdict = {</span>
<span class="gi">+        &quot;red&quot;: get_color_function(-0.14861, 1.78277),</span>
<span class="gi">+        &quot;green&quot;: get_color_function(-0.29227, -0.90649),</span>
<span class="gi">+        &quot;blue&quot;: get_color_function(1.97294, 0.0),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    cmap = mpl.colors.LinearSegmentedColormap(&quot;cubehelix&quot;, cdict)</span>
<span class="gi">+</span>
<span class="gi">+    x = np.linspace(light, dark, int(n_colors))</span>
<span class="gi">+    pal = cmap(x)[:, :3].tolist()</span>
<span class="gi">+    if reverse:</span>
<span class="gi">+        pal = pal[::-1]</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        x_256 = np.linspace(light, dark, 256)</span>
<span class="gi">+        if reverse:</span>
<span class="gi">+            x_256 = x_256[::-1]</span>
<span class="gi">+        pal_256 = cmap(x_256)</span>
<span class="gi">+        cmap = mpl.colors.ListedColormap(pal_256, &quot;seaborn_cubehelix&quot;)</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _ColorPalette(pal)</span>


<span class="w"> </span>def _parse_cubehelix_args(argstr):
<span class="w"> </span>    &quot;&quot;&quot;Turn stringified cubehelix params into args/kwargs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if argstr.startswith(&quot;ch:&quot;):</span>
<span class="gi">+        argstr = argstr[3:]</span>
<span class="gi">+</span>
<span class="gi">+    if argstr.endswith(&quot;_r&quot;):</span>
<span class="gi">+        reverse = True</span>
<span class="gi">+        argstr = argstr[:-2]</span>
<span class="gi">+    else:</span>
<span class="gi">+        reverse = False</span>
<span class="gi">+</span>
<span class="gi">+    if not argstr:</span>
<span class="gi">+        return [], {&quot;reverse&quot;: reverse}</span>
<span class="gi">+</span>
<span class="gi">+    all_args = argstr.split(&quot;,&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    args = [float(a.strip(&quot; &quot;)) for a in all_args if &quot;=&quot; not in a]</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = [a.split(&quot;=&quot;) for a in all_args if &quot;=&quot; in a]</span>
<span class="gi">+    kwargs = {k.strip(&quot; &quot;): float(v.strip(&quot; &quot;)) for k, v in kwargs}</span>
<span class="gi">+</span>
<span class="gi">+    kwarg_map = dict(</span>
<span class="gi">+        s=&quot;start&quot;, r=&quot;rot&quot;, g=&quot;gamma&quot;,</span>
<span class="gi">+        h=&quot;hue&quot;, l=&quot;light&quot;, d=&quot;dark&quot;,  # noqa: E741</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {kwarg_map.get(k, k): v for k, v in kwargs.items()}</span>
<span class="gi">+</span>
<span class="gi">+    if reverse:</span>
<span class="gi">+        kwargs[&quot;reverse&quot;] = True</span>
<span class="gi">+</span>
<span class="gi">+    return args, kwargs</span>


<span class="gd">-def set_color_codes(palette=&#39;deep&#39;):</span>
<span class="gi">+def set_color_codes(palette=&quot;deep&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Change how matplotlib color shorthands are interpreted.

<span class="w"> </span>    Calling this will change how shorthand codes like &quot;b&quot; or &quot;g&quot;
<span class="gu">@@ -535,4 +815,27 @@ def set_color_codes(palette=&#39;deep&#39;):</span>
<span class="w"> </span>                  sets the matplotlib color cycle.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if palette == &quot;reset&quot;:</span>
<span class="gi">+        colors = [</span>
<span class="gi">+            (0., 0., 1.),</span>
<span class="gi">+            (0., .5, 0.),</span>
<span class="gi">+            (1., 0., 0.),</span>
<span class="gi">+            (.75, 0., .75),</span>
<span class="gi">+            (.75, .75, 0.),</span>
<span class="gi">+            (0., .75, .75),</span>
<span class="gi">+            (0., 0., 0.)</span>
<span class="gi">+        ]</span>
<span class="gi">+    elif not isinstance(palette, str):</span>
<span class="gi">+        err = &quot;set_color_codes requires a named seaborn palette&quot;</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+    elif palette in SEABORN_PALETTES:</span>
<span class="gi">+        if not palette.endswith(&quot;6&quot;):</span>
<span class="gi">+            palette = palette + &quot;6&quot;</span>
<span class="gi">+        colors = SEABORN_PALETTES[palette] + [(.1, .1, .1)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        err = f&quot;Cannot set colors with palette &#39;{palette}&#39;&quot;</span>
<span class="gi">+        raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+    for code, color in zip(&quot;bgrmyck&quot;, colors):</span>
<span class="gi">+        rgb = mpl.colors.colorConverter.to_rgb(color)</span>
<span class="gi">+        mpl.colors.colorConverter.colors[code] = rgb</span>
<span class="gh">diff --git a/seaborn/rcmod.py b/seaborn/rcmod.py</span>
<span class="gh">index 28795aea..de238323 100644</span>
<span class="gd">--- a/seaborn/rcmod.py</span>
<span class="gi">+++ b/seaborn/rcmod.py</span>
<span class="gu">@@ -3,27 +3,84 @@ import functools</span>
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from cycler import cycler
<span class="w"> </span>from . import palettes
<span class="gd">-__all__ = [&#39;set_theme&#39;, &#39;set&#39;, &#39;reset_defaults&#39;, &#39;reset_orig&#39;, &#39;axes_style&#39;,</span>
<span class="gd">-    &#39;set_style&#39;, &#39;plotting_context&#39;, &#39;set_context&#39;, &#39;set_palette&#39;]</span>
<span class="gd">-_style_keys = [&#39;axes.facecolor&#39;, &#39;axes.edgecolor&#39;, &#39;axes.grid&#39;,</span>
<span class="gd">-    &#39;axes.axisbelow&#39;, &#39;axes.labelcolor&#39;, &#39;figure.facecolor&#39;, &#39;grid.color&#39;,</span>
<span class="gd">-    &#39;grid.linestyle&#39;, &#39;text.color&#39;, &#39;xtick.color&#39;, &#39;ytick.color&#39;,</span>
<span class="gd">-    &#39;xtick.direction&#39;, &#39;ytick.direction&#39;, &#39;lines.solid_capstyle&#39;,</span>
<span class="gd">-    &#39;patch.edgecolor&#39;, &#39;patch.force_edgecolor&#39;, &#39;image.cmap&#39;, &#39;font.family&#39;,</span>
<span class="gd">-    &#39;font.sans-serif&#39;, &#39;xtick.bottom&#39;, &#39;xtick.top&#39;, &#39;ytick.left&#39;,</span>
<span class="gd">-    &#39;ytick.right&#39;, &#39;axes.spines.left&#39;, &#39;axes.spines.bottom&#39;,</span>
<span class="gd">-    &#39;axes.spines.right&#39;, &#39;axes.spines.top&#39;]</span>
<span class="gd">-_context_keys = [&#39;font.size&#39;, &#39;axes.labelsize&#39;, &#39;axes.titlesize&#39;,</span>
<span class="gd">-    &#39;xtick.labelsize&#39;, &#39;ytick.labelsize&#39;, &#39;legend.fontsize&#39;,</span>
<span class="gd">-    &#39;legend.title_fontsize&#39;, &#39;axes.linewidth&#39;, &#39;grid.linewidth&#39;,</span>
<span class="gd">-    &#39;lines.linewidth&#39;, &#39;lines.markersize&#39;, &#39;patch.linewidth&#39;,</span>
<span class="gd">-    &#39;xtick.major.width&#39;, &#39;ytick.major.width&#39;, &#39;xtick.minor.width&#39;,</span>
<span class="gd">-    &#39;ytick.minor.width&#39;, &#39;xtick.major.size&#39;, &#39;ytick.major.size&#39;,</span>
<span class="gd">-    &#39;xtick.minor.size&#39;, &#39;ytick.minor.size&#39;]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def set_theme(context=&#39;notebook&#39;, style=&#39;darkgrid&#39;, palette=&#39;deep&#39;, font=</span>
<span class="gd">-    &#39;sans-serif&#39;, font_scale=1, color_codes=True, rc=None):</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;set_theme&quot;, &quot;set&quot;, &quot;reset_defaults&quot;, &quot;reset_orig&quot;,</span>
<span class="gi">+           &quot;axes_style&quot;, &quot;set_style&quot;, &quot;plotting_context&quot;, &quot;set_context&quot;,</span>
<span class="gi">+           &quot;set_palette&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_style_keys = [</span>
<span class="gi">+</span>
<span class="gi">+    &quot;axes.facecolor&quot;,</span>
<span class="gi">+    &quot;axes.edgecolor&quot;,</span>
<span class="gi">+    &quot;axes.grid&quot;,</span>
<span class="gi">+    &quot;axes.axisbelow&quot;,</span>
<span class="gi">+    &quot;axes.labelcolor&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;figure.facecolor&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;grid.color&quot;,</span>
<span class="gi">+    &quot;grid.linestyle&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;text.color&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;xtick.color&quot;,</span>
<span class="gi">+    &quot;ytick.color&quot;,</span>
<span class="gi">+    &quot;xtick.direction&quot;,</span>
<span class="gi">+    &quot;ytick.direction&quot;,</span>
<span class="gi">+    &quot;lines.solid_capstyle&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;patch.edgecolor&quot;,</span>
<span class="gi">+    &quot;patch.force_edgecolor&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;image.cmap&quot;,</span>
<span class="gi">+    &quot;font.family&quot;,</span>
<span class="gi">+    &quot;font.sans-serif&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;xtick.bottom&quot;,</span>
<span class="gi">+    &quot;xtick.top&quot;,</span>
<span class="gi">+    &quot;ytick.left&quot;,</span>
<span class="gi">+    &quot;ytick.right&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;axes.spines.left&quot;,</span>
<span class="gi">+    &quot;axes.spines.bottom&quot;,</span>
<span class="gi">+    &quot;axes.spines.right&quot;,</span>
<span class="gi">+    &quot;axes.spines.top&quot;,</span>
<span class="gi">+</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+_context_keys = [</span>
<span class="gi">+</span>
<span class="gi">+    &quot;font.size&quot;,</span>
<span class="gi">+    &quot;axes.labelsize&quot;,</span>
<span class="gi">+    &quot;axes.titlesize&quot;,</span>
<span class="gi">+    &quot;xtick.labelsize&quot;,</span>
<span class="gi">+    &quot;ytick.labelsize&quot;,</span>
<span class="gi">+    &quot;legend.fontsize&quot;,</span>
<span class="gi">+    &quot;legend.title_fontsize&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;axes.linewidth&quot;,</span>
<span class="gi">+    &quot;grid.linewidth&quot;,</span>
<span class="gi">+    &quot;lines.linewidth&quot;,</span>
<span class="gi">+    &quot;lines.markersize&quot;,</span>
<span class="gi">+    &quot;patch.linewidth&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;xtick.major.width&quot;,</span>
<span class="gi">+    &quot;ytick.major.width&quot;,</span>
<span class="gi">+    &quot;xtick.minor.width&quot;,</span>
<span class="gi">+    &quot;ytick.minor.width&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    &quot;xtick.major.size&quot;,</span>
<span class="gi">+    &quot;ytick.major.size&quot;,</span>
<span class="gi">+    &quot;xtick.minor.size&quot;,</span>
<span class="gi">+    &quot;ytick.minor.size&quot;,</span>
<span class="gi">+</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def set_theme(context=&quot;notebook&quot;, style=&quot;darkgrid&quot;, palette=&quot;deep&quot;,</span>
<span class="gi">+              font=&quot;sans-serif&quot;, font_scale=1, color_codes=True, rc=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Set aspects of the visual theme for all matplotlib and seaborn plots.

<span class="gu">@@ -59,7 +116,11 @@ def set_theme(context=&#39;notebook&#39;, style=&#39;darkgrid&#39;, palette=&#39;deep&#39;, font=</span>
<span class="w"> </span>    .. include:: ../docstrings/set_theme.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_context(context, font_scale)</span>
<span class="gi">+    set_style(style, rc={&quot;font.family&quot;: font})</span>
<span class="gi">+    set_palette(palette, color_codes=color_codes)</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        mpl.rcParams.update(rc)</span>


<span class="w"> </span>def set(*args, **kwargs):
<span class="gu">@@ -68,17 +129,18 @@ def set(*args, **kwargs):</span>

<span class="w"> </span>    This function may be removed in the future.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_theme(*args, **kwargs)</span>


<span class="w"> </span>def reset_defaults():
<span class="w"> </span>    &quot;&quot;&quot;Restore all RC params to default settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mpl.rcParams.update(mpl.rcParamsDefault)</span>


<span class="w"> </span>def reset_orig():
<span class="w"> </span>    &quot;&quot;&quot;Restore all RC params to original settings (respects custom rc).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from . import _orig_rc_params</span>
<span class="gi">+    mpl.rcParams.update(_orig_rc_params)</span>


<span class="w"> </span>def axes_style(style=None, rc=None):
<span class="gu">@@ -111,7 +173,131 @@ def axes_style(style=None, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/axes_style.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if style is None:</span>
<span class="gi">+        style_dict = {k: mpl.rcParams[k] for k in _style_keys}</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(style, dict):</span>
<span class="gi">+        style_dict = style</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        styles = [&quot;white&quot;, &quot;dark&quot;, &quot;whitegrid&quot;, &quot;darkgrid&quot;, &quot;ticks&quot;]</span>
<span class="gi">+        if style not in styles:</span>
<span class="gi">+            raise ValueError(f&quot;style must be one of {&#39;, &#39;.join(styles)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Define colors here</span>
<span class="gi">+        dark_gray = &quot;.15&quot;</span>
<span class="gi">+        light_gray = &quot;.8&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Common parameters</span>
<span class="gi">+        style_dict = {</span>
<span class="gi">+</span>
<span class="gi">+            &quot;figure.facecolor&quot;: &quot;white&quot;,</span>
<span class="gi">+            &quot;axes.labelcolor&quot;: dark_gray,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;xtick.direction&quot;: &quot;out&quot;,</span>
<span class="gi">+            &quot;ytick.direction&quot;: &quot;out&quot;,</span>
<span class="gi">+            &quot;xtick.color&quot;: dark_gray,</span>
<span class="gi">+            &quot;ytick.color&quot;: dark_gray,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;axes.axisbelow&quot;: True,</span>
<span class="gi">+            &quot;grid.linestyle&quot;: &quot;-&quot;,</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+            &quot;text.color&quot;: dark_gray,</span>
<span class="gi">+            &quot;font.family&quot;: [&quot;sans-serif&quot;],</span>
<span class="gi">+            &quot;font.sans-serif&quot;: [&quot;Arial&quot;, &quot;DejaVu Sans&quot;, &quot;Liberation Sans&quot;,</span>
<span class="gi">+                                &quot;Bitstream Vera Sans&quot;, &quot;sans-serif&quot;],</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+            &quot;lines.solid_capstyle&quot;: &quot;round&quot;,</span>
<span class="gi">+            &quot;patch.edgecolor&quot;: &quot;w&quot;,</span>
<span class="gi">+            &quot;patch.force_edgecolor&quot;: True,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;image.cmap&quot;: &quot;rocket&quot;,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;xtick.top&quot;: False,</span>
<span class="gi">+            &quot;ytick.right&quot;: False,</span>
<span class="gi">+</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Set grid on or off</span>
<span class="gi">+        if &quot;grid&quot; in style:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+                &quot;axes.grid&quot;: True,</span>
<span class="gi">+            })</span>
<span class="gi">+        else:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+                &quot;axes.grid&quot;: False,</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        # Set the color of the background, spines, and grids</span>
<span class="gi">+        if style.startswith(&quot;dark&quot;):</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.facecolor&quot;: &quot;#EAEAF2&quot;,</span>
<span class="gi">+                &quot;axes.edgecolor&quot;: &quot;white&quot;,</span>
<span class="gi">+                &quot;grid.color&quot;: &quot;white&quot;,</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.spines.left&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.bottom&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.right&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.top&quot;: True,</span>
<span class="gi">+</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        elif style == &quot;whitegrid&quot;:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.facecolor&quot;: &quot;white&quot;,</span>
<span class="gi">+                &quot;axes.edgecolor&quot;: light_gray,</span>
<span class="gi">+                &quot;grid.color&quot;: light_gray,</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.spines.left&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.bottom&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.right&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.top&quot;: True,</span>
<span class="gi">+</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        elif style in [&quot;white&quot;, &quot;ticks&quot;]:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.facecolor&quot;: &quot;white&quot;,</span>
<span class="gi">+                &quot;axes.edgecolor&quot;: dark_gray,</span>
<span class="gi">+                &quot;grid.color&quot;: light_gray,</span>
<span class="gi">+</span>
<span class="gi">+                &quot;axes.spines.left&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.bottom&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.right&quot;: True,</span>
<span class="gi">+                &quot;axes.spines.top&quot;: True,</span>
<span class="gi">+</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        # Show or hide the axes ticks</span>
<span class="gi">+        if style == &quot;ticks&quot;:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+                &quot;xtick.bottom&quot;: True,</span>
<span class="gi">+                &quot;ytick.left&quot;: True,</span>
<span class="gi">+            })</span>
<span class="gi">+        else:</span>
<span class="gi">+            style_dict.update({</span>
<span class="gi">+                &quot;xtick.bottom&quot;: False,</span>
<span class="gi">+                &quot;ytick.left&quot;: False,</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+    # Remove entries that are not defined in the base list of valid keys</span>
<span class="gi">+    # This lets us handle matplotlib &lt;=/&gt; 2.0</span>
<span class="gi">+    style_dict = {k: v for k, v in style_dict.items() if k in _style_keys}</span>
<span class="gi">+</span>
<span class="gi">+    # Override these settings with the provided rc dictionary</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        rc = {k: v for k, v in rc.items() if k in _style_keys}</span>
<span class="gi">+        style_dict.update(rc)</span>
<span class="gi">+</span>
<span class="gi">+    # Wrap in an _AxesStyle object so this can be used in a with statement</span>
<span class="gi">+    style_object = _AxesStyle(style_dict)</span>
<span class="gi">+</span>
<span class="gi">+    return style_object</span>


<span class="w"> </span>def set_style(style=None, rc=None):
<span class="gu">@@ -142,7 +328,8 @@ def set_style(style=None, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/set_style.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    style_object = axes_style(style, rc)</span>
<span class="gi">+    mpl.rcParams.update(style_object)</span>


<span class="w"> </span>def plotting_context(context=None, font_scale=1, rc=None):
<span class="gu">@@ -179,7 +366,70 @@ def plotting_context(context=None, font_scale=1, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/plotting_context.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if context is None:</span>
<span class="gi">+        context_dict = {k: mpl.rcParams[k] for k in _context_keys}</span>
<span class="gi">+</span>
<span class="gi">+    elif isinstance(context, dict):</span>
<span class="gi">+        context_dict = context</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        contexts = [&quot;paper&quot;, &quot;notebook&quot;, &quot;talk&quot;, &quot;poster&quot;]</span>
<span class="gi">+        if context not in contexts:</span>
<span class="gi">+            raise ValueError(f&quot;context must be in {&#39;, &#39;.join(contexts)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Set up dictionary of default parameters</span>
<span class="gi">+        texts_base_context = {</span>
<span class="gi">+</span>
<span class="gi">+            &quot;font.size&quot;: 12,</span>
<span class="gi">+            &quot;axes.labelsize&quot;: 12,</span>
<span class="gi">+            &quot;axes.titlesize&quot;: 12,</span>
<span class="gi">+            &quot;xtick.labelsize&quot;: 11,</span>
<span class="gi">+            &quot;ytick.labelsize&quot;: 11,</span>
<span class="gi">+            &quot;legend.fontsize&quot;: 11,</span>
<span class="gi">+            &quot;legend.title_fontsize&quot;: 12,</span>
<span class="gi">+</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        base_context = {</span>
<span class="gi">+</span>
<span class="gi">+            &quot;axes.linewidth&quot;: 1.25,</span>
<span class="gi">+            &quot;grid.linewidth&quot;: 1,</span>
<span class="gi">+            &quot;lines.linewidth&quot;: 1.5,</span>
<span class="gi">+            &quot;lines.markersize&quot;: 6,</span>
<span class="gi">+            &quot;patch.linewidth&quot;: 1,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;xtick.major.width&quot;: 1.25,</span>
<span class="gi">+            &quot;ytick.major.width&quot;: 1.25,</span>
<span class="gi">+            &quot;xtick.minor.width&quot;: 1,</span>
<span class="gi">+            &quot;ytick.minor.width&quot;: 1,</span>
<span class="gi">+</span>
<span class="gi">+            &quot;xtick.major.size&quot;: 6,</span>
<span class="gi">+            &quot;ytick.major.size&quot;: 6,</span>
<span class="gi">+            &quot;xtick.minor.size&quot;: 4,</span>
<span class="gi">+            &quot;ytick.minor.size&quot;: 4,</span>
<span class="gi">+</span>
<span class="gi">+        }</span>
<span class="gi">+        base_context.update(texts_base_context)</span>
<span class="gi">+</span>
<span class="gi">+        # Scale all the parameters by the same factor depending on the context</span>
<span class="gi">+        scaling = dict(paper=.8, notebook=1, talk=1.5, poster=2)[context]</span>
<span class="gi">+        context_dict = {k: v * scaling for k, v in base_context.items()}</span>
<span class="gi">+</span>
<span class="gi">+        # Now independently scale the fonts</span>
<span class="gi">+        font_keys = texts_base_context.keys()</span>
<span class="gi">+        font_dict = {k: context_dict[k] * font_scale for k in font_keys}</span>
<span class="gi">+        context_dict.update(font_dict)</span>
<span class="gi">+</span>
<span class="gi">+    # Override these settings with the provided rc dictionary</span>
<span class="gi">+    if rc is not None:</span>
<span class="gi">+        rc = {k: v for k, v in rc.items() if k in _context_keys}</span>
<span class="gi">+        context_dict.update(rc)</span>
<span class="gi">+</span>
<span class="gi">+    # Wrap in a _PlottingContext object so this can be used in a with statement</span>
<span class="gi">+    context_object = _PlottingContext(context_dict)</span>
<span class="gi">+</span>
<span class="gi">+    return context_object</span>


<span class="w"> </span>def set_context(context=None, font_scale=1, rc=None):
<span class="gu">@@ -215,11 +465,11 @@ def set_context(context=None, font_scale=1, rc=None):</span>
<span class="w"> </span>    .. include:: ../docstrings/set_context.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context_object = plotting_context(context, font_scale, rc)</span>
<span class="gi">+    mpl.rcParams.update(context_object)</span>


<span class="w"> </span>class _RCAesthetics(dict):
<span class="gd">-</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        rc = mpl.rcParams
<span class="w"> </span>        self._orig = {k: rc[k] for k in self._keys}
<span class="gu">@@ -229,7 +479,6 @@ class _RCAesthetics(dict):</span>
<span class="w"> </span>        self._set(self._orig)

<span class="w"> </span>    def __call__(self, func):
<span class="gd">-</span>
<span class="w"> </span>        @functools.wraps(func)
<span class="w"> </span>        def wrapper(*args, **kwargs):
<span class="w"> </span>            with self:
<span class="gu">@@ -274,4 +523,11 @@ def set_palette(palette, n_colors=None, desat=None, color_codes=False):</span>
<span class="w"> </span>    set_style : set the default parameters for figure style

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    colors = palettes.color_palette(palette, n_colors, desat)</span>
<span class="gi">+    cyl = cycler(&#39;color&#39;, colors)</span>
<span class="gi">+    mpl.rcParams[&#39;axes.prop_cycle&#39;] = cyl</span>
<span class="gi">+    if color_codes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            palettes.set_color_codes(palette)</span>
<span class="gi">+        except (ValueError, TypeError):</span>
<span class="gi">+            pass</span>
<span class="gh">diff --git a/seaborn/regression.py b/seaborn/regression.py</span>
<span class="gh">index 9a41fe79..5e5503a4 100644</span>
<span class="gd">--- a/seaborn/regression.py</span>
<span class="gi">+++ b/seaborn/regression.py</span>
<span class="gu">@@ -6,16 +6,20 @@ import numpy as np</span>
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import statsmodels
<span class="w"> </span>    assert statsmodels
<span class="w"> </span>    _has_statsmodels = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    _has_statsmodels = False
<span class="gi">+</span>
<span class="w"> </span>from . import utils
<span class="w"> </span>from . import algorithms as algo
<span class="w"> </span>from .axisgrid import FacetGrid, _facet_docs
<span class="gd">-__all__ = [&#39;lmplot&#39;, &#39;regplot&#39;, &#39;residplot&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;lmplot&quot;, &quot;regplot&quot;, &quot;residplot&quot;]</span>


<span class="w"> </span>class _LinearPlotter:
<span class="gu">@@ -25,14 +29,42 @@ class _LinearPlotter:</span>
<span class="w"> </span>    code that can be abstracted out should be put here.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def establish_variables(self, data, **kws):
<span class="w"> </span>        &quot;&quot;&quot;Extract variables from data or use directly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.data = data</span>
<span class="gi">+</span>
<span class="gi">+        # Validate the inputs</span>
<span class="gi">+        any_strings = any([isinstance(v, str) for v in kws.values()])</span>
<span class="gi">+        if any_strings and data is None:</span>
<span class="gi">+            raise ValueError(&quot;Must pass `data` if using named variables.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Set the variables</span>
<span class="gi">+        for var, val in kws.items():</span>
<span class="gi">+            if isinstance(val, str):</span>
<span class="gi">+                vector = data[val]</span>
<span class="gi">+            elif isinstance(val, list):</span>
<span class="gi">+                vector = np.asarray(val)</span>
<span class="gi">+            else:</span>
<span class="gi">+                vector = val</span>
<span class="gi">+            if vector is not None and vector.shape != (1,):</span>
<span class="gi">+                vector = np.squeeze(vector)</span>
<span class="gi">+            if np.ndim(vector) &gt; 1:</span>
<span class="gi">+                err = &quot;regplot inputs must be 1d&quot;</span>
<span class="gi">+                raise ValueError(err)</span>
<span class="gi">+            setattr(self, var, vector)</span>

<span class="w"> </span>    def dropna(self, *vars):
<span class="w"> </span>        &quot;&quot;&quot;Remove observations with missing data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vals = [getattr(self, var) for var in vars]</span>
<span class="gi">+        vals = [v for v in vals if v is not None]</span>
<span class="gi">+        not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)</span>
<span class="gi">+        for var in vars:</span>
<span class="gi">+            val = getattr(self, var)</span>
<span class="gi">+            if val is not None:</span>
<span class="gi">+                setattr(self, var, val[not_na])</span>
<span class="gi">+</span>
<span class="gi">+    def plot(self, ax):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class _RegressionPlotter(_LinearPlotter):
<span class="gu">@@ -41,15 +73,17 @@ class _RegressionPlotter(_LinearPlotter):</span>
<span class="w"> </span>    This does the computations and drawing for the `regplot` function, and
<span class="w"> </span>    is thus also used indirectly by `lmplot`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None, x_ci</span>
<span class="gd">-        =&#39;ci&#39;, scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,</span>
<span class="gd">-        seed=None, order=1, logistic=False, lowess=False, robust=False,</span>
<span class="gd">-        logx=False, x_partial=None, y_partial=None, truncate=False, dropna=</span>
<span class="gd">-        True, x_jitter=None, y_jitter=None, color=None, label=None):</span>
<span class="gi">+    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,</span>
<span class="gi">+                 x_ci=&quot;ci&quot;, scatter=True, fit_reg=True, ci=95, n_boot=1000,</span>
<span class="gi">+                 units=None, seed=None, order=1, logistic=False, lowess=False,</span>
<span class="gi">+                 robust=False, logx=False, x_partial=None, y_partial=None,</span>
<span class="gi">+                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,</span>
<span class="gi">+                 color=None, label=None):</span>
<span class="gi">+</span>
<span class="gi">+        # Set member attributes</span>
<span class="w"> </span>        self.x_estimator = x_estimator
<span class="w"> </span>        self.ci = ci
<span class="gd">-        self.x_ci = ci if x_ci == &#39;ci&#39; else x_ci</span>
<span class="gi">+        self.x_ci = ci if x_ci == &quot;ci&quot; else x_ci</span>
<span class="w"> </span>        self.n_boot = n_boot
<span class="w"> </span>        self.seed = seed
<span class="w"> </span>        self.scatter = scatter
<span class="gu">@@ -64,196 +98,567 @@ class _RegressionPlotter(_LinearPlotter):</span>
<span class="w"> </span>        self.y_jitter = y_jitter
<span class="w"> </span>        self.color = color
<span class="w"> </span>        self.label = label
<span class="gi">+</span>
<span class="gi">+        # Validate the regression options:</span>
<span class="w"> </span>        if sum((order &gt; 1, logistic, robust, lowess, logx)) &gt; 1:
<span class="gd">-            raise ValueError(&#39;Mutually exclusive regression options.&#39;)</span>
<span class="gd">-        self.establish_variables(data, x=x, y=y, units=units, x_partial=</span>
<span class="gd">-            x_partial, y_partial=y_partial)</span>
<span class="gi">+            raise ValueError(&quot;Mutually exclusive regression options.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Extract the data vals from the arguments or passed dataframe</span>
<span class="gi">+        self.establish_variables(data, x=x, y=y, units=units,</span>
<span class="gi">+                                 x_partial=x_partial, y_partial=y_partial)</span>
<span class="gi">+</span>
<span class="gi">+        # Drop null observations</span>
<span class="w"> </span>        if dropna:
<span class="gd">-            self.dropna(&#39;x&#39;, &#39;y&#39;, &#39;units&#39;, &#39;x_partial&#39;, &#39;y_partial&#39;)</span>
<span class="gi">+            self.dropna(&quot;x&quot;, &quot;y&quot;, &quot;units&quot;, &quot;x_partial&quot;, &quot;y_partial&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Regress nuisance variables out of the data</span>
<span class="w"> </span>        if self.x_partial is not None:
<span class="w"> </span>            self.x = self.regress_out(self.x, self.x_partial)
<span class="w"> </span>        if self.y_partial is not None:
<span class="w"> </span>            self.y = self.regress_out(self.y, self.y_partial)
<span class="gi">+</span>
<span class="gi">+        # Possibly bin the predictor variable, which implies a point estimate</span>
<span class="w"> </span>        if x_bins is not None:
<span class="w"> </span>            self.x_estimator = np.mean if x_estimator is None else x_estimator
<span class="w"> </span>            x_discrete, x_bins = self.bin_predictor(x_bins)
<span class="w"> </span>            self.x_discrete = x_discrete
<span class="w"> </span>        else:
<span class="w"> </span>            self.x_discrete = self.x
<span class="gi">+</span>
<span class="gi">+        # Disable regression in case of singleton inputs</span>
<span class="w"> </span>        if len(self.x) &lt;= 1:
<span class="w"> </span>            self.fit_reg = False
<span class="gi">+</span>
<span class="gi">+        # Save the range of the x variable for the grid later</span>
<span class="w"> </span>        if self.fit_reg:
<span class="w"> </span>            self.x_range = self.x.min(), self.x.max()

<span class="w"> </span>    @property
<span class="w"> </span>    def scatter_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Data where each observation is a point.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x_j = self.x_jitter</span>
<span class="gi">+        if x_j is None:</span>
<span class="gi">+            x = self.x</span>
<span class="gi">+        else:</span>
<span class="gi">+            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))</span>
<span class="gi">+</span>
<span class="gi">+        y_j = self.y_jitter</span>
<span class="gi">+        if y_j is None:</span>
<span class="gi">+            y = self.y</span>
<span class="gi">+        else:</span>
<span class="gi">+            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))</span>
<span class="gi">+</span>
<span class="gi">+        return x, y</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def estimate_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Data with a point estimate and CI for each discrete x value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x, y = self.x_discrete, self.y</span>
<span class="gi">+        vals = sorted(np.unique(x))</span>
<span class="gi">+        points, cis = [], []</span>
<span class="gi">+</span>
<span class="gi">+        for val in vals:</span>
<span class="gi">+</span>
<span class="gi">+            # Get the point estimate of the y variable</span>
<span class="gi">+            _y = y[x == val]</span>
<span class="gi">+            est = self.x_estimator(_y)</span>
<span class="gi">+            points.append(est)</span>
<span class="gi">+</span>
<span class="gi">+            # Compute the confidence interval for this estimate</span>
<span class="gi">+            if self.x_ci is None:</span>
<span class="gi">+                cis.append(None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                units = None</span>
<span class="gi">+                if self.x_ci == &quot;sd&quot;:</span>
<span class="gi">+                    sd = np.std(_y)</span>
<span class="gi">+                    _ci = est - sd, est + sd</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.units is not None:</span>
<span class="gi">+                        units = self.units[x == val]</span>
<span class="gi">+                    boots = algo.bootstrap(_y,</span>
<span class="gi">+                                           func=self.x_estimator,</span>
<span class="gi">+                                           n_boot=self.n_boot,</span>
<span class="gi">+                                           units=units,</span>
<span class="gi">+                                           seed=self.seed)</span>
<span class="gi">+                    _ci = utils.ci(boots, self.x_ci)</span>
<span class="gi">+                cis.append(_ci)</span>
<span class="gi">+</span>
<span class="gi">+        return vals, points, cis</span>

<span class="w"> </span>    def _check_statsmodels(self):
<span class="w"> </span>        &quot;&quot;&quot;Check whether statsmodels is installed if any boolean options require it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options = &quot;logistic&quot;, &quot;robust&quot;, &quot;lowess&quot;</span>
<span class="gi">+        err = &quot;`{}=True` requires statsmodels, an optional dependency, to be installed.&quot;</span>
<span class="gi">+        for option in options:</span>
<span class="gi">+            if getattr(self, option) and not _has_statsmodels:</span>
<span class="gi">+                raise RuntimeError(err.format(option))</span>

<span class="w"> </span>    def fit_regression(self, ax=None, x_range=None, grid=None):
<span class="w"> </span>        &quot;&quot;&quot;Fit the regression model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_statsmodels()</span>
<span class="gi">+</span>
<span class="gi">+        # Create the grid for the regression</span>
<span class="gi">+        if grid is None:</span>
<span class="gi">+            if self.truncate:</span>
<span class="gi">+                x_min, x_max = self.x_range</span>
<span class="gi">+            else:</span>
<span class="gi">+                if ax is None:</span>
<span class="gi">+                    x_min, x_max = x_range</span>
<span class="gi">+                else:</span>
<span class="gi">+                    x_min, x_max = ax.get_xlim()</span>
<span class="gi">+            grid = np.linspace(x_min, x_max, 100)</span>
<span class="gi">+        ci = self.ci</span>
<span class="gi">+</span>
<span class="gi">+        # Fit the regression</span>
<span class="gi">+        if self.order &gt; 1:</span>
<span class="gi">+            yhat, yhat_boots = self.fit_poly(grid, self.order)</span>
<span class="gi">+        elif self.logistic:</span>
<span class="gi">+            from statsmodels.genmod.generalized_linear_model import GLM</span>
<span class="gi">+            from statsmodels.genmod.families import Binomial</span>
<span class="gi">+            yhat, yhat_boots = self.fit_statsmodels(grid, GLM,</span>
<span class="gi">+                                                    family=Binomial())</span>
<span class="gi">+        elif self.lowess:</span>
<span class="gi">+            ci = None</span>
<span class="gi">+            grid, yhat = self.fit_lowess()</span>
<span class="gi">+        elif self.robust:</span>
<span class="gi">+            from statsmodels.robust.robust_linear_model import RLM</span>
<span class="gi">+            yhat, yhat_boots = self.fit_statsmodels(grid, RLM)</span>
<span class="gi">+        elif self.logx:</span>
<span class="gi">+            yhat, yhat_boots = self.fit_logx(grid)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yhat, yhat_boots = self.fit_fast(grid)</span>
<span class="gi">+</span>
<span class="gi">+        # Compute the confidence interval at each grid point</span>
<span class="gi">+        if ci is None:</span>
<span class="gi">+            err_bands = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            err_bands = utils.ci(yhat_boots, ci, axis=0)</span>
<span class="gi">+</span>
<span class="gi">+        return grid, yhat, err_bands</span>

<span class="w"> </span>    def fit_fast(self, grid):
<span class="w"> </span>        &quot;&quot;&quot;Low-level regression and prediction using linear algebra.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            return np.linalg.pinv(_x).dot(_y)</span>
<span class="gi">+</span>
<span class="gi">+        X, y = np.c_[np.ones(len(self.x)), self.x], self.y</span>
<span class="gi">+        grid = np.c_[np.ones(len(grid)), grid]</span>
<span class="gi">+        yhat = grid.dot(reg_func(X, y))</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat, None</span>
<span class="gi">+</span>
<span class="gi">+        beta_boots = algo.bootstrap(X, y,</span>
<span class="gi">+                                    func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot,</span>
<span class="gi">+                                    units=self.units,</span>
<span class="gi">+                                    seed=self.seed).T</span>
<span class="gi">+        yhat_boots = grid.dot(beta_boots).T</span>
<span class="gi">+        return yhat, yhat_boots</span>

<span class="w"> </span>    def fit_poly(self, grid, order):
<span class="w"> </span>        &quot;&quot;&quot;Regression using numpy polyfit for higher-order trends.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            return np.polyval(np.polyfit(_x, _y, order), grid)</span>
<span class="gi">+</span>
<span class="gi">+        x, y = self.x, self.y</span>
<span class="gi">+        yhat = reg_func(x, y)</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat, None</span>
<span class="gi">+</span>
<span class="gi">+        yhat_boots = algo.bootstrap(x, y,</span>
<span class="gi">+                                    func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot,</span>
<span class="gi">+                                    units=self.units,</span>
<span class="gi">+                                    seed=self.seed)</span>
<span class="gi">+        return yhat, yhat_boots</span>

<span class="w"> </span>    def fit_statsmodels(self, grid, model, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;More general regression function using statsmodels objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import statsmodels.tools.sm_exceptions as sme</span>
<span class="gi">+        X, y = np.c_[np.ones(len(self.x)), self.x], self.y</span>
<span class="gi">+        grid = np.c_[np.ones(len(grid)), grid]</span>
<span class="gi">+</span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            err_classes = (sme.PerfectSeparationError,)</span>
<span class="gi">+            try:</span>
<span class="gi">+                with warnings.catch_warnings():</span>
<span class="gi">+                    if hasattr(sme, &quot;PerfectSeparationWarning&quot;):</span>
<span class="gi">+                        # statsmodels&gt;=0.14.0</span>
<span class="gi">+                        warnings.simplefilter(&quot;error&quot;, sme.PerfectSeparationWarning)</span>
<span class="gi">+                        err_classes = (*err_classes, sme.PerfectSeparationWarning)</span>
<span class="gi">+                    yhat = model(_y, _x, **kwargs).fit().predict(grid)</span>
<span class="gi">+            except err_classes:</span>
<span class="gi">+                yhat = np.empty(len(grid))</span>
<span class="gi">+                yhat.fill(np.nan)</span>
<span class="gi">+            return yhat</span>
<span class="gi">+</span>
<span class="gi">+        yhat = reg_func(X, y)</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat, None</span>
<span class="gi">+</span>
<span class="gi">+        yhat_boots = algo.bootstrap(X, y,</span>
<span class="gi">+                                    func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot,</span>
<span class="gi">+                                    units=self.units,</span>
<span class="gi">+                                    seed=self.seed)</span>
<span class="gi">+        return yhat, yhat_boots</span>

<span class="w"> </span>    def fit_lowess(self):
<span class="w"> </span>        &quot;&quot;&quot;Fit a locally-weighted regression, which returns its own grid.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from statsmodels.nonparametric.smoothers_lowess import lowess</span>
<span class="gi">+        grid, yhat = lowess(self.y, self.x).T</span>
<span class="gi">+        return grid, yhat</span>

<span class="w"> </span>    def fit_logx(self, grid):
<span class="w"> </span>        &quot;&quot;&quot;Fit the model in log-space.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        X, y = np.c_[np.ones(len(self.x)), self.x], self.y</span>
<span class="gi">+        grid = np.c_[np.ones(len(grid)), np.log(grid)]</span>
<span class="gi">+</span>
<span class="gi">+        def reg_func(_x, _y):</span>
<span class="gi">+            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]</span>
<span class="gi">+            return np.linalg.pinv(_x).dot(_y)</span>
<span class="gi">+</span>
<span class="gi">+        yhat = grid.dot(reg_func(X, y))</span>
<span class="gi">+        if self.ci is None:</span>
<span class="gi">+            return yhat, None</span>
<span class="gi">+</span>
<span class="gi">+        beta_boots = algo.bootstrap(X, y,</span>
<span class="gi">+                                    func=reg_func,</span>
<span class="gi">+                                    n_boot=self.n_boot,</span>
<span class="gi">+                                    units=self.units,</span>
<span class="gi">+                                    seed=self.seed).T</span>
<span class="gi">+        yhat_boots = grid.dot(beta_boots).T</span>
<span class="gi">+        return yhat, yhat_boots</span>

<span class="w"> </span>    def bin_predictor(self, bins):
<span class="w"> </span>        &quot;&quot;&quot;Discretize a predictor by assigning value to closest bin.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = np.asarray(self.x)</span>
<span class="gi">+        if np.isscalar(bins):</span>
<span class="gi">+            percentiles = np.linspace(0, 100, bins + 2)[1:-1]</span>
<span class="gi">+            bins = np.percentile(x, percentiles)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bins = np.ravel(bins)</span>
<span class="gi">+</span>
<span class="gi">+        dist = np.abs(np.subtract.outer(x, bins))</span>
<span class="gi">+        x_binned = bins[np.argmin(dist, axis=1)].ravel()</span>
<span class="gi">+</span>
<span class="gi">+        return x_binned, bins</span>

<span class="w"> </span>    def regress_out(self, a, b):
<span class="w"> </span>        &quot;&quot;&quot;Regress b from a keeping a&#39;s original mean.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        a_mean = a.mean()</span>
<span class="gi">+        a = a - a_mean</span>
<span class="gi">+        b = b - b.mean()</span>
<span class="gi">+        b = np.c_[b]</span>
<span class="gi">+        a_prime = a - b.dot(np.linalg.pinv(b).dot(a))</span>
<span class="gi">+        return np.asarray(a_prime + a_mean).reshape(a.shape)</span>

<span class="w"> </span>    def plot(self, ax, scatter_kws, line_kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the full plot.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Insert the plot label into the correct set of keyword arguments</span>
<span class="gi">+        if self.scatter:</span>
<span class="gi">+            scatter_kws[&quot;label&quot;] = self.label</span>
<span class="gi">+        else:</span>
<span class="gi">+            line_kws[&quot;label&quot;] = self.label</span>
<span class="gi">+</span>
<span class="gi">+        # Use the current color cycle state as a default</span>
<span class="gi">+        if self.color is None:</span>
<span class="gi">+            lines, = ax.plot([], [])</span>
<span class="gi">+            color = lines.get_color()</span>
<span class="gi">+            lines.remove()</span>
<span class="gi">+        else:</span>
<span class="gi">+            color = self.color</span>
<span class="gi">+</span>
<span class="gi">+        # Ensure that color is hex to avoid matplotlib weirdness</span>
<span class="gi">+        color = mpl.colors.rgb2hex(mpl.colors.colorConverter.to_rgb(color))</span>
<span class="gi">+</span>
<span class="gi">+        # Let color in keyword arguments override overall plot color</span>
<span class="gi">+        scatter_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+        line_kws.setdefault(&quot;color&quot;, color)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the constituent plots</span>
<span class="gi">+        if self.scatter:</span>
<span class="gi">+            self.scatterplot(ax, scatter_kws)</span>
<span class="gi">+</span>
<span class="gi">+        if self.fit_reg:</span>
<span class="gi">+            self.lineplot(ax, line_kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Label the axes</span>
<span class="gi">+        if hasattr(self.x, &quot;name&quot;):</span>
<span class="gi">+            ax.set_xlabel(self.x.name)</span>
<span class="gi">+        if hasattr(self.y, &quot;name&quot;):</span>
<span class="gi">+            ax.set_ylabel(self.y.name)</span>

<span class="w"> </span>    def scatterplot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Treat the line-based markers specially, explicitly setting larger</span>
<span class="gi">+        # linewidth than is provided by the seaborn style defaults.</span>
<span class="gi">+        # This would ideally be handled better in matplotlib (i.e., distinguish</span>
<span class="gi">+        # between edgewidth for solid glyphs and linewidth for line glyphs</span>
<span class="gi">+        # but this should do for now.</span>
<span class="gi">+        line_markers = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;+&quot;, &quot;x&quot;, &quot;|&quot;, &quot;_&quot;]</span>
<span class="gi">+        if self.x_estimator is None:</span>
<span class="gi">+            if &quot;marker&quot; in kws and kws[&quot;marker&quot;] in line_markers:</span>
<span class="gi">+                lw = mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                lw = mpl.rcParams[&quot;lines.markeredgewidth&quot;]</span>
<span class="gi">+            kws.setdefault(&quot;linewidths&quot;, lw)</span>
<span class="gi">+</span>
<span class="gi">+            if not hasattr(kws[&#39;color&#39;], &#39;shape&#39;) or kws[&#39;color&#39;].shape[1] &lt; 4:</span>
<span class="gi">+                kws.setdefault(&quot;alpha&quot;, .8)</span>
<span class="gi">+</span>
<span class="gi">+            x, y = self.scatter_data</span>
<span class="gi">+            ax.scatter(x, y, **kws)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO abstraction</span>
<span class="gi">+            ci_kws = {&quot;color&quot;: kws[&quot;color&quot;]}</span>
<span class="gi">+            if &quot;alpha&quot; in kws:</span>
<span class="gi">+                ci_kws[&quot;alpha&quot;] = kws[&quot;alpha&quot;]</span>
<span class="gi">+            ci_kws[&quot;linewidth&quot;] = mpl.rcParams[&quot;lines.linewidth&quot;] * 1.75</span>
<span class="gi">+            kws.setdefault(&quot;s&quot;, 50)</span>
<span class="gi">+</span>
<span class="gi">+            xs, ys, cis = self.estimate_data</span>
<span class="gi">+            if [ci for ci in cis if ci is not None]:</span>
<span class="gi">+                for x, ci in zip(xs, cis):</span>
<span class="gi">+                    ax.plot([x, x], ci, **ci_kws)</span>
<span class="gi">+            ax.scatter(xs, ys, **kws)</span>

<span class="w"> </span>    def lineplot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Fit the regression model</span>
<span class="gi">+        grid, yhat, err_bands = self.fit_regression(ax)</span>
<span class="gi">+        edges = grid[0], grid[-1]</span>
<span class="gi">+</span>
<span class="gi">+        # Get set default aesthetics</span>
<span class="gi">+        fill_color = kws[&quot;color&quot;]</span>
<span class="gi">+        lw = kws.pop(&quot;lw&quot;, mpl.rcParams[&quot;lines.linewidth&quot;] * 1.5)</span>
<span class="gi">+        kws.setdefault(&quot;linewidth&quot;, lw)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the regression line and confidence interval</span>
<span class="gi">+        line, = ax.plot(grid, yhat, **kws)</span>
<span class="gi">+        if not self.truncate:</span>
<span class="gi">+            line.sticky_edges.x[:] = edges  # Prevent mpl from adding margin</span>
<span class="gi">+        if err_bands is not None:</span>
<span class="gi">+            ax.fill_between(grid, *err_bands, facecolor=fill_color, alpha=.15)</span>


<span class="gd">-_regression_docs = dict(model_api=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    There are a number of mutually exclusive options for estimating the</span>
<span class="gi">+_regression_docs = dict(</span>
<span class="gi">+</span>
<span class="gi">+    model_api=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    There are a number of mutually exclusive options for estimating the</span>
<span class="w"> </span>    regression model. See the :ref:`tutorial &lt;regression_tutorial&gt;` for more
<span class="gd">-    information.    &quot;&quot;&quot;</span>
<span class="gd">-    ), regplot_vs_lmplot=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    The :func:`regplot` and :func:`lmplot` functions are closely related, but</span>
<span class="gi">+    information.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    regplot_vs_lmplot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    The :func:`regplot` and :func:`lmplot` functions are closely related, but</span>
<span class="w"> </span>    the former is an axes-level function while the latter is a figure-level
<span class="gd">-    function that combines :func:`regplot` and :class:`FacetGrid`.    &quot;&quot;&quot;</span>
<span class="gd">-    ), x_estimator=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    x_estimator : callable that maps vector -&gt; scalar, optional</span>
<span class="gi">+    function that combines :func:`regplot` and :class:`FacetGrid`.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    x_estimator=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    x_estimator : callable that maps vector -&gt; scalar, optional</span>
<span class="w"> </span>        Apply this function to each unique value of ``x`` and plot the
<span class="w"> </span>        resulting estimate. This is useful when ``x`` is a discrete variable.
<span class="w"> </span>        If ``x_ci`` is given, this estimate will be bootstrapped and a
<span class="gd">-        confidence interval will be drawn.    &quot;&quot;&quot;</span>
<span class="gd">-    ), x_bins=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    x_bins : int or vector, optional</span>
<span class="gi">+        confidence interval will be drawn.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    x_bins=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    x_bins : int or vector, optional</span>
<span class="w"> </span>        Bin the ``x`` variable into discrete bins and then estimate the central
<span class="w"> </span>        tendency and a confidence interval. This binning only influences how
<span class="w"> </span>        the scatterplot is drawn; the regression is still fit to the original
<span class="w"> </span>        data.  This parameter is interpreted either as the number of
<span class="w"> </span>        evenly-sized (not necessary spaced) bins or the positions of the bin
<span class="w"> </span>        centers. When this parameter is used, it implies that the default of
<span class="gd">-        ``x_estimator`` is ``numpy.mean``.    &quot;&quot;&quot;</span>
<span class="gd">-    ), x_ci=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    x_ci : &quot;ci&quot;, &quot;sd&quot;, int in [0, 100] or None, optional</span>
<span class="gi">+        ``x_estimator`` is ``numpy.mean``.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    x_ci=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    x_ci : &quot;ci&quot;, &quot;sd&quot;, int in [0, 100] or None, optional</span>
<span class="w"> </span>        Size of the confidence interval used when plotting a central tendency
<span class="w"> </span>        for discrete values of ``x``. If ``&quot;ci&quot;``, defer to the value of the
<span class="w"> </span>        ``ci`` parameter. If ``&quot;sd&quot;``, skip bootstrapping and show the
<span class="gd">-        standard deviation of the observations in each bin.    &quot;&quot;&quot;</span>
<span class="gd">-    ), scatter=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    scatter : bool, optional</span>
<span class="gi">+        standard deviation of the observations in each bin.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    scatter=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    scatter : bool, optional</span>
<span class="w"> </span>        If ``True``, draw a scatterplot with the underlying observations (or
<span class="gd">-        the ``x_estimator`` values).    &quot;&quot;&quot;</span>
<span class="gd">-    ), fit_reg=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    fit_reg : bool, optional</span>
<span class="gi">+        the ``x_estimator`` values).\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    fit_reg=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    fit_reg : bool, optional</span>
<span class="w"> </span>        If ``True``, estimate and plot a regression model relating the ``x``
<span class="gd">-        and ``y`` variables.    &quot;&quot;&quot;</span>
<span class="gd">-    ), ci=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    ci : int in [0, 100] or None, optional</span>
<span class="gi">+        and ``y`` variables.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    ci=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    ci : int in [0, 100] or None, optional</span>
<span class="w"> </span>        Size of the confidence interval for the regression estimate. This will
<span class="w"> </span>        be drawn using translucent bands around the regression line. The
<span class="w"> </span>        confidence interval is estimated using a bootstrap; for large
<span class="w"> </span>        datasets, it may be advisable to avoid that computation by setting
<span class="gd">-        this parameter to None.    &quot;&quot;&quot;</span>
<span class="gd">-    ), n_boot=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    n_boot : int, optional</span>
<span class="gi">+        this parameter to None.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    n_boot=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    n_boot : int, optional</span>
<span class="w"> </span>        Number of bootstrap resamples used to estimate the ``ci``. The default
<span class="w"> </span>        value attempts to balance time and stability; you may want to increase
<span class="gd">-        this value for &quot;final&quot; versions of plots.    &quot;&quot;&quot;</span>
<span class="gd">-    ), units=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    units : variable name in ``data``, optional</span>
<span class="gi">+        this value for &quot;final&quot; versions of plots.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    units=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    units : variable name in ``data``, optional</span>
<span class="w"> </span>        If the ``x`` and ``y`` observations are nested within sampling units,
<span class="w"> </span>        those can be specified here. This will be taken into account when
<span class="w"> </span>        computing the confidence intervals by performing a multilevel bootstrap
<span class="w"> </span>        that resamples both units and observations (within unit). This does not
<span class="gd">-        otherwise influence how the regression is estimated or drawn.    &quot;&quot;&quot;</span>
<span class="gd">-    ), seed=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    seed : int, numpy.random.Generator, or numpy.random.RandomState, optional</span>
<span class="gd">-        Seed or random number generator for reproducible bootstrapping.    &quot;&quot;&quot;</span>
<span class="gd">-    ), order=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    order : int, optional</span>
<span class="gi">+        otherwise influence how the regression is estimated or drawn.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    seed=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    seed : int, numpy.random.Generator, or numpy.random.RandomState, optional</span>
<span class="gi">+        Seed or random number generator for reproducible bootstrapping.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    order=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    order : int, optional</span>
<span class="w"> </span>        If ``order`` is greater than 1, use ``numpy.polyfit`` to estimate a
<span class="gd">-        polynomial regression.    &quot;&quot;&quot;</span>
<span class="gd">-    ), logistic=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    logistic : bool, optional</span>
<span class="gi">+        polynomial regression.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    logistic=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    logistic : bool, optional</span>
<span class="w"> </span>        If ``True``, assume that ``y`` is a binary variable and use
<span class="w"> </span>        ``statsmodels`` to estimate a logistic regression model. Note that this
<span class="w"> </span>        is substantially more computationally intensive than linear regression,
<span class="w"> </span>        so you may wish to decrease the number of bootstrap resamples
<span class="gd">-        (``n_boot``) or set ``ci`` to None.    &quot;&quot;&quot;</span>
<span class="gd">-    ), lowess=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    lowess : bool, optional</span>
<span class="gi">+        (``n_boot``) or set ``ci`` to None.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    lowess=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    lowess : bool, optional</span>
<span class="w"> </span>        If ``True``, use ``statsmodels`` to estimate a nonparametric lowess
<span class="w"> </span>        model (locally weighted linear regression). Note that confidence
<span class="gd">-        intervals cannot currently be drawn for this kind of model.    &quot;&quot;&quot;</span>
<span class="gd">-    ), robust=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    robust : bool, optional</span>
<span class="gi">+        intervals cannot currently be drawn for this kind of model.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    robust=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    robust : bool, optional</span>
<span class="w"> </span>        If ``True``, use ``statsmodels`` to estimate a robust regression. This
<span class="w"> </span>        will de-weight outliers. Note that this is substantially more
<span class="w"> </span>        computationally intensive than standard linear regression, so you may
<span class="w"> </span>        wish to decrease the number of bootstrap resamples (``n_boot``) or set
<span class="gd">-        ``ci`` to None.    &quot;&quot;&quot;</span>
<span class="gd">-    ), logx=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    logx : bool, optional</span>
<span class="gi">+        ``ci`` to None.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    logx=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    logx : bool, optional</span>
<span class="w"> </span>        If ``True``, estimate a linear regression of the form y ~ log(x), but
<span class="w"> </span>        plot the scatterplot and regression model in the input space. Note that
<span class="gd">-        ``x`` must be positive for this to work.    &quot;&quot;&quot;</span>
<span class="gd">-    ), xy_partial=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    {x,y}_partial : strings in ``data`` or matrices</span>
<span class="gi">+        ``x`` must be positive for this to work.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    xy_partial=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    {x,y}_partial : strings in ``data`` or matrices</span>
<span class="w"> </span>        Confounding variables to regress out of the ``x`` or ``y`` variables
<span class="gd">-        before plotting.    &quot;&quot;&quot;</span>
<span class="gd">-    ), truncate=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    truncate : bool, optional</span>
<span class="gi">+        before plotting.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    truncate=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    truncate : bool, optional</span>
<span class="w"> </span>        If ``True``, the regression line is bounded by the data limits. If
<span class="w"> </span>        ``False``, it extends to the ``x`` axis limits.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ), xy_jitter=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    {x,y}_jitter : floats, optional</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    xy_jitter=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    {x,y}_jitter : floats, optional</span>
<span class="w"> </span>        Add uniform random noise of this size to either the ``x`` or ``y``
<span class="w"> </span>        variables. The noise is added to a copy of the data after fitting the
<span class="w"> </span>        regression, and only influences the look of the scatterplot. This can
<span class="gd">-        be helpful when plotting variables that take discrete values.    &quot;&quot;&quot;</span>
<span class="gd">-    ), scatter_line_kws=dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    {scatter,line}_kws : dictionaries</span>
<span class="gi">+        be helpful when plotting variables that take discrete values.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+    scatter_line_kws=dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    {scatter,line}_kws : dictionaries</span>
<span class="w"> </span>        Additional keyword arguments to pass to ``plt.scatter`` and
<span class="gd">-        ``plt.plot``.    &quot;&quot;&quot;</span>
<span class="gd">-    ))</span>
<span class="gi">+        ``plt.plot``.\</span>
<span class="gi">+    &quot;&quot;&quot;),</span>
<span class="gi">+)</span>
<span class="w"> </span>_regression_docs.update(_facet_docs)
<span class="gd">-lmplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Plot data and regression model fits across a FacetGrid.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lmplot(</span>
<span class="gi">+    data, *,</span>
<span class="gi">+    x=None, y=None, hue=None, col=None, row=None,</span>
<span class="gi">+    palette=None, col_wrap=None, height=5, aspect=1, markers=&quot;o&quot;,</span>
<span class="gi">+    sharex=None, sharey=None, hue_order=None, col_order=None, row_order=None,</span>
<span class="gi">+    legend=True, legend_out=None, x_estimator=None, x_bins=None,</span>
<span class="gi">+    x_ci=&quot;ci&quot;, scatter=True, fit_reg=True, ci=95, n_boot=1000,</span>
<span class="gi">+    units=None, seed=None, order=1, logistic=False, lowess=False,</span>
<span class="gi">+    robust=False, logx=False, x_partial=None, y_partial=None,</span>
<span class="gi">+    truncate=True, x_jitter=None, y_jitter=None, scatter_kws=None,</span>
<span class="gi">+    line_kws=None, facet_kws=None,</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    if facet_kws is None:</span>
<span class="gi">+        facet_kws = {}</span>
<span class="gi">+</span>
<span class="gi">+    def facet_kw_deprecation(key, val):</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            f&quot;{key} is deprecated from the `lmplot` function signature. &quot;</span>
<span class="gi">+            &quot;Please update your code to pass it using `facet_kws`.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if val is not None:</span>
<span class="gi">+            warnings.warn(msg, UserWarning)</span>
<span class="gi">+            facet_kws[key] = val</span>
<span class="gi">+</span>
<span class="gi">+    facet_kw_deprecation(&quot;sharex&quot;, sharex)</span>
<span class="gi">+    facet_kw_deprecation(&quot;sharey&quot;, sharey)</span>
<span class="gi">+    facet_kw_deprecation(&quot;legend_out&quot;, legend_out)</span>
<span class="gi">+</span>
<span class="gi">+    if data is None:</span>
<span class="gi">+        raise TypeError(&quot;Missing required keyword argument `data`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Reduce the dataframe to only needed columns</span>
<span class="gi">+    need_cols = [x, y, hue, col, row, units, x_partial, y_partial]</span>
<span class="gi">+    cols = np.unique([a for a in need_cols if a is not None]).tolist()</span>
<span class="gi">+    data = data[cols]</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the grid</span>
<span class="gi">+    facets = FacetGrid(</span>
<span class="gi">+        data, row=row, col=col, hue=hue,</span>
<span class="gi">+        palette=palette,</span>
<span class="gi">+        row_order=row_order, col_order=col_order, hue_order=hue_order,</span>
<span class="gi">+        height=height, aspect=aspect, col_wrap=col_wrap,</span>
<span class="gi">+        **facet_kws,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Add the markers here as FacetGrid has figured out how many levels of the</span>
<span class="gi">+    # hue variable are needed and we don&#39;t want to duplicate that process</span>
<span class="gi">+    if facets.hue_names is None:</span>
<span class="gi">+        n_markers = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        n_markers = len(facets.hue_names)</span>
<span class="gi">+    if not isinstance(markers, list):</span>
<span class="gi">+        markers = [markers] * n_markers</span>
<span class="gi">+    if len(markers) != n_markers:</span>
<span class="gi">+        raise ValueError(&quot;markers must be a singleton or a list of markers &quot;</span>
<span class="gi">+                         &quot;for each level of the hue variable&quot;)</span>
<span class="gi">+    facets.hue_kws = {&quot;marker&quot;: markers}</span>
<span class="gi">+</span>
<span class="gi">+    def update_datalim(data, x, y, ax, **kws):</span>
<span class="gi">+        xys = data[[x, y]].to_numpy().astype(float)</span>
<span class="gi">+        ax.update_datalim(xys, updatey=False)</span>
<span class="gi">+        ax.autoscale_view(scaley=False)</span>
<span class="gi">+</span>
<span class="gi">+    facets.map_dataframe(update_datalim, x=x, y=y)</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the regression plot on each facet</span>
<span class="gi">+    regplot_kws = dict(</span>
<span class="gi">+        x_estimator=x_estimator, x_bins=x_bins, x_ci=x_ci,</span>
<span class="gi">+        scatter=scatter, fit_reg=fit_reg, ci=ci, n_boot=n_boot, units=units,</span>
<span class="gi">+        seed=seed, order=order, logistic=logistic, lowess=lowess,</span>
<span class="gi">+        robust=robust, logx=logx, x_partial=x_partial, y_partial=y_partial,</span>
<span class="gi">+        truncate=truncate, x_jitter=x_jitter, y_jitter=y_jitter,</span>
<span class="gi">+        scatter_kws=scatter_kws, line_kws=line_kws,</span>
<span class="gi">+    )</span>
<span class="gi">+    facets.map_dataframe(regplot, x=x, y=y, **regplot_kws)</span>
<span class="gi">+    facets.set_axis_labels(x, y)</span>
<span class="gi">+</span>
<span class="gi">+    # Add a legend</span>
<span class="gi">+    if legend and (hue is not None) and (hue not in [col, row]):</span>
<span class="gi">+        facets.add_legend()</span>
<span class="gi">+    return facets</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+lmplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Plot data and regression model fits across a FacetGrid.</span>

<span class="w"> </span>    This function combines :func:`regplot` and :class:`FacetGrid`. It is
<span class="w"> </span>    intended as a convenient interface to fit regression models across
<span class="gu">@@ -341,10 +746,38 @@ lmplot.__doc__ = dedent(</span>

<span class="w"> </span>    .. include:: ../docstrings/lmplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_regression_docs)</span>
<span class="gd">-regplot.__doc__ = dedent(</span>
<span class="gd">-    &quot;&quot;&quot;    Plot data and a linear regression model fit.</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_regression_docs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def regplot(</span>
<span class="gi">+    data=None, *, x=None, y=None,</span>
<span class="gi">+    x_estimator=None, x_bins=None, x_ci=&quot;ci&quot;,</span>
<span class="gi">+    scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,</span>
<span class="gi">+    seed=None, order=1, logistic=False, lowess=False, robust=False,</span>
<span class="gi">+    logx=False, x_partial=None, y_partial=None,</span>
<span class="gi">+    truncate=True, dropna=True, x_jitter=None, y_jitter=None,</span>
<span class="gi">+    label=None, color=None, marker=&quot;o&quot;,</span>
<span class="gi">+    scatter_kws=None, line_kws=None, ax=None</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    plotter = _RegressionPlotter(x, y, data, x_estimator, x_bins, x_ci,</span>
<span class="gi">+                                 scatter, fit_reg, ci, n_boot, units, seed,</span>
<span class="gi">+                                 order, logistic, lowess, robust, logx,</span>
<span class="gi">+                                 x_partial, y_partial, truncate, dropna,</span>
<span class="gi">+                                 x_jitter, y_jitter, color, label)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    scatter_kws = {} if scatter_kws is None else copy.copy(scatter_kws)</span>
<span class="gi">+    scatter_kws[&quot;marker&quot;] = marker</span>
<span class="gi">+    line_kws = {} if line_kws is None else copy.copy(line_kws)</span>
<span class="gi">+    plotter.plot(ax, scatter_kws, line_kws)</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+regplot.__doc__ = dedent(&quot;&quot;&quot;\</span>
<span class="gi">+    Plot data and a linear regression model fit.</span>

<span class="w"> </span>    {model_api}

<span class="gu">@@ -415,13 +848,15 @@ regplot.__doc__ = dedent(</span>

<span class="w"> </span>    .. include:: ../docstrings/regplot.rst

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ).format(**_regression_docs)</span>
<span class="gi">+    &quot;&quot;&quot;).format(**_regression_docs)</span>


<span class="gd">-def residplot(data=None, *, x=None, y=None, x_partial=None, y_partial=None,</span>
<span class="gd">-    lowess=False, order=1, robust=False, dropna=True, label=None, color=</span>
<span class="gd">-    None, scatter_kws=None, line_kws=None, ax=None):</span>
<span class="gi">+def residplot(</span>
<span class="gi">+    data=None, *, x=None, y=None,</span>
<span class="gi">+    x_partial=None, y_partial=None, lowess=False,</span>
<span class="gi">+    order=1, robust=False, dropna=True, label=None, color=None,</span>
<span class="gi">+    scatter_kws=None, line_kws=None, ax=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Plot the residuals of a linear regression.

<span class="w"> </span>    This function will regress y on x (possibly as a robust or polynomial
<span class="gu">@@ -477,4 +912,29 @@ def residplot(data=None, *, x=None, y=None, x_partial=None, y_partial=None,</span>
<span class="w"> </span>    .. include:: ../docstrings/residplot.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    plotter = _RegressionPlotter(x, y, data, ci=None,</span>
<span class="gi">+                                 order=order, robust=robust,</span>
<span class="gi">+                                 x_partial=x_partial, y_partial=y_partial,</span>
<span class="gi">+                                 dropna=dropna, color=color, label=label)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the residual from a linear regression</span>
<span class="gi">+    _, yhat, _ = plotter.fit_regression(grid=plotter.x)</span>
<span class="gi">+    plotter.y = plotter.y - yhat</span>
<span class="gi">+</span>
<span class="gi">+    # Set the regression option on the plotter</span>
<span class="gi">+    if lowess:</span>
<span class="gi">+        plotter.lowess = True</span>
<span class="gi">+    else:</span>
<span class="gi">+        plotter.fit_reg = False</span>
<span class="gi">+</span>
<span class="gi">+    # Plot a horizontal line at 0</span>
<span class="gi">+    ax.axhline(0, ls=&quot;:&quot;, c=&quot;.2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the scatterplot</span>
<span class="gi">+    scatter_kws = {} if scatter_kws is None else scatter_kws.copy()</span>
<span class="gi">+    line_kws = {} if line_kws is None else line_kws.copy()</span>
<span class="gi">+    plotter.plot(ax, scatter_kws, line_kws)</span>
<span class="gi">+    return ax</span>
<span class="gh">diff --git a/seaborn/relational.py b/seaborn/relational.py</span>
<span class="gh">index 76efb2d1..ff0701c7 100644</span>
<span class="gd">--- a/seaborn/relational.py</span>
<span class="gi">+++ b/seaborn/relational.py</span>
<span class="gu">@@ -1,19 +1,35 @@</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="w"> </span>from matplotlib.cbook import normalize_kwargs
<span class="gd">-from ._base import VectorPlotter</span>
<span class="gd">-from .utils import adjust_legend_subtitles, _default_color, _deprecate_ci, _get_transform_functions, _scatter_legend_artist</span>
<span class="gi">+</span>
<span class="gi">+from ._base import (</span>
<span class="gi">+    VectorPlotter,</span>
<span class="gi">+)</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    adjust_legend_subtitles,</span>
<span class="gi">+    _default_color,</span>
<span class="gi">+    _deprecate_ci,</span>
<span class="gi">+    _get_transform_functions,</span>
<span class="gi">+    _scatter_legend_artist,</span>
<span class="gi">+)</span>
<span class="w"> </span>from ._compat import groupby_apply_include_groups
<span class="w"> </span>from ._statistics import EstimateAggregator, WeightedAggregator
<span class="w"> </span>from .axisgrid import FacetGrid, _facet_docs
<span class="w"> </span>from ._docstrings import DocstringComponents, _core_docs
<span class="gd">-__all__ = [&#39;relplot&#39;, &#39;scatterplot&#39;, &#39;lineplot&#39;]</span>
<span class="gd">-_relational_narrative = DocstringComponents(dict(main_api=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;relplot&quot;, &quot;scatterplot&quot;, &quot;lineplot&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_relational_narrative = DocstringComponents(dict(</span>
<span class="gi">+</span>
<span class="gi">+    # ---  Introductory prose</span>
<span class="gi">+    main_api=&quot;&quot;&quot;</span>
<span class="w"> </span>The relationship between `x` and `y` can be shown for different subsets
<span class="w"> </span>of the data using the `hue`, `size`, and `style` parameters. These
<span class="w"> </span>parameters control what visual semantics are used to identify the different
<span class="gu">@@ -24,9 +40,9 @@ interpret and is often ineffective. Using redundant semantics (i.e. both</span>
<span class="w"> </span>graphics more accessible.

<span class="w"> </span>See the :ref:`tutorial &lt;relational_tutorial&gt;` for more information.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , relational_semantic=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+</span>
<span class="gi">+    relational_semantic=&quot;&quot;&quot;</span>
<span class="w"> </span>The default treatment of the `hue` (and to a lesser extent, `size`)
<span class="w"> </span>semantic, if present, depends on whether the variable is inferred to
<span class="w"> </span>represent &quot;numeric&quot; or &quot;categorical&quot; data. In particular, numeric variables
<span class="gu">@@ -34,67 +50,62 @@ are represented with a sequential colormap by default, and the legend</span>
<span class="w"> </span>entries show regular &quot;ticks&quot; with values that may or may not exist in the
<span class="w"> </span>data. This behavior can be controlled through various parameters, as
<span class="w"> </span>described and illustrated below.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    ))</span>
<span class="gd">-_relational_docs = dict(data_vars=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+))</span>
<span class="gi">+</span>
<span class="gi">+_relational_docs = dict(</span>
<span class="gi">+</span>
<span class="gi">+    # --- Shared function parameters</span>
<span class="gi">+    data_vars=&quot;&quot;&quot;</span>
<span class="w"> </span>x, y : names of variables in `data` or vector data
<span class="w"> </span>    Input data variables; must be numeric. Can pass data directly or
<span class="w"> </span>    reference columns in `data`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , data=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    data=&quot;&quot;&quot;</span>
<span class="w"> </span>data : DataFrame, array, or list of arrays
<span class="w"> </span>    Input data structure. If `x` and `y` are specified as names, this
<span class="w"> </span>    should be a &quot;long-form&quot; DataFrame containing those columns. Otherwise
<span class="w"> </span>    it is treated as &quot;wide-form&quot; data and grouping variables are ignored.
<span class="w"> </span>    See the examples for the various ways this parameter can be specified
<span class="w"> </span>    and the different effects of each.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , palette=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    palette=&quot;&quot;&quot;</span>
<span class="w"> </span>palette : string, list, dict, or matplotlib colormap
<span class="w"> </span>    An object that determines how colors are chosen when `hue` is used.
<span class="w"> </span>    It can be the name of a seaborn palette or matplotlib colormap, a list
<span class="w"> </span>    of colors (anything matplotlib understands), a dict mapping levels
<span class="w"> </span>    of the `hue` variable to colors, or a matplotlib colormap object.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , hue_order=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    hue_order=&quot;&quot;&quot;</span>
<span class="w"> </span>hue_order : list
<span class="w"> </span>    Specified order for the appearance of the `hue` variable levels,
<span class="w"> </span>    otherwise they are determined from the data. Not relevant when the
<span class="w"> </span>    `hue` variable is numeric.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , hue_norm=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    hue_norm=&quot;&quot;&quot;</span>
<span class="w"> </span>hue_norm : tuple or :class:`matplotlib.colors.Normalize` object
<span class="w"> </span>    Normalization in data units for colormap applied to the `hue`
<span class="w"> </span>    variable when it is numeric. Not relevant if `hue` is categorical.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , sizes=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    sizes=&quot;&quot;&quot;</span>
<span class="w"> </span>sizes : list, dict, or tuple
<span class="w"> </span>    An object that determines how sizes are chosen when `size` is used.
<span class="w"> </span>    List or dict arguments should provide a size for each unique data value,
<span class="w"> </span>    which forces a categorical interpretation. The argument may also be a
<span class="w"> </span>    min, max tuple.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , size_order=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    size_order=&quot;&quot;&quot;</span>
<span class="w"> </span>size_order : list
<span class="w"> </span>    Specified order for appearance of the `size` variable levels,
<span class="w"> </span>    otherwise they are determined from the data. Not relevant when the
<span class="w"> </span>    `size` variable is numeric.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , size_norm=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    size_norm=&quot;&quot;&quot;</span>
<span class="w"> </span>size_norm : tuple or Normalize object
<span class="w"> </span>    Normalization in data units for scaling plot objects when the
<span class="w"> </span>    `size` variable is numeric.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , dashes=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    dashes=&quot;&quot;&quot;</span>
<span class="w"> </span>dashes : boolean, list, or dictionary
<span class="w"> </span>    Object determining how to draw the lines for different levels of the
<span class="w"> </span>    `style` variable. Setting to `True` will use default dash codes, or
<span class="gu">@@ -102,98 +113,108 @@ dashes : boolean, list, or dictionary</span>
<span class="w"> </span>    `style` variable to dash codes. Setting to `False` will use solid
<span class="w"> </span>    lines for all subsets. Dashes are specified as in matplotlib: a tuple
<span class="w"> </span>    of `(segment, gap)` lengths, or an empty string to draw a solid line.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , markers=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    markers=&quot;&quot;&quot;</span>
<span class="w"> </span>markers : boolean, list, or dictionary
<span class="w"> </span>    Object determining how to draw the markers for different levels of the
<span class="w"> </span>    `style` variable. Setting to `True` will use default markers, or
<span class="w"> </span>    you can pass a list of markers or a dictionary mapping levels of the
<span class="w"> </span>    `style` variable to markers. Setting to `False` will draw
<span class="w"> </span>    marker-less lines.  Markers are specified as in matplotlib.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , style_order=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    style_order=&quot;&quot;&quot;</span>
<span class="w"> </span>style_order : list
<span class="w"> </span>    Specified order for appearance of the `style` variable levels
<span class="w"> </span>    otherwise they are determined from the data. Not relevant when the
<span class="w"> </span>    `style` variable is numeric.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , units=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    units=&quot;&quot;&quot;</span>
<span class="w"> </span>units : vector or key in `data`
<span class="w"> </span>    Grouping variable identifying sampling units. When used, a separate
<span class="w"> </span>    line will be drawn for each unit with appropriate semantics, but no
<span class="w"> </span>    legend entry will be added. Useful for showing distribution of
<span class="w"> </span>    experimental replicates when exact identities are not needed.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , estimator=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    estimator=&quot;&quot;&quot;</span>
<span class="w"> </span>estimator : name of pandas method or callable or None
<span class="w"> </span>    Method for aggregating across multiple observations of the `y`
<span class="w"> </span>    variable at the same `x` level. If `None`, all observations will
<span class="w"> </span>    be drawn.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , ci=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    ci=&quot;&quot;&quot;</span>
<span class="w"> </span>ci : int or &quot;sd&quot; or None
<span class="w"> </span>    Size of the confidence interval to draw when aggregating.

<span class="w"> </span>    .. deprecated:: 0.12.0
<span class="w"> </span>        Use the new `errorbar` parameter for more flexibility.

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , n_boot=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    n_boot=&quot;&quot;&quot;</span>
<span class="w"> </span>n_boot : int
<span class="w"> </span>    Number of bootstraps to use for computing the confidence interval.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , seed=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    seed=&quot;&quot;&quot;</span>
<span class="w"> </span>seed : int, numpy.random.Generator, or numpy.random.RandomState
<span class="w"> </span>    Seed or random number generator for reproducible bootstrapping.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , legend=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    legend=&quot;&quot;&quot;</span>
<span class="w"> </span>legend : &quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;, or False
<span class="w"> </span>    How to draw the legend. If &quot;brief&quot;, numeric `hue` and `size`
<span class="w"> </span>    variables will be represented with a sample of evenly spaced values.
<span class="w"> </span>    If &quot;full&quot;, every group will get an entry in the legend. If &quot;auto&quot;,
<span class="w"> </span>    choose between brief or full representation based on number of levels.
<span class="w"> </span>    If `False`, no legend data is added and no legend is drawn.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , ax_in=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    ax_in=&quot;&quot;&quot;</span>
<span class="w"> </span>ax : matplotlib Axes
<span class="w"> </span>    Axes object to draw the plot onto, otherwise uses the current Axes.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , ax_out=</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    ax_out=&quot;&quot;&quot;</span>
<span class="w"> </span>ax : matplotlib Axes
<span class="w"> </span>    Returns the Axes object with the plot drawn onto it.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gd">-_param_docs = DocstringComponents.from_nested_components(core=_core_docs[</span>
<span class="gd">-    &#39;params&#39;], facets=DocstringComponents(_facet_docs), rel=</span>
<span class="gd">-    DocstringComponents(_relational_docs), stat=DocstringComponents.</span>
<span class="gd">-    from_function_params(EstimateAggregator.__init__))</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_param_docs = DocstringComponents.from_nested_components(</span>
<span class="gi">+    core=_core_docs[&quot;params&quot;],</span>
<span class="gi">+    facets=DocstringComponents(_facet_docs),</span>
<span class="gi">+    rel=DocstringComponents(_relational_docs),</span>
<span class="gi">+    stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),</span>
<span class="gi">+)</span>


<span class="w"> </span>class _RelationalPlotter(VectorPlotter):
<span class="gd">-    wide_structure = {&#39;x&#39;: &#39;@index&#39;, &#39;y&#39;: &#39;@values&#39;, &#39;hue&#39;: &#39;@columns&#39;,</span>
<span class="gd">-        &#39;style&#39;: &#39;@columns&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    wide_structure = {</span>
<span class="gi">+        &quot;x&quot;: &quot;@index&quot;, &quot;y&quot;: &quot;@values&quot;, &quot;hue&quot;: &quot;@columns&quot;, &quot;style&quot;: &quot;@columns&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # TODO where best to define default parameters?</span>
<span class="w"> </span>    sort = True


<span class="w"> </span>class _LinePlotter(_RelationalPlotter):
<span class="gd">-    _legend_attributes = [&#39;color&#39;, &#39;linewidth&#39;, &#39;marker&#39;, &#39;dashes&#39;]</span>

<span class="gd">-    def __init__(self, *, data=None, variables={}, estimator=None, n_boot=</span>
<span class="gd">-        None, seed=None, errorbar=None, sort=True, orient=&#39;x&#39;, err_style=</span>
<span class="gd">-        None, err_kws=None, legend=None):</span>
<span class="gd">-        self._default_size_range = np.r_[0.5, 2] * mpl.rcParams[</span>
<span class="gd">-            &#39;lines.linewidth&#39;]</span>
<span class="gi">+    _legend_attributes = [&quot;color&quot;, &quot;linewidth&quot;, &quot;marker&quot;, &quot;dashes&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, *,</span>
<span class="gi">+        data=None, variables={},</span>
<span class="gi">+        estimator=None, n_boot=None, seed=None, errorbar=None,</span>
<span class="gi">+        sort=True, orient=&quot;x&quot;, err_style=None, err_kws=None, legend=None</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        # TODO this is messy, we want the mapping to be agnostic about</span>
<span class="gi">+        # the kind of plot to draw, but for the time being we need to set</span>
<span class="gi">+        # this information so the SizeMapping can use it</span>
<span class="gi">+        self._default_size_range = (</span>
<span class="gi">+            np.r_[.5, 2] * mpl.rcParams[&quot;lines.linewidth&quot;]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(data=data, variables=variables)
<span class="gi">+</span>
<span class="w"> </span>        self.estimator = estimator
<span class="w"> </span>        self.errorbar = errorbar
<span class="w"> </span>        self.n_boot = n_boot
<span class="gu">@@ -202,25 +223,301 @@ class _LinePlotter(_RelationalPlotter):</span>
<span class="w"> </span>        self.orient = orient
<span class="w"> </span>        self.err_style = err_style
<span class="w"> </span>        self.err_kws = {} if err_kws is None else err_kws
<span class="gi">+</span>
<span class="w"> </span>        self.legend = legend

<span class="w"> </span>    def plot(self, ax, kws):
<span class="w"> </span>        &quot;&quot;&quot;Draw the plot onto an axes, passing matplotlib kwargs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Draw a test plot, using the passed in kwargs. The goal here is to</span>
<span class="gi">+        # honor both (a) the current state of the plot cycler and (b) the</span>
<span class="gi">+        # specified kwargs on all the lines we will draw, overriding when</span>
<span class="gi">+        # relevant with the data semantics. Note that we won&#39;t cycle</span>
<span class="gi">+        # internally; in other words, if `hue` is not used, all elements will</span>
<span class="gi">+        # have the same color, but they will have the color that you would have</span>
<span class="gi">+        # gotten from the corresponding matplotlib function, and calling the</span>
<span class="gi">+        # function will advance the axes property cycle.</span>
<span class="gi">+</span>
<span class="gi">+        kws = normalize_kwargs(kws, mpl.lines.Line2D)</span>
<span class="gi">+        kws.setdefault(&quot;markeredgewidth&quot;, 0.75)</span>
<span class="gi">+        kws.setdefault(&quot;markeredgecolor&quot;, &quot;w&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Set default error kwargs</span>
<span class="gi">+        err_kws = self.err_kws.copy()</span>
<span class="gi">+        if self.err_style == &quot;band&quot;:</span>
<span class="gi">+            err_kws.setdefault(&quot;alpha&quot;, .2)</span>
<span class="gi">+        elif self.err_style == &quot;bars&quot;:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self.err_style is not None:</span>
<span class="gi">+            err = &quot;`err_style` must be &#39;band&#39; or &#39;bars&#39;, not {}&quot;</span>
<span class="gi">+            raise ValueError(err.format(self.err_style))</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize the aggregation object</span>
<span class="gi">+        weighted = &quot;weight&quot; in self.plot_data</span>
<span class="gi">+        agg = (WeightedAggregator if weighted else EstimateAggregator)(</span>
<span class="gi">+            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # TODO abstract variable to aggregate over here-ish. Better name?</span>
<span class="gi">+        orient = self.orient</span>
<span class="gi">+        if orient not in {&quot;x&quot;, &quot;y&quot;}:</span>
<span class="gi">+            err = f&quot;`orient` must be either &#39;x&#39; or &#39;y&#39;, not {orient!r}.&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+        other = {&quot;x&quot;: &quot;y&quot;, &quot;y&quot;: &quot;x&quot;}[orient]</span>
<span class="gi">+</span>
<span class="gi">+        # TODO How to handle NA? We don&#39;t want NA to propagate through to the</span>
<span class="gi">+        # estimate/CI when some values are present, but we would also like</span>
<span class="gi">+        # matplotlib to show &quot;gaps&quot; in the line when all values are missing.</span>
<span class="gi">+        # This is straightforward absent aggregation, but complicated with it.</span>
<span class="gi">+        # If we want to use nas, we need to conditionalize dropna in iter_data.</span>
<span class="gi">+</span>
<span class="gi">+        # Loop over the semantic subsets and add to the plot</span>
<span class="gi">+        grouping_vars = &quot;hue&quot;, &quot;size&quot;, &quot;style&quot;</span>
<span class="gi">+        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):</span>
<span class="gi">+</span>
<span class="gi">+            if self.sort:</span>
<span class="gi">+                sort_vars = [&quot;units&quot;, orient, other]</span>
<span class="gi">+                sort_cols = [var for var in sort_vars if var in self.variables]</span>
<span class="gi">+                sub_data = sub_data.sort_values(sort_cols)</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                self.estimator is not None</span>
<span class="gi">+                and sub_data[orient].value_counts().max() &gt; 1</span>
<span class="gi">+            ):</span>
<span class="gi">+                if &quot;units&quot; in self.variables:</span>
<span class="gi">+                    # TODO eventually relax this constraint</span>
<span class="gi">+                    err = &quot;estimator must be None when specifying units&quot;</span>
<span class="gi">+                    raise ValueError(err)</span>
<span class="gi">+                grouped = sub_data.groupby(orient, sort=self.sort)</span>
<span class="gi">+                # Could pass as_index=False instead of reset_index,</span>
<span class="gi">+                # but that fails on a corner case with older pandas.</span>
<span class="gi">+                sub_data = (</span>
<span class="gi">+                    grouped</span>
<span class="gi">+                    .apply(agg, other, **groupby_apply_include_groups(False))</span>
<span class="gi">+                    .reset_index()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                sub_data[f&quot;{other}min&quot;] = np.nan</span>
<span class="gi">+                sub_data[f&quot;{other}max&quot;] = np.nan</span>
<span class="gi">+</span>
<span class="gi">+            # Apply inverse axis scaling</span>
<span class="gi">+            for var in &quot;xy&quot;:</span>
<span class="gi">+                _, inv = _get_transform_functions(ax, var)</span>
<span class="gi">+                for col in sub_data.filter(regex=f&quot;^{var}&quot;):</span>
<span class="gi">+                    sub_data[col] = inv(sub_data[col])</span>
<span class="gi">+</span>
<span class="gi">+            # --- Draw the main line(s)</span>
<span class="gi">+</span>
<span class="gi">+            if &quot;units&quot; in self.variables:   # XXX why not add to grouping variables?</span>
<span class="gi">+                lines = []</span>
<span class="gi">+                for _, unit_data in sub_data.groupby(&quot;units&quot;):</span>
<span class="gi">+                    lines.extend(ax.plot(unit_data[&quot;x&quot;], unit_data[&quot;y&quot;], **kws))</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines = ax.plot(sub_data[&quot;x&quot;], sub_data[&quot;y&quot;], **kws)</span>
<span class="gi">+</span>
<span class="gi">+            for line in lines:</span>
<span class="gi">+</span>
<span class="gi">+                if &quot;hue&quot; in sub_vars:</span>
<span class="gi">+                    line.set_color(self._hue_map(sub_vars[&quot;hue&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+                if &quot;size&quot; in sub_vars:</span>
<span class="gi">+                    line.set_linewidth(self._size_map(sub_vars[&quot;size&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+                if &quot;style&quot; in sub_vars:</span>
<span class="gi">+                    attributes = self._style_map(sub_vars[&quot;style&quot;])</span>
<span class="gi">+                    if &quot;dashes&quot; in attributes:</span>
<span class="gi">+                        line.set_dashes(attributes[&quot;dashes&quot;])</span>
<span class="gi">+                    if &quot;marker&quot; in attributes:</span>
<span class="gi">+                        line.set_marker(attributes[&quot;marker&quot;])</span>
<span class="gi">+</span>
<span class="gi">+            line_color = line.get_color()</span>
<span class="gi">+            line_alpha = line.get_alpha()</span>
<span class="gi">+            line_capstyle = line.get_solid_capstyle()</span>
<span class="gi">+</span>
<span class="gi">+            # --- Draw the confidence intervals</span>
<span class="gi">+</span>
<span class="gi">+            if self.estimator is not None and self.errorbar is not None:</span>
<span class="gi">+</span>
<span class="gi">+                # TODO handling of orientation will need to happen here</span>
<span class="gi">+</span>
<span class="gi">+                if self.err_style == &quot;band&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                    func = {&quot;x&quot;: ax.fill_between, &quot;y&quot;: ax.fill_betweenx}[orient]</span>
<span class="gi">+                    func(</span>
<span class="gi">+                        sub_data[orient],</span>
<span class="gi">+                        sub_data[f&quot;{other}min&quot;], sub_data[f&quot;{other}max&quot;],</span>
<span class="gi">+                        color=line_color, **err_kws</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                elif self.err_style == &quot;bars&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                    error_param = {</span>
<span class="gi">+                        f&quot;{other}err&quot;: (</span>
<span class="gi">+                            sub_data[other] - sub_data[f&quot;{other}min&quot;],</span>
<span class="gi">+                            sub_data[f&quot;{other}max&quot;] - sub_data[other],</span>
<span class="gi">+                        )</span>
<span class="gi">+                    }</span>
<span class="gi">+                    ebars = ax.errorbar(</span>
<span class="gi">+                        sub_data[&quot;x&quot;], sub_data[&quot;y&quot;], **error_param,</span>
<span class="gi">+                        linestyle=&quot;&quot;, color=line_color, alpha=line_alpha,</span>
<span class="gi">+                        **err_kws</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    # Set the capstyle properly on the error bars</span>
<span class="gi">+                    for obj in ebars.get_children():</span>
<span class="gi">+                        if isinstance(obj, mpl.collections.LineCollection):</span>
<span class="gi">+                            obj.set_capstyle(line_capstyle)</span>
<span class="gi">+</span>
<span class="gi">+        # Finalize the axes details</span>
<span class="gi">+        self._add_axis_labels(ax)</span>
<span class="gi">+        if self.legend:</span>
<span class="gi">+            legend_artist = partial(mpl.lines.Line2D, xdata=[], ydata=[])</span>
<span class="gi">+            attrs = {&quot;hue&quot;: &quot;color&quot;, &quot;size&quot;: &quot;linewidth&quot;, &quot;style&quot;: None}</span>
<span class="gi">+            self.add_legend_data(ax, legend_artist, kws, attrs)</span>
<span class="gi">+            handles, _ = ax.get_legend_handles_labels()</span>
<span class="gi">+            if handles:</span>
<span class="gi">+                legend = ax.legend(title=self.legend_title)</span>
<span class="gi">+                adjust_legend_subtitles(legend)</span>


<span class="w"> </span>class _ScatterPlotter(_RelationalPlotter):
<span class="gd">-    _legend_attributes = [&#39;color&#39;, &#39;s&#39;, &#39;marker&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    _legend_attributes = [&quot;color&quot;, &quot;s&quot;, &quot;marker&quot;]</span>

<span class="w"> </span>    def __init__(self, *, data=None, variables={}, legend=None):
<span class="gd">-        self._default_size_range = np.r_[0.5, 2] * np.square(mpl.rcParams[</span>
<span class="gd">-            &#39;lines.markersize&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        # TODO this is messy, we want the mapping to be agnostic about</span>
<span class="gi">+        # the kind of plot to draw, but for the time being we need to set</span>
<span class="gi">+        # this information so the SizeMapping can use it</span>
<span class="gi">+        self._default_size_range = (</span>
<span class="gi">+            np.r_[.5, 2] * np.square(mpl.rcParams[&quot;lines.markersize&quot;])</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(data=data, variables=variables)
<span class="gi">+</span>
<span class="w"> </span>        self.legend = legend

<span class="gi">+    def plot(self, ax, kws):</span>

<span class="gd">-lineplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Draw a line plot with possibility of several semantic groupings.</span>
<span class="gi">+        # --- Determine the visual attributes of the plot</span>
<span class="gi">+</span>
<span class="gi">+        data = self.comp_data.dropna()</span>
<span class="gi">+        if data.empty:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        kws = normalize_kwargs(kws, mpl.collections.PathCollection)</span>
<span class="gi">+</span>
<span class="gi">+        # Define the vectors of x and y positions</span>
<span class="gi">+        empty = np.full(len(data), np.nan)</span>
<span class="gi">+        x = data.get(&quot;x&quot;, empty)</span>
<span class="gi">+        y = data.get(&quot;y&quot;, empty)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply inverse scaling to the coordinate variables</span>
<span class="gi">+        _, inv_x = _get_transform_functions(ax, &quot;x&quot;)</span>
<span class="gi">+        _, inv_y = _get_transform_functions(ax, &quot;y&quot;)</span>
<span class="gi">+        x, y = inv_x(x), inv_y(y)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;style&quot; in self.variables:</span>
<span class="gi">+            # Use a representative marker so scatter sets the edgecolor</span>
<span class="gi">+            # properly for line art markers. We currently enforce either</span>
<span class="gi">+            # all or none line art so this works.</span>
<span class="gi">+            example_level = self._style_map.levels[0]</span>
<span class="gi">+            example_marker = self._style_map(example_level, &quot;marker&quot;)</span>
<span class="gi">+            kws.setdefault(&quot;marker&quot;, example_marker)</span>
<span class="gi">+</span>
<span class="gi">+        # Conditionally set the marker edgecolor based on whether the marker is &quot;filled&quot;</span>
<span class="gi">+        # See https://github.com/matplotlib/matplotlib/issues/17849 for context</span>
<span class="gi">+        m = kws.get(&quot;marker&quot;, mpl.rcParams.get(&quot;marker&quot;, &quot;o&quot;))</span>
<span class="gi">+        if not isinstance(m, mpl.markers.MarkerStyle):</span>
<span class="gi">+            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here</span>
<span class="gi">+            m = mpl.markers.MarkerStyle(m)</span>
<span class="gi">+        if m.is_filled():</span>
<span class="gi">+            kws.setdefault(&quot;edgecolor&quot;, &quot;w&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw the scatter plot</span>
<span class="gi">+        points = ax.scatter(x=x, y=y, **kws)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply the mapping from semantic variables to artist attributes</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;hue&quot; in self.variables:</span>
<span class="gi">+            points.set_facecolors(self._hue_map(data[&quot;hue&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;size&quot; in self.variables:</span>
<span class="gi">+            points.set_sizes(self._size_map(data[&quot;size&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;style&quot; in self.variables:</span>
<span class="gi">+            p = [self._style_map(val, &quot;path&quot;) for val in data[&quot;style&quot;]]</span>
<span class="gi">+            points.set_paths(p)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply dependent default attributes</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;linewidth&quot; not in kws:</span>
<span class="gi">+            sizes = points.get_sizes()</span>
<span class="gi">+            linewidth = .08 * np.sqrt(np.percentile(sizes, 10))</span>
<span class="gi">+            points.set_linewidths(linewidth)</span>
<span class="gi">+            kws[&quot;linewidth&quot;] = linewidth</span>
<span class="gi">+</span>
<span class="gi">+        # Finalize the axes details</span>
<span class="gi">+        self._add_axis_labels(ax)</span>
<span class="gi">+        if self.legend:</span>
<span class="gi">+            attrs = {&quot;hue&quot;: &quot;color&quot;, &quot;size&quot;: &quot;s&quot;, &quot;style&quot;: None}</span>
<span class="gi">+            self.add_legend_data(ax, _scatter_legend_artist, kws, attrs)</span>
<span class="gi">+            handles, _ = ax.get_legend_handles_labels()</span>
<span class="gi">+            if handles:</span>
<span class="gi">+                legend = ax.legend(title=self.legend_title)</span>
<span class="gi">+                adjust_legend_subtitles(legend)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def lineplot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    x=None, y=None, hue=None, size=None, style=None, units=None, weights=None,</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None,</span>
<span class="gi">+    sizes=None, size_order=None, size_norm=None,</span>
<span class="gi">+    dashes=True, markers=None, style_order=None,</span>
<span class="gi">+    estimator=&quot;mean&quot;, errorbar=(&quot;ci&quot;, 95), n_boot=1000, seed=None,</span>
<span class="gi">+    orient=&quot;x&quot;, sort=True, err_style=&quot;band&quot;, err_kws=None,</span>
<span class="gi">+    legend=&quot;auto&quot;, ci=&quot;deprecated&quot;, ax=None, **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    # Handle deprecation of ci parameter</span>
<span class="gi">+    errorbar = _deprecate_ci(errorbar, ci)</span>
<span class="gi">+</span>
<span class="gi">+    p = _LinePlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(</span>
<span class="gi">+            x=x, y=y, hue=hue, size=size, style=style, units=units, weight=weights</span>
<span class="gi">+        ),</span>
<span class="gi">+        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,</span>
<span class="gi">+        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    p.map_size(sizes=sizes, order=size_order, norm=size_norm)</span>
<span class="gi">+    p.map_style(markers=markers, dashes=dashes, order=style_order)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;style&quot; not in p.variables and not {&quot;ls&quot;, &quot;linestyle&quot;} &amp; set(kwargs):  # XXX</span>
<span class="gi">+        kwargs[&quot;dashes&quot;] = &quot;&quot; if dashes is None or isinstance(dashes, bool) else dashes</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax)</span>
<span class="gi">+</span>
<span class="gi">+    # Other functions have color as an explicit param,</span>
<span class="gi">+    # and we should probably do that here too</span>
<span class="gi">+    color = kwargs.pop(&quot;color&quot;, kwargs.pop(&quot;c&quot;, None))</span>
<span class="gi">+    kwargs[&quot;color&quot;] = _default_color(ax.plot, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot(ax, kwargs)</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+lineplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Draw a line plot with possibility of several semantic groupings.</span>

<span class="w"> </span>{narrative.main_api}

<span class="gu">@@ -298,11 +595,51 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/lineplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(narrative=_relational_narrative, params=_param_docs, returns=</span>
<span class="gd">-    _core_docs[&#39;returns&#39;], seealso=_core_docs[&#39;seealso&#39;]))</span>
<span class="gd">-scatterplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Draw a scatter plot with possibility of several semantic groupings.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    narrative=_relational_narrative,</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def scatterplot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    x=None, y=None, hue=None, size=None, style=None,</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None,</span>
<span class="gi">+    sizes=None, size_order=None, size_norm=None,</span>
<span class="gi">+    markers=True, style_order=None, legend=&quot;auto&quot;, ax=None,</span>
<span class="gi">+    **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    p = _ScatterPlotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=dict(x=x, y=y, hue=hue, size=size, style=style),</span>
<span class="gi">+        legend=legend</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    p.map_size(sizes=sizes, order=size_order, norm=size_norm)</span>
<span class="gi">+    p.map_style(markers=markers, order=style_order)</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if not p.has_xy_data:</span>
<span class="gi">+        return ax</span>
<span class="gi">+</span>
<span class="gi">+    p._attach(ax)</span>
<span class="gi">+</span>
<span class="gi">+    color = kwargs.pop(&quot;color&quot;, None)</span>
<span class="gi">+    kwargs[&quot;color&quot;] = _default_color(ax.scatter, hue, color, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    p.plot(ax, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return ax</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+scatterplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Draw a scatter plot with possibility of several semantic groupings.</span>

<span class="w"> </span>{narrative.main_api}

<span class="gu">@@ -352,11 +689,218 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/scatterplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(narrative=_relational_narrative, params=_param_docs, returns=</span>
<span class="gd">-    _core_docs[&#39;returns&#39;], seealso=_core_docs[&#39;seealso&#39;]))</span>
<span class="gd">-relplot.__doc__ = (</span>
<span class="gd">-    &quot;&quot;&quot;Figure-level interface for drawing relational plots onto a FacetGrid.</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    narrative=_relational_narrative,</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+    seealso=_core_docs[&quot;seealso&quot;],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def relplot(</span>
<span class="gi">+    data=None, *,</span>
<span class="gi">+    x=None, y=None, hue=None, size=None, style=None, units=None, weights=None,</span>
<span class="gi">+    row=None, col=None, col_wrap=None, row_order=None, col_order=None,</span>
<span class="gi">+    palette=None, hue_order=None, hue_norm=None,</span>
<span class="gi">+    sizes=None, size_order=None, size_norm=None,</span>
<span class="gi">+    markers=None, dashes=None, style_order=None,</span>
<span class="gi">+    legend=&quot;auto&quot;, kind=&quot;scatter&quot;, height=5, aspect=1, facet_kws=None,</span>
<span class="gi">+    **kwargs</span>
<span class="gi">+):</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;scatter&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        Plotter = _ScatterPlotter</span>
<span class="gi">+        func = scatterplot</span>
<span class="gi">+        markers = True if markers is None else markers</span>
<span class="gi">+</span>
<span class="gi">+    elif kind == &quot;line&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        Plotter = _LinePlotter</span>
<span class="gi">+        func = lineplot</span>
<span class="gi">+        dashes = True if dashes is None else dashes</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        err = f&quot;Plot kind {kind} not recognized&quot;</span>
<span class="gi">+        raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+    # Check for attempt to plot onto specific axes and warn</span>
<span class="gi">+    if &quot;ax&quot; in kwargs:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;relplot is a figure-level function and does not accept &quot;</span>
<span class="gi">+            &quot;the `ax` parameter. You may wish to try {}&quot;.format(kind + &quot;plot&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        warnings.warn(msg, UserWarning)</span>
<span class="gi">+        kwargs.pop(&quot;ax&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Use the full dataset to map the semantics</span>
<span class="gi">+    variables = dict(x=x, y=y, hue=hue, size=size, style=style)</span>
<span class="gi">+    if kind == &quot;line&quot;:</span>
<span class="gi">+        variables[&quot;units&quot;] = units</span>
<span class="gi">+        variables[&quot;weight&quot;] = weights</span>
<span class="gi">+    else:</span>
<span class="gi">+        if units is not None:</span>
<span class="gi">+            msg = &quot;The `units` parameter has no effect with kind=&#39;scatter&#39;.&quot;</span>
<span class="gi">+            warnings.warn(msg, stacklevel=2)</span>
<span class="gi">+        if weights is not None:</span>
<span class="gi">+            msg = &quot;The `weights` parameter has no effect with kind=&#39;scatter&#39;.&quot;</span>
<span class="gi">+            warnings.warn(msg, stacklevel=2)</span>
<span class="gi">+    p = Plotter(</span>
<span class="gi">+        data=data,</span>
<span class="gi">+        variables=variables,</span>
<span class="gi">+        legend=legend,</span>
<span class="gi">+    )</span>
<span class="gi">+    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)</span>
<span class="gi">+    p.map_size(sizes=sizes, order=size_order, norm=size_norm)</span>
<span class="gi">+    p.map_style(markers=markers, dashes=dashes, order=style_order)</span>
<span class="gi">+</span>
<span class="gi">+    # Extract the semantic mappings</span>
<span class="gi">+    if &quot;hue&quot; in p.variables:</span>
<span class="gi">+        palette = p._hue_map.lookup_table</span>
<span class="gi">+        hue_order = p._hue_map.levels</span>
<span class="gi">+        hue_norm = p._hue_map.norm</span>
<span class="gi">+    else:</span>
<span class="gi">+        palette = hue_order = hue_norm = None</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;size&quot; in p.variables:</span>
<span class="gi">+        sizes = p._size_map.lookup_table</span>
<span class="gi">+        size_order = p._size_map.levels</span>
<span class="gi">+        size_norm = p._size_map.norm</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;style&quot; in p.variables:</span>
<span class="gi">+        style_order = p._style_map.levels</span>
<span class="gi">+        if markers:</span>
<span class="gi">+            markers = {k: p._style_map(k, &quot;marker&quot;) for k in style_order}</span>
<span class="gi">+        else:</span>
<span class="gi">+            markers = None</span>
<span class="gi">+        if dashes:</span>
<span class="gi">+            dashes = {k: p._style_map(k, &quot;dashes&quot;) for k in style_order}</span>
<span class="gi">+        else:</span>
<span class="gi">+            dashes = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        markers = dashes = style_order = None</span>
<span class="gi">+</span>
<span class="gi">+    # Now extract the data that would be used to draw a single plot</span>
<span class="gi">+    variables = p.variables</span>
<span class="gi">+    plot_data = p.plot_data</span>
<span class="gi">+</span>
<span class="gi">+    # Define the common plotting parameters</span>
<span class="gi">+    plot_kws = dict(</span>
<span class="gi">+        palette=palette, hue_order=hue_order, hue_norm=hue_norm,</span>
<span class="gi">+        sizes=sizes, size_order=size_order, size_norm=size_norm,</span>
<span class="gi">+        markers=markers, dashes=dashes, style_order=style_order,</span>
<span class="gi">+        legend=False,</span>
<span class="gi">+    )</span>
<span class="gi">+    plot_kws.update(kwargs)</span>
<span class="gi">+    if kind == &quot;scatter&quot;:</span>
<span class="gi">+        plot_kws.pop(&quot;dashes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Add the grid semantics onto the plotter</span>
<span class="gi">+    grid_variables = dict(</span>
<span class="gi">+        x=x, y=y, row=row, col=col, hue=hue, size=size, style=style,</span>
<span class="gi">+    )</span>
<span class="gi">+    if kind == &quot;line&quot;:</span>
<span class="gi">+        grid_variables.update(units=units, weights=weights)</span>
<span class="gi">+    p.assign_variables(data, grid_variables)</span>
<span class="gi">+</span>
<span class="gi">+    # Define the named variables for plotting on each facet</span>
<span class="gi">+    # Rename the variables with a leading underscore to avoid</span>
<span class="gi">+    # collisions with faceting variable names</span>
<span class="gi">+    plot_variables = {v: f&quot;_{v}&quot; for v in variables}</span>
<span class="gi">+    if &quot;weight&quot; in plot_variables:</span>
<span class="gi">+        plot_variables[&quot;weights&quot;] = plot_variables.pop(&quot;weight&quot;)</span>
<span class="gi">+    plot_kws.update(plot_variables)</span>
<span class="gi">+</span>
<span class="gi">+    # Pass the row/col variables to FacetGrid with their original</span>
<span class="gi">+    # names so that the axes titles render correctly</span>
<span class="gi">+    for var in [&quot;row&quot;, &quot;col&quot;]:</span>
<span class="gi">+        # Handle faceting variables that lack name information</span>
<span class="gi">+        if var in p.variables and p.variables[var] is None:</span>
<span class="gi">+            p.variables[var] = f&quot;_{var}_&quot;</span>
<span class="gi">+    grid_kws = {v: p.variables.get(v) for v in [&quot;row&quot;, &quot;col&quot;]}</span>
<span class="gi">+</span>
<span class="gi">+    # Rename the columns of the plot_data structure appropriately</span>
<span class="gi">+    new_cols = plot_variables.copy()</span>
<span class="gi">+    new_cols.update(grid_kws)</span>
<span class="gi">+    full_data = p.plot_data.rename(columns=new_cols)</span>
<span class="gi">+</span>
<span class="gi">+    # Set up the FacetGrid object</span>
<span class="gi">+    facet_kws = {} if facet_kws is None else facet_kws.copy()</span>
<span class="gi">+    g = FacetGrid(</span>
<span class="gi">+        data=full_data.dropna(axis=1, how=&quot;all&quot;),</span>
<span class="gi">+        **grid_kws,</span>
<span class="gi">+        col_wrap=col_wrap, row_order=row_order, col_order=col_order,</span>
<span class="gi">+        height=height, aspect=aspect, dropna=False,</span>
<span class="gi">+        **facet_kws</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the plot</span>
<span class="gi">+    g.map_dataframe(func, **plot_kws)</span>
<span class="gi">+</span>
<span class="gi">+    # Label the axes, using the original variables</span>
<span class="gi">+    # Pass &quot;&quot; when the variable name is None to overwrite internal variables</span>
<span class="gi">+    g.set_axis_labels(variables.get(&quot;x&quot;) or &quot;&quot;, variables.get(&quot;y&quot;) or &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if legend:</span>
<span class="gi">+        # Replace the original plot data so the legend uses numeric data with</span>
<span class="gi">+        # the correct type, since we force a categorical mapping above.</span>
<span class="gi">+        p.plot_data = plot_data</span>
<span class="gi">+</span>
<span class="gi">+        # Handle the additional non-semantic keyword arguments out here.</span>
<span class="gi">+        # We&#39;re selective because some kwargs may be seaborn function specific</span>
<span class="gi">+        # and not relevant to the matplotlib artists going into the legend.</span>
<span class="gi">+        # Ideally, we will have a better solution where we don&#39;t need to re-make</span>
<span class="gi">+        # the legend out here and will have parity with the axes-level functions.</span>
<span class="gi">+        keys = [&quot;c&quot;, &quot;color&quot;, &quot;alpha&quot;, &quot;m&quot;, &quot;marker&quot;]</span>
<span class="gi">+        if kind == &quot;scatter&quot;:</span>
<span class="gi">+            legend_artist = _scatter_legend_artist</span>
<span class="gi">+            keys += [&quot;s&quot;, &quot;facecolor&quot;, &quot;fc&quot;, &quot;edgecolor&quot;, &quot;ec&quot;, &quot;linewidth&quot;, &quot;lw&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            legend_artist = partial(mpl.lines.Line2D, xdata=[], ydata=[])</span>
<span class="gi">+            keys += [</span>
<span class="gi">+                &quot;markersize&quot;, &quot;ms&quot;,</span>
<span class="gi">+                &quot;markeredgewidth&quot;, &quot;mew&quot;,</span>
<span class="gi">+                &quot;markeredgecolor&quot;, &quot;mec&quot;,</span>
<span class="gi">+                &quot;linestyle&quot;, &quot;ls&quot;,</span>
<span class="gi">+                &quot;linewidth&quot;, &quot;lw&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        common_kws = {k: v for k, v in kwargs.items() if k in keys}</span>
<span class="gi">+        attrs = {&quot;hue&quot;: &quot;color&quot;, &quot;style&quot;: None}</span>
<span class="gi">+        if kind == &quot;scatter&quot;:</span>
<span class="gi">+            attrs[&quot;size&quot;] = &quot;s&quot;</span>
<span class="gi">+        elif kind == &quot;line&quot;:</span>
<span class="gi">+            attrs[&quot;size&quot;] = &quot;linewidth&quot;</span>
<span class="gi">+        p.add_legend_data(g.axes.flat[0], legend_artist, common_kws, attrs)</span>
<span class="gi">+        if p.legend_data:</span>
<span class="gi">+            g.add_legend(legend_data=p.legend_data,</span>
<span class="gi">+                         label_order=p.legend_order,</span>
<span class="gi">+                         title=p.legend_title,</span>
<span class="gi">+                         adjust_subtitles=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Rename the columns of the FacetGrid&#39;s `data` attribute</span>
<span class="gi">+    # to match the original column names</span>
<span class="gi">+    orig_cols = {</span>
<span class="gi">+        f&quot;_{k}&quot;: f&quot;_{k}_&quot; if v is None else v for k, v in variables.items()</span>
<span class="gi">+    }</span>
<span class="gi">+    grid_data = g.data.rename(columns=orig_cols)</span>
<span class="gi">+    if data is not None and (x is not None or y is not None):</span>
<span class="gi">+        if not isinstance(data, pd.DataFrame):</span>
<span class="gi">+            data = pd.DataFrame(data)</span>
<span class="gi">+        g.data = pd.merge(</span>
<span class="gi">+            data,</span>
<span class="gi">+            grid_data[grid_data.columns.difference(data.columns)],</span>
<span class="gi">+            left_index=True,</span>
<span class="gi">+            right_index=True,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        g.data = grid_data</span>
<span class="gi">+</span>
<span class="gi">+    return g</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+relplot.__doc__ = &quot;&quot;&quot;\</span>
<span class="gi">+Figure-level interface for drawing relational plots onto a FacetGrid.</span>

<span class="w"> </span>This function provides access to several different axes-level functions
<span class="w"> </span>that show the relationship between two variables with semantic mappings
<span class="gu">@@ -431,6 +975,8 @@ Examples</span>

<span class="w"> </span>.. include:: ../docstrings/relplot.rst

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .format(narrative=_relational_narrative, params=_param_docs, returns=</span>
<span class="gd">-    _core_docs[&#39;returns&#39;]))</span>
<span class="gi">+&quot;&quot;&quot;.format(</span>
<span class="gi">+    narrative=_relational_narrative,</span>
<span class="gi">+    params=_param_docs,</span>
<span class="gi">+    returns=_core_docs[&quot;returns&quot;],</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/seaborn/utils.py b/seaborn/utils.py</span>
<span class="gh">index ba736ec6..98720ba3 100644</span>
<span class="gd">--- a/seaborn/utils.py</span>
<span class="gi">+++ b/seaborn/utils.py</span>
<span class="gu">@@ -6,20 +6,23 @@ import colorsys</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from urllib.request import urlopen, urlretrieve
<span class="w"> </span>from types import ModuleType
<span class="gi">+</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import pandas as pd
<span class="w"> </span>import matplotlib as mpl
<span class="w"> </span>from matplotlib.colors import to_rgb
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="w"> </span>from matplotlib.cbook import normalize_kwargs
<span class="gi">+</span>
<span class="w"> </span>from seaborn._core.typing import deprecated
<span class="w"> </span>from seaborn.external.version import Version
<span class="w"> </span>from seaborn.external.appdirs import user_cache_dir
<span class="gd">-__all__ = [&#39;desaturate&#39;, &#39;saturate&#39;, &#39;set_hls_values&#39;, &#39;move_legend&#39;,</span>
<span class="gd">-    &#39;despine&#39;, &#39;get_dataset_names&#39;, &#39;get_data_home&#39;, &#39;load_dataset&#39;]</span>
<span class="gd">-DATASET_SOURCE = (</span>
<span class="gd">-    &#39;https://raw.githubusercontent.com/mwaskom/seaborn-data/master&#39;)</span>
<span class="gd">-DATASET_NAMES_URL = f&#39;{DATASET_SOURCE}/dataset_names.txt&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;desaturate&quot;, &quot;saturate&quot;, &quot;set_hls_values&quot;, &quot;move_legend&quot;,</span>
<span class="gi">+           &quot;despine&quot;, &quot;get_dataset_names&quot;, &quot;get_data_home&quot;, &quot;load_dataset&quot;]</span>
<span class="gi">+</span>
<span class="gi">+DATASET_SOURCE = &quot;https://raw.githubusercontent.com/mwaskom/seaborn-data/master&quot;</span>
<span class="gi">+DATASET_NAMES_URL = f&quot;{DATASET_SOURCE}/dataset_names.txt&quot;</span>


<span class="w"> </span>def ci_to_errsize(cis, heights):
<span class="gu">@@ -39,17 +42,106 @@ def ci_to_errsize(cis, heights):</span>
<span class="w"> </span>        format as argument for plt.bar

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cis = np.atleast_2d(cis).reshape(2, -1)</span>
<span class="gi">+    heights = np.atleast_1d(heights)</span>
<span class="gi">+    errsize = []</span>
<span class="gi">+    for i, (low, high) in enumerate(np.transpose(cis)):</span>
<span class="gi">+        h = heights[i]</span>
<span class="gi">+        elow = h - low</span>
<span class="gi">+        ehigh = high - h</span>
<span class="gi">+        errsize.append([elow, ehigh])</span>
<span class="gi">+</span>
<span class="gi">+    errsize = np.asarray(errsize).T</span>
<span class="gi">+    return errsize</span>


<span class="w"> </span>def _draw_figure(fig):
<span class="w"> </span>    &quot;&quot;&quot;Force draw of a matplotlib figure, accounting for back-compat.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # See https://github.com/matplotlib/matplotlib/issues/19197 for context</span>
<span class="gi">+    fig.canvas.draw()</span>
<span class="gi">+    if fig.stale:</span>
<span class="gi">+        try:</span>
<span class="gi">+            fig.draw(fig.canvas.get_renderer())</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>def _default_color(method, hue, color, kws, saturation=1):
<span class="w"> </span>    &quot;&quot;&quot;If needed, get a default color by using the matplotlib property cycle.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if hue is not None:</span>
<span class="gi">+        # This warning is probably user-friendly, but it&#39;s currently triggered</span>
<span class="gi">+        # in a FacetGrid context and I don&#39;t want to mess with that logic right now</span>
<span class="gi">+        #  if color is not None:</span>
<span class="gi">+        #      msg = &quot;`color` is ignored when `hue` is assigned.&quot;</span>
<span class="gi">+        #      warnings.warn(msg)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    kws = kws.copy()</span>
<span class="gi">+    kws.pop(&quot;label&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    if color is not None:</span>
<span class="gi">+        if saturation &lt; 1:</span>
<span class="gi">+            color = desaturate(color, saturation)</span>
<span class="gi">+        return color</span>
<span class="gi">+</span>
<span class="gi">+    elif method.__name__ == &quot;plot&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        color = normalize_kwargs(kws, mpl.lines.Line2D).get(&quot;color&quot;)</span>
<span class="gi">+        scout, = method([], [], scalex=False, scaley=False, color=color)</span>
<span class="gi">+        color = scout.get_color()</span>
<span class="gi">+        scout.remove()</span>
<span class="gi">+</span>
<span class="gi">+    elif method.__name__ == &quot;scatter&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        # Matplotlib will raise if the size of x/y don&#39;t match s/c,</span>
<span class="gi">+        # and the latter might be in the kws dict</span>
<span class="gi">+        scout_size = max(</span>
<span class="gi">+            np.atleast_1d(kws.get(key, [])).shape[0]</span>
<span class="gi">+            for key in [&quot;s&quot;, &quot;c&quot;, &quot;fc&quot;, &quot;facecolor&quot;, &quot;facecolors&quot;]</span>
<span class="gi">+        )</span>
<span class="gi">+        scout_x = scout_y = np.full(scout_size, np.nan)</span>
<span class="gi">+</span>
<span class="gi">+        scout = method(scout_x, scout_y, **kws)</span>
<span class="gi">+        facecolors = scout.get_facecolors()</span>
<span class="gi">+</span>
<span class="gi">+        if not len(facecolors):</span>
<span class="gi">+            # Handle bug in matplotlib &lt;= 3.2 (I think)</span>
<span class="gi">+            # This will limit the ability to use non color= kwargs to specify</span>
<span class="gi">+            # a color in versions of matplotlib with the bug, but trying to</span>
<span class="gi">+            # work out what the user wanted by re-implementing the broken logic</span>
<span class="gi">+            # of inspecting the kwargs is probably too brittle.</span>
<span class="gi">+            single_color = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            single_color = np.unique(facecolors, axis=0).shape[0] == 1</span>
<span class="gi">+</span>
<span class="gi">+        # Allow the user to specify an array of colors through various kwargs</span>
<span class="gi">+        if &quot;c&quot; not in kws and single_color:</span>
<span class="gi">+            color = to_rgb(facecolors[0])</span>
<span class="gi">+</span>
<span class="gi">+        scout.remove()</span>
<span class="gi">+</span>
<span class="gi">+    elif method.__name__ == &quot;bar&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        # bar() needs masked, not empty data, to generate a patch</span>
<span class="gi">+        scout, = method([np.nan], [np.nan], **kws)</span>
<span class="gi">+        color = to_rgb(scout.get_facecolor())</span>
<span class="gi">+        scout.remove()</span>
<span class="gi">+        # Axes.bar adds both a patch and a container</span>
<span class="gi">+        method.__self__.containers.pop(-1)</span>
<span class="gi">+</span>
<span class="gi">+    elif method.__name__ == &quot;fill_between&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        kws = normalize_kwargs(kws, mpl.collections.PolyCollection)</span>
<span class="gi">+        scout = method([], [], **kws)</span>
<span class="gi">+        facecolor = scout.get_facecolor()</span>
<span class="gi">+        color = to_rgb(facecolor[0])</span>
<span class="gi">+        scout.remove()</span>
<span class="gi">+</span>
<span class="gi">+    if saturation &lt; 1:</span>
<span class="gi">+        color = desaturate(color, saturation)</span>
<span class="gi">+</span>
<span class="gi">+    return color</span>


<span class="w"> </span>def desaturate(color, prop):
<span class="gu">@@ -68,7 +160,27 @@ def desaturate(color, prop):</span>
<span class="w"> </span>        desaturated color code in RGB tuple representation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check inputs</span>
<span class="gi">+    if not 0 &lt;= prop &lt;= 1:</span>
<span class="gi">+        raise ValueError(&quot;prop must be between 0 and 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Get rgb tuple rep</span>
<span class="gi">+    rgb = to_rgb(color)</span>
<span class="gi">+</span>
<span class="gi">+    # Short circuit to avoid floating point issues</span>
<span class="gi">+    if prop == 1:</span>
<span class="gi">+        return rgb</span>
<span class="gi">+</span>
<span class="gi">+    # Convert to hls</span>
<span class="gi">+    h, l, s = colorsys.rgb_to_hls(*rgb)</span>
<span class="gi">+</span>
<span class="gi">+    # Desaturate the saturation channel</span>
<span class="gi">+    s *= prop</span>
<span class="gi">+</span>
<span class="gi">+    # Convert back to rgb</span>
<span class="gi">+    new_color = colorsys.hls_to_rgb(h, l, s)</span>
<span class="gi">+</span>
<span class="gi">+    return new_color</span>


<span class="w"> </span>def saturate(color):
<span class="gu">@@ -85,10 +197,10 @@ def saturate(color):</span>
<span class="w"> </span>        saturated color code in RGB tuple representation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set_hls_values(color, s=1)</span>


<span class="gd">-def set_hls_values(color, h=None, l=None, s=None):</span>
<span class="gi">+def set_hls_values(color, h=None, l=None, s=None):  # noqa</span>
<span class="w"> </span>    &quot;&quot;&quot;Independently manipulate the h, l, or s channels of a color.

<span class="w"> </span>    Parameters
<span class="gu">@@ -104,7 +216,15 @@ def set_hls_values(color, h=None, l=None, s=None):</span>
<span class="w"> </span>        new color code in RGB tuple representation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get an RGB tuple representation</span>
<span class="gi">+    rgb = to_rgb(color)</span>
<span class="gi">+    vals = list(colorsys.rgb_to_hls(*rgb))</span>
<span class="gi">+    for i, val in enumerate([h, l, s]):</span>
<span class="gi">+        if val is not None:</span>
<span class="gi">+            vals[i] = val</span>
<span class="gi">+</span>
<span class="gi">+    rgb = colorsys.hls_to_rgb(*vals)</span>
<span class="gi">+    return rgb</span>


<span class="w"> </span>def axlabel(xlabel, ylabel, **kwargs):
<span class="gu">@@ -113,7 +233,11 @@ def axlabel(xlabel, ylabel, **kwargs):</span>
<span class="w"> </span>    DEPRECATED: will be removed in a future version.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    msg = &quot;This function is deprecated and will be removed in a future version&quot;</span>
<span class="gi">+    warnings.warn(msg, FutureWarning)</span>
<span class="gi">+    ax = plt.gca()</span>
<span class="gi">+    ax.set_xlabel(xlabel, **kwargs)</span>
<span class="gi">+    ax.set_ylabel(ylabel, **kwargs)</span>


<span class="w"> </span>def remove_na(vector):
<span class="gu">@@ -130,7 +254,7 @@ def remove_na(vector):</span>
<span class="w"> </span>        Vector of data with null values removed. May be a copy or a view.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return vector[pd.notnull(vector)]</span>


<span class="w"> </span>def get_color_cycle():
<span class="gu">@@ -146,11 +270,12 @@ def get_color_cycle():</span>
<span class="w"> </span>        List of matplotlib colors in the current cycle, or dark gray if
<span class="w"> </span>        the current color cycle is empty.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cycler = mpl.rcParams[&#39;axes.prop_cycle&#39;]</span>
<span class="gi">+    return cycler.by_key()[&#39;color&#39;] if &#39;color&#39; in cycler.keys else [&quot;.15&quot;]</span>


<span class="gd">-def despine(fig=None, ax=None, top=True, right=True, left=False, bottom=</span>
<span class="gd">-    False, offset=None, trim=False):</span>
<span class="gi">+def despine(fig=None, ax=None, top=True, right=True, left=False,</span>
<span class="gi">+            bottom=False, offset=None, trim=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove the top and right spines from plot(s).

<span class="w"> </span>    fig : matplotlib figure, optional
<span class="gu">@@ -173,7 +298,82 @@ def despine(fig=None, ax=None, top=True, right=True, left=False, bottom=</span>
<span class="w"> </span>    None

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get references to the axes we want</span>
<span class="gi">+    if fig is None and ax is None:</span>
<span class="gi">+        axes = plt.gcf().axes</span>
<span class="gi">+    elif fig is not None:</span>
<span class="gi">+        axes = fig.axes</span>
<span class="gi">+    elif ax is not None:</span>
<span class="gi">+        axes = [ax]</span>
<span class="gi">+</span>
<span class="gi">+    for ax_i in axes:</span>
<span class="gi">+        for side in [&quot;top&quot;, &quot;right&quot;, &quot;left&quot;, &quot;bottom&quot;]:</span>
<span class="gi">+            # Toggle the spine objects</span>
<span class="gi">+            is_visible = not locals()[side]</span>
<span class="gi">+            ax_i.spines[side].set_visible(is_visible)</span>
<span class="gi">+            if offset is not None and is_visible:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    val = offset.get(side, 0)</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    val = offset</span>
<span class="gi">+                ax_i.spines[side].set_position((&#39;outward&#39;, val))</span>
<span class="gi">+</span>
<span class="gi">+        # Potentially move the ticks</span>
<span class="gi">+        if left and not right:</span>
<span class="gi">+            maj_on = any(</span>
<span class="gi">+                t.tick1line.get_visible()</span>
<span class="gi">+                for t in ax_i.yaxis.majorTicks</span>
<span class="gi">+            )</span>
<span class="gi">+            min_on = any(</span>
<span class="gi">+                t.tick1line.get_visible()</span>
<span class="gi">+                for t in ax_i.yaxis.minorTicks</span>
<span class="gi">+            )</span>
<span class="gi">+            ax_i.yaxis.set_ticks_position(&quot;right&quot;)</span>
<span class="gi">+            for t in ax_i.yaxis.majorTicks:</span>
<span class="gi">+                t.tick2line.set_visible(maj_on)</span>
<span class="gi">+            for t in ax_i.yaxis.minorTicks:</span>
<span class="gi">+                t.tick2line.set_visible(min_on)</span>
<span class="gi">+</span>
<span class="gi">+        if bottom and not top:</span>
<span class="gi">+            maj_on = any(</span>
<span class="gi">+                t.tick1line.get_visible()</span>
<span class="gi">+                for t in ax_i.xaxis.majorTicks</span>
<span class="gi">+            )</span>
<span class="gi">+            min_on = any(</span>
<span class="gi">+                t.tick1line.get_visible()</span>
<span class="gi">+                for t in ax_i.xaxis.minorTicks</span>
<span class="gi">+            )</span>
<span class="gi">+            ax_i.xaxis.set_ticks_position(&quot;top&quot;)</span>
<span class="gi">+            for t in ax_i.xaxis.majorTicks:</span>
<span class="gi">+                t.tick2line.set_visible(maj_on)</span>
<span class="gi">+            for t in ax_i.xaxis.minorTicks:</span>
<span class="gi">+                t.tick2line.set_visible(min_on)</span>
<span class="gi">+</span>
<span class="gi">+        if trim:</span>
<span class="gi">+            # clip off the parts of the spines that extend past major ticks</span>
<span class="gi">+            xticks = np.asarray(ax_i.get_xticks())</span>
<span class="gi">+            if xticks.size:</span>
<span class="gi">+                firsttick = np.compress(xticks &gt;= min(ax_i.get_xlim()),</span>
<span class="gi">+                                        xticks)[0]</span>
<span class="gi">+                lasttick = np.compress(xticks &lt;= max(ax_i.get_xlim()),</span>
<span class="gi">+                                       xticks)[-1]</span>
<span class="gi">+                ax_i.spines[&#39;bottom&#39;].set_bounds(firsttick, lasttick)</span>
<span class="gi">+                ax_i.spines[&#39;top&#39;].set_bounds(firsttick, lasttick)</span>
<span class="gi">+                newticks = xticks.compress(xticks &lt;= lasttick)</span>
<span class="gi">+                newticks = newticks.compress(newticks &gt;= firsttick)</span>
<span class="gi">+                ax_i.set_xticks(newticks)</span>
<span class="gi">+</span>
<span class="gi">+            yticks = np.asarray(ax_i.get_yticks())</span>
<span class="gi">+            if yticks.size:</span>
<span class="gi">+                firsttick = np.compress(yticks &gt;= min(ax_i.get_ylim()),</span>
<span class="gi">+                                        yticks)[0]</span>
<span class="gi">+                lasttick = np.compress(yticks &lt;= max(ax_i.get_ylim()),</span>
<span class="gi">+                                       yticks)[-1]</span>
<span class="gi">+                ax_i.spines[&#39;left&#39;].set_bounds(firsttick, lasttick)</span>
<span class="gi">+                ax_i.spines[&#39;right&#39;].set_bounds(firsttick, lasttick)</span>
<span class="gi">+                newticks = yticks.compress(yticks &lt;= lasttick)</span>
<span class="gi">+                newticks = newticks.compress(newticks &gt;= firsttick)</span>
<span class="gi">+                ax_i.set_yticks(newticks)</span>


<span class="w"> </span>def move_legend(obj, loc, **kwargs):
<span class="gu">@@ -204,17 +404,90 @@ def move_legend(obj, loc, **kwargs):</span>
<span class="w"> </span>    .. include:: ../docstrings/move_legend.rst

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This is a somewhat hackish solution that will hopefully be obviated by</span>
<span class="gi">+    # upstream improvements to matplotlib legends that make them easier to</span>
<span class="gi">+    # modify after creation.</span>
<span class="gi">+</span>
<span class="gi">+    from seaborn.axisgrid import Grid  # Avoid circular import</span>
<span class="gi">+</span>
<span class="gi">+    # Locate the legend object and a method to recreate the legend</span>
<span class="gi">+    if isinstance(obj, Grid):</span>
<span class="gi">+        old_legend = obj.legend</span>
<span class="gi">+        legend_func = obj.figure.legend</span>
<span class="gi">+    elif isinstance(obj, mpl.axes.Axes):</span>
<span class="gi">+        old_legend = obj.legend_</span>
<span class="gi">+        legend_func = obj.legend</span>
<span class="gi">+    elif isinstance(obj, mpl.figure.Figure):</span>
<span class="gi">+        if obj.legends:</span>
<span class="gi">+            old_legend = obj.legends[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            old_legend = None</span>
<span class="gi">+        legend_func = obj.legend</span>
<span class="gi">+    else:</span>
<span class="gi">+        err = &quot;`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.&quot;</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+    if old_legend is None:</span>
<span class="gi">+        err = f&quot;{obj} has no legend attached.&quot;</span>
<span class="gi">+        raise ValueError(err)</span>
<span class="gi">+</span>
<span class="gi">+    # Extract the components of the legend we need to reuse</span>
<span class="gi">+    # Import here to avoid a circular import</span>
<span class="gi">+    from seaborn._compat import get_legend_handles</span>
<span class="gi">+    handles = get_legend_handles(old_legend)</span>
<span class="gi">+    labels = [t.get_text() for t in old_legend.get_texts()]</span>
<span class="gi">+</span>
<span class="gi">+    # Handle the case where the user is trying to override the labels</span>
<span class="gi">+    if (new_labels := kwargs.pop(&quot;labels&quot;, None)) is not None:</span>
<span class="gi">+        if len(new_labels) != len(labels):</span>
<span class="gi">+            err = &quot;Length of new labels does not match existing legend.&quot;</span>
<span class="gi">+            raise ValueError(err)</span>
<span class="gi">+        labels = new_labels</span>
<span class="gi">+</span>
<span class="gi">+    # Extract legend properties that can be passed to the recreation method</span>
<span class="gi">+    # (Vexingly, these don&#39;t all round-trip)</span>
<span class="gi">+    legend_kws = inspect.signature(mpl.legend.Legend).parameters</span>
<span class="gi">+    props = {k: v for k, v in old_legend.properties().items() if k in legend_kws}</span>
<span class="gi">+</span>
<span class="gi">+    # Delegate default bbox_to_anchor rules to matplotlib</span>
<span class="gi">+    props.pop(&quot;bbox_to_anchor&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Try to propagate the existing title and font properties; respect new ones too</span>
<span class="gi">+    title = props.pop(&quot;title&quot;)</span>
<span class="gi">+    if &quot;title&quot; in kwargs:</span>
<span class="gi">+        title.set_text(kwargs.pop(&quot;title&quot;))</span>
<span class="gi">+    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith(&quot;title_&quot;)}</span>
<span class="gi">+    for key, val in title_kwargs.items():</span>
<span class="gi">+        title.set(**{key[6:]: val})</span>
<span class="gi">+        kwargs.pop(key)</span>
<span class="gi">+</span>
<span class="gi">+    # Try to respect the frame visibility</span>
<span class="gi">+    kwargs.setdefault(&quot;frameon&quot;, old_legend.legendPatch.get_visible())</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the old legend and create the new one</span>
<span class="gi">+    props.update(kwargs)</span>
<span class="gi">+    old_legend.remove()</span>
<span class="gi">+    new_legend = legend_func(handles, labels, loc=loc, **props)</span>
<span class="gi">+    new_legend.set_title(title.get_text(), title.get_fontproperties())</span>
<span class="gi">+</span>
<span class="gi">+    # Let the Grid object continue to track the correct legend object</span>
<span class="gi">+    if isinstance(obj, Grid):</span>
<span class="gi">+        obj._legend = new_legend</span>


<span class="w"> </span>def _kde_support(data, bw, gridsize, cut, clip):
<span class="w"> </span>    &quot;&quot;&quot;Establish support for a kernel density estimate.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    support_min = max(data.min() - bw * cut, clip[0])</span>
<span class="gi">+    support_max = min(data.max() + bw * cut, clip[1])</span>
<span class="gi">+    support = np.linspace(support_min, support_max, gridsize)</span>
<span class="gi">+</span>
<span class="gi">+    return support</span>


<span class="w"> </span>def ci(a, which=95, axis=None):
<span class="w"> </span>    &quot;&quot;&quot;Return a percentile range from an array of values.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p = 50 - which / 2, 50 + which / 2</span>
<span class="gi">+    return np.nanpercentile(a, p, axis)</span>


<span class="w"> </span>def get_dataset_names():
<span class="gu">@@ -223,7 +496,11 @@ def get_dataset_names():</span>
<span class="w"> </span>    Requires an internet connection.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with urlopen(DATASET_NAMES_URL) as resp:</span>
<span class="gi">+        txt = resp.read()</span>
<span class="gi">+</span>
<span class="gi">+    dataset_names = [name.strip() for name in txt.decode().split(&quot;\n&quot;)]</span>
<span class="gi">+    return list(filter(None, dataset_names))</span>


<span class="w"> </span>def get_data_home(data_home=None):
<span class="gu">@@ -236,7 +513,12 @@ def get_data_home(data_home=None):</span>
<span class="w"> </span>    or otherwise default to an OS-appropriate user cache location.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data_home is None:</span>
<span class="gi">+        data_home = os.environ.get(&quot;SEABORN_DATA&quot;, user_cache_dir(&quot;seaborn&quot;))</span>
<span class="gi">+    data_home = os.path.expanduser(data_home)</span>
<span class="gi">+    if not os.path.exists(data_home):</span>
<span class="gi">+        os.makedirs(data_home)</span>
<span class="gi">+    return data_home</span>


<span class="w"> </span>def load_dataset(name, cache=True, data_home=None, **kws):
<span class="gu">@@ -271,7 +553,80 @@ def load_dataset(name, cache=True, data_home=None, **kws):</span>
<span class="w"> </span>        Tabular data, possibly with some preprocessing applied.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # A common beginner mistake is to assume that one&#39;s personal data needs</span>
<span class="gi">+    # to be passed through this function to be usable with seaborn.</span>
<span class="gi">+    # Let&#39;s provide a more helpful error than you would otherwise get.</span>
<span class="gi">+    if isinstance(name, pd.DataFrame):</span>
<span class="gi">+        err = (</span>
<span class="gi">+            &quot;This function accepts only strings (the name of an example dataset). &quot;</span>
<span class="gi">+            &quot;You passed a pandas DataFrame. If you have your own dataset, &quot;</span>
<span class="gi">+            &quot;it is not necessary to use this function before plotting.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise TypeError(err)</span>
<span class="gi">+</span>
<span class="gi">+    url = f&quot;{DATASET_SOURCE}/{name}.csv&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if cache:</span>
<span class="gi">+        cache_path = os.path.join(get_data_home(data_home), os.path.basename(url))</span>
<span class="gi">+        if not os.path.exists(cache_path):</span>
<span class="gi">+            if name not in get_dataset_names():</span>
<span class="gi">+                raise ValueError(f&quot;&#39;{name}&#39; is not one of the example datasets.&quot;)</span>
<span class="gi">+            urlretrieve(url, cache_path)</span>
<span class="gi">+        full_path = cache_path</span>
<span class="gi">+    else:</span>
<span class="gi">+        full_path = url</span>
<span class="gi">+</span>
<span class="gi">+    df = pd.read_csv(full_path, **kws)</span>
<span class="gi">+</span>
<span class="gi">+    if df.iloc[-1].isnull().all():</span>
<span class="gi">+        df = df.iloc[:-1]</span>
<span class="gi">+</span>
<span class="gi">+    # Set some columns as a categorical type with ordered levels</span>
<span class="gi">+</span>
<span class="gi">+    if name == &quot;tips&quot;:</span>
<span class="gi">+        df[&quot;day&quot;] = pd.Categorical(df[&quot;day&quot;], [&quot;Thur&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;])</span>
<span class="gi">+        df[&quot;sex&quot;] = pd.Categorical(df[&quot;sex&quot;], [&quot;Male&quot;, &quot;Female&quot;])</span>
<span class="gi">+        df[&quot;time&quot;] = pd.Categorical(df[&quot;time&quot;], [&quot;Lunch&quot;, &quot;Dinner&quot;])</span>
<span class="gi">+        df[&quot;smoker&quot;] = pd.Categorical(df[&quot;smoker&quot;], [&quot;Yes&quot;, &quot;No&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;flights&quot;:</span>
<span class="gi">+        months = df[&quot;month&quot;].str[:3]</span>
<span class="gi">+        df[&quot;month&quot;] = pd.Categorical(months, months.unique())</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;exercise&quot;:</span>
<span class="gi">+        df[&quot;time&quot;] = pd.Categorical(df[&quot;time&quot;], [&quot;1 min&quot;, &quot;15 min&quot;, &quot;30 min&quot;])</span>
<span class="gi">+        df[&quot;kind&quot;] = pd.Categorical(df[&quot;kind&quot;], [&quot;rest&quot;, &quot;walking&quot;, &quot;running&quot;])</span>
<span class="gi">+        df[&quot;diet&quot;] = pd.Categorical(df[&quot;diet&quot;], [&quot;no fat&quot;, &quot;low fat&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;titanic&quot;:</span>
<span class="gi">+        df[&quot;class&quot;] = pd.Categorical(df[&quot;class&quot;], [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])</span>
<span class="gi">+        df[&quot;deck&quot;] = pd.Categorical(df[&quot;deck&quot;], list(&quot;ABCDEFG&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;penguins&quot;:</span>
<span class="gi">+        df[&quot;sex&quot;] = df[&quot;sex&quot;].str.title()</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;diamonds&quot;:</span>
<span class="gi">+        df[&quot;color&quot;] = pd.Categorical(</span>
<span class="gi">+            df[&quot;color&quot;], [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+        df[&quot;clarity&quot;] = pd.Categorical(</span>
<span class="gi">+            df[&quot;clarity&quot;], [&quot;IF&quot;, &quot;VVS1&quot;, &quot;VVS2&quot;, &quot;VS1&quot;, &quot;VS2&quot;, &quot;SI1&quot;, &quot;SI2&quot;, &quot;I1&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+        df[&quot;cut&quot;] = pd.Categorical(</span>
<span class="gi">+            df[&quot;cut&quot;], [&quot;Ideal&quot;, &quot;Premium&quot;, &quot;Very Good&quot;, &quot;Good&quot;, &quot;Fair&quot;],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;taxis&quot;:</span>
<span class="gi">+        df[&quot;pickup&quot;] = pd.to_datetime(df[&quot;pickup&quot;])</span>
<span class="gi">+        df[&quot;dropoff&quot;] = pd.to_datetime(df[&quot;dropoff&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;seaice&quot;:</span>
<span class="gi">+        df[&quot;Date&quot;] = pd.to_datetime(df[&quot;Date&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    elif name == &quot;dowjones&quot;:</span>
<span class="gi">+        df[&quot;Date&quot;] = pd.to_datetime(df[&quot;Date&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    return df</span>


<span class="w"> </span>def axis_ticklabels_overlap(labels):
<span class="gu">@@ -287,7 +642,15 @@ def axis_ticklabels_overlap(labels):</span>
<span class="w"> </span>        True if any of the labels overlap.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not labels:</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        bboxes = [l.get_window_extent() for l in labels]</span>
<span class="gi">+        overlaps = [b.count_overlaps(bboxes) for b in bboxes]</span>
<span class="gi">+        return max(overlaps) &gt; 1</span>
<span class="gi">+    except RuntimeError:</span>
<span class="gi">+        # Issue on macos backend raises an error in the above code</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def axes_ticklabels_overlap(ax):
<span class="gu">@@ -303,12 +666,34 @@ def axes_ticklabels_overlap(ax):</span>
<span class="w"> </span>        True when the labels on that axis overlap.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (axis_ticklabels_overlap(ax.get_xticklabels()),</span>
<span class="gi">+            axis_ticklabels_overlap(ax.get_yticklabels()))</span>


<span class="w"> </span>def locator_to_legend_entries(locator, limits, dtype):
<span class="w"> </span>    &quot;&quot;&quot;Return levels and formatted levels for brief numeric legends.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raw_levels = locator.tick_values(*limits).astype(dtype)</span>
<span class="gi">+</span>
<span class="gi">+    # The locator can return ticks outside the limits, clip them here</span>
<span class="gi">+    raw_levels = [l for l in raw_levels if l &gt;= limits[0] and l &lt;= limits[1]]</span>
<span class="gi">+</span>
<span class="gi">+    class dummy_axis:</span>
<span class="gi">+        def get_view_interval(self):</span>
<span class="gi">+            return limits</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(locator, mpl.ticker.LogLocator):</span>
<span class="gi">+        formatter = mpl.ticker.LogFormatter()</span>
<span class="gi">+    else:</span>
<span class="gi">+        formatter = mpl.ticker.ScalarFormatter()</span>
<span class="gi">+        # Avoid having an offset/scientific notation which we don&#39;t currently</span>
<span class="gi">+        # have any way of representing in the legend</span>
<span class="gi">+        formatter.set_useOffset(False)</span>
<span class="gi">+        formatter.set_scientific(False)</span>
<span class="gi">+    formatter.axis = dummy_axis()</span>
<span class="gi">+</span>
<span class="gi">+    formatted_levels = formatter.format_ticks(raw_levels)</span>
<span class="gi">+</span>
<span class="gi">+    return raw_levels, formatted_levels</span>


<span class="w"> </span>def relative_luminance(color):
<span class="gu">@@ -324,7 +709,13 @@ def relative_luminance(color):</span>
<span class="w"> </span>    luminance : float(s) between 0 and 1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]</span>
<span class="gi">+    rgb = np.where(rgb &lt;= .03928, rgb / 12.92, ((rgb + .055) / 1.055) ** 2.4)</span>
<span class="gi">+    lum = rgb.dot([.2126, .7152, .0722])</span>
<span class="gi">+    try:</span>
<span class="gi">+        return lum.item()</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return lum</span>


<span class="w"> </span>def to_utf8(obj):
<span class="gu">@@ -348,17 +739,45 @@ def to_utf8(obj):</span>
<span class="w"> </span>        UTF-8-decoded string representation of ``obj``

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, str):</span>
<span class="gi">+        return obj</span>
<span class="gi">+    try:</span>
<span class="gi">+        return obj.decode(encoding=&quot;utf-8&quot;)</span>
<span class="gi">+    except AttributeError:  # obj is not bytes-like</span>
<span class="gi">+        return str(obj)</span>


<span class="w"> </span>def _check_argument(param, options, value, prefix=False):
<span class="w"> </span>    &quot;&quot;&quot;Raise if value for param is not in options.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if prefix and value is not None:</span>
<span class="gi">+        failure = not any(value.startswith(p) for p in options if isinstance(p, str))</span>
<span class="gi">+    else:</span>
<span class="gi">+        failure = value not in options</span>
<span class="gi">+    if failure:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&quot;The value for `{param}` must be one of {options}, &quot;</span>
<span class="gi">+            f&quot;but {repr(value)} was passed.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def _assign_default_kwargs(kws, call_func, source_func):
<span class="w"> </span>    &quot;&quot;&quot;Assign default kwargs for call_func using values from source_func.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This exists so that axes-level functions and figure-level functions can</span>
<span class="gi">+    # both call a Plotter method while having the default kwargs be defined in</span>
<span class="gi">+    # the signature of the axes-level function.</span>
<span class="gi">+    # An alternative would be to have a decorator on the method that sets its</span>
<span class="gi">+    # defaults based on those defined in the axes-level function.</span>
<span class="gi">+    # Then the figure-level function would not need to worry about defaults.</span>
<span class="gi">+    # I am not sure which is better.</span>
<span class="gi">+    needed = inspect.signature(call_func).parameters</span>
<span class="gi">+    defaults = inspect.signature(source_func).parameters</span>
<span class="gi">+</span>
<span class="gi">+    for param in needed:</span>
<span class="gi">+        if param in defaults and param not in kws:</span>
<span class="gi">+            kws[param] = defaults[param].default</span>
<span class="gi">+</span>
<span class="gi">+    return kws</span>


<span class="w"> </span>def adjust_legend_subtitles(legend):
<span class="gu">@@ -368,7 +787,17 @@ def adjust_legend_subtitles(legend):</span>
<span class="w"> </span>    Note: This function is not part of the public API and may be changed or removed.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Legend title not in rcParams until 3.0</span>
<span class="gi">+    font_size = plt.rcParams.get(&quot;legend.title_fontsize&quot;, None)</span>
<span class="gi">+    hpackers = legend.findobj(mpl.offsetbox.VPacker)[0].get_children()</span>
<span class="gi">+    for hpack in hpackers:</span>
<span class="gi">+        draw_area, text_area = hpack.get_children()</span>
<span class="gi">+        handles = draw_area.get_children()</span>
<span class="gi">+        if not all(artist.get_visible() for artist in handles):</span>
<span class="gi">+            draw_area.set_width(0)</span>
<span class="gi">+            for text in text_area.get_children():</span>
<span class="gi">+                if font_size is not None:</span>
<span class="gi">+                    text.set_size(font_size)</span>


<span class="w"> </span>def _deprecate_ci(errorbar, ci):
<span class="gu">@@ -380,20 +809,89 @@ def _deprecate_ci(errorbar, ci):</span>
<span class="w"> </span>    (and extracted from kwargs) after one cycle.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ci is not deprecated and ci != &quot;deprecated&quot;:</span>
<span class="gi">+        if ci is None:</span>
<span class="gi">+            errorbar = None</span>
<span class="gi">+        elif ci == &quot;sd&quot;:</span>
<span class="gi">+            errorbar = &quot;sd&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            errorbar = (&quot;ci&quot;, ci)</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;\n\nThe `ci` parameter is deprecated. &quot;</span>
<span class="gi">+            f&quot;Use `errorbar={repr(errorbar)}` for the same effect.\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        warnings.warn(msg, FutureWarning, stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+    return errorbar</span>


<span class="w"> </span>def _get_transform_functions(ax, axis):
<span class="w"> </span>    &quot;&quot;&quot;Return the forward and inverse transforms for a given axis.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    axis_obj = getattr(ax, f&quot;{axis}axis&quot;)</span>
<span class="gi">+    transform = axis_obj.get_transform()</span>
<span class="gi">+    return transform.transform, transform.inverted().transform</span>


<span class="w"> </span>@contextmanager
<span class="w"> </span>def _disable_autolayout():
<span class="w"> </span>    &quot;&quot;&quot;Context manager for preventing rc-controlled auto-layout behavior.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This is a workaround for an issue in matplotlib, for details see</span>
<span class="gi">+    # https://github.com/mwaskom/seaborn/issues/2914</span>
<span class="gi">+    # The only affect of this rcParam is to set the default value for</span>
<span class="gi">+    # layout= in plt.figure, so we could just do that instead.</span>
<span class="gi">+    # But then we would need to own the complexity of the transition</span>
<span class="gi">+    # from tight_layout=True -&gt; layout=&quot;tight&quot;. This seems easier,</span>
<span class="gi">+    # but can be removed when (if) that is simpler on the matplotlib side,</span>
<span class="gi">+    # or if the layout algorithms are improved to handle figure legends.</span>
<span class="gi">+    orig_val = mpl.rcParams[&quot;figure.autolayout&quot;]</span>
<span class="gi">+    try:</span>
<span class="gi">+        mpl.rcParams[&quot;figure.autolayout&quot;] = False</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        mpl.rcParams[&quot;figure.autolayout&quot;] = orig_val</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _version_predates(lib: ModuleType, version: str) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Helper function for checking version compatibility.&quot;&quot;&quot;</span>
<span class="gi">+    return Version(lib.__version__) &lt; Version(version)</span>


<span class="gd">-def _version_predates(lib: ModuleType, version: str) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Helper function for checking version compatibility.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _scatter_legend_artist(**kws):</span>
<span class="gi">+</span>
<span class="gi">+    kws = normalize_kwargs(kws, mpl.collections.PathCollection)</span>
<span class="gi">+</span>
<span class="gi">+    edgecolor = kws.pop(&quot;edgecolor&quot;, None)</span>
<span class="gi">+    rc = mpl.rcParams</span>
<span class="gi">+    line_kws = {</span>
<span class="gi">+        &quot;linestyle&quot;: &quot;&quot;,</span>
<span class="gi">+        &quot;marker&quot;: kws.pop(&quot;marker&quot;, &quot;o&quot;),</span>
<span class="gi">+        &quot;markersize&quot;: np.sqrt(kws.pop(&quot;s&quot;, rc[&quot;lines.markersize&quot;] ** 2)),</span>
<span class="gi">+        &quot;markerfacecolor&quot;: kws.pop(&quot;facecolor&quot;, kws.get(&quot;color&quot;)),</span>
<span class="gi">+        &quot;markeredgewidth&quot;: kws.pop(&quot;linewidth&quot;, 0),</span>
<span class="gi">+        **kws,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if edgecolor is not None:</span>
<span class="gi">+        if edgecolor == &quot;face&quot;:</span>
<span class="gi">+            line_kws[&quot;markeredgecolor&quot;] = line_kws[&quot;markerfacecolor&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            line_kws[&quot;markeredgecolor&quot;] = edgecolor</span>
<span class="gi">+</span>
<span class="gi">+    return mpl.lines.Line2D([], [], **line_kws)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_patch_legend_artist(fill):</span>
<span class="gi">+</span>
<span class="gi">+    def legend_artist(**kws):</span>
<span class="gi">+</span>
<span class="gi">+        color = kws.pop(&quot;color&quot;, None)</span>
<span class="gi">+        if color is not None:</span>
<span class="gi">+            if fill:</span>
<span class="gi">+                kws[&quot;facecolor&quot;] = color</span>
<span class="gi">+            else:</span>
<span class="gi">+                kws[&quot;edgecolor&quot;] = color</span>
<span class="gi">+                kws[&quot;facecolor&quot;] = &quot;none&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return mpl.patches.Rectangle((0, 0), 0, 0, **kws)</span>
<span class="gi">+</span>
<span class="gi">+    return legend_artist</span>
<span class="gh">diff --git a/seaborn/widgets.py b/seaborn/widgets.py</span>
<span class="gh">index 3941f65b..502812af 100644</span>
<span class="gd">--- a/seaborn/widgets.py</span>
<span class="gi">+++ b/seaborn/widgets.py</span>
<span class="gu">@@ -1,28 +1,47 @@</span>
<span class="w"> </span>import numpy as np
<span class="w"> </span>import matplotlib.pyplot as plt
<span class="w"> </span>from matplotlib.colors import LinearSegmentedColormap
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from ipywidgets import interact, FloatSlider, IntSlider
<span class="w"> </span>except ImportError:
<span class="gi">+    def interact(f):</span>
<span class="gi">+        msg = &quot;Interactive palettes require `ipywidgets`, which is not installed.&quot;</span>
<span class="gi">+        raise ImportError(msg)</span>
<span class="gi">+</span>
<span class="w"> </span>from .miscplot import palplot
<span class="gd">-from .palettes import color_palette, dark_palette, light_palette, diverging_palette, cubehelix_palette</span>
<span class="gd">-__all__ = [&#39;choose_colorbrewer_palette&#39;, &#39;choose_cubehelix_palette&#39;,</span>
<span class="gd">-    &#39;choose_dark_palette&#39;, &#39;choose_light_palette&#39;, &#39;choose_diverging_palette&#39;]</span>
<span class="gi">+from .palettes import (color_palette, dark_palette, light_palette,</span>
<span class="gi">+                       diverging_palette, cubehelix_palette)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;choose_colorbrewer_palette&quot;, &quot;choose_cubehelix_palette&quot;,</span>
<span class="gi">+           &quot;choose_dark_palette&quot;, &quot;choose_light_palette&quot;,</span>
<span class="gi">+           &quot;choose_diverging_palette&quot;]</span>


<span class="w"> </span>def _init_mutable_colormap():
<span class="w"> </span>    &quot;&quot;&quot;Create a matplotlib colormap that will be updated by the widgets.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    greys = color_palette(&quot;Greys&quot;, 256)</span>
<span class="gi">+    cmap = LinearSegmentedColormap.from_list(&quot;interactive&quot;, greys)</span>
<span class="gi">+    cmap._init()</span>
<span class="gi">+    cmap._set_extremes()</span>
<span class="gi">+    return cmap</span>


<span class="w"> </span>def _update_lut(cmap, colors):
<span class="w"> </span>    &quot;&quot;&quot;Change the LUT values in a matplotlib colormap in-place.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cmap._lut[:256] = colors</span>
<span class="gi">+    cmap._set_extremes()</span>


<span class="w"> </span>def _show_cmap(cmap):
<span class="w"> </span>    &quot;&quot;&quot;Show a continuous matplotlib colormap.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .rcmod import axes_style  # Avoid circular import</span>
<span class="gi">+    with axes_style(&quot;white&quot;):</span>
<span class="gi">+        f, ax = plt.subplots(figsize=(8.25, .75))</span>
<span class="gi">+    ax.set(xticks=[], yticks=[])</span>
<span class="gi">+    x = np.linspace(0, 1, 256)[np.newaxis, :]</span>
<span class="gi">+    ax.pcolormesh(x, cmap=cmap)</span>


<span class="w"> </span>def choose_colorbrewer_palette(data_type, as_cmap=False):
<span class="gu">@@ -57,10 +76,71 @@ def choose_colorbrewer_palette(data_type, as_cmap=False):</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def choose_dark_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="gi">+    if data_type.startswith(&quot;q&quot;) and as_cmap:</span>
<span class="gi">+        raise ValueError(&quot;Qualitative palettes cannot be colormaps.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    pal = []</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        cmap = _init_mutable_colormap()</span>
<span class="gi">+</span>
<span class="gi">+    if data_type.startswith(&quot;s&quot;):</span>
<span class="gi">+        opts = [&quot;Greys&quot;, &quot;Reds&quot;, &quot;Greens&quot;, &quot;Blues&quot;, &quot;Oranges&quot;, &quot;Purples&quot;,</span>
<span class="gi">+                &quot;BuGn&quot;, &quot;BuPu&quot;, &quot;GnBu&quot;, &quot;OrRd&quot;, &quot;PuBu&quot;, &quot;PuRd&quot;, &quot;RdPu&quot;, &quot;YlGn&quot;,</span>
<span class="gi">+                &quot;PuBuGn&quot;, &quot;YlGnBu&quot;, &quot;YlOrBr&quot;, &quot;YlOrRd&quot;]</span>
<span class="gi">+        variants = [&quot;regular&quot;, &quot;reverse&quot;, &quot;dark&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_sequential(name=opts, n=(2, 18),</span>
<span class="gi">+                              desat=FloatSlider(min=0, max=1, value=1),</span>
<span class="gi">+                              variant=variants):</span>
<span class="gi">+            if variant == &quot;reverse&quot;:</span>
<span class="gi">+                name += &quot;_r&quot;</span>
<span class="gi">+            elif variant == &quot;dark&quot;:</span>
<span class="gi">+                name += &quot;_d&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = color_palette(name, 256, desat)</span>
<span class="gi">+                _update_lut(cmap, np.c_[colors, np.ones(256)])</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = color_palette(name, n, desat)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif data_type.startswith(&quot;d&quot;):</span>
<span class="gi">+        opts = [&quot;RdBu&quot;, &quot;RdGy&quot;, &quot;PRGn&quot;, &quot;PiYG&quot;, &quot;BrBG&quot;,</span>
<span class="gi">+                &quot;RdYlBu&quot;, &quot;RdYlGn&quot;, &quot;Spectral&quot;]</span>
<span class="gi">+        variants = [&quot;regular&quot;, &quot;reverse&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_diverging(name=opts, n=(2, 16),</span>
<span class="gi">+                             desat=FloatSlider(min=0, max=1, value=1),</span>
<span class="gi">+                             variant=variants):</span>
<span class="gi">+            if variant == &quot;reverse&quot;:</span>
<span class="gi">+                name += &quot;_r&quot;</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = color_palette(name, 256, desat)</span>
<span class="gi">+                _update_lut(cmap, np.c_[colors, np.ones(256)])</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = color_palette(name, n, desat)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif data_type.startswith(&quot;q&quot;):</span>
<span class="gi">+        opts = [&quot;Set1&quot;, &quot;Set2&quot;, &quot;Set3&quot;, &quot;Paired&quot;, &quot;Accent&quot;,</span>
<span class="gi">+                &quot;Pastel1&quot;, &quot;Pastel2&quot;, &quot;Dark2&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_qualitative(name=opts, n=(2, 16),</span>
<span class="gi">+                               desat=FloatSlider(min=0, max=1, value=1)):</span>
<span class="gi">+            pal[:] = color_palette(name, n, desat)</span>
<span class="gi">+            palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    return pal</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def choose_dark_palette(input=&quot;husl&quot;, as_cmap=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Launch an interactive widget to create a dark sequential palette.

<span class="w"> </span>    This corresponds with the :func:`dark_palette` function. This kind
<span class="gu">@@ -91,10 +171,61 @@ def choose_dark_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def choose_light_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="gi">+    pal = []</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        cmap = _init_mutable_colormap()</span>
<span class="gi">+</span>
<span class="gi">+    if input == &quot;rgb&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_dark_palette_rgb(r=(0., 1.),</span>
<span class="gi">+                                    g=(0., 1.),</span>
<span class="gi">+                                    b=(0., 1.),</span>
<span class="gi">+                                    n=(3, 17)):</span>
<span class="gi">+            color = r, g, b</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = dark_palette(color, 256, input=&quot;rgb&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = dark_palette(color, n, input=&quot;rgb&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif input == &quot;hls&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_dark_palette_hls(h=(0., 1.),</span>
<span class="gi">+                                    l=(0., 1.),  # noqa: E741</span>
<span class="gi">+                                    s=(0., 1.),</span>
<span class="gi">+                                    n=(3, 17)):</span>
<span class="gi">+            color = h, l, s</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = dark_palette(color, 256, input=&quot;hls&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = dark_palette(color, n, input=&quot;hls&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif input == &quot;husl&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_dark_palette_husl(h=(0, 359),</span>
<span class="gi">+                                     s=(0, 99),</span>
<span class="gi">+                                     l=(0, 99),  # noqa: E741</span>
<span class="gi">+                                     n=(3, 17)):</span>
<span class="gi">+            color = h, s, l</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = dark_palette(color, 256, input=&quot;husl&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = dark_palette(color, n, input=&quot;husl&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    return pal</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def choose_light_palette(input=&quot;husl&quot;, as_cmap=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Launch an interactive widget to create a light sequential palette.

<span class="w"> </span>    This corresponds with the :func:`light_palette` function. This kind
<span class="gu">@@ -125,7 +256,58 @@ def choose_light_palette(input=&#39;husl&#39;, as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pal = []</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        cmap = _init_mutable_colormap()</span>
<span class="gi">+</span>
<span class="gi">+    if input == &quot;rgb&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_light_palette_rgb(r=(0., 1.),</span>
<span class="gi">+                                     g=(0., 1.),</span>
<span class="gi">+                                     b=(0., 1.),</span>
<span class="gi">+                                     n=(3, 17)):</span>
<span class="gi">+            color = r, g, b</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = light_palette(color, 256, input=&quot;rgb&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = light_palette(color, n, input=&quot;rgb&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif input == &quot;hls&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_light_palette_hls(h=(0., 1.),</span>
<span class="gi">+                                     l=(0., 1.),  # noqa: E741</span>
<span class="gi">+                                     s=(0., 1.),</span>
<span class="gi">+                                     n=(3, 17)):</span>
<span class="gi">+            color = h, l, s</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = light_palette(color, 256, input=&quot;hls&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = light_palette(color, n, input=&quot;hls&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    elif input == &quot;husl&quot;:</span>
<span class="gi">+        @interact</span>
<span class="gi">+        def choose_light_palette_husl(h=(0, 359),</span>
<span class="gi">+                                      s=(0, 99),</span>
<span class="gi">+                                      l=(0, 99),  # noqa: E741</span>
<span class="gi">+                                      n=(3, 17)):</span>
<span class="gi">+            color = h, s, l</span>
<span class="gi">+            if as_cmap:</span>
<span class="gi">+                colors = light_palette(color, 256, input=&quot;husl&quot;)</span>
<span class="gi">+                _update_lut(cmap, colors)</span>
<span class="gi">+                _show_cmap(cmap)</span>
<span class="gi">+            else:</span>
<span class="gi">+                pal[:] = light_palette(color, n, input=&quot;husl&quot;)</span>
<span class="gi">+                palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    return pal</span>


<span class="w"> </span>def choose_diverging_palette(as_cmap=False):
<span class="gu">@@ -156,7 +338,35 @@ def choose_diverging_palette(as_cmap=False):</span>
<span class="w"> </span>                                 colorbrewer set, including diverging palettes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pal = []</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        cmap = _init_mutable_colormap()</span>
<span class="gi">+</span>
<span class="gi">+    @interact</span>
<span class="gi">+    def choose_diverging_palette(</span>
<span class="gi">+        h_neg=IntSlider(min=0,</span>
<span class="gi">+                        max=359,</span>
<span class="gi">+                        value=220),</span>
<span class="gi">+        h_pos=IntSlider(min=0,</span>
<span class="gi">+                        max=359,</span>
<span class="gi">+                        value=10),</span>
<span class="gi">+        s=IntSlider(min=0, max=99, value=74),</span>
<span class="gi">+        l=IntSlider(min=0, max=99, value=50),  # noqa: E741</span>
<span class="gi">+        sep=IntSlider(min=1, max=50, value=10),</span>
<span class="gi">+        n=(2, 16),</span>
<span class="gi">+        center=[&quot;light&quot;, &quot;dark&quot;]</span>
<span class="gi">+    ):</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)</span>
<span class="gi">+            _update_lut(cmap, colors)</span>
<span class="gi">+            _show_cmap(cmap)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)</span>
<span class="gi">+            palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    return pal</span>


<span class="w"> </span>def choose_cubehelix_palette(as_cmap=False):
<span class="gu">@@ -187,4 +397,30 @@ def choose_cubehelix_palette(as_cmap=False):</span>
<span class="w"> </span>                        cubehelix system.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pal = []</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        cmap = _init_mutable_colormap()</span>
<span class="gi">+</span>
<span class="gi">+    @interact</span>
<span class="gi">+    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),</span>
<span class="gi">+                         start=FloatSlider(min=0, max=3, value=0),</span>
<span class="gi">+                         rot=FloatSlider(min=-1, max=1, value=.4),</span>
<span class="gi">+                         gamma=FloatSlider(min=0, max=5, value=1),</span>
<span class="gi">+                         hue=FloatSlider(min=0, max=1, value=.8),</span>
<span class="gi">+                         light=FloatSlider(min=0, max=1, value=.85),</span>
<span class="gi">+                         dark=FloatSlider(min=0, max=1, value=.15),</span>
<span class="gi">+                         reverse=False):</span>
<span class="gi">+</span>
<span class="gi">+        if as_cmap:</span>
<span class="gi">+            colors = cubehelix_palette(256, start, rot, gamma,</span>
<span class="gi">+                                       hue, light, dark, reverse)</span>
<span class="gi">+            _update_lut(cmap, np.c_[colors, np.ones(256)])</span>
<span class="gi">+            _show_cmap(cmap)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,</span>
<span class="gi">+                                       hue, light, dark, reverse)</span>
<span class="gi">+            palplot(pal)</span>
<span class="gi">+</span>
<span class="gi">+    if as_cmap:</span>
<span class="gi">+        return cmap</span>
<span class="gi">+    return pal</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>