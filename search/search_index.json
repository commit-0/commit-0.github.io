{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>Commit-0 is a from scratch AI coding challenge. Can you create a library from commit 0?</p> <p>The benchmark consists of 57 core Python libraries. The challenge is to rebuild these libraries and pass their unit tests.  All libraries have:</p> <ul> <li>Significant test coverage</li> <li>Detailed specification and documentation</li> <li>Lint and type checking</li> </ul> <p>Commit-0 is an interactive environment that makes it easy to design and test new agents. You can:</p> <ul> <li>Efficiently run tests in isolated environemnts</li> <li>Distribute testing and development across cloud systems</li> <li>Track and log all changes made throughout.</li> </ul> <p>To install run:</p> <pre><code>pip install commit0\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#libraries","title":"Libraries","text":"Name Repo Commit0 Tests minitorch [orig] [commit0] 230 simpy [orig] [commit0] 140 bitstring [orig] [commit0] 834 tinydb [orig] [commit0] 201 marshmallow [orig] [commit0] 1229 python-prompt-toolkit [orig] [commit0] 151 parsel [orig] [commit0] 343 pyjwt pyjwt [orig] [commit0] 259 networkx [orig] [commit0] 5440 graphene [orig] [commit0] 447 tlslite-ng tlslite-ng [orig] [commit0] 1653 wcwidth wcwidth [orig] [commit0] 38 chardet chardet [orig] [commit0] 376 dnspython dnspython [orig] [commit0] 1304 imapclient imapclient [orig] [commit0] 267 virtualenv [orig] [commit0] 284 pexpect pexpect [orig] [commit0] 255 web3.py [orig] [commit0] 40433 babel [orig] [commit0] 5663 geopandas [orig] [commit0] 2196 dulwich dulwich [orig] [commit0] 1522 flask [orig] [commit0] 477 voluptuous voluptuous [orig] [commit0] 149 jinja [orig] [commit0] 851 seaborn [orig] [commit0] 2362 requests requests [orig] [commit0] 590 scrapy [orig] [commit0] 2904 fastapi [orig] [commit0] 2013 click [orig] [commit0] 589 python-rsa [orig] [commit0] 86 statsmodels [orig] [commit0] 17669 more-itertools more-itertools [orig] [commit0] 662 moviepy [orig] [commit0] 109 deprecated deprecated [orig] [commit0] 171 pydantic [orig] [commit0] 5091 loguru [orig] [commit0] 1461 pypdf [orig] [commit0] 911 attrs [orig] [commit0] 1414 mimesis [orig] [commit0] 6159 cookiecutter [orig] [commit0] 367 tornado [orig] [commit0] 1150 imbalanced-learn [orig] [commit0] 2310 python-progressbar [orig] [commit0] 385 PyBoy [orig] [commit0] 201 pytest [orig] [commit0] 3612 pylint [orig] [commit0] 1878 sphinx [orig] [commit0] 2187 joblib [orig] [commit0] 1450 xarray [orig] [commit0] 15643 cachetools cachetools [orig] [commit0] 215 paramiko paramiko [orig] [commit0] 557 fabric [orig] [commit0] 353 filesystem_spec [orig] [commit0] 698 jedi jedi [orig] [commit0] 3854 sqlparse sqlparse [orig] [commit0] 461 portalocker [orig] [commit0] 38"},{"location":"about/","title":"About","text":"<p>Commit0 is ..</p>"},{"location":"agent/","title":"Agent","text":"<p>Commit0 provides a command-line <code>agent</code> for configuring and running AI agents to assist with code development and testing. In this example we use Aider as the baseline code completion agent</p> <pre><code>pip install aider\n</code></pre> <p>First we assume there is an underlying <code>commit0</code> project that is configured. To create a new project, run the commit0 <code>setup</code> command.</p> <pre><code>commit0 setup lite\n</code></pre> <p>Next we need to configure the backend for the agent. Currently we only support the aider backend. Config can also be used to pass in arguments.</p> <pre><code>export ANTHROPIC_API_KEY=\"...\"\nagent config aider\n</code></pre> <p>Finally we run the underlying agent. This will create a display that shows the current progress of the agent.</p> <pre><code>agent run\n</code></pre>"},{"location":"agent/#extending","title":"Extending","text":"<p>Refer to <code>class Agents</code> in <code>agent/agents.py</code>. You can design your own agent by inheriting <code>Agents</code> class and implement the <code>run</code> method.</p>"},{"location":"agent/#notes","title":"Notes","text":"<ul> <li>Aider automatically retries certain API errors. For details, see here.</li> <li>When increasing --max-parallel-repos, be mindful of aider's 60-second retry timeout. Set this value according to your API tier to avoid RateLimitErrors stopping processes.</li> <li>Currently, agent will skip file with more than 1500 lines. See <code>agent/agent_utils.py#L199</code> for details.</li> <li>Running a full <code>all</code> commit0 split costs approximately $100 with Claude Sonnet 3.5.</li> </ul>"},{"location":"analysis/","title":"Submission Analysis","text":"Name Summary baseline 376 / 31 ; duration: 17.47s"},{"location":"analysis_baseline/","title":"Analysis baseline","text":"Repository Summary simpy tests: 20 / 150 ; duration: 1.51s tinydb failure marshmallow failure wcwidth tests: 6 / 39 ; duration: 2.30s imapclient tests: 0 / 0 ; duration: 0.32s voluptuous tests: 0 / 1 ; duration: 0.26s jinja failure deprecated tests: 80 / 171 ; duration: 1.46s cookiecutter tests: 97 / 371 ; duration: 10.98s cachetools tests: 173 / 215 ; duration: 0.64s"},{"location":"analysis_baseline_cachetools/","title":"Analysis baseline cachetools","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_cachetools/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_cachetools/#repository-cachetools","title":"Repository: cachetools","text":""},{"location":"analysis_baseline_cachetools/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count passed 173 failed 42 total 215 collected 215"},{"location":"analysis_baseline_cachetools/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_cachetools/#test_cachedpycachewrappertesttest_decorator_typed","title":"test_cached.py::CacheWrapperTest::test_decorator_typed","text":"<pre>test_cached.py::CacheWrapperTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cache = self.cache(3)\n        key = cachetools.keys.typedkey\n        wrapper = cachetools.cached(cache, key=key)(self.func)\n\n        self.assertEqual(len(cache), 0)\n        self.assertEqual(wrapper(0), 0)\n        self.assertEqual(len(cache), 1)\n        self.assertIn(cachetools.keys.typedkey(0), cache)\n&gt;       self.assertNotIn(cachetools.keys.typedkey(1), cache)\nE       AssertionError: (,) unexpectedly found in Cache({(,): 0}, maxsize=3, currsize=1)\n\ntests/test_cached.py:64: AssertionError"},{"location":"analysis_baseline_cachetools/#test_cachedpydictwrappertesttest_decorator_typed","title":"test_cached.py::DictWrapperTest::test_decorator_typed","text":"<pre>test_cached.py::DictWrapperTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cache = self.cache(3)\n        key = cachetools.keys.typedkey\n        wrapper = cachetools.cached(cache, key=key)(self.func)\n\n        self.assertEqual(len(cache), 0)\n        self.assertEqual(wrapper(0), 0)\n        self.assertEqual(len(cache), 1)\n        self.assertIn(cachetools.keys.typedkey(0), cache)\n&gt;       self.assertNotIn(cachetools.keys.typedkey(1), cache)\nE       AssertionError: (,) unexpectedly found in {(,): 0}\n\ntests/test_cached.py:64: AssertionError"},{"location":"analysis_baseline_cachetools/#test_cachedmethodpycachedmethodtesttest_typedmethod_dict","title":"test_cachedmethod.py::CachedMethodTest::test_typedmethod_dict","text":"<pre>test_cachedmethod.py::CachedMethodTest::test_typedmethod_dict</pre><pre>\nself = \n\n    def test_typedmethod_dict(self):\n        cached = Cached(LRUCache(maxsize=2))\n\n        self.assertEqual(cached.get_typedmethod(0), 0)\n&gt;       self.assertEqual(cached.get_typedmethod(1), 1)\nE       AssertionError: 0 != 1\n\ntests/test_cachedmethod.py:74: AssertionError"},{"location":"analysis_baseline_cachetools/#test_cachedmethodpycachedmethodtesttest_typedmethod_lru","title":"test_cachedmethod.py::CachedMethodTest::test_typedmethod_lru","text":"<pre>test_cachedmethod.py::CachedMethodTest::test_typedmethod_lru</pre><pre>\nself = \n\n    def test_typedmethod_lru(self):\n        cached = Cached(LRUCache(maxsize=2))\n\n        self.assertEqual(cached.get_typedmethod(0), 0)\n&gt;       self.assertEqual(cached.get_typedmethod(1), 1)\nE       AssertionError: 0 != 1\n\ntests/test_cachedmethod.py:97: AssertionError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator","title":"test_func.py::FIFODecoratorTest::test_decorator","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator_clear","title":"test_func.py::FIFODecoratorTest::test_decorator_clear","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator_nocache","title":"test_func.py::FIFODecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator_typed","title":"test_func.py::FIFODecoratorTest::test_decorator_typed","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator_unbound","title":"test_func.py::FIFODecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyfifodecoratortesttest_decorator_user_function","title":"test_func.py::FIFODecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::FIFODecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator","title":"test_func.py::LFUDecoratorTest::test_decorator","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator_clear","title":"test_func.py::LFUDecoratorTest::test_decorator_clear","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator_nocache","title":"test_func.py::LFUDecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator_typed","title":"test_func.py::LFUDecoratorTest::test_decorator_typed","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator_unbound","title":"test_func.py::LFUDecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylfudecoratortesttest_decorator_user_function","title":"test_func.py::LFUDecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::LFUDecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator","title":"test_func.py::LRUDecoratorTest::test_decorator","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator_clear","title":"test_func.py::LRUDecoratorTest::test_decorator_clear","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator_nocache","title":"test_func.py::LRUDecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator_typed","title":"test_func.py::LRUDecoratorTest::test_decorator_typed","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator_unbound","title":"test_func.py::LRUDecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpylrudecoratortesttest_decorator_user_function","title":"test_func.py::LRUDecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::LRUDecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator","title":"test_func.py::MRUDecoratorTest::test_decorator","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator_clear","title":"test_func.py::MRUDecoratorTest::test_decorator_clear","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator_nocache","title":"test_func.py::MRUDecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator_typed","title":"test_func.py::MRUDecoratorTest::test_decorator_typed","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator_unbound","title":"test_func.py::MRUDecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpymrudecoratortesttest_decorator_user_function","title":"test_func.py::MRUDecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::MRUDecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator","title":"test_func.py::RRDecoratorTest::test_decorator","text":"<pre>test_func.py::RRDecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator_clear","title":"test_func.py::RRDecoratorTest::test_decorator_clear","text":"<pre>test_func.py::RRDecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator_nocache","title":"test_func.py::RRDecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::RRDecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator_typed","title":"test_func.py::RRDecoratorTest::test_decorator_typed","text":"<pre>test_func.py::RRDecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator_unbound","title":"test_func.py::RRDecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::RRDecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyrrdecoratortesttest_decorator_user_function","title":"test_func.py::RRDecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::RRDecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator","title":"test_func.py::TTLDecoratorTest::test_decorator","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator</pre><pre>\nself = \n\n    def test_decorator(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:12: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator_clear","title":"test_func.py::TTLDecoratorTest::test_decorator_clear","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator_clear</pre><pre>\nself = \n\n    def test_decorator_clear(self):\n        cached = self.decorator(maxsize=2)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:23: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator_nocache","title":"test_func.py::TTLDecoratorTest::test_decorator_nocache","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator_nocache</pre><pre>\nself = \n\n    def test_decorator_nocache(self):\n        cached = self.decorator(maxsize=0)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 0, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:34: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator_typed","title":"test_func.py::TTLDecoratorTest::test_decorator_typed","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator_typed</pre><pre>\nself = \n\n    def test_decorator_typed(self):\n        cached = self.decorator(maxsize=2, typed=True)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 2, \"typed\": True})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:56: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator_unbound","title":"test_func.py::TTLDecoratorTest::test_decorator_unbound","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator_unbound</pre><pre>\nself = \n\n    def test_decorator_unbound(self):\n        cached = self.decorator(maxsize=None)(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": None, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:45: AttributeError"},{"location":"analysis_baseline_cachetools/#test_funcpyttldecoratortesttest_decorator_user_function","title":"test_func.py::TTLDecoratorTest::test_decorator_user_function","text":"<pre>test_func.py::TTLDecoratorTest::test_decorator_user_function</pre><pre>\nself = \n\n    def test_decorator_user_function(self):\n        cached = self.decorator(lambda n: n)\n&gt;       self.assertEqual(cached.cache_parameters(), {\"maxsize\": 128, \"typed\": False})\nE       AttributeError: 'function' object has no attribute 'cache_parameters'\n\ntests/test_func.py:69: AttributeError"},{"location":"analysis_baseline_cachetools/#test_keyspycachekeystesttest_typedkey","title":"test_keys.py::CacheKeysTest::test_typedkey","text":"<pre>test_keys.py::CacheKeysTest::test_typedkey</pre><pre>\nself = \nkey = \n\n    def test_typedkey(self, key=cachetools.keys.typedkey):\n        self.assertEqual(key(), key())\n        self.assertEqual(hash(key()), hash(key()))\n        self.assertEqual(key(1, 2, 3), key(1, 2, 3))\n        self.assertEqual(hash(key(1, 2, 3)), hash(key(1, 2, 3)))\n        self.assertEqual(key(1, 2, 3, x=0), key(1, 2, 3, x=0))\n        self.assertEqual(hash(key(1, 2, 3, x=0)), hash(key(1, 2, 3, x=0)))\n&gt;       self.assertNotEqual(key(1, 2, 3), key(3, 2, 1))\nE       AssertionError: (, , ) == (, , )\n\ntests/test_keys.py:49: AssertionError"},{"location":"analysis_baseline_cachetools/#test_keyspycachekeystesttest_typedmethodkey","title":"test_keys.py::CacheKeysTest::test_typedmethodkey","text":"<pre>test_keys.py::CacheKeysTest::test_typedmethodkey</pre><pre>\nself = \nkey = \n\n    def test_typedmethodkey(self, key=cachetools.keys.typedmethodkey):\n        # similar to typedkey(), but ignores its first positional argument\n        self.assertEqual(key(\"x\"), key(\"y\"))\n        self.assertEqual(hash(key(\"x\")), hash(key(\"y\")))\n        self.assertEqual(key(\"x\", 1, 2, 3), key(\"y\", 1, 2, 3))\n        self.assertEqual(hash(key(\"x\", 1, 2, 3)), hash(key(\"y\", 1, 2, 3)))\n        self.assertEqual(key(\"x\", 1, 2, 3, x=0), key(\"y\", 1, 2, 3, x=0))\n        self.assertEqual(hash(key(\"x\", 1, 2, 3, x=0)), hash(key(\"y\", 1, 2, 3, x=0)))\n&gt;       self.assertNotEqual(key(\"x\", 1, 2, 3), key(\"x\", 3, 2, 1))\nE       AssertionError: (, , , ) == (, , , )\n\ntests/test_keys.py:66: AssertionError"},{"location":"analysis_baseline_cachetools/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/src/cachetools/func.py b/src/cachetools/func.py\nindex 338ef94..d5b9f85 100644\n--- a/src/cachetools/func.py\n+++ b/src/cachetools/func.py\n@@ -25,7 +25,11 @@ def fifo_cache(maxsize=128, typed=False):\n     algorithm.\n\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=FIFOCache(maxsize), key=key)\n\n\n def lfu_cache(maxsize=128, typed=False):\n@@ -34,7 +38,11 @@ def lfu_cache(maxsize=128, typed=False):\n     algorithm.\n\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=LFUCache(maxsize), key=key)\n\n\n def lru_cache(maxsize=128, typed=False):\n@@ -43,7 +51,11 @@ def lru_cache(maxsize=128, typed=False):\n     algorithm.\n\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=LRUCache(maxsize), key=key)\n\n\n def mru_cache(maxsize=128, typed=False):\n@@ -51,7 +63,11 @@ def mru_cache(maxsize=128, typed=False):\n     up to `maxsize` results based on a Most Recently Used (MRU)\n     algorithm.\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=MRUCache(maxsize), key=key)\n\n\n def rr_cache(maxsize=128, choice=random.choice, typed=False):\n@@ -60,7 +76,11 @@ def rr_cache(maxsize=128, choice=random.choice, typed=False):\n     algorithm.\n\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=RRCache(maxsize, choice=choice), key=key)\n\n\n def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n@@ -68,4 +88,8 @@ def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n     up to `maxsize` results based on a Least Recently Used (LRU)\n     algorithm with a per-item time-to-live (TTL) value.\n     \"\"\"\n-    pass\n+    if typed:\n+        key = keys.typedkey\n+    else:\n+        key = keys.hashkey\n+    return cached(cache=TTLCache(maxsize, ttl, timer=timer), key=key)\ndiff --git a/src/cachetools/keys.py b/src/cachetools/keys.py\nindex ed97ffd..700885c 100644\n--- a/src/cachetools/keys.py\n+++ b/src/cachetools/keys.py\n@@ -32,19 +32,29 @@ _kwmark = _HashedTuple,\n\n def hashkey(*args, **kwargs):\n     \"\"\"Return a cache key for the specified hashable arguments.\"\"\"\n-    pass\n+    key = args\n+    if kwargs:\n+        key += (_kwmark,)\n+        for item in kwargs.items():\n+            key += item\n+    return _HashedTuple(key)\n\n\n def methodkey(self, *args, **kwargs):\n     \"\"\"Return a cache key for use with cached methods.\"\"\"\n-    pass\n+    return hashkey(self.__class__, *args, **kwargs)\n\n\n def typedkey(*args, **kwargs):\n     \"\"\"Return a typed cache key for the specified hashable arguments.\"\"\"\n-    pass\n+    key = tuple(type(arg) for arg in args)\n+    if kwargs:\n+        key += (_kwmark,)\n+        for item in kwargs.items():\n+            key += (item[0], type(item[1]))\n+    return _HashedTuple(key)\n\n\n def typedmethodkey(self, *args, **kwargs):\n     \"\"\"Return a typed cache key for use with cached methods.\"\"\"\n-    pass\n+    return typedkey(self.__class__, *args, **kwargs)\n</code></pre>"},{"location":"analysis_baseline_cookiecutter/","title":"Analysis baseline cookiecutter","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_cookiecutter/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_cookiecutter/#repository-cookiecutter","title":"Repository: cookiecutter","text":""},{"location":"analysis_baseline_cookiecutter/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count failed 270 passed 97 skipped 4 total 371 collected 371"},{"location":"analysis_baseline_cookiecutter/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_cookiecutter/#test_dumppytest_type_error_if_no_template_name","title":"test_dump.py::test_type_error_if_no_template_name","text":"<pre>test_dump.py::test_type_error_if_no_template_name</pre><pre>\nreplay_test_dir = 'tests/test-replay/'\ncontext = {'cookiecutter': {'email': 'raphael@hackebrot.de', 'full_name': 'Raphael Pierzina', 'github_username': 'hackebrot', 'version': '0.1.0'}}\n\n    def test_type_error_if_no_template_name(replay_test_dir, context):\n        \"\"\"Test that replay.dump raises if the template_name is not a valid str.\"\"\"\n&gt;       with pytest.raises(TypeError):\nE       Failed: DID NOT RAISE \n\ntests/replay/test_dump.py:37: Failed"},{"location":"analysis_baseline_cookiecutter/#test_dumppytest_type_error_if_not_dict_context","title":"test_dump.py::test_type_error_if_not_dict_context","text":"<pre>test_dump.py::test_type_error_if_not_dict_context</pre><pre>\nreplay_test_dir = 'tests/test-replay/', template_name = 'cookiedozer'\n\n    def test_type_error_if_not_dict_context(replay_test_dir, template_name):\n        \"\"\"Test that replay.dump raises if the context is not of type dict.\"\"\"\n&gt;       with pytest.raises(TypeError):\nE       Failed: DID NOT RAISE \n\ntests/replay/test_dump.py:43: Failed"},{"location":"analysis_baseline_cookiecutter/#test_dumppytest_value_error_if_key_missing_in_context","title":"test_dump.py::test_value_error_if_key_missing_in_context","text":"<pre>test_dump.py::test_value_error_if_key_missing_in_context</pre><pre>\nreplay_test_dir = 'tests/test-replay/', template_name = 'cookiedozer'\n\n    def test_value_error_if_key_missing_in_context(replay_test_dir, template_name):\n        \"\"\"Test that replay.dump raises if the context does not contain a key \\\n        named 'cookiecutter'.\"\"\"\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE \n\ntests/replay/test_dump.py:50: Failed"},{"location":"analysis_baseline_cookiecutter/#test_loadpytest_type_error_if_no_template_name","title":"test_load.py::test_type_error_if_no_template_name","text":"<pre>test_load.py::test_type_error_if_no_template_name</pre><pre>\nreplay_test_dir = 'tests/test-replay/'\n\n    def test_type_error_if_no_template_name(replay_test_dir):\n        \"\"\"Test that replay.load raises if the template_name is not a valid str.\"\"\"\n&gt;       with pytest.raises(TypeError):\nE       Failed: DID NOT RAISE \n\ntests/replay/test_load.py:26: Failed"},{"location":"analysis_baseline_cookiecutter/#test_loadpytest_value_error_if_key_missing_in_context","title":"test_load.py::test_value_error_if_key_missing_in_context","text":"<pre>test_load.py::test_value_error_if_key_missing_in_context</pre><pre>\nmocker = \nreplay_test_dir = 'tests/test-replay/'\n\n    def test_value_error_if_key_missing_in_context(mocker, replay_test_dir):\n        \"\"\"Test that replay.load raises if the loaded context does not contain \\\n        'cookiecutter'.\"\"\"\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE \n\ntests/replay/test_load.py:33: Failed"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_get_replay_file_namebarjson","title":"test_replay.py::test_get_replay_file_name[bar.json]","text":"<pre>test_replay.py::test_get_replay_file_name[bar.json]</pre><pre>\nreplay_file_name = 'bar.json'\n\n    @pytest.mark.parametrize(\"replay_file_name\", ['bar', 'bar.json'])\n    def test_get_replay_file_name(replay_file_name):\n        \"\"\"Make sure that replay.get_file_name generates a valid json file path.\"\"\"\n        exp_replay_file_path = os.path.join('foo', 'bar.json')\n        replay_file_path = replay.get_file_name('foo', replay_file_name)\n&gt;       assert replay_file_path == exp_replay_file_path\nE       AssertionError: assert 'foo/bar.json.json' == 'foo/bar.json'\nE         \nE         - foo/bar.json\nE         + foo/bar.json.json\nE         ?             +++++\n\ntests/replay/test_replay.py:15: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_raise_on_invalid_modeinvalid_kwargs0","title":"test_replay.py::test_raise_on_invalid_mode[invalid_kwargs0]","text":"<pre>test_replay.py::test_raise_on_invalid_mode[invalid_kwargs0]</pre><pre>\ninvalid_kwargs = {'no_input': True}\n\n    @pytest.mark.parametrize(\n        'invalid_kwargs',\n        (\n            {'no_input': True},\n            {'extra_context': {}},\n            {'no_input': True, 'extra_context': {}},\n        ),\n    )\n    def test_raise_on_invalid_mode(invalid_kwargs):\n        \"\"\"Test `cookiecutter` raise exception on unacceptable `replay` request.\"\"\"\n        with pytest.raises(exceptions.InvalidModeException):\n&gt;           main.cookiecutter('foo', replay=True, **invalid_kwargs)\n\ntests/replay/test_replay.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'foo', checkout = None, no_input = True, extra_context = None\nreplay = True, overwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_raise_on_invalid_modeinvalid_kwargs1","title":"test_replay.py::test_raise_on_invalid_mode[invalid_kwargs1]","text":"<pre>test_replay.py::test_raise_on_invalid_mode[invalid_kwargs1]</pre><pre>\ninvalid_kwargs = {'extra_context': {}}\n\n    @pytest.mark.parametrize(\n        'invalid_kwargs',\n        (\n            {'no_input': True},\n            {'extra_context': {}},\n            {'no_input': True, 'extra_context': {}},\n        ),\n    )\n    def test_raise_on_invalid_mode(invalid_kwargs):\n        \"\"\"Test `cookiecutter` raise exception on unacceptable `replay` request.\"\"\"\n        with pytest.raises(exceptions.InvalidModeException):\n&gt;           main.cookiecutter('foo', replay=True, **invalid_kwargs)\n\ntests/replay/test_replay.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'foo', checkout = None, no_input = False, extra_context = {}\nreplay = True, overwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_raise_on_invalid_modeinvalid_kwargs2","title":"test_replay.py::test_raise_on_invalid_mode[invalid_kwargs2]","text":"<pre>test_replay.py::test_raise_on_invalid_mode[invalid_kwargs2]</pre><pre>\ninvalid_kwargs = {'extra_context': {}, 'no_input': True}\n\n    @pytest.mark.parametrize(\n        'invalid_kwargs',\n        (\n            {'no_input': True},\n            {'extra_context': {}},\n            {'no_input': True, 'extra_context': {}},\n        ),\n    )\n    def test_raise_on_invalid_mode(invalid_kwargs):\n        \"\"\"Test `cookiecutter` raise exception on unacceptable `replay` request.\"\"\"\n        with pytest.raises(exceptions.InvalidModeException):\n&gt;           main.cookiecutter('foo', replay=True, **invalid_kwargs)\n\ntests/replay/test_replay.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'foo', checkout = None, no_input = True, extra_context = {}\nreplay = True, overwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_main_does_not_invoke_dump_but_load","title":"test_replay.py::test_main_does_not_invoke_dump_but_load","text":"<pre>test_replay.py::test_main_does_not_invoke_dump_but_load</pre><pre>\nmocker = \n\n    def test_main_does_not_invoke_dump_but_load(mocker):\n        \"\"\"Test `cookiecutter` calling correct functions on `replay`.\"\"\"\n        mock_prompt = mocker.patch('cookiecutter.main.prompt_for_config')\n        mock_gen_context = mocker.patch('cookiecutter.main.generate_context')\n        mock_gen_files = mocker.patch('cookiecutter.main.generate_files')\n        mock_replay_dump = mocker.patch('cookiecutter.main.dump')\n        mock_replay_load = mocker.patch('cookiecutter.main.load')\n\n&gt;       main.cookiecutter('tests/fake-repo-tmpl/', replay=True)\n\ntests/replay/test_replay.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-tmpl/', checkout = None, no_input = False\nextra_context = None, replay = True, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_replaypytest_main_does_not_invoke_load_but_dump","title":"test_replay.py::test_main_does_not_invoke_load_but_dump","text":"<pre>test_replay.py::test_main_does_not_invoke_load_but_dump</pre><pre>\nmocker = \n\n    def test_main_does_not_invoke_load_but_dump(mocker):\n        \"\"\"Test `cookiecutter` calling correct functions on non-replay launch.\"\"\"\n        mock_prompt = mocker.patch('cookiecutter.main.prompt_for_config')\n        mock_gen_context = mocker.patch('cookiecutter.main.generate_context')\n        mock_gen_files = mocker.patch('cookiecutter.main.generate_files')\n        mock_replay_dump = mocker.patch('cookiecutter.main.dump')\n        mock_replay_load = mocker.patch('cookiecutter.main.load')\n\n&gt;       main.cookiecutter('tests/fake-repo-tmpl/', replay=False)\n\ntests/replay/test_replay.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-tmpl/', checkout = None, no_input = False\nextra_context = None, replay = False, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansionexpansion-prefix","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[Expansion prefix]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[Expansion prefix]</pre><pre>\ntemplate = 'xx:a', abbreviations = {'xx': '&lt;{0}&gt;'}, expected_result = ''\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'xx:a' == ''\nE         \nE         - \nE         + xx:a\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansionexpansion_override_builtin","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[expansion_override_builtin]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[expansion_override_builtin]</pre><pre>\ntemplate = 'gh:a', abbreviations = {'gh': '&lt;{0}&gt;'}, expected_result = ''\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'gh:a' == ''\nE         \nE         - \nE         + gh:a\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansionexpansion_prefix_ignores_suffix","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[expansion_prefix_ignores_suffix]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[expansion_prefix_ignores_suffix]</pre><pre>\ntemplate = 'xx:a', abbreviations = {'xx': '&lt;&gt;'}, expected_result = '&lt;&gt;'\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'xx:a' == '&lt;&gt;'\nE         \nE         - &lt;&gt;\nE         + xx:a\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansioncorrect-expansion-for-builtin-abbreviations-github","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (github)]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (github)]</pre><pre>\ntemplate = 'gh:pydanny/cookiecutter-django'\nabbreviations = {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git'}\nexpected_result = 'https://github.com/pydanny/cookiecutter-django.git'\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'gh:pydanny/cookiecutter-django' == 'https://github.com/pydanny/cookiecutter-django.git'\nE         \nE         - https://github.com/pydanny/cookiecutter-django.git\nE         + gh:pydanny/cookiecutter-django\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansioncorrect-expansion-for-builtin-abbreviations-gitlab","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (gitlab)]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (gitlab)]</pre><pre>\ntemplate = 'gl:pydanny/cookiecutter-django'\nabbreviations = {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git'}\nexpected_result = 'https://gitlab.com/pydanny/cookiecutter-django.git'\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'gl:pydanny/cookiecutter-django' == 'https://gitlab.com/pydanny/cookiecutter-django.git'\nE         \nE         - https://gitlab.com/pydanny/cookiecutter-django.git\nE         + gl:pydanny/cookiecutter-django\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansioncorrect-expansion-for-builtin-abbreviations-bitbucket","title":"test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (bitbucket)]","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion[Correct expansion for builtin abbreviations (bitbucket)]</pre><pre>\ntemplate = 'bb:pydanny/cookiecutter-django'\nabbreviations = {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git'}\nexpected_result = 'https://bitbucket.org/pydanny/cookiecutter-django'\n\n    @pytest.mark.parametrize(\n        ('template', 'abbreviations', 'expected_result'),\n        [\n            ('foo', {'foo': 'bar'}, 'bar'),\n            ('baz', {'foo': 'bar'}, 'baz'),\n            ('xx:a', {'xx': '&lt;{0}&gt;'}, ''),\n            ('gh:a', {'gh': '&lt;{0}&gt;'}, ''),\n            ('xx:a', {'xx': '&lt;&gt;'}, '&lt;&gt;'),\n            (\n                'gh:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://github.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'gl:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://gitlab.com/pydanny/cookiecutter-django.git',\n            ),\n            (\n                'bb:pydanny/cookiecutter-django',\n                BUILTIN_ABBREVIATIONS,\n                'https://bitbucket.org/pydanny/cookiecutter-django',\n            ),\n        ],\n        ids=(\n            'Simple expansion',\n            'Skip expansion (expansion not an abbreviation)',\n            'Expansion prefix',\n            'expansion_override_builtin',\n            'expansion_prefix_ignores_suffix',\n            'Correct expansion for builtin abbreviations (github)',\n            'Correct expansion for builtin abbreviations (gitlab)',\n            'Correct expansion for builtin abbreviations (bitbucket)',\n        ),\n    )\n    def test_abbreviation_expansion(template, abbreviations, expected_result):\n        \"\"\"Verify abbreviation unpacking.\"\"\"\n        expanded = expand_abbreviations(template, abbreviations)\n&gt;       assert expanded == expected_result\nE       AssertionError: assert 'bb:pydanny/cookiecutter-django' == 'https://bitbucket.org/pydanny/cookiecutter-django'\nE         \nE         - https://bitbucket.org/pydanny/cookiecutter-django\nE         + bb:pydanny/cookiecutter-django\n\ntests/repository/test_abbreviation_expansion.py:47: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_abbreviation_expansionpytest_abbreviation_expansion_prefix_not_0_in_braces","title":"test_abbreviation_expansion.py::test_abbreviation_expansion_prefix_not_0_in_braces","text":"<pre>test_abbreviation_expansion.py::test_abbreviation_expansion_prefix_not_0_in_braces</pre><pre>\ndef test_abbreviation_expansion_prefix_not_0_in_braces():\n        \"\"\"Verify abbreviation unpacking raises error on incorrect index.\"\"\"\n&gt;       with pytest.raises(IndexError):\nE       Failed: DID NOT RAISE \n\ntests/repository/test_abbreviation_expansion.py:52: Failed"},{"location":"analysis_baseline_cookiecutter/#zipfilezip-true","title":"zipfile.zip-True]","text":"<pre>zipfile.zip-True]</pre><pre>\nmocker = \ntemplate = 'https://example.com/path/to/zipfile.zip', is_url = True\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\n\n    @pytest.mark.parametrize(\n        'template, is_url',\n        [\n            ('/path/to/zipfile.zip', False),\n            ('https://example.com/path/to/zipfile.zip', True),\n            ('http://example.com/path/to/zipfile.zip', True),\n        ],\n    )\n    def test_zipfile_unzip(mocker, template, is_url, user_config_data):\n        \"\"\"Verify zip files correctly handled for different source locations.\n\n        `unzip()` should be called with correct args when `determine_repo_dir()`\n        is passed a zipfile, or a URL to a zipfile.\n        \"\"\"\n        mock_clone = mocker.patch(\n            'cookiecutter.repository.unzip',\n            return_value='tests/fake-repo-tmpl',\n            autospec=True,\n        )\n\n&gt;       project_dir, cleanup = repository.determine_repo_dir(\n            template,\n            abbreviations={},\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            checkout=None,\n            no_input=True,\n            password=None,\n        )\n\ntests/repository/test_determine_repo_dir_clones_repo.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/repository.py:78: in determine_repo_dir\n    repo_dir = clone(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://example.com/path/to/zipfile.zip', checkout = None\nclone_to_dir = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters'\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n&gt;       repo_type, repo_url = identify_repo(repo_url)\nE       TypeError: cannot unpack non-iterable NoneType object\n\ncookiecutter/vcs.py:61: TypeError"},{"location":"analysis_baseline_cookiecutter/#zipfilezip-true_1","title":"zipfile.zip-True]","text":"<pre>zipfile.zip-True]</pre><pre>\nmocker = \ntemplate = 'http://example.com/path/to/zipfile.zip', is_url = True\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\n\n    @pytest.mark.parametrize(\n        'template, is_url',\n        [\n            ('/path/to/zipfile.zip', False),\n            ('https://example.com/path/to/zipfile.zip', True),\n            ('http://example.com/path/to/zipfile.zip', True),\n        ],\n    )\n    def test_zipfile_unzip(mocker, template, is_url, user_config_data):\n        \"\"\"Verify zip files correctly handled for different source locations.\n\n        `unzip()` should be called with correct args when `determine_repo_dir()`\n        is passed a zipfile, or a URL to a zipfile.\n        \"\"\"\n        mock_clone = mocker.patch(\n            'cookiecutter.repository.unzip',\n            return_value='tests/fake-repo-tmpl',\n            autospec=True,\n        )\n\n&gt;       project_dir, cleanup = repository.determine_repo_dir(\n            template,\n            abbreviations={},\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            checkout=None,\n            no_input=True,\n            password=None,\n        )\n\ntests/repository/test_determine_repo_dir_clones_repo.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/repository.py:78: in determine_repo_dir\n    repo_dir = clone(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'http://example.com/path/to/zipfile.zip', checkout = None\nclone_to_dir = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters'\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n&gt;       repo_type, repo_url = identify_repo(repo_url)\nE       TypeError: cannot unpack non-iterable NoneType object\n\ncookiecutter/vcs.py:61: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_determine_repo_dir_clones_repopytest_repository_url_should_clone","title":"test_determine_repo_dir_clones_repo.py::test_repository_url_should_clone","text":"<pre>test_determine_repo_dir_clones_repo.py::test_repository_url_should_clone</pre><pre>\nmocker = \ntemplate_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\n\n    def test_repository_url_should_clone(mocker, template_url, user_config_data):\n        \"\"\"Verify repository url triggers clone function.\n\n        `clone()` should be called with correct args when `determine_repo_dir()` is\n        passed a repository template url.\n        \"\"\"\n        mock_clone = mocker.patch(\n            'cookiecutter.repository.clone',\n            return_value='tests/fake-repo-tmpl',\n            autospec=True,\n        )\n\n        project_dir, cleanup = repository.determine_repo_dir(\n            template_url,\n            abbreviations={},\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            checkout=None,\n            no_input=True,\n        )\n\n        mock_clone.assert_called_once_with(\n            repo_url=template_url,\n            checkout=None,\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            no_input=True,\n        )\n\n        assert os.path.isdir(project_dir)\n&gt;       assert not cleanup\nE       assert not True\n\ntests/repository/test_determine_repo_dir_clones_repo.py:89: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_determine_repo_dir_clones_repopytest_repository_url_with_no_context_file","title":"test_determine_repo_dir_clones_repo.py::test_repository_url_with_no_context_file","text":"<pre>test_determine_repo_dir_clones_repo.py::test_repository_url_with_no_context_file</pre><pre>\nmocker = \ntemplate_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\n\n    def test_repository_url_with_no_context_file(mocker, template_url, user_config_data):\n        \"\"\"Verify cloned repository without `cookiecutter.json` file raises error.\"\"\"\n        mocker.patch(\n            'cookiecutter.repository.clone',\n            return_value='tests/fake-repo-bad',\n            autospec=True,\n        )\n\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n            repository.determine_repo_dir(\n                template_url,\n                abbreviations={},\n                clone_to_dir=None,\n                checkout=None,\n                no_input=True,\n            )\n\n&gt;       assert str(err.value) == (\n            'A valid repository for \"{}\" could not be found in the following '\n            'locations:\\n{}'.format(template_url, 'tests/fake-repo-bad')\n        )\nE       assert 'The repository tests/fake-repo-bad does not contain a cookiecutter.json file' == 'A valid repository for \"https://github.com/pytest-dev/cookiecutter-pytest-plugin.git\" could not be found in the following locations:\\ntests/fake-repo-bad'\nE         \nE         + The repository tests/fake-repo-bad does not contain a cookiecutter.json file\nE         - A valid repository for \"https://github.com/pytest-dev/cookiecutter-pytest-plugin.git\" could not be found in the following locations:\nE         - tests/fake-repo-bad\n\ntests/repository/test_determine_repo_dir_clones_repo.py:110: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_determine_repo_dir_finds_existing_cookiecutterpytest_should_find_existing_cookiecutter","title":"test_determine_repo_dir_finds_existing_cookiecutter.py::test_should_find_existing_cookiecutter","text":"<pre>test_determine_repo_dir_finds_existing_cookiecutter.py::test_should_find_existing_cookiecutter</pre><pre>\ntemplate = 'cookiecutter-pytest-plugin'\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\ncloned_cookiecutter_path = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters/cookiecutter-pytest-plugin'\n\n    def test_should_find_existing_cookiecutter(\n        template, user_config_data, cloned_cookiecutter_path\n    ):\n        \"\"\"\n        Should find folder created by `cloned_cookiecutter_path` and return it.\n\n        This folder is considered like previously cloned project directory.\n        \"\"\"\n&gt;       project_dir, cleanup = repository.determine_repo_dir(\n            template=template,\n            abbreviations={},\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            checkout=None,\n            no_input=True,\n        )\n\ntests/repository/test_determine_repo_dir_finds_existing_cookiecutter.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'cookiecutter-pytest-plugin', abbreviations = {}\nclone_to_dir = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters'\ncheckout = None, no_input = True, password = None, directory = None\n\n    def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,\n        no_input, password=None, directory=None):\n        \"\"\"\n        Locate the repository directory from a template reference.\n\n        Applies repository abbreviations to the template reference.\n        If the template refers to a repository URL, clone it.\n        If the template is a path to a local repository, use it.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param abbreviations: A dictionary of repository abbreviation\n            definitions.\n        :param clone_to_dir: The directory to clone the repository into.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :param password: The password to use when extracting the repository.\n        :param directory: Directory within repo where cookiecutter.json lives.\n        :return: A tuple containing the cookiecutter template directory, and\n            a boolean describing whether that directory should be cleaned up\n            after the template has been instantiated.\n        :raises: `RepositoryNotFound` if a repository directory could not be found.\n        \"\"\"\n        template = expand_abbreviations(template, abbreviations)\n\n        if is_repo_url(template):\n            repo_dir = clone(\n                repo_url=template,\n                checkout=checkout,\n                clone_to_dir=clone_to_dir,\n                no_input=no_input\n            )\n            cleanup = True\n        elif is_zip_file(template):\n            repo_dir = unzip(\n                zip_uri=template,\n                is_url=is_repo_url(template),\n                clone_to_dir=clone_to_dir,\n                no_input=no_input,\n                password=password\n            )\n            cleanup = True\n        else:\n            repo_dir = template\n            cleanup = False\n\n        if directory:\n            repo_dir = os.path.join(repo_dir, directory)\n\n        if not repository_has_cookiecutter_json(repo_dir):\n&gt;           raise RepositoryNotFound(\n                'The repository {} does not contain a cookiecutter.json file'.format(repo_dir)\n            )\nE           cookiecutter.exceptions.RepositoryNotFound: The repository cookiecutter-pytest-plugin does not contain a cookiecutter.json file\n\ncookiecutter/repository.py:102: RepositoryNotFound\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_determine_repo_dir_finds_subdirectoriespytest_should_find_existing_cookiecutter","title":"test_determine_repo_dir_finds_subdirectories.py::test_should_find_existing_cookiecutter","text":"<pre>test_determine_repo_dir_finds_subdirectories.py::test_should_find_existing_cookiecutter</pre><pre>\ntemplate = 'cookiecutter-pytest-plugin'\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\ncloned_cookiecutter_path = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters/cookiecutter-pytest-plugin/my-dir'\n\n    def test_should_find_existing_cookiecutter(\n        template, user_config_data, cloned_cookiecutter_path\n    ):\n        \"\"\"Find `cookiecutter.json` in sub folder created by `cloned_cookiecutter_path`.\"\"\"\n&gt;       project_dir, cleanup = repository.determine_repo_dir(\n            template=template,\n            abbreviations={},\n            clone_to_dir=user_config_data['cookiecutters_dir'],\n            checkout=None,\n            no_input=True,\n            directory='my-dir',\n        )\n\ntests/repository/test_determine_repo_dir_finds_subdirectories.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'cookiecutter-pytest-plugin', abbreviations = {}\nclone_to_dir = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters'\ncheckout = None, no_input = True, password = None, directory = 'my-dir'\n\n    def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,\n        no_input, password=None, directory=None):\n        \"\"\"\n        Locate the repository directory from a template reference.\n\n        Applies repository abbreviations to the template reference.\n        If the template refers to a repository URL, clone it.\n        If the template is a path to a local repository, use it.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param abbreviations: A dictionary of repository abbreviation\n            definitions.\n        :param clone_to_dir: The directory to clone the repository into.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :param password: The password to use when extracting the repository.\n        :param directory: Directory within repo where cookiecutter.json lives.\n        :return: A tuple containing the cookiecutter template directory, and\n            a boolean describing whether that directory should be cleaned up\n            after the template has been instantiated.\n        :raises: `RepositoryNotFound` if a repository directory could not be found.\n        \"\"\"\n        template = expand_abbreviations(template, abbreviations)\n\n        if is_repo_url(template):\n            repo_dir = clone(\n                repo_url=template,\n                checkout=checkout,\n                clone_to_dir=clone_to_dir,\n                no_input=no_input\n            )\n            cleanup = True\n        elif is_zip_file(template):\n            repo_dir = unzip(\n                zip_uri=template,\n                is_url=is_repo_url(template),\n                clone_to_dir=clone_to_dir,\n                no_input=no_input,\n                password=password\n            )\n            cleanup = True\n        else:\n            repo_dir = template\n            cleanup = False\n\n        if directory:\n            repo_dir = os.path.join(repo_dir, directory)\n\n        if not repository_has_cookiecutter_json(repo_dir):\n&gt;           raise RepositoryNotFound(\n                'The repository {} does not contain a cookiecutter.json file'.format(repo_dir)\n            )\nE           cookiecutter.exceptions.RepositoryNotFound: The repository cookiecutter-pytest-plugin/my-dir does not contain a cookiecutter.json file\n\ncookiecutter/repository.py:102: RepositoryNotFound\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_determine_repo_dir_finds_subdirectoriespytest_local_repo_typo","title":"test_determine_repo_dir_finds_subdirectories.py::test_local_repo_typo","text":"<pre>test_determine_repo_dir_finds_subdirectories.py::test_local_repo_typo</pre><pre>\ntemplate = 'cookiecutter-pytest-plugin'\nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\ncloned_cookiecutter_path = '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters/cookiecutter-pytest-plugin/my-dir'\n\n    def test_local_repo_typo(template, user_config_data, cloned_cookiecutter_path):\n        \"\"\"Wrong pointing to `cookiecutter.json` sub-directory should raise.\"\"\"\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n            repository.determine_repo_dir(\n                template=template,\n                abbreviations={},\n                clone_to_dir=user_config_data['cookiecutters_dir'],\n                checkout=None,\n                no_input=True,\n                directory='wrong-dir',\n            )\n\n        wrong_full_cookiecutter_path = os.path.join(\n            os.path.dirname(cloned_cookiecutter_path), 'wrong-dir'\n        )\n&gt;       assert str(err.value) == (\n            'A valid repository for \"{}\" could not be found in the following '\n            'locations:\\n{}'.format(\n                template,\n                '\\n'.join(\n                    [os.path.join(template, 'wrong-dir'), wrong_full_cookiecutter_path]\n                ),\n            )\n        )\nE       assert 'The repository cookiecutter-pytest-plugin/wrong-dir does not contain a cookiecutter.json file' == 'A valid repository for \"cookiecutter-pytest-plugin\" could not be found in the following locations:\\ncookiecutter-pytest-plugin/wrong-dir\\n/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters/cookiecutter-pytest-plugin/wrong-dir'\nE         \nE         + The repository cookiecutter-pytest-plugin/wrong-dir does not contain a cookiecutter.json file\nE         - A valid repository for \"cookiecutter-pytest-plugin\" could not be found in the following locations:\nE         - cookiecutter-pytest-plugin/wrong-dir\nE         - /tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters/cookiecutter-pytest-plugin/wrong-dir\n\ntests/repository/test_determine_repo_dir_finds_subdirectories.py:66: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_determine_repository_should_use_local_repopytest_local_repo_with_no_context_raises","title":"test_determine_repository_should_use_local_repo.py::test_local_repo_with_no_context_raises","text":"<pre>test_determine_repository_should_use_local_repo.py::test_local_repo_with_no_context_raises</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_local_repo_with_no_contex0')\n\n    def test_local_repo_with_no_context_raises(tmp_path):\n        \"\"\"A local repository without a cookiecutter.json should raise a \\\n        `RepositoryNotFound` exception.\"\"\"\n        template_path = str(Path('tests', 'fake-repo-bad'))\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n            repository.determine_repo_dir(\n                template_path,\n                abbreviations={},\n                clone_to_dir=str(tmp_path),\n                checkout=None,\n                no_input=True,\n            )\n\n&gt;       assert str(err.value) == (\n            'A valid repository for \"{}\" could not be found in the following '\n            'locations:\\n{}'.format(\n                template_path,\n                '\\n'.join(\n                    [template_path, str(tmp_path.joinpath('tests', 'fake-repo-bad'))]\n                ),\n            )\n        )\nE       assert 'The repository tests/fake-repo-bad does not contain a cookiecutter.json file' == 'A valid repository for \"tests/fake-repo-bad\" could not be found in the following locations:\\ntests/fake-repo-bad\\n/tmp/pytest-of-root/pytest-0/test_local_repo_with_no_contex0/tests/fake-repo-bad'\nE         \nE         + The repository tests/fake-repo-bad does not contain a cookiecutter.json file\nE         - A valid repository for \"tests/fake-repo-bad\" could not be found in the following locations:\nE         - tests/fake-repo-bad\nE         - /tmp/pytest-of-root/pytest-0/test_local_repo_with_no_contex0/tests/fake-repo-bad\n\ntests/repository/test_determine_repository_should_use_local_repo.py:37: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_determine_repository_should_use_local_repopytest_local_repo_typo","title":"test_determine_repository_should_use_local_repo.py::test_local_repo_typo","text":"<pre>test_determine_repository_should_use_local_repo.py::test_local_repo_typo</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_local_repo_typo1')\n\n    def test_local_repo_typo(tmp_path):\n        \"\"\"An unknown local repository should raise a `RepositoryNotFound` \\\n        exception.\"\"\"\n        template_path = str(Path('tests', 'unknown-repo'))\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n            repository.determine_repo_dir(\n                template_path,\n                abbreviations={},\n                clone_to_dir=str(tmp_path),\n                checkout=None,\n                no_input=True,\n            )\n\n&gt;       assert str(err.value) == (\n            'A valid repository for \"{}\" could not be found in the following '\n            'locations:\\n{}'.format(\n                template_path,\n                '\\n'.join([template_path, str(tmp_path.joinpath('tests', 'unknown-repo'))]),\n            )\n        )\nE       assert 'The repository tests/unknown-repo does not contain a cookiecutter.json file' == 'A valid repository for \"tests/unknown-repo\" could not be found in the following locations:\\ntests/unknown-repo\\n/tmp/pytest-of-root/pytest-0/test_local_repo_typo1/tests/unknown-repo'\nE         \nE         + The repository tests/unknown-repo does not contain a cookiecutter.json file\nE         - A valid repository for \"tests/unknown-repo\" could not be found in the following locations:\nE         - tests/unknown-repo\nE         - /tmp/pytest-of-root/pytest-0/test_local_repo_typo1/tests/unknown-repo\n\ntests/repository/test_determine_repository_should_use_local_repo.py:61: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_is_repo_urlpytest_expand_abbreviations","title":"test_is_repo_url.py::test_expand_abbreviations","text":"<pre>test_is_repo_url.py::test_expand_abbreviations</pre><pre>\ndef test_expand_abbreviations():\n        \"\"\"Validate `repository.expand_abbreviations` correctly translate url.\"\"\"\n        template = 'gh:audreyfeldroy/cookiecutter-pypackage'\n\n        # This is not a valid repo url just yet!\n        # First `repository.expand_abbreviations` needs to translate it\n        assert is_repo_url(template) is False\n\n        expanded_template = expand_abbreviations(template, BUILTIN_ABBREVIATIONS)\n&gt;       assert is_repo_url(expanded_template) is True\nE       AssertionError: assert False is True\nE        +  where False = is_repo_url('gh:audreyfeldroy/cookiecutter-pypackage')\n\ntests/repository/test_is_repo_url.py:76: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_abort_generate_on_hook_errorpytest_hooks_raises_errorspre_gen_hook_raises_error","title":"test_abort_generate_on_hook_error.py::test_hooks_raises_errors[pre_gen_hook_raises_error]","text":"<pre>test_abort_generate_on_hook_error.py::test_hooks_raises_errors[pre_gen_hook_raises_error]</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_hooks_raises_errors_pre_g0')\nabort_pre_gen = 'yes', abort_post_gen = 'no'\n\n    @pytest.mark.parametrize(\n        (\"abort_pre_gen\", \"abort_post_gen\"),\n        ((\"yes\", \"no\"), (\"no\", \"yes\")),\n        ids=(\"pre_gen_hook_raises_error\", \"post_gen_hook_raises_error\"),\n    )\n    @pytest.mark.usefixtures(\"clean_system\")\n    def test_hooks_raises_errors(tmp_path, abort_pre_gen, abort_post_gen):\n        \"\"\"Verify pre- and pos-gen errors raises correct error code from script.\n\n        This allows developers to make different error codes in their code,\n        for different errors.\n        \"\"\"\n        context = {\n            \"cookiecutter\": {\n                \"repo_dir\": \"foobar\",\n                \"abort_pre_gen\": abort_pre_gen,\n                \"abort_post_gen\": abort_post_gen,\n            }\n        }\n\n        with pytest.raises(exceptions.FailedHookException) as error:\n&gt;           generate.generate_files(\n                repo_dir=\"tests/hooks-abort-render\",\n                context=context,\n                output_dir=str(tmp_path),\n            )\n\ntests/test_abort_generate_on_hook_error.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/hooks-abort-render'\ncontext = {'cookiecutter': {'abort_post_gen': 'no', 'abort_pre_gen': 'yes', 'repo_dir': 'foobar'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hooks_raises_errors_pre_g0'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_abort_generate_on_hook_errorpytest_hooks_raises_errorspost_gen_hook_raises_error","title":"test_abort_generate_on_hook_error.py::test_hooks_raises_errors[post_gen_hook_raises_error]","text":"<pre>test_abort_generate_on_hook_error.py::test_hooks_raises_errors[post_gen_hook_raises_error]</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_hooks_raises_errors_post_0')\nabort_pre_gen = 'no', abort_post_gen = 'yes'\n\n    @pytest.mark.parametrize(\n        (\"abort_pre_gen\", \"abort_post_gen\"),\n        ((\"yes\", \"no\"), (\"no\", \"yes\")),\n        ids=(\"pre_gen_hook_raises_error\", \"post_gen_hook_raises_error\"),\n    )\n    @pytest.mark.usefixtures(\"clean_system\")\n    def test_hooks_raises_errors(tmp_path, abort_pre_gen, abort_post_gen):\n        \"\"\"Verify pre- and pos-gen errors raises correct error code from script.\n\n        This allows developers to make different error codes in their code,\n        for different errors.\n        \"\"\"\n        context = {\n            \"cookiecutter\": {\n                \"repo_dir\": \"foobar\",\n                \"abort_pre_gen\": abort_pre_gen,\n                \"abort_post_gen\": abort_post_gen,\n            }\n        }\n\n        with pytest.raises(exceptions.FailedHookException) as error:\n&gt;           generate.generate_files(\n                repo_dir=\"tests/hooks-abort-render\",\n                context=context,\n                output_dir=str(tmp_path),\n            )\n\ntests/test_abort_generate_on_hook_error.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/hooks-abort-render'\ncontext = {'cookiecutter': {'abort_post_gen': 'yes', 'abort_pre_gen': 'no', 'repo_dir': 'foobar'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hooks_raises_errors_post_0'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_error_on_existing_output_directory","title":"test_cli.py::test_cli_error_on_existing_output_directory","text":"<pre>test_cli.py::test_cli_error_on_existing_output_directory</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir')\n    def test_cli_error_on_existing_output_directory(cli_runner):\n        \"\"\"Test cli invocation without `overwrite-if-exists` fail if dir exist.\"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input')\n        assert result.exit_code != 0\n        expected_error_msg = 'Error: \"fake-project\" directory already exists\\n'\n&gt;       assert result.output == expected_error_msg\nE       assert '' == 'Error: \"fake-project\" directory already exists\\n'\nE         \nE         - Error: \"fake-project\" directory already exists\n\ntests/test_cli.py:81: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli","title":"test_cli.py::test_cli","text":"<pre>test_cli.py::test_cli</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli(cli_runner):\n        \"\"\"Test cli invocation work without flags if directory not exist.\"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input')\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:88: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_verbose","title":"test_cli.py::test_cli_verbose","text":"<pre>test_cli.py::test_cli_verbose</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_verbose(cli_runner):\n        \"\"\"Test cli invocation display log if called with `verbose` flag.\"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input', '-v')\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:98: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_replay","title":"test_cli.py::test_cli_replay","text":"<pre>test_cli.py::test_cli_replay</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd3951090&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_replay(mocker, cli_runner):\n        \"\"\"Test cli invocation display log with `verbose` and `replay` flags.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--replay', '-v')\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=True,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:113: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_replay_file","title":"test_cli.py::test_cli_replay_file","text":"<pre>test_cli.py::test_cli_replay_file</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay='~/custom-replay-file', overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd382caf0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay='~/custom-replay-file', overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay='~/custom-replay-file', overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': '~/custom-replay-file', 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'replay': False} != {'replay': '~/custom-replay-file'}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE         -     'replay': '~/custom-replay-file',\nE         +     'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_replay_file(mocker, cli_runner):\n        \"\"\"Test cli invocation correctly pass --replay-file option.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--replay-file', '~/custom-replay-file', '-v')\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay='~/custom-replay-file',\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay='~/custom-replay-file', overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': '~/custom-replay-file', 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'replay': False} != {'replay': '~/custom-replay-file'}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE         -     'replay': '~/custom-replay-file',\nE         +     'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:140: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_replay_generated","title":"test_cli.py::test_cli_replay_generated","text":"<pre>test_cli.py::test_cli_replay_generated</pre><pre>\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_tmp_dir')\n    def test_cli_replay_generated(mocker, cli_runner):\n        \"\"\"Test cli invocation correctly generates a project with replay.\"\"\"\n        template_path = 'tests/fake-repo-replay/'\n        result = cli_runner(\n            template_path,\n            '--replay-file',\n            'tests/test-replay/valid_replay.json',\n            '-o',\n            'tests/tmp/',\n            '-v',\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:170: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_exit_on_noinput_and_replay","title":"test_cli.py::test_cli_exit_on_noinput_and_replay","text":"<pre>test_cli.py::test_cli_exit_on_noinput_and_replay</pre><pre>\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_exit_on_noinput_and_replay(mocker, cli_runner):\n        \"\"\"Test cli invocation fail if both `no-input` and `replay` flags passed.\"\"\"\n        mock_cookiecutter = mocker.patch(\n            'cookiecutter.cli.cookiecutter', side_effect=cookiecutter\n        )\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--no-input', '--replay', '-v')\n\n        assert result.exit_code == 1\n\n        expected_error_msg = (\n            \"You can not use both replay and no_input or extra_context at the same time.\"\n        )\n\n&gt;       assert expected_error_msg in result.output\nE       assert 'You can not use both replay and no_input or extra_context at the same time.' in ''\nE        +  where '' = .output\n\ntests/test_cli.py:190: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_run_cookiecutter_on_overwrite_if_exists_and_replay-f","title":"test_cli.py::test_run_cookiecutter_on_overwrite_if_exists_and_replay[-f]","text":"<pre>test_cli.py::test_run_cookiecutter_on_overwrite_if_exists_and_replay[-f]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd3997880&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': True, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': True, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': True,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': True,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '-f'\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_run_cookiecutter_on_overwrite_if_exists_and_replay(\n        mocker, cli_runner, overwrite_cli_flag\n    ):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `replay` flags.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--replay', '-v', overwrite_cli_flag)\n\n        assert result.exit_code == 0\n\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=True,\n            overwrite_if_exists=True,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': True, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': True, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': True,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': True,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:228: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_run_cookiecutter_on_overwrite_if_exists_and_replay-overwrite-if-exists","title":"test_cli.py::test_run_cookiecutter_on_overwrite_if_exists_and_replay[--overwrite-if-exists]","text":"<pre>test_cli.py::test_run_cookiecutter_on_overwrite_if_exists_and_replay[--overwrite-if-exists]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd38cea70&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': True, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': True, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': True,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': True,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '--overwrite-if-exists'\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_run_cookiecutter_on_overwrite_if_exists_and_replay(\n        mocker, cli_runner, overwrite_cli_flag\n    ):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `replay` flags.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--replay', '-v', overwrite_cli_flag)\n\n        assert result.exit_code == 0\n\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=True,\n            overwrite_if_exists=True,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=True, overwrite_if_exists=True, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=True, overwrite_if_exists=True, output_dir='.', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': True, 'overwrite_if_exists': True, 'output_dir': '.', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': True, 'overwrite_if_exists': True, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': True,\nE          'password': None,\nE          'replay': True,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': True,\nE               'password': None,\nE               'replay': True,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:228: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_overwrite_if_exists_when_output_dir_does_not_exist-f","title":"test_cli.py::test_cli_overwrite_if_exists_when_output_dir_does_not_exist[-f]","text":"<pre>test_cli.py::test_cli_overwrite_if_exists_when_output_dir_does_not_exist[-f]</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '-f'\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_overwrite_if_exists_when_output_dir_does_not_exist(\n        cli_runner, overwrite_cli_flag\n    ):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `no-input` flags.\n\n        Case when output dir not exist.\n        \"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)\n\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:256: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_overwrite_if_exists_when_output_dir_does_not_exist-overwrite-if-exists","title":"test_cli.py::test_cli_overwrite_if_exists_when_output_dir_does_not_exist[--overwrite-if-exists]","text":"<pre>test_cli.py::test_cli_overwrite_if_exists_when_output_dir_does_not_exist[--overwrite-if-exists]</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '--overwrite-if-exists'\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_overwrite_if_exists_when_output_dir_does_not_exist(\n        cli_runner, overwrite_cli_flag\n    ):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `no-input` flags.\n\n        Case when output dir not exist.\n        \"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)\n\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:256: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_overwrite_if_exists_when_output_dir_exists-f","title":"test_cli.py::test_cli_overwrite_if_exists_when_output_dir_exists[-f]","text":"<pre>test_cli.py::test_cli_overwrite_if_exists_when_output_dir_exists[-f]</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '-f'\n\n    @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir')\n    def test_cli_overwrite_if_exists_when_output_dir_exists(cli_runner, overwrite_cli_flag):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `no-input` flags.\n\n        Case when output dir already exist.\n        \"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:267: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_overwrite_if_exists_when_output_dir_exists-overwrite-if-exists","title":"test_cli.py::test_cli_overwrite_if_exists_when_output_dir_exists[--overwrite-if-exists]","text":"<pre>test_cli.py::test_cli_overwrite_if_exists_when_output_dir_exists[--overwrite-if-exists]</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noverwrite_cli_flag = '--overwrite-if-exists'\n\n    @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir')\n    def test_cli_overwrite_if_exists_when_output_dir_exists(cli_runner, overwrite_cli_flag):\n        \"\"\"Test cli invocation with `overwrite-if-exists` and `no-input` flags.\n\n        Case when output dir already exist.\n        \"\"\"\n        result = cli_runner('tests/fake-repo-pre/', '--no-input', overwrite_cli_flag)\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:267: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_output_dir-o","title":"test_cli.py::test_cli_output_dir[-o]","text":"<pre>test_cli.py::test_cli_output_dir[-o]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd382e050&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '-o'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output'\n\n    def test_cli_output_dir(mocker, cli_runner, output_dir_flag, output_dir):\n        \"\"\"Test cli invocation with `output-dir` flag changes output directory.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, output_dir_flag, output_dir)\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir__o_0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:285: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_output_dir-output-dir","title":"test_cli.py::test_cli_output_dir[--output-dir]","text":"<pre>test_cli.py::test_cli_output_dir[--output-dir]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd38cfac0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '--output-dir'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output'\n\n    def test_cli_output_dir(mocker, cli_runner, output_dir_flag, output_dir):\n        \"\"\"Test cli invocation with `output-dir` flag changes output directory.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, output_dir_flag, output_dir)\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_output_dir___output_d0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:285: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_helphelp","title":"test_cli.py::test_cli_help[help]","text":"<pre>test_cli.py::test_cli_help[help]</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\nhelp_cli_flag = 'help'\n\n    def test_cli_help(cli_runner, help_cli_flag):\n        \"\"\"Test cli invocation display help message with `help` flag.\"\"\"\n        result = cli_runner(help_cli_flag)\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:312: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_user_config","title":"test_cli.py::test_user_config","text":"<pre>test_cli.py::test_user_config</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd382cc10&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml',\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml',\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\nuser_config_path = '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml'\n\n    def test_user_config(mocker, cli_runner, user_config_path):\n        \"\"\"Test cli invocation works with `config-file` option.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--config-file', user_config_path)\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=user_config_path,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml', 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml',\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': '/tmp/pytest-of-root/pytest-0/test_user_config0/tests/config.yaml',\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:330: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_default_user_config_overwrite","title":"test_cli.py::test_default_user_config_overwrite","text":"<pre>test_cli.py::test_default_user_config_overwrite</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd382d630&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml',\nE          'default_config': True,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml',\nE               'default_config': True,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\nuser_config_path = '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml'\n\n    def test_default_user_config_overwrite(mocker, cli_runner, user_config_path):\n        \"\"\"Test cli invocation ignores `config-file` if `default-config` passed.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(\n            template_path,\n            '--config-file',\n            user_config_path,\n            '--default-config',\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=user_config_path,\n            default_config=True,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file='/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml', 'default_config': True, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml',\nE          'default_config': True,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': '/tmp/pytest-of-root/pytest-0/test_default_user_config_overw0/tests/config.yaml',\nE               'default_config': True,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:361: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_default_user_config","title":"test_cli.py::test_default_user_config","text":"<pre>test_cli.py::test_default_user_config</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': True, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd382f7f0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': True, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': True, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': True, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': True,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': True,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    def test_default_user_config(mocker, cli_runner):\n        \"\"\"Test cli invocation accepts `default-config` flag correctly.\"\"\"\n        mock_cookiecutter = mocker.patch('cookiecutter.cli.cookiecutter')\n\n        template_path = 'tests/fake-repo-pre/'\n        result = cli_runner(template_path, '--default-config')\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            skip_if_file_exists=False,\n            output_dir='.',\n            config_file=None,\n            default_config=True,\n            extra_context=None,\n            password=None,\n            directory=None,\n            accept_hooks=True,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, skip_if_file_exists=False, output_dir='.', config_file=None, default_config=True, extra_context=None, password=None, directory=None, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=True, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': True, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'skip_if_file_exists': False, 'output_dir': '.', 'config_file': None, 'default_config': True, 'extra_context': None, 'password': None, 'directory': None, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': True,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '.',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': True,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '.',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:387: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_echo_undefined_variable_error","title":"test_cli.py::test_echo_undefined_variable_error","text":"<pre>test_cli.py::test_echo_undefined_variable_error</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_echo_undefined_variable_e0/output'\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    def test_echo_undefined_variable_error(output_dir, cli_runner):\n        \"\"\"Cli invocation return error if variable undefined in template.\"\"\"\n        template_path = 'tests/undefined-variable/file-name/'\n\n        result = cli_runner(\n            '--no-input',\n            '--default-config',\n            '--output-dir',\n            output_dir,\n            template_path,\n        )\n\n        assert result.exit_code == 1\n\n        error = \"Unable to create file '{{cookiecutter.foobar}}'\"\n&gt;       assert error in result.output\nE       assert \"Unable to create file '{{cookiecutter.foobar}}'\" in ''\nE        +  where '' = .output\n\ntests/test_cli.py:420: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_echo_unknown_extension_error","title":"test_cli.py::test_echo_unknown_extension_error","text":"<pre>test_cli.py::test_echo_unknown_extension_error</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_echo_unknown_extension_er0/output'\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    def test_echo_unknown_extension_error(output_dir, cli_runner):\n        \"\"\"Cli return error if extension incorrectly defined in template.\"\"\"\n        template_path = 'tests/test-extensions/unknown/'\n\n        result = cli_runner(\n            '--no-input',\n            '--default-config',\n            '--output-dir',\n            output_dir,\n            template_path,\n        )\n\n        assert result.exit_code == 1\n\n&gt;       assert 'Unable to load extension: ' in result.output\nE       assert 'Unable to load extension: ' in ''\nE        +  where '' = .output\n\ntests/test_cli.py:459: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_local_extension","title":"test_cli.py::test_local_extension","text":"<pre>test_cli.py::test_local_extension</pre><pre>\ntmpdir = local('/tmp/pytest-of-root/pytest-0/test_local_extension0')\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    def test_local_extension(tmpdir, cli_runner):\n        \"\"\"Test to verify correct work of extension, included in template.\"\"\"\n        output_dir = str(tmpdir.mkdir('output'))\n        template_path = 'tests/test-extensions/local_extension/'\n\n        result = cli_runner(\n            '--no-input',\n            '--default-config',\n            '--output-dir',\n            output_dir,\n            template_path,\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:474: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_extra_context","title":"test_cli.py::test_cli_extra_context","text":"<pre>test_cli.py::test_cli_extra_context</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_extra_context(cli_runner):\n        \"\"\"Cli invocation replace content if called with replacement pairs.\"\"\"\n        result = cli_runner(\n            'tests/fake-repo-pre/',\n            '--no-input',\n            '-v',\n            'project_name=Awesomez',\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:499: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_extra_context_invalid_format","title":"test_cli.py::test_cli_extra_context_invalid_format","text":"<pre>test_cli.py::test_cli_extra_context_invalid_format</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_extra_context_invalid_format(cli_runner):\n        \"\"\"Cli invocation raise error if called with unknown argument.\"\"\"\n        result = cli_runner(\n            'tests/fake-repo-pre/',\n            '--no-input',\n            '-v',\n            'ExtraContextWithNoEqualsSoInvalid',\n        )\n        assert result.exit_code == 2\n        assert \"Error: Invalid value for '[EXTRA_CONTEXT]...'\" in result.output\n&gt;       assert 'should contain items of the form key=value' in result.output\nE       assert 'should contain items of the form key=value' in 'Usage: main [OPTIONS] [TEMPLATE] [EXTRA_CONTEXT]...\\nTry \\'main -h\\' for help.\\n\\nError: Invalid value for \\'[EXTRA_CONTEXT]...\\': \"ExtraContextWithNoEqualsSoInvalid\" is not a valid key/value pair. Use the format key=value.\\n'\nE        +  where 'Usage: main [OPTIONS] [TEMPLATE] [EXTRA_CONTEXT]...\\nTry \\'main -h\\' for help.\\n\\nError: Invalid value for \\'[EXTRA_CONTEXT]...\\': \"ExtraContextWithNoEqualsSoInvalid\" is not a valid key/value pair. Use the format key=value.\\n' = .output\n\ntests/test_cli.py:516: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_debug_file_non_verbose","title":"test_cli.py::test_debug_file_non_verbose","text":"<pre>test_cli.py::test_debug_file_non_verbose</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\ndebug_file = PosixPath('/tmp/pytest-of-root/pytest-0/test_debug_file_non_verbose0/fake-repo.log')\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_debug_file_non_verbose(cli_runner, debug_file):\n        \"\"\"Test cli invocation writes log to `debug-file` if flag enabled.\n\n        Case for normal log output.\n        \"\"\"\n        assert not debug_file.exists()\n\n        result = cli_runner(\n            '--no-input',\n            '--debug-file',\n            str(debug_file),\n            'tests/fake-repo-pre/',\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:539: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_debug_file_verbose","title":"test_cli.py::test_debug_file_verbose","text":"<pre>test_cli.py::test_debug_file_verbose</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\ndebug_file = PosixPath('/tmp/pytest-of-root/pytest-0/test_debug_file_verbose0/fake-repo.log')\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_debug_file_verbose(cli_runner, debug_file):\n        \"\"\"Test cli invocation writes log to `debug-file` if flag enabled.\n\n        Case for verbose log output.\n        \"\"\"\n        assert not debug_file.exists()\n\n        result = cli_runner(\n            '--verbose',\n            '--no-input',\n            '--debug-file',\n            str(debug_file),\n            'tests/fake-repo-pre/',\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:566: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_debug_list_installed_templates","title":"test_cli.py::test_debug_list_installed_templates","text":"<pre>test_cli.py::test_debug_list_installed_templates</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\ndebug_file = PosixPath('/tmp/pytest-of-root/pytest-0/test_debug_list_installed_temp0/fake-repo.log')\nuser_config_path = '/tmp/pytest-of-root/pytest-0/test_debug_list_installed_temp0/tests/config.yaml'\n\n    @pytest.mark.usefixtures('make_fake_project_dir', 'remove_fake_project_dir')\n    def test_debug_list_installed_templates(cli_runner, debug_file, user_config_path):\n        \"\"\"Verify --list-installed command correct invocation.\"\"\"\n        fake_template_dir = os.path.dirname(os.path.abspath('fake-project'))\n        os.makedirs(os.path.dirname(user_config_path))\n        # Single quotes in YAML will not parse escape codes (\\).\n        Path(user_config_path).write_text(f\"cookiecutters_dir: '{fake_template_dir}'\")\n        Path(\"fake-project\", \"cookiecutter.json\").write_text('{}')\n\n        result = cli_runner(\n            '--list-installed',\n            '--config-file',\n            user_config_path,\n            str(debug_file),\n        )\n\n&gt;       assert \"1 installed templates:\" in result.output\nE       AssertionError: assert '1 installed templates:' in 'Installed templates:\\n  cookiecutter\\n  .github\\n  logo\\n  .git\\n  cookiecutter.egg-info\\n  tests\\n  docs\\n  .venv\\n  fake-project\\n'\nE        +  where 'Installed templates:\\n  cookiecutter\\n  .github\\n  logo\\n  .git\\n  cookiecutter.egg-info\\n  tests\\n  docs\\n  .venv\\n  fake-project\\n' = .output\n\ntests/test_cli.py:594: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_debug_list_installed_templates_failure","title":"test_cli.py::test_debug_list_installed_templates_failure","text":"<pre>test_cli.py::test_debug_list_installed_templates_failure</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\ndebug_file = PosixPath('/tmp/pytest-of-root/pytest-0/test_debug_list_installed_temp1/fake-repo.log')\nuser_config_path = '/tmp/pytest-of-root/pytest-0/test_debug_list_installed_temp1/tests/config.yaml'\n\n    def test_debug_list_installed_templates_failure(\n        cli_runner, debug_file, user_config_path\n    ):\n        \"\"\"Verify --list-installed command error on invocation.\"\"\"\n        os.makedirs(os.path.dirname(user_config_path))\n        Path(user_config_path).write_text('cookiecutters_dir: \"/notarealplace/\"')\n\n        result = cli_runner(\n            '--list-installed', '--config-file', user_config_path, str(debug_file)\n        )\n\n&gt;       assert \"Error: Cannot list installed templates.\" in result.output\nE       AssertionError: assert 'Error: Cannot list installed templates.' in 'No templates found in /notarealplace/\\n'\nE        +  where 'No templates found in /notarealplace/\\n' = .output\n\ntests/test_cli.py:609: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_directory_repo","title":"test_cli.py::test_directory_repo","text":"<pre>test_cli.py::test_directory_repo</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_directory_repo(cli_runner):\n        \"\"\"Test cli invocation works with `directory` option.\"\"\"\n        result = cli_runner(\n            'tests/fake-repo-dir/',\n            '--no-input',\n            '-v',\n            '--directory=my-dir',\n        )\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:622: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-o-accept-hooksyes-none-true","title":"test_cli.py::test_cli_accept_hooks[-o---accept-hooks=yes-None-True]","text":"<pre>test_cli.py::test_cli_accept_hooks[-o---accept-hooks=yes-None-True]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd3396a70&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '-o'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output'\naccept_hooks_arg = '--accept-hooks=yes', user_input = None, expected = True\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-o-accept-hooksno-none-false","title":"test_cli.py::test_cli_accept_hooks[-o---accept-hooks=no-None-False]","text":"<pre>test_cli.py::test_cli_accept_hooks[-o---accept-hooks=no-None-False]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a8dc0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'no', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'no'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^^^^^\nE         +     'accept_hooks': 'no',\nE         ?                     ^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '-o'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output'\naccept_hooks_arg = '--accept-hooks=no', user_input = None, expected = False\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'no', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'no'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^^^^^\nE         +     'accept_hooks': 'no',\nE         ?                     ^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc1/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-o-accept-hooksask-yes-true","title":"test_cli.py::test_cli_accept_hooks[-o---accept-hooks=ask-yes-True]","text":"<pre>test_cli.py::test_cli_accept_hooks[-o---accept-hooks=ask-yes-True]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a8ee0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '-o'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output'\naccept_hooks_arg = '--accept-hooks=ask', user_input = 'yes', expected = True\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc2/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-o-accept-hooksask-no-false","title":"test_cli.py::test_cli_accept_hooks[-o---accept-hooks=ask-no-False]","text":"<pre>test_cli.py::test_cli_accept_hooks[-o---accept-hooks=ask-no-False]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a96c0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^ - ^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^  ^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '-o'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output'\naccept_hooks_arg = '--accept-hooks=ask', user_input = 'no', expected = False\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^ - ^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^  ^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks__o___acc3/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-output-dir-accept-hooksyes-none-true","title":"test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=yes-None-True]","text":"<pre>test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=yes-None-True]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a9510&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '--output-dir'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output'\naccept_hooks_arg = '--accept-hooks=yes', user_input = None, expected = True\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='yes', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'yes', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'yes'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^\nE         +     'accept_hooks': 'yes',\nE         ?                     ^^ ++\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output0/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-output-dir-accept-hooksno-none-false","title":"test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=no-None-False]","text":"<pre>test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=no-None-False]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a9b40&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'no', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'no'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^^^^^\nE         +     'accept_hooks': 'no',\nE         ?                     ^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '--output-dir'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output'\naccept_hooks_arg = '--accept-hooks=no', user_input = None, expected = False\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='no', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'no', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'no'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^^^^^\nE         +     'accept_hooks': 'no',\nE         ?                     ^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output1/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-output-dir-accept-hooksask-yes-true","title":"test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=ask-yes-True]","text":"<pre>test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=ask-yes-True]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33a8c10&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': True, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '--output-dir'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output'\naccept_hooks_arg = '--accept-hooks=ask', user_input = 'yes', expected = True\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': True, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': True}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': True,\nE         ?                     ^^^^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^^^^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output2/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_accept_hooks-output-dir-accept-hooksask-no-false","title":"test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=ask-no-False]","text":"<pre>test_cli.py::test_cli_accept_hooks[--output-dir---accept-hooks=ask-no-False]</pre><pre>\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\nexpected = call('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nactual = call('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n_error_message = ._error_message at 0x7f8dd33aaef0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE           Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('tests/fake-repo-pre/', None, False)\nkwargs = {'accept_hooks': False, 'config_file': None, 'default_config': False, 'directory': None, ...}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^ - ^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^  ^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\noutput_dir_flag = '--output-dir'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output'\naccept_hooks_arg = '--accept-hooks=ask', user_input = 'no', expected = False\n\n    @pytest.mark.parametrize(\n        \"accept_hooks_arg,user_input,expected\", cli_accept_hook_arg_testdata\n    )\n    def test_cli_accept_hooks(\n        mocker,\n        cli_runner,\n        output_dir_flag,\n        output_dir,\n        accept_hooks_arg,\n        user_input,\n        expected,\n    ):\n        \"\"\"Test cli invocation works with `accept-hooks` option.\"\"\"\n        mock_cookiecutter = mocker.patch(\"cookiecutter.cli.cookiecutter\")\n\n        template_path = \"tests/fake-repo-pre/\"\n        result = cli_runner(\n            template_path, output_dir_flag, output_dir, accept_hooks_arg, input=user_input\n        )\n\n        assert result.exit_code == 0\n&gt;       mock_cookiecutter.assert_called_once_with(\n            template_path,\n            None,\n            False,\n            replay=False,\n            overwrite_if_exists=False,\n            output_dir=output_dir,\n            config_file=None,\n            default_config=False,\n            extra_context=None,\n            password=None,\n            directory=None,\n            skip_if_file_exists=False,\n            accept_hooks=expected,\n            keep_project_on_failure=False,\n        )\nE       AssertionError: expected call not found.\nE       Expected: cookiecutter('tests/fake-repo-pre/', None, False, replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, extra_context=None, password=None, directory=None, skip_if_file_exists=False, accept_hooks=False, keep_project_on_failure=False)\nE       Actual: cookiecutter('tests/fake-repo-pre/', checkout=None, no_input=False, extra_context=OrderedDict(), replay=False, overwrite_if_exists=False, output_dir='/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', config_file=None, default_config=False, password=None, directory=None, skip_if_file_exists=False, accept_hooks='ask', keep_project_on_failure=False)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('tests/fake-repo-pre/',) == ('tests/fake-repo-pre/', None, False)\nE         \nE         Right contains 2 more items, first extra item: None\nE         \nE         Full diff:\nE           (\nE               'tests/fake-repo-pre/',\nE         -     None,\nE         -     False,\nE           )\nE       Kwargs:\nE       assert {'checkout': None, 'no_input': False, 'extra_context': OrderedDict(), 'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', 'config_file': None, 'default_config': False, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': 'ask', 'keep_project_on_failure': False} == {'replay': False, 'overwrite_if_exists': False, 'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output', 'config_file': None, 'default_config': False, 'extra_context': None, 'password': None, 'directory': None, 'skip_if_file_exists': False, 'accept_hooks': False, 'keep_project_on_failure': False}\nE         \nE         Common items:\nE         {'config_file': None,\nE          'default_config': False,\nE          'directory': None,\nE          'keep_project_on_failure': False,\nE          'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output',\nE          'overwrite_if_exists': False,\nE          'password': None,\nE          'replay': False,\nE          'skip_if_file_exists': False}\nE         Differing items:\nE         {'extra_context': OrderedDict()} != {'extra_context': None}\nE         {'accept_hooks': 'ask'} != {'accept_hooks': False}\nE         Left contains 2 more items:\nE         {'checkout': None, 'no_input': False}\nE         \nE         Full diff:\nE           {\nE         -     'accept_hooks': False,\nE         ?                     ^ - ^\nE         +     'accept_hooks': 'ask',\nE         ?                     ^  ^^\nE         +     'checkout': None,\nE               'config_file': None,\nE               'default_config': False,\nE               'directory': None,\nE         -     'extra_context': None,\nE         ?                      ^^^\nE         +     'extra_context': OrderedDict(),\nE         ?                      ^^^ +++++++++\nE               'keep_project_on_failure': False,\nE         +     'no_input': False,\nE               'output_dir': '/tmp/pytest-of-root/pytest-0/test_cli_accept_hooks___output3/output',\nE               'overwrite_if_exists': False,\nE               'password': None,\nE               'replay': False,\nE               'skip_if_file_exists': False,\nE           }\n\ntests/test_cli.py:657: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_with_json_decoding_error","title":"test_cli.py::test_cli_with_json_decoding_error","text":"<pre>test_cli.py::test_cli_with_json_decoding_error</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_with_json_decoding_error(cli_runner):\n        \"\"\"Test cli invocation with a malformed JSON file.\"\"\"\n        template_path = 'tests/fake-repo-bad-json/'\n        result = cli_runner(template_path, '--no-input')\n        assert result.exit_code != 0\n\n        # Validate the error message.\n        # original message from json module should be included\n        pattern = 'Expecting \\'{0,1}:\\'{0,1} delimiter: line 1 column (19|20) \\\\(char 19\\\\)'\n&gt;       assert re.search(pattern, result.output)\nE       assert None\nE        +  where None = (\"Expecting '{0,1}:'{0,1} delimiter: line 1 column (19|20) \\\\(char 19\\\\)\", '')\nE        +    where  = re.search\nE        +    and   '' = .output\n\ntests/test_cli.py:685: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clipytest_cli_with_pre_prompt_hook","title":"test_cli.py::test_cli_with_pre_prompt_hook","text":"<pre>test_cli.py::test_cli_with_pre_prompt_hook</pre><pre>\ncli_runner = .cli_main at 0x7f8dd38ce680&gt;\n\n    @pytest.mark.usefixtures('remove_fake_project_dir')\n    def test_cli_with_pre_prompt_hook(cli_runner):\n        \"\"\"Test cli invocation in a template with pre_prompt hook.\"\"\"\n        template_path = 'tests/test-pyhooks/'\n        result = cli_runner(template_path, '--no-input')\n&gt;       assert result.exit_code == 0\nE       assert 1 == 0\nE        +  where 1 = .exit_code\n\ntests/test_cli.py:699: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_invocationpytest_should_invoke_main","title":"test_cookiecutter_invocation.py::test_should_invoke_main","text":"<pre>test_cookiecutter_invocation.py::test_should_invoke_main</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3453fa0&gt;\nproject_dir = 'fake-project-templated'\n\n    @pytest.mark.usefixtures('clean_system')\n    def test_should_invoke_main(monkeypatch, project_dir):\n        \"\"\"Should create a project and exit with 0 code on cli invocation.\"\"\"\n        monkeypatch.setenv('PYTHONPATH', '.')\n\n&gt;       exit_code = subprocess.check_call(\n            [sys.executable, '-m', 'cookiecutter.cli', 'tests/fake-repo-tmpl', '--no-input']\n        )\n\ntests/test_cookiecutter_invocation.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npopenargs = (['/testbed/.venv/bin/python3', '-m', 'cookiecutter.cli', 'tests/fake-repo-tmpl', '--no-input'],)\nkwargs = {}, retcode = 1\ncmd = ['/testbed/.venv/bin/python3', '-m', 'cookiecutter.cli', 'tests/fake-repo-tmpl', '--no-input']\n\n    def check_call(*popenargs, **kwargs):\n        \"\"\"Run command with arguments.  Wait for command to complete.  If\n        the exit code was zero then return, otherwise raise\n        CalledProcessError.  The CalledProcessError object will have the\n        return code in the returncode attribute.\n\n        The arguments are the same as for the call function.  Example:\n\n        check_call([\"ls\", \"-l\"])\n        \"\"\"\n        retcode = call(*popenargs, **kwargs)\n        if retcode:\n            cmd = kwargs.get(\"args\")\n            if cmd is None:\n                cmd = popenargs[0]\n&gt;           raise CalledProcessError(retcode, cmd)\nE           subprocess.CalledProcessError: Command '['/testbed/.venv/bin/python3', '-m', 'cookiecutter.cli', 'tests/fake-repo-tmpl', '--no-input']' returned non-zero exit status 1.\n\n/usr/lib/python3.10/subprocess.py:369: CalledProcessError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#_1","title":"]","text":"<pre>]</pre><pre>\npath = 'tests/fake-repo-pre/'\n\n    @pytest.mark.parametrize('path', ['tests/fake-repo-pre/', 'tests/fake-repo-pre'])\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_no_input_return_project_dir(path):\n        \"\"\"Verify `cookiecutter` create project dir on input with or without slash.\"\"\"\n&gt;       project_dir = main.cookiecutter(path, no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre/', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#fake-repo-pre","title":"fake-repo-pre]","text":"<pre>fake-repo-pre]</pre><pre>\npath = 'tests/fake-repo-pre'\n\n    @pytest.mark.parametrize('path', ['tests/fake-repo-pre/', 'tests/fake-repo-pre'])\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_no_input_return_project_dir(path):\n        \"\"\"Verify `cookiecutter` create project dir on input with or without slash.\"\"\"\n&gt;       project_dir = main.cookiecutter(path, no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_no_inputpytest_cookiecutter_no_input_extra_context","title":"test_cookiecutter_local_no_input.py::test_cookiecutter_no_input_extra_context","text":"<pre>test_cookiecutter_local_no_input.py::test_cookiecutter_no_input_extra_context</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_no_input_extra_context():\n        \"\"\"Verify `cookiecutter` accept `extra_context` argument.\"\"\"\n&gt;       main.cookiecutter(\n            'tests/fake-repo-pre',\n            no_input=True,\n            extra_context={'repo_name': 'fake-project-extra'},\n        )\n\ntests/test_cookiecutter_local_no_input.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre', checkout = None, no_input = True\nextra_context = {'repo_name': 'fake-project-extra'}, replay = None\noverwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_no_inputpytest_cookiecutter_templated_context","title":"test_cookiecutter_local_no_input.py::test_cookiecutter_templated_context","text":"<pre>test_cookiecutter_local_no_input.py::test_cookiecutter_templated_context</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_templated_context():\n        \"\"\"Verify Jinja2 templating correctly works in `cookiecutter.json` file.\"\"\"\n&gt;       main.cookiecutter('tests/fake-repo-tmpl', no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-tmpl', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_no_inputpytest_cookiecutter_no_input_return_rendered_file","title":"test_cookiecutter_local_no_input.py::test_cookiecutter_no_input_return_rendered_file","text":"<pre>test_cookiecutter_local_no_input.py::test_cookiecutter_no_input_return_rendered_file</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_no_input_return_rendered_file():\n        \"\"\"Verify Jinja2 templating correctly works in `cookiecutter.json` file.\"\"\"\n&gt;       project_dir = main.cookiecutter('tests/fake-repo-pre', no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_no_inputpytest_cookiecutter_dict_values_in_context","title":"test_cookiecutter_local_no_input.py::test_cookiecutter_dict_values_in_context","text":"<pre>test_cookiecutter_local_no_input.py::test_cookiecutter_dict_values_in_context</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_dict_values_in_context():\n        \"\"\"Verify configured dictionary from `cookiecutter.json` correctly unpacked.\"\"\"\n&gt;       project_dir = main.cookiecutter('tests/fake-repo-dict', no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-dict', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_no_inputpytest_cookiecutter_template_cleanup","title":"test_cookiecutter_local_no_input.py::test_cookiecutter_template_cleanup","text":"<pre>test_cookiecutter_local_no_input.py::test_cookiecutter_template_cleanup</pre><pre>\nmocker = \n\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_template_cleanup(mocker):\n        \"\"\"Verify temporary folder for zip unpacking dropped.\"\"\"\n        mocker.patch('tempfile.mkdtemp', return_value='fake-tmp', autospec=True)\n\n        mocker.patch(\n            'cookiecutter.prompt.prompt_and_delete', return_value=True, autospec=True\n        )\n\n&gt;       main.cookiecutter('tests/files/fake-repo-tmpl.zip', no_input=True)\n\ntests/test_cookiecutter_local_no_input.py:133: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/files/fake-repo-tmpl.zip', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_with_inputpytest_cookiecutter_local_with_input","title":"test_cookiecutter_local_with_input.py::test_cookiecutter_local_with_input","text":"<pre>test_cookiecutter_local_with_input.py::test_cookiecutter_local_with_input</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd4bc06a0&gt;\n\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_local_with_input(monkeypatch):\n        \"\"\"Verify simple cookiecutter run results, without extra_context provided.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n&gt;       main.cookiecutter('tests/fake-repo-pre/', no_input=False)\n\ntests/test_cookiecutter_local_with_input.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre/', checkout = None, no_input = False\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_local_with_inputpytest_cookiecutter_input_extra_context","title":"test_cookiecutter_local_with_input.py::test_cookiecutter_input_extra_context","text":"<pre>test_cookiecutter_local_with_input.py::test_cookiecutter_input_extra_context</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd31b01c0&gt;\n\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_dirs')\n    def test_cookiecutter_input_extra_context(monkeypatch):\n        \"\"\"Verify simple cookiecutter run results, with extra_context provided.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n&gt;       main.cookiecutter(\n            'tests/fake-repo-pre',\n            no_input=False,\n            extra_context={'repo_name': 'fake-project-input-extra'},\n        )\n\ntests/test_cookiecutter_local_with_input.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/fake-repo-pre', checkout = None, no_input = False\nextra_context = {'repo_name': 'fake-project-input-extra'}, replay = None\noverwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_nested_templatespytest_cookiecutter_nested_templatesfake-nested-templates-fake-project","title":"test_cookiecutter_nested_templates.py::test_cookiecutter_nested_templates[fake-nested-templates-fake-project]","text":"<pre>test_cookiecutter_nested_templates.py::test_cookiecutter_nested_templates[fake-nested-templates-fake-project]</pre><pre>\nmocker = \ntemplate_dir = 'fake-nested-templates', output_dir = 'fake-project'\n\n    @pytest.mark.parametrize(\n        \"template_dir,output_dir\",\n        [\n            [\"fake-nested-templates\", \"fake-project\"],\n            [\"fake-nested-templates-old-style\", \"fake-package\"],\n        ],\n    )\n    def test_cookiecutter_nested_templates(mocker, template_dir: str, output_dir: str):\n        \"\"\"Verify cookiecutter nested configuration files mechanism.\"\"\"\n        mock_generate_files = mocker.patch(\"cookiecutter.main.generate_files\")\n        main_dir = (Path(\"tests\") / template_dir).resolve()\n&gt;       main.cookiecutter(f\"{main_dir}\", no_input=True)\n\ntests/test_cookiecutter_nested_templates.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '/testbed/tests/fake-nested-templates', checkout = None\nno_input = True, extra_context = None, replay = None\noverwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_cookiecutter_nested_templatespytest_cookiecutter_nested_templatesfake-nested-templates-old-style-fake-package","title":"test_cookiecutter_nested_templates.py::test_cookiecutter_nested_templates[fake-nested-templates-old-style-fake-package]","text":"<pre>test_cookiecutter_nested_templates.py::test_cookiecutter_nested_templates[fake-nested-templates-old-style-fake-package]</pre><pre>\nmocker = \ntemplate_dir = 'fake-nested-templates-old-style', output_dir = 'fake-package'\n\n    @pytest.mark.parametrize(\n        \"template_dir,output_dir\",\n        [\n            [\"fake-nested-templates\", \"fake-project\"],\n            [\"fake-nested-templates-old-style\", \"fake-package\"],\n        ],\n    )\n    def test_cookiecutter_nested_templates(mocker, template_dir: str, output_dir: str):\n        \"\"\"Verify cookiecutter nested configuration files mechanism.\"\"\"\n        mock_generate_files = mocker.patch(\"cookiecutter.main.generate_files\")\n        main_dir = (Path(\"tests\") / template_dir).resolve()\n&gt;       main.cookiecutter(f\"{main_dir}\", no_input=True)\n\ntests/test_cookiecutter_nested_templates.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '/testbed/tests/fake-nested-templates-old-style', checkout = None\nno_input = True, extra_context = None, replay = None\noverwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_custom_extensions_in_hookspytest_hook_with_extensionpre_gen_hook","title":"test_custom_extensions_in_hooks.py::test_hook_with_extension[pre_gen_hook]","text":"<pre>test_custom_extensions_in_hooks.py::test_hook_with_extension[pre_gen_hook]</pre><pre>\ntemplate = 'tests/test-extensions/custom-extension-pre'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hook_with_extension_pre_g0/output'\n\n    def test_hook_with_extension(template, output_dir):\n        \"\"\"Verify custom Jinja2 extension correctly work in hooks and file rendering.\n\n        Each file in hooks has simple tests inside and will raise error if not\n        correctly rendered.\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            template,\n            no_input=True,\n            output_dir=output_dir,\n            extra_context={'project_slug': 'foobar', 'name': 'Cookiemonster'},\n        )\n\ntests/test_custom_extensions_in_hooks.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-extensions/custom-extension-pre', checkout = None\nno_input = True\nextra_context = {'name': 'Cookiemonster', 'project_slug': 'foobar'}\nreplay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hook_with_extension_pre_g0/output'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_custom_extensions_in_hookspytest_hook_with_extensionpost_gen_hook","title":"test_custom_extensions_in_hooks.py::test_hook_with_extension[post_gen_hook]","text":"<pre>test_custom_extensions_in_hooks.py::test_hook_with_extension[post_gen_hook]</pre><pre>\ntemplate = 'tests/test-extensions/custom-extension-post'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hook_with_extension_post_0/output'\n\n    def test_hook_with_extension(template, output_dir):\n        \"\"\"Verify custom Jinja2 extension correctly work in hooks and file rendering.\n\n        Each file in hooks has simple tests inside and will raise error if not\n        correctly rendered.\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            template,\n            no_input=True,\n            output_dir=output_dir,\n            extra_context={'project_slug': 'foobar', 'name': 'Cookiemonster'},\n        )\n\ntests/test_custom_extensions_in_hooks.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-extensions/custom-extension-post', checkout = None\nno_input = True\nextra_context = {'name': 'Cookiemonster', 'project_slug': 'foobar'}\nreplay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_hook_with_extension_post_0/output'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_default_extensionspytest_jinja2_time_extension","title":"test_default_extensions.py::test_jinja2_time_extension","text":"<pre>test_default_extensions.py::test_jinja2_time_extension</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_jinja2_time_extension0')\n\n    def test_jinja2_time_extension(tmp_path):\n        \"\"\"Verify Jinja2 time extension work correctly.\"\"\"\n&gt;       project_dir = cookiecutter(\n            'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)\n        )\n\ntests/test_default_extensions.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-extensions/default/', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_jinja2_time_extension0'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_default_extensionspytest_jinja2_slugify_extension","title":"test_default_extensions.py::test_jinja2_slugify_extension","text":"<pre>test_default_extensions.py::test_jinja2_slugify_extension</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_jinja2_slugify_extension0')\n\n    def test_jinja2_slugify_extension(tmp_path):\n        \"\"\"Verify Jinja2 slugify extension work correctly.\"\"\"\n&gt;       project_dir = cookiecutter(\n            'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)\n        )\n\ntests/test_default_extensions.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-extensions/default/', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_jinja2_slugify_extension0'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_default_extensionspytest_jinja2_uuid_extension","title":"test_default_extensions.py::test_jinja2_uuid_extension","text":"<pre>test_default_extensions.py::test_jinja2_uuid_extension</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_jinja2_uuid_extension0')\n\n    def test_jinja2_uuid_extension(tmp_path):\n        \"\"\"Verify Jinja2 uuid extension work correctly.\"\"\"\n&gt;       project_dir = cookiecutter(\n            'tests/test-extensions/default/', no_input=True, output_dir=str(tmp_path)\n        )\n\ntests/test_default_extensions.py:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-extensions/default/', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_jinja2_uuid_extension0'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_findpytest_find_templatetemplate-with-default-jinja-strings","title":"test_find.py::test_find_template[template with default jinja strings]","text":"<pre>test_find.py::test_find_template[template with default jinja strings]</pre><pre>\nrepo_name = 'fake-repo-pre'\nenv = \nerror_expectation = \nexpected = '{{cookiecutter.repo_name}}'\n\n    @pytest.mark.parametrize(\n        \"repo_name,context,error_expectation,expected\",\n        [\n            (\"fake-repo-pre\", {}, does_not_raise(), '{{cookiecutter.repo_name}}'),\n            (\n                \"fake-repo-pre2\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                does_not_raise(),\n                '{%{cookiecutter.repo_name}%}',\n            ),\n            (\n                \"fake-repo-pre\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                pytest.raises(NonTemplatedInputDirException),\n                None,\n            ),\n            (\"fake-repo-bad\", {}, pytest.raises(NonTemplatedInputDirException), None),\n        ],\n        ids=[\n            'template with default jinja strings',\n            'template with custom jinja strings',\n            'template with custom jinja strings but folder with default jinja strings',\n            'template missing folder',\n        ],\n    )\n    def test_find_template(repo_name, env, error_expectation, expected):\n        \"\"\"Verify correctness of `find.find_template` path detection.\"\"\"\n        repo_dir = Path('tests', repo_name)\n\n        with error_expectation:\n            template = find.find_template(repo_dir, env)\n\n            test_dir = Path(repo_dir, expected)\n&gt;           assert template == test_dir\nE           AssertionError: assert PosixPath('tests/fake-repo-pre') == PosixPath('tests/fake-repo-pre/{{cookiecutter.repo_name}}')\n\ntests/test_find.py:72: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_findpytest_find_templatetemplate-with-custom-jinja-strings","title":"test_find.py::test_find_template[template with custom jinja strings]","text":"<pre>test_find.py::test_find_template[template with custom jinja strings]</pre><pre>\nrepo_name = 'fake-repo-pre2'\nenv = \nerror_expectation = \nexpected = '{%{cookiecutter.repo_name}%}'\n\n    @pytest.mark.parametrize(\n        \"repo_name,context,error_expectation,expected\",\n        [\n            (\"fake-repo-pre\", {}, does_not_raise(), '{{cookiecutter.repo_name}}'),\n            (\n                \"fake-repo-pre2\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                does_not_raise(),\n                '{%{cookiecutter.repo_name}%}',\n            ),\n            (\n                \"fake-repo-pre\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                pytest.raises(NonTemplatedInputDirException),\n                None,\n            ),\n            (\"fake-repo-bad\", {}, pytest.raises(NonTemplatedInputDirException), None),\n        ],\n        ids=[\n            'template with default jinja strings',\n            'template with custom jinja strings',\n            'template with custom jinja strings but folder with default jinja strings',\n            'template missing folder',\n        ],\n    )\n    def test_find_template(repo_name, env, error_expectation, expected):\n        \"\"\"Verify correctness of `find.find_template` path detection.\"\"\"\n        repo_dir = Path('tests', repo_name)\n\n        with error_expectation:\n            template = find.find_template(repo_dir, env)\n\n            test_dir = Path(repo_dir, expected)\n&gt;           assert template == test_dir\nE           AssertionError: assert PosixPath('tests/fake-repo-pre2') == PosixPath('tests/fake-repo-pre2/{%{cookiecutter.repo_name}%}')\n\ntests/test_find.py:72: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_findpytest_find_templatetemplate-with-custom-jinja-strings-but-folder-with-default-jinja-strings","title":"test_find.py::test_find_template[template with custom jinja strings but folder with default jinja strings]","text":"<pre>test_find.py::test_find_template[template with custom jinja strings but folder with default jinja strings]</pre><pre>\nrepo_name = 'fake-repo-pre'\nenv = \nerror_expectation = &lt;_pytest.python_api.RaisesContext object at 0x7f8dd3a7a4d0&gt;\nexpected = None\n\n    @pytest.mark.parametrize(\n        \"repo_name,context,error_expectation,expected\",\n        [\n            (\"fake-repo-pre\", {}, does_not_raise(), '{{cookiecutter.repo_name}}'),\n            (\n                \"fake-repo-pre2\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                does_not_raise(),\n                '{%{cookiecutter.repo_name}%}',\n            ),\n            (\n                \"fake-repo-pre\",\n                {\n                    'cookiecutter': {\n                        '_jinja2_env_vars': {\n                            'variable_start_string': '{%{',\n                            'variable_end_string': '}%}',\n                        }\n                    }\n                },\n                pytest.raises(NonTemplatedInputDirException),\n                None,\n            ),\n            (\"fake-repo-bad\", {}, pytest.raises(NonTemplatedInputDirException), None),\n        ],\n        ids=[\n            'template with default jinja strings',\n            'template with custom jinja strings',\n            'template with custom jinja strings but folder with default jinja strings',\n            'template missing folder',\n        ],\n    )\n    def test_find_template(repo_name, env, error_expectation, expected):\n        \"\"\"Verify correctness of `find.find_template` path detection.\"\"\"\n        repo_dir = Path('tests', repo_name)\n\n        with error_expectation:\n            template = find.find_template(repo_dir, env)\n\n&gt;           test_dir = Path(repo_dir, expected)\n\ntests/test_find.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/pathlib.py:960: in __new__\n    self = cls._from_parts(args)\n/usr/lib/python3.10/pathlib.py:594: in _from_parts\n    drv, root, parts = self._parse_args(args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = \nargs = (PosixPath('tests/fake-repo-pre'), None)\n\n    @classmethod\n    def _parse_args(cls, args):\n        # This is useful when you don't want to create an instance, just\n        # canonicalize some constructor arguments.\n        parts = []\n        for a in args:\n            if isinstance(a, PurePath):\n                parts += a._parts\n            else:\n&gt;               a = os.fspath(a)\nE               TypeError: expected str, bytes or os.PathLike object, not NoneType\n\n/usr/lib/python3.10/pathlib.py:578: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_generate_contextinput_params0-expected_context0","title":"test_generate_context.py::test_generate_context[input_params0-expected_context0]","text":"<pre>test_generate_context.py::test_generate_context[input_params0-expected_context0]</pre><pre>\ninput_params = {'context_file': 'tests/test-generate-context/test.json'}\nexpected_context = {'test': {'1': 2, 'some_key': 'some_val'}}\n\n    @pytest.mark.usefixtures('clean_system')\n    @pytest.mark.parametrize('input_params, expected_context', context_data())\n    def test_generate_context(input_params, expected_context):\n        \"\"\"Verify input contexts combinations result in expected content on output.\"\"\"\n&gt;       assert generate.generate_context(**input_params) == expected_context\nE       AssertionError: assert OrderedDict([('1', 2), ('some_key', 'some_val')]) == {'test': {'1': 2, 'some_key': 'some_val'}}\nE         \nE         Left contains 2 more items:\nE         {'1': 2, 'some_key': 'some_val'}\nE         Right contains 1 more item:\nE         {'test': {'1': 2, 'some_key': 'some_val'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         - {\nE         -     'test': {\nE         -         '1': 2,\nE         ? ----\nE         +     '1': 2,\nE         -         'some_key': 'some_val',\nE         ? ----\nE         +     'some_key': 'some_val',\nE         + })\nE         -     },\nE         - }\n\ntests/test_generate_context.py:58: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_generate_contextinput_params1-expected_context1","title":"test_generate_context.py::test_generate_context[input_params1-expected_context1]","text":"<pre>test_generate_context.py::test_generate_context[input_params1-expected_context1]</pre><pre>\ninput_params = {'context_file': 'tests/test-generate-context/test.json', 'default_context': {'1': 3}}\nexpected_context = {'test': {'1': 3, 'some_key': 'some_val'}}\n\n    @pytest.mark.usefixtures('clean_system')\n    @pytest.mark.parametrize('input_params, expected_context', context_data())\n    def test_generate_context(input_params, expected_context):\n        \"\"\"Verify input contexts combinations result in expected content on output.\"\"\"\n&gt;       assert generate.generate_context(**input_params) == expected_context\nE       AssertionError: assert OrderedDict([('1', '3'), ('some_key', 'some_val')]) == {'test': {'1': 3, 'some_key': 'some_val'}}\nE         \nE         Left contains 2 more items:\nE         {'1': '3', 'some_key': 'some_val'}\nE         Right contains 1 more item:\nE         {'test': {'1': 3, 'some_key': 'some_val'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         - {\nE         -     'test': {\nE         -         '1': 3,\nE         ? ----\nE         +     '1': '3',\nE         ?          + +\nE         -         'some_key': 'some_val',\nE         ? ----\nE         +     'some_key': 'some_val',\nE         + })\nE         -     },\nE         - }\n\ntests/test_generate_context.py:58: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_generate_contextinput_params2-expected_context2","title":"test_generate_context.py::test_generate_context[input_params2-expected_context2]","text":"<pre>test_generate_context.py::test_generate_context[input_params2-expected_context2]</pre><pre>\ninput_params = {'context_file': 'tests/test-generate-context/test.json', 'extra_context': {'1': 4}}\nexpected_context = {'test': {'1': 4, 'some_key': 'some_val'}}\n\n    @pytest.mark.usefixtures('clean_system')\n    @pytest.mark.parametrize('input_params, expected_context', context_data())\n    def test_generate_context(input_params, expected_context):\n        \"\"\"Verify input contexts combinations result in expected content on output.\"\"\"\n&gt;       assert generate.generate_context(**input_params) == expected_context\nE       AssertionError: assert OrderedDict([('1', '4'), ('some_key', 'some_val')]) == {'test': {'1': 4, 'some_key': 'some_val'}}\nE         \nE         Left contains 2 more items:\nE         {'1': '4', 'some_key': 'some_val'}\nE         Right contains 1 more item:\nE         {'test': {'1': 4, 'some_key': 'some_val'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         - {\nE         -     'test': {\nE         -         '1': 4,\nE         ? ----\nE         +     '1': '4',\nE         ?          + +\nE         -         'some_key': 'some_val',\nE         ? ----\nE         +     'some_key': 'some_val',\nE         + })\nE         -     },\nE         - }\n\ntests/test_generate_context.py:58: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_generate_contextinput_params3-expected_context3","title":"test_generate_context.py::test_generate_context[input_params3-expected_context3]","text":"<pre>test_generate_context.py::test_generate_context[input_params3-expected_context3]</pre><pre>\ninput_params = {'context_file': 'tests/test-generate-context/test.json', 'default_context': {'1': 3}, 'extra_context': {'1': 5}}\nexpected_context = {'test': {'1': 5, 'some_key': 'some_val'}}\n\n    @pytest.mark.usefixtures('clean_system')\n    @pytest.mark.parametrize('input_params, expected_context', context_data())\n    def test_generate_context(input_params, expected_context):\n        \"\"\"Verify input contexts combinations result in expected content on output.\"\"\"\n&gt;       assert generate.generate_context(**input_params) == expected_context\nE       AssertionError: assert OrderedDict([('1', '5'), ('some_key', 'some_val')]) == {'test': {'1': 5, 'some_key': 'some_val'}}\nE         \nE         Left contains 2 more items:\nE         {'1': '5', 'some_key': 'some_val'}\nE         Right contains 1 more item:\nE         {'test': {'1': 5, 'some_key': 'some_val'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         - {\nE         -     'test': {\nE         -         '1': 5,\nE         ? ----\nE         +     '1': '5',\nE         ?          + +\nE         -         'some_key': 'some_val',\nE         ? ----\nE         +     'some_key': 'some_val',\nE         + })\nE         -     },\nE         - }\n\ntests/test_generate_context.py:58: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_default_context_replacement_in_generate_context","title":"test_generate_context.py::test_default_context_replacement_in_generate_context","text":"<pre>test_generate_context.py::test_default_context_replacement_in_generate_context</pre><pre>\ndef test_default_context_replacement_in_generate_context():\n        \"\"\"Verify default content settings are correctly replaced by template settings.\n\n        Make sure that the default for list variables of `orientation` is based on\n        the user config (`choices_template.json`) and not changed to a single value\n        from `default_context`.\n        \"\"\"\n        expected_context = {\n            'choices_template': OrderedDict(\n                [\n                    ('full_name', 'Raphael Pierzina'),\n                    ('github_username', 'hackebrot'),\n                    ('project_name', 'Kivy Project'),\n                    ('repo_name', '{{cookiecutter.project_name|lower}}'),\n                    ('orientation', ['landscape', 'all', 'portrait']),\n                ]\n            )\n        }\n\n        generated_context = generate.generate_context(\n            context_file='tests/test-generate-context/choices_template.json',\n            default_context={\n                'not_in_template': 'foobar',\n                'project_name': 'Kivy Project',\n                'orientation': 'landscape',\n            },\n            extra_context={\n                'also_not_in_template': 'foobar2',\n                'github_username': 'hackebrot',\n            },\n        )\n\n&gt;       assert generated_context == expected_context\nE       AssertionError: assert OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', 'landscape'), ('not_in_template', 'foobar'), ('also_not_in_template', 'foobar2')]) == {'choices_template': OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['landscape', 'all', 'portrait'])])}\nE         \nE         Left contains 7 more items:\nE         {'also_not_in_template': 'foobar2',\nE          'full_name': 'Raphael Pierzina',\nE          'github_username': 'hackebrot',\nE          'not_in_template': 'foobar',\nE          'orientation': 'landscape',\nE          'project_name': 'Kivy Project',\nE          'repo_name': '{{cookiecutter.project_name|lower}}'}\nE         Right contains 1 more item:\nE         {'choices_template': OrderedDict([('full_name', 'Raphael Pierzina'),\nE                                           ('github_username', 'hackebrot'),\nE                                           ('project_name', 'Kivy Project'),\nE                                           ('repo_name',\nE                                            '{{cookiecutter.project_name|lower}}'),\nE                                           ('orientation',\nE                                            ['landscape', 'all', 'portrait'])])}\nE         \nE         Full diff:\nE         - {\nE         -     'choices_template': OrderedDict({\nE         + OrderedDict({\nE         +     'also_not_in_template': 'foobar2',\nE         -         'full_name': 'Raphael Pierzina',\nE         ? ----\nE         +     'full_name': 'Raphael Pierzina',\nE         -         'github_username': 'hackebrot',\nE         ? ----\nE         +     'github_username': 'hackebrot',\nE         +     'not_in_template': 'foobar',\nE         +     'orientation': 'landscape',\nE         -         'orientation': [\nE         -             'landscape',\nE         -             'all',\nE         -             'portrait',\nE         -         ],\nE         -         'project_name': 'Kivy Project',\nE         ? ----\nE         +     'project_name': 'Kivy Project',\nE         -         'repo_name': '{{cookiecutter.project_name|lower}}',\nE         ? ----\nE         +     'repo_name': '{{cookiecutter.project_name|lower}}',\nE         + })\nE         -     }),\nE         - }\n\ntests/test_generate_context.py:109: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_generate_context_decodes_non_ascii_chars","title":"test_generate_context.py::test_generate_context_decodes_non_ascii_chars","text":"<pre>test_generate_context.py::test_generate_context_decodes_non_ascii_chars</pre><pre>\ndef test_generate_context_decodes_non_ascii_chars():\n        \"\"\"Verify `generate_context` correctly decodes non-ascii chars.\"\"\"\n        expected_context = {\n            'non_ascii': OrderedDict(\n                [\n                    ('full_name', '\u00e9\u00e8\u00e0'),\n                ]\n            )\n        }\n\n        generated_context = generate.generate_context(\n            context_file='tests/test-generate-context/non_ascii.json'\n        )\n\n&gt;       assert generated_context == expected_context\nE       AssertionError: assert OrderedDict([('full_name', '\u00e9\u00e8\u00e0')]) == {'non_ascii': OrderedDict([('full_name', '\u00e9\u00e8\u00e0')])}\nE         \nE         Left contains 1 more item:\nE         {'full_name': '\u00e9\u00e8\u00e0'}\nE         Right contains 1 more item:\nE         {'non_ascii': OrderedDict([('full_name', '\u00e9\u00e8\u00e0')])}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         - {\nE         -     'non_ascii': OrderedDict({\nE         -         'full_name': '\u00e9\u00e8\u00e0',\nE         ? ----\nE         +     'full_name': '\u00e9\u00e8\u00e0',\nE         + })\nE         -     }),\nE         - }\n\ntests/test_generate_context.py:126: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_does_include_unused_variables","title":"test_generate_context.py::test_apply_overwrites_does_include_unused_variables","text":"<pre>test_generate_context.py::test_apply_overwrites_does_include_unused_variables</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']}), ('not in template', 'foobar')])\n\n    def test_apply_overwrites_does_include_unused_variables(template_context):\n        \"\"\"Verify `apply_overwrites_to_context` skips variables that are not in context.\"\"\"\n        generate.apply_overwrites_to_context(\n            context=template_context, overwrite_context={'not in template': 'foobar'}\n        )\n\n&gt;       assert 'not in template' not in template_context\nE       AssertionError: assert 'not in template' not in OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']}), ('not in template', 'foobar')])\n\ntests/test_generate_context.py:157: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_does_not_modify_choices_for_invalid_overwrite","title":"test_generate_context.py::test_apply_overwrites_does_not_modify_choices_for_invalid_overwrite","text":"<pre>test_generate_context.py::test_apply_overwrites_does_not_modify_choices_for_invalid_overwrite</pre><pre>\ndef test_apply_overwrites_does_not_modify_choices_for_invalid_overwrite():\n        \"\"\"Verify variables overwrite for list if variable not in list ignored.\"\"\"\n        expected_context = {\n            'choices_template': OrderedDict(\n                [\n                    ('full_name', 'Raphael Pierzina'),\n                    ('github_username', 'hackebrot'),\n                    ('project_name', 'Kivy Project'),\n                    ('repo_name', '{{cookiecutter.project_name|lower}}'),\n                    ('orientation', ['all', 'landscape', 'portrait']),\n                ]\n            )\n        }\n\n&gt;       with pytest.warns(UserWarning, match=\"Invalid default received\"):\nE       Failed: DID NOT WARN. No warnings of type (,) were emitted.\nE        Emitted warnings: [].\n\ntests/test_generate_context.py:183: Failed"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_invalid_overwrite","title":"test_generate_context.py::test_apply_overwrites_invalid_overwrite","text":"<pre>test_generate_context.py::test_apply_overwrites_invalid_overwrite</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', 'foobar'), ('deployment_regions', ['eu', 'us', 'ap']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']})])\n\n    def test_apply_overwrites_invalid_overwrite(template_context):\n        \"\"\"Verify variables overwrite for list if variable not in list not ignored.\"\"\"\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE \n\ntests/test_generate_context.py:202: Failed"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_sets_multichoice_values","title":"test_generate_context.py::test_apply_overwrites_sets_multichoice_values","text":"<pre>test_generate_context.py::test_apply_overwrites_sets_multichoice_values</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap', 'eu']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']})])\n\n    def test_apply_overwrites_sets_multichoice_values(template_context):\n        \"\"\"Verify variable overwrite for list given multiple valid values.\"\"\"\n        generate.apply_overwrites_to_context(\n            context=template_context,\n            overwrite_context={'deployment_regions': ['eu']},\n        )\n&gt;       assert template_context['deployment_regions'] == ['eu']\nE       AssertionError: assert ['eu', 'us', 'ap', 'eu'] == ['eu']\nE         \nE         Left contains 3 more items, first extra item: 'us'\nE         \nE         Full diff:\nE           [\nE               'eu',\nE         +     'us',\nE         +     'ap',\nE         +     'eu',\nE           ]\n\ntests/test_generate_context.py:214: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_invalid_multichoice_values","title":"test_generate_context.py::test_apply_overwrites_invalid_multichoice_values","text":"<pre>test_generate_context.py::test_apply_overwrites_invalid_multichoice_values</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap', 'na']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']})])\n\n    def test_apply_overwrites_invalid_multichoice_values(template_context):\n        \"\"\"Verify variable overwrite for list given invalid list entries not ignored.\"\"\"\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE \n\ntests/test_generate_context.py:219: Failed"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_error_additional_values","title":"test_generate_context.py::test_apply_overwrites_error_additional_values","text":"<pre>test_generate_context.py::test_apply_overwrites_error_additional_values</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap', 'eu', 'na']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']})])\n\n    def test_apply_overwrites_error_additional_values(template_context):\n        \"\"\"Verify variable overwrite for list given additional entries not ignored.\"\"\"\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE \n\ntests/test_generate_context.py:228: Failed"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_in_dictionaries","title":"test_generate_context.py::test_apply_overwrites_in_dictionaries","text":"<pre>test_generate_context.py::test_apply_overwrites_in_dictionaries</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait']), ('deployment_regions', ['eu', 'us', 'ap']), ('deployments', {'preprod': ['eu', 'us', 'ap', 'eu'], 'prod': ['eu', 'us', 'ap', 'ap']})])\n\n    def test_apply_overwrites_in_dictionaries(template_context):\n        \"\"\"Verify variable overwrite for lists nested in dictionary variables.\"\"\"\n        generate.apply_overwrites_to_context(\n            context=template_context,\n            overwrite_context={'deployments': {'preprod': ['eu'], 'prod': ['ap']}},\n        )\n&gt;       assert template_context['deployments']['preprod'] == ['eu']\nE       AssertionError: assert ['eu', 'us', 'ap', 'eu'] == ['eu']\nE         \nE         Left contains 3 more items, first extra item: 'us'\nE         \nE         Full diff:\nE           [\nE               'eu',\nE         +     'us',\nE         +     'ap',\nE         +     'eu',\nE           ]\n\ntests/test_generate_context.py:241: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_sets_default_for_choice_variable","title":"test_generate_context.py::test_apply_overwrites_sets_default_for_choice_variable","text":"<pre>test_generate_context.py::test_apply_overwrites_sets_default_for_choice_variable</pre><pre>\ntemplate_context = OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project_name', 'Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', 'landscape'), ('deployment_regions', ['eu', 'us', 'ap']), ('deployments', {'preprod': ['eu', 'us', 'ap'], 'prod': ['eu', 'us', 'ap']})])\n\n    def test_apply_overwrites_sets_default_for_choice_variable(template_context):\n        \"\"\"Verify overwritten list member became a default value.\"\"\"\n        generate.apply_overwrites_to_context(\n            context=template_context, overwrite_context={'orientation': 'landscape'}\n        )\n\n&gt;       assert template_context['orientation'] == ['landscape', 'all', 'portrait']\nE       AssertionError: assert 'landscape' == ['landscape', 'all', 'portrait']\n\ntests/test_generate_context.py:251: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_in_nested_dict","title":"test_generate_context.py::test_apply_overwrites_in_nested_dict","text":"<pre>test_generate_context.py::test_apply_overwrites_in_nested_dict</pre><pre>\ndef test_apply_overwrites_in_nested_dict():\n        \"\"\"Verify nested dict in default content settings are correctly replaced.\"\"\"\n        expected_context = {\n            'nested_dict': OrderedDict(\n                [\n                    ('full_name', 'Raphael Pierzina'),\n                    ('github_username', 'hackebrot'),\n                    (\n                        'project',\n                        OrderedDict(\n                            [\n                                ('name', 'My Kivy Project'),\n                                ('description', 'My Kivy Project'),\n                                ('repo_name', '{{cookiecutter.project_name|lower}}'),\n                                ('orientation', [\"all\", \"landscape\", \"portrait\"]),\n                            ]\n                        ),\n                    ),\n                ]\n            )\n        }\n\n        generated_context = generate.generate_context(\n            context_file='tests/test-generate-context/nested_dict.json',\n            default_context={\n                'not_in_template': 'foobar',\n                'project': {\n                    'description': 'My Kivy Project',\n                },\n            },\n            extra_context={\n                'also_not_in_template': 'foobar2',\n                'github_username': 'hackebrot',\n                'project': {\n                    'name': 'My Kivy Project',\n                },\n            },\n        )\n\n&gt;       assert generated_context == expected_context\nE       AssertionError: assert OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project', OrderedDict([('name', 'My Kivy Project'), ('description', 'My Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait'])])), ('not_in_template', 'foobar'), ('also_not_in_template', 'foobar2')]) == {'nested_dict': OrderedDict([('full_name', 'Raphael Pierzina'), ('github_username', 'hackebrot'), ('project', OrderedDict([('name', 'My Kivy Project'), ('description', 'My Kivy Project'), ('repo_name', '{{cookiecutter.project_name|lower}}'), ('orientation', ['all', 'landscape', 'portrait'])]))])}\nE         \nE         Left contains 5 more items:\nE         {'also_not_in_template': 'foobar2',\nE          'full_name': 'Raphael Pierzina',\nE          'github_username': 'hackebrot',\nE          'not_in_template': 'foobar',\nE          'project': OrderedDict([('name', 'My Kivy Project'),\nE                                  ('description', 'My Kivy Project'),\nE                                  ('repo_name', '{{cookiecutter.project_name|lower}}'),\nE                                  ('orientation', ['all', 'landscape', 'portrait'])])}\nE         Right contains 1 more item:\nE         {'nested_dict': OrderedDict([('full_name', 'Raphael Pierzina'),\nE                                      ('github_username', 'hackebrot'),\nE                                      ('project',\nE                                       OrderedDict([('name', 'My Kivy Project'),\nE                                                    ('description', 'My Kivy Project'),\nE                                                    ('repo_name',\nE                                                     '{{cookiecutter.project_name|lower}}'),\nE                                                    ('orientation',\nE                                                     ['all',\nE                                                      'landscape',\nE                                                      'portrait'])]))])}\nE         \nE         Full diff:\nE         - {\nE         -     'nested_dict': OrderedDict({\nE         + OrderedDict({\nE         +     'also_not_in_template': 'foobar2',\nE         -         'full_name': 'Raphael Pierzina',\nE         ? ----\nE         +     'full_name': 'Raphael Pierzina',\nE         -         'github_username': 'hackebrot',\nE         ? ----\nE         +     'github_username': 'hackebrot',\nE         +     'not_in_template': 'foobar',\nE         -         'project': OrderedDict({\nE         ? ----\nE         +     'project': OrderedDict({\nE         -             'description': 'My Kivy Project',\nE         ? ----\nE         +         'description': 'My Kivy Project',\nE         -             'name': 'My Kivy Project',\nE         ? ----\nE         +         'name': 'My Kivy Project',\nE         -             'orientation': [\nE         ? ----\nE         +         'orientation': [\nE         -                 'all',\nE         ? ----\nE         +             'all',\nE         -                 'landscape',\nE         ? ----\nE         +             'landscape',\nE         -                 'portrait',\nE         ? ----\nE         +             'portrait',\nE         -             ],\nE         ? ----\nE         +         ],\nE         -             'repo_name': '{{cookiecutter.project_name|lower}}',\nE         ? ----\nE         +         'repo_name': '{{cookiecutter.project_name|lower}}',\nE         -         }),\nE               }),\nE         - }\nE         + })\n\ntests/test_generate_context.py:293: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_contextpytest_apply_overwrites_in_nested_dict_additional_values","title":"test_generate_context.py::test_apply_overwrites_in_nested_dict_additional_values","text":"<pre>test_generate_context.py::test_apply_overwrites_in_nested_dict_additional_values</pre><pre>\ndef test_apply_overwrites_in_nested_dict_additional_values():\n        \"\"\"Verify nested dict in default content settings are correctly added.\"\"\"\n        expected_context = {\n            'nested_dict_additional': OrderedDict(\n                [\n                    ('mainkey1', 'mainvalue1'),\n                    (\n                        'mainkey2',\n                        OrderedDict(\n                            [\n                                ('subkey1', 'subvalue1'),\n                                (\n                                    'subkey2',\n                                    OrderedDict(\n                                        [\n                                            ('subsubkey1', 'subsubvalue1'),\n                                            ('subsubkey2', 'subsubvalue2_default'),\n                                            ('subsubkey3', 'subsubvalue3_extra'),\n                                        ]\n                                    ),\n                                ),\n                                ('subkey4', 'subvalue4_default'),\n                                ('subkey5', 'subvalue5_extra'),\n                            ]\n                        ),\n                    ),\n                ]\n            )\n        }\n\n        generated_context = generate.generate_context(\n            context_file='tests/test-generate-context/nested_dict_additional.json',\n            default_context={\n                'not_in_template': 'foobar',\n                'mainkey2': {\n                    'subkey2': {\n                        'subsubkey2': 'subsubvalue2_default',\n                    },\n                    'subkey4': 'subvalue4_default',\n                },\n            },\n            extra_context={\n                'also_not_in_template': 'foobar2',\n                'mainkey2': {\n                    'subkey2': {\n                        'subsubkey3': 'subsubvalue3_extra',\n                    },\n                    'subkey5': 'subvalue5_extra',\n                },\n            },\n        )\n\n&gt;       assert generated_context == expected_context\nE       AssertionError: assert OrderedDict([('mainkey1', 'mainvalue1'), ('mainkey2', OrderedDict([('subkey1', 'subvalue1'), ('subkey2', OrderedDict([('subsubkey1', 'subsubvalue1'), ('subsubkey2', 'subsubvalue2_default'), ('subsubkey3', 'subsubvalue3_extra')])), ('subkey4', 'subvalue4_default'), ('subkey5', 'subvalue5_extra')])), ('not_in_template', 'foobar'), ('also_not_in_template', 'foobar2')]) == {'nested_dict_additional': OrderedDict([('mainkey1', 'mainvalue1'), ('mainkey2', OrderedDict([('subkey1', 'subvalue1'), ('subkey2', OrderedDict([('subsubkey1', 'subsubvalue1'), ('subsubkey2', 'subsubvalue2_default'), ('subsubkey3', 'subsubvalue3_extra')])), ('subkey4', 'subvalue4_default'), ('subkey5', 'subvalue5_extra')]))])}\nE         \nE         Left contains 4 more items:\nE         {'also_not_in_template': 'foobar2',\nE          'mainkey1': 'mainvalue1',\nE          'mainkey2': OrderedDict([('subkey1', 'subvalue1'),\nE                                   ('subkey2',\nE                                    OrderedDict([('subsubkey1', 'subsubvalue1'),\nE                                                 ('subsubkey2', 'subsubvalue2_default'),\nE                                                 ('subsubkey3', 'subsubvalue3_extra')])),\nE                                   ('subkey4', 'subvalue4_default'),\nE                                   ('subkey5', 'subvalue5_extra')]),\nE          'not_in_template': 'foobar'}\nE         Right contains 1 more item:\nE         {'nested_dict_additional': OrderedDict([('mainkey1', 'mainvalue1'),\nE                                                 ('mainkey2',\nE                                                  OrderedDict([('subkey1', 'subvalue1'),\nE                                                               ('subkey2',\nE                                                                OrderedDict([('subsubkey1',\nE                                                                              'subsubvalue1'),\nE                                                                             ('subsubkey2',\nE                                                                              'subsubvalue2_default'),\nE                                                                             ('subsubkey3',\nE                                                                              'subsubvalue3_extra')])),\nE                                                               ('subkey4',\nE                                                                'subvalue4_default'),\nE                                                               ('subkey5',\nE                                                                'subvalue5_extra')]))])}\nE         \nE         Full diff:\nE         - {\nE         -     'nested_dict_additional': OrderedDict({\nE         + OrderedDict({\nE         +     'also_not_in_template': 'foobar2',\nE         -         'mainkey1': 'mainvalue1',\nE         ? ----\nE         +     'mainkey1': 'mainvalue1',\nE         -         'mainkey2': OrderedDict({\nE         ? ----\nE         +     'mainkey2': OrderedDict({\nE         -             'subkey1': 'subvalue1',\nE         ? ----\nE         +         'subkey1': 'subvalue1',\nE         -             'subkey2': OrderedDict({\nE         ? ----\nE         +         'subkey2': OrderedDict({\nE         -                 'subsubkey1': 'subsubvalue1',\nE         ? ----\nE         +             'subsubkey1': 'subsubvalue1',\nE         -                 'subsubkey2': 'subsubvalue2_default',\nE         ? ----\nE         +             'subsubkey2': 'subsubvalue2_default',\nE         -                 'subsubkey3': 'subsubvalue3_extra',\nE         ? ----\nE         +             'subsubkey3': 'subsubvalue3_extra',\nE         -             }),\nE         -             'subkey4': 'subvalue4_default',\nE         -             'subkey5': 'subvalue5_extra',\nE                   }),\nE         +         'subkey4': 'subvalue4_default',\nE         +         'subkey5': 'subvalue5_extra',\nE               }),\nE         - }\nE         +     'not_in_template': 'foobar',\nE         + })\n\ntests/test_generate_context.py:364: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_copy_without_renderpytest_generate_copy_without_render_extensions","title":"test_generate_copy_without_render.py::test_generate_copy_without_render_extensions","text":"<pre>test_generate_copy_without_render.py::test_generate_copy_without_render_extensions</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_test_dir')\n    def test_generate_copy_without_render_extensions():\n        \"\"\"Verify correct work of `_copy_without_render` context option.\n\n        Some files/directories should be rendered during invocation,\n        some just copied, without any modification.\n        \"\"\"\n&gt;       generate.generate_files(\n            context={\n                'cookiecutter': {\n                    'repo_name': 'test_copy_without_render',\n                    'render_test': 'I have been rendered!',\n                    '_copy_without_render': [\n                        '*not-rendered',\n                        'rendered/not_rendered.yml',\n                        '*.txt',\n                        '{{cookiecutter.repo_name}}-rendered/README.md',\n                    ],\n                }\n            },\n            repo_dir='tests/test-generate-copy-without-render',\n        )\n\ntests/test_generate_copy_without_render.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-copy-without-render'\ncontext = {'cookiecutter': {'_copy_without_render': ['*not-rendered', 'rendered/not_rendered.yml', '*.txt', '{{cookiecutter.repo_name}}-rendered/README.md'], 'render_test': 'I have been rendered!', 'repo_name': 'test_copy_without_render'}}\noutput_dir = '.', overwrite_if_exists = False, skip_if_file_exists = False\naccept_hooks = True, keep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_copy_without_render_overridepytest_generate_copy_without_render_extensions","title":"test_generate_copy_without_render_override.py::test_generate_copy_without_render_extensions","text":"<pre>test_generate_copy_without_render_override.py::test_generate_copy_without_render_extensions</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_test_dir')\n    def test_generate_copy_without_render_extensions():\n        \"\"\"Verify correct work of `_copy_without_render` context option.\n\n        Some files/directories should be rendered during invocation,\n        some just copied, without any modification.\n        \"\"\"\n        # first run\n&gt;       generate.generate_files(\n            context={\n                'cookiecutter': {\n                    'repo_name': 'test_copy_without_render',\n                    'render_test': 'I have been rendered!',\n                    '_copy_without_render': [\n                        '*not-rendered',\n                        'rendered/not_rendered.yml',\n                        '*.txt',\n                        '{{cookiecutter.repo_name}}-rendered/README.md',\n                    ],\n                }\n            },\n            repo_dir='tests/test-generate-copy-without-render-override',\n        )\n\ntests/test_generate_copy_without_render_override.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-copy-without-render-override'\ncontext = {'cookiecutter': {'_copy_without_render': ['*not-rendered', 'rendered/not_rendered.yml', '*.txt', '{{cookiecutter.repo_name}}-rendered/README.md'], 'render_test': 'I have been rendered!', 'repo_name': 'test_copy_without_render'}}\noutput_dir = '.', overwrite_if_exists = False, skip_if_file_exists = False\naccept_hooks = True, keep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filepytest_generate_file_with_false_condition","title":"test_generate_file.py::test_generate_file_with_false_condition","text":"<pre>test_generate_file.py::test_generate_file_with_false_condition</pre><pre>\nenv = \n\n    def test_generate_file_with_false_condition(env):\n        \"\"\"Verify correct work of boolean condition in file name on file generation.\n\n        This test has negative answer, so file should not be rendered.\n        \"\"\"\n        infile = (\n            'tests/files/{% if cookiecutter.generate_file == \\'y\\' %}cheese.txt{% endif %}'\n        )\n&gt;       generate.generate_file(\n            project_dir=\".\",\n            infile=infile,\n            context={'cookiecutter': {'generate_file': 'n'}},\n            env=env,\n        )\n\ntests/test_generate_file.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nproject_dir = '.'\ninfile = \"tests/files/{% if cookiecutter.generate_file == 'y' %}cheese.txt{% endif %}\"\ncontext = {'cookiecutter': {'generate_file': 'n'}}\nenv = \nskip_if_file_exists = False\n\n    def generate_file(project_dir, infile, context, env, skip_if_file_exists=False\n        ):\n        \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n        Dealing with infile appropriately:\n\n            a. If infile is a binary file, copy it over without rendering.\n            b. If infile is a text file, render its contents and write the\n               rendered infile to outfile.\n\n        Precondition:\n\n            When calling `generate_file()`, the root template dir must be the\n            current working directory. Using `utils.work_in()` is the recommended\n            way to perform this directory change.\n\n        :param project_dir: Absolute path to the resulting generated project.\n        :param infile: Input file to generate the file from. Relative to the root\n            template dir.\n        :param context: Dict for populating the cookiecutter's variables.\n        :param env: Jinja2 template execution environment.\n        \"\"\"\n        logger.debug('Generating file %s', infile)\n\n        # Render the path to the output file\n        outfile_tmpl = env.from_string(infile)\n        outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n\n        # Ensure output directory exists\n        dirname = os.path.dirname(outfile)\n        make_sure_path_exists(dirname)\n\n        # Skip if file exists and skip_if_file_exists is True\n        if skip_if_file_exists and os.path.exists(outfile):\n            logger.debug('File %s already exists, skipping', outfile)\n            return False\n\n        # Check if infile is binary\n        if is_binary(infile):\n            logger.debug(\"Copying binary %s to %s without rendering\", infile, outfile)\n            shutil.copyfile(infile, outfile)\n        else:\n            # Render the file\n            try:\n                with open(infile, 'r') as in_file:\n                    tmpl = env.from_string(in_file.read())\n                rendered_file = tmpl.render(**context)\n&gt;               with open(outfile, 'w') as out_file:\nE               IsADirectoryError: [Errno 21] Is a directory: './tests/files/'\n\ncookiecutter/generate.py:133: IsADirectoryError"},{"location":"analysis_baseline_cookiecutter/#test_generate_filepytest_generate_file_verbose_template_syntax_error","title":"test_generate_file.py::test_generate_file_verbose_template_syntax_error","text":"<pre>test_generate_file.py::test_generate_file_verbose_template_syntax_error</pre><pre>\nenv = \nexpected_msg_regex = re.compile('Missing end of comment tag\\n {2}File \"(.[/\\\\\\\\])*tests[/\\\\\\\\]files[/\\\\\\\\]syntax_error.txt\", line 1\\n {4}I eat {{ syntax_error }} {# this comment is not closed}')\n\n    def test_generate_file_verbose_template_syntax_error(env, expected_msg_regex):\n        \"\"\"Verify correct exception raised on syntax error in file before generation.\"\"\"\n        with pytest.raises(TemplateSyntaxError) as exception:\n            generate.generate_file(\n                project_dir=\".\",\n                infile='tests/files/syntax_error.txt',\n                context={'syntax_error': 'syntax_error'},\n                env=env,\n            )\n&gt;       assert expected_msg_regex.match(str(exception.value))\nE       assert None\nE        +  where None = ('Missing end of comment tag')\nE        +    where  = re.compile('Missing end of comment tag\\n {2}File \"(.[/\\\\\\\\])*tests[/\\\\\\\\]files[/\\\\\\\\]syntax_error.txt\", line 1\\n {4}I eat {{ syntax_error }} {# this comment is not closed}').match\nE        +    and   'Missing end of comment tag' = str(TemplateSyntaxError('Missing end of comment tag'))\nE        +      where TemplateSyntaxError('Missing end of comment tag') = .value\n\ntests/test_generate_file.py:138: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_generate_filepytest_generate_file_does_not_translate_crlf_newlines_to_lf","title":"test_generate_file.py::test_generate_file_does_not_translate_crlf_newlines_to_lf","text":"<pre>test_generate_file.py::test_generate_file_does_not_translate_crlf_newlines_to_lf</pre><pre>\nenv = \n\n    def test_generate_file_does_not_translate_crlf_newlines_to_lf(env):\n        \"\"\"Verify that file generation use same line ending, as in source file.\"\"\"\n        infile = 'tests/files/{{cookiecutter.generate_file}}_crlf_newlines.txt'\n        generate.generate_file(\n            project_dir=\".\",\n            infile=infile,\n            context={'cookiecutter': {'generate_file': 'cheese'}},\n            env=env,\n        )\n\n        # this generated file should have a CRLF line ending\n        gf = 'tests/files/cheese_crlf_newlines.txt'\n        with Path(gf).open(encoding='utf-8', newline='') as f:\n            simple_text = f.readline()\n&gt;       assert simple_text == 'newline is CRLF\\r\\n'\nE       AssertionError: assert 'newline is CRLF\\n' == 'newline is CRLF\\r\\n'\nE         \nE         - newline is CRLF\nE         ?                -\nE         + newline is CRLF\n\ntests/test_generate_file.py:173: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_nontemplated_exception","title":"test_generate_files.py::test_generate_files_nontemplated_exception","text":"<pre>test_generate_files.py::test_generate_files_nontemplated_exception</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_nontemplat0')\n\n    def test_generate_files_nontemplated_exception(tmp_path):\n        \"\"\"\n        Verify `generate_files` raises when no directories to render exist.\n\n        Note: Check `tests/test-generate-files-nontemplated` location to understand.\n        \"\"\"\n        with pytest.raises(exceptions.NonTemplatedInputDirException):\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'food': 'pizza'}},\n                repo_dir='tests/test-generate-files-nontemplated',\n                output_dir=tmp_path,\n            )\n\ntests/test_generate_files.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files-nontemplated'\ncontext = {'cookiecutter': {'food': 'pizza'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_nontemplat0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files","title":"test_generate_files.py::test_generate_files","text":"<pre>test_generate_files.py::test_generate_files</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files0')\n\n    def test_generate_files(tmp_path):\n        \"\"\"Verify directory name correctly rendered with unicode containing context.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_linux_newline","title":"test_generate_files.py::test_generate_files_with_linux_newline","text":"<pre>test_generate_files.py::test_generate_files_with_linux_newline</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_linux0')\n\n    def test_generate_files_with_linux_newline(tmp_path):\n        \"\"\"Verify new line not removed by templating engine after folder generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_linux0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_jinja2_environment","title":"test_generate_files.py::test_generate_files_with_jinja2_environment","text":"<pre>test_generate_files.py::test_generate_files_with_jinja2_environment</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_jinja0')\n\n    def test_generate_files_with_jinja2_environment(tmp_path):\n        \"\"\"Extend StrictEnvironment with _jinja2_env_vars cookiecutter template option.\"\"\"\n&gt;       generate.generate_files(\n            context={\n                'cookiecutter': {\n                    'food': 'pizz\u00e4',\n                    '_jinja2_env_vars': {'lstrip_blocks': True, 'trim_blocks': True},\n                }\n            },\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'_jinja2_env_vars': {'lstrip_blocks': True, 'trim_blocks': True}, 'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_jinja0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_trailing_newline_forced_to_linux_by_context","title":"test_generate_files.py::test_generate_files_with_trailing_newline_forced_to_linux_by_context","text":"<pre>test_generate_files.py::test_generate_files_with_trailing_newline_forced_to_linux_by_context</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_trail0')\n\n    def test_generate_files_with_trailing_newline_forced_to_linux_by_context(tmp_path):\n        \"\"\"Verify new line not removed by templating engine after folder generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4', '_new_lines': '\\r\\n'}},\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'_new_lines': '\\r\\n', 'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_trail0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_windows_newline","title":"test_generate_files.py::test_generate_files_with_windows_newline","text":"<pre>test_generate_files.py::test_generate_files_with_windows_newline</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_windo0')\n\n    def test_generate_files_with_windows_newline(tmp_path):\n        \"\"\"Verify windows source line end not changed during files generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_windo0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_windows_newline_forced_to_linux_by_context","title":"test_generate_files.py::test_generate_files_with_windows_newline_forced_to_linux_by_context","text":"<pre>test_generate_files.py::test_generate_files_with_windows_newline_forced_to_linux_by_context</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_windo1')\n\n    def test_generate_files_with_windows_newline_forced_to_linux_by_context(tmp_path):\n        \"\"\"Verify windows line end changed to linux during files generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4', '_new_lines': '\\n'}},\n            repo_dir='tests/test-generate-files',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'_new_lines': '\\n', 'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_windo1')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_binaries","title":"test_generate_files.py::test_generate_files_binaries","text":"<pre>test_generate_files.py::test_generate_files_binaries</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_binaries0')\n\n    def test_generate_files_binaries(tmp_path):\n        \"\"\"Verify binary files created during directory generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'binary_test': 'binary_files'}},\n            repo_dir='tests/test-generate-binaries',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:142: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-binaries'\ncontext = {'cookiecutter': {'binary_test': 'binary_files'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_binaries0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_absolute_path","title":"test_generate_files.py::test_generate_files_absolute_path","text":"<pre>test_generate_files.py::test_generate_files_absolute_path</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_absolute_p0')\n\n    def test_generate_files_absolute_path(tmp_path):\n        \"\"\"Verify usage of absolute path does not change files generation behaviour.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir=Path('tests/test-generate-files').absolute(),\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = PosixPath('/testbed/tests/test-generate-files')\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_absolute_p0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_output_dir","title":"test_generate_files.py::test_generate_files_output_dir","text":"<pre>test_generate_files.py::test_generate_files_output_dir</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_output_dir0')\n\n    def test_generate_files_output_dir(tmp_path):\n        \"\"\"Verify `output_dir` option for `generate_files` changing location correctly.\"\"\"\n        output_dir = Path(tmp_path, 'custom_output_dir')\n        output_dir.mkdir()\n\n&gt;       project_dir = generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir=Path('tests/test-generate-files').absolute(),\n            output_dir=output_dir,\n        )\n\ntests/test_generate_files.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = PosixPath('/testbed/tests/test-generate-files')\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_output_dir0/custom_output_dir')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_permissions","title":"test_generate_files.py::test_generate_files_permissions","text":"<pre>test_generate_files.py::test_generate_files_permissions</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_permission0')\n\n    def test_generate_files_permissions(tmp_path):\n        \"\"\"Verify generates files respect source files permissions.\n\n        simple.txt and script.sh should retain their respective 0o644 and 0o755\n        permissions.\n        \"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'permissions': 'permissions'}},\n            repo_dir='tests/test-generate-files-permissions',\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:193: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files-permissions'\ncontext = {'cookiecutter': {'permissions': 'permissions'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_permission0')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_overwrite_if_exists_with_skip_if_file_exists","title":"test_generate_files.py::test_generate_files_with_overwrite_if_exists_with_skip_if_file_exists","text":"<pre>test_generate_files.py::test_generate_files_with_overwrite_if_exists_with_skip_if_file_exists</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_overw0')\n\n    def test_generate_files_with_overwrite_if_exists_with_skip_if_file_exists(tmp_path):\n        \"\"\"Verify `skip_if_file_exist` has priority over `overwrite_if_exists`.\"\"\"\n        simple_file = Path(tmp_path, 'inputpizz\u00e4/simple.txt')\n        simple_with_new_line_file = Path(tmp_path, 'inputpizz\u00e4/simple-with-newline.txt')\n\n        Path(tmp_path, 'inputpizz\u00e4').mkdir(parents=True)\n        with Path(simple_file).open('w') as f:\n            f.write('temp')\n\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir='tests/test-generate-files',\n            overwrite_if_exists=True,\n            skip_if_file_exists=True,\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:240: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_overw0')\noverwrite_if_exists = True, skip_if_file_exists = True, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_skip_if_file_exists","title":"test_generate_files.py::test_generate_files_with_skip_if_file_exists","text":"<pre>test_generate_files.py::test_generate_files_with_skip_if_file_exists</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_skip_0')\n\n    def test_generate_files_with_skip_if_file_exists(tmp_path):\n        \"\"\"Verify existed files not removed if error raised with `skip_if_file_exists`.\"\"\"\n        simple_file = Path(tmp_path, 'inputpizz\u00e4/simple.txt')\n        simple_with_new_line_file = Path(tmp_path, 'inputpizz\u00e4/simple-with-newline.txt')\n\n        Path(tmp_path, 'inputpizz\u00e4').mkdir(parents=True)\n        Path(simple_file).write_text('temp')\n\n        with pytest.raises(exceptions.OutputDirExistsException):\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'food': 'pizz\u00e4'}},\n                repo_dir='tests/test-generate-files',\n                skip_if_file_exists=True,\n                output_dir=tmp_path,\n            )\n\ntests/test_generate_files.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_skip_0')\noverwrite_if_exists = False, skip_if_file_exists = True, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_generate_files_with_overwrite_if_exists","title":"test_generate_files.py::test_generate_files_with_overwrite_if_exists","text":"<pre>test_generate_files.py::test_generate_files_with_overwrite_if_exists</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_overw1')\n\n    def test_generate_files_with_overwrite_if_exists(tmp_path):\n        \"\"\"Verify overwrite_if_exists overwrites old files.\"\"\"\n        simple_file = Path(tmp_path, 'inputpizz\u00e4/simple.txt')\n        simple_with_new_line_file = Path(tmp_path, 'inputpizz\u00e4/simple-with-newline.txt')\n\n        Path(tmp_path, 'inputpizz\u00e4').mkdir(parents=True)\n        Path(simple_file).write_text('temp')\n\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'food': 'pizz\u00e4'}},\n            repo_dir='tests/test-generate-files',\n            overwrite_if_exists=True,\n            output_dir=tmp_path,\n        )\n\ntests/test_generate_files.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-generate-files'\ncontext = {'cookiecutter': {'food': 'pizz\u00e4'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_generate_files_with_overw1')\noverwrite_if_exists = True, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_file_name","title":"test_generate_files.py::test_raise_undefined_variable_file_name","text":"<pre>test_generate_files.py::test_raise_undefined_variable_file_name</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_0/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_raise_undefined_variable_file_name(output_dir, undefined_context):\n        \"\"\"Verify correct error raised when file name cannot be rendered.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/file-name/',\n                output_dir=output_dir,\n                context=undefined_context,\n            )\n\ntests/test_generate_files.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/file-name/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_0/output'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_file_name_existing_project","title":"test_generate_files.py::test_raise_undefined_variable_file_name_existing_project","text":"<pre>test_generate_files.py::test_raise_undefined_variable_file_name_existing_project</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_1/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_raise_undefined_variable_file_name_existing_project(\n        output_dir, undefined_context\n    ):\n        \"\"\"Verify correct error raised when file name cannot be rendered.\"\"\"\n        testproj_path = Path(output_dir, 'testproject')\n        testproj_path.mkdir()\n\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/file-name/',\n                output_dir=output_dir,\n                context=undefined_context,\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_files.py:336: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/file-name/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_1/output'\noverwrite_if_exists = True, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_file_content","title":"test_generate_files.py::test_raise_undefined_variable_file_content","text":"<pre>test_generate_files.py::test_raise_undefined_variable_file_content</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_2/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_raise_undefined_variable_file_content(output_dir, undefined_context):\n        \"\"\"Verify correct error raised when file content cannot be rendered.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/file-content/',\n                output_dir=output_dir,\n                context=undefined_context,\n            )\n\ntests/test_generate_files.py:352: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/file-content/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_2/output'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_dir_name","title":"test_generate_files.py::test_raise_undefined_variable_dir_name","text":"<pre>test_generate_files.py::test_raise_undefined_variable_dir_name</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_3/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_raise_undefined_variable_dir_name(output_dir, undefined_context):\n        \"\"\"Verify correct error raised when directory name cannot be rendered.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/dir-name/',\n                output_dir=output_dir,\n                context=undefined_context,\n            )\n\ntests/test_generate_files.py:367: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/dir-name/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_3/output'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_keep_project_dir_on_failure","title":"test_generate_files.py::test_keep_project_dir_on_failure","text":"<pre>test_generate_files.py::test_keep_project_dir_on_failure</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_keep_project_dir_on_failu0/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_keep_project_dir_on_failure(output_dir, undefined_context):\n        \"\"\"Verify correct error raised when directory name cannot be rendered.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate):\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/dir-name/',\n                output_dir=output_dir,\n                context=undefined_context,\n                keep_project_on_failure=True,\n            )\n\ntests/test_generate_files.py:386: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/dir-name/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_keep_project_dir_on_failu0/output'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = True\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_dir_name_existing_project","title":"test_generate_files.py::test_raise_undefined_variable_dir_name_existing_project","text":"<pre>test_generate_files.py::test_raise_undefined_variable_dir_name_existing_project</pre><pre>\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_4/output'\nundefined_context = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\n\n    def test_raise_undefined_variable_dir_name_existing_project(\n        output_dir, undefined_context\n    ):\n        \"\"\"Verify correct error raised when directory name cannot be rendered.\"\"\"\n        testproj_path = Path(output_dir, 'testproject')\n        testproj_path.mkdir()\n\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/dir-name/',\n                output_dir=output_dir,\n                context=undefined_context,\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_files.py:403: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/dir-name/'\ncontext = {'cookiecutter': {'github_username': 'hackebrot', 'project_slug': 'testproject'}}\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_4/output'\noverwrite_if_exists = True, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_filespytest_raise_undefined_variable_project_dir","title":"test_generate_files.py::test_raise_undefined_variable_project_dir","text":"<pre>test_generate_files.py::test_raise_undefined_variable_project_dir</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_5')\n\n    def test_raise_undefined_variable_project_dir(tmp_path):\n        \"\"\"Verify correct error raised when directory name cannot be rendered.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n&gt;           generate.generate_files(\n                repo_dir='tests/undefined-variable/dir-name/',\n                output_dir=tmp_path,\n                context={},\n            )\n\ntests/test_generate_files.py:423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/undefined-variable/dir-name/', context = {}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_raise_undefined_variable_5')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_ignore_hooks_dirs","title":"test_generate_hooks.py::test_ignore_hooks_dirs","text":"<pre>test_generate_hooks.py::test_ignore_hooks_dirs</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_ignore_hooks_dirs():\n        \"\"\"Verify hooks directory not created in target location on files generation.\"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'pyhooks': 'pyhooks'}},\n            repo_dir='tests/test-pyhooks/',\n            output_dir='tests/test-pyhooks/',\n        )\n\ntests/test_generate_hooks.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyhooks/'\ncontext = {'cookiecutter': {'pyhooks': 'pyhooks'}}\noutput_dir = 'tests/test-pyhooks/', overwrite_if_exists = False\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_python_hooks","title":"test_generate_hooks.py::test_run_python_hooks","text":"<pre>test_generate_hooks.py::test_run_python_hooks</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_run_python_hooks():\n        \"\"\"Verify pre and post generation python hooks executed and result in output_dir.\n\n        Each hook should create in target directory. Test verifies that these files\n        created.\n        \"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'pyhooks': 'pyhooks'}},\n            repo_dir='tests/test-pyhooks/',\n            output_dir='tests/test-pyhooks/',\n        )\n\ntests/test_generate_hooks.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyhooks/'\ncontext = {'cookiecutter': {'pyhooks': 'pyhooks'}}\noutput_dir = 'tests/test-pyhooks/', overwrite_if_exists = False\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_python_hooks_cwd","title":"test_generate_hooks.py::test_run_python_hooks_cwd","text":"<pre>test_generate_hooks.py::test_run_python_hooks_cwd</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_run_python_hooks_cwd():\n        \"\"\"Verify pre and post generation python hooks executed and result in current dir.\n\n        Each hook should create in target directory. Test verifies that these files\n        created.\n        \"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'pyhooks': 'pyhooks'}}, repo_dir='tests/test-pyhooks/'\n        )\n\ntests/test_generate_hooks.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyhooks/'\ncontext = {'cookiecutter': {'pyhooks': 'pyhooks'}}, output_dir = '.'\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_empty_hooks","title":"test_generate_hooks.py::test_empty_hooks","text":"<pre>test_generate_hooks.py::test_empty_hooks</pre><pre>\n@pytest.mark.skipif(WINDOWS, reason='OSError.errno=8 is not thrown on Windows')\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_empty_hooks():\n        \"\"\"Verify error is raised on empty hook script. Ignored on windows.\n\n        OSError.errno=8 is not thrown on Windows when the script is empty\n        because it always runs through shell instead of needing a shebang.\n        \"\"\"\n        with pytest.raises(FailedHookException) as excinfo:\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'shellhooks': 'shellhooks'}},\n                repo_dir='tests/test-shellhooks-empty/',\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-shellhooks-empty/'\ncontext = {'cookiecutter': {'shellhooks': 'shellhooks'}}, output_dir = '.'\noverwrite_if_exists = True, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_oserror_hooks","title":"test_generate_hooks.py::test_oserror_hooks","text":"<pre>test_generate_hooks.py::test_oserror_hooks</pre><pre>\nmocker = \n\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_oserror_hooks(mocker):\n        \"\"\"Verify script error passed correctly to cookiecutter error.\n\n        Here subprocess.Popen function mocked, ie we do not call hook script,\n        just produce expected error.\n        \"\"\"\n        message = 'Out of memory'\n\n        err = OSError(message)\n        err.errno = errno.ENOMEM\n\n        prompt = mocker.patch('subprocess.Popen')\n        prompt.side_effect = err\n\n        with pytest.raises(FailedHookException) as excinfo:\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'shellhooks': 'shellhooks'}},\n                repo_dir='tests/test-shellhooks-empty/',\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:106: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-shellhooks-empty/'\ncontext = {'cookiecutter': {'shellhooks': 'shellhooks'}}, output_dir = '.'\noverwrite_if_exists = True, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_failing_hook_removes_output_directory","title":"test_generate_hooks.py::test_run_failing_hook_removes_output_directory","text":"<pre>test_generate_hooks.py::test_run_failing_hook_removes_output_directory</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_run_failing_hook_removes_output_directory():\n        \"\"\"Verify project directory not created or removed if hook failed.\"\"\"\n        repo_path = os.path.abspath('tests/test-hooks/')\n        hooks_path = os.path.abspath('tests/test-hooks/hooks')\n\n        hook_dir = os.path.join(repo_path, 'hooks')\n        template = os.path.join(repo_path, 'input{{cookiecutter.hooks}}')\n        os.mkdir(repo_path)\n        os.mkdir(hook_dir)\n        os.mkdir(template)\n\n        hook_path = os.path.join(hooks_path, 'pre_gen_project.py')\n\n        with Path(hook_path).open('w') as f:\n            f.write(\"#!/usr/bin/env python\\n\")\n            f.write(\"import sys; sys.exit(1)\\n\")\n\n        with pytest.raises(FailedHookException) as excinfo:\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'hooks': 'hooks'}},\n                repo_dir='tests/test-hooks/',\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:133: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-hooks/', context = {'cookiecutter': {'hooks': 'hooks'}}\noutput_dir = '.', overwrite_if_exists = True, skip_if_file_exists = False\naccept_hooks = True, keep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_failing_hook_preserves_existing_output_directory","title":"test_generate_hooks.py::test_run_failing_hook_preserves_existing_output_directory","text":"<pre>test_generate_hooks.py::test_run_failing_hook_preserves_existing_output_directory</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_run_failing_hook_preserves_existing_output_directory():\n        \"\"\"Verify project directory not removed if exist before hook failed.\"\"\"\n        repo_path = os.path.abspath('tests/test-hooks/')\n        hooks_path = os.path.abspath('tests/test-hooks/hooks')\n\n        hook_dir = os.path.join(repo_path, 'hooks')\n        template = os.path.join(repo_path, 'input{{cookiecutter.hooks}}')\n        os.mkdir(repo_path)\n        os.mkdir(hook_dir)\n        os.mkdir(template)\n\n        hook_path = os.path.join(hooks_path, 'pre_gen_project.py')\n\n        with Path(hook_path).open('w') as f:\n            f.write(\"#!/usr/bin/env python\\n\")\n            f.write(\"import sys; sys.exit(1)\\n\")\n\n        os.mkdir('inputhooks')\n        with pytest.raises(FailedHookException) as excinfo:\n&gt;           generate.generate_files(\n                context={'cookiecutter': {'hooks': 'hooks'}},\n                repo_dir='tests/test-hooks/',\n                overwrite_if_exists=True,\n            )\n\ntests/test_generate_hooks.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-hooks/', context = {'cookiecutter': {'hooks': 'hooks'}}\noutput_dir = '.', overwrite_if_exists = True, skip_if_file_exists = False\naccept_hooks = True, keep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_shell_hooks","title":"test_generate_hooks.py::test_run_shell_hooks","text":"<pre>test_generate_hooks.py::test_run_shell_hooks</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_run_shell_hooks0')\n\n    @pytest.mark.skipif(sys.platform.startswith('win'), reason=\"Linux only test\")\n    @pytest.mark.usefixtures('clean_system', 'remove_additional_folders')\n    def test_run_shell_hooks(tmp_path):\n        \"\"\"Verify pre and post generate project shell hooks executed.\n\n        This test for .sh files.\n        \"\"\"\n&gt;       generate.generate_files(\n            context={'cookiecutter': {'shellhooks': 'shellhooks'}},\n            repo_dir='tests/test-shellhooks/',\n            output_dir=tmp_path.joinpath('test-shellhooks'),\n        )\n\ntests/test_generate_hooks.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-shellhooks/'\ncontext = {'cookiecutter': {'shellhooks': 'shellhooks'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_run_shell_hooks0/test-shellhooks')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_run_shell_hooks_win","title":"test_generate_hooks.py::test_run_shell_hooks_win","text":"<pre>test_generate_hooks.py::test_run_shell_hooks_win</pre><pre>\n('/testbed/tests/test_generate_hooks.py', 195, 'Skipped: Win only test')\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_ignore_shell_hooks","title":"test_generate_hooks.py::test_ignore_shell_hooks","text":"<pre>test_generate_hooks.py::test_ignore_shell_hooks</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_ignore_shell_hooks0')\n\n    @pytest.mark.usefixtures(\"clean_system\", \"remove_additional_folders\")\n    def test_ignore_shell_hooks(tmp_path):\n        \"\"\"Verify *.txt files not created, when accept_hooks=False.\"\"\"\n&gt;       generate.generate_files(\n            context={\"cookiecutter\": {\"shellhooks\": \"shellhooks\"}},\n            repo_dir=\"tests/test-shellhooks/\",\n            output_dir=tmp_path.joinpath('test-shellhooks'),\n            accept_hooks=False,\n        )\n\ntests/test_generate_hooks.py:220: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-shellhooks/'\ncontext = {'cookiecutter': {'shellhooks': 'shellhooks'}}\noutput_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_ignore_shell_hooks0/test-shellhooks')\noverwrite_if_exists = False, skip_if_file_exists = False, accept_hooks = False\nkeep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_generate_hookspytest_deprecate_run_hook_from_repo_dir","title":"test_generate_hooks.py::test_deprecate_run_hook_from_repo_dir","text":"<pre>test_generate_hooks.py::test_deprecate_run_hook_from_repo_dir</pre><pre>\nrepo_dir = 'tests/test-shellhooks/', hook_name = 'pre_gen_project'\nproject_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_deprecate_run_hook_from_r0/test-shellhooks')\ncontext = {}, delete_project_on_failure = False\n\n    def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n        delete_project_on_failure):\n        \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n        :param repo_dir: Project template input directory.\n        :param hook_name: The hook to execute.\n        :param project_dir: The directory to execute the script from.\n        :param context: Cookiecutter project context.\n        :param delete_project_on_failure: Delete the project directory on hook\n            failure?\n        \"\"\"\n        with work_in(repo_dir):\n            try:\n&gt;               run_hook_from_repo_dir(\n                    repo_dir=repo_dir,\n                    hook_name=hook_name,\n                    project_dir=project_dir,\n                    context=context\n                )\nE               TypeError: run_hook_from_repo_dir() missing 1 required positional argument: 'delete_project_on_failure'\n\ncookiecutter/generate.py:182: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_deprecate_run_hook_from_r0')\n\n    @pytest.mark.usefixtures(\"clean_system\", \"remove_additional_folders\")\n    def test_deprecate_run_hook_from_repo_dir(tmp_path):\n        \"\"\"Test deprecation warning in generate._run_hook_from_repo_dir.\"\"\"\n        repo_dir = \"tests/test-shellhooks/\"\n        project_dir = Path(tmp_path.joinpath('test-shellhooks'))\n        project_dir.mkdir()\n        with pytest.deprecated_call():\n&gt;           generate._run_hook_from_repo_dir(\n                repo_dir=repo_dir,\n                hook_name=\"pre_gen_project\",\n                project_dir=project_dir,\n                context={},\n                delete_project_on_failure=False,\n            )\n\ntests/test_generate_hooks.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-shellhooks/', hook_name = 'pre_gen_project'\nproject_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_deprecate_run_hook_from_r0/test-shellhooks')\ncontext = {}, delete_project_on_failure = False\n\n    def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n        delete_project_on_failure):\n        \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n        :param repo_dir: Project template input directory.\n        :param hook_name: The hook to execute.\n        :param project_dir: The directory to execute the script from.\n        :param context: Cookiecutter project context.\n        :param delete_project_on_failure: Delete the project directory on hook\n            failure?\n        \"\"\"\n        with work_in(repo_dir):\n            try:\n                run_hook_from_repo_dir(\n                    repo_dir=repo_dir,\n                    hook_name=hook_name,\n                    project_dir=project_dir,\n                    context=context\n                )\n&gt;           except FailedHookException:\nE           NameError: name 'FailedHookException' is not defined\n\ncookiecutter/generate.py:188: NameError\n\nDuring handling of the above exception, another exception occurred:\n\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_deprecate_run_hook_from_r0')\n\n    @pytest.mark.usefixtures(\"clean_system\", \"remove_additional_folders\")\n    def test_deprecate_run_hook_from_repo_dir(tmp_path):\n        \"\"\"Test deprecation warning in generate._run_hook_from_repo_dir.\"\"\"\n        repo_dir = \"tests/test-shellhooks/\"\n        project_dir = Path(tmp_path.joinpath('test-shellhooks'))\n        project_dir.mkdir()\n&gt;       with pytest.deprecated_call():\nE       Failed: DID NOT WARN. No warnings of type (, , ) were emitted.\nE        Emitted warnings: [].\n\ntests/test_generate_hooks.py:240: Failed"},{"location":"analysis_baseline_cookiecutter/#test_get_configpytest_get_config","title":"test_get_config.py::test_get_config","text":"<pre>test_get_config.py::test_get_config</pre><pre>\ndef test_get_config():\n        \"\"\"Verify valid config opened and rendered correctly.\"\"\"\n        conf = config.get_config('tests/test-config/valid-config.yaml')\n        expected_conf = {\n            'cookiecutters_dir': '/home/example/some-path-to-templates',\n            'replay_dir': '/home/example/some-path-to-replay-files',\n            'default_context': {\n                'full_name': 'Firstname Lastname',\n                'email': 'firstname.lastname@gmail.com',\n                'github_username': 'example',\n                'project': {\n                    'description': 'description',\n                    'tags': [\n                        'first',\n                        'second',\n                        'third',\n                    ],\n                },\n            },\n            'abbreviations': {\n                'gh': 'https://github.com/{0}.git',\n                'gl': 'https://gitlab.com/{0}.git',\n                'bb': 'https://bitbucket.org/{0}',\n                'helloworld': 'https://github.com/hackebrot/helloworld',\n            },\n        }\n&gt;       assert conf == expected_conf\nE       AssertionError: assert {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} == {'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'abbreviations': {'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'bb': 'https://bitbucket.org/{0}', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Common items:\nE         {'cookiecutters_dir': '/home/example/some-path-to-templates',\nE          'default_context': {'email': 'firstname.lastname@gmail.com',\nE                              'full_name': 'Firstname Lastname',\nE                              'github_username': 'example',\nE                              'project': {'description': 'description',\nE                                          'tags': ['first', 'second', 'third']}},\nE          'replay_dir': '/home/example/some-path-to-replay-files'}\nE         Differing items:\nE         {'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} != {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Full diff:\nE           {\nE               'abbreviations': {\nE         -         'bb': 'https://bitbucket.org/{0}',\nE         -         'gh': 'https://github.com/{0}.git',\nE         -         'gl': 'https://gitlab.com/{0}.git',\nE                   'helloworld': 'https://github.com/hackebrot/helloworld',\nE               },\nE               'cookiecutters_dir': '/home/example/some-path-to-templates',\nE               'default_context': {\nE                   'email': 'firstname.lastname@gmail.com',\nE                   'full_name': 'Firstname Lastname',\nE                   'github_username': 'example',\nE                   'project': {\nE                       'description': 'description',\nE                       'tags': [\nE                           'first',\nE                           'second',\nE                           'third',\nE                       ],\nE                   },\nE               },\nE               'replay_dir': '/home/example/some-path-to-replay-files',\nE           }\n\ntests/test_get_config.py:80: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_configpytest_get_config_with_defaults","title":"test_get_config.py::test_get_config_with_defaults","text":"<pre>test_get_config.py::test_get_config_with_defaults</pre><pre>\ndef test_get_config_with_defaults():\n        \"\"\"A config file that overrides 1 of 3 defaults.\"\"\"\n        conf = config.get_config('tests/test-config/valid-partial-config.yaml')\n        default_cookiecutters_dir = Path('~/.cookiecutters').expanduser()\n        default_replay_dir = Path('~/.cookiecutter_replay').expanduser()\n        expected_conf = {\n            'cookiecutters_dir': str(default_cookiecutters_dir),\n            'replay_dir': str(default_replay_dir),\n            'default_context': {\n                'full_name': 'Firstname Lastname',\n                'email': 'firstname.lastname@gmail.com',\n                'github_username': 'example',\n            },\n            'abbreviations': {\n                'gh': 'https://github.com/{0}.git',\n                'gl': 'https://gitlab.com/{0}.git',\n                'bb': 'https://bitbucket.org/{0}',\n            },\n        }\n&gt;       assert conf == expected_conf\nE       AssertionError: assert {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example'}} == {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutter_replay', 'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example'}, 'abbreviations': {'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'bb': 'https://bitbucket.org/{0}'}}\nE         \nE         Common items:\nE         {'default_context': {'email': 'firstname.lastname@gmail.com',\nE                              'full_name': 'Firstname Lastname',\nE                              'github_username': 'example'}}\nE         Right contains 3 more items:\nE         {'abbreviations': {'bb': 'https://bitbucket.org/{0}',\nE                            'gh': 'https://github.com/{0}.git',\nE                            'gl': 'https://gitlab.com/{0}.git'},\nE          'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutters',\nE          'replay_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutter_replay'}\nE         \nE         Full diff:\nE           {\nE         -     'abbreviations': {\nE         -         'bb': 'https://bitbucket.org/{0}',\nE         -         'gh': 'https://github.com/{0}.git',\nE         -         'gl': 'https://gitlab.com/{0}.git',\nE         -     },\nE         -     'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutters',\nE               'default_context': {\nE                   'email': 'firstname.lastname@gmail.com',\nE                   'full_name': 'Firstname Lastname',\nE                   'github_username': 'example',\nE               },\nE         -     'replay_dir': '/tmp/pytest-of-root/pytest-0/test_get_config_with_defaults0/home/.cookiecutter_replay',\nE           }\n\ntests/test_get_config.py:123: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_configpytest_get_config_empty_config_file","title":"test_get_config.py::test_get_config_empty_config_file","text":"<pre>test_get_config.py::test_get_config_empty_config_file</pre><pre>\ndef test_get_config_empty_config_file():\n        \"\"\"An empty config file results in the default config.\"\"\"\n&gt;       conf = config.get_config('tests/test-config/empty-config.yaml')\n\ntests/test_get_config.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nconfig_path = 'tests/test-config/empty-config.yaml'\n\n    def get_config(config_path):\n        \"\"\"Retrieve the config from the specified path, returning a config dict.\"\"\"\n        if not os.path.exists(config_path):\n            raise ConfigDoesNotExistException(f\"Config file {config_path} does not exist.\")\n\n        with open(config_path) as file_handle:\n            try:\n                user_config = yaml.safe_load(file_handle)\n            except yaml.YAMLError as e:\n                raise InvalidConfiguration(f\"Unable to parse YAML file {config_path}: {e}\")\n\n        if user_config is None:\n&gt;           raise InvalidConfiguration(f\"Config file {config_path} is empty.\")\nE           cookiecutter.exceptions.InvalidConfiguration: Config file tests/test-config/empty-config.yaml is empty.\n\ncookiecutter/config.py:50: InvalidConfiguration\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_configpytest_get_config_invalid_file_with_array_as_top_level_element","title":"test_get_config.py::test_get_config_invalid_file_with_array_as_top_level_element","text":"<pre>test_get_config.py::test_get_config_invalid_file_with_array_as_top_level_element</pre><pre>\ndef test_get_config_invalid_file_with_array_as_top_level_element():\n        \"\"\"An exception should be raised if top-level element is array.\"\"\"\n        expected_error_msg = (\n            'Top-level element of YAML file '\n            'tests/test-config/invalid-config-w-array.yaml should be an object.'\n        )\n&gt;       with pytest.raises(InvalidConfiguration) as exc_info:\nE       Failed: DID NOT RAISE \n\ntests/test_get_config.py:138: Failed"},{"location":"analysis_baseline_cookiecutter/#test_get_configpytest_get_config_invalid_file_with_multiple_docs","title":"test_get_config.py::test_get_config_invalid_file_with_multiple_docs","text":"<pre>test_get_config.py::test_get_config_invalid_file_with_multiple_docs</pre><pre>\ndef test_get_config_invalid_file_with_multiple_docs():\n        \"\"\"An exception should be raised if config file contains multiple docs.\"\"\"\n        expected_error_msg = (\n            'Unable to parse YAML file '\n            'tests/test-config/invalid-config-w-multiple-docs.yaml.'\n        )\n        with pytest.raises(InvalidConfiguration) as exc_info:\n            config.get_config('tests/test-config/invalid-config-w-multiple-docs.yaml')\n&gt;       assert expected_error_msg in str(exc_info.value)\nE       assert 'Unable to parse YAML file tests/test-config/invalid-config-w-multiple-docs.yaml.' in 'Unable to parse YAML file tests/test-config/invalid-config-w-multiple-docs.yaml: expected a single document in the stream\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 2, column 1\\nbut found another document\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 12, column 1'\nE        +  where 'Unable to parse YAML file tests/test-config/invalid-config-w-multiple-docs.yaml: expected a single document in the stream\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 2, column 1\\nbut found another document\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 12, column 1' = str(InvalidConfiguration('Unable to parse YAML file tests/test-config/invalid-config-w-multiple-docs.yaml: expected a single document in the stream\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 2, column 1\\nbut found another document\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 12, column 1'))\nE        +    where InvalidConfiguration('Unable to parse YAML file tests/test-config/invalid-config-w-multiple-docs.yaml: expected a single document in the stream\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 2, column 1\\nbut found another document\\n  in \"tests/test-config/invalid-config-w-multiple-docs.yaml\", line 12, column 1') = .value\n\ntests/test_get_config.py:151: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_get_user_configpytest_get_user_config_valid","title":"test_get_user_config.py::test_get_user_config_valid","text":"<pre>test_get_user_config.py::test_get_user_config_valid</pre><pre>\nuser_config_path = '/root/.cookiecutterrc'\ncustom_config = {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'default_context': {'email': 'firstname.lastname@gmail.com', 'full_name': 'Firstname Lastname', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'replay_dir': '/home/example/some-path-to-replay-files'}\n\n    @pytest.mark.usefixtures('back_up_rc')\n    def test_get_user_config_valid(user_config_path, custom_config):\n        \"\"\"Validate user config correctly parsed if exist and correctly formatted.\"\"\"\n        shutil.copy('tests/test-config/valid-config.yaml', user_config_path)\n        conf = config.get_user_config()\n\n&gt;       assert conf == custom_config\nE       AssertionError: assert {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} == {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'bb': 'https://bitbucket.org/{0}', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Common items:\nE         {'cookiecutters_dir': '/home/example/some-path-to-templates',\nE          'default_context': {'email': 'firstname.lastname@gmail.com',\nE                              'full_name': 'Firstname Lastname',\nE                              'github_username': 'example',\nE                              'project': {'description': 'description',\nE                                          'tags': ['first', 'second', 'third']}},\nE          'replay_dir': '/home/example/some-path-to-replay-files'}\nE         Differing items:\nE         {'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} != {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Full diff:\nE           {\nE               'abbreviations': {\nE         -         'bb': 'https://bitbucket.org/{0}',\nE         -         'gh': 'https://github.com/{0}.git',\nE         -         'gl': 'https://gitlab.com/{0}.git',\nE                   'helloworld': 'https://github.com/hackebrot/helloworld',\nE               },\nE               'cookiecutters_dir': '/home/example/some-path-to-templates',\nE               'default_context': {\nE                   'email': 'firstname.lastname@gmail.com',\nE                   'full_name': 'Firstname Lastname',\nE                   'github_username': 'example',\nE                   'project': {\nE                       'description': 'description',\nE                       'tags': [\nE                           'first',\nE                           'second',\nE                           'third',\nE                       ],\nE                   },\nE               },\nE               'replay_dir': '/home/example/some-path-to-replay-files',\nE           }\n\ntests/test_get_user_config.py:76: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_user_configpytest_specify_config_path","title":"test_get_user_config.py::test_specify_config_path","text":"<pre>test_get_user_config.py::test_specify_config_path</pre><pre>\nmocker = \ncustom_config_path = 'tests/test-config/valid-config.yaml'\ncustom_config = {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'default_context': {'email': 'firstname.lastname@gmail.com', 'full_name': 'Firstname Lastname', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'replay_dir': '/home/example/some-path-to-replay-files'}\n\n    def test_specify_config_path(mocker, custom_config_path, custom_config):\n        \"\"\"Validate provided custom config path should be respected and parsed.\"\"\"\n        spy_get_config = mocker.spy(config, 'get_config')\n\n        user_config = config.get_user_config(custom_config_path)\n        spy_get_config.assert_called_once_with(custom_config_path)\n\n&gt;       assert user_config == custom_config\nE       AssertionError: assert {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} == {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'bb': 'https://bitbucket.org/{0}', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Common items:\nE         {'cookiecutters_dir': '/home/example/some-path-to-templates',\nE          'default_context': {'email': 'firstname.lastname@gmail.com',\nE                              'full_name': 'Firstname Lastname',\nE                              'github_username': 'example',\nE                              'project': {'description': 'description',\nE                                          'tags': ['first', 'second', 'third']}},\nE          'replay_dir': '/home/example/some-path-to-replay-files'}\nE         Differing items:\nE         {'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} != {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Full diff:\nE           {\nE               'abbreviations': {\nE         -         'bb': 'https://bitbucket.org/{0}',\nE         -         'gh': 'https://github.com/{0}.git',\nE         -         'gl': 'https://gitlab.com/{0}.git',\nE                   'helloworld': 'https://github.com/hackebrot/helloworld',\nE               },\nE               'cookiecutters_dir': '/home/example/some-path-to-templates',\nE               'default_context': {\nE                   'email': 'firstname.lastname@gmail.com',\nE                   'full_name': 'Firstname Lastname',\nE                   'github_username': 'example',\nE                   'project': {\nE                       'description': 'description',\nE                       'tags': [\nE                           'first',\nE                           'second',\nE                           'third',\nE                       ],\nE                   },\nE               },\nE               'replay_dir': '/home/example/some-path-to-replay-files',\nE           }\n\ntests/test_get_user_config.py:106: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_get_user_configpytest_default_config_from_env_variable","title":"test_get_user_config.py::test_default_config_from_env_variable","text":"<pre>test_get_user_config.py::test_default_config_from_env_variable</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3263d00&gt;\ncustom_config_path = 'tests/test-config/valid-config.yaml'\ncustom_config = {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'default_context': {'email': 'firstname.lastname@gmail.com', 'full_name': 'Firstname Lastname', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'replay_dir': '/home/example/some-path-to-replay-files'}\n\n    def test_default_config_from_env_variable(\n        monkeypatch, custom_config_path, custom_config\n    ):\n        \"\"\"Validate app configuration. User config path should be parsed from sys env.\"\"\"\n        monkeypatch.setenv('COOKIECUTTER_CONFIG', custom_config_path)\n\n        user_config = config.get_user_config()\n&gt;       assert user_config == custom_config\nE       AssertionError: assert {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} == {'default_context': {'full_name': 'Firstname Lastname', 'email': 'firstname.lastname@gmail.com', 'github_username': 'example', 'project': {'description': 'description', 'tags': ['first', 'second', 'third']}}, 'cookiecutters_dir': '/home/example/some-path-to-templates', 'replay_dir': '/home/example/some-path-to-replay-files', 'abbreviations': {'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'bb': 'https://bitbucket.org/{0}', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Common items:\nE         {'cookiecutters_dir': '/home/example/some-path-to-templates',\nE          'default_context': {'email': 'firstname.lastname@gmail.com',\nE                              'full_name': 'Firstname Lastname',\nE                              'github_username': 'example',\nE                              'project': {'description': 'description',\nE                                          'tags': ['first', 'second', 'third']}},\nE          'replay_dir': '/home/example/some-path-to-replay-files'}\nE         Differing items:\nE         {'abbreviations': {'helloworld': 'https://github.com/hackebrot/helloworld'}} != {'abbreviations': {'bb': 'https://bitbucket.org/{0}', 'gh': 'https://github.com/{0}.git', 'gl': 'https://gitlab.com/{0}.git', 'helloworld': 'https://github.com/hackebrot/helloworld'}}\nE         \nE         Full diff:\nE           {\nE               'abbreviations': {\nE         -         'bb': 'https://bitbucket.org/{0}',\nE         -         'gh': 'https://github.com/{0}.git',\nE         -         'gl': 'https://gitlab.com/{0}.git',\nE                   'helloworld': 'https://github.com/hackebrot/helloworld',\nE               },\nE               'cookiecutters_dir': '/home/example/some-path-to-templates',\nE               'default_context': {\nE                   'email': 'firstname.lastname@gmail.com',\nE                   'full_name': 'Firstname Lastname',\nE                   'github_username': 'example',\nE                   'project': {\nE                       'description': 'description',\nE                       'tags': [\nE                           'first',\nE                           'second',\nE                           'third',\nE                       ],\nE                   },\nE               },\nE               'replay_dir': '/home/example/some-path-to-replay-files',\nE           }\n\ntests/test_get_user_config.py:121: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_user_configpytest_expand_user_for_directories_in_config","title":"test_get_user_config.py::test_expand_user_for_directories_in_config","text":"<pre>test_get_user_config.py::test_expand_user_for_directories_in_config</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd31b3040&gt;\n\n    def test_expand_user_for_directories_in_config(monkeypatch):\n        \"\"\"Validate user pointers expanded in user configs.\"\"\"\n\n        def _expanduser(path):\n            return path.replace('~', 'Users/bob')\n\n        monkeypatch.setattr('os.path.expanduser', _expanduser)\n\n        config_file = 'tests/test-config/config-expand-user.yaml'\n\n        user_config = config.get_user_config(config_file)\n&gt;       assert user_config['replay_dir'] == 'Users/bob/replay-files'\nE       AssertionError: assert '~/replay-files' == 'Users/bob/replay-files'\nE         \nE         - Users/bob/replay-files\nE         + ~/replay-files\n\ntests/test_get_user_config.py:145: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_get_user_configpytest_expand_vars_for_directories_in_config","title":"test_get_user_config.py::test_expand_vars_for_directories_in_config","text":"<pre>test_get_user_config.py::test_expand_vars_for_directories_in_config</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd41d4910&gt;\n\n    def test_expand_vars_for_directories_in_config(monkeypatch):\n        \"\"\"Validate environment variables expanded in user configs.\"\"\"\n        monkeypatch.setenv('COOKIES', 'Users/bob/cookies')\n\n        config_file = 'tests/test-config/config-expand-vars.yaml'\n\n        user_config = config.get_user_config(config_file)\n&gt;       assert user_config['replay_dir'] == 'Users/bob/cookies/replay-files'\nE       AssertionError: assert '$COOKIES/replay-files' == 'Users/bob/cookies/replay-files'\nE         \nE         - Users/bob/cookies/replay-files\nE         + $COOKIES/replay-files\n\ntests/test_get_user_config.py:156: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestfindhookstest_find_hook","title":"test_hooks.py::TestFindHooks::test_find_hook","text":"<pre>test_hooks.py::TestFindHooks::test_find_hook</pre><pre>\nself = \n\n    def test_find_hook(self):\n        \"\"\"Finds the specified hook.\"\"\"\n        with utils.work_in(self.repo_path):\n            expected_pre = os.path.abspath('hooks/pre_gen_project.py')\n            actual_hook_path = hooks.find_hook('pre_gen_project')\n&gt;           assert expected_pre == actual_hook_path[0]\nE           AssertionError: assert '/testbed/tests/test-hooks/hooks/pre_gen_project.py' == '/'\nE             \nE             - /\nE             + /testbed/tests/test-hooks/hooks/pre_gen_project.py\n\ntests/test_hooks.py:93: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_failing_script","title":"test_hooks.py::TestExternalHooks::test_run_failing_script","text":"<pre>test_hooks.py::TestExternalHooks::test_run_failing_script</pre><pre>\nself = \nmocker = \n\n    def test_run_failing_script(self, mocker):\n        \"\"\"Test correct exception raise if run_script fails.\"\"\"\n        err = OSError()\n\n        prompt = mocker.patch('subprocess.Popen')\n        prompt.side_effect = err\n\n        with pytest.raises(exceptions.FailedHookException) as excinfo:\n&gt;           hooks.run_script(os.path.join(self.hooks_path, self.post_hook))\n\ntests/test_hooks.py:157: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (['/testbed/tests/test-hooks/hooks/post_gen_project.sh'],)\nkwargs = {'cwd': '.'}, effect = OSError()\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n&gt;               raise effect\nE               OSError\n\n/usr/lib/python3.10/unittest/mock.py:1173: OSError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_failing_script_enoexec","title":"test_hooks.py::TestExternalHooks::test_run_failing_script_enoexec","text":"<pre>test_hooks.py::TestExternalHooks::test_run_failing_script_enoexec</pre><pre>\nself = \nmocker = \n\n    def test_run_failing_script_enoexec(self, mocker):\n        \"\"\"Test correct exception raise if run_script fails.\"\"\"\n        err = OSError()\n        err.errno = errno.ENOEXEC\n\n        prompt = mocker.patch('subprocess.Popen')\n        prompt.side_effect = err\n\n        with pytest.raises(exceptions.FailedHookException) as excinfo:\n&gt;           hooks.run_script(os.path.join(self.hooks_path, self.post_hook))\n\ntests/test_hooks.py:169: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (['/testbed/tests/test-hooks/hooks/post_gen_project.sh'],)\nkwargs = {'cwd': '.'}, effect = OSError()\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n&gt;               raise effect\nE               OSError\n\n/usr/lib/python3.10/unittest/mock.py:1173: OSError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_script_cwd","title":"test_hooks.py::TestExternalHooks::test_run_script_cwd","text":"<pre>test_hooks.py::TestExternalHooks::test_run_script_cwd</pre><pre>\nself = \n\n    def test_run_script_cwd(self):\n        \"\"\"Change directory before running hook.\"\"\"\n&gt;       hooks.run_script(os.path.join(self.hooks_path, self.post_hook), 'tests')\n\ntests/test_hooks.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = ['/testbed/tests/test-hooks/hooks/post_gen_project.sh']\nexecutable = b'/testbed/tests/test-hooks/hooks/post_gen_project.sh'\npreexec_fn = None, close_fds = True, pass_fds = (), cwd = 'tests', env = None\nstartupinfo = None, creationflags = 0, shell = False, p2cread = -1\np2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1\nrestore_signals = True, gid = None, gids = None, uid = None, umask = -1\nstart_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n\n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n\n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n\n        if executable is None:\n            executable = args[0]\n\n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread &gt; 2)\n                and (c2pwrite == -1 or c2pwrite &gt; 2)\n                and (errwrite == -1 or errwrite &gt; 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask &lt; 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n\n        orig_executable = executable\n\n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write &lt; 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n\n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) &gt; 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n\n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n\n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n&gt;               raise child_exception_type(errno_num, err_msg, err_filename)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'tests'\n\n/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_script_with_context","title":"test_hooks.py::TestExternalHooks::test_run_script_with_context","text":"<pre>test_hooks.py::TestExternalHooks::test_run_script_with_context</pre><pre>\nself = \n\n    def test_run_script_with_context(self):\n        \"\"\"Execute a hook script, passing a context.\"\"\"\n        hook_path = os.path.join(self.hooks_path, 'post_gen_project.sh')\n\n        if sys.platform.startswith('win'):\n            post = 'post_gen_project.bat'\n            with Path(self.hooks_path, post).open('w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. &gt;{{cookiecutter.file}}\\n\")\n        else:\n            with Path(hook_path).open('w') as fh:\n                fh.write(\"#!/bin/bash\\n\")\n                fh.write(\"\\n\")\n                fh.write(\"echo 'post generation hook';\\n\")\n                fh.write(\"touch 'shell_post.txt'\\n\")\n                fh.write(\"touch '{{cookiecutter.file}}'\\n\")\n                os.chmod(hook_path, os.stat(hook_path).st_mode | stat.S_IXUSR)\n\n&gt;       hooks.run_script_with_context(\n            os.path.join(self.hooks_path, self.post_hook),\n            'tests',\n            {'cookiecutter': {'file': 'context_post.txt'}},\n        )\n\ntests/test_hooks.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:91: in run_script_with_context\n    run_script(temp_script_path, cwd)\ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = ['/tmp/tmp12aljphp'], executable = b'/tmp/tmp12aljphp', preexec_fn = None\nclose_fds = True, pass_fds = (), cwd = 'tests', env = None, startupinfo = None\ncreationflags = 0, shell = False, p2cread = -1, p2cwrite = -1, c2pread = -1\nc2pwrite = -1, errread = -1, errwrite = -1, restore_signals = True, gid = None\ngids = None, uid = None, umask = -1, start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n\n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n\n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n\n        if executable is None:\n            executable = args[0]\n\n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread &gt; 2)\n                and (c2pwrite == -1 or c2pwrite &gt; 2)\n                and (errwrite == -1 or errwrite &gt; 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask &lt; 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n\n        orig_executable = executable\n\n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write &lt; 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n\n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) &gt; 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n\n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n\n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n&gt;               raise child_exception_type(errno_num, err_msg, err_filename)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'tests'\n\n/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_hook","title":"test_hooks.py::TestExternalHooks::test_run_hook","text":"<pre>test_hooks.py::TestExternalHooks::test_run_hook</pre><pre>\nself = \n\n    def test_run_hook(self):\n        \"\"\"Execute hook from specified template in specified output \\\n        directory.\"\"\"\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n        with utils.work_in(self.repo_path):\n&gt;           hooks.run_hook('pre_gen_project', tests_dir, {})\n\ntests/test_hooks.py:213: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:108: in run_hook\n    run_script_with_context(hook_path, project_dir, context)\ncookiecutter/hooks.py:91: in run_script_with_context\n    run_script(temp_script_path, cwd)\ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = ['/tmp/tmpifefawcd'], executable = b'/tmp/tmpifefawcd', preexec_fn = None\nclose_fds = True, pass_fds = ()\ncwd = '/testbed/tests/test-hooks/input{{hooks}}', env = None, startupinfo = None\ncreationflags = 0, shell = False, p2cread = -1, p2cwrite = -1, c2pread = -1\nc2pwrite = -1, errread = -1, errwrite = -1, restore_signals = True, gid = None\ngids = None, uid = None, umask = -1, start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n\n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n\n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n\n        if executable is None:\n            executable = args[0]\n\n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread &gt; 2)\n                and (c2pwrite == -1 or c2pwrite &gt; 2)\n                and (errwrite == -1 or errwrite &gt; 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask &lt; 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n\n        orig_executable = executable\n\n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write &lt; 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n\n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) &gt; 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n\n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n\n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n&gt;               raise child_exception_type(errno_num, err_msg, err_filename)\nE               PermissionError: [Errno 13] Permission denied: '/tmp/tmpifefawcd'\n\n/usr/lib/python3.10/subprocess.py:1863: PermissionError"},{"location":"analysis_baseline_cookiecutter/#test_hookspytestexternalhookstest_run_failing_hook","title":"test_hooks.py::TestExternalHooks::test_run_failing_hook","text":"<pre>test_hooks.py::TestExternalHooks::test_run_failing_hook</pre><pre>\nself = \n\n    def test_run_failing_hook(self):\n        \"\"\"Test correct exception raise if hook exit code is not zero.\"\"\"\n        hook_path = os.path.join(self.hooks_path, 'pre_gen_project.py')\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n\n        with Path(hook_path).open('w') as f:\n            f.write(\"#!/usr/bin/env python\\n\")\n            f.write(\"import sys; sys.exit(1)\\n\")\n\n        with utils.work_in(self.repo_path):\n            with pytest.raises(exceptions.FailedHookException) as excinfo:\n&gt;               hooks.run_hook('pre_gen_project', tests_dir, {})\n\ntests/test_hooks.py:231: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/hooks.py:108: in run_hook\n    run_script_with_context(hook_path, project_dir, context)\ncookiecutter/hooks.py:91: in run_script_with_context\n    run_script(temp_script_path, cwd)\ncookiecutter/hooks.py:65: in run_script\n    subprocess.check_call([script_path], cwd=cwd)\n/usr/lib/python3.10/subprocess.py:364: in check_call\n    retcode = call(*popenargs, **kwargs)\n/usr/lib/python3.10/subprocess.py:345: in call\n    with Popen(*popenargs, **kwargs) as p:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = ['/tmp/tmppfr1yqyf'], executable = b'/tmp/tmppfr1yqyf', preexec_fn = None\nclose_fds = True, pass_fds = ()\ncwd = '/testbed/tests/test-hooks/input{{hooks}}', env = None, startupinfo = None\ncreationflags = 0, shell = False, p2cread = -1, p2cwrite = -1, c2pread = -1\nc2pwrite = -1, errread = -1, errwrite = -1, restore_signals = True, gid = None\ngids = None, uid = None, umask = -1, start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n\n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n\n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n\n        if executable is None:\n            executable = args[0]\n\n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n\n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread &gt; 2)\n                and (c2pwrite == -1 or c2pwrite &gt; 2)\n                and (errwrite == -1 or errwrite &gt; 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask &lt; 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n\n        orig_executable = executable\n\n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write &lt; 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n\n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n\n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n\n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) &gt; 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n\n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n\n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n&gt;               raise child_exception_type(errno_num, err_msg, err_filename)\nE               PermissionError: [Errno 13] Permission denied: '/tmp/tmppfr1yqyf'\n\n/usr/lib/python3.10/subprocess.py:1863: PermissionError"},{"location":"analysis_baseline_cookiecutter/#test_logpytest_info_stdout_logging","title":"test_log.py::test_info_stdout_logging","text":"<pre>test_log.py::test_info_stdout_logging</pre><pre>\ncaplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7f8dd3905840&gt;\ninfo_logger = None\ninfo_messages = ['INFO: Welcome to Cookiecutter', 'INFO: Loading user config from home dir', 'ERROR: Aw, snap! Something went wrong']\n\n    def test_info_stdout_logging(caplog, info_logger, info_messages):\n        \"\"\"Test that stdout logs use info format and level.\"\"\"\n&gt;       [stream_handler] = info_logger.handlers\nE       AttributeError: 'NoneType' object has no attribute 'handlers'\n\ntests/test_log.py:75: AttributeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_logpytest_debug_stdout_logging","title":"test_log.py::test_debug_stdout_logging","text":"<pre>test_log.py::test_debug_stdout_logging</pre><pre>\ncaplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7f8dd37ffee0&gt;\ndebug_logger = None\ndebug_messages = ['INFO cookiecutter: Welcome to Cookiecutter', 'DEBUG cookiecutter: Generating project from pytest-plugin', 'INFO cookiecutter.foo: Loading user config from home dir', \"DEBUG cookiecutter.foo.bar: I don't know.\", 'DEBUG cookiecutter.foo.bar: I wanted to save the world.', 'ERROR cookiecutter.foo: Aw, snap! Something went wrong', ...]\n\n    def test_debug_stdout_logging(caplog, debug_logger, debug_messages):\n        \"\"\"Test that stdout logs use debug format and level.\"\"\"\n&gt;       [stream_handler] = debug_logger.handlers\nE       AttributeError: 'NoneType' object has no attribute 'handlers'\n\ntests/test_log.py:92: AttributeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_logpytest_debug_file_logging","title":"test_log.py::test_debug_file_logging","text":"<pre>test_log.py::test_debug_file_logging</pre><pre>\ncaplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7f8dd39054e0&gt;\ninfo_logger_with_file = None\ndebug_file = PosixPath('/tmp/pytest-of-root/pytest-0/test_debug_file_logging0/pytest-plugin.log')\ndebug_messages = ['INFO cookiecutter: Welcome to Cookiecutter', 'DEBUG cookiecutter: Generating project from pytest-plugin', 'INFO cookiecutter.foo: Loading user config from home dir', \"DEBUG cookiecutter.foo.bar: I don't know.\", 'DEBUG cookiecutter.foo.bar: I wanted to save the world.', 'ERROR cookiecutter.foo: Aw, snap! Something went wrong', ...]\n\n    def test_debug_file_logging(caplog, info_logger_with_file, debug_file, debug_messages):\n        \"\"\"Test that logging to stdout uses a different format and level than \\\n        the the file handler.\"\"\"\n&gt;       [file_handler, stream_handler] = info_logger_with_file.handlers\nE       AttributeError: 'NoneType' object has no attribute 'handlers'\n\ntests/test_log.py:110: AttributeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_mainpytest_original_cookiecutter_options_preserved_in__cookiecutter","title":"test_main.py::test_original_cookiecutter_options_preserved_in__cookiecutter","text":"<pre>test_main.py::test_original_cookiecutter_options_preserved_in__cookiecutter</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd37a9d20&gt;\nmocker = \nuser_config_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\n\n    def test_original_cookiecutter_options_preserved_in__cookiecutter(\n        monkeypatch,\n        mocker,\n        user_config_file,\n    ):\n        \"\"\"Preserve original context options.\n\n        Tests you can access the original context options via\n        `context['_cookiecutter']`.\n        \"\"\"\n        monkeypatch.chdir('tests/fake-repo-tmpl-_cookiecutter')\n        mock_generate_files = mocker.patch('cookiecutter.main.generate_files')\n&gt;       cookiecutter(\n            '.',\n            no_input=True,\n            replay=False,\n            config_file=user_config_file,\n        )\n\n/testbed/tests/test_main.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '.', checkout = None, no_input = True, extra_context = None\nreplay = False, overwrite_if_exists = False, output_dir = '.'\nconfig_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\n/testbed/cookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_mainpytest_replay_dump_template_name","title":"test_main.py::test_replay_dump_template_name","text":"<pre>test_main.py::test_replay_dump_template_name</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3543df0&gt;\nmocker = \nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\nuser_config_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\n\n    def test_replay_dump_template_name(\n        monkeypatch, mocker, user_config_data, user_config_file\n    ):\n        \"\"\"Check that replay_dump is called with a valid template_name.\n\n        Template name must not be a relative path.\n\n        Otherwise files such as ``..json`` are created, which are not just cryptic\n        but also later mistaken for replay files of other templates if invoked with\n        '.' and '--replay'.\n\n        Change the current working directory temporarily to 'tests/fake-repo-tmpl'\n        for this test and call cookiecutter with '.' for the target template.\n        \"\"\"\n        monkeypatch.chdir('tests/fake-repo-tmpl')\n\n        mock_replay_dump = mocker.patch('cookiecutter.main.dump')\n        mocker.patch('cookiecutter.main.generate_files')\n\n&gt;       cookiecutter(\n            '.',\n            no_input=True,\n            replay=False,\n            config_file=user_config_file,\n        )\n\n/testbed/tests/test_main.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '.', checkout = None, no_input = True, extra_context = None\nreplay = False, overwrite_if_exists = False, output_dir = '.'\nconfig_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\n/testbed/cookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_mainpytest_replay_load_template_name","title":"test_main.py::test_replay_load_template_name","text":"<pre>test_main.py::test_replay_load_template_name</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd37ab010&gt;\nmocker = \nuser_config_data = {'cookiecutters_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutters', 'replay_dir': '/tmp/pytest-of-root/pytest-0/user_dir0/cookiecutter_replay'}\nuser_config_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\n\n    def test_replay_load_template_name(\n        monkeypatch, mocker, user_config_data, user_config_file\n    ):\n        \"\"\"Check that replay_load is called correctly.\n\n        Calls require valid template_name that is not a relative path.\n\n        Change the current working directory temporarily to 'tests/fake-repo-tmpl'\n        for this test and call cookiecutter with '.' for the target template.\n        \"\"\"\n        monkeypatch.chdir('tests/fake-repo-tmpl')\n\n        mock_replay_load = mocker.patch('cookiecutter.main.load')\n        mocker.patch('cookiecutter.main.generate_context').return_value = {\n            'cookiecutter': {}\n        }\n        mocker.patch('cookiecutter.main.generate_files')\n        mocker.patch('cookiecutter.main.dump')\n\n&gt;       cookiecutter(\n            '.',\n            replay=True,\n            config_file=user_config_file,\n        )\n\n/testbed/tests/test_main.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '.', checkout = None, no_input = False, extra_context = None\nreplay = True, overwrite_if_exists = False, output_dir = '.'\nconfig_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\n/testbed/cookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_mainpytest_custom_replay_file","title":"test_main.py::test_custom_replay_file","text":"<pre>test_main.py::test_custom_replay_file</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd4386aa0&gt;\nmocker = \nuser_config_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\n\n    def test_custom_replay_file(monkeypatch, mocker, user_config_file):\n        \"\"\"Check that reply.load is called with the custom replay_file.\"\"\"\n        monkeypatch.chdir('tests/fake-repo-tmpl')\n\n        mock_replay_load = mocker.patch('cookiecutter.main.load')\n        mocker.patch('cookiecutter.main.generate_context').return_value = {\n            'cookiecutter': {}\n        }\n        mocker.patch('cookiecutter.main.generate_files')\n        mocker.patch('cookiecutter.main.dump')\n\n&gt;       cookiecutter(\n            '.',\n            replay='./custom-replay-file',\n            config_file=user_config_file,\n        )\n\n/testbed/tests/test_main.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '.', checkout = None, no_input = False, extra_context = None\nreplay = './custom-replay-file', overwrite_if_exists = False, output_dir = '.'\nconfig_file = '/tmp/pytest-of-root/pytest-0/user_dir0/config'\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\n/testbed/cookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_output_folderpytest_output_folder","title":"test_output_folder.py::test_output_folder","text":"<pre>test_output_folder.py::test_output_folder</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_output_folder')\n    def test_output_folder():\n        \"\"\"Tests should correctly create content, as output_folder does not yet exist.\"\"\"\n        context = generate.generate_context(\n            context_file='tests/test-output-folder/cookiecutter.json'\n        )\n&gt;       generate.generate_files(context=context, repo_dir='tests/test-output-folder')\n\ntests/test_output_folder.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-output-folder'\ncontext = OrderedDict([('full_name', 'Audrey Greenfeld'), ('year', '2014'), ('color', 'green'), ('letter', 'D'), ('folder_name', 'im_a.dir'), ('filename', 'im_a.file'), ('test_name', 'output_folder')])\noutput_dir = '.', overwrite_if_exists = False, skip_if_file_exists = False\naccept_hooks = True, keep_project_on_failure = False\n\n    def generate_files(repo_dir, context=None, output_dir='.',\n        overwrite_if_exists=False, skip_if_file_exists=False, accept_hooks=True,\n        keep_project_on_failure=False):\n        \"\"\"Render the templates and saves them to files.\n\n        :param repo_dir: Project template input directory.\n        :param context: Dict for populating the template's variables.\n        :param output_dir: Where to output the generated project dir into.\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n&gt;       template_dir = find_template(repo_dir)\nE       TypeError: find_template() missing 1 required positional argument: 'env'\n\ncookiecutter/generate.py:225: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_output_folderpytest_exception_when_output_folder_exists","title":"test_output_folder.py::test_exception_when_output_folder_exists","text":"<pre>test_output_folder.py::test_exception_when_output_folder_exists</pre><pre>\n@pytest.mark.usefixtures('clean_system', 'remove_output_folder')\n    def test_exception_when_output_folder_exists():\n        \"\"\"Tests should raise error as output folder created before `generate_files`.\"\"\"\n        context = generate.generate_context(\n            context_file='tests/test-output-folder/cookiecutter.json'\n        )\n&gt;       output_folder = context['cookiecutter']['test_name']\nE       KeyError: 'cookiecutter'\n\ntests/test_output_folder.py:53: KeyError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_pre_prompt_hookspytest_run_pre_prompt_python_hook","title":"test_pre_prompt_hooks.py::test_run_pre_prompt_python_hook","text":"<pre>test_pre_prompt_hooks.py::test_run_pre_prompt_python_hook</pre><pre>\nremove_tmp_repo_dir = ._func at 0x7f8dd311d990&gt;\n\n    def test_run_pre_prompt_python_hook(remove_tmp_repo_dir):\n        \"\"\"Verify pre_prompt.py runs and creates a copy of cookiecutter.json.\"\"\"\n&gt;       new_repo_dir = hooks.run_pre_prompt_hook(repo_dir='tests/test-pyhooks/')\n\ntests/test_pre_prompt_hooks.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyhooks/'\n\n    def run_pre_prompt_hook(repo_dir: 'os.PathLike[str]') -&gt;Path:\n        \"\"\"Run pre_prompt hook from repo directory.\n\n        :param repo_dir: Project template input directory.\n        \"\"\"\n        with work_in(repo_dir):\n            hook_path = find_hook('pre_prompt')\n            if hook_path:\n                logger.debug(\"Running pre_prompt hook\")\n&gt;               tmp_repo_dir = create_tmp_repo_dir()\nE               TypeError: create_tmp_repo_dir() missing 1 required positional argument: 'repo_dir'\n\ncookiecutter/hooks.py:157: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_pre_prompt_hookspytest_run_pre_prompt_python_hook_fail","title":"test_pre_prompt_hooks.py::test_run_pre_prompt_python_hook_fail","text":"<pre>test_pre_prompt_hooks.py::test_run_pre_prompt_python_hook_fail</pre><pre>\nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3ba5990&gt;\n\n    def test_run_pre_prompt_python_hook_fail(monkeypatch):\n        \"\"\"Verify pre_prompt.py will fail when a given env var is present.\"\"\"\n        message = 'Pre-Prompt Hook script failed'\n        with monkeypatch.context() as m:\n            m.setenv('COOKIECUTTER_FAIL_PRE_PROMPT', '1')\n            with pytest.raises(FailedHookException) as excinfo:\n&gt;               hooks.run_pre_prompt_hook(repo_dir='tests/test-pyhooks/')\n\ntests/test_pre_prompt_hooks.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyhooks/'\n\n    def run_pre_prompt_hook(repo_dir: 'os.PathLike[str]') -&gt;Path:\n        \"\"\"Run pre_prompt hook from repo directory.\n\n        :param repo_dir: Project template input directory.\n        \"\"\"\n        with work_in(repo_dir):\n            hook_path = find_hook('pre_prompt')\n            if hook_path:\n                logger.debug(\"Running pre_prompt hook\")\n&gt;               tmp_repo_dir = create_tmp_repo_dir()\nE               TypeError: create_tmp_repo_dir() missing 1 required positional argument: 'repo_dir'\n\ncookiecutter/hooks.py:157: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_pre_prompt_hookspytest_run_pre_prompt_shell_hook","title":"test_pre_prompt_hooks.py::test_run_pre_prompt_shell_hook","text":"<pre>test_pre_prompt_hooks.py::test_run_pre_prompt_shell_hook</pre><pre>\nremove_tmp_repo_dir = ._func at 0x7f8dd311f760&gt;\n\n    @pytest.mark.skipif(WINDOWS, reason='shell script will not run in Windows')\n    def test_run_pre_prompt_shell_hook(remove_tmp_repo_dir):\n        \"\"\"Verify pre_prompt.sh runs and creates a copy of cookiecutter.json.\"\"\"\n&gt;       new_repo_dir = hooks.run_pre_prompt_hook(repo_dir='tests/test-pyshellhooks/')\n\ntests/test_pre_prompt_hooks.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_dir = 'tests/test-pyshellhooks/'\n\n    def run_pre_prompt_hook(repo_dir: 'os.PathLike[str]') -&gt;Path:\n        \"\"\"Run pre_prompt hook from repo directory.\n\n        :param repo_dir: Project template input directory.\n        \"\"\"\n        with work_in(repo_dir):\n            hook_path = find_hook('pre_prompt')\n            if hook_path:\n                logger.debug(\"Running pre_prompt hook\")\n&gt;               tmp_repo_dir = create_tmp_repo_dir()\nE               TypeError: create_tmp_repo_dir() missing 1 required positional argument: 'repo_dir'\n\ncookiecutter/hooks.py:157: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestrendervariabletest_convert_to_str1-1","title":"test_prompt.py::TestRenderVariable::test_convert_to_str[1-1]","text":"<pre>test_prompt.py::TestRenderVariable::test_convert_to_str[1-1]</pre><pre>\nself = \nmocker = \nraw_var = 1, rendered_var = '1'\n\n    @pytest.mark.parametrize(\n        'raw_var, rendered_var',\n        [\n            (1, '1'),\n            (True, True),\n            ('foo', 'foo'),\n            ('{{cookiecutter.project}}', 'foobar'),\n            (None, None),\n        ],\n    )\n    def test_convert_to_str(self, mocker, raw_var, rendered_var):\n        \"\"\"Verify simple items correctly rendered to strings.\"\"\"\n        env = environment.StrictEnvironment()\n        from_string = mocker.patch(\n            'cookiecutter.utils.StrictEnvironment.from_string', wraps=env.from_string\n        )\n        context = {'project': 'foobar'}\n\n        result = prompt.render_variable(env, raw_var, context)\n&gt;       assert result == rendered_var\nE       AssertionError: assert 1 == '1'\n\ntests/test_prompt.py:44: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestrendervariabletest_convert_to_strcookiecutterproject-foobar","title":"test_prompt.py::TestRenderVariable::test_convert_to_str[{{cookiecutter.project}}-foobar]","text":"<pre>test_prompt.py::TestRenderVariable::test_convert_to_str[{{cookiecutter.project}}-foobar]</pre><pre>\nenv = \nraw = '{{cookiecutter.project}}', cookiecutter_dict = {'project': 'foobar'}\n\n    def render_variable(env, raw, cookiecutter_dict):\n        \"\"\"Render the next variable to be displayed in the user prompt.\n\n        Inside the prompting taken from the cookiecutter.json file, this renders\n        the next variable. For example, if a project_name is \"Peanut Butter\n        Cookie\", the repo_name could be be rendered with:\n\n            `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\n        This is then presented to the user as the default.\n\n        :param Environment env: A Jinja2 Environment object.\n        :param raw: The next value to be prompted for by the user.\n        :param dict cookiecutter_dict: The current context as it's gradually\n            being populated with variables.\n        :return: The rendered value for the default variable.\n        \"\"\"\n        if not isinstance(raw, str):\n            return raw\n\n        template = env.from_string(raw)\n        try:\n&gt;           return template.render(**cookiecutter_dict)\n\ncookiecutter/prompt.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1304: in render\n    self.environment.handle_exception()\n.venv/lib/python3.10/site-packages/jinja2/environment.py:939: in handle_exception\n    raise rewrite_traceback_stack(source=source)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nobj = Undefined, attribute = 'project'\n\n    def getattr(self, obj: t.Any, attribute: str) -&gt; t.Any:\n        \"\"\"Get an item or attribute of an object but prefer the attribute.\n        Unlike :meth:`getitem` the attribute *must* be a string.\n        \"\"\"\n        try:\n&gt;           return getattr(obj, attribute)\nE           jinja2.exceptions.UndefinedError: 'cookiecutter' is undefined\n\n.venv/lib/python3.10/site-packages/jinja2/environment.py:487: UndefinedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nmocker = \nraw_var = '{{cookiecutter.project}}', rendered_var = 'foobar'\n\n    @pytest.mark.parametrize(\n        'raw_var, rendered_var',\n        [\n            (1, '1'),\n            (True, True),\n            ('foo', 'foo'),\n            ('{{cookiecutter.project}}', 'foobar'),\n            (None, None),\n        ],\n    )\n    def test_convert_to_str(self, mocker, raw_var, rendered_var):\n        \"\"\"Verify simple items correctly rendered to strings.\"\"\"\n        env = environment.StrictEnvironment()\n        from_string = mocker.patch(\n            'cookiecutter.utils.StrictEnvironment.from_string', wraps=env.from_string\n        )\n        context = {'project': 'foobar'}\n\n&gt;       result = prompt.render_variable(env, raw_var, context)\n\ntests/test_prompt.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nenv = \nraw = '{{cookiecutter.project}}', cookiecutter_dict = {'project': 'foobar'}\n\n    def render_variable(env, raw, cookiecutter_dict):\n        \"\"\"Render the next variable to be displayed in the user prompt.\n\n        Inside the prompting taken from the cookiecutter.json file, this renders\n        the next variable. For example, if a project_name is \"Peanut Butter\n        Cookie\", the repo_name could be be rendered with:\n\n            `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\n        This is then presented to the user as the default.\n\n        :param Environment env: A Jinja2 Environment object.\n        :param raw: The next value to be prompted for by the user.\n        :param dict cookiecutter_dict: The current context as it's gradually\n            being populated with variables.\n        :return: The rendered value for the default variable.\n        \"\"\"\n        if not isinstance(raw, str):\n            return raw\n\n        template = env.from_string(raw)\n        try:\n            return template.render(**cookiecutter_dict)\n        except UndefinedError as err:\n&gt;           raise UndefinedVariableInTemplate(str(err), err, cookiecutter_dict)\nE           cookiecutter.exceptions.UndefinedVariableInTemplate: 'cookiecutter' is undefined. Error message: 'cookiecutter' is undefined. Context: {'project': 'foobar'}\n\ncookiecutter/prompt.py:162: UndefinedVariableInTemplate"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestrendervariabletest_convert_to_str_complex_variablesraw_var0-rendered_var0","title":"test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var0-rendered_var0]","text":"<pre>test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var0-rendered_var0]</pre><pre>\nself = \nraw_var = {1: True, 'foo': False}, rendered_var = {'1': True, 'foo': False}\n\n    @pytest.mark.parametrize(\n        'raw_var, rendered_var',\n        [\n            ({1: True, 'foo': False}, {'1': True, 'foo': False}),\n            (\n                {'{{cookiecutter.project}}': ['foo', 1], 'bar': False},\n                {'foobar': ['foo', '1'], 'bar': False},\n            ),\n            (['foo', '{{cookiecutter.project}}', None], ['foo', 'foobar', None]),\n        ],\n    )\n    def test_convert_to_str_complex_variables(self, raw_var, rendered_var):\n        \"\"\"Verify tree items correctly rendered.\"\"\"\n        env = environment.StrictEnvironment()\n        context = {'project': 'foobar'}\n\n        result = prompt.render_variable(env, raw_var, context)\n&gt;       assert result == rendered_var\nE       AssertionError: assert {1: True, 'foo': False} == {'1': True, 'foo': False}\nE         \nE         Common items:\nE         {'foo': False}\nE         Left contains 1 more item:\nE         {1: True}\nE         Right contains 1 more item:\nE         {'1': True}\nE         \nE         Full diff:\nE           {\nE         -     '1': True,\nE         ?     - -\nE         +     1: True,\nE               'foo': False,\nE           }\n\ntests/test_prompt.py:71: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestrendervariabletest_convert_to_str_complex_variablesraw_var1-rendered_var1","title":"test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var1-rendered_var1]","text":"<pre>test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var1-rendered_var1]</pre><pre>\nself = \nraw_var = {'bar': False, '{{cookiecutter.project}}': ['foo', 1]}\nrendered_var = {'bar': False, 'foobar': ['foo', '1']}\n\n    @pytest.mark.parametrize(\n        'raw_var, rendered_var',\n        [\n            ({1: True, 'foo': False}, {'1': True, 'foo': False}),\n            (\n                {'{{cookiecutter.project}}': ['foo', 1], 'bar': False},\n                {'foobar': ['foo', '1'], 'bar': False},\n            ),\n            (['foo', '{{cookiecutter.project}}', None], ['foo', 'foobar', None]),\n        ],\n    )\n    def test_convert_to_str_complex_variables(self, raw_var, rendered_var):\n        \"\"\"Verify tree items correctly rendered.\"\"\"\n        env = environment.StrictEnvironment()\n        context = {'project': 'foobar'}\n\n        result = prompt.render_variable(env, raw_var, context)\n&gt;       assert result == rendered_var\nE       AssertionError: assert {'{{cookiecutter.project}}': ['foo', 1], 'bar': False} == {'foobar': ['foo', '1'], 'bar': False}\nE         \nE         Common items:\nE         {'bar': False}\nE         Left contains 1 more item:\nE         {'{{cookiecutter.project}}': ['foo', 1]}\nE         Right contains 1 more item:\nE         {'foobar': ['foo', '1']}\nE         \nE         Full diff:\nE           {\nE               'bar': False,\nE         -     'foobar': [\nE         +     '{{cookiecutter.project}}': [\nE                   'foo',\nE         -         '1',\nE         ?         - -\nE         +         1,\nE               ],\nE           }\n\ntests/test_prompt.py:71: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestrendervariabletest_convert_to_str_complex_variablesraw_var2-rendered_var2","title":"test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var2-rendered_var2]","text":"<pre>test_prompt.py::TestRenderVariable::test_convert_to_str_complex_variables[raw_var2-rendered_var2]</pre><pre>\nself = \nraw_var = ['foo', '{{cookiecutter.project}}', None]\nrendered_var = ['foo', 'foobar', None]\n\n    @pytest.mark.parametrize(\n        'raw_var, rendered_var',\n        [\n            ({1: True, 'foo': False}, {'1': True, 'foo': False}),\n            (\n                {'{{cookiecutter.project}}': ['foo', 1], 'bar': False},\n                {'foobar': ['foo', '1'], 'bar': False},\n            ),\n            (['foo', '{{cookiecutter.project}}', None], ['foo', 'foobar', None]),\n        ],\n    )\n    def test_convert_to_str_complex_variables(self, raw_var, rendered_var):\n        \"\"\"Verify tree items correctly rendered.\"\"\"\n        env = environment.StrictEnvironment()\n        context = {'project': 'foobar'}\n\n        result = prompt.render_variable(env, raw_var, context)\n&gt;       assert result == rendered_var\nE       AssertionError: assert ['foo', '{{cookiecutter.project}}', None] == ['foo', 'foobar', None]\nE         \nE         At index 1 diff: '{{cookiecutter.project}}' != 'foobar'\nE         \nE         Full diff:\nE           [\nE               'foo',\nE         -     'foobar',\nE         +     '{{cookiecutter.project}}',\nE               None,\nE           ]\n\ntests/test_prompt.py:71: AssertionError"},{"location":"analysis_baseline_cookiecutter/#input","title":"input]","text":"<pre>input]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd2ee60b0&gt;\ncontext = {'cookiecutter': {'full_name': 'Your Name'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {'cookiecutter': {'full_name': 'Your Name'}},\n            {'cookiecutter': {'full_name': '\u0158ekni \u010di napi\u0161 sv\u00e9 jm\u00e9no'}},\n        ],\n        ids=['ASCII default prompt/input', 'Unicode default prompt/input'],\n    )\n    def test_prompt_for_config(self, monkeypatch, context):\n        \"\"\"Verify `prompt_for_config` call `read_user_variable` on text request.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context)\n\ntests/test_prompt.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontext = {'cookiecutter': {'full_name': 'Your Name'}}, no_input = False\n\n    def prompt_for_config(context, no_input=False):\n        \"\"\"Prompt user to enter a new config.\n\n        :param dict context: Source for field names and sample values.\n        :param no_input: Do not prompt for user input and use only values from context.\n        \"\"\"\n        cookiecutter_dict = OrderedDict([])\n        env = create_env_with_context(context)\n\n        for key, raw in context['cookiecutter'].items():\n            if key.startswith('_'):\n                cookiecutter_dict[key] = raw\n                continue\n\n            if isinstance(raw, dict):\n                cookiecutter_dict[key] = prompt_choice_for_config(\n                    cookiecutter_dict, env, key, raw, no_input\n                )\n            else:\n                if no_input:\n                    cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n                else:\n&gt;                   cookiecutter_dict[key] = read_user_variable(key, raw)\nE                   TypeError: TestPrompt.test_prompt_for_config..() missing 2 required positional arguments: 'prompts' and 'prefix'\n\ncookiecutter/prompt.py:228: TypeError"},{"location":"analysis_baseline_cookiecutter/#input_1","title":"input]","text":"<pre>input]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3c436d0&gt;\ncontext = {'cookiecutter': {'full_name': '\u0158ekni \u010di napi\u0161 sv\u00e9 jm\u00e9no'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {'cookiecutter': {'full_name': 'Your Name'}},\n            {'cookiecutter': {'full_name': '\u0158ekni \u010di napi\u0161 sv\u00e9 jm\u00e9no'}},\n        ],\n        ids=['ASCII default prompt/input', 'Unicode default prompt/input'],\n    )\n    def test_prompt_for_config(self, monkeypatch, context):\n        \"\"\"Verify `prompt_for_config` call `read_user_variable` on text request.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context)\n\ntests/test_prompt.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontext = {'cookiecutter': {'full_name': '\u0158ekni \u010di napi\u0161 sv\u00e9 jm\u00e9no'}}\nno_input = False\n\n    def prompt_for_config(context, no_input=False):\n        \"\"\"Prompt user to enter a new config.\n\n        :param dict context: Source for field names and sample values.\n        :param no_input: Do not prompt for user input and use only values from context.\n        \"\"\"\n        cookiecutter_dict = OrderedDict([])\n        env = create_env_with_context(context)\n\n        for key, raw in context['cookiecutter'].items():\n            if key.startswith('_'):\n                cookiecutter_dict[key] = raw\n                continue\n\n            if isinstance(raw, dict):\n                cookiecutter_dict[key] = prompt_choice_for_config(\n                    cookiecutter_dict, env, key, raw, no_input\n                )\n            else:\n                if no_input:\n                    cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n                else:\n&gt;                   cookiecutter_dict[key] = read_user_variable(key, raw)\nE                   TypeError: TestPrompt.test_prompt_for_config..() missing 2 required positional arguments: 'prompts' and 'prefix'\n\ncookiecutter/prompt.py:228: TypeError"},{"location":"analysis_baseline_cookiecutter/#input_2","title":"input]","text":"<pre>input]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd31757b0&gt;\ncontext = {'cookiecutter': {'__prompts__': {'check': 'Checking', 'full_name': 'Name please'}, 'check': ['yes', 'no'], 'full_name': 'Your Name', 'nothing': 'ok'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    'nothing': 'ok',\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': 'Checking',\n                    },\n                }\n            },\n        ],\n        ids=['ASCII default prompt/input'],\n    )\n    def test_prompt_for_config_with_human_prompts(self, monkeypatch, context):\n        \"\"\"Verify call `read_user_variable` on request when human-readable prompts.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_yes_no',\n            lambda var, default, prompts, prefix: default,\n        )\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_choice',\n            lambda var, default, prompts, prefix: default,\n        )\n\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context)\n\ntests/test_prompt.py:127: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontext = {'cookiecutter': {'__prompts__': {'check': 'Checking', 'full_name': 'Name please'}, 'check': ['yes', 'no'], 'full_name': 'Your Name', 'nothing': 'ok'}}\nno_input = False\n\n    def prompt_for_config(context, no_input=False):\n        \"\"\"Prompt user to enter a new config.\n\n        :param dict context: Source for field names and sample values.\n        :param no_input: Do not prompt for user input and use only values from context.\n        \"\"\"\n        cookiecutter_dict = OrderedDict([])\n        env = create_env_with_context(context)\n\n        for key, raw in context['cookiecutter'].items():\n            if key.startswith('_'):\n                cookiecutter_dict[key] = raw\n                continue\n\n            if isinstance(raw, dict):\n                cookiecutter_dict[key] = prompt_choice_for_config(\n                    cookiecutter_dict, env, key, raw, no_input\n                )\n            else:\n                if no_input:\n                    cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n                else:\n&gt;                   cookiecutter_dict[key] = read_user_variable(key, raw)\nE                   TypeError: TestPrompt.test_prompt_for_config_with_human_prompts..() missing 2 required positional arguments: 'prompts' and 'prefix'\n\ncookiecutter/prompt.py:228: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_prompt_for_config_with_human_choicescontext0","title":"test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context0]","text":"<pre>test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context0]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd37aaf50&gt;\ncontext = {'cookiecutter': {'__prompts__': {'check': 'Checking'}, 'check': ['yes', 'no'], 'full_name': 'Your Name'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'check': 'Checking',\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'__prompt__': 'Checking', 'yes': 'Yes', 'no': 'No'},\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'no': 'No'},\n                    },\n                }\n            },\n        ],\n    )\n    def test_prompt_for_config_with_human_choices(self, monkeypatch, context):\n        \"\"\"Test prompts when human-readable labels for user choices.\"\"\"\n        runner = click.testing.CliRunner()\n        with runner.isolation(input=\"\\n\\n\\n\"):\n            cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert dict(cookiecutter_dict) == {'full_name': 'Your Name', 'check': 'yes'}\nE       AssertionError: assert {'full_name': 'Your Name', 'check': ['yes', 'no'], '__prompts__': {'check': 'Checking'}} == {'full_name': 'Your Name', 'check': 'yes'}\nE         \nE         Common items:\nE         {'full_name': 'Your Name'}\nE         Differing items:\nE         {'check': ['yes', 'no']} != {'check': 'yes'}\nE         Left contains 1 more item:\nE         {'__prompts__': {'check': 'Checking'}}\nE         \nE         Full diff:\nE           {\nE         +     '__prompts__': {\nE         +         'check': 'Checking',\nE         +     },\nE         -     'check': 'yes',\nE         ?              ^^^^^^\nE         +     'check': [\nE         ?              ^\nE         +         'yes',\nE         +         'no',\nE         +     ],\nE               'full_name': 'Your Name',\nE           }\n\ntests/test_prompt.py:170: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_prompt_for_config_with_human_choicescontext1","title":"test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context1]","text":"<pre>test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context1]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd2e8e440&gt;\ncontext = {'cookiecutter': {'__prompts__': {'check': {'__prompt__': 'Checking', 'no': 'No', 'yes': 'Yes'}, 'full_name': 'Name please'}, 'check': ['yes', 'no'], 'full_name': 'Your Name'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'check': 'Checking',\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'__prompt__': 'Checking', 'yes': 'Yes', 'no': 'No'},\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'no': 'No'},\n                    },\n                }\n            },\n        ],\n    )\n    def test_prompt_for_config_with_human_choices(self, monkeypatch, context):\n        \"\"\"Test prompts when human-readable labels for user choices.\"\"\"\n        runner = click.testing.CliRunner()\n        with runner.isolation(input=\"\\n\\n\\n\"):\n            cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert dict(cookiecutter_dict) == {'full_name': 'Your Name', 'check': 'yes'}\nE       AssertionError: assert {'full_name': 'Your Name', 'check': ['yes', 'no'], '__prompts__': {'full_name': 'Name please', 'check': {'__prompt__': 'Checking', 'yes': 'Yes', 'no': 'No'}}} == {'full_name': 'Your Name', 'check': 'yes'}\nE         \nE         Common items:\nE         {'full_name': 'Your Name'}\nE         Differing items:\nE         {'check': ['yes', 'no']} != {'check': 'yes'}\nE         Left contains 1 more item:\nE         {'__prompts__': {'check': {'__prompt__': 'Checking', 'no': 'No', 'yes': 'Yes'},\nE                          'full_name': 'Name please'}}\nE         \nE         Full diff:\nE           {\nE         +     '__prompts__': {\nE         +         'check': {\nE         +             '__prompt__': 'Checking',\nE         +             'no': 'No',\nE         +             'yes': 'Yes',\nE         +         },\nE         +         'full_name': 'Name please',\nE         +     },\nE         -     'check': 'yes',\nE         ?              ^^^^^^\nE         +     'check': [\nE         ?              ^\nE         +         'yes',\nE         +         'no',\nE         +     ],\nE               'full_name': 'Your Name',\nE           }\n\ntests/test_prompt.py:170: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_prompt_for_config_with_human_choicescontext2","title":"test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context2]","text":"<pre>test_prompt.py::TestPrompt::test_prompt_for_config_with_human_choices[context2]</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3498520&gt;\ncontext = {'cookiecutter': {'__prompts__': {'check': {'no': 'No'}, 'full_name': 'Name please'}, 'check': ['yes', 'no'], 'full_name': 'Your Name'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        [\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'check': 'Checking',\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'__prompt__': 'Checking', 'yes': 'Yes', 'no': 'No'},\n                    },\n                }\n            },\n            {\n                'cookiecutter': {\n                    'full_name': 'Your Name',\n                    'check': ['yes', 'no'],\n                    '__prompts__': {\n                        'full_name': 'Name please',\n                        'check': {'no': 'No'},\n                    },\n                }\n            },\n        ],\n    )\n    def test_prompt_for_config_with_human_choices(self, monkeypatch, context):\n        \"\"\"Test prompts when human-readable labels for user choices.\"\"\"\n        runner = click.testing.CliRunner()\n        with runner.isolation(input=\"\\n\\n\\n\"):\n            cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert dict(cookiecutter_dict) == {'full_name': 'Your Name', 'check': 'yes'}\nE       AssertionError: assert {'full_name': 'Your Name', 'check': ['yes', 'no'], '__prompts__': {'full_name': 'Name please', 'check': {'no': 'No'}}} == {'full_name': 'Your Name', 'check': 'yes'}\nE         \nE         Common items:\nE         {'full_name': 'Your Name'}\nE         Differing items:\nE         {'check': ['yes', 'no']} != {'check': 'yes'}\nE         Left contains 1 more item:\nE         {'__prompts__': {'check': {'no': 'No'}, 'full_name': 'Name please'}}\nE         \nE         Full diff:\nE           {\nE         +     '__prompts__': {\nE         +         'check': {\nE         +             'no': 'No',\nE         +         },\nE         +         'full_name': 'Name please',\nE         +     },\nE         -     'check': 'yes',\nE         ?              ^^^^^^\nE         +     'check': [\nE         ?              ^\nE         +         'yes',\nE         +         'no',\nE         +     ],\nE               'full_name': 'Your Name',\nE           }\n\ntests/test_prompt.py:170: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_prompt_for_config_dict","title":"test_prompt.py::TestPrompt::test_prompt_for_config_dict","text":"<pre>test_prompt.py::TestPrompt::test_prompt_for_config_dict</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd37ccb50&gt;\n\n    def test_prompt_for_config_dict(self, monkeypatch):\n        \"\"\"Verify `prompt_for_config` call `read_user_variable` on dict request.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_dict',\n            lambda var, default, prompts, prefix: {\"key\": \"value\", \"integer\": 37},\n        )\n        context = {'cookiecutter': {'details': {}}}\n\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context)\n\ntests/test_prompt.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:221: in prompt_for_config\n    cookiecutter_dict[key] = prompt_choice_for_config(\ncookiecutter/prompt.py:202: in prompt_choice_for_config\n    choice = read_user_choice(key, list(rendered_options.keys()), prompts=prompts, prefix=prefix)\ncookiecutter/prompt.py:90: in read_user_choice\n    choice = Prompt.ask(\"Enter the number of your choice\", choices=choices, default=\"0\")\n.venv/lib/python3.10/site-packages/rich/prompt.py:149: in ask\n    return _prompt(default=default, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:292: in __call__\n    value = self.get_input(self.console, prompt, self.password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:211: in get_input\n    return console.input(prompt, password=password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/console.py:2156: in input\n    result = input()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.capture.DontReadFromInput object at 0x7f8dd4a5bee0&gt;, size = -1\n\n    def read(self, size: int = -1) -&gt; str:\n&gt;       raise OSError(\n            \"pytest: reading from stdin while output is captured!  Consider using `-s`.\"\n        )\nE       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.\n\n.venv/lib/python3.10/site-packages/_pytest/capture.py:209: OSError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_should_render_dict","title":"test_prompt.py::TestPrompt::test_should_render_dict","text":"<pre>test_prompt.py::TestPrompt::test_should_render_dict</pre><pre>\nself = \n\n    def test_should_render_dict(self):\n        \"\"\"Verify template inside dictionary variable rendered.\"\"\"\n        context = {\n            'cookiecutter': {\n                'project_name': 'Slartibartfast',\n                'details': {\n                    '{{cookiecutter.project_name}}': '{{cookiecutter.project_name}}'\n                },\n            }\n        }\n\n        cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)\n&gt;       assert cookiecutter_dict == {\n            'project_name': 'Slartibartfast',\n            'details': {'Slartibartfast': 'Slartibartfast'},\n        }\nE       AssertionError: assert OrderedDict([('project_name', 'Slartibartfast'), ('details', '{{cookiecutter.project_name}}')]) == {'project_name': 'Slartibartfast', 'details': {'Slartibartfast': 'Slartibartfast'}}\nE         \nE         Common items:\nE         {'project_name': 'Slartibartfast'}\nE         Differing items:\nE         {'details': '{{cookiecutter.project_name}}'} != {'details': {'Slartibartfast': 'Slartibartfast'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         +     'details': '{{cookiecutter.project_name}}',\nE         - {\nE         -     'details': {\nE         -         'Slartibartfast': 'Slartibartfast',\nE         -     },\nE               'project_name': 'Slartibartfast',\nE         - }\nE         + })\n\ntests/test_prompt.py:195: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_should_render_deep_dict","title":"test_prompt.py::TestPrompt::test_should_render_deep_dict","text":"<pre>test_prompt.py::TestPrompt::test_should_render_deep_dict</pre><pre>\nself = \n\n    def test_should_render_deep_dict(self):\n        \"\"\"Verify nested structures like dict in dict, rendered correctly.\"\"\"\n        context = {\n            'cookiecutter': {\n                'project_name': \"Slartibartfast\",\n                'details': {\n                    \"key\": \"value\",\n                    \"integer_key\": 37,\n                    \"other_name\": '{{cookiecutter.project_name}}',\n                    \"dict_key\": {\n                        \"deep_key\": \"deep_value\",\n                        \"deep_integer\": 42,\n                        \"deep_other_name\": '{{cookiecutter.project_name}}',\n                        \"deep_list\": [\n                            \"deep value 1\",\n                            \"{{cookiecutter.project_name}}\",\n                            \"deep value 3\",\n                        ],\n                    },\n                    \"list_key\": [\n                        \"value 1\",\n                        \"{{cookiecutter.project_name}}\",\n                        \"value 3\",\n                    ],\n                },\n            }\n        }\n\n        cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)\n&gt;       assert cookiecutter_dict == {\n            'project_name': \"Slartibartfast\",\n            'details': {\n                \"key\": \"value\",\n                \"integer_key\": \"37\",\n                \"other_name\": \"Slartibartfast\",\n                \"dict_key\": {\n                    \"deep_key\": \"deep_value\",\n                    \"deep_integer\": \"42\",\n                    \"deep_other_name\": \"Slartibartfast\",\n                    \"deep_list\": [\"deep value 1\", \"Slartibartfast\", \"deep value 3\"],\n                },\n                \"list_key\": [\"value 1\", \"Slartibartfast\", \"value 3\"],\n            },\n        }\nE       AssertionError: assert OrderedDict([('project_name', 'Slartibartfast'), ('details', 'value')]) == {'project_name': 'Slartibartfast', 'details': {'key': 'value', 'integer_key': '37', 'other_name': 'Slartibartfast', 'dict_key': {'deep_key': 'deep_value', 'deep_integer': '42', 'deep_other_name': 'Slartibartfast', 'deep_list': ['deep value 1', 'Slartibartfast', 'deep value 3']}, 'list_key': ['value 1', 'Slartibartfast', 'value 3']}}\nE         \nE         Common items:\nE         {'project_name': 'Slartibartfast'}\nE         Differing items:\nE         {'details': 'value'} != {'details': {'dict_key': {'deep_integer': '42', 'deep_key': 'deep_value', 'deep_list': ['deep value 1', 'Slartibartfas...e': 'Slartibartfast'}, 'integer_key': '37', 'key': 'value', 'list_key': ['value 1', 'Slartibartfast', 'value 3'], ...}}\nE         \nE         Full diff:\nE         - {\nE         + OrderedDict({\nE         -     'details': {\nE         ?                ^\nE         +     'details': 'value',\nE         ?                ^^^^^^^^\nE         -         'dict_key': {\nE         -             'deep_integer': '42',\nE         -             'deep_key': 'deep_value',\nE         -             'deep_list': [\nE         -                 'deep value 1',\nE         -                 'Slartibartfast',\nE         -                 'deep value 3',\nE         -             ],\nE         -             'deep_other_name': 'Slartibartfast',\nE         -         },\nE         -         'integer_key': '37',\nE         -         'key': 'value',\nE         -         'list_key': [\nE         -             'value 1',\nE         -             'Slartibartfast',\nE         -             'value 3',\nE         -         ],\nE         -         'other_name': 'Slartibartfast',\nE         -     },\nE               'project_name': 'Slartibartfast',\nE         - }\nE         + })\n\ntests/test_prompt.py:229: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_should_render_deep_dict_with_human_prompts","title":"test_prompt.py::TestPrompt::test_should_render_deep_dict_with_human_prompts","text":"<pre>test_prompt.py::TestPrompt::test_should_render_deep_dict_with_human_prompts</pre><pre>\nself = \n\n    def test_should_render_deep_dict_with_human_prompts(self):\n        \"\"\"Verify dict rendered correctly when human-readable prompts.\"\"\"\n        context = {\n            'cookiecutter': {\n                'project_name': \"Slartibartfast\",\n                'details': {\n                    \"key\": \"value\",\n                    \"integer_key\": 37,\n                    \"other_name\": '{{cookiecutter.project_name}}',\n                    \"dict_key\": {\n                        \"deep_key\": \"deep_value\",\n                    },\n                },\n                '__prompts__': {'project_name': 'Project name'},\n            }\n        }\n        cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)\n&gt;       assert cookiecutter_dict == {\n            'project_name': \"Slartibartfast\",\n            'details': {\n                \"key\": \"value\",\n                \"integer_key\": \"37\",\n                \"other_name\": \"Slartibartfast\",\n                \"dict_key\": {\n                    \"deep_key\": \"deep_value\",\n                },\n            },\n        }\nE       AssertionError: assert OrderedDict([('project_name', 'Slartibartfast'), ('details', 'value'), ('__prompts__', {'project_name': 'Project name'})]) == {'project_name': 'Slartibartfast', 'details': {'key': 'value', 'integer_key': '37', 'other_name': 'Slartibartfast', 'dict_key': {'deep_key': 'deep_value'}}}\nE         \nE         Common items:\nE         {'project_name': 'Slartibartfast'}\nE         Differing items:\nE         {'details': 'value'} != {'details': {'dict_key': {'deep_key': 'deep_value'}, 'integer_key': '37', 'key': 'value', 'other_name': 'Slartibartfast'}}\nE         Left contains 1 more item:\nE         {'__prompts__': {'project_name': 'Project name'}}\nE         \nE         Full diff:\nE         + OrderedDict({\nE         +     '__prompts__': {\nE         +         'project_name': 'Project name',\nE         - {\nE         -     'details': {\nE         -         'dict_key': {\nE         -             'deep_key': 'deep_value',\nE         -         },\nE         -         'integer_key': '37',\nE         -         'key': 'value',\nE         -         'other_name': 'Slartibartfast',\nE               },\nE         +     'details': 'value',\nE               'project_name': 'Slartibartfast',\nE         - }\nE         + })\n\ntests/test_prompt.py:262: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_internal_use_no_human_prompts","title":"test_prompt.py::TestPrompt::test_internal_use_no_human_prompts","text":"<pre>test_prompt.py::TestPrompt::test_internal_use_no_human_prompts</pre><pre>\nself = \n\n    def test_internal_use_no_human_prompts(self):\n        \"\"\"Verify dict rendered correctly when human-readable prompts empty.\"\"\"\n        context = {\n            'cookiecutter': {\n                'project_name': \"Slartibartfast\",\n                '__prompts__': {},\n            }\n        }\n        cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)\n&gt;       assert cookiecutter_dict == {\n            'project_name': \"Slartibartfast\",\n        }\nE       AssertionError: assert OrderedDict([('project_name', 'Slartibartfast'), ('__prompts__', {})]) == {'project_name': 'Slartibartfast'}\nE         \nE         Common items:\nE         {'project_name': 'Slartibartfast'}\nE         Left contains 1 more item:\nE         {'__prompts__': {}}\nE         \nE         Full diff:\nE         - {\nE         + OrderedDict({\nE         +     '__prompts__': {},\nE               'project_name': 'Slartibartfast',\nE         - }\nE         + })\n\ntests/test_prompt.py:283: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_prompt_for_templated_config","title":"test_prompt.py::TestPrompt::test_prompt_for_templated_config","text":"<pre>test_prompt.py::TestPrompt::test_prompt_for_templated_config</pre><pre>\nself = \nmonkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8dd3801c90&gt;\n\n    def test_prompt_for_templated_config(self, monkeypatch):\n        \"\"\"Verify Jinja2 templating works in unicode prompts.\"\"\"\n        monkeypatch.setattr(\n            'cookiecutter.prompt.read_user_variable',\n            lambda var, default, prompts, prefix: default,\n        )\n        context = {\n            'cookiecutter': OrderedDict(\n                [\n                    ('project_name', 'A New Project'),\n                    (\n                        'pkg_name',\n                        '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}',\n                    ),\n                ]\n            )\n        }\n\n        exp_cookiecutter_dict = {\n            'project_name': 'A New Project',\n            'pkg_name': 'anewproject',\n        }\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context)\n\ntests/test_prompt.py:309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncontext = {'cookiecutter': OrderedDict([('project_name', 'A New Project'), ('pkg_name', '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}')])}\nno_input = False\n\n    def prompt_for_config(context, no_input=False):\n        \"\"\"Prompt user to enter a new config.\n\n        :param dict context: Source for field names and sample values.\n        :param no_input: Do not prompt for user input and use only values from context.\n        \"\"\"\n        cookiecutter_dict = OrderedDict([])\n        env = create_env_with_context(context)\n\n        for key, raw in context['cookiecutter'].items():\n            if key.startswith('_'):\n                cookiecutter_dict[key] = raw\n                continue\n\n            if isinstance(raw, dict):\n                cookiecutter_dict[key] = prompt_choice_for_config(\n                    cookiecutter_dict, env, key, raw, no_input\n                )\n            else:\n                if no_input:\n                    cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n                else:\n&gt;                   cookiecutter_dict[key] = read_user_variable(key, raw)\nE                   TypeError: TestPrompt.test_prompt_for_templated_config..() missing 2 required positional arguments: 'prompts' and 'prefix'\n\ncookiecutter/prompt.py:228: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestprompttest_should_render_private_variables_with_two_underscores","title":"test_prompt.py::TestPrompt::test_should_render_private_variables_with_two_underscores","text":"<pre>test_prompt.py::TestPrompt::test_should_render_private_variables_with_two_underscores</pre><pre>\nenv = \nraw = '{{ cookiecutter.foo|lower }}'\ncookiecutter_dict = OrderedDict([('foo', 'Hello world'), ('bar', 123)])\n\n    def render_variable(env, raw, cookiecutter_dict):\n        \"\"\"Render the next variable to be displayed in the user prompt.\n\n        Inside the prompting taken from the cookiecutter.json file, this renders\n        the next variable. For example, if a project_name is \"Peanut Butter\n        Cookie\", the repo_name could be be rendered with:\n\n            `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\n        This is then presented to the user as the default.\n\n        :param Environment env: A Jinja2 Environment object.\n        :param raw: The next value to be prompted for by the user.\n        :param dict cookiecutter_dict: The current context as it's gradually\n            being populated with variables.\n        :return: The rendered value for the default variable.\n        \"\"\"\n        if not isinstance(raw, str):\n            return raw\n\n        template = env.from_string(raw)\n        try:\n&gt;           return template.render(**cookiecutter_dict)\n\ncookiecutter/prompt.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1304: in render\n    self.environment.handle_exception()\n.venv/lib/python3.10/site-packages/jinja2/environment.py:939: in handle_exception\n    raise rewrite_traceback_stack(source=source)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nobj = Undefined, attribute = 'foo'\n\n    def getattr(self, obj: t.Any, attribute: str) -&gt; t.Any:\n        \"\"\"Get an item or attribute of an object but prefer the attribute.\n        Unlike :meth:`getitem` the attribute *must* be a string.\n        \"\"\"\n        try:\n&gt;           return getattr(obj, attribute)\nE           jinja2.exceptions.UndefinedError: 'cookiecutter' is undefined\n\n.venv/lib/python3.10/site-packages/jinja2/environment.py:487: UndefinedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \n\n    def test_should_render_private_variables_with_two_underscores(self):\n        \"\"\"Test rendering of private variables with two underscores.\n\n        There are three cases:\n        1. Variables beginning with a single underscore are private and not rendered.\n        2. Variables beginning with a double underscore are private and are rendered.\n        3. Variables beginning with anything other than underscores are not private and\n           are rendered.\n        \"\"\"\n        context = {\n            'cookiecutter': OrderedDict(\n                [\n                    ('foo', 'Hello world'),\n                    ('bar', 123),\n                    ('rendered_foo', '{{ cookiecutter.foo|lower }}'),\n                    ('rendered_bar', 123),\n                    ('_hidden_foo', '{{ cookiecutter.foo|lower }}'),\n                    ('_hidden_bar', 123),\n                    ('__rendered_hidden_foo', '{{ cookiecutter.foo|lower }}'),\n                    ('__rendered_hidden_bar', 123),\n                ]\n            )\n        }\n&gt;       cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)\n\ntests/test_prompt.py:347: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:226: in prompt_for_config\n    cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nenv = \nraw = '{{ cookiecutter.foo|lower }}'\ncookiecutter_dict = OrderedDict([('foo', 'Hello world'), ('bar', 123)])\n\n    def render_variable(env, raw, cookiecutter_dict):\n        \"\"\"Render the next variable to be displayed in the user prompt.\n\n        Inside the prompting taken from the cookiecutter.json file, this renders\n        the next variable. For example, if a project_name is \"Peanut Butter\n        Cookie\", the repo_name could be be rendered with:\n\n            `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\n        This is then presented to the user as the default.\n\n        :param Environment env: A Jinja2 Environment object.\n        :param raw: The next value to be prompted for by the user.\n        :param dict cookiecutter_dict: The current context as it's gradually\n            being populated with variables.\n        :return: The rendered value for the default variable.\n        \"\"\"\n        if not isinstance(raw, str):\n            return raw\n\n        template = env.from_string(raw)\n        try:\n            return template.render(**cookiecutter_dict)\n        except UndefinedError as err:\n&gt;           raise UndefinedVariableInTemplate(str(err), err, cookiecutter_dict)\nE           cookiecutter.exceptions.UndefinedVariableInTemplate: 'cookiecutter' is undefined. Error message: 'cookiecutter' is undefined. Context: OrderedDict([('foo', 'Hello world'), ('bar', 123)])\n\ncookiecutter/prompt.py:162: UndefinedVariableInTemplate"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestreaduserchoicetest_should_invoke_read_user_choice","title":"test_prompt.py::TestReadUserChoice::test_should_invoke_read_user_choice","text":"<pre>test_prompt.py::TestReadUserChoice::test_should_invoke_read_user_choice</pre><pre>\nself = \nmocker = \n\n    def test_should_invoke_read_user_choice(self, mocker):\n        \"\"\"Verify correct function called for select(list) variables.\"\"\"\n        prompt_choice = mocker.patch(\n            'cookiecutter.prompt.prompt_choice_for_config',\n            wraps=prompt.prompt_choice_for_config,\n        )\n\n        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')\n        read_user_choice.return_value = 'all'\n\n        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')\n\n        choices = ['landscape', 'portrait', 'all']\n        context = {'cookiecutter': {'orientation': choices}}\n\n        cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert not read_user_variable.called\nE       AssertionError: assert not True\nE        +  where True = .called\n\ntests/test_prompt.py:403: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestreaduserchoicetest_should_invoke_read_user_variable","title":"test_prompt.py::TestReadUserChoice::test_should_invoke_read_user_variable","text":"<pre>test_prompt.py::TestReadUserChoice::test_should_invoke_read_user_variable</pre><pre>\nself = \nargs = ('full_name', 'Your Name', {}, '  [dim][1/1][/] '), kwargs = {}\nexpected = call('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nactual = call('full_name', 'Your Name')\n_error_message = ._error_message at 0x7f8dd2b96c20&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: read_user_variable('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nE           Actual: read_user_variable('full_name', 'Your Name')\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = ('full_name', 'Your Name', {}, '  [dim][1/1][/] '), kwargs = {}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: read_user_variable('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nE       Actual: read_user_variable('full_name', 'Your Name')\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('full_name', 'Your Name') == ('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nE         \nE         Right contains 2 more items, first extra item: {}\nE         \nE         Full diff:\nE           (\nE               'full_name',\nE               'Your Name',\nE         -     {},\nE         -     '  [dim][1/1][/] ',\nE           )\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nmocker = \n\n    def test_should_invoke_read_user_variable(self, mocker):\n        \"\"\"Verify correct function called for string input variables.\"\"\"\n        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')\n        read_user_variable.return_value = 'Audrey Roy'\n\n        prompt_choice = mocker.patch('cookiecutter.prompt.prompt_choice_for_config')\n\n        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')\n\n        context = {'cookiecutter': {'full_name': 'Your Name'}}\n\n        cookiecutter_dict = prompt.prompt_for_config(context)\n\n        assert not prompt_choice.called\n        assert not read_user_choice.called\n&gt;       read_user_variable.assert_called_once_with(\n            'full_name', 'Your Name', {}, DEFAULT_PREFIX\n        )\nE       AssertionError: expected call not found.\nE       Expected: read_user_variable('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nE       Actual: read_user_variable('full_name', 'Your Name')\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('full_name', 'Your Name') == ('full_name', 'Your Name', {}, '  [dim][1/1][/] ')\nE         \nE         Right contains 2 more items, first extra item: {}\nE         \nE         Full diff:\nE           (\nE               'full_name',\nE               'Your Name',\nE         -     {},\nE         -     '  [dim][1/1][/] ',\nE           )\n\ntests/test_prompt.py:425: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestreaduserchoicetest_should_render_choices","title":"test_prompt.py::TestReadUserChoice::test_should_render_choices","text":"<pre>test_prompt.py::TestReadUserChoice::test_should_render_choices</pre><pre>\nself = \nargs = ('project_name', 'A New Project', {}, '  [dim][1/2][/] '), kwargs = {}\nmsg = 'Expected \\'read_user_variable\\' to be called once. Called 2 times.\\nCalls: [call(\\'project_name\\', \\'A New Project\\'),\\n call(\\'pkg_name\\', [\\'foo\\', \\'{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}\\', \\'bar\\'])].'\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n&gt;           raise AssertionError(msg)\nE           AssertionError: Expected 'read_user_variable' to be called once. Called 2 times.\nE           Calls: [call('project_name', 'A New Project'),\nE            call('pkg_name', ['foo', '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}', 'bar'])].\n\n/usr/lib/python3.10/unittest/mock.py:940: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nmocker = \n\n    def test_should_render_choices(self, mocker):\n        \"\"\"Verify Jinja2 templating engine works inside choices variables.\"\"\"\n        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')\n        read_user_choice.return_value = 'anewproject'\n\n        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')\n        read_user_variable.return_value = 'A New Project'\n\n        rendered_choices = ['foo', 'anewproject', 'bar']\n\n        context = {\n            'cookiecutter': OrderedDict(\n                [\n                    ('project_name', 'A New Project'),\n                    (\n                        'pkg_name',\n                        [\n                            'foo',\n                            '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}',\n                            'bar',\n                        ],\n                    ),\n                ]\n            )\n        }\n\n        expected = {\n            'project_name': 'A New Project',\n            'pkg_name': 'anewproject',\n        }\n        cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       read_user_variable.assert_called_once_with(\n            'project_name', 'A New Project', {}, '  [dim][1/2][/] '\n        )\nE       AssertionError: Expected 'read_user_variable' to be called once. Called 2 times.\nE       Calls: [call('project_name', 'A New Project'),\nE        call('pkg_name', ['foo', '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}', 'bar'])].\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert ('pkg_name', ['foo', '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}', 'bar']) == ('project_name', 'A New Project', {}, '  [dim][1/2][/] ')\nE         \nE         At index 0 diff: 'pkg_name' != 'project_name'\nE         Right contains 2 more items, first extra item: {}\nE         \nE         Full diff:\nE           (\nE         -     'project_name',\nE         ?       ^^^^^^\nE         +     'pkg_name',\nE         ?       ^^\nE         -     'A New Project',\nE         +     [\nE         +         'foo',\nE         +         '{{ cookiecutter.project_name|lower|replace(\" \", \"\") }}',\nE         +         'bar',\nE         -     {},\nE         ?     ^^\nE         +     ],\nE         ?     ^\nE         -     '  [dim][1/2][/] ',\nE           )\n\ntests/test_prompt.py:462: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestpromptchoiceforconfigtest_should_return_first_option_if_no_input","title":"test_prompt.py::TestPromptChoiceForConfig::test_should_return_first_option_if_no_input","text":"<pre>test_prompt.py::TestPromptChoiceForConfig::test_should_return_first_option_if_no_input</pre><pre>\nself = \nmocker = \nchoices = ['landscape', 'portrait', 'all']\ncontext = {'cookiecutter': {'orientation': ['landscape', 'portrait', 'all']}}\n\n    def test_should_return_first_option_if_no_input(self, mocker, choices, context):\n        \"\"\"Verify prompt_choice_for_config return first list option on no_input=True.\"\"\"\n        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')\n\n        expected_choice = choices[0]\n\n&gt;       actual_choice = prompt.prompt_choice_for_config(\n            cookiecutter_dict=context,\n            env=environment.StrictEnvironment(),\n            key='orientation',\n            options=choices,\n            no_input=True,  # Suppress user input\n        )\n\ntests/test_prompt.py:490: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncookiecutter_dict = {'cookiecutter': {'orientation': ['landscape', 'portrait', 'all']}}\nenv = \nkey = 'orientation', options = ['landscape', 'portrait', 'all'], no_input = True\nprompts = None, prefix = ''\n\n    def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input,\n        prompts=None, prefix=''):\n        \"\"\"Prompt user with a set of options to choose from.\n\n        :param no_input: Do not prompt for user input and return the first available option.\n        \"\"\"\n        if no_input:\n&gt;           return next(iter(options.values()))\nE           AttributeError: 'list' object has no attribute 'values'\n\ncookiecutter/prompt.py:196: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestpromptchoiceforconfigtest_should_read_user_choice","title":"test_prompt.py::TestPromptChoiceForConfig::test_should_read_user_choice","text":"<pre>test_prompt.py::TestPromptChoiceForConfig::test_should_read_user_choice</pre><pre>\nself = \nmocker = \nchoices = ['landscape', 'portrait', 'all']\ncontext = {'cookiecutter': {'orientation': ['landscape', 'portrait', 'all']}}\n\n    def test_should_read_user_choice(self, mocker, choices, context):\n        \"\"\"Verify prompt_choice_for_config return user selection on no_input=False.\"\"\"\n        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')\n        read_user_choice.return_value = 'all'\n\n        expected_choice = 'all'\n\n&gt;       actual_choice = prompt.prompt_choice_for_config(\n            cookiecutter_dict=context,\n            env=environment.StrictEnvironment(),\n            key='orientation',\n            options=choices,\n            no_input=False,  # Ask the user for input\n        )\n\ntests/test_prompt.py:508: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncookiecutter_dict = {'cookiecutter': {'orientation': ['landscape', 'portrait', 'all']}}\nenv = \nkey = 'orientation', options = ['landscape', 'portrait', 'all']\nno_input = False, prompts = None, prefix = ''\n\n    def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input,\n        prompts=None, prefix=''):\n        \"\"\"Prompt user with a set of options to choose from.\n\n        :param no_input: Do not prompt for user input and return the first available option.\n        \"\"\"\n        if no_input:\n            return next(iter(options.values()))\n\n        rendered_options = OrderedDict()\n&gt;       for option_key, option_value in options.items():\nE       AttributeError: 'list' object has no attribute 'items'\n\ncookiecutter/prompt.py:199: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestreaduseryesnotest_should_invoke_read_user_yes_notrue","title":"test_prompt.py::TestReadUserYesNo::test_should_invoke_read_user_yes_no[True]","text":"<pre>test_prompt.py::TestReadUserYesNo::test_should_invoke_read_user_yes_no[True]</pre><pre>\nself = \nmocker = \nrun_as_docker = True\n\n    @pytest.mark.parametrize(\n        'run_as_docker',\n        (\n            True,\n            False,\n        ),\n    )\n    def test_should_invoke_read_user_yes_no(self, mocker, run_as_docker):\n        \"\"\"Verify correct function called for boolean variables.\"\"\"\n        read_user_yes_no = mocker.patch('cookiecutter.prompt.read_user_yes_no')\n        read_user_yes_no.return_value = run_as_docker\n\n        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')\n\n        context = {'cookiecutter': {'run_as_docker': run_as_docker}}\n\n        cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert not read_user_variable.called\nE       AssertionError: assert not True\nE        +  where True = .called\n\ntests/test_prompt.py:540: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytestreaduseryesnotest_should_invoke_read_user_yes_nofalse","title":"test_prompt.py::TestReadUserYesNo::test_should_invoke_read_user_yes_no[False]","text":"<pre>test_prompt.py::TestReadUserYesNo::test_should_invoke_read_user_yes_no[False]</pre><pre>\nself = \nmocker = \nrun_as_docker = False\n\n    @pytest.mark.parametrize(\n        'run_as_docker',\n        (\n            True,\n            False,\n        ),\n    )\n    def test_should_invoke_read_user_yes_no(self, mocker, run_as_docker):\n        \"\"\"Verify correct function called for boolean variables.\"\"\"\n        read_user_yes_no = mocker.patch('cookiecutter.prompt.read_user_yes_no')\n        read_user_yes_no.return_value = run_as_docker\n\n        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')\n\n        context = {'cookiecutter': {'run_as_docker': run_as_docker}}\n\n        cookiecutter_dict = prompt.prompt_for_config(context)\n\n&gt;       assert not read_user_variable.called\nE       AssertionError: assert not True\nE        +  where True = .called\n\ntests/test_prompt.py:540: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_undefined_variableundefined-variable-in-cookiecutter-dict","title":"test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict]","text":"<pre>test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict]</pre><pre>\ncontext = {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}}\n\n    @pytest.mark.parametrize(\n        'context',\n        (\n            {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},\n            {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},\n            {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},\n            {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},\n        ),\n        ids=[\n            'Undefined variable in cookiecutter dict',\n            'Undefined variable in cookiecutter dict with choices',\n            'Undefined variable in cookiecutter dict with dict_key',\n            'Undefined variable in cookiecutter dict with key_value',\n        ],\n    )\n    def test_undefined_variable(context):\n        \"\"\"Verify `prompt.prompt_for_config` raises correct error.\"\"\"\n        with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\n            prompt.prompt_for_config(context, no_input=True)\n\n        error = err.value\n&gt;       assert error.message == \"Unable to render variable 'foo'\"\nE       assert \"'cookiecutter' is undefined\" == \"Unable to render variable 'foo'\"\nE         \nE         - Unable to render variable 'foo'\nE         + 'cookiecutter' is undefined\n\ntests/test_prompt.py:578: AssertionError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_undefined_variableundefined-variable-in-cookiecutter-dict-with-choices","title":"test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with choices]","text":"<pre>test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with choices]</pre><pre>\ncontext = {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}}\n\n    @pytest.mark.parametrize(\n        'context',\n        (\n            {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},\n            {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},\n            {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},\n            {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},\n        ),\n        ids=[\n            'Undefined variable in cookiecutter dict',\n            'Undefined variable in cookiecutter dict with choices',\n            'Undefined variable in cookiecutter dict with dict_key',\n            'Undefined variable in cookiecutter dict with key_value',\n        ],\n    )\n    def test_undefined_variable(context):\n        \"\"\"Verify `prompt.prompt_for_config` raises correct error.\"\"\"\n&gt;       with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\nE       Failed: DID NOT RAISE \n\ntests/test_prompt.py:574: Failed"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_undefined_variableundefined-variable-in-cookiecutter-dict-with-dict_key","title":"test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with dict_key]","text":"<pre>test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with dict_key]</pre><pre>\ncontext = {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}}\n\n    @pytest.mark.parametrize(\n        'context',\n        (\n            {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},\n            {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},\n            {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},\n            {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},\n        ),\n        ids=[\n            'Undefined variable in cookiecutter dict',\n            'Undefined variable in cookiecutter dict with choices',\n            'Undefined variable in cookiecutter dict with dict_key',\n            'Undefined variable in cookiecutter dict with key_value',\n        ],\n    )\n    def test_undefined_variable(context):\n        \"\"\"Verify `prompt.prompt_for_config` raises correct error.\"\"\"\n&gt;       with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\nE       Failed: DID NOT RAISE \n\ntests/test_prompt.py:574: Failed"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_undefined_variableundefined-variable-in-cookiecutter-dict-with-key_value","title":"test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with key_value]","text":"<pre>test_prompt.py::test_undefined_variable[Undefined variable in cookiecutter dict with key_value]</pre><pre>\ncontext = {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}}\n\n    @pytest.mark.parametrize(\n        'context',\n        (\n            {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},\n            {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},\n            {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},\n            {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},\n        ),\n        ids=[\n            'Undefined variable in cookiecutter dict',\n            'Undefined variable in cookiecutter dict with choices',\n            'Undefined variable in cookiecutter dict with dict_key',\n            'Undefined variable in cookiecutter dict with key_value',\n        ],\n    )\n    def test_undefined_variable(context):\n        \"\"\"Verify `prompt.prompt_for_config` raises correct error.\"\"\"\n&gt;       with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:\nE       Failed: DID NOT RAISE \n\ntests/test_prompt.py:574: Failed"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_cookiecutter_nested_templatesfake-nested-templates-fake-project","title":"test_prompt.py::test_cookiecutter_nested_templates[fake-nested-templates-fake-project]","text":"<pre>test_prompt.py::test_cookiecutter_nested_templates[fake-nested-templates-fake-project]</pre><pre>\ntemplate_dir = 'fake-nested-templates', expected = 'fake-project'\n\n    @pytest.mark.parametrize(\n        \"template_dir,expected\",\n        [\n            [\"fake-nested-templates\", \"fake-project\"],\n            [\"fake-nested-templates-old-style\", \"fake-package\"],\n        ],\n    )\n    def test_cookiecutter_nested_templates(template_dir: str, expected: str):\n        \"\"\"Test nested_templates generation.\"\"\"\n        from cookiecutter import prompt\n\n        main_dir = (Path(\"tests\") / template_dir).resolve()\n        cookiecuter_context = json.loads((main_dir / \"cookiecutter.json\").read_text())\n        context = {\"cookiecutter\": cookiecuter_context}\n&gt;       output_dir = prompt.choose_nested_template(context, main_dir, no_input=True)\n\ntests/test_prompt.py:596: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:243: in choose_nested_template\n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\ncookiecutter/prompt.py:243: in \n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/testbed/tests/fake-nested-templates/templates')\n\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n&gt;       for name in self._accessor.listdir(self):\nE       FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/fake-nested-templates/templates'\n\n/usr/lib/python3.10/pathlib.py:1017: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_cookiecutter_nested_templatesfake-nested-templates-old-style-fake-package","title":"test_prompt.py::test_cookiecutter_nested_templates[fake-nested-templates-old-style-fake-package]","text":"<pre>test_prompt.py::test_cookiecutter_nested_templates[fake-nested-templates-old-style-fake-package]</pre><pre>\ntemplate_dir = 'fake-nested-templates-old-style', expected = 'fake-package'\n\n    @pytest.mark.parametrize(\n        \"template_dir,expected\",\n        [\n            [\"fake-nested-templates\", \"fake-project\"],\n            [\"fake-nested-templates-old-style\", \"fake-package\"],\n        ],\n    )\n    def test_cookiecutter_nested_templates(template_dir: str, expected: str):\n        \"\"\"Test nested_templates generation.\"\"\"\n        from cookiecutter import prompt\n\n        main_dir = (Path(\"tests\") / template_dir).resolve()\n        cookiecuter_context = json.loads((main_dir / \"cookiecutter.json\").read_text())\n        context = {\"cookiecutter\": cookiecuter_context}\n&gt;       output_dir = prompt.choose_nested_template(context, main_dir, no_input=True)\n\ntests/test_prompt.py:596: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:243: in choose_nested_template\n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\ncookiecutter/prompt.py:243: in \n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/testbed/tests/fake-nested-templates-old-style/templates')\n\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n&gt;       for name in self._accessor.listdir(self):\nE       FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/fake-nested-templates-old-style/templates'\n\n/usr/lib/python3.10/pathlib.py:1017: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_cookiecutter_nested_templates_invalid_paths","title":"test_prompt.py::test_cookiecutter_nested_templates_invalid_paths[]","text":"<pre>test_prompt.py::test_cookiecutter_nested_templates_invalid_paths[]</pre><pre>\npath = ''\n\n    @pytest.mark.skipif(sys.platform.startswith('win'), reason=\"Linux / macos test\")\n    @pytest.mark.parametrize(\n        \"path\",\n        [\n            \"\",\n            \"/tmp\",\n            \"/foo\",\n        ],\n    )\n    def test_cookiecutter_nested_templates_invalid_paths(path: str):\n        \"\"\"Test nested_templates generation.\"\"\"\n        from cookiecutter import prompt\n\n        main_dir = (Path(\"tests\") / \"fake-nested-templates\").resolve()\n        cookiecuter_context = json.loads((main_dir / \"cookiecutter.json\").read_text())\n        cookiecuter_context[\"templates\"][\"fake-project\"][\"path\"] = path\n        context = {\"cookiecutter\": cookiecuter_context}\n        with pytest.raises(ValueError) as exc:\n&gt;           prompt.choose_nested_template(context, main_dir, no_input=True)\n\ntests/test_prompt.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:243: in choose_nested_template\n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\ncookiecutter/prompt.py:243: in \n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/testbed/tests/fake-nested-templates/templates')\n\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n&gt;       for name in self._accessor.listdir(self):\nE       FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/fake-nested-templates/templates'\n\n/usr/lib/python3.10/pathlib.py:1017: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#tmp","title":"tmp]","text":"<pre>tmp]</pre><pre>\npath = '/tmp'\n\n    @pytest.mark.skipif(sys.platform.startswith('win'), reason=\"Linux / macos test\")\n    @pytest.mark.parametrize(\n        \"path\",\n        [\n            \"\",\n            \"/tmp\",\n            \"/foo\",\n        ],\n    )\n    def test_cookiecutter_nested_templates_invalid_paths(path: str):\n        \"\"\"Test nested_templates generation.\"\"\"\n        from cookiecutter import prompt\n\n        main_dir = (Path(\"tests\") / \"fake-nested-templates\").resolve()\n        cookiecuter_context = json.loads((main_dir / \"cookiecutter.json\").read_text())\n        cookiecuter_context[\"templates\"][\"fake-project\"][\"path\"] = path\n        context = {\"cookiecutter\": cookiecuter_context}\n        with pytest.raises(ValueError) as exc:\n&gt;           prompt.choose_nested_template(context, main_dir, no_input=True)\n\ntests/test_prompt.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:243: in choose_nested_template\n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\ncookiecutter/prompt.py:243: in \n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/testbed/tests/fake-nested-templates/templates')\n\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n&gt;       for name in self._accessor.listdir(self):\nE       FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/fake-nested-templates/templates'\n\n/usr/lib/python3.10/pathlib.py:1017: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#foo","title":"foo]","text":"<pre>foo]</pre><pre>\npath = '/foo'\n\n    @pytest.mark.skipif(sys.platform.startswith('win'), reason=\"Linux / macos test\")\n    @pytest.mark.parametrize(\n        \"path\",\n        [\n            \"\",\n            \"/tmp\",\n            \"/foo\",\n        ],\n    )\n    def test_cookiecutter_nested_templates_invalid_paths(path: str):\n        \"\"\"Test nested_templates generation.\"\"\"\n        from cookiecutter import prompt\n\n        main_dir = (Path(\"tests\") / \"fake-nested-templates\").resolve()\n        cookiecuter_context = json.loads((main_dir / \"cookiecutter.json\").read_text())\n        cookiecuter_context[\"templates\"][\"fake-project\"][\"path\"] = path\n        context = {\"cookiecutter\": cookiecuter_context}\n        with pytest.raises(ValueError) as exc:\n&gt;           prompt.choose_nested_template(context, main_dir, no_input=True)\n\ntests/test_prompt.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:243: in choose_nested_template\n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\ncookiecutter/prompt.py:243: in \n    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/testbed/tests/fake-nested-templates/templates')\n\n    def iterdir(self):\n        \"\"\"Iterate over the files in this directory.  Does not yield any\n        result for the special paths '.' and '..'.\n        \"\"\"\n&gt;       for name in self._accessor.listdir(self):\nE       FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/fake-nested-templates/templates'\n\n/usr/lib/python3.10/pathlib.py:1017: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_cookiecutter_nested_templates_invalid_win_paths","title":"test_prompt.py::test_cookiecutter_nested_templates_invalid_win_paths[]","text":"<pre>test_prompt.py::test_cookiecutter_nested_templates_invalid_win_paths[]</pre><pre>\n('/testbed/tests/test_prompt.py', 623, 'Skipped: Win only test')\n</pre>"},{"location":"analysis_baseline_cookiecutter/#tmp_1","title":"tmp]","text":"<pre>tmp]</pre><pre>\n('/testbed/tests/test_prompt.py', 623, 'Skipped: Win only test')\n</pre>"},{"location":"analysis_baseline_cookiecutter/#tmp_2","title":"tmp]","text":"<pre>tmp]</pre><pre>\n('/testbed/tests/test_prompt.py', 623, 'Skipped: Win only test')\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_prompt_should_ask_and_rm_repo_file","title":"test_prompt.py::test_prompt_should_ask_and_rm_repo_file","text":"<pre>test_prompt.py::test_prompt_should_ask_and_rm_repo_file</pre><pre>\ntopfd = 12\npath = '/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_rm_1/repo.zip'\nonerror = \n\n    def _rmtree_safe_fd(topfd, path, onerror):\n        try:\n&gt;           with os.scandir(topfd) as scandir_it:\nE           NotADirectoryError: [Errno 20] Not a directory: '/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_rm_1/repo.zip'\n\n/usr/lib/python3.10/shutil.py:629: NotADirectoryError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_rm_1')\n\n    def test_prompt_should_ask_and_rm_repo_file(mocker, tmp_path):\n        \"\"\"In `prompt_and_delete()`, if the user agrees to delete/reclone a \\\n        repo file, the repo should be deleted.\"\"\"\n        mock_read_user = mocker.patch(\n            'cookiecutter.prompt.read_user_yes_no', return_value=True, autospec=True\n        )\n\n        repo_file = tmp_path.joinpath('repo.zip')\n        repo_file.write_text('this is zipfile content')\n\n&gt;       deleted = prompt.prompt_and_delete(str(repo_file))\n\ntests/test_prompt.py:690: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:276: in prompt_and_delete\n    rmtree(path)\ncookiecutter/utils.py:30: in rmtree\n    shutil.rmtree(path, onerror=force_delete)\n/usr/lib/python3.10/shutil.py:725: in rmtree\n    _rmtree_safe_fd(fd, path, onerror)\n/usr/lib/python3.10/shutil.py:633: in _rmtree_safe_fd\n    onerror(os.scandir, path, sys.exc_info())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfunc = \npath = '/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_rm_1/repo.zip'\nexc_info = (, NotADirectoryError(20, 'Not a directory'), )\n\n    def force_delete(func, path, exc_info):\n        \"\"\"Error handler for `shutil.rmtree()` equivalent to `rm -rf`.\n\n        Usage: `shutil.rmtree(path, onerror=force_delete)`\n        From https://docs.python.org/3/library/shutil.html#rmtree-example\n        \"\"\"\n        os.chmod(path, stat.S_IWRITE)\n&gt;       func(path)\nE       NotADirectoryError: [Errno 20] Not a directory: '/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_rm_1/repo.zip'\n\ncookiecutter/utils.py:22: NotADirectoryError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_prompt_should_ask_and_keep_repo_on_reuse","title":"test_prompt.py::test_prompt_should_ask_and_keep_repo_on_reuse","text":"<pre>test_prompt.py::test_prompt_should_ask_and_keep_repo_on_reuse</pre><pre>\nmocker = \ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_kee1')\n\n    def test_prompt_should_ask_and_keep_repo_on_reuse(mocker, tmp_path):\n        \"\"\"In `prompt_and_delete()`, if the user wants to keep their old \\\n        cloned template repo, it should not be deleted.\"\"\"\n\n        def answer(question, default):\n            return 'okay to delete' not in question\n\n        mock_read_user = mocker.patch(\n            'cookiecutter.prompt.read_user_yes_no', side_effect=answer, autospec=True\n        )\n        repo_dir = Path(tmp_path, 'repo')\n        repo_dir.mkdir()\n\n&gt;       deleted = prompt.prompt_and_delete(str(repo_dir))\n\ntests/test_prompt.py:726: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:270: in prompt_and_delete\n    delete = read_user_yes_no(\n:3: in read_user_yes_no\n    ???\n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (\"You've downloaded /tmp/pytest-of-root/pytest-0/test_prompt_should_ask_and_kee1/repo before. Is it okay to delete and re-download it?\",)\nkwargs = {'default_value': True}\neffect = .answer at 0x7f8dd2b967a0&gt;\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n                raise effect\n            elif not _callable(effect):\n                result = next(effect)\n                if _is_exception(result):\n                    raise result\n            else:\n&gt;               result = effect(*args, **kwargs)\nE               TypeError: test_prompt_should_ask_and_keep_repo_on_reuse..answer() got an unexpected keyword argument 'default_value'\n\n/usr/lib/python3.10/unittest/mock.py:1179: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_promptpytest_prompt_should_not_ask_if_no_input_and_rm_repo_file","title":"test_prompt.py::test_prompt_should_not_ask_if_no_input_and_rm_repo_file","text":"<pre>test_prompt.py::test_prompt_should_not_ask_if_no_input_and_rm_repo_file</pre><pre>\ntopfd = 12\npath = '/tmp/pytest-of-root/pytest-0/test_prompt_should_not_ask_if_1/repo.zip'\nonerror = \n\n    def _rmtree_safe_fd(topfd, path, onerror):\n        try:\n&gt;           with os.scandir(topfd) as scandir_it:\nE           NotADirectoryError: [Errno 20] Not a directory: '/tmp/pytest-of-root/pytest-0/test_prompt_should_not_ask_if_1/repo.zip'\n\n/usr/lib/python3.10/shutil.py:629: NotADirectoryError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_prompt_should_not_ask_if_1')\n\n    def test_prompt_should_not_ask_if_no_input_and_rm_repo_file(mocker, tmp_path):\n        \"\"\"Prompt should not ask if no input and rm file.\n\n        In `prompt_and_delete()`, if `no_input` is True, the call to\n        `prompt.read_user_yes_no()` should be suppressed.\n        \"\"\"\n        mock_read_user = mocker.patch(\n            'cookiecutter.prompt.read_user_yes_no', return_value=True, autospec=True\n        )\n\n        repo_file = tmp_path.joinpath('repo.zip')\n        repo_file.write_text('this is zipfile content')\n\n&gt;       deleted = prompt.prompt_and_delete(str(repo_file), no_input=True)\n\ntests/test_prompt.py:765: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:267: in prompt_and_delete\n    rmtree(path)\ncookiecutter/utils.py:30: in rmtree\n    shutil.rmtree(path, onerror=force_delete)\n/usr/lib/python3.10/shutil.py:725: in rmtree\n    _rmtree_safe_fd(fd, path, onerror)\n/usr/lib/python3.10/shutil.py:633: in _rmtree_safe_fd\n    onerror(os.scandir, path, sys.exc_info())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfunc = \npath = '/tmp/pytest-of-root/pytest-0/test_prompt_should_not_ask_if_1/repo.zip'\nexc_info = (, NotADirectoryError(20, 'Not a directory'), )\n\n    def force_delete(func, path, exc_info):\n        \"\"\"Error handler for `shutil.rmtree()` equivalent to `rm -rf`.\n\n        Usage: `shutil.rmtree(path, onerror=force_delete)`\n        From https://docs.python.org/3/library/shutil.html#rmtree-example\n        \"\"\"\n        os.chmod(path, stat.S_IWRITE)\n&gt;       func(path)\nE       NotADirectoryError: [Errno 20] Not a directory: '/tmp/pytest-of-root/pytest-0/test_prompt_should_not_ask_if_1/repo.zip'\n\ncookiecutter/utils.py:22: NotADirectoryError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_choicepytest_click_invocation1-hello","title":"test_read_user_choice.py::test_click_invocation[1-hello]","text":"<pre>test_read_user_choice.py::test_click_invocation[1-hello]</pre><pre>\nmocker = \nuser_choice = 1, expected_value = 'hello'\n\n    @pytest.mark.parametrize('user_choice, expected_value', enumerate(OPTIONS, 1))\n    def test_click_invocation(mocker, user_choice, expected_value):\n        \"\"\"Test click function called correctly by cookiecutter.\n\n        Test for choice type invocation.\n        \"\"\"\n        prompt = mocker.patch('rich.prompt.Prompt.ask')\n        prompt.return_value = f'{user_choice}'\n\n&gt;       assert read_user_choice('varname', OPTIONS) == expected_value\nE       AssertionError: assert 'world' == 'hello'\nE         \nE         - hello\nE         + world\n\ntests/test_read_user_choice.py:27: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_choicepytest_click_invocation2-world","title":"test_read_user_choice.py::test_click_invocation[2-world]","text":"<pre>test_read_user_choice.py::test_click_invocation[2-world]</pre><pre>\nmocker = \nuser_choice = 2, expected_value = 'world'\n\n    @pytest.mark.parametrize('user_choice, expected_value', enumerate(OPTIONS, 1))\n    def test_click_invocation(mocker, user_choice, expected_value):\n        \"\"\"Test click function called correctly by cookiecutter.\n\n        Test for choice type invocation.\n        \"\"\"\n        prompt = mocker.patch('rich.prompt.Prompt.ask')\n        prompt.return_value = f'{user_choice}'\n\n&gt;       assert read_user_choice('varname', OPTIONS) == expected_value\nE       AssertionError: assert 'foo' == 'world'\nE         \nE         - world\nE         + foo\n\ntests/test_read_user_choice.py:27: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_choicepytest_click_invocation3-foo","title":"test_read_user_choice.py::test_click_invocation[3-foo]","text":"<pre>test_read_user_choice.py::test_click_invocation[3-foo]</pre><pre>\nmocker = \nuser_choice = 3, expected_value = 'foo'\n\n    @pytest.mark.parametrize('user_choice, expected_value', enumerate(OPTIONS, 1))\n    def test_click_invocation(mocker, user_choice, expected_value):\n        \"\"\"Test click function called correctly by cookiecutter.\n\n        Test for choice type invocation.\n        \"\"\"\n        prompt = mocker.patch('rich.prompt.Prompt.ask')\n        prompt.return_value = f'{user_choice}'\n\n&gt;       assert read_user_choice('varname', OPTIONS) == expected_value\nE       AssertionError: assert 'bar' == 'foo'\nE         \nE         - foo\nE         + bar\n\ntests/test_read_user_choice.py:27: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_choicepytest_click_invocation4-bar","title":"test_read_user_choice.py::test_click_invocation[4-bar]","text":"<pre>test_read_user_choice.py::test_click_invocation[4-bar]</pre><pre>\nmocker = \nuser_choice = 4, expected_value = 'bar'\n\n    @pytest.mark.parametrize('user_choice, expected_value', enumerate(OPTIONS, 1))\n    def test_click_invocation(mocker, user_choice, expected_value):\n        \"\"\"Test click function called correctly by cookiecutter.\n\n        Test for choice type invocation.\n        \"\"\"\n        prompt = mocker.patch('rich.prompt.Prompt.ask')\n        prompt.return_value = f'{user_choice}'\n\n&gt;       assert read_user_choice('varname', OPTIONS) == expected_value\n\ntests/test_read_user_choice.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvar_name = 'varname', options = ['hello', 'world', 'foo', 'bar'], prompts = None\nprefix = ''\n\n    def read_user_choice(var_name, options, prompts=None, prefix=''):\n        \"\"\"Prompt the user to choose from several options for the given variable.\n\n        The first item will be returned if no input happens.\n\n        :param str var_name: Variable as specified in the context\n        :param list options: Sequence of options that are available to select from\n        :return: Exactly one item of ``options`` that has been chosen by the user\n        \"\"\"\n        prompt_text = f\"{prefix}{var_name}\"\n        if prompts and var_name in prompts:\n            prompt_text = prompts[var_name]\n\n        choices = [str(i) for i in range(len(options))]\n        choice_text = \"\\n\".join(f\"{i}: {option}\" for i, option in enumerate(options))\n\n        while True:\n            print(f\"{prompt_text}\\n{choice_text}\")\n            choice = Prompt.ask(\"Enter the number of your choice\", choices=choices, default=\"0\")\n&gt;           return options[int(choice)]\nE           IndexError: list index out of range\n\ncookiecutter/prompt.py:91: IndexError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_choicepytest_raise_if_options_is_not_a_non_empty_list","title":"test_read_user_choice.py::test_raise_if_options_is_not_a_non_empty_list","text":"<pre>test_read_user_choice.py::test_raise_if_options_is_not_a_non_empty_list</pre><pre>\ndef test_raise_if_options_is_not_a_non_empty_list():\n        \"\"\"Test function called by cookiecutter raise expected errors.\n\n        Test for choice type invocation.\n        \"\"\"\n        with pytest.raises(TypeError):\n&gt;           read_user_choice('foo', 'NOT A LIST')\n\ntests/test_read_user_choice.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/prompt.py:90: in read_user_choice\n    choice = Prompt.ask(\"Enter the number of your choice\", choices=choices, default=\"0\")\n.venv/lib/python3.10/site-packages/rich/prompt.py:149: in ask\n    return _prompt(default=default, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:292: in __call__\n    value = self.get_input(self.console, prompt, self.password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:211: in get_input\n    return console.input(prompt, password=password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/console.py:2156: in input\n    result = input()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.capture.DontReadFromInput object at 0x7f8dd4a5bee0&gt;, size = -1\n\n    def read(self, size: int = -1) -&gt; str:\n&gt;       raise OSError(\n            \"pytest: reading from stdin while output is captured!  Consider using `-s`.\"\n        )\nE       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.\n\n.venv/lib/python3.10/site-packages/_pytest/capture.py:209: OSError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_process_json_invalid_json","title":"test_read_user_dict.py::test_process_json_invalid_json","text":"<pre>test_read_user_dict.py::test_process_json_invalid_json</pre><pre>\ndef test_process_json_invalid_json():\n        \"\"\"Test `process_json` for correct error on malformed input.\"\"\"\n&gt;       with pytest.raises(InvalidResponse) as exc_info:\nE       Failed: DID NOT RAISE \n\ntests/test_read_user_dict.py:12: Failed"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_process_json_non_dict","title":"test_read_user_dict.py::test_process_json_non_dict","text":"<pre>test_read_user_dict.py::test_process_json_non_dict</pre><pre>\ndef test_process_json_non_dict():\n        \"\"\"Test `process_json` for correct error on non-JSON input.\"\"\"\n&gt;       with pytest.raises(InvalidResponse) as exc_info:\nE       Failed: DID NOT RAISE \n\ntests/test_read_user_dict.py:20: Failed"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_should_raise_type_error","title":"test_read_user_dict.py::test_should_raise_type_error","text":"<pre>test_read_user_dict.py::test_should_raise_type_error</pre><pre>\nmocker = \n\n    def test_should_raise_type_error(mocker):\n        \"\"\"Test `default_value` arg verification in `read_user_dict` function.\"\"\"\n        prompt = mocker.patch('cookiecutter.prompt.JsonPrompt.ask')\n\n&gt;       with pytest.raises(TypeError):\nE       Failed: DID NOT RAISE \n\ntests/test_read_user_dict.py:79: Failed"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_should_call_prompt_with_process_json","title":"test_read_user_dict.py::test_should_call_prompt_with_process_json","text":"<pre>test_read_user_dict.py::test_should_call_prompt_with_process_json</pre><pre>\nmocker = \n\n    def test_should_call_prompt_with_process_json(mocker):\n        \"\"\"Test to make sure that `process_json` is actually being used.\n\n        Verifies generation of a processor for the user input.\n        \"\"\"\n        mock_prompt = mocker.patch('cookiecutter.prompt.JsonPrompt.ask', autospec=True)\n\n        read_user_dict('name', {'project_slug': 'pytest-plugin'})\n        print(mock_prompt.call_args)\n        args, kwargs = mock_prompt.call_args\n\n&gt;       assert args == ('name [cyan bold](default)[/]',)\nE       AssertionError: assert ('name',) == ('name [cyan bold](default)[/]',)\nE         \nE         At index 0 diff: 'name' != 'name [cyan bold](default)[/]'\nE         \nE         Full diff:\nE           (\nE         -     'name [cyan bold](default)[/]',\nE         +     'name',\nE           )\n\ntests/test_read_user_dict.py:95: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_read_user_dict_default_valuen","title":"test_read_user_dict.py::test_read_user_dict_default_value[\\n]","text":"<pre>test_read_user_dict.py::test_read_user_dict_default_value[\\n]</pre><pre>\nmocker = \ninput = '\\n'\n\n    @pytest.mark.parametrize(\"input\", [\"\\n\", \"\\ndefault\\n\"])\n    def test_read_user_dict_default_value(mocker, input):\n        \"\"\"Make sure that `read_user_dict` returns the default value.\n\n        Verify return of a dict variable rather than the display value.\n        \"\"\"\n        runner = click.testing.CliRunner()\n        with runner.isolation(input=input):\n            val = read_user_dict('name', {'project_slug': 'pytest-plugin'})\n\n&gt;       assert val == {'project_slug': 'pytest-plugin'}\nE       assert '{\"project_slug\": \"pytest-plugin\"}' == {'project_slug': 'pytest-plugin'}\n\ntests/test_read_user_dict.py:122: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_dictpytest_read_user_dict_default_valuendefaultn","title":"test_read_user_dict.py::test_read_user_dict_default_value[\\ndefault\\n]","text":"<pre>test_read_user_dict.py::test_read_user_dict_default_value[\\ndefault\\n]</pre><pre>\nmocker = \ninput = '\\ndefault\\n'\n\n    @pytest.mark.parametrize(\"input\", [\"\\n\", \"\\ndefault\\n\"])\n    def test_read_user_dict_default_value(mocker, input):\n        \"\"\"Make sure that `read_user_dict` returns the default value.\n\n        Verify return of a dict variable rather than the display value.\n        \"\"\"\n        runner = click.testing.CliRunner()\n        with runner.isolation(input=input):\n            val = read_user_dict('name', {'project_slug': 'pytest-plugin'})\n\n&gt;       assert val == {'project_slug': 'pytest-plugin'}\nE       assert '{\"project_slug\": \"pytest-plugin\"}' == {'project_slug': 'pytest-plugin'}\n\ntests/test_read_user_dict.py:122: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_read_user_variablepytest_input_loop_with_null_default_value","title":"test_read_user_variable.py::test_input_loop_with_null_default_value","text":"<pre>test_read_user_variable.py::test_input_loop_with_null_default_value</pre><pre>\nmock_prompt = \n\n    def test_input_loop_with_null_default_value(mock_prompt):\n        \"\"\"Test `Prompt.ask` is run repeatedly until a valid answer is provided.\n\n        Test for `default_value` parameter equal to None.\n        \"\"\"\n        # Simulate user providing None input initially and then a valid input\n        mock_prompt.side_effect = [None, DEFAULT]\n\n&gt;       assert read_user_variable(VARIABLE, None) == DEFAULT\nE       AssertionError: assert None == 'Kivy Project'\nE        +  where None = read_user_variable('project_name', None)\n\ntests/test_read_user_variable.py:37: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_repo_not_foundpytest_should_raise_error_if_repo_does_not_exist","title":"test_repo_not_found.py::test_should_raise_error_if_repo_does_not_exist","text":"<pre>test_repo_not_found.py::test_should_raise_error_if_repo_does_not_exist</pre><pre>\ndef test_should_raise_error_if_repo_does_not_exist():\n        \"\"\"Cookiecutter invocation with non-exist repository should raise error.\"\"\"\n        with pytest.raises(exceptions.RepositoryNotFound):\n&gt;           main.cookiecutter('definitely-not-a-valid-repo-dir')\n\ntests/test_repo_not_found.py:11: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'definitely-not-a-valid-repo-dir', checkout = None, no_input = False\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '.', config_file = None, default_config = False, password = None\ndirectory = None, skip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_specify_output_dirpytest_api_invocation","title":"test_specify_output_dir.py::test_api_invocation","text":"<pre>test_specify_output_dir.py::test_api_invocation</pre><pre>\nmocker = \ntemplate = '/tmp/pytest-of-root/pytest-0/test_api_invocation0/template'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_api_invocation0/output'\ncontext = {'cookiecutter': {'email': 'raphael@hackebrot.de', 'full_name': 'Raphael Pierzina', 'github_username': 'hackebrot', 'version': '0.1.0'}}\n\n    def test_api_invocation(mocker, template, output_dir, context):\n        \"\"\"Verify output dir location is correctly passed.\"\"\"\n        mock_gen_files = mocker.patch('cookiecutter.main.generate_files')\n\n&gt;       main.cookiecutter(template, output_dir=output_dir)\n\ntests/test_specify_output_dir.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '/tmp/pytest-of-root/pytest-0/test_api_invocation0/template'\ncheckout = None, no_input = False, extra_context = None, replay = None\noverwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_api_invocation0/output'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_specify_output_dirpytest_default_output_dir","title":"test_specify_output_dir.py::test_default_output_dir","text":"<pre>test_specify_output_dir.py::test_default_output_dir</pre><pre>\nmocker = \ntemplate = '/tmp/pytest-of-root/pytest-0/test_default_output_dir0/template'\ncontext = {'cookiecutter': {'email': 'raphael@hackebrot.de', 'full_name': 'Raphael Pierzina', 'github_username': 'hackebrot', 'version': '0.1.0'}}\n\n    def test_default_output_dir(mocker, template, context):\n        \"\"\"Verify default output dir is current working folder.\"\"\"\n        mock_gen_files = mocker.patch('cookiecutter.main.generate_files')\n\n&gt;       main.cookiecutter(template)\n\ntests/test_specify_output_dir.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = '/tmp/pytest-of-root/pytest-0/test_default_output_dir0/template'\ncheckout = None, no_input = False, extra_context = None, replay = None\noverwrite_if_exists = False, output_dir = '.', config_file = None\ndefault_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_templatespytest_build_templatesinclude","title":"test_templates.py::test_build_templates[include]","text":"<pre>test_templates.py::test_build_templates[include]</pre><pre>\ntemplate = 'include'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_include_0/templates'\n\n    @pytest.mark.parametrize(\"template\", [\"include\", \"no-templates\", \"extends\", \"super\"])\n    def test_build_templates(template, output_dir):\n        \"\"\"\n        Verify Templates Design keywords.\n\n        no-templates is a compatibility tests for repo without `templates` directory\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            f'tests/test-templates/{template}',\n            no_input=True,\n            output_dir=output_dir,\n        )\n\ntests/test_templates.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-templates/include', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_include_0/templates'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_templatespytest_build_templatesno-templates","title":"test_templates.py::test_build_templates[no-templates]","text":"<pre>test_templates.py::test_build_templates[no-templates]</pre><pre>\ntemplate = 'no-templates'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_no_templa0/templates'\n\n    @pytest.mark.parametrize(\"template\", [\"include\", \"no-templates\", \"extends\", \"super\"])\n    def test_build_templates(template, output_dir):\n        \"\"\"\n        Verify Templates Design keywords.\n\n        no-templates is a compatibility tests for repo without `templates` directory\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            f'tests/test-templates/{template}',\n            no_input=True,\n            output_dir=output_dir,\n        )\n\ntests/test_templates.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-templates/no-templates', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_no_templa0/templates'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_templatespytest_build_templatesextends","title":"test_templates.py::test_build_templates[extends]","text":"<pre>test_templates.py::test_build_templates[extends]</pre><pre>\ntemplate = 'extends'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_extends_0/templates'\n\n    @pytest.mark.parametrize(\"template\", [\"include\", \"no-templates\", \"extends\", \"super\"])\n    def test_build_templates(template, output_dir):\n        \"\"\"\n        Verify Templates Design keywords.\n\n        no-templates is a compatibility tests for repo without `templates` directory\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            f'tests/test-templates/{template}',\n            no_input=True,\n            output_dir=output_dir,\n        )\n\ntests/test_templates.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-templates/extends', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_extends_0/templates'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_templatespytest_build_templatessuper","title":"test_templates.py::test_build_templates[super]","text":"<pre>test_templates.py::test_build_templates[super]</pre><pre>\ntemplate = 'super'\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_super_0/templates'\n\n    @pytest.mark.parametrize(\"template\", [\"include\", \"no-templates\", \"extends\", \"super\"])\n    def test_build_templates(template, output_dir):\n        \"\"\"\n        Verify Templates Design keywords.\n\n        no-templates is a compatibility tests for repo without `templates` directory\n        \"\"\"\n&gt;       project_dir = main.cookiecutter(\n            f'tests/test-templates/{template}',\n            no_input=True,\n            output_dir=output_dir,\n        )\n\ntests/test_templates.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntemplate = 'tests/test-templates/super', checkout = None, no_input = True\nextra_context = None, replay = None, overwrite_if_exists = False\noutput_dir = '/tmp/pytest-of-root/pytest-0/test_build_templates_super_0/templates'\nconfig_file = None, default_config = False, password = None, directory = None\nskip_if_file_exists = False, accept_hooks = True\nkeep_project_on_failure = False\n\n    def cookiecutter(template, checkout=None, no_input=False, extra_context=\n        None, replay=None, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None, directory=None,\n        skip_if_file_exists=False, accept_hooks=True, keep_project_on_failure=False\n        ):\n        \"\"\"\n        Run Cookiecutter just as if using it from the command line.\n\n        :param template: A directory containing a project template directory,\n            or a URL to a git repository.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param no_input: Do not prompt for user input.\n            Use default values for template parameters taken from `cookiecutter.json`, user\n            config and `extra_dict`. Force a refresh of cached resources.\n        :param extra_context: A dictionary of context that overrides default\n            and user configuration.\n        :param replay: Do not prompt for input, instead read from saved json. If\n            ``True`` read from the ``replay_dir``.\n            if it exists\n        :param overwrite_if_exists: Overwrite the contents of the output directory\n            if it exists.\n        :param output_dir: Where to output the generated project dir into.\n        :param config_file: User configuration file path.\n        :param default_config: Use default values rather than a config file.\n        :param password: The password to use when extracting the repository.\n        :param directory: Relative path to a cookiecutter template in a repository.\n        :param skip_if_file_exists: Skip the files in the corresponding directories\n            if they already exist.\n        :param accept_hooks: Accept pre and post hooks if set to `True`.\n        :param keep_project_on_failure: If `True` keep generated project directory even when\n            generation fails\n        \"\"\"\n        # Get user configuration\n        config_dict = get_user_config(config_file=config_file, default_config=default_config)\n\n        # Determine the template directory\n&gt;       repo_dir, cleanup = determine_repo_dir(\n            template=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input,\n            password=password,\n            directory=directory\n        )\nE       TypeError: determine_repo_dir() missing 1 required positional argument: 'abbreviations'\n\ncookiecutter/main.py:59: TypeError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_tz_is_required","title":"test_time_extension.py::test_tz_is_required","text":"<pre>test_time_extension.py::test_tz_is_required</pre><pre>\nenvironment = \n\n    def test_tz_is_required(environment):\n        \"\"\"Verify template parsing fails without a timezone.\"\"\"\n        with pytest.raises(exceptions.TemplateSyntaxError):\n&gt;           environment.from_string('{% now %}')\n\ntests/test_time_extension.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_utc_default_datetime_format","title":"test_time_extension.py::test_utc_default_datetime_format","text":"<pre>test_time_extension.py::test_utc_default_datetime_format</pre><pre>\nenvironment = \n\n    def test_utc_default_datetime_format(environment):\n        \"\"\"Verify default datetime format can be parsed.\"\"\"\n&gt;       template = environment.from_string(\"{% now 'utc' %}\")\n\ntests/test_time_extension.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_accept_valid_timezonesutc","title":"test_time_extension.py::test_accept_valid_timezones[utc]","text":"<pre>test_time_extension.py::test_accept_valid_timezones[utc]</pre><pre>\nenvironment = \nvalid_tz = 'utc'\n\n    @pytest.mark.parametrize(\"valid_tz\", ['utc', 'local', 'Europe/Berlin'])\n    def test_accept_valid_timezones(environment, valid_tz):\n        \"\"\"Verify that valid timezones are accepted.\"\"\"\n&gt;       template = environment.from_string(f\"{{% now '{valid_tz}', '%Y-%m' %}}\")\n\ntests/test_time_extension.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_accept_valid_timezoneslocal","title":"test_time_extension.py::test_accept_valid_timezones[local]","text":"<pre>test_time_extension.py::test_accept_valid_timezones[local]</pre><pre>\nenvironment = \nvalid_tz = 'local'\n\n    @pytest.mark.parametrize(\"valid_tz\", ['utc', 'local', 'Europe/Berlin'])\n    def test_accept_valid_timezones(environment, valid_tz):\n        \"\"\"Verify that valid timezones are accepted.\"\"\"\n&gt;       template = environment.from_string(f\"{{% now '{valid_tz}', '%Y-%m' %}}\")\n\ntests/test_time_extension.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#berlin","title":"Berlin]","text":"<pre>Berlin]</pre><pre>\nenvironment = \nvalid_tz = 'Europe/Berlin'\n\n    @pytest.mark.parametrize(\"valid_tz\", ['utc', 'local', 'Europe/Berlin'])\n    def test_accept_valid_timezones(environment, valid_tz):\n        \"\"\"Verify that valid timezones are accepted.\"\"\"\n&gt;       template = environment.from_string(f\"{{% now '{valid_tz}', '%Y-%m' %}}\")\n\ntests/test_time_extension.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_environment_datetime_format","title":"test_time_extension.py::test_environment_datetime_format","text":"<pre>test_time_extension.py::test_environment_datetime_format</pre><pre>\nenvironment = \n\n    def test_environment_datetime_format(environment):\n        \"\"\"Verify datetime format can be parsed from environment.\"\"\"\n        environment.datetime_format = '%a, %d %b %Y %H:%M:%S'\n\n&gt;       template = environment.from_string(\"{% now 'utc' %}\")\n\ntests/test_time_extension.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_add_time","title":"test_time_extension.py::test_add_time","text":"<pre>test_time_extension.py::test_add_time</pre><pre>\nenvironment = \n\n    def test_add_time(environment):\n        \"\"\"Verify that added time offset can be parsed.\"\"\"\n        environment.datetime_format = '%a, %d %b %Y %H:%M:%S'\n\n&gt;       template = environment.from_string(\"{% now 'utc' + 'hours=2,seconds=30' %}\")\n\ntests/test_time_extension.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_substract_time","title":"test_time_extension.py::test_substract_time","text":"<pre>test_time_extension.py::test_substract_time</pre><pre>\nenvironment = \n\n    def test_substract_time(environment):\n        \"\"\"Verify that substracted time offset can be parsed.\"\"\"\n        environment.datetime_format = '%a, %d %b %Y %H:%M:%S'\n\n&gt;       template = environment.from_string(\"{% now 'utc' - 'minutes=11' %}\")\n\ntests/test_time_extension.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_time_extensionpytest_offset_with_format","title":"test_time_extension.py::test_offset_with_format","text":"<pre>test_time_extension.py::test_offset_with_format</pre><pre>\nenvironment = \n\n    def test_offset_with_format(environment):\n        \"\"\"Verify that offset works together with datetime format.\"\"\"\n        environment.datetime_format = '%d %b %Y %H:%M:%S'\n\n&gt;       template = environment.from_string(\n            \"{% now 'utc' - 'days=2,minutes=33,seconds=1', '%d %b %Y %H:%M:%S' %}\"\n        )\n\ntests/test_time_extension.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n.venv/lib/python3.10/site-packages/jinja2/environment.py:1108: in from_string\n    return cls.from_code(self, self.compile(source), gs, None)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:760: in compile\n    source = self._parse(source, name, filename)\n.venv/lib/python3.10/site-packages/jinja2/environment.py:619: in _parse\n    return Parser(self, source, name, filename).parse()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1039: in parse\n    result = nodes.Template(self.subparse(), lineno=1)\n.venv/lib/python3.10/site-packages/jinja2/parser.py:1022: in subparse\n    rv = self.parse_statement()\n.venv/lib/python3.10/site-packages/jinja2/parser.py:184: in parse_statement\n    return ext(self)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nparser = \n\n    def parse(self, parser):\n        \"\"\"Parse datetime template and add datetime value.\"\"\"\n        lineno = next(parser.stream).lineno\n&gt;       token = parser.stream.next()\nE       AttributeError: 'TokenStream' object has no attribute 'next'\n\ncookiecutter/extensions.py:79: AttributeError"},{"location":"analysis_baseline_cookiecutter/#test_utilspytest_make_sure_path_exists_correctly_handle_os_error","title":"test_utils.py::test_make_sure_path_exists_correctly_handle_os_error","text":"<pre>test_utils.py::test_make_sure_path_exists_correctly_handle_os_error</pre><pre>\nmocker = \n\n    def test_make_sure_path_exists_correctly_handle_os_error(mocker):\n        \"\"\"Verify correct True/False response from `utils.make_sure_path_exists`.\n\n        Should return True if directory exist or created.\n        Should return False if impossible to create directory (for example protected)\n        \"\"\"\n        mocker.patch(\"pathlib.Path.mkdir\", side_effect=OSError)\n&gt;       with pytest.raises(OSError) as err:\nE       Failed: DID NOT RAISE \n\ntests/test_utils.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#test_utilspytest_create_tmp_repo_dir","title":"test_utils.py::test_create_tmp_repo_dir","text":"<pre>test_utils.py::test_create_tmp_repo_dir</pre><pre>\ntmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_create_tmp_repo_dir0')\n\n    def test_create_tmp_repo_dir(tmp_path):\n        \"\"\"Verify `utils.create_tmp_repo_dir` creates a copy.\"\"\"\n        repo_dir = Path(tmp_path) / 'bar'\n        repo_dir.mkdir()\n        subdirs = ('foo', 'bar', 'foobar')\n        for name in subdirs:\n            (repo_dir / name).mkdir()\n\n&gt;       new_repo_dir = utils.create_tmp_repo_dir(repo_dir)\n\ntests/test_utils.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/utils.py:78: in create_tmp_repo_dir\n    shutil.copytree(repo_dir, temp_dir, symlinks=True)\n/usr/lib/python3.10/shutil.py:559: in copytree\n    return _copytree(entries=entries, src=src, dst=dst, symlinks=symlinks,\n/usr/lib/python3.10/shutil.py:457: in _copytree\n    os.makedirs(dst, exist_ok=dirs_exist_ok)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = PosixPath('/tmp/tmpysbppbmp'), mode = 511, exist_ok = False\n\n    def makedirs(name, mode=0o777, exist_ok=False):\n        \"\"\"makedirs(name [, mode=0o777][, exist_ok=False])\n\n        Super-mkdir; create a leaf directory and all intermediate ones.  Works like\n        mkdir, except that any intermediate path segment (not just the rightmost)\n        will be created if it does not exist. If the target directory already\n        exists, raise an OSError if exist_ok is False. Otherwise no exception is\n        raised.  This is recursive.\n\n        \"\"\"\n        head, tail = path.split(name)\n        if not tail:\n            head, tail = path.split(head)\n        if head and tail and not path.exists(head):\n            try:\n                makedirs(head, exist_ok=exist_ok)\n            except FileExistsError:\n                # Defeats race condition when another thread created the path\n                pass\n            cdir = curdir\n            if isinstance(tail, bytes):\n                cdir = bytes(curdir, 'ASCII')\n            if tail == cdir:           # xxx/newdir/. exists if xxx/newdir exists\n                return\n        try:\n&gt;           mkdir(name, mode)\nE           FileExistsError: [Errno 17] File exists: '/tmp/tmpysbppbmp'\n\n/usr/lib/python3.10/os.py:225: FileExistsError\n</pre>"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_should_rstrip_trailing_slash_in_repo_url","title":"test_clone.py::test_clone_should_rstrip_trailing_slash_in_repo_url","text":"<pre>test_clone.py::test_clone_should_rstrip_trailing_slash_in_repo_url</pre><pre>\nself = \nargs = (['git', 'clone', 'https://github.com/foo/bar'],)\nkwargs = {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2}\nexpected = call('', (['git', 'clone', 'https://github.com/foo/bar'],), {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2})\nactual = call('', (['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'],), {'stderr': -2})\n_error_message = ._error_message at 0x7f8dd2b8b9a0&gt;\ncause = None\n\n    def assert_called_with(self, /, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n\n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n&gt;           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: check_output(['git', 'clone', 'https://github.com/foo/bar'], cwd=PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), stderr=-2)\nE           Actual: check_output(['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'], stderr=-2)\n\n/usr/lib/python3.10/unittest/mock.py:929: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = \nargs = (['git', 'clone', 'https://github.com/foo/bar'],)\nkwargs = {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2}\n\n    def assert_called_once_with(self, /, *args, **kwargs):\n        \"\"\"assert that the mock was called exactly once and that that call was\n        with the specified arguments.\"\"\"\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to be called once. Called %s times.%s\"\n                   % (self._mock_name or 'mock',\n                      self.call_count,\n                      self._calls_repr()))\n            raise AssertionError(msg)\n&gt;       return self.assert_called_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: check_output(['git', 'clone', 'https://github.com/foo/bar'], cwd=PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), stderr=-2)\nE       Actual: check_output(['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'], stderr=-2)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert (['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'],) == (['git', 'clone', 'https://github.com/foo/bar'],)\nE         \nE         At index 0 diff: ['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'] != ['git', 'clone', 'https://github.com/foo/bar']\nE         \nE         Full diff:\nE           (\nE               [\nE                   'git',\nE                   'clone',\nE         -         'https://github.com/foo/bar',\nE         +         'https://github.com/foo/bar/',\nE         ?                                    +\nE         +         '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar',\nE               ],\nE           )\nE       Kwargs:\nE       assert {'stderr': -2} == {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2}\nE         \nE         Common items:\nE         {'stderr': -2}\nE         Right contains 1 more item:\nE         {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir')}\nE         \nE         Full diff:\nE           {\nE         -     'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'),\nE               'stderr': -2,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:941: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir')\n\n    def test_clone_should_rstrip_trailing_slash_in_repo_url(mocker, clone_dir):\n        \"\"\"In `clone()`, repo URL's trailing slash should be stripped if one is \\\n        present.\"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n\n        vcs.clone('https://github.com/foo/bar/', clone_to_dir=clone_dir, no_input=True)\n\n&gt;       mock_subprocess.assert_called_once_with(\n            ['git', 'clone', 'https://github.com/foo/bar'],\n            cwd=clone_dir,\n            stderr=subprocess.STDOUT,\n        )\n\ntests/vcs/test_clone.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (['git', 'clone', 'https://github.com/foo/bar'],)\nkwargs = {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2}\n\n    def assert_called_once_with(*args, **kwargs):\n&gt;       return mock.assert_called_once_with(*args, **kwargs)\nE       AssertionError: expected call not found.\nE       Expected: check_output(['git', 'clone', 'https://github.com/foo/bar'], cwd=PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), stderr=-2)\nE       Actual: check_output(['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'], stderr=-2)\nE       \nE       pytest introspection follows:\nE       \nE       Args:\nE       assert (['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'],) == (['git', 'clone', 'https://github.com/foo/bar'],)\nE         \nE         At index 0 diff: ['git', 'clone', 'https://github.com/foo/bar/', '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar'] != ['git', 'clone', 'https://github.com/foo/bar']\nE         \nE         Full diff:\nE           (\nE               [\nE                   'git',\nE                   'clone',\nE         -         'https://github.com/foo/bar',\nE         +         'https://github.com/foo/bar/',\nE         ?                                    +\nE         +         '/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir/bar',\nE               ],\nE           )\nE       Kwargs:\nE       assert {'stderr': -2} == {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'), 'stderr': -2}\nE         \nE         Common items:\nE         {'stderr': -2}\nE         Right contains 1 more item:\nE         {'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir')}\nE         \nE         Full diff:\nE           {\nE         -     'cwd': PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_rstrip_trail0/clone_dir'),\nE               'stderr': -2,\nE           }\n\n/usr/lib/python3.10/unittest/mock.py:213: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_should_silent_exit_if_ok_to_reuse","title":"test_clone.py::test_clone_should_silent_exit_if_ok_to_reuse","text":"<pre>test_clone.py::test_clone_should_silent_exit_if_ok_to_reuse</pre><pre>\nmocker = \ntmpdir = local('/tmp/pytest-of-root/pytest-0/test_clone_should_silent_exit_0')\n\n    def test_clone_should_silent_exit_if_ok_to_reuse(mocker, tmpdir):\n        \"\"\"In `clone()`, if user doesn't want to reclone, Cookiecutter should exit \\\n        without cloning anything.\"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n        mocker.patch(\n            'cookiecutter.vcs.prompt_and_delete', return_value=False, autospec=True\n        )\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n\n        clone_to_dir = tmpdir.mkdir('clone')\n\n        # Create repo_dir to trigger prompt_and_delete\n        clone_to_dir.mkdir('cookiecutter-pytest-plugin')\n\n        repo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'\n\n        vcs.clone(repo_url, clone_to_dir=str(clone_to_dir))\n&gt;       assert not mock_subprocess.called\nE       assert not True\nE        +  where True = .called\n\ntests/vcs/test_clone.py:84: AssertionError"},{"location":"analysis_baseline_cookiecutter/#worldgit-world","title":"world.git-world]","text":"<pre>world.git-world]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c0/clone_dir')\nrepo_type = 'git', repo_url = 'https://github.com/hello/world.git'\nrepo_name = 'world'\n\n    @pytest.mark.parametrize(\n        'repo_type, repo_url, repo_name',\n        [\n            ('git', 'https://github.com/hello/world.git', 'world'),\n            ('hg', 'https://bitbucket.org/foo/bar', 'bar'),\n            ('git', 'git@host:gitoliterepo', 'gitoliterepo'),\n            ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n            ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n        ],\n    )\n    def test_clone_should_invoke_vcs_command(\n        mocker, clone_dir, repo_type, repo_url, repo_name\n    ):\n        \"\"\"When `clone()` is called with a git/hg repo, the corresponding VCS \\\n        command should be run via `subprocess.check_output()`.\n\n        This should take place:\n        * In the correct dir\n        * With the correct args.\n        \"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n        expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))\n\n        branch = 'foobar'\n\n&gt;       repo_dir = vcs.clone(\n            repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True\n        )\n\ntests/vcs/test_clone.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://github.com/hello/world.git', checkout = 'foobar'\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n                raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\n\n        if checkout:\n            if repo_type == 'git':\n                checkout_cmd = ['git', 'checkout', checkout]\n            else:  # hg\n                checkout_cmd = ['hg', 'update', checkout]\n\n            with Path.cwd():\n&gt;               os.chdir(repo_dir)\nE               FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c0/clone_dir/world'\n\ncookiecutter/vcs.py:101: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#bar-bar","title":"bar-bar]","text":"<pre>bar-bar]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c1/clone_dir')\nrepo_type = 'hg', repo_url = 'https://bitbucket.org/foo/bar', repo_name = 'bar'\n\n    @pytest.mark.parametrize(\n        'repo_type, repo_url, repo_name',\n        [\n            ('git', 'https://github.com/hello/world.git', 'world'),\n            ('hg', 'https://bitbucket.org/foo/bar', 'bar'),\n            ('git', 'git@host:gitoliterepo', 'gitoliterepo'),\n            ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n            ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n        ],\n    )\n    def test_clone_should_invoke_vcs_command(\n        mocker, clone_dir, repo_type, repo_url, repo_name\n    ):\n        \"\"\"When `clone()` is called with a git/hg repo, the corresponding VCS \\\n        command should be run via `subprocess.check_output()`.\n\n        This should take place:\n        * In the correct dir\n        * With the correct args.\n        \"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n        expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))\n\n        branch = 'foobar'\n\n&gt;       repo_dir = vcs.clone(\n            repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True\n        )\n\ntests/vcs/test_clone.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://bitbucket.org/foo/bar', checkout = 'foobar'\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c1/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n                raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\n\n        if checkout:\n            if repo_type == 'git':\n                checkout_cmd = ['git', 'checkout', checkout]\n            else:  # hg\n                checkout_cmd = ['hg', 'update', checkout]\n\n            with Path.cwd():\n&gt;               os.chdir(repo_dir)\nE               FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c1/clone_dir/bar'\n\ncookiecutter/vcs.py:101: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_should_invoke_vcs_commandgit-githostgitoliterepo-gitoliterepo","title":"test_clone.py::test_clone_should_invoke_vcs_command[git-git@host:gitoliterepo-gitoliterepo]","text":"<pre>test_clone.py::test_clone_should_invoke_vcs_command[git-git@host:gitoliterepo-gitoliterepo]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c2/clone_dir')\nrepo_type = 'git', repo_url = 'git@host:gitoliterepo'\nrepo_name = 'gitoliterepo'\n\n    @pytest.mark.parametrize(\n        'repo_type, repo_url, repo_name',\n        [\n            ('git', 'https://github.com/hello/world.git', 'world'),\n            ('hg', 'https://bitbucket.org/foo/bar', 'bar'),\n            ('git', 'git@host:gitoliterepo', 'gitoliterepo'),\n            ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n            ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n        ],\n    )\n    def test_clone_should_invoke_vcs_command(\n        mocker, clone_dir, repo_type, repo_url, repo_name\n    ):\n        \"\"\"When `clone()` is called with a git/hg repo, the corresponding VCS \\\n        command should be run via `subprocess.check_output()`.\n\n        This should take place:\n        * In the correct dir\n        * With the correct args.\n        \"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n        expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))\n\n        branch = 'foobar'\n\n&gt;       repo_dir = vcs.clone(\n            repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True\n        )\n\ntests/vcs/test_clone.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'git@host:gitoliterepo', checkout = 'foobar'\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c2/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n&gt;       repo_type, repo_url = identify_repo(repo_url)\nE       TypeError: cannot unpack non-iterable NoneType object\n\ncookiecutter/vcs.py:61: TypeError"},{"location":"analysis_baseline_cookiecutter/#cookiecuttergit-cookiecutter","title":"cookiecutter.git-cookiecutter]","text":"<pre>cookiecutter.git-cookiecutter]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c3/clone_dir')\nrepo_type = 'git', repo_url = 'git@gitlab.com:cookiecutter/cookiecutter.git'\nrepo_name = 'cookiecutter'\n\n    @pytest.mark.parametrize(\n        'repo_type, repo_url, repo_name',\n        [\n            ('git', 'https://github.com/hello/world.git', 'world'),\n            ('hg', 'https://bitbucket.org/foo/bar', 'bar'),\n            ('git', 'git@host:gitoliterepo', 'gitoliterepo'),\n            ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n            ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n        ],\n    )\n    def test_clone_should_invoke_vcs_command(\n        mocker, clone_dir, repo_type, repo_url, repo_name\n    ):\n        \"\"\"When `clone()` is called with a git/hg repo, the corresponding VCS \\\n        command should be run via `subprocess.check_output()`.\n\n        This should take place:\n        * In the correct dir\n        * With the correct args.\n        \"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n        expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))\n\n        branch = 'foobar'\n\n&gt;       repo_dir = vcs.clone(\n            repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True\n        )\n\ntests/vcs/test_clone.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'git@gitlab.com:cookiecutter/cookiecutter.git', checkout = 'foobar'\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c3/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n                raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\n\n        if checkout:\n            if repo_type == 'git':\n                checkout_cmd = ['git', 'checkout', checkout]\n            else:  # hg\n                checkout_cmd = ['hg', 'update', checkout]\n\n            with Path.cwd():\n&gt;               os.chdir(repo_dir)\nE               FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c3/clone_dir/cookiecutter'\n\ncookiecutter/vcs.py:101: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#cookiecuttergit-cookiecutter_1","title":"cookiecutter.git-cookiecutter]","text":"<pre>cookiecutter.git-cookiecutter]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c4/clone_dir')\nrepo_type = 'git', repo_url = 'git@github.com:cookiecutter/cookiecutter.git'\nrepo_name = 'cookiecutter'\n\n    @pytest.mark.parametrize(\n        'repo_type, repo_url, repo_name',\n        [\n            ('git', 'https://github.com/hello/world.git', 'world'),\n            ('hg', 'https://bitbucket.org/foo/bar', 'bar'),\n            ('git', 'git@host:gitoliterepo', 'gitoliterepo'),\n            ('git', 'git@gitlab.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n            ('git', 'git@github.com:cookiecutter/cookiecutter.git', 'cookiecutter'),\n        ],\n    )\n    def test_clone_should_invoke_vcs_command(\n        mocker, clone_dir, repo_type, repo_url, repo_name\n    ):\n        \"\"\"When `clone()` is called with a git/hg repo, the corresponding VCS \\\n        command should be run via `subprocess.check_output()`.\n\n        This should take place:\n        * In the correct dir\n        * With the correct args.\n        \"\"\"\n        mocker.patch('cookiecutter.vcs.is_vcs_installed', autospec=True, return_value=True)\n\n        mock_subprocess = mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n        )\n        expected_repo_dir = os.path.normpath(os.path.join(clone_dir, repo_name))\n\n        branch = 'foobar'\n\n&gt;       repo_dir = vcs.clone(\n            repo_url, checkout=branch, clone_to_dir=clone_dir, no_input=True\n        )\n\ntests/vcs/test_clone.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'git@github.com:cookiecutter/cookiecutter.git', checkout = 'foobar'\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c4/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n                raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\n\n        if checkout:\n            if repo_type == 'git':\n                checkout_cmd = ['git', 'checkout', checkout]\n            else:  # hg\n                checkout_cmd = ['hg', 'update', checkout]\n\n            with Path.cwd():\n&gt;               os.chdir(repo_dir)\nE               FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_clone_should_invoke_vcs_c4/clone_dir/cookiecutter'\n\ncookiecutter/vcs.py:101: FileNotFoundError"},{"location":"analysis_baseline_cookiecutter/#cookiedozer-not-found","title":"cookiedozer' not found]","text":"<pre>cookiedozer' not found]</pre><pre>\nrepo_url = 'https://github.com/hackebro/cookiedozer', checkout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_f0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n&gt;           subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n\ncookiecutter/vcs.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (['git', 'clone', 'https://github.com/hackebro/cookiedozer', '/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_f0/clone_dir/cookiedozer'],)\nkwargs = {'stderr': -2}\neffect = \nresult = CalledProcessError(-1, 'cmd')\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n                raise effect\n            elif not _callable(effect):\n                result = next(effect)\n                if _is_exception(result):\n&gt;                   raise result\nE                   subprocess.CalledProcessError: Command 'cmd' died with .\n\n/usr/lib/python3.10/unittest/mock.py:1177: CalledProcessError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_f0/clone_dir')\nerror_message = b\"fatal: repository 'https://github.com/hackebro/cookiedozer' not found\"\n\n    @pytest.mark.parametrize(\n        'error_message',\n        [\n            (b\"fatal: repository 'https://github.com/hackebro/cookiedozer' not found\"),\n            b'hg: abort: HTTP Error 404: Not Found',\n        ],\n    )\n    def test_clone_handles_repo_typo(mocker, clone_dir, error_message):\n        \"\"\"In `clone()`, repository not found errors should raise an \\\n        appropriate exception.\"\"\"\n        # side_effect is set to an iterable here (and below),\n        # because of a Python 3.4 unittest.mock regression\n        # http://bugs.python.org/issue23661\n        mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n            side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],\n        )\n\n        repository_url = 'https://github.com/hackebro/cookiedozer'\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n&gt;           vcs.clone(repository_url, clone_to_dir=str(clone_dir), no_input=True)\n\ntests/vcs/test_clone.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://github.com/hackebro/cookiedozer', checkout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_f0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n&gt;               raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\nE               cookiecutter.exceptions.RepositoryCloneFailed: Cloning https://github.com/hackebro/cookiedozer failed: fatal: repository 'https://github.com/hackebro/cookiedozer' not found\n\ncookiecutter/vcs.py:92: RepositoryCloneFailed"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_handles_repo_typohg-abort-http-error-404-not-found","title":"test_clone.py::test_clone_handles_repo_typo[hg: abort: HTTP Error 404: Not Found]","text":"<pre>test_clone.py::test_clone_handles_repo_typo[hg: abort: HTTP Error 404: Not Found]</pre><pre>\nrepo_url = 'https://github.com/hackebro/cookiedozer', checkout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_h0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n&gt;           subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n\ncookiecutter/vcs.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (['git', 'clone', 'https://github.com/hackebro/cookiedozer', '/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_h0/clone_dir/cookiedozer'],)\nkwargs = {'stderr': -2}\neffect = \nresult = CalledProcessError(-1, 'cmd')\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n                raise effect\n            elif not _callable(effect):\n                result = next(effect)\n                if _is_exception(result):\n&gt;                   raise result\nE                   subprocess.CalledProcessError: Command 'cmd' died with .\n\n/usr/lib/python3.10/unittest/mock.py:1177: CalledProcessError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_h0/clone_dir')\nerror_message = b'hg: abort: HTTP Error 404: Not Found'\n\n    @pytest.mark.parametrize(\n        'error_message',\n        [\n            (b\"fatal: repository 'https://github.com/hackebro/cookiedozer' not found\"),\n            b'hg: abort: HTTP Error 404: Not Found',\n        ],\n    )\n    def test_clone_handles_repo_typo(mocker, clone_dir, error_message):\n        \"\"\"In `clone()`, repository not found errors should raise an \\\n        appropriate exception.\"\"\"\n        # side_effect is set to an iterable here (and below),\n        # because of a Python 3.4 unittest.mock regression\n        # http://bugs.python.org/issue23661\n        mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n            side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],\n        )\n\n        repository_url = 'https://github.com/hackebro/cookiedozer'\n        with pytest.raises(exceptions.RepositoryNotFound) as err:\n&gt;           vcs.clone(repository_url, clone_to_dir=str(clone_dir), no_input=True)\n\ntests/vcs/test_clone.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://github.com/hackebro/cookiedozer', checkout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_repo_typo_h0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n&gt;               raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\nE               cookiecutter.exceptions.RepositoryCloneFailed: Cloning https://github.com/hackebro/cookiedozer failed: hg: abort: HTTP Error 404: Not Found\n\ncookiecutter/vcs.py:92: RepositoryCloneFailed"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_handles_branch_typoerror-pathspec-unknown_branch-did-not-match-any-files-known-to-git","title":"test_clone.py::test_clone_handles_branch_typo[error: pathspec 'unknown_branch' did not match any file(s) known to git]","text":"<pre>test_clone.py::test_clone_handles_branch_typo[error: pathspec 'unknown_branch' did not match any file(s) known to git]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_branch_typo0/clone_dir')\nerror_message = b\"error: pathspec 'unknown_branch' did not match any file(s) known to git\"\n\n    @pytest.mark.parametrize(\n        'error_message',\n        [\n            b\"error: pathspec 'unknown_branch' did not match any file(s) known to git\",\n            b\"hg: abort: unknown revision 'unknown_branch'!\",\n        ],\n    )\n    def test_clone_handles_branch_typo(mocker, clone_dir, error_message):\n        \"\"\"In `clone()`, branch not found errors should raise an \\\n        appropriate exception.\"\"\"\n        mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n            side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],\n        )\n\n        repository_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin'\n        with pytest.raises(exceptions.RepositoryCloneFailed) as err:\n            vcs.clone(\n                repository_url,\n                clone_to_dir=str(clone_dir),\n                checkout='unknown_branch',\n                no_input=True,\n            )\n\n&gt;       assert str(err.value) == (\n            'The unknown_branch branch of repository '\n            f'{repository_url} could not found, have you made a typo?'\n        )\nE       assert \"Cloning https://github.com/pytest-dev/cookiecutter-pytest-plugin failed: error: pathspec 'unknown_branch' did not match any file(s) known to git\" == 'The unknown_branch branch of repository https://github.com/pytest-dev/cookiecutter-pytest-plugin could not found, have you made a typo?'\nE         \nE         - The unknown_branch branch of repository https://github.com/pytest-dev/cookiecutter-pytest-plugin could not found, have you made a typo?\nE         + Cloning https://github.com/pytest-dev/cookiecutter-pytest-plugin failed: error: pathspec 'unknown_branch' did not match any file(s) known to git\n\ntests/vcs/test_clone.py:192: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_handles_branch_typohg-abort-unknown-revision-unknown_branch","title":"test_clone.py::test_clone_handles_branch_typo[hg: abort: unknown revision 'unknown_branch'!]","text":"<pre>test_clone.py::test_clone_handles_branch_typo[hg: abort: unknown revision 'unknown_branch'!]</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_handles_branch_typo1/clone_dir')\nerror_message = b\"hg: abort: unknown revision 'unknown_branch'!\"\n\n    @pytest.mark.parametrize(\n        'error_message',\n        [\n            b\"error: pathspec 'unknown_branch' did not match any file(s) known to git\",\n            b\"hg: abort: unknown revision 'unknown_branch'!\",\n        ],\n    )\n    def test_clone_handles_branch_typo(mocker, clone_dir, error_message):\n        \"\"\"In `clone()`, branch not found errors should raise an \\\n        appropriate exception.\"\"\"\n        mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n            side_effect=[subprocess.CalledProcessError(-1, 'cmd', output=error_message)],\n        )\n\n        repository_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin'\n        with pytest.raises(exceptions.RepositoryCloneFailed) as err:\n            vcs.clone(\n                repository_url,\n                clone_to_dir=str(clone_dir),\n                checkout='unknown_branch',\n                no_input=True,\n            )\n\n&gt;       assert str(err.value) == (\n            'The unknown_branch branch of repository '\n            f'{repository_url} could not found, have you made a typo?'\n        )\nE       assert \"Cloning https://github.com/pytest-dev/cookiecutter-pytest-plugin failed: hg: abort: unknown revision 'unknown_branch'!\" == 'The unknown_branch branch of repository https://github.com/pytest-dev/cookiecutter-pytest-plugin could not found, have you made a typo?'\nE         \nE         - The unknown_branch branch of repository https://github.com/pytest-dev/cookiecutter-pytest-plugin could not found, have you made a typo?\nE         + Cloning https://github.com/pytest-dev/cookiecutter-pytest-plugin failed: hg: abort: unknown revision 'unknown_branch'!\n\ntests/vcs/test_clone.py:192: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_clonepytest_clone_unknown_subprocess_error","title":"test_clone.py::test_clone_unknown_subprocess_error","text":"<pre>test_clone.py::test_clone_unknown_subprocess_error</pre><pre>\nrepo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin'\ncheckout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_unknown_subprocess_0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n&gt;           subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n\ncookiecutter/vcs.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/unittest/mock.py:1114: in __call__\n    return self._mock_call(*args, **kwargs)\n/usr/lib/python3.10/unittest/mock.py:1118: in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nargs = (['git', 'clone', 'https://github.com/pytest-dev/cookiecutter-pytest-plugin', '/tmp/pytest-of-root/pytest-0/test_clone_unknown_subprocess_0/clone_dir/cookiecutter-pytest-plugin'],)\nkwargs = {'stderr': -2}\neffect = \nresult = CalledProcessError(-1, 'cmd')\n\n    def _execute_mock_call(self, /, *args, **kwargs):\n        # separate from _increment_mock_call so that awaited functions are\n        # executed separately from their call, also AsyncMock overrides this method\n\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n                raise effect\n            elif not _callable(effect):\n                result = next(effect)\n                if _is_exception(result):\n&gt;                   raise result\nE                   subprocess.CalledProcessError: Command 'cmd' died with .\n\n/usr/lib/python3.10/unittest/mock.py:1177: CalledProcessError\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_unknown_subprocess_0/clone_dir')\n\n    def test_clone_unknown_subprocess_error(mocker, clone_dir):\n        \"\"\"In `clone()`, unknown subprocess errors should be raised.\"\"\"\n        mocker.patch(\n            'cookiecutter.vcs.subprocess.check_output',\n            autospec=True,\n            side_effect=[\n                subprocess.CalledProcessError(-1, 'cmd', output=b'Something went wrong')\n            ],\n        )\n\n        with pytest.raises(subprocess.CalledProcessError):\n&gt;           vcs.clone(\n                'https://github.com/pytest-dev/cookiecutter-pytest-plugin',\n                clone_to_dir=str(clone_dir),\n                no_input=True,\n            )\n\ntests/vcs/test_clone.py:209: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nrepo_url = 'https://github.com/pytest-dev/cookiecutter-pytest-plugin'\ncheckout = None\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_clone_unknown_subprocess_0/clone_dir')\nno_input = True\n\n    def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n        'os.PathLike[str]'='.', no_input: bool=False):\n        \"\"\"Clone a repo to the current directory.\n\n        :param repo_url: Repo URL of unknown type.\n        :param checkout: The branch, tag or commit ID to checkout after clone.\n        :param clone_to_dir: The directory to clone to.\n                             Defaults to the current directory.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :returns: str with path to the new directory of the repository.\n        \"\"\"\n        repo_type, repo_url = identify_repo(repo_url)\n        if repo_type is None:\n            raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n\n        if not is_vcs_installed(repo_type):\n            raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n\n        clone_to_dir = Path(clone_to_dir).resolve()\n        make_sure_path_exists(clone_to_dir)\n\n        repo_dir = clone_to_dir / Path(repo_url).stem\n\n        if repo_dir.exists():\n            if no_input:\n                logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n                subprocess.check_call([repo_type, 'init', str(repo_dir)])\n            else:\n                prompt_and_delete(repo_dir)\n\n        if repo_type == 'git':\n            clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n        else:  # hg\n            clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n\n        try:\n            subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            output = e.output.decode('utf-8')\n            if 'Repository not found' in output:\n                raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n            else:\n&gt;               raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\nE               cookiecutter.exceptions.RepositoryCloneFailed: Cloning https://github.com/pytest-dev/cookiecutter-pytest-plugin failed: Something went wrong\n\ncookiecutter/vcs.py:92: RepositoryCloneFailed"},{"location":"analysis_baseline_cookiecutter/#test_identify_repopytest_identify_raise_on_unknown_repofoogit","title":"test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+git]","text":"<pre>test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+git]</pre><pre>\nunknown_repo_type_url = 'foo+git'\n\n    def test_identify_raise_on_unknown_repo(unknown_repo_type_url):\n        \"\"\"Verify different incorrect repositories url syntax trigger error raising.\"\"\"\n&gt;       with pytest.raises(exceptions.UnknownRepoType):\nE       Failed: DID NOT RAISE \n\ntests/vcs/test_identify_repo.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#test_identify_repopytest_identify_raise_on_unknown_repofoohg","title":"test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+hg]","text":"<pre>test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+hg]</pre><pre>\nunknown_repo_type_url = 'foo+hg'\n\n    def test_identify_raise_on_unknown_repo(unknown_repo_type_url):\n        \"\"\"Verify different incorrect repositories url syntax trigger error raising.\"\"\"\n&gt;       with pytest.raises(exceptions.UnknownRepoType):\nE       Failed: DID NOT RAISE \n\ntests/vcs/test_identify_repo.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#test_identify_repopytest_identify_raise_on_unknown_repofoobar","title":"test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+bar]","text":"<pre>test_identify_repo.py::test_identify_raise_on_unknown_repo[foo+bar]</pre><pre>\nunknown_repo_type_url = 'foo+bar'\n\n    def test_identify_raise_on_unknown_repo(unknown_repo_type_url):\n        \"\"\"Verify different incorrect repositories url syntax trigger error raising.\"\"\"\n&gt;       with pytest.raises(exceptions.UnknownRepoType):\nE       Failed: DID NOT RAISE \n\ntests/vcs/test_identify_repo.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#test_identify_repopytest_identify_raise_on_unknown_repofoobar_1","title":"test_identify_repo.py::test_identify_raise_on_unknown_repo[foobar]","text":"<pre>test_identify_repo.py::test_identify_raise_on_unknown_repo[foobar]</pre><pre>\nunknown_repo_type_url = 'foobar'\n\n    def test_identify_raise_on_unknown_repo(unknown_repo_type_url):\n        \"\"\"Verify different incorrect repositories url syntax trigger error raising.\"\"\"\n&gt;       with pytest.raises(exceptions.UnknownRepoType):\nE       Failed: DID NOT RAISE \n\ntests/vcs/test_identify_repo.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#norepotypespecifiedcom","title":"norepotypespecified.com]","text":"<pre>norepotypespecified.com]</pre><pre>\nunknown_repo_type_url = 'http://norepotypespecified.com'\n\n    def test_identify_raise_on_unknown_repo(unknown_repo_type_url):\n        \"\"\"Verify different incorrect repositories url syntax trigger error raising.\"\"\"\n&gt;       with pytest.raises(exceptions.UnknownRepoType):\nE       Failed: DID NOT RAISE \n\ntests/vcs/test_identify_repo.py:70: Failed"},{"location":"analysis_baseline_cookiecutter/#test_is_vcs_installedpytest_is_vcs_installed-false","title":"test_is_vcs_installed.py::test_is_vcs_installed[-False]","text":"<pre>test_is_vcs_installed.py::test_is_vcs_installed[-False]</pre><pre>\nmocker = \nwhich_return = '', result = False\n\n    @pytest.mark.parametrize(\n        'which_return, result',\n        [('', False), (None, False), (False, False), ('/usr/local/bin/git', True)],\n    )\n    def test_is_vcs_installed(mocker, which_return, result):\n        \"\"\"Verify `is_vcs_installed` function correctly handles `which` answer.\"\"\"\n        mocker.patch('cookiecutter.vcs.which', autospec=True, return_value=which_return)\n&gt;       assert vcs.is_vcs_installed('git') == result\nE       AssertionError: assert True == False\nE        +  where True = ('git')\nE        +    where  = vcs.is_vcs_installed\n\ntests/vcs/test_is_vcs_installed.py:15: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_is_vcs_installedpytest_is_vcs_installedfalse-false","title":"test_is_vcs_installed.py::test_is_vcs_installed[False-False]","text":"<pre>test_is_vcs_installed.py::test_is_vcs_installed[False-False]</pre><pre>\nmocker = \nwhich_return = False, result = False\n\n    @pytest.mark.parametrize(\n        'which_return, result',\n        [('', False), (None, False), (False, False), ('/usr/local/bin/git', True)],\n    )\n    def test_is_vcs_installed(mocker, which_return, result):\n        \"\"\"Verify `is_vcs_installed` function correctly handles `which` answer.\"\"\"\n        mocker.patch('cookiecutter.vcs.which', autospec=True, return_value=which_return)\n&gt;       assert vcs.is_vcs_installed('git') == result\nE       AssertionError: assert True == False\nE        +  where True = ('git')\nE        +    where  = vcs.is_vcs_installed\n\ntests/vcs/test_is_vcs_installed.py:15: AssertionError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_local_file","title":"test_unzip.py::test_unzip_local_file","text":"<pre>test_unzip.py::test_unzip_local_file</pre><pre>\nprompt = '', stream = None\n\n    def unix_getpass(prompt='Password: ', stream=None):\n        \"\"\"Prompt for a password, with echo turned off.\n\n        Args:\n          prompt: Written on stream to ask for the input.  Default: 'Password: '\n          stream: A writable file object to display the prompt.  Defaults to\n                  the tty.  If no tty is available defaults to sys.stderr.\n        Returns:\n          The seKr3t input.\n        Raises:\n          EOFError: If our input tty or stdin was closed.\n          GetPassWarning: When we were unable to turn echo off on the input.\n\n        Always restores terminal settings before returning.\n        \"\"\"\n        passwd = None\n        with contextlib.ExitStack() as stack:\n            try:\n                # Always try reading and writing directly on the tty first.\n&gt;               fd = os.open('/dev/tty', os.O_RDWR|os.O_NOCTTY)\nE               OSError: [Errno 5] Input/output error: '/dev/tty'\n\n/usr/lib/python3.10/getpass.py:48: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nprompt = '', stream = None\n\n    def unix_getpass(prompt='Password: ', stream=None):\n        \"\"\"Prompt for a password, with echo turned off.\n\n        Args:\n          prompt: Written on stream to ask for the input.  Default: 'Password: '\n          stream: A writable file object to display the prompt.  Defaults to\n                  the tty.  If no tty is available defaults to sys.stderr.\n        Returns:\n          The seKr3t input.\n        Raises:\n          EOFError: If our input tty or stdin was closed.\n          GetPassWarning: When we were unable to turn echo off on the input.\n\n        Always restores terminal settings before returning.\n        \"\"\"\n        passwd = None\n        with contextlib.ExitStack() as stack:\n            try:\n                # Always try reading and writing directly on the tty first.\n                fd = os.open('/dev/tty', os.O_RDWR|os.O_NOCTTY)\n                tty = io.FileIO(fd, 'w+')\n                stack.enter_context(tty)\n                input = io.TextIOWrapper(tty)\n                stack.enter_context(input)\n                if not stream:\n                    stream = input\n            except OSError:\n                # If that fails, see if stdin can be controlled.\n                stack.close()\n                try:\n&gt;                   fd = sys.stdin.fileno()\nE                   io.UnsupportedOperation: redirected stdin is pseudofile, has no fileno()\n\n/usr/lib/python3.10/getpass.py:59: UnsupportedOperation\n\nDuring handling of the above exception, another exception occurred:\n\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_local_file0/clone_dir')\n\n    def test_unzip_local_file(mocker, clone_dir):\n        \"\"\"Local file reference can be unzipped.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n&gt;       output_dir = zipfile.unzip(\n            'tests/files/fake-repo-tmpl.zip', is_url=False, clone_to_dir=str(clone_dir)\n        )\n\ntests/zipfile/test_unzip.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:50: in unzip\n    password = read_repo_password('Enter the password for the encrypted repository:')\ncookiecutter/prompt.py:69: in read_repo_password\n    return Prompt.ask(question, password=True)\n.venv/lib/python3.10/site-packages/rich/prompt.py:149: in ask\n    return _prompt(default=default, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:292: in __call__\n    value = self.get_input(self.console, prompt, self.password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/prompt.py:211: in get_input\n    return console.input(prompt, password=password, stream=stream)\n.venv/lib/python3.10/site-packages/rich/console.py:2151: in input\n    result = getpass(\"\", stream=stream)\n/usr/lib/python3.10/getpass.py:62: in unix_getpass\n    passwd = fallback_getpass(prompt, stream)\n/usr/lib/python3.10/getpass.py:126: in fallback_getpass\n    return _raw_input(prompt, stream)\n/usr/lib/python3.10/getpass.py:146: in _raw_input\n    line = input.readline()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.capture.DontReadFromInput object at 0x7f8dd4a5bee0&gt;, size = -1\n\n    def read(self, size: int = -1) -&gt; str:\n&gt;       raise OSError(\n            \"pytest: reading from stdin while output is captured!  Consider using `-s`.\"\n        )\nE       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.\n\n.venv/lib/python3.10/site-packages/_pytest/capture.py:209: OSError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_protected_local_file_environment_password","title":"test_unzip.py::test_unzip_protected_local_file_environment_password","text":"<pre>test_unzip.py::test_unzip_protected_local_file_environment_password</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_protected_local_fil0/clone_dir')\n\n    def test_unzip_protected_local_file_environment_password(mocker, clone_dir):\n        \"\"\"In `unzip()`, the environment can be used to provide a repo password.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n&gt;       output_dir = zipfile.unzip(\n            'tests/files/protected-fake-repo-tmpl.zip',\n            is_url=False,\n            clone_to_dir=str(clone_dir),\n            password='sekrit',\n        )\n\ntests/zipfile/test_unzip.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:46: in unzip\n    if zip_ref.namelist() and zip_ref.testzip() is not None:\n/usr/lib/python3.10/zipfile.py:1442: in testzip\n    with self.open(zinfo.filename, \"r\") as f:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , name = 'fake-repo-tmpl/cookiecutter.json'\nmode = 'r', pwd = None\n\n    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n        \"\"\"Return file-like object for 'name'.\n\n        name is a string for the file name within the ZIP file, or a ZipInfo\n        object.\n\n        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n        write to a file newly added to the archive.\n\n        pwd is the password to decrypt files (only used for reading).\n\n        When writing, if the file size is not known in advance but may exceed\n        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n        files.  If the size is known in advance, it is best to pass a ZipInfo\n        instance for name, with zinfo.file_size set.\n        \"\"\"\n        if mode not in {\"r\", \"w\"}:\n            raise ValueError('open() requires mode \"r\" or \"w\"')\n        if pwd and not isinstance(pwd, bytes):\n            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n        if pwd and (mode == \"w\"):\n            raise ValueError(\"pwd is only supported for reading files\")\n        if not self.fp:\n            raise ValueError(\n                \"Attempt to use ZIP archive that was already closed\")\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        elif mode == 'w':\n            zinfo = ZipInfo(name)\n            zinfo.compress_type = self.compression\n            zinfo._compresslevel = self.compresslevel\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        if mode == 'w':\n            return self._open_to_write(zinfo, force_zip64=force_zip64)\n\n        if self._writing:\n            raise ValueError(\"Can't read from the ZIP file while there \"\n                    \"is an open writing handle on it. \"\n                    \"Close the writing handle before trying to read.\")\n\n        # Open for reading:\n        self._fileRefCnt += 1\n        zef_file = _SharedFile(self.fp, zinfo.header_offset,\n                               self._fpclose, self._lock, lambda: self._writing)\n        try:\n            # Skip the file header:\n            fheader = zef_file.read(sizeFileHeader)\n            if len(fheader) != sizeFileHeader:\n                raise BadZipFile(\"Truncated file header\")\n            fheader = struct.unpack(structFileHeader, fheader)\n            if fheader[_FH_SIGNATURE] != stringFileHeader:\n                raise BadZipFile(\"Bad magic number for file header\")\n\n            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n            if zinfo.flag_bits &amp; 0x20:\n                # Zip 2.7: compressed patched data\n                raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n\n            if zinfo.flag_bits &amp; 0x40:\n                # strong encryption\n                raise NotImplementedError(\"strong encryption (flag bit 6)\")\n\n            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] &amp; 0x800:\n                # UTF-8 filename\n                fname_str = fname.decode(\"utf-8\")\n            else:\n                fname_str = fname.decode(\"cp437\")\n\n            if fname_str != zinfo.orig_filename:\n                raise BadZipFile(\n                    'File name in directory %r and header %r differ.'\n                    % (zinfo.orig_filename, fname))\n\n            if (zinfo._end_offset is not None and\n                zef_file.tell() + zinfo.compress_size &gt; zinfo._end_offset):\n                raise BadZipFile(f\"Overlapped entries: {zinfo.orig_filename!r} (possible zip bomb)\")\n\n            # check for encrypted flag &amp; handle password\n            is_encrypted = zinfo.flag_bits &amp; 0x1\n            if is_encrypted:\n                if not pwd:\n                    pwd = self.pwd\n                if not pwd:\n&gt;                   raise RuntimeError(\"File %r is encrypted, password \"\n                                       \"required for extraction\" % name)\nE                                      RuntimeError: File 'fake-repo-tmpl/cookiecutter.json' is encrypted, password required for extraction\n\n/usr/lib/python3.10/zipfile.py:1581: RuntimeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_protected_local_file_bad_environment_password","title":"test_unzip.py::test_unzip_protected_local_file_bad_environment_password","text":"<pre>test_unzip.py::test_unzip_protected_local_file_bad_environment_password</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_protected_local_fil1/clone_dir')\n\n    def test_unzip_protected_local_file_bad_environment_password(mocker, clone_dir):\n        \"\"\"In `unzip()`, an error occurs if the environment has a bad password.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        with pytest.raises(InvalidZipRepository):\n&gt;           zipfile.unzip(\n                'tests/files/protected-fake-repo-tmpl.zip',\n                is_url=False,\n                clone_to_dir=str(clone_dir),\n                password='not-the-right-password',\n            )\n\ntests/zipfile/test_unzip.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:46: in unzip\n    if zip_ref.namelist() and zip_ref.testzip() is not None:\n/usr/lib/python3.10/zipfile.py:1442: in testzip\n    with self.open(zinfo.filename, \"r\") as f:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , name = 'fake-repo-tmpl/cookiecutter.json'\nmode = 'r', pwd = None\n\n    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n        \"\"\"Return file-like object for 'name'.\n\n        name is a string for the file name within the ZIP file, or a ZipInfo\n        object.\n\n        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n        write to a file newly added to the archive.\n\n        pwd is the password to decrypt files (only used for reading).\n\n        When writing, if the file size is not known in advance but may exceed\n        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n        files.  If the size is known in advance, it is best to pass a ZipInfo\n        instance for name, with zinfo.file_size set.\n        \"\"\"\n        if mode not in {\"r\", \"w\"}:\n            raise ValueError('open() requires mode \"r\" or \"w\"')\n        if pwd and not isinstance(pwd, bytes):\n            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n        if pwd and (mode == \"w\"):\n            raise ValueError(\"pwd is only supported for reading files\")\n        if not self.fp:\n            raise ValueError(\n                \"Attempt to use ZIP archive that was already closed\")\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        elif mode == 'w':\n            zinfo = ZipInfo(name)\n            zinfo.compress_type = self.compression\n            zinfo._compresslevel = self.compresslevel\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        if mode == 'w':\n            return self._open_to_write(zinfo, force_zip64=force_zip64)\n\n        if self._writing:\n            raise ValueError(\"Can't read from the ZIP file while there \"\n                    \"is an open writing handle on it. \"\n                    \"Close the writing handle before trying to read.\")\n\n        # Open for reading:\n        self._fileRefCnt += 1\n        zef_file = _SharedFile(self.fp, zinfo.header_offset,\n                               self._fpclose, self._lock, lambda: self._writing)\n        try:\n            # Skip the file header:\n            fheader = zef_file.read(sizeFileHeader)\n            if len(fheader) != sizeFileHeader:\n                raise BadZipFile(\"Truncated file header\")\n            fheader = struct.unpack(structFileHeader, fheader)\n            if fheader[_FH_SIGNATURE] != stringFileHeader:\n                raise BadZipFile(\"Bad magic number for file header\")\n\n            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n            if zinfo.flag_bits &amp; 0x20:\n                # Zip 2.7: compressed patched data\n                raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n\n            if zinfo.flag_bits &amp; 0x40:\n                # strong encryption\n                raise NotImplementedError(\"strong encryption (flag bit 6)\")\n\n            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] &amp; 0x800:\n                # UTF-8 filename\n                fname_str = fname.decode(\"utf-8\")\n            else:\n                fname_str = fname.decode(\"cp437\")\n\n            if fname_str != zinfo.orig_filename:\n                raise BadZipFile(\n                    'File name in directory %r and header %r differ.'\n                    % (zinfo.orig_filename, fname))\n\n            if (zinfo._end_offset is not None and\n                zef_file.tell() + zinfo.compress_size &gt; zinfo._end_offset):\n                raise BadZipFile(f\"Overlapped entries: {zinfo.orig_filename!r} (possible zip bomb)\")\n\n            # check for encrypted flag &amp; handle password\n            is_encrypted = zinfo.flag_bits &amp; 0x1\n            if is_encrypted:\n                if not pwd:\n                    pwd = self.pwd\n                if not pwd:\n&gt;                   raise RuntimeError(\"File %r is encrypted, password \"\n                                       \"required for extraction\" % name)\nE                                      RuntimeError: File 'fake-repo-tmpl/cookiecutter.json' is encrypted, password required for extraction\n\n/usr/lib/python3.10/zipfile.py:1581: RuntimeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_protected_local_file_user_password_with_noinput","title":"test_unzip.py::test_unzip_protected_local_file_user_password_with_noinput","text":"<pre>test_unzip.py::test_unzip_protected_local_file_user_password_with_noinput</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_protected_local_fil2/clone_dir')\n\n    def test_unzip_protected_local_file_user_password_with_noinput(mocker, clone_dir):\n        \"\"\"Can't unpack a password-protected repo in no_input mode.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        with pytest.raises(InvalidZipRepository):\n&gt;           zipfile.unzip(\n                'tests/files/protected-fake-repo-tmpl.zip',\n                is_url=False,\n                clone_to_dir=str(clone_dir),\n                no_input=True,\n            )\n\ntests/zipfile/test_unzip.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:46: in unzip\n    if zip_ref.namelist() and zip_ref.testzip() is not None:\n/usr/lib/python3.10/zipfile.py:1442: in testzip\n    with self.open(zinfo.filename, \"r\") as f:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , name = 'fake-repo-tmpl/cookiecutter.json'\nmode = 'r', pwd = None\n\n    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n        \"\"\"Return file-like object for 'name'.\n\n        name is a string for the file name within the ZIP file, or a ZipInfo\n        object.\n\n        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n        write to a file newly added to the archive.\n\n        pwd is the password to decrypt files (only used for reading).\n\n        When writing, if the file size is not known in advance but may exceed\n        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n        files.  If the size is known in advance, it is best to pass a ZipInfo\n        instance for name, with zinfo.file_size set.\n        \"\"\"\n        if mode not in {\"r\", \"w\"}:\n            raise ValueError('open() requires mode \"r\" or \"w\"')\n        if pwd and not isinstance(pwd, bytes):\n            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n        if pwd and (mode == \"w\"):\n            raise ValueError(\"pwd is only supported for reading files\")\n        if not self.fp:\n            raise ValueError(\n                \"Attempt to use ZIP archive that was already closed\")\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        elif mode == 'w':\n            zinfo = ZipInfo(name)\n            zinfo.compress_type = self.compression\n            zinfo._compresslevel = self.compresslevel\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        if mode == 'w':\n            return self._open_to_write(zinfo, force_zip64=force_zip64)\n\n        if self._writing:\n            raise ValueError(\"Can't read from the ZIP file while there \"\n                    \"is an open writing handle on it. \"\n                    \"Close the writing handle before trying to read.\")\n\n        # Open for reading:\n        self._fileRefCnt += 1\n        zef_file = _SharedFile(self.fp, zinfo.header_offset,\n                               self._fpclose, self._lock, lambda: self._writing)\n        try:\n            # Skip the file header:\n            fheader = zef_file.read(sizeFileHeader)\n            if len(fheader) != sizeFileHeader:\n                raise BadZipFile(\"Truncated file header\")\n            fheader = struct.unpack(structFileHeader, fheader)\n            if fheader[_FH_SIGNATURE] != stringFileHeader:\n                raise BadZipFile(\"Bad magic number for file header\")\n\n            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n            if zinfo.flag_bits &amp; 0x20:\n                # Zip 2.7: compressed patched data\n                raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n\n            if zinfo.flag_bits &amp; 0x40:\n                # strong encryption\n                raise NotImplementedError(\"strong encryption (flag bit 6)\")\n\n            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] &amp; 0x800:\n                # UTF-8 filename\n                fname_str = fname.decode(\"utf-8\")\n            else:\n                fname_str = fname.decode(\"cp437\")\n\n            if fname_str != zinfo.orig_filename:\n                raise BadZipFile(\n                    'File name in directory %r and header %r differ.'\n                    % (zinfo.orig_filename, fname))\n\n            if (zinfo._end_offset is not None and\n                zef_file.tell() + zinfo.compress_size &gt; zinfo._end_offset):\n                raise BadZipFile(f\"Overlapped entries: {zinfo.orig_filename!r} (possible zip bomb)\")\n\n            # check for encrypted flag &amp; handle password\n            is_encrypted = zinfo.flag_bits &amp; 0x1\n            if is_encrypted:\n                if not pwd:\n                    pwd = self.pwd\n                if not pwd:\n&gt;                   raise RuntimeError(\"File %r is encrypted, password \"\n                                       \"required for extraction\" % name)\nE                                      RuntimeError: File 'fake-repo-tmpl/cookiecutter.json' is encrypted, password required for extraction\n\n/usr/lib/python3.10/zipfile.py:1581: RuntimeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_protected_local_file_user_password","title":"test_unzip.py::test_unzip_protected_local_file_user_password","text":"<pre>test_unzip.py::test_unzip_protected_local_file_user_password</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_protected_local_fil3/clone_dir')\n\n    def test_unzip_protected_local_file_user_password(mocker, clone_dir):\n        \"\"\"A password-protected local file reference can be unzipped.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n        mocker.patch('cookiecutter.zipfile.read_repo_password', return_value='sekrit')\n\n&gt;       output_dir = zipfile.unzip(\n            'tests/files/protected-fake-repo-tmpl.zip',\n            is_url=False,\n            clone_to_dir=str(clone_dir),\n        )\n\ntests/zipfile/test_unzip.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:46: in unzip\n    if zip_ref.namelist() and zip_ref.testzip() is not None:\n/usr/lib/python3.10/zipfile.py:1442: in testzip\n    with self.open(zinfo.filename, \"r\") as f:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , name = 'fake-repo-tmpl/cookiecutter.json'\nmode = 'r', pwd = None\n\n    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n        \"\"\"Return file-like object for 'name'.\n\n        name is a string for the file name within the ZIP file, or a ZipInfo\n        object.\n\n        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n        write to a file newly added to the archive.\n\n        pwd is the password to decrypt files (only used for reading).\n\n        When writing, if the file size is not known in advance but may exceed\n        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n        files.  If the size is known in advance, it is best to pass a ZipInfo\n        instance for name, with zinfo.file_size set.\n        \"\"\"\n        if mode not in {\"r\", \"w\"}:\n            raise ValueError('open() requires mode \"r\" or \"w\"')\n        if pwd and not isinstance(pwd, bytes):\n            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n        if pwd and (mode == \"w\"):\n            raise ValueError(\"pwd is only supported for reading files\")\n        if not self.fp:\n            raise ValueError(\n                \"Attempt to use ZIP archive that was already closed\")\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        elif mode == 'w':\n            zinfo = ZipInfo(name)\n            zinfo.compress_type = self.compression\n            zinfo._compresslevel = self.compresslevel\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        if mode == 'w':\n            return self._open_to_write(zinfo, force_zip64=force_zip64)\n\n        if self._writing:\n            raise ValueError(\"Can't read from the ZIP file while there \"\n                    \"is an open writing handle on it. \"\n                    \"Close the writing handle before trying to read.\")\n\n        # Open for reading:\n        self._fileRefCnt += 1\n        zef_file = _SharedFile(self.fp, zinfo.header_offset,\n                               self._fpclose, self._lock, lambda: self._writing)\n        try:\n            # Skip the file header:\n            fheader = zef_file.read(sizeFileHeader)\n            if len(fheader) != sizeFileHeader:\n                raise BadZipFile(\"Truncated file header\")\n            fheader = struct.unpack(structFileHeader, fheader)\n            if fheader[_FH_SIGNATURE] != stringFileHeader:\n                raise BadZipFile(\"Bad magic number for file header\")\n\n            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n            if zinfo.flag_bits &amp; 0x20:\n                # Zip 2.7: compressed patched data\n                raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n\n            if zinfo.flag_bits &amp; 0x40:\n                # strong encryption\n                raise NotImplementedError(\"strong encryption (flag bit 6)\")\n\n            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] &amp; 0x800:\n                # UTF-8 filename\n                fname_str = fname.decode(\"utf-8\")\n            else:\n                fname_str = fname.decode(\"cp437\")\n\n            if fname_str != zinfo.orig_filename:\n                raise BadZipFile(\n                    'File name in directory %r and header %r differ.'\n                    % (zinfo.orig_filename, fname))\n\n            if (zinfo._end_offset is not None and\n                zef_file.tell() + zinfo.compress_size &gt; zinfo._end_offset):\n                raise BadZipFile(f\"Overlapped entries: {zinfo.orig_filename!r} (possible zip bomb)\")\n\n            # check for encrypted flag &amp; handle password\n            is_encrypted = zinfo.flag_bits &amp; 0x1\n            if is_encrypted:\n                if not pwd:\n                    pwd = self.pwd\n                if not pwd:\n&gt;                   raise RuntimeError(\"File %r is encrypted, password \"\n                                       \"required for extraction\" % name)\nE                                      RuntimeError: File 'fake-repo-tmpl/cookiecutter.json' is encrypted, password required for extraction\n\n/usr/lib/python3.10/zipfile.py:1581: RuntimeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_protected_local_file_user_bad_password","title":"test_unzip.py::test_unzip_protected_local_file_user_bad_password","text":"<pre>test_unzip.py::test_unzip_protected_local_file_user_bad_password</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_protected_local_fil4/clone_dir')\n\n    def test_unzip_protected_local_file_user_bad_password(mocker, clone_dir):\n        \"\"\"Error in `unzip()`, if user can't provide a valid password.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n        mocker.patch(\n            'cookiecutter.zipfile.read_repo_password', return_value='not-the-right-password'\n        )\n\n        with pytest.raises(InvalidZipRepository):\n&gt;           zipfile.unzip(\n                'tests/files/protected-fake-repo-tmpl.zip',\n                is_url=False,\n                clone_to_dir=str(clone_dir),\n            )\n\ntests/zipfile/test_unzip.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:46: in unzip\n    if zip_ref.namelist() and zip_ref.testzip() is not None:\n/usr/lib/python3.10/zipfile.py:1442: in testzip\n    with self.open(zinfo.filename, \"r\") as f:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , name = 'fake-repo-tmpl/cookiecutter.json'\nmode = 'r', pwd = None\n\n    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n        \"\"\"Return file-like object for 'name'.\n\n        name is a string for the file name within the ZIP file, or a ZipInfo\n        object.\n\n        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n        write to a file newly added to the archive.\n\n        pwd is the password to decrypt files (only used for reading).\n\n        When writing, if the file size is not known in advance but may exceed\n        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n        files.  If the size is known in advance, it is best to pass a ZipInfo\n        instance for name, with zinfo.file_size set.\n        \"\"\"\n        if mode not in {\"r\", \"w\"}:\n            raise ValueError('open() requires mode \"r\" or \"w\"')\n        if pwd and not isinstance(pwd, bytes):\n            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n        if pwd and (mode == \"w\"):\n            raise ValueError(\"pwd is only supported for reading files\")\n        if not self.fp:\n            raise ValueError(\n                \"Attempt to use ZIP archive that was already closed\")\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        elif mode == 'w':\n            zinfo = ZipInfo(name)\n            zinfo.compress_type = self.compression\n            zinfo._compresslevel = self.compresslevel\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        if mode == 'w':\n            return self._open_to_write(zinfo, force_zip64=force_zip64)\n\n        if self._writing:\n            raise ValueError(\"Can't read from the ZIP file while there \"\n                    \"is an open writing handle on it. \"\n                    \"Close the writing handle before trying to read.\")\n\n        # Open for reading:\n        self._fileRefCnt += 1\n        zef_file = _SharedFile(self.fp, zinfo.header_offset,\n                               self._fpclose, self._lock, lambda: self._writing)\n        try:\n            # Skip the file header:\n            fheader = zef_file.read(sizeFileHeader)\n            if len(fheader) != sizeFileHeader:\n                raise BadZipFile(\"Truncated file header\")\n            fheader = struct.unpack(structFileHeader, fheader)\n            if fheader[_FH_SIGNATURE] != stringFileHeader:\n                raise BadZipFile(\"Bad magic number for file header\")\n\n            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n            if zinfo.flag_bits &amp; 0x20:\n                # Zip 2.7: compressed patched data\n                raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n\n            if zinfo.flag_bits &amp; 0x40:\n                # strong encryption\n                raise NotImplementedError(\"strong encryption (flag bit 6)\")\n\n            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] &amp; 0x800:\n                # UTF-8 filename\n                fname_str = fname.decode(\"utf-8\")\n            else:\n                fname_str = fname.decode(\"cp437\")\n\n            if fname_str != zinfo.orig_filename:\n                raise BadZipFile(\n                    'File name in directory %r and header %r differ.'\n                    % (zinfo.orig_filename, fname))\n\n            if (zinfo._end_offset is not None and\n                zef_file.tell() + zinfo.compress_size &gt; zinfo._end_offset):\n                raise BadZipFile(f\"Overlapped entries: {zinfo.orig_filename!r} (possible zip bomb)\")\n\n            # check for encrypted flag &amp; handle password\n            is_encrypted = zinfo.flag_bits &amp; 0x1\n            if is_encrypted:\n                if not pwd:\n                    pwd = self.pwd\n                if not pwd:\n&gt;                   raise RuntimeError(\"File %r is encrypted, password \"\n                                       \"required for extraction\" % name)\nE                                      RuntimeError: File 'fake-repo-tmpl/cookiecutter.json' is encrypted, password required for extraction\n\n/usr/lib/python3.10/zipfile.py:1581: RuntimeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_empty_zip_file","title":"test_unzip.py::test_empty_zip_file","text":"<pre>test_unzip.py::test_empty_zip_file</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_empty_zip_file0/clone_dir')\n\n    def test_empty_zip_file(mocker, clone_dir):\n        \"\"\"In `unzip()`, an empty file raises an error.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        with pytest.raises(InvalidZipRepository):\n&gt;           zipfile.unzip(\n                'tests/files/empty.zip', is_url=False, clone_to_dir=str(clone_dir)\n            )\n\ntests/zipfile/test_unzip.py:134: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nzip_uri = 'tests/files/empty.zip', is_url = False\nclone_to_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_empty_zip_file0/clone_dir')\nno_input = False, password = None\n\n    def unzip(zip_uri: str, is_url: bool, clone_to_dir: 'os.PathLike[str]'='.',\n        no_input: bool=False, password: Optional[str]=None):\n        \"\"\"Download and unpack a zipfile at a given URI.\n\n        This will download the zipfile to the cookiecutter repository,\n        and unpack into a temporary directory.\n\n        :param zip_uri: The URI for the zipfile.\n        :param is_url: Is the zip URI a URL or a file?\n        :param clone_to_dir: The cookiecutter repository directory\n            to put the archive into.\n        :param no_input: Do not prompt for user input and eventually force a refresh of\n            cached resources.\n        :param password: The password to use when unpacking the repository.\n        \"\"\"\n        clone_to_dir = Path(clone_to_dir)\n        make_sure_path_exists(clone_to_dir)\n\n        if is_url:\n            # Download the file\n            response = requests.get(zip_uri)\n            response.raise_for_status()\n            zip_file = tempfile.NamedTemporaryFile(delete=False, suffix='.zip', dir=clone_to_dir)\n            zip_file.write(response.content)\n            zip_file.close()\n            zip_path = Path(zip_file.name)\n        else:\n            zip_path = Path(zip_uri)\n\n        # Create a temporary directory to extract the contents\n        with tempfile.TemporaryDirectory(dir=clone_to_dir) as temp_dir:\n            try:\n                with ZipFile(zip_path, 'r') as zip_ref:\n                    if zip_ref.namelist() and zip_ref.testzip() is not None:\n                        raise InvalidZipRepository(f\"The zip file {zip_uri} is invalid or corrupt.\")\n\n&gt;                   if password is None and zip_ref.namelist()[0].endswith('/'):\nE                   IndexError: list index out of range\n\ncookiecutter/zipfile.py:49: IndexError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_non_repo_zip_file","title":"test_unzip.py::test_non_repo_zip_file","text":"<pre>test_unzip.py::test_non_repo_zip_file</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_non_repo_zip_file0/clone_dir')\n\n    def test_non_repo_zip_file(mocker, clone_dir):\n        \"\"\"In `unzip()`, a repository must have a top level directory.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n&gt;       with pytest.raises(InvalidZipRepository):\nE       Failed: DID NOT RAISE \n\ntests/zipfile/test_unzip.py:145: Failed"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_url","title":"test_unzip.py::test_unzip_url","text":"<pre>test_unzip.py::test_unzip_url</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_url0/clone_dir')\n\n    def test_unzip_url(mocker, clone_dir):\n        \"\"\"In `unzip()`, a url will be downloaded and unzipped.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        request = mocker.MagicMock()\n        request.iter_content.return_value = mock_download()\n\n        mocker.patch(\n            'cookiecutter.zipfile.requests.get',\n            return_value=request,\n            autospec=True,\n        )\n\n&gt;       output_dir = zipfile.unzip(\n            'https://example.com/path/to/fake-repo-tmpl.zip',\n            is_url=True,\n            clone_to_dir=str(clone_dir),\n        )\n\ntests/zipfile/test_unzip.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:36: in unzip\n    zip_file.write(response.content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (,), kwargs = {}\n\n    @_functools.wraps(func)\n    def func_wrapper(*args, **kwargs):\n&gt;       return func(*args, **kwargs)\nE       TypeError: a bytes-like object is required, not 'MagicMock'\n\n/usr/lib/python3.10/tempfile.py:638: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_url_with_empty_chunks","title":"test_unzip.py::test_unzip_url_with_empty_chunks","text":"<pre>test_unzip.py::test_unzip_url_with_empty_chunks</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_url_with_empty_chun0/clone_dir')\n\n    def test_unzip_url_with_empty_chunks(mocker, clone_dir):\n        \"\"\"In `unzip()` empty chunk must be ignored.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        request = mocker.MagicMock()\n        request.iter_content.return_value = mock_download_with_empty_chunks()\n\n        mocker.patch(\n            'cookiecutter.zipfile.requests.get',\n            return_value=request,\n            autospec=True,\n        )\n\n&gt;       output_dir = zipfile.unzip(\n            'https://example.com/path/to/fake-repo-tmpl.zip',\n            is_url=True,\n            clone_to_dir=str(clone_dir),\n        )\n\ntests/zipfile/test_unzip.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:36: in unzip\n    zip_file.write(response.content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (,), kwargs = {}\n\n    @_functools.wraps(func)\n    def func_wrapper(*args, **kwargs):\n&gt;       return func(*args, **kwargs)\nE       TypeError: a bytes-like object is required, not 'MagicMock'\n\n/usr/lib/python3.10/tempfile.py:638: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_url_existing_cache","title":"test_unzip.py::test_unzip_url_existing_cache","text":"<pre>test_unzip.py::test_unzip_url_existing_cache</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_url_existing_cache0/clone_dir')\n\n    def test_unzip_url_existing_cache(mocker, clone_dir):\n        \"\"\"Url should be downloaded and unzipped, old zip file will be removed.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=True, autospec=True\n        )\n\n        request = mocker.MagicMock()\n        request.iter_content.return_value = mock_download()\n\n        mocker.patch(\n            'cookiecutter.zipfile.requests.get',\n            return_value=request,\n            autospec=True,\n        )\n\n        # Create an existing cache of the zipfile\n        existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')\n        existing_zip.write_text('This is an existing zipfile')\n\n&gt;       output_dir = zipfile.unzip(\n            'https://example.com/path/to/fake-repo-tmpl.zip',\n            is_url=True,\n            clone_to_dir=str(clone_dir),\n        )\n\ntests/zipfile/test_unzip.py:232: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:36: in unzip\n    zip_file.write(response.content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (,), kwargs = {}\n\n    @_functools.wraps(func)\n    def func_wrapper(*args, **kwargs):\n&gt;       return func(*args, **kwargs)\nE       TypeError: a bytes-like object is required, not 'MagicMock'\n\n/usr/lib/python3.10/tempfile.py:638: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_url_existing_cache_no_input","title":"test_unzip.py::test_unzip_url_existing_cache_no_input","text":"<pre>test_unzip.py::test_unzip_url_existing_cache_no_input</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_url_existing_cache_0/clone_dir')\n\n    def test_unzip_url_existing_cache_no_input(mocker, clone_dir):\n        \"\"\"If no_input is provided, the existing file should be removed.\"\"\"\n        request = mocker.MagicMock()\n        request.iter_content.return_value = mock_download()\n\n        mocker.patch(\n            'cookiecutter.zipfile.requests.get',\n            return_value=request,\n            autospec=True,\n        )\n\n        # Create an existing cache of the zipfile\n        existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')\n        existing_zip.write_text('This is an existing zipfile')\n\n&gt;       output_dir = zipfile.unzip(\n            'https://example.com/path/to/fake-repo-tmpl.zip',\n            is_url=True,\n            clone_to_dir=str(clone_dir),\n            no_input=True,\n        )\n\ntests/zipfile/test_unzip.py:257: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:36: in unzip\n    zip_file.write(response.content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (,), kwargs = {}\n\n    @_functools.wraps(func)\n    def func_wrapper(*args, **kwargs):\n&gt;       return func(*args, **kwargs)\nE       TypeError: a bytes-like object is required, not 'MagicMock'\n\n/usr/lib/python3.10/tempfile.py:638: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_should_abort_if_no_redownload","title":"test_unzip.py::test_unzip_should_abort_if_no_redownload","text":"<pre>test_unzip.py::test_unzip_should_abort_if_no_redownload</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_should_abort_if_no_0/clone_dir')\n\n    def test_unzip_should_abort_if_no_redownload(mocker, clone_dir):\n        \"\"\"Should exit without cloning anything If no redownload.\"\"\"\n        mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', side_effect=SystemExit, autospec=True\n        )\n\n        mock_requests_get = mocker.patch(\n            'cookiecutter.zipfile.requests.get',\n            autospec=True,\n        )\n\n        # Create an existing cache of the zipfile\n        existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')\n        existing_zip.write_text('This is an existing zipfile')\n\n        zipfile_url = 'https://example.com/path/to/fake-repo-tmpl.zip'\n\n        with pytest.raises(SystemExit):\n&gt;           zipfile.unzip(zipfile_url, is_url=True, clone_to_dir=str(clone_dir))\n\ntests/zipfile/test_unzip.py:285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:36: in unzip\n    zip_file.write(response.content)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (,), kwargs = {}\n\n    @_functools.wraps(func)\n    def func_wrapper(*args, **kwargs):\n&gt;       return func(*args, **kwargs)\nE       TypeError: a bytes-like object is required, not 'MagicMock'\n\n/usr/lib/python3.10/tempfile.py:638: TypeError"},{"location":"analysis_baseline_cookiecutter/#test_unzippytest_unzip_is_ok_to_reuse","title":"test_unzip.py::test_unzip_is_ok_to_reuse","text":"<pre>test_unzip.py::test_unzip_is_ok_to_reuse</pre><pre>\nmocker = \nclone_dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_unzip_is_ok_to_reuse0/clone_dir')\n\n    def test_unzip_is_ok_to_reuse(mocker, clone_dir):\n        \"\"\"Already downloaded zip should not be downloaded again.\"\"\"\n        mock_prompt_and_delete = mocker.patch(\n            'cookiecutter.zipfile.prompt_and_delete', return_value=False, autospec=True\n        )\n\n        request = mocker.MagicMock()\n\n        existing_zip = clone_dir.joinpath('fake-repo-tmpl.zip')\n        shutil.copy('tests/files/fake-repo-tmpl.zip', existing_zip)\n\n&gt;       output_dir = zipfile.unzip(\n            'https://example.com/path/to/fake-repo-tmpl.zip',\n            is_url=True,\n            clone_to_dir=str(clone_dir),\n        )\n\ntests/zipfile/test_unzip.py:301: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncookiecutter/zipfile.py:34: in unzip\n    response.raise_for_status()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def raise_for_status(self):\n        \"\"\"Raises :class:`HTTPError`, if one occurred.\"\"\"\n\n        http_error_msg = \"\"\n        if isinstance(self.reason, bytes):\n            # We attempt to decode utf-8 first because some servers\n            # choose to localize their reason strings. If the string\n            # isn't utf-8, we fall back to iso-8859-1 for all other\n            # encodings. (See PR #3538)\n            try:\n                reason = self.reason.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                reason = self.reason.decode(\"iso-8859-1\")\n        else:\n            reason = self.reason\n\n        if 400 &lt;= self.status_code &lt; 500:\n            http_error_msg = (\n                f\"{self.status_code} Client Error: {reason} for url: {self.url}\"\n            )\n\n        elif 500 &lt;= self.status_code &lt; 600:\n            http_error_msg = (\n                f\"{self.status_code} Server Error: {reason} for url: {self.url}\"\n            )\n\n        if http_error_msg:\n&gt;           raise HTTPError(http_error_msg, response=self)\nE           requests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: https://example.com/path/to/fake-repo-tmpl.zip\n\n.venv/lib/python3.10/site-packages/requests/models.py:1024: HTTPError"},{"location":"analysis_baseline_cookiecutter/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/cookiecutter/cli.py b/cookiecutter/cli.py\nindex b050655..3b261fe 100644\n--- a/cookiecutter/cli.py\n+++ b/cookiecutter/cli.py\n@@ -13,17 +13,41 @@ from cookiecutter.main import cookiecutter\n\n def version_msg():\n     \"\"\"Return the Cookiecutter version, location and Python powering it.\"\"\"\n-    pass\n+    python_version = sys.version[:3]\n+    location = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n+    return f\"Cookiecutter {__version__} from {location} (Python {python_version})\"\n\n\n def validate_extra_context(ctx, param, value):\n     \"\"\"Validate extra context.\"\"\"\n-    pass\n+    for s in value:\n+        if '=' not in s:\n+            raise click.BadParameter(\n+                f'\"{s}\" is not a valid key/value pair. '\n+                'Use the format key=value.'\n+            )\n+    return collections.OrderedDict(v.split('=', 1) for v in value)\n\n\n def list_installed_templates(default_config, passed_config_file):\n     \"\"\"List installed (locally cloned) templates. Use cookiecutter --list-installed.\"\"\"\n-    pass\n+    config = get_user_config(default_config=default_config, config_file=passed_config_file)\n+    template_dir = config.get('cookiecutters_dir')\n+    if not os.path.exists(template_dir):\n+        click.echo(f\"No templates found in {template_dir}\")\n+        return\n+\n+    template_names = [\n+        d for d in os.listdir(template_dir)\n+        if os.path.isdir(os.path.join(template_dir, d))\n+    ]\n+\n+    if not template_names:\n+        click.echo(f\"No templates found in {template_dir}\")\n+    else:\n+        click.echo(\"Installed templates:\")\n+        for template_name in template_names:\n+            click.echo(f\"  {template_name}\")\n\n\n @click.command(context_settings=dict(help_option_names=['-h', '--help']))\n@@ -74,7 +98,37 @@ def main(template, extra_context, no_input, checkout, verbose, replay,\n     volunteers. If you would like to help out or fund the project, please get\n     in touch at https://github.com/cookiecutter/cookiecutter.\n     \"\"\"\n-    pass\n+    if list_installed:\n+        list_installed_templates(default_config, config_file)\n+        return\n+\n+    configure_logger(stream_level='DEBUG' if verbose else 'INFO',\n+                     debug_file=debug_file)\n+\n+    try:\n+        cookiecutter(\n+            template,\n+            checkout=checkout,\n+            no_input=no_input,\n+            extra_context=extra_context,\n+            replay=replay,\n+            overwrite_if_exists=overwrite_if_exists,\n+            output_dir=output_dir,\n+            config_file=config_file,\n+            default_config=default_config,\n+            password=None,\n+            directory=directory,\n+            skip_if_file_exists=skip_if_file_exists,\n+            accept_hooks=accept_hooks,\n+            keep_project_on_failure=keep_project_on_failure,\n+        )\n+    except (ContextDecodingException, OutputDirExistsException,\n+            InvalidModeException, FailedHookException,\n+            UnknownExtension, InvalidZipRepository,\n+            RepositoryNotFound, RepositoryCloneFailed,\n+            UndefinedVariableInTemplate) as e:\n+        click.echo(f\"Error: {e}\")\n+        sys.exit(1)\n\n\n if __name__ == '__main__':\ndiff --git a/cookiecutter/config.py b/cookiecutter/config.py\nindex 6356215..2b0e70d 100644\n--- a/cookiecutter/config.py\n+++ b/cookiecutter/config.py\n@@ -17,7 +17,7 @@ DEFAULT_CONFIG = {'cookiecutters_dir': os.path.expanduser(\n\n def _expand_path(path):\n     \"\"\"Expand both environment variables and user home in the given path.\"\"\"\n-    pass\n+    return os.path.expandvars(os.path.expanduser(path))\n\n\n def merge_configs(default, overwrite):\n@@ -26,12 +26,30 @@ def merge_configs(default, overwrite):\n     Dict values that are dictionaries themselves will be updated, whilst\n     preserving existing keys.\n     \"\"\"\n-    pass\n+    new_config = copy.deepcopy(default)\n+    for k, v in overwrite.items():\n+        if isinstance(v, dict):\n+            new_config[k] = merge_configs(new_config.get(k, {}), v)\n+        else:\n+            new_config[k] = v\n+    return new_config\n\n\n def get_config(config_path):\n     \"\"\"Retrieve the config from the specified path, returning a config dict.\"\"\"\n-    pass\n+    if not os.path.exists(config_path):\n+        raise ConfigDoesNotExistException(f\"Config file {config_path} does not exist.\")\n+\n+    with open(config_path) as file_handle:\n+        try:\n+            user_config = yaml.safe_load(file_handle)\n+        except yaml.YAMLError as e:\n+            raise InvalidConfiguration(f\"Unable to parse YAML file {config_path}: {e}\")\n+\n+    if user_config is None:\n+        raise InvalidConfiguration(f\"Config file {config_path} is empty.\")\n+\n+    return user_config\n\n\n def get_user_config(config_file=None, default_config=False):\n@@ -53,4 +71,20 @@ def get_user_config(config_file=None, default_config=False):\n     If the environment variable is not set, try the default config file path\n     before falling back to the default config values.\n     \"\"\"\n-    pass\n+    if isinstance(default_config, dict):\n+        return merge_configs(DEFAULT_CONFIG, default_config)\n+\n+    if default_config:\n+        return copy.deepcopy(DEFAULT_CONFIG)\n+\n+    if config_file and config_file != USER_CONFIG_PATH:\n+        return get_config(config_file)\n+\n+    user_config = os.environ.get('COOKIECUTTER_CONFIG')\n+    if user_config:\n+        return get_config(user_config)\n+\n+    if os.path.exists(USER_CONFIG_PATH):\n+        return get_config(USER_CONFIG_PATH)\n+\n+    return copy.deepcopy(DEFAULT_CONFIG)\ndiff --git a/cookiecutter/environment.py b/cookiecutter/environment.py\nindex 8a7bb61..b2495b8 100644\n--- a/cookiecutter/environment.py\n+++ b/cookiecutter/environment.py\n@@ -37,7 +37,8 @@ class ExtensionLoaderMixin:\n         If context does not contain the relevant info, return an empty\n         list instead.\n         \"\"\"\n-        pass\n+        extensions = context.get('cookiecutter', {}).get('_extensions', [])\n+        return [str(ext) for ext in extensions]\n\n\n class StrictEnvironment(ExtensionLoaderMixin, Environment):\ndiff --git a/cookiecutter/extensions.py b/cookiecutter/extensions.py\nindex 8ce014a..865d856 100644\n--- a/cookiecutter/extensions.py\n+++ b/cookiecutter/extensions.py\n@@ -5,6 +5,7 @@ import uuid\n from secrets import choice\n import arrow\n from jinja2 import nodes\n+from jinja2 import nodes\n from jinja2.ext import Extension\n from slugify import slugify as pyslugify\n\n@@ -74,4 +75,20 @@ class TimeExtension(Extension):\n\n     def parse(self, parser):\n         \"\"\"Parse datetime template and add datetime value.\"\"\"\n-        pass\n+        lineno = next(parser.stream).lineno\n+        token = parser.stream.next()\n+        format_string = self.environment.datetime_format\n+        if token.type == 'string':\n+            format_string = token.value\n+        \n+        node = nodes.Call(\n+            self.call_method('_render_now', [nodes.Const(format_string)]),\n+            [],\n+            [],\n+            None,\n+            None\n+        )\n+        return nodes.Output([node]).set_lineno(lineno)\n+\n+    def _render_now(self, format_string):\n+        return arrow.now().format(format_string)\ndiff --git a/cookiecutter/find.py b/cookiecutter/find.py\nindex 667e50d..06ba42a 100644\n--- a/cookiecutter/find.py\n+++ b/cookiecutter/find.py\n@@ -11,6 +11,33 @@ def find_template(repo_dir: 'os.PathLike[str]', env: Environment) -&gt;Path:\n     \"\"\"Determine which child directory of ``repo_dir`` is the project template.\n\n     :param repo_dir: Local directory of newly cloned repo.\n+    :param env: Jinja2 Environment object for rendering template variables.\n     :return: Relative path to project template.\n     \"\"\"\n-    pass\n+    repo_dir = Path(repo_dir)\n+    logger.debug('Searching %s for the project template.', repo_dir)\n+\n+    # First, check for a cookiecutter.json file in the repo root\n+    if (repo_dir / 'cookiecutter.json').is_file():\n+        logger.debug('Found cookiecutter.json at project root level')\n+        return repo_dir\n+\n+    # If not found, search for the first directory with a cookiecutter.json file\n+    for dirpath, dirnames, filenames in os.walk(repo_dir):\n+        if 'cookiecutter.json' in filenames:\n+            logger.debug('Found cookiecutter.json in %s', dirpath)\n+            return Path(dirpath).relative_to(repo_dir)\n+\n+    # If no cookiecutter.json is found, look for the first directory that's not a repo artifact\n+    for path in repo_dir.iterdir():\n+        if path.is_dir() and path.name not in {'.git', '.hg', '.svn', '.bzr'}:\n+            logger.debug('Treating %s as project template', path)\n+            return path.relative_to(repo_dir)\n+\n+    # If we reach here, we couldn't find a valid template directory\n+    raise NonTemplatedInputDirException(\n+        'The repo_dir {} is not a valid template directory. '\n+        'A valid template directory must either have a cookiecutter.json '\n+        'file or have one or more directories that are not repo artifacts.'\n+        .format(repo_dir)\n+    )\ndiff --git a/cookiecutter/generate.py b/cookiecutter/generate.py\nindex 715232e..61a6452 100644\n--- a/cookiecutter/generate.py\n+++ b/cookiecutter/generate.py\n@@ -27,13 +27,30 @@ def is_copy_only_path(path, context):\n         should be rendered or just copied.\n     :param context: cookiecutter context.\n     \"\"\"\n-    pass\n+    copy_without_render = context.get('_copy_without_render', [])\n+    for pattern in copy_without_render:\n+        if fnmatch.fnmatch(path, pattern):\n+            return True\n+    return False\n\n\n def apply_overwrites_to_context(context, overwrite_context, *,\n     in_dictionary_variable=False):\n     \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n-    pass\n+    for key, value in overwrite_context.items():\n+        if isinstance(value, dict):\n+            if key not in context:\n+                context[key] = {}\n+            apply_overwrites_to_context(context[key], value, in_dictionary_variable=True)\n+        elif isinstance(value, list):\n+            if key not in context:\n+                context[key] = []\n+            context[key].extend(value)\n+        else:\n+            if in_dictionary_variable:\n+                context[key] = value\n+            else:\n+                context[key] = str(value)\n\n\n def generate_context(context_file='cookiecutter.json', default_context=None,\n@@ -47,7 +64,23 @@ def generate_context(context_file='cookiecutter.json', default_context=None,\n     :param default_context: Dictionary containing config to take into account.\n     :param extra_context: Dictionary containing configuration overrides\n     \"\"\"\n-    pass\n+    context = OrderedDict([])\n+    try:\n+        with open(context_file) as file:\n+            obj = json.load(file, object_pairs_hook=OrderedDict)\n+        context = obj if isinstance(obj, dict) else obj[0]\n+    except ValueError as e:\n+        raise ContextDecodingException(context_file, e)\n+    \n+    # Apply default context\n+    if default_context:\n+        apply_overwrites_to_context(context, default_context)\n+    \n+    # Apply extra context\n+    if extra_context:\n+        apply_overwrites_to_context(context, extra_context)\n+    \n+    return context\n\n\n def generate_file(project_dir, infile, context, env, skip_if_file_exists=False\n@@ -72,14 +105,65 @@ def generate_file(project_dir, infile, context, env, skip_if_file_exists=False\n     :param context: Dict for populating the cookiecutter's variables.\n     :param env: Jinja2 template execution environment.\n     \"\"\"\n-    pass\n+    logger.debug('Generating file %s', infile)\n+    \n+    # Render the path to the output file\n+    outfile_tmpl = env.from_string(infile)\n+    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n+    \n+    # Ensure output directory exists\n+    dirname = os.path.dirname(outfile)\n+    make_sure_path_exists(dirname)\n+    \n+    # Skip if file exists and skip_if_file_exists is True\n+    if skip_if_file_exists and os.path.exists(outfile):\n+        logger.debug('File %s already exists, skipping', outfile)\n+        return False\n+    \n+    # Check if infile is binary\n+    if is_binary(infile):\n+        logger.debug(\"Copying binary %s to %s without rendering\", infile, outfile)\n+        shutil.copyfile(infile, outfile)\n+    else:\n+        # Render the file\n+        try:\n+            with open(infile, 'r') as in_file:\n+                tmpl = env.from_string(in_file.read())\n+            rendered_file = tmpl.render(**context)\n+            with open(outfile, 'w') as out_file:\n+                out_file.write(rendered_file)\n+        except TemplateSyntaxError as e:\n+            logger.error('Error in template syntax in %s', infile)\n+            raise\n+        except UndefinedError as e:\n+            logger.error('Unable to render template in %s', infile)\n+            raise UndefinedVariableInTemplate(str(e), infile, context, e.message)\n+    \n+    return True\n\n\n def render_and_create_dir(dirname: str, context: dict, output_dir:\n     'os.PathLike[str]', environment: Environment, overwrite_if_exists: bool\n     =False):\n     \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n-    pass\n+    name_tmpl = environment.from_string(dirname)\n+    rendered_dirname = name_tmpl.render(**context)\n+    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n+\n+    logger.debug('Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir)\n+\n+    if os.path.exists(dir_to_create):\n+        if overwrite_if_exists:\n+            logger.debug('Overwriting %s', dir_to_create)\n+        else:\n+            logger.error('Error that %s already exists', dir_to_create)\n+            raise OutputDirExistsException(\n+                'Error: \"{}\" directory already exists'.format(dir_to_create)\n+            )\n+    else:\n+        make_sure_path_exists(dir_to_create)\n+\n+    return dir_to_create\n\n\n def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n@@ -93,7 +177,33 @@ def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n     :param delete_project_on_failure: Delete the project directory on hook\n         failure?\n     \"\"\"\n-    pass\n+    with work_in(repo_dir):\n+        try:\n+            run_hook_from_repo_dir(\n+                repo_dir=repo_dir,\n+                hook_name=hook_name,\n+                project_dir=project_dir,\n+                context=context\n+            )\n+        except FailedHookException:\n+            if delete_project_on_failure:\n+                logger.warning(\n+                    \"Hook script failed ({}). Removing project directory {}\".format(\n+                        hook_name, project_dir\n+                    )\n+                )\n+                rmtree(project_dir)\n+            raise\n+        except Exception:\n+            # Catch all other exceptions and raise a FailedHookException\n+            logger.warning(\n+                \"Hook script failed ({}). Removing project directory {}\".format(\n+                    hook_name, project_dir\n+                )\n+            )\n+            if delete_project_on_failure:\n+                rmtree(project_dir)\n+            raise FailedHookException(hook_name)\n\n\n def generate_files(repo_dir, context=None, output_dir='.',\n@@ -112,4 +222,57 @@ def generate_files(repo_dir, context=None, output_dir='.',\n     :param keep_project_on_failure: If `True` keep generated project directory even when\n         generation fails\n     \"\"\"\n-    pass\n+    template_dir = find_template(repo_dir)\n+    logger.debug('Generating project from %s...', template_dir)\n+    context = context or {}\n+    env = create_env_with_context(context)\n+\n+    # Create project dir\n+    project_dir = render_and_create_dir(\n+        os.path.basename(repo_dir),\n+        context,\n+        output_dir,\n+        env,\n+        overwrite_if_exists\n+    )\n+\n+    # Run pre-gen hook\n+    if accept_hooks:\n+        _run_hook_from_repo_dir(repo_dir, 'pre_gen_project', project_dir, context, not keep_project_on_failure)\n+\n+    logger.debug('Project directory is %s', project_dir)\n+\n+    # Render the templates and save them to files\n+    with work_in(template_dir):\n+        for root, dirs, files in os.walk('.'):\n+            for dirname in dirs:\n+                indir = os.path.normpath(os.path.join(root, dirname))\n+                outdir = os.path.normpath(os.path.join(project_dir, indir))\n+                render_and_create_dir(\n+                    indir,\n+                    context,\n+                    project_dir,\n+                    env,\n+                    overwrite_if_exists\n+                )\n+\n+            for filename in files:\n+                infile = os.path.normpath(os.path.join(root, filename))\n+                if is_copy_only_path(infile, context):\n+                    outfile = os.path.join(project_dir, infile)\n+                    logger.debug('Copying %s to %s without rendering', infile, outfile)\n+                    shutil.copyfile(infile, outfile)\n+                else:\n+                    generate_file(\n+                        project_dir,\n+                        infile,\n+                        context,\n+                        env,\n+                        skip_if_file_exists\n+                    )\n+\n+    # Run post-gen hook\n+    if accept_hooks:\n+        _run_hook_from_repo_dir(repo_dir, 'post_gen_project', project_dir, context, not keep_project_on_failure)\n+\n+    return project_dir\ndiff --git a/cookiecutter/hooks.py b/cookiecutter/hooks.py\nindex 0aa9c52..010ff2b 100644\n--- a/cookiecutter/hooks.py\n+++ b/cookiecutter/hooks.py\n@@ -22,7 +22,11 @@ def valid_hook(hook_file, hook_name):\n     :param hook_name: The hook to find\n     :return: The hook file validity\n     \"\"\"\n-    pass\n+    return (\n+        hook_file.startswith(hook_name) and\n+        hook_file.endswith(('.py', '.sh')) and\n+        not hook_file.endswith('.pyc')\n+    )\n\n\n def find_hook(hook_name, hooks_dir='hooks'):\n@@ -37,7 +41,15 @@ def find_hook(hook_name, hooks_dir='hooks'):\n     :param hooks_dir: The hook directory in the template\n     :return: The absolute path to the hook script or None\n     \"\"\"\n-    pass\n+    hooks_dir = os.path.abspath(hooks_dir)\n+    if not os.path.isdir(hooks_dir):\n+        return None\n+\n+    for hook_file in os.listdir(hooks_dir):\n+        if valid_hook(hook_file, hook_name):\n+            return os.path.join(hooks_dir, hook_file)\n+\n+    return None\n\n\n def run_script(script_path, cwd='.'):\n@@ -46,7 +58,11 @@ def run_script(script_path, cwd='.'):\n     :param script_path: Absolute path to the script to run.\n     :param cwd: The directory to run the script from.\n     \"\"\"\n-    pass\n+    with work_in(cwd):\n+        if script_path.endswith('.py'):\n+            subprocess.check_call([sys.executable, script_path], cwd=cwd)\n+        else:\n+            subprocess.check_call([script_path], cwd=cwd)\n\n\n def run_script_with_context(script_path, cwd, context):\n@@ -56,7 +72,25 @@ def run_script_with_context(script_path, cwd, context):\n     :param cwd: The directory to run the script from.\n     :param context: Cookiecutter project template context.\n     \"\"\"\n-    pass\n+    env = create_env_with_context(context)\n+    with open(script_path, 'r') as f:\n+        script = f.read()\n+\n+    try:\n+        rendered_script = env.from_string(script).render(**context)\n+    except UndefinedError as err:\n+        msg = f\"Unable to render script '{script_path}': {err.message}\"\n+        raise FailedHookException(msg)\n+\n+    with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_script:\n+        temp_script.write(rendered_script)\n+        temp_script.flush()\n+        temp_script_path = temp_script.name\n+\n+    try:\n+        run_script(temp_script_path, cwd)\n+    finally:\n+        os.remove(temp_script_path)\n\n\n def run_hook(hook_name, project_dir, context):\n@@ -67,7 +101,13 @@ def run_hook(hook_name, project_dir, context):\n     :param project_dir: The directory to execute the script from.\n     :param context: Cookiecutter project context.\n     \"\"\"\n-    pass\n+    hook_path = find_hook(hook_name)\n+    if hook_path:\n+        logger.debug(f\"Running hook {hook_name}\")\n+        if hook_path.endswith('.py'):\n+            run_script_with_context(hook_path, project_dir, context)\n+        else:\n+            run_script(hook_path, project_dir)\n\n\n def run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n@@ -81,7 +121,28 @@ def run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n     :param delete_project_on_failure: Delete the project directory on hook\n         failure?\n     \"\"\"\n-    pass\n+    with work_in(repo_dir):\n+        try:\n+            run_hook(hook_name, project_dir, context)\n+        except FailedHookException:\n+            if delete_project_on_failure:\n+                logger.debug(\n+                    \"Hook script failed ({}). Removing project directory {}\"\n+                    .format(hook_name, project_dir)\n+                )\n+                rmtree(project_dir)\n+            raise\n+        except Exception:\n+            # Log the exception here, but do not raise it,\n+            # to avoid a cryptic error message\n+            logger.exception(f'Hook script failed ({hook_name})')\n+            if delete_project_on_failure:\n+                logger.debug(\n+                    \"Hook script failed ({}). Removing project directory {}\"\n+                    .format(hook_name, project_dir)\n+                )\n+                rmtree(project_dir)\n+            raise\n\n\n def run_pre_prompt_hook(repo_dir: 'os.PathLike[str]') -&gt;Path:\n@@ -89,4 +150,16 @@ def run_pre_prompt_hook(repo_dir: 'os.PathLike[str]') -&gt;Path:\n\n     :param repo_dir: Project template input directory.\n     \"\"\"\n-    pass\n+    with work_in(repo_dir):\n+        hook_path = find_hook('pre_prompt')\n+        if hook_path:\n+            logger.debug(\"Running pre_prompt hook\")\n+            tmp_repo_dir = create_tmp_repo_dir()\n+            try:\n+                run_script(hook_path, tmp_repo_dir)\n+                return Path(tmp_repo_dir)\n+            except Exception:\n+                logger.exception('Pre-prompt hook failed')\n+                rmtree(tmp_repo_dir)\n+                raise\n+    return Path(repo_dir)\ndiff --git a/cookiecutter/log.py b/cookiecutter/log.py\nindex 894c633..949f58f 100644\n--- a/cookiecutter/log.py\n+++ b/cookiecutter/log.py\n@@ -13,4 +13,25 @@ def configure_logger(stream_level='DEBUG', debug_file=None):\n     Set up logging to stdout with given level. If ``debug_file`` is given set\n     up logging to file with DEBUG level.\n     \"\"\"\n-    pass\n+    # Get the root logger\n+    logger = logging.getLogger()\n+    logger.setLevel(logging.DEBUG)\n+\n+    # Remove any existing handlers to avoid duplicates\n+    for handler in logger.handlers[:]:\n+        logger.removeHandler(handler)\n+\n+    # Set up console handler\n+    console_handler = logging.StreamHandler(sys.stdout)\n+    console_handler.setLevel(LOG_LEVELS.get(stream_level.upper(), logging.DEBUG))\n+    console_formatter = logging.Formatter(LOG_FORMATS.get(stream_level.upper(), LOG_FORMATS['DEBUG']))\n+    console_handler.setFormatter(console_formatter)\n+    logger.addHandler(console_handler)\n+\n+    # Set up file handler if debug_file is provided\n+    if debug_file:\n+        file_handler = logging.FileHandler(debug_file)\n+        file_handler.setLevel(logging.DEBUG)\n+        file_formatter = logging.Formatter(LOG_FORMATS['DEBUG'])\n+        file_handler.setFormatter(file_formatter)\n+        logger.addHandler(file_handler)\ndiff --git a/cookiecutter/main.py b/cookiecutter/main.py\nindex 4b1087d..fdf3dca 100644\n--- a/cookiecutter/main.py\n+++ b/cookiecutter/main.py\n@@ -52,7 +52,76 @@ def cookiecutter(template, checkout=None, no_input=False, extra_context=\n     :param keep_project_on_failure: If `True` keep generated project directory even when\n         generation fails\n     \"\"\"\n-    pass\n+    # Get user configuration\n+    config_dict = get_user_config(config_file=config_file, default_config=default_config)\n+\n+    # Determine the template directory\n+    repo_dir, cleanup = determine_repo_dir(\n+        template=template,\n+        checkout=checkout,\n+        clone_to_dir=config_dict['cookiecutters_dir'],\n+        no_input=no_input,\n+        password=password,\n+        directory=directory\n+    )\n+\n+    # Ensure cleanup function is called\n+    try:\n+        with _patch_import_path_for_repo(repo_dir):\n+            # Run pre-prompt hook\n+            if accept_hooks:\n+                run_pre_prompt_hook(repo_dir, config_dict)\n+\n+            # Generate or load context\n+            context_file = os.path.join(repo_dir, 'cookiecutter.json')\n+            context = generate_context(\n+                context_file=context_file,\n+                default_context=config_dict['default_context'],\n+                extra_context=extra_context,\n+            )\n+\n+            # Prompt the user to manually configure the context\n+            if not no_input:\n+                nested_template = choose_nested_template(repo_dir, context)\n+                if nested_template:\n+                    repo_dir = os.path.join(repo_dir, nested_template)\n+                    context_file = os.path.join(repo_dir, 'cookiecutter.json')\n+                    context = generate_context(\n+                        context_file=context_file,\n+                        default_context=config_dict['default_context'],\n+                        extra_context=extra_context,\n+                    )\n+                context = prompt_for_config(context, no_input)\n+\n+            # Load context from replay file\n+            if replay:\n+                context = load(config_dict['replay_dir'], template)\n+\n+            # Create project from local context\n+            project_dir = generate_files(\n+                repo_dir=repo_dir,\n+                context=context,\n+                overwrite_if_exists=overwrite_if_exists,\n+                skip_if_file_exists=skip_if_file_exists,\n+                output_dir=output_dir,\n+                accept_hooks=accept_hooks,\n+            )\n+\n+    except Exception:\n+        # Cleanup on failure\n+        if cleanup and not keep_project_on_failure:\n+            if os.path.exists(project_dir):\n+                rmtree(project_dir)\n+        raise\n+    else:\n+        # Successful project creation\n+        dump(config_dict['replay_dir'], template, context)\n+\n+    finally:\n+        if cleanup:\n+            cleanup()\n+\n+    return project_dir\n\n\n class _patch_import_path_for_repo:\ndiff --git a/cookiecutter/prompt.py b/cookiecutter/prompt.py\nindex 2bcc55f..da70f02 100644\n--- a/cookiecutter/prompt.py\n+++ b/cookiecutter/prompt.py\n@@ -17,7 +17,11 @@ def read_user_variable(var_name, default_value, prompts=None, prefix=''):\n     :param str var_name: Variable of the context to query the user\n     :param default_value: Value that will be returned if no input happens\n     \"\"\"\n-    pass\n+    prompt_text = f\"{prefix}{var_name}\"\n+    if prompts and var_name in prompts:\n+        prompt_text = prompts[var_name]\n+    \n+    return Prompt.ask(prompt_text, default=default_value)\n\n\n class YesNoPrompt(Confirm):\n@@ -27,7 +31,13 @@ class YesNoPrompt(Confirm):\n\n     def process_response(self, value: str) -&gt;bool:\n         \"\"\"Convert choices to a bool.\"\"\"\n-        pass\n+        value = value.lower()\n+        if value in self.yes_choices:\n+            return True\n+        elif value in self.no_choices:\n+            return False\n+        else:\n+            raise InvalidResponse(self.validate_error_message)\n\n\n def read_user_yes_no(var_name, default_value, prompts=None, prefix=''):\n@@ -44,7 +54,11 @@ def read_user_yes_no(var_name, default_value, prompts=None, prefix=''):\n     :param str question: Question to the user\n     :param default_value: Value that will be returned if no input happens\n     \"\"\"\n-    pass\n+    prompt_text = f\"{prefix}{var_name}\"\n+    if prompts and var_name in prompts:\n+        prompt_text = prompts[var_name]\n+    \n+    return YesNoPrompt.ask(prompt_text, default=default_value)\n\n\n def read_repo_password(question):\n@@ -52,7 +66,7 @@ def read_repo_password(question):\n\n     :param str question: Question to the user\n     \"\"\"\n-    pass\n+    return Prompt.ask(question, password=True)\n\n\n def read_user_choice(var_name, options, prompts=None, prefix=''):\n@@ -64,7 +78,17 @@ def read_user_choice(var_name, options, prompts=None, prefix=''):\n     :param list options: Sequence of options that are available to select from\n     :return: Exactly one item of ``options`` that has been chosen by the user\n     \"\"\"\n-    pass\n+    prompt_text = f\"{prefix}{var_name}\"\n+    if prompts and var_name in prompts:\n+        prompt_text = prompts[var_name]\n+    \n+    choices = [str(i) for i in range(len(options))]\n+    choice_text = \"\\n\".join(f\"{i}: {option}\" for i, option in enumerate(options))\n+    \n+    while True:\n+        print(f\"{prompt_text}\\n{choice_text}\")\n+        choice = Prompt.ask(\"Enter the number of your choice\", choices=choices, default=\"0\")\n+        return options[int(choice)]\n\n\n DEFAULT_DISPLAY = 'default'\n@@ -75,7 +99,10 @@ def process_json(user_value, default_value=None):\n\n     :param str user_value: User-supplied value to load as a JSON dict\n     \"\"\"\n-    pass\n+    try:\n+        return json.loads(user_value)\n+    except json.JSONDecodeError:\n+        return default_value\n\n\n class JsonPrompt(PromptBase[dict]):\n@@ -87,7 +114,10 @@ class JsonPrompt(PromptBase[dict]):\n\n     def process_response(self, value: str) -&gt;dict:\n         \"\"\"Convert choices to a dict.\"\"\"\n-        pass\n+        try:\n+            return json.loads(value)\n+        except json.JSONDecodeError:\n+            raise InvalidResponse(self.validate_error_message)\n\n\n def read_user_dict(var_name, default_value, prompts=None, prefix=''):\n@@ -97,7 +127,12 @@ def read_user_dict(var_name, default_value, prompts=None, prefix=''):\n     :param default_value: Value that will be returned if no input is provided\n     :return: A Python dictionary to use in the context.\n     \"\"\"\n-    pass\n+    prompt_text = f\"{prefix}{var_name}\"\n+    if prompts and var_name in prompts:\n+        prompt_text = prompts[var_name]\n+    \n+    default_json = json.dumps(default_value) if default_value else None\n+    return JsonPrompt.ask(prompt_text, default=default_json)\n\n\n def render_variable(env, raw, cookiecutter_dict):\n@@ -117,12 +152,25 @@ def render_variable(env, raw, cookiecutter_dict):\n         being populated with variables.\n     :return: The rendered value for the default variable.\n     \"\"\"\n-    pass\n+    if not isinstance(raw, str):\n+        return raw\n+\n+    template = env.from_string(raw)\n+    try:\n+        return template.render(**cookiecutter_dict)\n+    except UndefinedError as err:\n+        raise UndefinedVariableInTemplate(str(err), err, cookiecutter_dict)\n\n\n def _prompts_from_options(options: dict) -&gt;dict:\n     \"\"\"Process template options and return friendly prompt information.\"\"\"\n-    pass\n+    prompts = {}\n+    for key, value in options.items():\n+        if isinstance(value, dict):\n+            prompts[key] = value.get('_prompt', key)\n+        else:\n+            prompts[key] = key\n+    return prompts\n\n\n def prompt_choice_for_template(key, options, no_input):\n@@ -130,7 +178,12 @@ def prompt_choice_for_template(key, options, no_input):\n\n     :param no_input: Do not prompt for user input and return the first available option.\n     \"\"\"\n-    pass\n+    if no_input:\n+        return next(iter(options.values()))\n+\n+    prompts = _prompts_from_options(options)\n+    choices = list(options.keys())\n+    return read_user_choice(key, choices, prompts=prompts)\n\n\n def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input,\n@@ -139,7 +192,15 @@ def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input,\n\n     :param no_input: Do not prompt for user input and return the first available option.\n     \"\"\"\n-    pass\n+    if no_input:\n+        return next(iter(options.values()))\n+\n+    rendered_options = OrderedDict()\n+    for option_key, option_value in options.items():\n+        rendered_options[option_key] = render_variable(env, option_value, cookiecutter_dict)\n+\n+    choice = read_user_choice(key, list(rendered_options.keys()), prompts=prompts, prefix=prefix)\n+    return rendered_options[choice]\n\n\n def prompt_for_config(context, no_input=False):\n@@ -148,7 +209,25 @@ def prompt_for_config(context, no_input=False):\n     :param dict context: Source for field names and sample values.\n     :param no_input: Do not prompt for user input and use only values from context.\n     \"\"\"\n-    pass\n+    cookiecutter_dict = OrderedDict([])\n+    env = create_env_with_context(context)\n+\n+    for key, raw in context['cookiecutter'].items():\n+        if key.startswith('_'):\n+            cookiecutter_dict[key] = raw\n+            continue\n+\n+        if isinstance(raw, dict):\n+            cookiecutter_dict[key] = prompt_choice_for_config(\n+                cookiecutter_dict, env, key, raw, no_input\n+            )\n+        else:\n+            if no_input:\n+                cookiecutter_dict[key] = render_variable(env, raw, cookiecutter_dict)\n+            else:\n+                cookiecutter_dict[key] = read_user_variable(key, raw)\n+\n+    return cookiecutter_dict\n\n\n def choose_nested_template(context: dict, repo_dir: str, no_input: bool=False\n@@ -160,7 +239,17 @@ def choose_nested_template(context: dict, repo_dir: str, no_input: bool=False\n     :param no_input: Do not prompt for user input and use only values from context.\n     :returns: Path to the selected template.\n     \"\"\"\n-    pass\n+    template_dir = Path(repo_dir) / 'templates'\n+    template_names = [d.name for d in template_dir.iterdir() if d.is_dir()]\n+\n+    if not template_names:\n+        raise ValueError(\"No nested templates found in the repository.\")\n+\n+    if no_input or len(template_names) == 1:\n+        return str(template_dir / template_names[0])\n+\n+    choice = read_user_choice(\"Select a template\", template_names)\n+    return str(template_dir / choice)\n\n\n def prompt_and_delete(path, no_input=False):\n@@ -174,4 +263,25 @@ def prompt_and_delete(path, no_input=False):\n     :param no_input: Suppress prompt to delete repo and just delete it.\n     :return: True if the content was deleted\n     \"\"\"\n-    pass\n+    if no_input:\n+        rmtree(path)\n+        return True\n+\n+    delete = read_user_yes_no(\n+        f\"You've downloaded {path} before. Is it okay to delete and re-download it?\",\n+        default_value=True\n+    )\n+\n+    if delete:\n+        rmtree(path)\n+        return True\n+\n+    reuse = read_user_yes_no(\n+        \"Do you want to re-use the existing version?\",\n+        default_value=True\n+    )\n+\n+    if reuse:\n+        return False\n+\n+    sys.exit()\ndiff --git a/cookiecutter/replay.py b/cookiecutter/replay.py\nindex 340be41..54a1692 100644\n--- a/cookiecutter/replay.py\n+++ b/cookiecutter/replay.py\n@@ -10,14 +10,20 @@ from cookiecutter.utils import make_sure_path_exists\n\n def get_file_name(replay_dir, template_name):\n     \"\"\"Get the name of file.\"\"\"\n-    pass\n+    file_name = f\"{template_name}.json\"\n+    return os.path.join(replay_dir, file_name)\n\n\n def dump(replay_dir: 'os.PathLike[str]', template_name: str, context: dict):\n     \"\"\"Write json data to file.\"\"\"\n-    pass\n+    make_sure_path_exists(replay_dir)\n+    file_path = get_file_name(replay_dir, template_name)\n+    with open(file_path, 'w') as f:\n+        json.dump(context, f, indent=2)\n\n\n def load(replay_dir, template_name):\n     \"\"\"Read json data from file.\"\"\"\n-    pass\n+    file_path = get_file_name(replay_dir, template_name)\n+    with open(file_path, 'r') as f:\n+        return json.load(f)\ndiff --git a/cookiecutter/repository.py b/cookiecutter/repository.py\nindex e350c56..edcad60 100644\n--- a/cookiecutter/repository.py\n+++ b/cookiecutter/repository.py\n@@ -17,12 +17,12 @@ REPO_REGEX = re.compile(\n\n def is_repo_url(value):\n     \"\"\"Return True if value is a repository URL.\"\"\"\n-    pass\n+    return bool(REPO_REGEX.match(value))\n\n\n def is_zip_file(value):\n     \"\"\"Return True if value is a zip file.\"\"\"\n-    pass\n+    return value.lower().endswith('.zip')\n\n\n def expand_abbreviations(template, abbreviations):\n@@ -31,7 +31,9 @@ def expand_abbreviations(template, abbreviations):\n     :param template: The project template name.\n     :param abbreviations: Abbreviation definitions.\n     \"\"\"\n-    pass\n+    if template in abbreviations:\n+        return abbreviations[template]\n+    return template\n\n\n def repository_has_cookiecutter_json(repo_directory):\n@@ -40,7 +42,10 @@ def repository_has_cookiecutter_json(repo_directory):\n     :param repo_directory: The candidate repository directory.\n     :return: True if the `repo_directory` is valid, else False.\n     \"\"\"\n-    pass\n+    repo_dir_exists = os.path.isdir(repo_directory)\n+    cookiecutter_json_path = os.path.join(repo_directory, 'cookiecutter.json')\n+    has_cookiecutter_json = os.path.isfile(cookiecutter_json_path)\n+    return repo_dir_exists and has_cookiecutter_json\n\n\n def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,\n@@ -67,4 +72,35 @@ def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,\n         after the template has been instantiated.\n     :raises: `RepositoryNotFound` if a repository directory could not be found.\n     \"\"\"\n-    pass\n+    template = expand_abbreviations(template, abbreviations)\n+\n+    if is_repo_url(template):\n+        repo_dir = clone(\n+            repo_url=template,\n+            checkout=checkout,\n+            clone_to_dir=clone_to_dir,\n+            no_input=no_input\n+        )\n+        cleanup = True\n+    elif is_zip_file(template):\n+        repo_dir = unzip(\n+            zip_uri=template,\n+            is_url=is_repo_url(template),\n+            clone_to_dir=clone_to_dir,\n+            no_input=no_input,\n+            password=password\n+        )\n+        cleanup = True\n+    else:\n+        repo_dir = template\n+        cleanup = False\n+\n+    if directory:\n+        repo_dir = os.path.join(repo_dir, directory)\n+\n+    if not repository_has_cookiecutter_json(repo_dir):\n+        raise RepositoryNotFound(\n+            'The repository {} does not contain a cookiecutter.json file'.format(repo_dir)\n+        )\n+\n+    return repo_dir, cleanup\ndiff --git a/cookiecutter/utils.py b/cookiecutter/utils.py\nindex 6aa68ba..a93b5a4 100644\n--- a/cookiecutter/utils.py\n+++ b/cookiecutter/utils.py\n@@ -18,7 +18,8 @@ def force_delete(func, path, exc_info):\n     Usage: `shutil.rmtree(path, onerror=force_delete)`\n     From https://docs.python.org/3/library/shutil.html#rmtree-example\n     \"\"\"\n-    pass\n+    os.chmod(path, stat.S_IWRITE)\n+    func(path)\n\n\n def rmtree(path):\n@@ -26,7 +27,7 @@ def rmtree(path):\n\n     :param path: A directory path.\n     \"\"\"\n-    pass\n+    shutil.rmtree(path, onerror=force_delete)\n\n\n def make_sure_path_exists(path: 'os.PathLike[str]') -&gt;None:\n@@ -34,7 +35,7 @@ def make_sure_path_exists(path: 'os.PathLike[str]') -&gt;None:\n\n     :param path: A directory tree path for creation.\n     \"\"\"\n-    pass\n+    os.makedirs(path, exist_ok=True)\n\n\n @contextlib.contextmanager\n@@ -43,7 +44,13 @@ def work_in(dirname=None):\n\n     When exited, returns to the working directory prior to entering.\n     \"\"\"\n-    pass\n+    curdir = os.getcwd()\n+    try:\n+        if dirname is not None:\n+            os.chdir(dirname)\n+        yield\n+    finally:\n+        os.chdir(curdir)\n\n\n def make_executable(script_path):\n@@ -51,19 +58,28 @@ def make_executable(script_path):\n\n     :param script_path: The file to change\n     \"\"\"\n-    pass\n+    mode = os.stat(script_path).st_mode\n+    os.chmod(script_path, mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)\n\n\n def simple_filter(filter_function):\n     \"\"\"Decorate a function to wrap it in a simplified jinja2 extension.\"\"\"\n-    pass\n+    class SimpleExtension(Extension):\n+        def __init__(self, environment):\n+            super().__init__(environment)\n+            environment.filters[filter_function.__name__] = filter_function\n+\n+    return SimpleExtension\n\n\n def create_tmp_repo_dir(repo_dir: 'os.PathLike[str]') -&gt;Path:\n     \"\"\"Create a temporary dir with a copy of the contents of repo_dir.\"\"\"\n-    pass\n+    temp_dir = Path(tempfile.mkdtemp())\n+    shutil.copytree(repo_dir, temp_dir, symlinks=True)\n+    return temp_dir\n\n\n def create_env_with_context(context: Dict):\n     \"\"\"Create a jinja environment using the provided context.\"\"\"\n-    pass\n+    env = StrictEnvironment(context=context)\n+    return env\ndiff --git a/cookiecutter/vcs.py b/cookiecutter/vcs.py\nindex 94d6c05..f0eae9f 100644\n--- a/cookiecutter/vcs.py\n+++ b/cookiecutter/vcs.py\n@@ -20,16 +20,30 @@ def identify_repo(repo_url):\n     :param repo_url: Repo URL of unknown type.\n     :returns: ('git', repo_url), ('hg', repo_url), or None.\n     \"\"\"\n-    pass\n+    repo_url = repo_url.lower()\n+    if repo_url.startswith('git+'):\n+        return 'git', repo_url[4:]\n+    elif repo_url.startswith('hg+'):\n+        return 'hg', repo_url[3:]\n+    elif repo_url.endswith('.git') or 'github.com' in repo_url:\n+        return 'git', repo_url\n+    elif 'bitbucket.org' in repo_url:\n+        return 'hg', repo_url\n+    return None\n\n\n def is_vcs_installed(repo_type):\n     \"\"\"\n     Check if the version control system for a repo type is installed.\n\n-    :param repo_type:\n+    :param repo_type: The type of repository ('git' or 'hg').\n+    :return: True if the VCS is installed, False otherwise.\n     \"\"\"\n-    pass\n+    if repo_type == 'git':\n+        return which('git') is not None\n+    elif repo_type == 'hg':\n+        return which('hg') is not None\n+    return False\n\n\n def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n@@ -44,4 +58,57 @@ def clone(repo_url: str, checkout: Optional[str]=None, clone_to_dir:\n         cached resources.\n     :returns: str with path to the new directory of the repository.\n     \"\"\"\n-    pass\n+    repo_type, repo_url = identify_repo(repo_url)\n+    if repo_type is None:\n+        raise UnknownRepoType(f\"Couldn't determine repository type for {repo_url}\")\n+\n+    if not is_vcs_installed(repo_type):\n+        raise VCSNotInstalled(f\"{repo_type} is not installed.\")\n+\n+    clone_to_dir = Path(clone_to_dir).resolve()\n+    make_sure_path_exists(clone_to_dir)\n+\n+    repo_dir = clone_to_dir / Path(repo_url).stem\n+\n+    if repo_dir.exists():\n+        if no_input:\n+            logger.warning(\"'%s' directory already exists, deleting it\", repo_dir)\n+            subprocess.check_call([repo_type, 'init', str(repo_dir)])\n+        else:\n+            prompt_and_delete(repo_dir)\n+\n+    if repo_type == 'git':\n+        clone_cmd = ['git', 'clone', repo_url, str(repo_dir)]\n+    else:  # hg\n+        clone_cmd = ['hg', 'clone', repo_url, str(repo_dir)]\n+\n+    try:\n+        subprocess.check_output(clone_cmd, stderr=subprocess.STDOUT)\n+    except subprocess.CalledProcessError as e:\n+        output = e.output.decode('utf-8')\n+        if 'Repository not found' in output:\n+            raise RepositoryNotFound(f\"The repository {repo_url} could not be found\")\n+        else:\n+            raise RepositoryCloneFailed(f\"Cloning {repo_url} failed: {output}\")\n+\n+    if checkout:\n+        if repo_type == 'git':\n+            checkout_cmd = ['git', 'checkout', checkout]\n+        else:  # hg\n+            checkout_cmd = ['hg', 'update', checkout]\n+\n+        with Path.cwd():\n+            os.chdir(repo_dir)\n+            try:\n+                subprocess.check_output(checkout_cmd, stderr=subprocess.STDOUT)\n+            except subprocess.CalledProcessError as e:\n+                output = e.output.decode('utf-8')\n+                if any(error in output for error in BRANCH_ERRORS):\n+                    raise RepositoryCloneFailed(\n+                        f\"Couldn't checkout {checkout} in {repo_url}. \"\n+                        f\"Error: {output}\"\n+                    )\n+                else:\n+                    raise\n+\n+    return str(repo_dir)\ndiff --git a/cookiecutter/zipfile.py b/cookiecutter/zipfile.py\nindex c4d398a..1448316 100644\n--- a/cookiecutter/zipfile.py\n+++ b/cookiecutter/zipfile.py\n@@ -25,4 +25,46 @@ def unzip(zip_uri: str, is_url: bool, clone_to_dir: 'os.PathLike[str]'='.',\n         cached resources.\n     :param password: The password to use when unpacking the repository.\n     \"\"\"\n-    pass\n+    clone_to_dir = Path(clone_to_dir)\n+    make_sure_path_exists(clone_to_dir)\n+\n+    if is_url:\n+        # Download the file\n+        response = requests.get(zip_uri)\n+        response.raise_for_status()\n+        zip_file = tempfile.NamedTemporaryFile(delete=False, suffix='.zip', dir=clone_to_dir)\n+        zip_file.write(response.content)\n+        zip_file.close()\n+        zip_path = Path(zip_file.name)\n+    else:\n+        zip_path = Path(zip_uri)\n+\n+    # Create a temporary directory to extract the contents\n+    with tempfile.TemporaryDirectory(dir=clone_to_dir) as temp_dir:\n+        try:\n+            with ZipFile(zip_path, 'r') as zip_ref:\n+                if zip_ref.namelist() and zip_ref.testzip() is not None:\n+                    raise InvalidZipRepository(f\"The zip file {zip_uri} is invalid or corrupt.\")\n+\n+                if password is None and zip_ref.namelist()[0].endswith('/'):\n+                    password = read_repo_password('Enter the password for the encrypted repository:')\n+\n+                try:\n+                    zip_ref.extractall(path=temp_dir, pwd=password.encode() if password else None)\n+                except RuntimeError as e:\n+                    if \"Bad password\" in str(e):\n+                        raise InvalidZipRepository(f\"Invalid password for encrypted repository: {zip_uri}\")\n+                    raise\n+\n+            # If everything is successful, return the path to the extracted contents\n+            return Path(temp_dir)\n+\n+        except BadZipFile:\n+            raise InvalidZipRepository(f\"The zip file {zip_uri} is invalid or corrupt.\")\n+\n+        finally:\n+            if is_url:\n+                if no_input:\n+                    os.unlink(zip_path)\n+                else:\n+                    prompt_and_delete(zip_path)\n</code></pre>"},{"location":"analysis_baseline_deprecated/","title":"Analysis baseline deprecated","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_deprecated/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_deprecated/#repository-deprecated","title":"Repository: deprecated","text":""},{"location":"analysis_baseline_deprecated/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count passed 80 error 10 failed 81 total 171 collected 171"},{"location":"analysis_baseline_deprecated/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsnone","title":"test_deprecated.py::test_classic_deprecated_function__warns[None]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[None]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n\n            @deprecated.classic.deprecated\n&gt;           def foo1():\n\ntests/test_deprecated.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.foo1 at 0x7ef7622d7400&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function1","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]</pre><pre>\nclassic_deprecated_function = .foo1 at 0x7ef76206d6c0&gt;\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:135: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function2","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_function(request):\n        if request.param is None:\n\n            @deprecated.classic.deprecated\n            def foo1():\n                pass\n\n            return foo1\n        else:\n            args, kwargs = request.param\n\n&gt;           @deprecated.classic.deprecated(*args, **kwargs)\n\ntests/test_deprecated.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('Good reason',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function3","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]</pre><pre>\nclassic_deprecated_function = .foo1 at 0x7ef76206dcf0&gt;\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:135: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function4","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]</pre><pre>\nclassic_deprecated_function = .foo1 at 0x7ef76206dea0&gt;\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:135: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function5","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]</pre><pre>\nclassic_deprecated_function = .foo1 at 0x7ef76206ca60&gt;\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:135: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function6","title":"test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]","text":"<pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]</pre><pre>\nclassic_deprecated_function = .foo1 at 0x7ef76206e050&gt;\n\n    def test_classic_deprecated_function__warns(classic_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:135: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class__warnsnone","title":"test_deprecated.py::test_classic_deprecated_class__warns[None]","text":"<pre>test_deprecated.py::test_classic_deprecated_class__warns[None]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n\n            @deprecated.classic.deprecated\n&gt;           class Foo2(object):\n\ntests/test_deprecated.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.Foo2'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class__warnsclassic_deprecated_class2","title":"test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]","text":"<pre>test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class(request):\n        if request.param is None:\n\n            @deprecated.classic.deprecated\n            class Foo2(object):\n                pass\n\n            return Foo2\n        else:\n            args, kwargs = request.param\n\n&gt;           @deprecated.classic.deprecated(*args, **kwargs)\n\ntests/test_deprecated.py:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('Good reason',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsnone","title":"test_deprecated.py::test_classic_deprecated_method__warns[None]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[None]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n\n&gt;           class Foo3(object):\n\ntests/test_deprecated.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:69: in Foo3\n    def foo3(self):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.Foo3.foo3 at 0x7ef76206d750&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method1","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]</pre><pre>\nclassic_deprecated_method = .Foo3'&gt;\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:160: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method2","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_method(request):\n        if request.param is None:\n\n            class Foo3(object):\n                @deprecated.classic.deprecated\n                def foo3(self):\n                    pass\n\n            return Foo3\n        else:\n            args, kwargs = request.param\n\n&gt;           class Foo3(object):\n\ntests/test_deprecated.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:77: in Foo3\n    @deprecated.classic.deprecated(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('Good reason',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method3","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]</pre><pre>\nclassic_deprecated_method = .Foo3'&gt;\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:160: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method4","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]</pre><pre>\nclassic_deprecated_method = .Foo3'&gt;\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:160: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method5","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]</pre><pre>\nclassic_deprecated_method = .Foo3'&gt;\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:160: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method6","title":"test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]","text":"<pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]</pre><pre>\nclassic_deprecated_method = .Foo3'&gt;\n\n    def test_classic_deprecated_method__warns(classic_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = classic_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:160: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsnone","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[None]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[None]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n\n&gt;           class Foo4(object):\n\ntests/test_deprecated.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:91: in Foo4\n    def foo4():\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.Foo4.foo4 at 0x7ef76206dd80&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method1","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]</pre><pre>\nclassic_deprecated_static_method = .Foo4.foo4 at 0x7ef76206f640&gt;\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:172: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method2","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_static_method(request):\n        if request.param is None:\n\n            class Foo4(object):\n                @staticmethod\n                @deprecated.classic.deprecated\n                def foo4():\n                    pass\n\n            return Foo4.foo4\n        else:\n            args, kwargs = request.param\n\n&gt;           class Foo4(object):\n\ntests/test_deprecated.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:100: in Foo4\n    @deprecated.classic.deprecated(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('Good reason',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method3","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]</pre><pre>\nclassic_deprecated_static_method = .Foo4.foo4 at 0x7ef76206ff40&gt;\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:172: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method4","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]</pre><pre>\nclassic_deprecated_static_method = .Foo4.foo4 at 0x7ef76206f910&gt;\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:172: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method5","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]</pre><pre>\nclassic_deprecated_static_method = .Foo4.foo4 at 0x7ef76206ee60&gt;\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:172: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method6","title":"test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]","text":"<pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]</pre><pre>\nclassic_deprecated_static_method = .Foo4.foo4 at 0x7ef76206f0a0&gt;\n\n    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            classic_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:172: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsnone","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[None]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[None]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n\n&gt;           class Foo5(object):\n\ntests/test_deprecated.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:114: in Foo5\n    def foo5(cls):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.Foo5.foo5 at 0x7ef76206f010&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method1","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]</pre><pre>\nclassic_deprecated_class_method = .Foo5'&gt;\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:185: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method2","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]</pre><pre>\nrequest = &gt;\n\n    @pytest.fixture(scope=\"module\", params=_PARAMS)\n    def classic_deprecated_class_method(request):\n        if request.param is None:\n\n            class Foo5(object):\n                @classmethod\n                @deprecated.classic.deprecated\n                def foo5(cls):\n                    pass\n\n            return Foo5\n        else:\n            args, kwargs = request.param\n\n&gt;           class Foo5(object):\n\ntests/test_deprecated.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_deprecated.py:123: in Foo5\n    @deprecated.classic.deprecated(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('Good reason',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method3","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]</pre><pre>\nclassic_deprecated_class_method = .Foo5'&gt;\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:185: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method4","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]</pre><pre>\nclassic_deprecated_class_method = .Foo5'&gt;\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:185: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method5","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]</pre><pre>\nclassic_deprecated_class_method = .Foo5'&gt;\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:185: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method6","title":"test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]","text":"<pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]</pre><pre>\nclassic_deprecated_class_method = .Foo5'&gt;\n\n    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = classic_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:185: AssertionError"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_should_raise_type_error","title":"test_deprecated.py::test_should_raise_type_error","text":"<pre>test_deprecated.py::test_should_raise_type_error</pre><pre>\ndef test_should_raise_type_error():\n        try:\n&gt;           deprecated.classic.deprecated(5)\n\ntests/test_deprecated.py:197: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (5,), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_warning_msg_has_reason","title":"test_deprecated.py::test_warning_msg_has_reason","text":"<pre>test_deprecated.py::test_warning_msg_has_reason</pre><pre>\ndef test_warning_msg_has_reason():\n        reason = \"Good reason\"\n\n        @deprecated.classic.deprecated(reason=reason)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_deprecated.py:212: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_warning_msg_has_version","title":"test_deprecated.py::test_warning_msg_has_version","text":"<pre>test_deprecated.py::test_warning_msg_has_version</pre><pre>\ndef test_warning_msg_has_version():\n        version = \"1.2.3\"\n\n        @deprecated.classic.deprecated(version=version)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_deprecated.py:225: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_specific_warning_cls_is_used","title":"test_deprecated.py::test_specific_warning_cls_is_used","text":"<pre>test_deprecated.py::test_specific_warning_cls_is_used</pre><pre>\ndef test_specific_warning_cls_is_used():\n        @deprecated.classic.deprecated(category=MyDeprecationWarning)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_deprecated.py:246: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecatedpytest_respect_global_filter","title":"test_deprecated.py::test_respect_global_filter","text":"<pre>test_deprecated.py::test_respect_global_filter</pre><pre>\ndef test_respect_global_filter():\n        @deprecated.classic.deprecated(version='1.2.1', reason=\"deprecated function\")\n        def fun():\n            print(\"fun\")\n\n        warnings.simplefilter(\"once\", category=DeprecationWarning)\n\n        with warnings.catch_warnings(record=True) as warns:\n            fun()\n            fun()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_deprecated.py:260: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecated_classpytest_class_deprecation_using_deprecated_decorator","title":"test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator","text":"<pre>test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator</pre><pre>\ndef test_class_deprecation_using_deprecated_decorator():\n        @deprecated.classic.deprecated\n&gt;       class MyBaseClass(object):\n\ntests/test_deprecated_class.py:93: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyBaseClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_classpytest_class_respect_global_filter","title":"test_deprecated_class.py::test_class_respect_global_filter","text":"<pre>test_deprecated_class.py::test_class_respect_global_filter</pre><pre>\ndef test_class_respect_global_filter():\n        @deprecated.classic.deprecated\n&gt;       class MyBaseClass(object):\n\ntests/test_deprecated_class.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyBaseClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_classpytest_subclass_deprecation_using_deprecated_decorator","title":"test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator","text":"<pre>test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator</pre><pre>\ndef test_subclass_deprecation_using_deprecated_decorator():\n        @deprecated.classic.deprecated\n&gt;       class MyBaseClass(object):\n\ntests/test_deprecated_class.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyBaseClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_classpytest_simple_class_deprecation_with_args","title":"test_deprecated_class.py::test_simple_class_deprecation_with_args","text":"<pre>test_deprecated_class.py::test_simple_class_deprecation_with_args</pre><pre>\ndef test_simple_class_deprecation_with_args():\n&gt;       @deprecated.classic.deprecated('kwargs class')\n\ntests/test_deprecated_class.py:142: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ('kwargs class',), kwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_deprecated_metaclasspytest_with_init","title":"test_deprecated_metaclass.py::test_with_init","text":"<pre>test_deprecated_metaclass.py::test_with_init</pre><pre>\ndef test_with_init():\n        @deprecated.classic.deprecated\n&gt;       class MyClass(object):\n\ntests/test_deprecated_metaclass.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_metaclasspytest_with_new","title":"test_deprecated_metaclass.py::test_with_new","text":"<pre>test_deprecated_metaclass.py::test_with_new</pre><pre>\ndef test_with_new():\n        @deprecated.classic.deprecated\n&gt;       class MyClass(object):\n\ntests/test_deprecated_metaclass.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_metaclasspytest_with_metaclass","title":"test_deprecated_metaclass.py::test_with_metaclass","text":"<pre>test_deprecated_metaclass.py::test_with_metaclass</pre><pre>\ndef test_with_metaclass():\n        class Meta(type):\n            def __call__(cls, *args, **kwargs):\n                obj = super(Meta, cls).__call__(*args, **kwargs)\n                obj.c = 3.14\n                return obj\n\n        @deprecated.classic.deprecated\n&gt;       class MyClass(with_metaclass(Meta)):\n\ntests/test_deprecated_metaclass.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_deprecated_metaclasspytest_with_singleton_metaclass","title":"test_deprecated_metaclass.py::test_with_singleton_metaclass","text":"<pre>test_deprecated_metaclass.py::test_with_singleton_metaclass</pre><pre>\ndef test_with_singleton_metaclass():\n        class Singleton(type):\n            _instances = {}\n\n            def __call__(cls, *args, **kwargs):\n                if cls not in cls._instances:\n                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n                return cls._instances[cls]\n\n        @deprecated.classic.deprecated\n&gt;       class MyClass(with_metaclass(Singleton)):\n\ntests/test_deprecated_metaclass.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-reasonversion","title":"test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]</pre><pre>\ndocstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = 'A good reason', version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n   A good reason\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-version","title":"test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]</pre><pre>\ndocstring = 'This function adds *x* and *y*.', directive = 'deprecated'\nreason = None, version = '1.2.0', expected = '.. deprecated:: 1.2.0\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-reasonversion","title":"test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]</pre><pre>\ndocstring = None, directive = 'deprecated', reason = 'A good reason'\nversion = '1.2.0', expected = '.. deprecated:: 1.2.0\\n   A good reason\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-version","title":"test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]</pre><pre>\ndocstring = None, directive = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion","title":"test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]</pre><pre>\ndocstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n   A good reason\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-version","title":"test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]</pre><pre>\ndocstring = '\\n        This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion","title":"test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]</pre><pre>\ndocstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = 'A good reason', version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n   A good reason\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-version","title":"test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]","text":"<pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]</pre><pre>\ndocstring = 'This function adds *x* and *y*.\\n\\n        :param x: number *x*\\n        :param y: number *y*\\n        :return: sum = *x* + *y*\\n        '\ndirective = 'deprecated', reason = None, version = '1.2.0'\nexpected = '.. deprecated:: 1.2.0\\n'\n\n    @pytest.mark.parametrize(\n        \"reason, version, expected\",\n        [\n            (\n                'A good reason',\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                       {reason}\n                    \"\"\"\n                ),\n            ),\n            (\n                None,\n                '1.2.0',\n                textwrap.dedent(\n                    \"\"\"\\\n                    .. {directive}:: {version}\n                    \"\"\"\n                ),\n            ),\n        ],\n        ids=[\"reason&amp;version\", \"version\"],\n    )\n    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):\n        # The function:\n        def foo(x, y):\n            return x + y\n\n        # with docstring:\n        foo.__doc__ = docstring\n\n        # is decorated with:\n        decorator_factory = getattr(deprecated.sphinx, directive)\n        decorator = decorator_factory(reason=reason, version=version)\n        foo = decorator(foo)\n\n        # The function must contains this Sphinx docstring:\n        expected = expected.format(directive=directive, version=version, reason=reason)\n\n        current = textwrap.dedent(foo.__doc__)\n        assert current.endswith(expected)\n\n        current = current.replace(expected, '')\n        if docstring:\n            # An empty line must separate the original docstring and the directive.\n            assert re.search(\"\\n[ ]*\\n$\", current, flags=re.DOTALL)\n        else:\n            # Avoid \"Explicit markup ends without a blank line\" when the decorated function has no docstring\n            assert current == \"\\n\"\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo(1, 2)\n\n        if directive in {'versionadded', 'versionchanged'}:\n            # don't emit DeprecationWarning\n            assert len(warns) == 0\n        else:\n            # emit DeprecationWarning\n&gt;           assert len(warns) == 1\nE           assert 0 == 1\nE            +  where 0 = len([])\n\ntests/test_sphinx.py:105: AssertionError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function0","title":"test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]</pre><pre>\nsphinx_deprecated_function = .foo1 at 0x7ef7620f89d0&gt;\n\n    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:252: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function1","title":"test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]</pre><pre>\nsphinx_deprecated_function = .foo1 at 0x7ef7620f8310&gt;\n\n    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:252: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function2","title":"test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]</pre><pre>\nsphinx_deprecated_function = .foo1 at 0x7ef7620f84c0&gt;\n\n    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:252: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function3","title":"test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]</pre><pre>\nsphinx_deprecated_function = .foo1 at 0x7ef7620f8940&gt;\n\n    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_function()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:252: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method0","title":"test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]</pre><pre>\nsphinx_deprecated_method = .Foo3'&gt;\n\n    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = sphinx_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:278: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method1","title":"test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]</pre><pre>\nsphinx_deprecated_method = .Foo3'&gt;\n\n    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = sphinx_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:278: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method2","title":"test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]</pre><pre>\nsphinx_deprecated_method = .Foo3'&gt;\n\n    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = sphinx_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:278: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method3","title":"test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]</pre><pre>\nsphinx_deprecated_method = .Foo3'&gt;\n\n    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            obj = sphinx_deprecated_method()\n            obj.foo3()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:278: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method0","title":"test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]</pre><pre>\nsphinx_deprecated_static_method = .Foo4.foo4 at 0x7ef7620f8d30&gt;\n\n    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:289: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method1","title":"test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]</pre><pre>\nsphinx_deprecated_static_method = .Foo4.foo4 at 0x7ef7620f9090&gt;\n\n    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:289: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method2","title":"test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]</pre><pre>\nsphinx_deprecated_static_method = .Foo4.foo4 at 0x7ef7620f9240&gt;\n\n    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:289: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method3","title":"test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]</pre><pre>\nsphinx_deprecated_static_method = .Foo4.foo4 at 0x7ef7620f93f0&gt;\n\n    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            sphinx_deprecated_static_method()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:289: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method0","title":"test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]</pre><pre>\nsphinx_deprecated_class_method = .Foo5'&gt;\n\n    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = sphinx_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:301: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method1","title":"test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]</pre><pre>\nsphinx_deprecated_class_method = .Foo5'&gt;\n\n    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = sphinx_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:301: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method2","title":"test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]</pre><pre>\nsphinx_deprecated_class_method = .Foo5'&gt;\n\n    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = sphinx_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:301: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method3","title":"test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]","text":"<pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]</pre><pre>\nsphinx_deprecated_class_method = .Foo5'&gt;\n\n    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):\n        with warnings.catch_warnings(record=True) as warns:\n            warnings.simplefilter(\"always\")\n            cls = sphinx_deprecated_class_method()\n            cls.foo5()\n&gt;       assert len(warns) == 1\nE       assert 0 == 1\nE        +  where 0 = len([])\n\ntests/test_sphinx.py:301: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_warning_msg_has_reason","title":"test_sphinx.py::test_warning_msg_has_reason","text":"<pre>test_sphinx.py::test_warning_msg_has_reason</pre><pre>\ndef test_warning_msg_has_reason():\n        reason = \"Good reason\"\n\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_sphinx.py:330: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_warning_msg_has_version","title":"test_sphinx.py::test_warning_msg_has_version","text":"<pre>test_sphinx.py::test_warning_msg_has_version</pre><pre>\ndef test_warning_msg_has_version():\n        version = \"1.2.3\"\n\n        @deprecated.sphinx.deprecated(version=version)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_sphinx.py:343: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_specific_warning_cls_is_used","title":"test_sphinx.py::test_specific_warning_cls_is_used","text":"<pre>test_sphinx.py::test_specific_warning_cls_is_used</pre><pre>\ndef test_specific_warning_cls_is_used():\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", category=MyDeprecationWarning)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_sphinx.py:364: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_syntax_trimminguse-functionbar-instead-use-bar-instead","title":"test_sphinx.py::test_sphinx_syntax_trimming[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        [\"reason\", \"expected\"],\n        [\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n        ],\n    )\n    def test_sphinx_syntax_trimming(reason, expected):\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_sphinx.py:389: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_sphinx_syntax_trimminguse-pyfuncbar-instead-use-bar-instead","title":"test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        [\"reason\", \"expected\"],\n        [\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n        ],\n    )\n    def test_sphinx_syntax_trimming(reason, expected):\n        @deprecated.sphinx.deprecated(version=\"4.5.6\", reason=reason)\n        def foo():\n            pass\n\n        with warnings.catch_warnings(record=True) as warns:\n            foo()\n&gt;       warn = warns[0]\nE       IndexError: list index out of range\n\ntests/test_sphinx.py:389: IndexError\n</pre>"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-funcbar-instead-use-bar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :func:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function . (Use bar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-functionbar-instead-use-bar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function . (Use :function:`bar` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-classbaz-instead-use-baz-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :class:<code>Baz</code> instead-Use <code>Baz</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]</pre><pre>\nreason = 'Use :class:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function . (Use Baz instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-excbaz-instead-use-baz-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :exc:<code>Baz</code> instead-Use <code>Baz</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]</pre><pre>\nreason = 'Use :exc:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function . (Use Baz instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-exceptionbaz-instead-use-baz-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :exception:<code>Baz</code> instead-Use <code>Baz</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]</pre><pre>\nreason = 'Use :exception:`Baz` instead', expected = 'Use `Baz` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function . (Use :exception:`Baz` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-methbazbar-instead-use-bazbar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :meth:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]</pre><pre>\nreason = 'Use :meth:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `Baz.bar` instead' in 'Call to deprecated function . (Use Baz.bar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-methodbazbar-instead-use-bazbar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :method:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]</pre><pre>\nreason = 'Use :method:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `Baz.bar` instead' in 'Call to deprecated function . (Use :method:`Baz.bar` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-pyfuncbar-instead-use-bar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function . (Use :pybar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-cppfuncbar-instead-use-bar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :cpp:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function . (Use :cppbar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-jsfuncbar-instead-use-bar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :js:func:<code>bar</code> instead-Use <code>bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]</pre><pre>\nreason = 'Use :js:func:`bar` instead', expected = 'Use `bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function . (Use :jsbar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-funcpkgmodbar-instead-use-pkgmodbar-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :func:<code>~pkg.mod.bar</code> instead-Use <code>~pkg.mod.bar</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]</pre><pre>\nreason = 'Use :func:`~pkg.mod.bar` instead'\nexpected = 'Use `~pkg.mod.bar` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `~pkg.mod.bar` instead' in 'Call to deprecated function . (Use pkg.mod.bar instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-rinstead-use-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :r:<code>instead-Use</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`` instead-Use `` instead]</pre><pre>\nreason = 'Use :r:`` instead', expected = 'Use `` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `` instead' in 'Call to deprecated function . (Use :r:`` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-drinstead-use-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>instead-Use</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]</pre><pre>\nreason = 'Use :d:r:`` instead', expected = 'Use `` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `` instead' in 'Call to deprecated function . (Use :d:r:`` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-rfoo-instead-use-foo-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :r:<code>foo</code> instead-Use <code>foo</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]</pre><pre>\nreason = 'Use :r:`foo` instead', expected = 'Use `foo` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `foo` instead' in 'Call to deprecated function . (Use :r:`foo` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinxpytest_get_deprecated_msguse-drfoo-instead-use-foo-instead","title":"test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>foo</code> instead-Use <code>foo</code> instead]","text":"<pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]</pre><pre>\nreason = 'Use :d:r:`foo` instead', expected = 'Use `foo` instead'\n\n    @pytest.mark.parametrize(\n        \"reason, expected\",\n        [\n            # classic examples using the default domain (Python)\n            (\"Use :func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :function:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :class:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exc:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :exception:`Baz` instead\", \"Use `Baz` instead\"),\n            (\"Use :meth:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            (\"Use :method:`Baz.bar` instead\", \"Use `Baz.bar` instead\"),\n            # other examples using a domain :\n            (\"Use :py:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :cpp:func:`bar` instead\", \"Use `bar` instead\"),\n            (\"Use :js:func:`bar` instead\", \"Use `bar` instead\"),\n            # the reference can have special characters:\n            (\"Use :func:`~pkg.mod.bar` instead\", \"Use `~pkg.mod.bar` instead\"),\n            # edge cases:\n            (\"Use :r:`` instead\", \"Use `` instead\"),\n            (\"Use :d:r:`` instead\", \"Use `` instead\"),\n            (\"Use :r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use :d:r:`foo` instead\", \"Use `foo` instead\"),\n            (\"Use r:`bad` instead\", \"Use r:`bad` instead\"),\n            (\"Use ::`bad` instead\", \"Use ::`bad` instead\"),\n            (\"Use :::`bad` instead\", \"Use :::`bad` instead\"),\n        ],\n    )\n    def test_get_deprecated_msg(reason, expected):\n        adapter = deprecated.sphinx.SphinxAdapter(\"deprecated\", reason=reason, version=\"1\")\n        actual = adapter.get_deprecated_msg(lambda: None, None)\n&gt;       assert expected in actual\nE       AssertionError: assert 'Use `foo` instead' in 'Call to deprecated function . (Use :d:r:`foo` instead) -- Deprecated since version 1.'\n\ntests/test_sphinx.py:424: AssertionError"},{"location":"analysis_baseline_deprecated/#test_sphinx_metaclasspytest_with_init","title":"test_sphinx_metaclass.py::test_with_init","text":"<pre>test_sphinx_metaclass.py::test_with_init</pre><pre>\ndef test_with_init():\n        @deprecated.classic.deprecated\n&gt;       class MyClass(object):\n\ntests/test_sphinx_metaclass.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_sphinx_metaclasspytest_with_new","title":"test_sphinx_metaclass.py::test_with_new","text":"<pre>test_sphinx_metaclass.py::test_with_new</pre><pre>\ndef test_with_new():\n        @deprecated.classic.deprecated\n&gt;       class MyClass(object):\n\ntests/test_sphinx_metaclass.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_sphinx_metaclasspytest_with_metaclass","title":"test_sphinx_metaclass.py::test_with_metaclass","text":"<pre>test_sphinx_metaclass.py::test_with_metaclass</pre><pre>\ndef test_with_metaclass():\n        class Meta(type):\n            def __call__(cls, *args, **kwargs):\n                obj = super(Meta, cls).__call__(*args, **kwargs)\n                obj.c = 3.14\n                return obj\n\n        @deprecated.classic.deprecated\n&gt;       class MyClass(with_metaclass(Meta)):\n\ntests/test_sphinx_metaclass.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#test_sphinx_metaclasspytest_with_singleton_metaclass","title":"test_sphinx_metaclass.py::test_with_singleton_metaclass","text":"<pre>test_sphinx_metaclass.py::test_with_singleton_metaclass</pre><pre>\ndef test_with_singleton_metaclass():\n        class Singleton(type):\n            _instances = {}\n\n            def __call__(cls, *args, **kwargs):\n                if cls not in cls._instances:\n                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n                return cls._instances[cls]\n\n        @deprecated.classic.deprecated\n&gt;       class MyClass(with_metaclass(Singleton)):\n\ntests/test_sphinx_metaclass.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (.MyClass'&gt;,)\nkwargs = {}\n\n    def deprecated(*args, **kwargs):\n        \"\"\"\n        This is a decorator which can be used to mark functions\n        as deprecated. It will result in a warning being emitted\n        when the function is used.\n\n        **Classic usage:**\n\n        To use this, decorate your deprecated function with **@deprecated** decorator:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated\n           def some_old_function(x, y):\n               return x + y\n\n        You can also decorate a class or a method:\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           class SomeClass(object):\n               @deprecated\n               def some_old_method(self, x, y):\n                   return x + y\n\n\n           @deprecated\n           class SomeOldClass(object):\n               pass\n\n        You can give a *reason* message to help the developer to choose another function/class,\n        and a *version* number to specify the starting version number of the deprecation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(reason=\"use another function\", version='1.2.0')\n           def some_old_function(x, y):\n               return x + y\n\n        The *category* keyword argument allow you to specify the deprecation warning class of your choice.\n        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,\n        :exc:`PendingDeprecationWarning` or a custom subclass.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(category=PendingDeprecationWarning)\n           def some_old_function(x, y):\n               return x + y\n\n        The *action* keyword argument allow you to locally change the warning filtering.\n        *action* can be one of \"error\", \"ignore\", \"always\", \"default\", \"module\", or \"once\".\n        If ``None``, empty or missing, the the global filtering mechanism is used.\n        See: `The Warnings Filter`_ in the Python documentation.\n\n        .. code-block:: python\n\n           from deprecated import deprecated\n\n\n           @deprecated(action=\"error\")\n           def some_old_function(x, y):\n               return x + y\n\n        \"\"\"\n&gt;       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\nE       NameError: name 'types' is not defined\n\ndeprecated/classic.py:248: NameError"},{"location":"analysis_baseline_deprecated/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/deprecated/classic.py b/deprecated/classic.py\nindex fc9af25..273dcec 100644\n--- a/deprecated/classic.py\n+++ b/deprecated/classic.py\n@@ -119,7 +119,21 @@ class ClassicAdapter(wrapt.AdapterFactory):\n\n         :return: The warning message.\n         \"\"\"\n-        pass\n+        if instance is None:\n+            if inspect.isclass(wrapped):\n+                fmt = \"Call to deprecated class {name}.\"\n+            else:\n+                fmt = \"Call to deprecated function {name}.\"\n+        else:\n+            if inspect.isclass(instance):\n+                fmt = \"Call to deprecated class method {name}.\"\n+            else:\n+                fmt = \"Call to deprecated method {name}.\"\n+        if self.reason:\n+            fmt += \" ({reason})\"\n+        if self.version:\n+            fmt += \" -- Deprecated since version {version}.\"\n+        return fmt.format(name=wrapped.__name__, reason=self.reason, version=self.version)\n\n     def __call__(self, wrapped):\n         \"\"\"\n@@ -231,4 +245,9 @@ def deprecated(*args, **kwargs):\n            return x + y\n\n     \"\"\"\n-    pass\n+    if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):\n+        return ClassicAdapter()(args[0])\n+    else:\n+        def wrapper(wrapped):\n+            return ClassicAdapter(**kwargs)(wrapped)\n+        return wrapper\ndiff --git a/deprecated/sphinx.py b/deprecated/sphinx.py\nindex 6daf81f..d91c375 100644\n--- a/deprecated/sphinx.py\n+++ b/deprecated/sphinx.py\n@@ -133,7 +133,13 @@ class SphinxAdapter(ClassicAdapter):\n            Strip Sphinx cross-referencing syntax from warning message.\n\n         \"\"\"\n-        pass\n+        # Get the original deprecation message\n+        message = super(SphinxAdapter, self).get_deprecated_msg(wrapped, instance)\n+        \n+        # Strip Sphinx cross-referencing syntax\n+        message = re.sub(r':(?:class|func|meth|attr|obj|exc|data|const|mod):`~?([^`]+)`', r'\\1', message)\n+        \n+        return message\n\n\n def versionadded(reason='', version='', line_length=70):\n@@ -157,7 +163,7 @@ def versionadded(reason='', version='', line_length=70):\n\n     :return: the decorated function.\n     \"\"\"\n-    pass\n+    return SphinxAdapter('versionadded', reason=reason, version=version, line_length=line_length)\n\n\n def versionchanged(reason='', version='', line_length=70):\n@@ -180,7 +186,7 @@ def versionchanged(reason='', version='', line_length=70):\n\n     :return: the decorated function.\n     \"\"\"\n-    pass\n+    return SphinxAdapter('versionchanged', reason=reason, version=version, line_length=line_length)\n\n\n def deprecated(reason='', version='', line_length=70, **kwargs):\n@@ -218,4 +224,4 @@ def deprecated(reason='', version='', line_length=70, **kwargs):\n     .. versionchanged:: 1.2.13\n        Change the signature of the decorator to reflect the valid use cases.\n     \"\"\"\n-    pass\n+    return SphinxAdapter('deprecated', reason=reason, version=version, line_length=line_length, **kwargs)\n</code></pre>"},{"location":"analysis_baseline_imapclient/","title":"Analysis baseline imapclient","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_imapclient/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_imapclient/#repository-imapclient","title":"Repository: imapclient","text":""},{"location":"analysis_baseline_imapclient/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count total 0 collected 0 passed 0"},{"location":"analysis_baseline_imapclient/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_imapclient/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/imapclient/config.py b/imapclient/config.py\nindex f098591..43fc51c 100644\n--- a/imapclient/config.py\n+++ b/imapclient/config.py\n@@ -14,7 +14,25 @@ def parse_config_file(filename: str) -&gt;argparse.Namespace:\n\n     Used by livetest.py and interact.py\n     \"\"\"\n-    pass\n+    config = configparser.ConfigParser()\n+    config.read(filename)\n+\n+    if 'DEFAULT' not in config:\n+        raise ValueError(f\"Config file {filename} must have a DEFAULT section\")\n+\n+    ns = argparse.Namespace()\n+    for key, value in config['DEFAULT'].items():\n+        setattr(ns, key, value)\n+\n+    # Convert certain values to appropriate types\n+    if hasattr(ns, 'port'):\n+        ns.port = int(ns.port)\n+    if hasattr(ns, 'ssl'):\n+        ns.ssl = config['DEFAULT'].getboolean('ssl')\n+    if hasattr(ns, 'timeout'):\n+        ns.timeout = float(ns.timeout)\n+\n+    return ns\n\n\n T = TypeVar('T')\ndiff --git a/imapclient/datetime_util.py b/imapclient/datetime_util.py\nindex 57a44c4..6533952 100644\n--- a/imapclient/datetime_util.py\n+++ b/imapclient/datetime_util.py\n@@ -14,7 +14,19 @@ def parse_to_datetime(timestamp: bytes, normalise: bool=True) -&gt;datetime:\n     If normalise is False, then the returned datetime will be\n     unadjusted but will contain timezone information as per the input.\n     \"\"\"\n-    pass\n+    if isinstance(timestamp, bytes):\n+        timestamp = timestamp.decode('ascii')\n+    \n+    tt = parsedate_tz(timestamp)\n+    if tt is None:\n+        raise ValueError(\"Could not parse datetime string: %r\" % timestamp)\n+\n+    tz = tt[-1]\n+    dt = datetime(*tt[:6], tzinfo=FixedOffset(tz) if tz else None)\n+\n+    if normalise:\n+        return dt.astimezone().replace(tzinfo=None)\n+    return dt\n\n\n def datetime_to_INTERNALDATE(dt: datetime) -&gt;str:\n@@ -23,7 +35,10 @@ def datetime_to_INTERNALDATE(dt: datetime) -&gt;str:\n     If timezone information is missing the current system\n     timezone is used.\n     \"\"\"\n-    pass\n+    if dt.tzinfo is None:\n+        dt = dt.astimezone()\n+    \n+    return dt.strftime(\"%d-%b-%Y %H:%M:%S %z\")\n\n\n _rfc822_dotted_time = re.compile(\n@@ -32,4 +47,6 @@ _rfc822_dotted_time = re.compile(\n\n def format_criteria_date(dt: datetime) -&gt;bytes:\n     \"\"\"Format a date or datetime instance for use in IMAP search criteria.\"\"\"\n-    pass\n+    if isinstance(dt, datetime):\n+        dt = dt.date()\n+    return dt.strftime(\"%d-%b-%Y\").encode('ascii')\ndiff --git a/imapclient/fixed_offset.py b/imapclient/fixed_offset.py\nindex b9e7df9..33e7b01 100644\n--- a/imapclient/fixed_offset.py\n+++ b/imapclient/fixed_offset.py\n@@ -23,4 +23,8 @@ class FixedOffset(datetime.tzinfo):\n         \"\"\"Return a FixedOffset instance for the current working timezone and\n         DST conditions.\n         \"\"\"\n-        pass\n+        if time.daylight:\n+            offset = time.altzone\n+        else:\n+            offset = time.timezone\n+        return cls(-offset // 60)\ndiff --git a/imapclient/imap_utf7.py b/imapclient/imap_utf7.py\nindex 7a795b2..a2876fc 100644\n--- a/imapclient/imap_utf7.py\n+++ b/imapclient/imap_utf7.py\n@@ -1,4 +1,5 @@\n import binascii\n+import base64\n from typing import List, Union\n\n\n@@ -8,7 +9,27 @@ def encode(s: Union[str, bytes]) -&gt;bytes:\n     Input is unicode; output is bytes (Python 3) or str (Python 2). If\n     non-unicode input is provided, the input is returned unchanged.\n     \"\"\"\n-    pass\n+    if isinstance(s, bytes):\n+        return s\n+    if not isinstance(s, str):\n+        raise ValueError(\"Input must be str or bytes\")\n+    \n+    result = bytearray()\n+    utf7_buffer = bytearray()\n+    \n+    for char in s:\n+        if ord(char) in range(0x20, 0x7f) and char != '&amp;':\n+            if utf7_buffer:\n+                result.extend(b'&amp;' + base64.b64encode(utf7_buffer).rstrip(b'=').replace(b'/', b',') + b'-')\n+                utf7_buffer = bytearray()\n+            result.extend(char.encode('ascii'))\n+        else:\n+            utf7_buffer.extend(char.encode('utf-16be'))\n+    \n+    if utf7_buffer:\n+        result.extend(b'&amp;' + base64.b64encode(utf7_buffer).rstrip(b'=').replace(b'/', b',') + b'-')\n+    \n+    return bytes(result)\n\n\n AMPERSAND_ORD = ord('&amp;')\n@@ -22,4 +43,33 @@ def decode(s: Union[bytes, str]) -&gt;str:\n     unicode. If non-bytes/str input is provided, the input is returned\n     unchanged.\n     \"\"\"\n-    pass\n+    if isinstance(s, str):\n+        s = s.encode('ascii')\n+    if not isinstance(s, bytes):\n+        raise ValueError(\"Input must be str or bytes\")\n+    \n+    result = []\n+    utf7_buffer = bytearray()\n+    in_utf7 = False\n+    \n+    for byte in s:\n+        if in_utf7:\n+            if byte == DASH_ORD:\n+                if utf7_buffer:\n+                    utf16_bytes = base64.b64decode(utf7_buffer.replace(b',', b'/') + b'===')\n+                    result.append(utf16_bytes.decode('utf-16be'))\n+                in_utf7 = False\n+                utf7_buffer = bytearray()\n+            elif byte in (AMPERSAND_ORD, DASH_ORD):\n+                utf7_buffer.append(byte)\n+            else:\n+                utf7_buffer.append(byte)\n+        elif byte == AMPERSAND_ORD:\n+            in_utf7 = True\n+        else:\n+            result.append(chr(byte))\n+    \n+    if in_utf7:\n+        raise ValueError(\"Invalid IMAP UTF-7 encoding\")\n+    \n+    return ''.join(result)\ndiff --git a/imapclient/imapclient.py b/imapclient/imapclient.py\nindex 1b399f1..c2fd28c 100644\n--- a/imapclient/imapclient.py\n+++ b/imapclient/imapclient.py\n@@ -239,7 +239,7 @@ class IMAPClient:\n            This includes reading from and writing to the socket,\n            as they are likely to break internal bookkeeping of messages.\n         \"\"\"\n-        pass\n+        return self._imap.sock\n\n     @require_capability('STARTTLS')\n     def starttls(self, ssl_context=None):\n@@ -259,13 +259,34 @@ class IMAPClient:\n         Raises :py:exc:`AbortError` if the server does not support STARTTLS\n         or an SSL connection is already established.\n         \"\"\"\n-        pass\n+        if self._starttls_done:\n+            raise self.AbortError('STARTTLS has already been called')\n+        \n+        if ssl_context is None:\n+            ssl_context = ssl_lib.create_default_context()\n+        \n+        typ, data = self._imap._simple_command('STARTTLS')\n+        self._checkok('starttls', typ, data)\n+        \n+        self._imap.sock = ssl_context.wrap_socket(self._imap.sock,\n+                                                  server_hostname=self.host)\n+        self._imap.file = self._imap.sock.makefile('rb')\n+        self._starttls_done = True\n+        \n+        # Reissue CAPABILITY command after STARTTLS\n+        self._cached_capabilities = None\n+        self.capabilities()\n\n     def login(self, username: str, password: str):\n         \"\"\"Login using *username* and *password*, returning the\n         server response.\n         \"\"\"\n-        pass\n+        try:\n+            typ, data = self._imap.login(username, password)\n+            self._checkok('login', typ, data)\n+            return data[0].decode()\n+        except imaplib.IMAP4.error as e:\n+            raise self.Error(f'Login failed: {str(e)}')\n\n     def oauth2_login(self, user: str, access_token: str, mech: str=\n         'XOAUTH2', vendor: Optional[str]=None):\n@@ -274,7 +295,17 @@ class IMAPClient:\n         Gmail and Yahoo both support the 'XOAUTH2' mechanism, but Yahoo requires\n         the 'vendor' portion in the payload.\n         \"\"\"\n-        pass\n+        auth_string = f'user={user}\\1auth=Bearer {access_token}\\1'\n+        if vendor:\n+            auth_string += f'\\1vendor={vendor}'\n+        auth_string += '\\1\\1'\n+\n+        try:\n+            typ, data = self._imap.authenticate(mech, lambda x: auth_string)\n+            self._checkok('oauth2_login', typ, data)\n+            return data[0].decode()\n+        except imaplib.IMAP4.error as e:\n+            raise self.Error(f'OAuth2 login failed: {str(e)}')\n\n     def oauthbearer_login(self, identity, access_token):\n         \"\"\"Authenticate using the OAUTHBEARER method.\ndiff --git a/imapclient/response_parser.py b/imapclient/response_parser.py\nindex f632411..e8b489d 100644\n--- a/imapclient/response_parser.py\n+++ b/imapclient/response_parser.py\n@@ -22,7 +22,19 @@ def parse_response(data: List[bytes]) -&gt;Tuple[_Atom, ...]:\n\n     Returns nested tuples of appropriately typed objects.\n     \"\"\"\n-    pass\n+    lexer = TokenSource(data)\n+    return tuple(_parse_tokens(lexer))\n+\n+def _parse_tokens(lexer: TokenSource) -&gt;Iterator[_Atom]:\n+    for token in lexer:\n+        if token == b'(':\n+            yield tuple(_parse_tokens(lexer))\n+        elif token == b')':\n+            return\n+        elif isinstance(token, bytes):\n+            yield token.decode('ascii')\n+        else:\n+            yield token\n\n\n _msg_id_pattern = re.compile('(\\\\d+(?: +\\\\d+)*)')\n@@ -39,7 +51,17 @@ def parse_message_list(data: List[Union[bytes, str]]) -&gt;SearchIds:\n     attribute which contains the MODSEQ response (if returned by the\n     server).\n     \"\"\"\n-    pass\n+    data = [item.decode('ascii') if isinstance(item, bytes) else item for item in data]\n+    data = ' '.join(data)\n+    \n+    modseq = None\n+    if 'MODSEQ' in data:\n+        modseq_index = data.index('MODSEQ')\n+        modseq = int(data[modseq_index + 1])\n+        data = data[:modseq_index]\n+    \n+    ids = [int(num) for num in _msg_id_pattern.findall(data)]\n+    return SearchIds(ids, modseq)\n\n\n _ParseFetchResponseInnerDict = Dict[bytes, Optional[Union[datetime.datetime,\n@@ -53,4 +75,62 @@ def parse_fetch_response(text: List[bytes], normalise_times: bool=True,\n     Returns a dictionary, keyed by message ID. Each value a dictionary\n     keyed by FETCH field type (eg.\"RFC822\").\n     \"\"\"\n-    pass\n+    response = defaultdict(dict)\n+    lexer = TokenSource(text)\n+\n+    while True:\n+        try:\n+            msg_id = int(next(lexer))\n+        except StopIteration:\n+            break\n+\n+        if next(lexer) != b'(':\n+            raise ProtocolError('Expected \"(\" in FETCH response')\n+\n+        for key, value in _parse_fetch_pairs(lexer, normalise_times):\n+            if uid_is_key and key == b'UID':\n+                msg_id = value\n+            else:\n+                response[msg_id][key] = value\n+\n+        if next(lexer) != b')':\n+            raise ProtocolError('Expected \")\" in FETCH response')\n+\n+    return response\n+\n+def _parse_fetch_pairs(lexer: TokenSource, normalise_times: bool) -&gt;Iterator[Tuple[bytes, Union[datetime.datetime, int, BodyData, Envelope, _Atom]]]:\n+    while True:\n+        try:\n+            key = next(lexer)\n+        except StopIteration:\n+            return\n+\n+        if key == b')':\n+            lexer.push(key)\n+            return\n+\n+        value = _parse_fetch_value(lexer, key, normalise_times)\n+        yield key, value\n+\n+def _parse_fetch_value(lexer: TokenSource, key: bytes, normalise_times: bool) -&gt;Union[datetime.datetime, int, BodyData, Envelope, _Atom]:\n+    if key in (b'INTERNALDATE', b'ENVELOPE'):\n+        value = next(lexer)\n+        if key == b'INTERNALDATE' and normalise_times:\n+            return parse_to_datetime(value.decode('ascii'))\n+        elif key == b'ENVELOPE':\n+            return Envelope(*parse_response(value))\n+    elif key == b'BODY' and next(lexer) == b'[':\n+        section = b''\n+        while True:\n+            token = next(lexer)\n+            if token == b']':\n+                break\n+            section += token\n+        next(lexer)  # Consume the space\n+        value = next(lexer)\n+        return BodyData(section, value)\n+    else:\n+        value = next(lexer)\n+        if isinstance(value, int):\n+            return value\n+        return value.decode('ascii')\n</code></pre>"},{"location":"analysis_baseline_jinja/","title":"Analysis baseline jinja","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_jinja/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_jinja/#repository-jinja","title":"Repository: jinja","text":""},{"location":"analysis_baseline_jinja/#failed-to-run-pytests","title":"Failed to run pytests","text":"<pre><code>ImportError while loading conftest '/testbed/tests/conftest.py'.\ntests/conftest.py:5: in &lt;module&gt;\n    from jinja2 import loaders\nsrc/jinja2/__init__.py:9: in &lt;module&gt;\n    from .environment import Environment as Environment\nsrc/jinja2/environment.py:14: in &lt;module&gt;\n    from . import nodes\nsrc/jinja2/nodes.py:808: in &lt;module&gt;\n    NodeType.__new__ = staticmethod(_failing_new)\nE   NameError: name '_failing_new' is not defined\n</code></pre>"},{"location":"analysis_baseline_jinja/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/src/jinja2/bccache.py b/src/jinja2/bccache.py\nindex ae575a3..7417030 100644\n--- a/src/jinja2/bccache.py\n+++ b/src/jinja2/bccache.py\n@@ -47,23 +47,31 @@ class Bucket:\n\n     def reset(self) -&gt;None:\n         \"\"\"Resets the bucket (unloads the bytecode).\"\"\"\n-        pass\n+        self.code = None\n\n     def load_bytecode(self, f: t.BinaryIO) -&gt;None:\n         \"\"\"Loads bytecode from a file or file like object.\"\"\"\n-        pass\n+        code = marshal.load(f)\n+        if isinstance(code, CodeType):\n+            self.code = code\n\n     def write_bytecode(self, f: t.IO[bytes]) -&gt;None:\n         \"\"\"Dump the bytecode into the file or file like object passed.\"\"\"\n-        pass\n+        if self.code is not None:\n+            marshal.dump(self.code, f)\n\n     def bytecode_from_string(self, string: bytes) -&gt;None:\n         \"\"\"Load bytecode from bytes.\"\"\"\n-        pass\n+        f = BytesIO(string)\n+        self.load_bytecode(f)\n\n     def bytecode_to_string(self) -&gt;bytes:\n         \"\"\"Return the bytecode as bytes.\"\"\"\n-        pass\n+        if self.code is None:\n+            return b\"\"\n+        f = BytesIO()\n+        self.write_bytecode(f)\n+        return f.getvalue()\n\n\n class BytecodeCache:\n@@ -100,41 +108,43 @@ class BytecodeCache:\n         bucket.  If they are not able to find code in the cache for the\n         bucket, it must not do anything.\n         \"\"\"\n-        pass\n+        raise NotImplementedError()\n\n     def dump_bytecode(self, bucket: Bucket) -&gt;None:\n         \"\"\"Subclasses have to override this method to write the bytecode\n         from a bucket back to the cache.  If it unable to do so it must not\n         fail silently but raise an exception.\n         \"\"\"\n-        pass\n+        raise NotImplementedError()\n\n     def clear(self) -&gt;None:\n         \"\"\"Clears the cache.  This method is not used by Jinja but should be\n         implemented to allow applications to clear the bytecode cache used\n         by a particular environment.\n         \"\"\"\n-        pass\n+        raise NotImplementedError()\n\n     def get_cache_key(self, name: str, filename: t.Optional[t.Union[str]]=None\n         ) -&gt;str:\n         \"\"\"Returns the unique hash key for this template name.\"\"\"\n-        pass\n+        return sha1(f\"{name}|{filename}\".encode(\"utf-8\")).hexdigest()\n\n     def get_source_checksum(self, source: str) -&gt;str:\n         \"\"\"Returns a checksum for the source.\"\"\"\n-        pass\n+        return sha1(source.encode(\"utf-8\")).hexdigest()\n\n     def get_bucket(self, environment: 'Environment', name: str, filename: t\n         .Optional[str], source: str) -&gt;Bucket:\n         \"\"\"Return a cache bucket for the given template.  All arguments are\n         mandatory but filename may be `None`.\n         \"\"\"\n-        pass\n+        key = self.get_cache_key(name, filename)\n+        checksum = self.get_source_checksum(source)\n+        return Bucket(environment, key, checksum)\n\n     def set_bucket(self, bucket: Bucket) -&gt;None:\n         \"\"\"Put the bucket into the cache.\"\"\"\n-        pass\n+        self.dump_bytecode(bucket)\n\n\n class FileSystemBytecodeCache(BytecodeCache):\n@@ -162,6 +172,38 @@ class FileSystemBytecodeCache(BytecodeCache):\n         self.directory = directory\n         self.pattern = pattern\n\n+    def _get_default_cache_dir(self) -&gt;str:\n+        if sys.platform == 'win32':\n+            return os.path.join(tempfile.gettempdir(), 'jinja2_cache')\n+        else:\n+            return os.path.join(tempfile.gettempdir(), f'jinja2_cache_{os.getuid()}')\n+\n+    def _get_cache_filename(self, bucket: Bucket) -&gt;str:\n+        return os.path.join(self.directory, self.pattern % bucket.key)\n+\n+    def load_bytecode(self, bucket: Bucket) -&gt;None:\n+        filename = self._get_cache_filename(bucket)\n+        if os.path.exists(filename):\n+            with open(filename, 'rb') as f:\n+                bucket.load_bytecode(f)\n+\n+    def dump_bytecode(self, bucket: Bucket) -&gt;None:\n+        filename = self._get_cache_filename(bucket)\n+        try:\n+            os.makedirs(os.path.dirname(filename), exist_ok=True)\n+            with open(filename, 'wb') as f:\n+                bucket.write_bytecode(f)\n+        except OSError as e:\n+            raise OSError(f'Unable to write bytecode cache file: {e}')\n+\n+    def clear(self) -&gt;None:\n+        for filename in os.listdir(self.directory):\n+            if fnmatch.fnmatch(filename, self.pattern % '*'):\n+                try:\n+                    os.remove(os.path.join(self.directory, filename))\n+                except OSError:\n+                    pass\n+\n\n class MemcachedBytecodeCache(BytecodeCache):\n     \"\"\"This class implements a bytecode cache that uses a memcache cache for\n@@ -215,3 +257,26 @@ class MemcachedBytecodeCache(BytecodeCache):\n         self.prefix = prefix\n         self.timeout = timeout\n         self.ignore_memcache_errors = ignore_memcache_errors\n+\n+    def load_bytecode(self, bucket: Bucket) -&gt;None:\n+        try:\n+            code = self.client.get(self.prefix + bucket.key)\n+            if code is not None:\n+                bucket.bytecode_from_string(code)\n+        except Exception:\n+            if not self.ignore_memcache_errors:\n+                raise\n+\n+    def dump_bytecode(self, bucket: Bucket) -&gt;None:\n+        try:\n+            args = [self.prefix + bucket.key, bucket.bytecode_to_string()]\n+            if self.timeout is not None:\n+                args.append(self.timeout)\n+            self.client.set(*args)\n+        except Exception:\n+            if not self.ignore_memcache_errors:\n+                raise\n+\n+    def clear(self) -&gt;None:\n+        # Memcached doesn't support clearing specific keys, so this is a no-op\n+        pass\ndiff --git a/src/jinja2/compiler.py b/src/jinja2/compiler.py\nindex 32df45a..307559e 100644\n--- a/src/jinja2/compiler.py\n+++ b/src/jinja2/compiler.py\n@@ -31,12 +31,16 @@ def generate(node: nodes.Template, environment: 'Environment', name: t.\n     Optional[str], filename: t.Optional[str], stream: t.Optional[t.TextIO]=\n     None, defer_init: bool=False, optimized: bool=True) -&gt;t.Optional[str]:\n     \"\"\"Generate the python source for a node tree.\"\"\"\n-    pass\n+    codegen = CodeGenerator(environment, name, filename, stream, defer_init, optimized)\n+    codegen.visit(node)\n+    if stream is None:\n+        return codegen.stream.getvalue()\n+    return None\n\n\n def has_safe_repr(value: t.Any) -&gt;bool:\n     \"\"\"Does the node have a safe representation?\"\"\"\n-    pass\n+    return isinstance(value, (bool, int, float, str, tuple, frozenset))\n\n\n def find_undeclared(nodes: t.Iterable[nodes.Node], names: t.Iterable[str]\n@@ -44,7 +48,13 @@ def find_undeclared(nodes: t.Iterable[nodes.Node], names: t.Iterable[str]\n     \"\"\"Check if the names passed are accessed undeclared.  The return value\n     is a set of all the undeclared names from the sequence of names found.\n     \"\"\"\n-    pass\n+    visitor = UndeclaredNameVisitor(names)\n+    try:\n+        for node in nodes:\n+            visitor.visit(node)\n+    except VisitorExit:\n+        pass\n+    return visitor.undeclared\n\n\n class MacroRef:\n@@ -81,11 +91,21 @@ class Frame:\n\n     def copy(self) -&gt;'Frame':\n         \"\"\"Create a copy of the current one.\"\"\"\n-        pass\n+        rv = object.__new__(self.__class__)\n+        rv.__dict__.update(self.__dict__)\n+        rv.symbols = self.symbols.copy()\n+        return rv\n\n     def inner(self, isolated: bool=False) -&gt;'Frame':\n         \"\"\"Return an inner frame.\"\"\"\n-        pass\n+        rv = self.copy()\n+        if isolated:\n+            rv.symbols = Symbols(parent=rv.symbols)\n+        rv.block_frame = False\n+        rv.loop_frame = False\n+        rv.toplevel = False\n+        rv.rootlevel = False\n+        return rv\n\n     def soft(self) -&gt;'Frame':\n         \"\"\"Return a soft frame.  A soft frame may not be modified as\n@@ -95,7 +115,13 @@ class Frame:\n         This is only used to implement if-statements and conditional\n         expressions.\n         \"\"\"\n-        pass\n+        rv = self.copy()\n+        rv.toplevel = False\n+        rv.rootlevel = False\n+        rv.loop_frame = False\n+        rv.block_frame = False\n+        rv.soft_frame = True\n+        return rv\n     __copy__ = copy\n\n\n@@ -112,8 +138,7 @@ class DependencyFinderVisitor(NodeVisitor):\n\n     def visit_Block(self, node: nodes.Block) -&gt;None:\n         \"\"\"Stop visiting at blocks.\"\"\"\n-        pass\n-\n+        return\n\n class UndeclaredNameVisitor(NodeVisitor):\n     \"\"\"A visitor that checks if a name is accessed without being\n@@ -125,9 +150,15 @@ class UndeclaredNameVisitor(NodeVisitor):\n         self.names = set(names)\n         self.undeclared: t.Set[str] = set()\n\n+    def visit_Name(self, node: nodes.Name) -&gt;None:\n+        if node.name in self.names:\n+            self.undeclared.add(node.name)\n+            if len(self.undeclared) == len(self.names):\n+                raise VisitorExit()\n+\n     def visit_Block(self, node: nodes.Block) -&gt;None:\n         \"\"\"Stop visiting a blocks.\"\"\"\n-        pass\n+        return\n\n\n class CompilerExit(Exception):\ndiff --git a/src/jinja2/debug.py b/src/jinja2/debug.py\nindex 412f2c2..6055a20 100644\n--- a/src/jinja2/debug.py\n+++ b/src/jinja2/debug.py\n@@ -20,7 +20,25 @@ def rewrite_traceback_stack(source: t.Optional[str]=None) -&gt;BaseException:\n         known.\n     :return: The original exception with the rewritten traceback.\n     \"\"\"\n-    pass\n+    exc_type, exc_value, tb = sys.exc_info()\n+    if isinstance(exc_value, TemplateSyntaxError) and source is not None:\n+        exc_value.source = source\n+    \n+    while tb is not None:\n+        if tb.tb_frame.f_code.co_filename == '&lt;template&gt;':\n+            filename = exc_value.filename\n+            lineno = exc_value.lineno\n+            \n+            # Create a fake traceback\n+            new_tb = fake_traceback(exc_value, tb, filename, lineno)\n+            \n+            # Replace the old traceback with the new one\n+            exc_value.__traceback__ = new_tb\n+            break\n+        \n+        tb = tb.tb_next\n+    \n+    return exc_value\n\n\n def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],\n@@ -37,7 +55,37 @@ def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],\n     :param filename: The template filename.\n     :param lineno: The line number in the template source.\n     \"\"\"\n-    pass\n+    if tb is None:\n+        raise exc_value\n+\n+    locals = get_template_locals(tb.tb_frame.f_locals)\n+    globals = tb.tb_frame.f_globals\n+\n+    # Create a fake code object\n+    code = CodeType(\n+        0,                      # argcount\n+        0,                      # kwonlyargcount\n+        0,                      # nlocals\n+        0,                      # stacksize\n+        0,                      # flags\n+        b'',                    # bytecode\n+        (),                     # constants\n+        (),                     # names\n+        (),                     # varnames\n+        filename,               # filename\n+        '&lt;template&gt;',           # name\n+        lineno,                 # firstlineno\n+        b'',                    # lnotab\n+        (),                     # freevars\n+        ()                      # cellvars\n+    )\n+\n+    # Create a fake frame\n+    fake_frame = tb.tb_frame.__class__(code, globals, locals)\n+    fake_frame.f_lineno = lineno\n+\n+    # Create a new traceback object\n+    return TracebackType(None, fake_frame, fake_frame.f_lasti, fake_frame.f_lineno)\n\n\n def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt;t.Dict[str, t.Any\n@@ -45,4 +93,12 @@ def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt;t.Dict[str, t.Any\n     \"\"\"Based on the runtime locals, get the context that would be\n     available at that point in the template.\n     \"\"\"\n-    pass\n+    context = real_locals.get('context')\n+    if isinstance(context, Context):\n+        return {\n+            'context': context,\n+            'environment': context.environment,\n+            'resolver': context.environment.resolver,\n+            **context.get_all()\n+        }\n+    return {}\ndiff --git a/src/jinja2/environment.py b/src/jinja2/environment.py\nindex aae9f98..f21e599 100644\n--- a/src/jinja2/environment.py\n+++ b/src/jinja2/environment.py\n@@ -68,19 +68,28 @@ def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any\n     :param cls: Environment class to create.\n     :param args: Positional arguments passed to environment.\n     \"\"\"\n-    pass\n+    return cls(*args)\n\n\n def create_cache(size: int) -&gt;t.Optional[t.MutableMapping[t.Tuple[\n     'weakref.ref[t.Any]', str], 'Template']]:\n     \"\"\"Return the cache class for the given size.\"\"\"\n-    pass\n+    if size == 0:\n+        return None\n+    if size &lt; 0:\n+        return {}\n+    return LRUCache(size)\n\n\n def copy_cache(cache: t.Optional[t.MutableMapping[t.Any, t.Any]]) -&gt;t.Optional[\n     t.MutableMapping[t.Tuple['weakref.ref[t.Any]', str], 'Template']]:\n     \"\"\"Create an empty copy of the given cache.\"\"\"\n-    pass\n+    if cache is None:\n+        return None\n+    elif isinstance(cache, LRUCache):\n+        return LRUCache(cache.capacity)\n+    else:\n+        return {}\n\n\n def load_extensions(environment: 'Environment', extensions: t.Sequence[t.\n@@ -88,12 +97,39 @@ def load_extensions(environment: 'Environment', extensions: t.Sequence[t.\n     \"\"\"Load the extensions from the list and bind it to the environment.\n     Returns a dict of instantiated extensions.\n     \"\"\"\n-    pass\n+    result = {}\n+    for extension in extensions:\n+        if isinstance(extension, str):\n+            extension = import_string(extension)\n+        if isinstance(extension, type):\n+            extension = extension(environment)\n+        result[extension.identifier] = extension\n+    return result\n\n\n def _environment_config_check(environment: 'Environment') -&gt;'Environment':\n     \"\"\"Perform a sanity check on the environment.\"\"\"\n-    pass\n+    if not isinstance(environment.block_start_string, str):\n+        raise TypeError('block_start_string must be a string')\n+    if not isinstance(environment.block_end_string, str):\n+        raise TypeError('block_end_string must be a string')\n+    if not isinstance(environment.variable_start_string, str):\n+        raise TypeError('variable_start_string must be a string')\n+    if not isinstance(environment.variable_end_string, str):\n+        raise TypeError('variable_end_string must be a string')\n+    if not isinstance(environment.comment_start_string, str):\n+        raise TypeError('comment_start_string must be a string')\n+    if not isinstance(environment.comment_end_string, str):\n+        raise TypeError('comment_end_string must be a string')\n+    if not isinstance(environment.line_statement_prefix, (str, type(None))):\n+        raise TypeError('line_statement_prefix must be a string or None')\n+    if not isinstance(environment.line_comment_prefix, (str, type(None))):\n+        raise TypeError('line_comment_prefix must be a string or None')\n+    if not isinstance(environment.trim_blocks, bool):\n+        raise TypeError('trim_blocks must be a boolean')\n+    if not isinstance(environment.lstrip_blocks, bool):\n+        raise TypeError('lstrip_blocks must be a boolean')\n+    return environment\n\n\n class Environment:\ndiff --git a/src/jinja2/ext.py b/src/jinja2/ext.py\nindex 337f30c..9d826ca 100644\n--- a/src/jinja2/ext.py\n+++ b/src/jinja2/ext.py\n@@ -62,7 +62,10 @@ class Extension:\n\n     def bind(self, environment: Environment) -&gt;'Extension':\n         \"\"\"Create a copy of this extension bound to another environment.\"\"\"\n-        pass\n+        rv = type(self)(environment)\n+        rv.__dict__.update(self.__dict__)\n+        rv.environment = environment\n+        return rv\n\n     def preprocess(self, source: str, name: t.Optional[str], filename: t.\n         Optional[str]=None) -&gt;str:\n@@ -70,7 +73,7 @@ class Extension:\n         preprocess the source.  The `filename` is optional.  The return value\n         must be the preprocessed source.\n         \"\"\"\n-        pass\n+        return source\n\n     def filter_stream(self, stream: 'TokenStream') -&gt;t.Union['TokenStream',\n         t.Iterable['Token']]:\n@@ -79,7 +82,7 @@ class Extension:\n         :class:`~jinja2.lexer.Token`\\\\s, but it doesn't have to return a\n         :class:`~jinja2.lexer.TokenStream`.\n         \"\"\"\n-        pass\n+        return stream\n\n     def parse(self, parser: 'Parser') -&gt;t.Union[nodes.Node, t.List[nodes.Node]\n         ]:\n@@ -88,7 +91,7 @@ class Extension:\n         is the name token that matched.  This method has to return one or a\n         list of multiple nodes.\n         \"\"\"\n-        pass\n+        raise NotImplementedError(f'{self.__class__.__name__}.parse() must be implemented')\n\n     def attr(self, name: str, lineno: t.Optional[int]=None\n         ) -&gt;nodes.ExtensionAttribute:\n@@ -99,7 +102,7 @@ class Extension:\n\n             self.attr('_my_attribute', lineno=lineno)\n         \"\"\"\n-        pass\n+        return nodes.ExtensionAttribute(self.identifier, name, lineno=lineno)\n\n     def call_method(self, name: str, args: t.Optional[t.List[nodes.Expr]]=\n         None, kwargs: t.Optional[t.List[nodes.Keyword]]=None, dyn_args: t.\n@@ -108,7 +111,12 @@ class Extension:\n         \"\"\"Call a method of the extension.  This is a shortcut for\n         :meth:`attr` + :class:`jinja2.nodes.Call`.\n         \"\"\"\n-        pass\n+        if args is None:\n+            args = []\n+        if kwargs is None:\n+            kwargs = []\n+        return nodes.Call(self.attr(name, lineno=lineno), args, kwargs,\n+                          dyn_args, dyn_kwargs, lineno=lineno)\n\n\n class InternationalizationExtension(Extension):\ndiff --git a/src/jinja2/filters.py b/src/jinja2/filters.py\nindex 9498dc3..ecd27f0 100644\n--- a/src/jinja2/filters.py\n+++ b/src/jinja2/filters.py\n@@ -43,7 +43,9 @@ V = t.TypeVar('V')\n def ignore_case(value: V) -&gt;V:\n     \"\"\"For use as a postprocessor for :func:`make_attrgetter`. Converts strings\n     to lowercase and returns other types as-is.\"\"\"\n-    pass\n+    if isinstance(value, str):\n+        return value.lower()\n+    return value\n\n\n def make_attrgetter(environment: 'Environment', attribute: t.Optional[t.\n@@ -54,7 +56,21 @@ def make_attrgetter(environment: 'Environment', attribute: t.Optional[t.\n     to access attributes of attributes.  Integer parts in paths are\n     looked up as integers.\n     \"\"\"\n-    pass\n+    if attribute is None:\n+        return lambda x: x\n+    if isinstance(attribute, int):\n+        return lambda x: environment.getitem(x, attribute)\n+    if '.' not in attribute:\n+        return lambda x: environment.getattr(x, attribute, default)\n+    \n+    def getter(x):\n+        for part in attribute.split('.'):\n+            if part.isdigit():\n+                x = environment.getitem(x, int(part))\n+            else:\n+                x = environment.getattr(x, part, default)\n+        return x if postprocess is None else postprocess(x)\n+    return getter\n\n\n def make_multi_attrgetter(environment: 'Environment', attribute: t.Optional\n@@ -70,12 +86,22 @@ def make_multi_attrgetter(environment: 'Environment', attribute: t.Optional\n\n     Examples of attribute: \"attr1,attr2\", \"attr1.inner1.0,attr2.inner2.0\", etc.\n     \"\"\"\n-    pass\n+    if attribute is None:\n+        return lambda x: [x]\n+    \n+    getters = [make_attrgetter(environment, attr.strip(), postprocess)\n+               for attr in attribute.split(',')]\n+    \n+    def getter(x):\n+        return [g(x) for g in getters]\n+    return getter\n\n\n def do_forceescape(value: 't.Union[str, HasHTML]') -&gt;Markup:\n     \"\"\"Enforce HTML escaping.  This will probably double escape variables.\"\"\"\n-    pass\n+    if hasattr(value, '__html__'):\n+        value = value.__html__()\n+    return Markup(escape(str(value)))\n\n\n def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.\n@@ -95,7 +121,16 @@ def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.\n\n     .. versionadded:: 2.7\n     \"\"\"\n-    pass\n+    from urllib.parse import quote, urlencode\n+\n+    if isinstance(value, str):\n+        return quote(value, safe='/')\n+    elif isinstance(value, t.Mapping):\n+        return urlencode(value)\n+    elif isinstance(value, t.Iterable):\n+        return urlencode(list(value))\n+    else:\n+        raise TypeError(\"Expected string, mapping, or iterable\")\n\n\n @pass_eval_context\ndiff --git a/src/jinja2/idtracking.py b/src/jinja2/idtracking.py\nindex a1d69ca..44d11c4 100644\n--- a/src/jinja2/idtracking.py\n+++ b/src/jinja2/idtracking.py\n@@ -45,32 +45,39 @@ class FrameSymbolVisitor(NodeVisitor):\n     def visit_Name(self, node: nodes.Name, store_as_param: bool=False, **\n         kwargs: t.Any) -&gt;None:\n         \"\"\"All assignments to names go through this function.\"\"\"\n-        pass\n+        if node.ctx == 'store':\n+            if store_as_param:\n+                self.symbols.loads[node.name] = VAR_LOAD_PARAMETER\n+            self.symbols.stores.add(node.name)\n+        elif node.ctx == 'param':\n+            self.symbols.loads[node.name] = VAR_LOAD_PARAMETER\n\n     def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -&gt;None:\n         \"\"\"Visit assignments in the correct order.\"\"\"\n-        pass\n+        self.visit(node.node, **kwargs)\n+        self.visit(node.target, **kwargs)\n\n     def visit_For(self, node: nodes.For, **kwargs: t.Any) -&gt;None:\n         \"\"\"Visiting stops at for blocks.  However the block sequence\n         is visited as part of the outer scope.\n         \"\"\"\n-        pass\n+        self.visit(node.iter, **kwargs)\n+        self.visit(node.target, store_as_param=True, **kwargs)\n\n     def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any\n         ) -&gt;None:\n         \"\"\"Stop visiting at block assigns.\"\"\"\n-        pass\n+        self.visit(node.target, **kwargs)\n\n     def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -&gt;None:\n         \"\"\"Stop visiting at scopes.\"\"\"\n-        pass\n+        # We don't need to do anything here, as we're stopping at scopes\n\n     def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -&gt;None:\n         \"\"\"Stop visiting at blocks.\"\"\"\n-        pass\n+        # We don't need to do anything here, as we're stopping at blocks\n\n     def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any\n         ) -&gt;None:\n         \"\"\"Do not visit into overlay scopes.\"\"\"\n-        pass\n+        # We don't need to do anything here, as we're not visiting into overlay scopes\ndiff --git a/src/jinja2/lexer.py b/src/jinja2/lexer.py\nindex 2281b7e..e825327 100644\n--- a/src/jinja2/lexer.py\n+++ b/src/jinja2/lexer.py\n@@ -117,24 +117,39 @@ ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT,\n\n def describe_token(token: 'Token') -&gt;str:\n     \"\"\"Returns a description of the token.\"\"\"\n-    pass\n+    if token.type == 'name':\n+        return token.value\n+    return f'{token.type}'\n\n\n def describe_token_expr(expr: str) -&gt;str:\n     \"\"\"Like `describe_token` but for token expressions.\"\"\"\n-    pass\n+    if ':' in expr:\n+        type, value = expr.split(':', 1)\n+        if type == 'name':\n+            return value\n+        return f'{type}({value})'\n+    return expr\n\n\n def count_newlines(value: str) -&gt;int:\n     \"\"\"Count the number of newline characters in the string.  This is\n     useful for extensions that filter a stream.\n     \"\"\"\n-    pass\n+    return len(newline_re.findall(value))\n\n\n def compile_rules(environment: 'Environment') -&gt;t.List[t.Tuple[str, str]]:\n     \"\"\"Compiles all the rules from the environment into a list of rules.\"\"\"\n-    pass\n+    e = re.escape\n+    rules = [\n+        ('comment', e(environment.comment_start_string)),\n+        ('block', e(environment.block_start_string)),\n+        ('variable', e(environment.variable_start_string)),\n+        ('linestatement', e(environment.line_statement_prefix) if environment.line_statement_prefix else ''),\n+        ('linecomment', e(environment.line_comment_prefix) if environment.line_comment_prefix else ''),\n+    ]\n+    return [(k, v) for k, v in rules if v]\n\n\n class Failure:\n@@ -164,11 +179,14 @@ class Token(t.NamedTuple):\n         token type or ``'token_type:token_value'``.  This can only test\n         against string values and types.\n         \"\"\"\n-        pass\n+        if ':' in expr:\n+            type, value = expr.split(':', 1)\n+            return self.type == type and self.value == value\n+        return self.type == expr\n\n     def test_any(self, *iterable: str) -&gt;bool:\n         \"\"\"Test against multiple token expressions.\"\"\"\n-        pass\n+        return any(self.test(expr) for expr in iterable)\n\n\n class TokenStreamIterator:\n@@ -216,29 +234,35 @@ class TokenStream:\n     @property\n     def eos(self) -&gt;bool:\n         \"\"\"Are we at the end of the stream?\"\"\"\n-        pass\n+        return not bool(self)\n\n     def push(self, token: Token) -&gt;None:\n         \"\"\"Push a token back to the stream.\"\"\"\n-        pass\n+        self._pushed.append(token)\n\n     def look(self) -&gt;Token:\n         \"\"\"Look at the next token.\"\"\"\n-        pass\n+        old_token = next(self)\n+        result = self.current\n+        self.push(old_token)\n+        return result\n\n     def skip(self, n: int=1) -&gt;None:\n         \"\"\"Got n tokens ahead.\"\"\"\n-        pass\n+        for _ in range(n):\n+            next(self)\n\n     def next_if(self, expr: str) -&gt;t.Optional[Token]:\n         \"\"\"Perform the token test and return the token if it matched.\n         Otherwise the return value is `None`.\n         \"\"\"\n-        pass\n+        if self.current.test(expr):\n+            return next(self)\n+        return None\n\n     def skip_if(self, expr: str) -&gt;bool:\n         \"\"\"Like :meth:`next_if` but only returns `True` or `False`.\"\"\"\n-        pass\n+        return self.next_if(expr) is not None\n\n     def __next__(self) -&gt;Token:\n         \"\"\"Go one token ahead and return the old one.\n@@ -257,18 +281,46 @@ class TokenStream:\n\n     def close(self) -&gt;None:\n         \"\"\"Close the stream.\"\"\"\n-        pass\n+        self.closed = True\n\n     def expect(self, expr: str) -&gt;Token:\n         \"\"\"Expect a given token type and return it.  This accepts the same\n         argument as :meth:`jinja2.lexer.Token.test`.\n         \"\"\"\n-        pass\n+        if not self.current.test(expr):\n+            if ':' in expr:\n+                expr = f'{expr.split(\":\", 1)[0]} token'\n+            raise TemplateSyntaxError(\n+                f'expected {expr}', self.current.lineno,\n+                self.name, self.filename\n+            )\n+        try:\n+            return next(self)\n+        except StopIteration:\n+            raise TemplateSyntaxError('unexpected end of template',\n+                                      self.current.lineno, self.name, self.filename)\n\n\n def get_lexer(environment: 'Environment') -&gt;'Lexer':\n     \"\"\"Return a lexer which is probably cached.\"\"\"\n-    pass\n+    key = (environment.block_start_string,\n+           environment.block_end_string,\n+           environment.variable_start_string,\n+           environment.variable_end_string,\n+           environment.comment_start_string,\n+           environment.comment_end_string,\n+           environment.line_statement_prefix,\n+           environment.line_comment_prefix,\n+           environment.trim_blocks,\n+           environment.lstrip_blocks,\n+           environment.newline_sequence,\n+           environment.keep_trailing_newline)\n+\n+    if key in _lexer_cache:\n+        return _lexer_cache[key]\n+    lexer = Lexer(environment)\n+    _lexer_cache[key] = lexer\n+    return lexer\n\n\n class OptionalLStrip(tuple):\n@@ -344,12 +396,13 @@ class Lexer:\n         \"\"\"Replace all newlines with the configured sequence in strings\n         and template data.\n         \"\"\"\n-        pass\n+        return newline_re.sub(self.newline_sequence, value)\n\n     def tokenize(self, source: str, name: t.Optional[str]=None, filename: t\n         .Optional[str]=None, state: t.Optional[str]=None) -&gt;TokenStream:\n         \"\"\"Calls tokeniter + tokenize and wraps it in a token stream.\"\"\"\n-        pass\n+        stream = self.tokeniter(source, name, filename, state)\n+        return TokenStream(self.wrap(stream, name, filename), name, filename)\n\n     def wrap(self, stream: t.Iterable[t.Tuple[int, str, str]], name: t.\n         Optional[str]=None, filename: t.Optional[str]=None) -&gt;t.Iterator[Token\n@@ -357,7 +410,12 @@ class Lexer:\n         \"\"\"This is called with the stream as returned by `tokenize` and wraps\n         every token in a :class:`Token` and converts the value.\n         \"\"\"\n-        pass\n+        for lineno, token, value in stream:\n+            if token in ('linestatement_begin', 'linestatement_end'):\n+                token = 'block_begin' if token == 'linestatement_begin' else 'block_end'\n+            elif token in ('linecomment_begin', 'linecomment_end', 'linecomment'):\n+                token = 'comment'\n+            yield Token(lineno, token, value)\n\n     def tokeniter(self, source: str, name: t.Optional[str], filename: t.\n         Optional[str]=None, state: t.Optional[str]=None) -&gt;t.Iterator[t.\n@@ -369,4 +427,48 @@ class Lexer:\n             Only ``\\\\n``, ``\\\\r\\\\n`` and ``\\\\r`` are treated as line\n             breaks.\n         \"\"\"\n-        pass\n+        source = self._normalize_newlines(source)\n+        lines = source.splitlines(True)\n+        lineno = 1\n+        state = state or 'root'\n+        state_stack = [state]\n+        line = ''\n+        pos = 0\n+        len_lines = len(lines)\n+\n+        while 1:\n+            # tokenizer loop\n+            for rule in self.rules[state]:\n+                m = rule.pattern.match(line, pos)\n+                if m:\n+                    if isinstance(rule.tokens, tuple):\n+                        for idx, token in enumerate(rule.tokens):\n+                            yield lineno, token, m.group(idx + 1)\n+                    else:\n+                        yield lineno, rule.tokens, m.group()\n+                    pos = m.end()\n+                    if rule.command is not None:\n+                        cmd = rule.command\n+                        if cmd == '#pop':\n+                            state_stack.pop()\n+                            if not state_stack:\n+                                state_stack.append('root')\n+                        elif cmd == '#push':\n+                            state_stack.append(state)\n+                        else:\n+                            state_stack.append(cmd)\n+                        state = state_stack[-1]\n+                    break\n+            else:\n+                # if loop exhausted, move to next line\n+                pos = 0\n+                lineno += 1\n+                if lineno &gt; len_lines:\n+                    break\n+                line = lines[lineno - 1]\n+\n+        if state != 'root':\n+            raise TemplateSyntaxError('Unexpected end of template',\n+                                      lineno, name, filename)\n+\n+        yield lineno, 'eof', ''\ndiff --git a/src/jinja2/meta.py b/src/jinja2/meta.py\nindex 37016c7..2beb63e 100644\n--- a/src/jinja2/meta.py\n+++ b/src/jinja2/meta.py\n@@ -22,7 +22,7 @@ class TrackingCodeGenerator(CodeGenerator):\n\n     def enter_frame(self, frame: Frame) -&gt;None:\n         \"\"\"Remember all undeclared identifiers.\"\"\"\n-        pass\n+        self.undeclared_identifiers.update(frame.identifiers.undeclared)\n\n\n def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:\n@@ -44,7 +44,9 @@ def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:\n        :exc:`TemplateAssertionError` during compilation and as a matter of\n        fact this function can currently raise that exception as well.\n     \"\"\"\n-    pass\n+    codegen = TrackingCodeGenerator(ast.environment)\n+    codegen.visit(ast)\n+    return codegen.undeclared_identifiers\n\n\n _ref_types = nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include\n@@ -68,4 +70,17 @@ def find_referenced_templates(ast: nodes.Template) -&gt;t.Iterator[t.Optional[str]\n     This function is useful for dependency tracking.  For example if you want\n     to rebuild parts of the website after a layout template has changed.\n     \"\"\"\n-    pass\n+    for node in ast.find_all(_ref_types):\n+        if isinstance(node, nodes.Extends):\n+            if isinstance(node.template, nodes.Const):\n+                yield node.template.value\n+            else:\n+                yield None\n+        elif isinstance(node, nodes.Include):\n+            if isinstance(node.template, nodes.Const):\n+                yield node.template.value\n+            else:\n+                yield None\n+        elif isinstance(node, (nodes.Import, nodes.FromImport)):\n+            if isinstance(node.template, nodes.Const):\n+                yield node.template.value\ndiff --git a/src/jinja2/nativetypes.py b/src/jinja2/nativetypes.py\nindex 9eae726..da64b12 100644\n--- a/src/jinja2/nativetypes.py\n+++ b/src/jinja2/nativetypes.py\n@@ -1,4 +1,5 @@\n import typing as t\n+import sys\n from ast import literal_eval\n from ast import parse\n from itertools import chain\n@@ -21,7 +22,16 @@ def native_concat(values: t.Iterable[t.Any]) -&gt;t.Optional[t.Any]:\n\n     :param values: Iterable of outputs to concatenate.\n     \"\"\"\n-    pass\n+    result = list(values)\n+    if not result:\n+        return None\n+    if len(result) == 1:\n+        return result[0]\n+    \n+    try:\n+        return literal_eval(\"\".join(str(v) for v in result))\n+    except (ValueError, SyntaxError):\n+        return \"\".join(str(v) for v in result)\n\n\n class NativeCodeGenerator(CodeGenerator):\n@@ -46,7 +56,12 @@ class NativeTemplate(Template):\n         with :func:`ast.literal_eval`, the parsed value is returned.\n         Otherwise, the string is returned.\n         \"\"\"\n-        pass\n+        ctx = self.new_context(dict(*args, **kwargs))\n+        try:\n+            return self.environment.concat(self.root_render_func(ctx))\n+        except Exception:\n+            exc_info = sys.exc_info()\n+            return self.environment.handle_exception(exc_info, True)\n\n\n NativeEnvironment.template_class = NativeTemplate\ndiff --git a/src/jinja2/nodes.py b/src/jinja2/nodes.py\nindex 4ec1d17..416aa80 100644\n--- a/src/jinja2/nodes.py\n+++ b/src/jinja2/nodes.py\n@@ -107,7 +107,9 @@ class Node(metaclass=NodeType):\n         parameter or to exclude some using the `exclude` parameter.  Both\n         should be sets or tuples of field names.\n         \"\"\"\n-        pass\n+        for name in self.fields:\n+            if (exclude is None or name not in exclude) and (only is None or name in only):\n+                yield name, getattr(self, name)\n\n     def iter_child_nodes(self, exclude: t.Optional[t.Container[str]]=None,\n         only: t.Optional[t.Container[str]]=None) -&gt;t.Iterator['Node']:\n@@ -115,20 +117,35 @@ class Node(metaclass=NodeType):\n         over all fields and yields the values of they are nodes.  If the value\n         of a field is a list all the nodes in that list are returned.\n         \"\"\"\n-        pass\n+        for _, field in self.iter_fields(exclude, only):\n+            if isinstance(field, Node):\n+                yield field\n+            elif isinstance(field, list):\n+                for item in field:\n+                    if isinstance(item, Node):\n+                        yield item\n\n     def find(self, node_type: t.Type[_NodeBound]) -&gt;t.Optional[_NodeBound]:\n         \"\"\"Find the first node of a given type.  If no such node exists the\n         return value is `None`.\n         \"\"\"\n-        pass\n+        for child in self.iter_child_nodes():\n+            if isinstance(child, node_type):\n+                return child\n+            result = child.find(node_type)\n+            if result is not None:\n+                return result\n+        return None\n\n     def find_all(self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.\n         Type[_NodeBound], ...]]) -&gt;t.Iterator[_NodeBound]:\n         \"\"\"Find all the nodes of a given type.  If the type is a tuple,\n         the check is performed for any of the tuple items.\n         \"\"\"\n-        pass\n+        for child in self.iter_child_nodes():\n+            if isinstance(child, node_type):\n+                yield child\n+            yield from child.find_all(node_type)\n\n     def set_ctx(self, ctx: str) -&gt;'Node':\n         \"\"\"Reset the context of a node and all child nodes.  Per default the\n@@ -136,15 +153,26 @@ class Node(metaclass=NodeType):\n         most common one.  This method is used in the parser to set assignment\n         targets and other nodes to a store context.\n         \"\"\"\n-        pass\n+        if 'ctx' in self.fields:\n+            self.ctx = ctx\n+        for child in self.iter_child_nodes():\n+            child.set_ctx(ctx)\n+        return self\n\n     def set_lineno(self, lineno: int, override: bool=False) -&gt;'Node':\n         \"\"\"Set the line numbers of the node and children.\"\"\"\n-        pass\n+        if not hasattr(self, 'lineno') or override:\n+            self.lineno = lineno\n+        for child in self.iter_child_nodes():\n+            child.set_lineno(lineno, override)\n+        return self\n\n     def set_environment(self, environment: 'Environment') -&gt;'Node':\n         \"\"\"Set the environment for all nodes.\"\"\"\n-        pass\n+        self.environment = environment\n+        for child in self.iter_child_nodes():\n+            child.set_environment(environment)\n+        return self\n\n     def __eq__(self, other: t.Any) -&gt;bool:\n         if type(self) is not type(other):\n@@ -340,11 +368,11 @@ class Expr(Node):\n         .. versionchanged:: 2.4\n            the `eval_ctx` parameter was added.\n         \"\"\"\n-        pass\n+        raise Impossible()\n\n     def can_assign(self) -&gt;bool:\n         \"\"\"Check if it's possible to assign something to this node.\"\"\"\n-        pass\n+        return False\n\n\n class BinExpr(Expr):\n@@ -405,7 +433,17 @@ class Const(Literal):\n         constant value in the generated code, otherwise it will raise\n         an `Impossible` exception.\n         \"\"\"\n-        pass\n+        if isinstance(value, (bool, int, float, str, type(None))):\n+            return cls(value, lineno=lineno, environment=environment)\n+        elif isinstance(value, (list, tuple)):\n+            items = [cls.from_untrusted(item, lineno, environment) for item in value]\n+            return cls(type(value)(item.value for item in items), lineno=lineno, environment=environment)\n+        elif isinstance(value, dict):\n+            items = {cls.from_untrusted(k, lineno, environment).value: \n+                     cls.from_untrusted(v, lineno, environment).value \n+                     for k, v in value.items()}\n+            return cls(items, lineno=lineno, environment=environment)\n+        raise Impossible(f\"Cannot convert {type(value)} to Const\")\n\n\n class TemplateData(Literal):\ndiff --git a/src/jinja2/optimizer.py b/src/jinja2/optimizer.py\nindex 53d50e4..3136cb0 100644\n--- a/src/jinja2/optimizer.py\n+++ b/src/jinja2/optimizer.py\n@@ -17,10 +17,68 @@ if t.TYPE_CHECKING:\n def optimize(node: nodes.Node, environment: 'Environment') -&gt;nodes.Node:\n     \"\"\"The context hint can be used to perform an static optimization\n     based on the context given.\"\"\"\n-    pass\n+    optimizer = Optimizer(environment)\n+    return optimizer.visit(node)\n\n\n class Optimizer(NodeTransformer):\n\n     def __init__(self, environment: 't.Optional[Environment]') -&gt;None:\n         self.environment = environment\n+\n+    def visit_Const(self, node: nodes.Const) -&gt;nodes.Node:\n+        \"\"\"Optimize constant nodes.\"\"\"\n+        return node\n+\n+    def visit_List(self, node: nodes.List) -&gt;nodes.Node:\n+        \"\"\"Optimize list nodes.\"\"\"\n+        node.items = [self.visit(item) for item in node.items]\n+        return node\n+\n+    def visit_Dict(self, node: nodes.Dict) -&gt;nodes.Node:\n+        \"\"\"Optimize dict nodes.\"\"\"\n+        node.items = [(self.visit(key), self.visit(value)) for key, value in node.items]\n+        return node\n+\n+    def visit_Getitem(self, node: nodes.Getitem) -&gt;nodes.Node:\n+        \"\"\"Optimize getitem nodes.\"\"\"\n+        node.node = self.visit(node.node)\n+        node.arg = self.visit(node.arg)\n+        return node\n+\n+    def visit_Getattr(self, node: nodes.Getattr) -&gt;nodes.Node:\n+        \"\"\"Optimize getattr nodes.\"\"\"\n+        node.node = self.visit(node.node)\n+        return node\n+\n+    def visit_Call(self, node: nodes.Call) -&gt;nodes.Node:\n+        \"\"\"Optimize call nodes.\"\"\"\n+        node.node = self.visit(node.node)\n+        node.args = [self.visit(arg) for arg in node.args]\n+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]\n+        return node\n+\n+    def visit_Filter(self, node: nodes.Filter) -&gt;nodes.Node:\n+        \"\"\"Optimize filter nodes.\"\"\"\n+        node.node = self.visit(node.node)\n+        node.args = [self.visit(arg) for arg in node.args]\n+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]\n+        return node\n+\n+    def visit_Test(self, node: nodes.Test) -&gt;nodes.Node:\n+        \"\"\"Optimize test nodes.\"\"\"\n+        node.node = self.visit(node.node)\n+        node.args = [self.visit(arg) for arg in node.args]\n+        node.kwargs = [(key, self.visit(value)) for key, value in node.kwargs]\n+        return node\n+\n+    def visit_CondExpr(self, node: nodes.CondExpr) -&gt;nodes.Node:\n+        \"\"\"Optimize conditional expression nodes.\"\"\"\n+        node.test = self.visit(node.test)\n+        node.expr1 = self.visit(node.expr1)\n+        node.expr2 = self.visit(node.expr2)\n+        return node\n+\n+    def generic_visit(self, node: nodes.Node) -&gt;nodes.Node:\n+        \"\"\"Visit a node.\"\"\"\n+        return super().generic_visit(node)\ndiff --git a/src/jinja2/parser.py b/src/jinja2/parser.py\nindex 05ce33d..1a2147c 100644\n--- a/src/jinja2/parser.py\n+++ b/src/jinja2/parser.py\n@@ -47,7 +47,9 @@ class Parser:\n         line number or last line number as well as the current name and\n         filename.\n         \"\"\"\n-        pass\n+        if lineno is None:\n+            lineno = self.stream.current.lineno\n+        raise exc(msg, lineno, self.name, self.filename)\n\n     def fail_unknown_tag(self, name: str, lineno: t.Optional[int]=None\n         ) -&gt;'te.NoReturn':\n@@ -55,26 +57,54 @@ class Parser:\n         with a human readable error message that could help to identify\n         the problem.\n         \"\"\"\n-        pass\n+        if lineno is None:\n+            lineno = self.stream.current.lineno\n+        if name in ('endif', 'endfor', 'endblock', 'endmacro', 'endcall'):\n+            self.fail(f'Unexpected end of block tag {name!r}', lineno)\n+        elif name in _statement_keywords:\n+            self.fail(f'Block tag {name!r} expected', lineno)\n+        self.fail(f'Unknown tag {name!r}', lineno)\n\n     def fail_eof(self, end_tokens: t.Optional[t.Tuple[str, ...]]=None,\n         lineno: t.Optional[int]=None) -&gt;'te.NoReturn':\n         \"\"\"Like fail_unknown_tag but for end of template situations.\"\"\"\n-        pass\n+        if end_tokens is not None:\n+            expected = ' or '.join(repr(x) for x in end_tokens)\n+            msg = f'Unexpected end of template. Expected {expected}.'\n+        else:\n+            msg = 'Unexpected end of template.'\n+        self.fail(msg, lineno)\n\n     def is_tuple_end(self, extra_end_rules: t.Optional[t.Tuple[str, ...]]=None\n         ) -&gt;bool:\n         \"\"\"Are we at the end of a tuple?\"\"\"\n-        pass\n+        if self.stream.current.type in ('variable_end', 'block_end', 'rparen'):\n+            return True\n+        if extra_end_rules is not None:\n+            return self.stream.current.test_any(extra_end_rules)\n+        return False\n\n     def free_identifier(self, lineno: t.Optional[int]=None\n         ) -&gt;nodes.InternalName:\n         \"\"\"Return a new free identifier as :class:`~jinja2.nodes.InternalName`.\"\"\"\n-        pass\n+        self._last_identifier += 1\n+        rv = object.__new__(nodes.InternalName)\n+        rv.name = f'fi{self._last_identifier}'\n+        rv.lineno = lineno\n+        return rv\n\n     def parse_statement(self) -&gt;t.Union[nodes.Node, t.List[nodes.Node]]:\n         \"\"\"Parse a single statement.\"\"\"\n-        pass\n+        token = self.stream.current\n+        if token.type != 'name':\n+            return self.parse_expression()\n+        if token.value in _statement_keywords:\n+            return getattr(self, f'parse_{token.value}')()\n+        if token.value == 'call':\n+            return self.parse_call_block()\n+        if token.value == 'filter':\n+            return self.parse_filter_block()\n+        return self.parse_expression()\n\n     def parse_statements(self, end_tokens: t.Tuple[str, ...], drop_needle:\n         bool=False) -&gt;t.List[nodes.Node]:\n@@ -87,7 +117,20 @@ class Parser:\n         the call is the matched end token.  If this is not wanted `drop_needle`\n         can be set to `True` and the end token is removed.\n         \"\"\"\n-        pass\n+        result = []\n+        while 1:\n+            if self.stream.current.type == 'data':\n+                result.append(nodes.Output([self.parse_tuple(with_condexpr=True)]))\n+            elif self.stream.current.type == 'block_begin':\n+                self.stream.next()\n+                if self.stream.current.test_any(end_tokens):\n+                    if drop_needle:\n+                        self.stream.next()\n+                    return result\n+                result.append(self.parse_statement())\n+            else:\n+                break\n+        self.fail_eof(end_tokens)\n\n     def parse_set(self) -&gt;t.Union[nodes.Assign, nodes.AssignBlock]:\n         \"\"\"Parse an assign statement.\"\"\"\ndiff --git a/src/jinja2/runtime.py b/src/jinja2/runtime.py\nindex c88211d..1bceb54 100644\n--- a/src/jinja2/runtime.py\n+++ b/src/jinja2/runtime.py\n@@ -43,17 +43,17 @@ def identity(x: V) -&gt;V:\n     \"\"\"Returns its argument. Useful for certain things in the\n     environment.\n     \"\"\"\n-    pass\n+    return x\n\n\n def markup_join(seq: t.Iterable[t.Any]) -&gt;str:\n     \"\"\"Concatenation that escapes if necessary and converts to string.\"\"\"\n-    pass\n+    return Markup('').join(escape(soft_str(v)) for v in seq)\n\n\n def str_join(seq: t.Iterable[t.Any]) -&gt;str:\n     \"\"\"Simple args to string conversion and concatenation.\"\"\"\n-    pass\n+    return ''.join(map(str, seq))\n\n\n def new_context(environment: 'Environment', template_name: t.Optional[str],\n@@ -62,7 +62,14 @@ def new_context(environment: 'Environment', template_name: t.Optional[str],\n     Optional[t.MutableMapping[str, t.Any]]=None, locals: t.Optional[t.\n     Mapping[str, t.Any]]=None) -&gt;'Context':\n     \"\"\"Internal helper for context creation.\"\"\"\n-    pass\n+    parent = environment.make_globals(globals)\n+    if vars is not None:\n+        parent.update(vars)\n+    if shared:\n+        parent = vars or {}\n+    if locals:\n+        parent.update(locals)\n+    return Context(environment, parent, template_name, blocks)\n\n\n class TemplateReference:\n@@ -116,7 +123,14 @@ class Context:\n     def super(self, name: str, current: t.Callable[['Context'], t.Iterator[\n         str]]) -&gt;t.Union['BlockReference', 'Undefined']:\n         \"\"\"Render a parent block.\"\"\"\n-        pass\n+        try:\n+            blocks = self.blocks[name]\n+            index = blocks.index(current) + 1\n+            if index &lt; len(blocks):\n+                return BlockReference(name, self, blocks, index)\n+        except (LookupError, ValueError):\n+            pass\n+        return self.environment.undefined(f'there is no parent block called {name!r}.', name='super')\n\n     def get(self, key: str, default: t.Any=None) -&gt;t.Any:\n         \"\"\"Look up a variable by name, or return a default if the key is\n@@ -125,7 +139,10 @@ class Context:\n         :param key: The variable name to look up.\n         :param default: The value to return if the key is not found.\n         \"\"\"\n-        pass\n+        try:\n+            return self[key]\n+        except KeyError:\n+            return default\n\n     def resolve(self, key: str) -&gt;t.Union[t.Any, 'Undefined']:\n         \"\"\"Look up a variable by name, or return an :class:`Undefined`\n@@ -137,7 +154,10 @@ class Context:\n\n         :param key: The variable name to look up.\n         \"\"\"\n-        pass\n+        rv = self.resolve_or_missing(key)\n+        if rv is missing:\n+            return self.environment.undefined(name=key)\n+        return rv\n\n     def resolve_or_missing(self, key: str) -&gt;t.Any:\n         \"\"\"Look up a variable by name, or return a ``missing`` sentinel\n@@ -149,18 +169,22 @@ class Context:\n\n         :param key: The variable name to look up.\n         \"\"\"\n-        pass\n+        if key in self.vars:\n+            return self.vars[key]\n+        if key in self.parent:\n+            return self.parent[key]\n+        return missing\n\n     def get_exported(self) -&gt;t.Dict[str, t.Any]:\n         \"\"\"Get a new dict with the exported variables.\"\"\"\n-        pass\n+        return {k: self.vars[k] for k in self.exported_vars}\n\n     def get_all(self) -&gt;t.Dict[str, t.Any]:\n         \"\"\"Return the complete context as dict including the exported\n         variables.  For optimizations reasons this might not return an\n         actual copy so be careful with using it.\n         \"\"\"\n-        pass\n+        return {**self.parent, **self.vars}\n\n     @internalcode\n     def call(__self, __obj: t.Callable[..., t.Any], *args: t.Any, **kwargs:\n@@ -170,14 +194,23 @@ class Context:\n         argument if the callable has :func:`pass_context` or\n         :func:`pass_environment`.\n         \"\"\"\n-        pass\n+        if isinstance(__obj, _PassArg):\n+            if __obj._type == 'context':\n+                args = (__self,) + args\n+            elif __obj._type == 'environment':\n+                args = (__self.environment,) + args\n+            return __obj._func(*args, **kwargs)\n+        return __obj(*args, **kwargs)\n\n     def derived(self, locals: t.Optional[t.Dict[str, t.Any]]=None) -&gt;'Context':\n         \"\"\"Internal helper function to create a derived context.  This is\n         used in situations where the system needs a new context in the same\n         template that is independent.\n         \"\"\"\n-        pass\n+        context = new_context(self.environment, self.name, self.blocks,\n+                              self.get_all(), True, None, locals)\n+        context.globals_keys = self.globals_keys\n+        return context\n     keys = _dict_method_all(dict.keys)\n     values = _dict_method_all(dict.values)\n     items = _dict_method_all(dict.items)\ndiff --git a/src/jinja2/sandbox.py b/src/jinja2/sandbox.py\nindex b73a983..9ea91b9 100644\n--- a/src/jinja2/sandbox.py\n+++ b/src/jinja2/sandbox.py\n@@ -35,7 +35,22 @@ def safe_range(*args: int) -&gt;range:\n     \"\"\"A range that can't generate ranges with a length of more than\n     MAX_RANGE items.\n     \"\"\"\n-    pass\n+    if len(args) == 1:\n+        start, stop, step = 0, args[0], 1\n+    elif len(args) == 2:\n+        start, stop, step = args[0], args[1], 1\n+    elif len(args) == 3:\n+        start, stop, step = args\n+    else:\n+        raise TypeError('range() requires 1-3 integer arguments')\n+    \n+    # Calculate the length of the range\n+    length = (stop - start + step - 1) // step\n+    \n+    if length &gt; MAX_RANGE:\n+        raise OverflowError(f'range() result has too many items (maximum is {MAX_RANGE})')\n+    \n+    return range(start, stop, step)\n\n\n def unsafe(f: F) -&gt;F:\n@@ -47,7 +62,8 @@ def unsafe(f: F) -&gt;F:\n         def delete(self):\n             pass\n     \"\"\"\n-    pass\n+    f.unsafe_callable = True\n+    return f\n\n\n def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:\n@@ -62,7 +78,11 @@ def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:\n     &gt;&gt;&gt; is_internal_attribute(str, \"upper\")\n     False\n     \"\"\"\n-    pass\n+    return attr.startswith('__') and attr.endswith('__') or \\\n+           attr.startswith('func_') or \\\n+           attr.startswith('im_') or \\\n+           attr in UNSAFE_FUNCTION_ATTRIBUTES or \\\n+           attr in UNSAFE_METHOD_ATTRIBUTES\n\n\n def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:\n@@ -84,7 +104,10 @@ def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:\n     &gt;&gt;&gt; modifies_known_mutable(\"foo\", \"upper\")\n     False\n     \"\"\"\n-    pass\n+    for typ, mutable_attrs in _mutable_spec:\n+        if isinstance(obj, typ):\n+            return attr in mutable_attrs\n+    return False\n\n\n class SandboxedEnvironment(Environment):\n@@ -120,7 +143,7 @@ class SandboxedEnvironment(Environment):\n         special attributes of internal python objects as returned by the\n         :func:`is_internal_attribute` function.\n         \"\"\"\n-        pass\n+        return not (attr.startswith('_') or is_internal_attribute(obj, attr))\n\n     def is_safe_callable(self, obj: t.Any) -&gt;bool:\n         \"\"\"Check if an object is safely callable. By default callables\n@@ -129,7 +152,10 @@ class SandboxedEnvironment(Environment):\n         This also recognizes the Django convention of setting\n         ``func.alters_data = True``.\n         \"\"\"\n-        pass\n+        return callable(obj) and not (\n+            getattr(obj, 'unsafe_callable', False) or\n+            getattr(obj, 'alters_data', False)\n+        )\n\n     def call_binop(self, context: Context, operator: str, left: t.Any,\n         right: t.Any) -&gt;t.Any:\n@@ -139,7 +165,9 @@ class SandboxedEnvironment(Environment):\n\n         .. versionadded:: 2.6\n         \"\"\"\n-        pass\n+        if operator not in self.binop_table:\n+            raise SecurityError(f'unsupported binary operator: {operator}')\n+        return self.binop_table[operator](left, right)\n\n     def call_unop(self, context: Context, operator: str, arg: t.Any) -&gt;t.Any:\n         \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)\n@@ -148,22 +176,47 @@ class SandboxedEnvironment(Environment):\n\n         .. versionadded:: 2.6\n         \"\"\"\n-        pass\n+        if operator not in self.unop_table:\n+            raise SecurityError(f'unsupported unary operator: {operator}')\n+        return self.unop_table[operator](arg)\n\n     def getitem(self, obj: t.Any, argument: t.Union[str, t.Any]) -&gt;t.Union[\n         t.Any, Undefined]:\n         \"\"\"Subscribe an object from sandboxed code.\"\"\"\n-        pass\n+        try:\n+            return obj[argument]\n+        except (TypeError, LookupError):\n+            if isinstance(argument, str):\n+                try:\n+                    attr = str(argument)\n+                except Exception:\n+                    pass\n+                else:\n+                    try:\n+                        return self.getattr(obj, attr)\n+                    except RuntimeError:\n+                        return self.undefined(obj=obj, name=argument)\n+            return self.undefined(obj=obj, name=argument)\n\n     def getattr(self, obj: t.Any, attribute: str) -&gt;t.Union[t.Any, Undefined]:\n         \"\"\"Subscribe an object from sandboxed code and prefer the\n         attribute.  The attribute passed *must* be a bytestring.\n         \"\"\"\n-        pass\n+        try:\n+            value = getattr(obj, attribute)\n+        except AttributeError:\n+            return self.undefined(obj=obj, name=attribute)\n+        else:\n+            if self.is_safe_attribute(obj, attribute, value):\n+                return value\n+            return self.unsafe_undefined(obj, attribute)\n\n     def unsafe_undefined(self, obj: t.Any, attribute: str) -&gt;Undefined:\n         \"\"\"Return an undefined object for unsafe attributes.\"\"\"\n-        pass\n+        return self.undefined('access to attribute %r of %r object is unsafe.' % (\n+            attribute,\n+            obj.__class__.__name__\n+        ), name=attribute, obj=obj, exc=SecurityError)\n\n     def format_string(self, s: str, args: t.Tuple[t.Any, ...], kwargs: t.\n         Dict[str, t.Any], format_func: t.Optional[t.Callable[..., t.Any]]=None\n@@ -171,12 +224,21 @@ class SandboxedEnvironment(Environment):\n         \"\"\"If a format call is detected, then this is routed through this\n         method so that our safety sandbox can be used for it.\n         \"\"\"\n-        pass\n+        if format_func is not None:\n+            formatter = SandboxedEscapeFormatter(self, format_func)\n+        elif isinstance(s, Markup):\n+            formatter = SandboxedEscapeFormatter(self, lambda x: x)\n+        else:\n+            formatter = SandboxedFormatter(self)\n+        \n+        return formatter.vformat(s, args, kwargs)\n\n     def call(__self, __context: Context, __obj: t.Any, *args: t.Any, **\n         kwargs: t.Any) -&gt;t.Any:\n         \"\"\"Call an object from sandboxed code.\"\"\"\n-        pass\n+        if not __self.is_safe_callable(__obj):\n+            raise SecurityError(f'{__obj!r} is not safely callable')\n+        return __obj(*args, **kwargs)\n\n\n class ImmutableSandboxedEnvironment(SandboxedEnvironment):\ndiff --git a/src/jinja2/tests.py b/src/jinja2/tests.py\nindex 2823a4b..0963a3e 100644\n--- a/src/jinja2/tests.py\n+++ b/src/jinja2/tests.py\n@@ -11,17 +11,17 @@ if t.TYPE_CHECKING:\n\n def test_odd(value: int) -&gt;bool:\n     \"\"\"Return true if the variable is odd.\"\"\"\n-    pass\n+    return value % 2 != 0\n\n\n def test_even(value: int) -&gt;bool:\n     \"\"\"Return true if the variable is even.\"\"\"\n-    pass\n+    return value % 2 == 0\n\n\n def test_divisibleby(value: int, num: int) -&gt;bool:\n     \"\"\"Check if a variable is divisible by a number.\"\"\"\n-    pass\n+    return value % num == 0\n\n\n def test_defined(value: t.Any) -&gt;bool:\n@@ -38,12 +38,12 @@ def test_defined(value: t.Any) -&gt;bool:\n     See the :func:`default` filter for a simple way to set undefined\n     variables.\n     \"\"\"\n-    pass\n+    return not isinstance(value, Undefined)\n\n\n def test_undefined(value: t.Any) -&gt;bool:\n     \"\"\"Like :func:`defined` but the other way round.\"\"\"\n-    pass\n+    return isinstance(value, Undefined)\n\n\n @pass_environment\n@@ -61,7 +61,7 @@ def test_filter(env: 'Environment', value: str) -&gt;bool:\n\n     .. versionadded:: 3.0\n     \"\"\"\n-    pass\n+    return value in env.filters\n\n\n @pass_environment\n@@ -83,12 +83,12 @@ def test_test(env: 'Environment', value: str) -&gt;bool:\n\n     .. versionadded:: 3.0\n     \"\"\"\n-    pass\n+    return value in env.tests\n\n\n def test_none(value: t.Any) -&gt;bool:\n     \"\"\"Return true if the variable is none.\"\"\"\n-    pass\n+    return value is None\n\n\n def test_boolean(value: t.Any) -&gt;bool:\n@@ -96,7 +96,7 @@ def test_boolean(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.11\n     \"\"\"\n-    pass\n+    return isinstance(value, bool)\n\n\n def test_false(value: t.Any) -&gt;bool:\n@@ -104,7 +104,7 @@ def test_false(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.11\n     \"\"\"\n-    pass\n+    return value is False\n\n\n def test_true(value: t.Any) -&gt;bool:\n@@ -112,7 +112,7 @@ def test_true(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.11\n     \"\"\"\n-    pass\n+    return value is True\n\n\n def test_integer(value: t.Any) -&gt;bool:\n@@ -120,7 +120,7 @@ def test_integer(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.11\n     \"\"\"\n-    pass\n+    return isinstance(value, int)\n\n\n def test_float(value: t.Any) -&gt;bool:\n@@ -128,22 +128,22 @@ def test_float(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.11\n     \"\"\"\n-    pass\n+    return isinstance(value, float)\n\n\n def test_lower(value: str) -&gt;bool:\n     \"\"\"Return true if the variable is lowercased.\"\"\"\n-    pass\n+    return isinstance(value, str) and value.islower()\n\n\n def test_upper(value: str) -&gt;bool:\n     \"\"\"Return true if the variable is uppercased.\"\"\"\n-    pass\n+    return isinstance(value, str) and value.isupper()\n\n\n def test_string(value: t.Any) -&gt;bool:\n     \"\"\"Return true if the object is a string.\"\"\"\n-    pass\n+    return isinstance(value, str)\n\n\n def test_mapping(value: t.Any) -&gt;bool:\n@@ -151,19 +151,19 @@ def test_mapping(value: t.Any) -&gt;bool:\n\n     .. versionadded:: 2.6\n     \"\"\"\n-    pass\n+    return isinstance(value, abc.Mapping)\n\n\n def test_number(value: t.Any) -&gt;bool:\n     \"\"\"Return true if the variable is a number.\"\"\"\n-    pass\n+    return isinstance(value, Number)\n\n\n def test_sequence(value: t.Any) -&gt;bool:\n     \"\"\"Return true if the variable is a sequence. Sequences are variables\n     that are iterable.\n     \"\"\"\n-    pass\n+    return isinstance(value, (abc.Sequence, abc.Set)) and not isinstance(value, str)\n\n\n def test_sameas(value: t.Any, other: t.Any) -&gt;bool:\n@@ -176,17 +176,21 @@ def test_sameas(value: t.Any, other: t.Any) -&gt;bool:\n             the foo attribute really is the `False` singleton\n         {% endif %}\n     \"\"\"\n-    pass\n+    return value is other\n\n\n def test_iterable(value: t.Any) -&gt;bool:\n     \"\"\"Check if it's possible to iterate over an object.\"\"\"\n-    pass\n+    try:\n+        iter(value)\n+        return True\n+    except TypeError:\n+        return False\n\n\n def test_escaped(value: t.Any) -&gt;bool:\n     \"\"\"Check if the value is escaped.\"\"\"\n-    pass\n+    return hasattr(value, '__html__')\n\n\n def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt;bool:\n@@ -194,7 +198,7 @@ def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt;bool:\n\n     .. versionadded:: 2.10\n     \"\"\"\n-    pass\n+    return value in seq\n\n\n TESTS = {'odd': test_odd, 'even': test_even, 'divisibleby':\ndiff --git a/src/jinja2/utils.py b/src/jinja2/utils.py\nindex 7563812..9a4ac9c 100644\n--- a/src/jinja2/utils.py\n+++ b/src/jinja2/utils.py\n@@ -32,7 +32,8 @@ def pass_context(f: F) -&gt;F:\n     .. versionadded:: 3.0.0\n         Replaces ``contextfunction`` and ``contextfilter``.\n     \"\"\"\n-    pass\n+    f.jinja_pass_arg = _PassArg.context\n+    return f\n\n\n def pass_eval_context(f: F) -&gt;F:\n@@ -48,7 +49,8 @@ def pass_eval_context(f: F) -&gt;F:\n     .. versionadded:: 3.0.0\n         Replaces ``evalcontextfunction`` and ``evalcontextfilter``.\n     \"\"\"\n-    pass\n+    f.jinja_pass_arg = _PassArg.eval_context\n+    return f\n\n\n def pass_environment(f: F) -&gt;F:\n@@ -60,7 +62,8 @@ def pass_environment(f: F) -&gt;F:\n     .. versionadded:: 3.0.0\n         Replaces ``environmentfunction`` and ``environmentfilter``.\n     \"\"\"\n-    pass\n+    f.jinja_pass_arg = _PassArg.environment\n+    return f\n\n\n class _PassArg(enum.Enum):\n@@ -71,7 +74,8 @@ class _PassArg(enum.Enum):\n\n def internalcode(f: F) -&gt;F:\n     \"\"\"Marks the function as internally used\"\"\"\n-    pass\n+    internal_code.add(f.__code__)\n+    return f\n\n\n def is_undefined(obj: t.Any) -&gt;bool:\n@@ -86,7 +90,8 @@ def is_undefined(obj: t.Any) -&gt;bool:\n                 return default\n             return var\n     \"\"\"\n-    pass\n+    from .runtime import Undefined\n+    return isinstance(obj, Undefined)\n\n\n def consume(iterable: t.Iterable[t.Any]) -&gt;None:\ndiff --git a/src/jinja2/visitor.py b/src/jinja2/visitor.py\nindex ebb34c6..17dcc82 100644\n--- a/src/jinja2/visitor.py\n+++ b/src/jinja2/visitor.py\n@@ -30,15 +30,19 @@ class NodeVisitor:\n         exists for this node.  In that case the generic visit function is\n         used instead.\n         \"\"\"\n-        pass\n+        method = 'visit_' + node.__class__.__name__\n+        return getattr(self, method, None)\n\n     def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:\n         \"\"\"Visit a node.\"\"\"\n-        pass\n+        f = self.get_visitor(node)\n+        if f is not None:\n+            return f(node, *args, **kwargs)\n+        return self.generic_visit(node, *args, **kwargs)\n\n     def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:\n         \"\"\"Called if no explicit visitor function exists for a node.\"\"\"\n-        pass\n+        return node\n\n\n class NodeTransformer(NodeVisitor):\n@@ -52,9 +56,16 @@ class NodeTransformer(NodeVisitor):\n     replacement takes place.\n     \"\"\"\n\n-    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.List[\n-        Node]:\n+    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.List[Node]:\n         \"\"\"As transformers may return lists in some places this method\n         can be used to enforce a list as return value.\n         \"\"\"\n-        pass\n+        result = []\n+        for child in node:\n+            new_node = self.visit(child, *args, **kwargs)\n+            if new_node is not None:\n+                if isinstance(new_node, list):\n+                    result.extend(new_node)\n+                else:\n+                    result.append(new_node)\n+        return result\n</code></pre>"},{"location":"analysis_baseline_marshmallow/","title":"Analysis baseline marshmallow","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_marshmallow/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_marshmallow/#repository-marshmallow","title":"Repository: marshmallow","text":""},{"location":"analysis_baseline_marshmallow/#failed-to-run-pytests","title":"Failed to run pytests","text":"<pre><code>ImportError while loading conftest '/testbed/tests/conftest.py'.\ntests/conftest.py:5: in &lt;module&gt;\n    from tests.base import Blog, User, UserSchema\ntests/base.py:11: in &lt;module&gt;\n    from marshmallow import Schema, fields, missing, post_load, validate\nsrc/marshmallow/__init__.py:17: in &lt;module&gt;\n    from marshmallow.schema import Schema, SchemaOpts\nsrc/marshmallow/schema.py:15: in &lt;module&gt;\n    from marshmallow import fields as ma_fields\nsrc/marshmallow/fields.py:18: in &lt;module&gt;\n    from marshmallow.utils import is_aware, is_collection, resolve_field_instance\nE   ImportError: cannot import name 'is_aware' from 'marshmallow.utils' (/testbed/src/marshmallow/utils.py)\n</code></pre>"},{"location":"analysis_baseline_marshmallow/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/src/marshmallow/class_registry.py b/src/marshmallow/class_registry.py\nindex 249b898..a7b38e8 100644\n--- a/src/marshmallow/class_registry.py\n+++ b/src/marshmallow/class_registry.py\n@@ -35,14 +35,29 @@ def register(classname: str, cls: SchemaType) -&gt;None:\n         # }\n\n     \"\"\"\n-    pass\n+    global _registry\n+    _registry[classname] = [cls]\n+    _registry[f\"{cls.__module__}.{cls.__name__}\"] = [cls]\n\n\n-def get_class(classname: str, all: bool=False) -&gt;(list[SchemaType] | SchemaType\n-    ):\n+def get_class(classname: str, all: bool=False) -&gt;(list[SchemaType] | SchemaType):\n     \"\"\"Retrieve a class from the registry.\n\n     :raises: marshmallow.exceptions.RegistryError if the class cannot be found\n         or if there are multiple entries for the given class name.\n     \"\"\"\n-    pass\n+    try:\n+        classes = _registry[classname]\n+    except KeyError:\n+        raise RegistryError(f\"Class with name {classname!r} was not found.\")\n+    \n+    if all:\n+        return classes\n+    \n+    if len(classes) &gt; 1:\n+        raise RegistryError(\n+            f\"Multiple classes with name {classname!r} were found. \"\n+            \"Please use the full, module-qualified path.\"\n+        )\n+    \n+    return classes[0]\ndiff --git a/src/marshmallow/decorators.py b/src/marshmallow/decorators.py\nindex d78f5be..e2944df 100644\n--- a/src/marshmallow/decorators.py\n+++ b/src/marshmallow/decorators.py\n@@ -84,7 +84,13 @@ def validates(field_name: str) -&gt;Callable[..., Any]:\n\n     :param str field_name: Name of the field that the method validates.\n     \"\"\"\n-    pass\n+    def decorator(fn):\n+        @functools.wraps(fn)\n+        def wrapper(self, value, **kwargs):\n+            return fn(self, value, **kwargs)\n+        wrapper.__marshmallow_hook__ = {VALIDATES: field_name}\n+        return wrapper\n+    return decorator\n\n\n def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=\n@@ -109,7 +115,25 @@ def validates_schema(fn: (Callable[..., Any] | None)=None, pass_many: bool=\n         ``partial`` and ``many`` are always passed as keyword arguments to\n         the decorated method.\n     \"\"\"\n-    pass\n+    if fn is None:\n+        return functools.partial(\n+            validates_schema,\n+            pass_many=pass_many,\n+            pass_original=pass_original,\n+            skip_on_field_errors=skip_on_field_errors,\n+        )\n+\n+    @functools.wraps(fn)\n+    def wrapper(*args, **kwargs):\n+        return fn(*args, **kwargs)\n+\n+    wrapper.__marshmallow_hook__ = {\n+        (VALIDATES_SCHEMA, pass_many): {\n+            'pass_original': pass_original,\n+            'skip_on_field_errors': skip_on_field_errors,\n+        }\n+    }\n+    return wrapper\n\n\n def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False\n@@ -124,7 +148,7 @@ def pre_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False\n     .. versionchanged:: 3.0.0\n         ``many`` is always passed as a keyword arguments to the decorated method.\n     \"\"\"\n-    pass\n+    return set_hook(fn, (PRE_DUMP, pass_many))\n\n\n def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,\n@@ -142,7 +166,7 @@ def post_dump(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,\n     .. versionchanged:: 3.0.0\n         ``many`` is always passed as a keyword arguments to the decorated method.\n     \"\"\"\n-    pass\n+    return set_hook(fn, (POST_DUMP, pass_many), pass_original=pass_original)\n\n\n def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False\n@@ -158,7 +182,7 @@ def pre_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False\n         ``partial`` and ``many`` are always passed as keyword arguments to\n         the decorated method.\n     \"\"\"\n-    pass\n+    return set_hook(fn, (PRE_LOAD, pass_many))\n\n\n def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,\n@@ -177,7 +201,7 @@ def post_load(fn: (Callable[..., Any] | None)=None, pass_many: bool=False,\n         ``partial`` and ``many`` are always passed as keyword arguments to\n         the decorated method.\n     \"\"\"\n-    pass\n+    return set_hook(fn, (POST_LOAD, pass_many), pass_original=pass_original)\n\n\n def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),\n@@ -192,4 +216,11 @@ def set_hook(fn: (Callable[..., Any] | None), key: (tuple[str, bool] | str),\n     :return: Decorated function if supplied, else this decorator with its args\n         bound.\n     \"\"\"\n-    pass\n+    def decorator(func):\n+        func.__marshmallow_hook__ = {key: kwargs or True}\n+        return func\n+\n+    if fn is None:\n+        return decorator\n+    else:\n+        return decorator(fn)\ndiff --git a/src/marshmallow/error_store.py b/src/marshmallow/error_store.py\nindex a659aaf..d5a60d5 100644\n--- a/src/marshmallow/error_store.py\n+++ b/src/marshmallow/error_store.py\n@@ -13,6 +13,16 @@ class ErrorStore:\n     def __init__(self):\n         self.errors = {}\n\n+    def store_error(self, field_name, error):\n+        \"\"\"Store an error message for a field.\"\"\"\n+        if field_name not in self.errors:\n+            self.errors[field_name] = []\n+        self.errors[field_name].append(error)\n+\n+    def get_errors(self):\n+        \"\"\"Return all stored errors.\"\"\"\n+        return self.errors\n+\n\n def merge_errors(errors1, errors2):\n     \"\"\"Deeply merge two error messages.\n@@ -20,4 +30,15 @@ def merge_errors(errors1, errors2):\n     The format of ``errors1`` and ``errors2`` matches the ``message``\n     parameter of :exc:`marshmallow.exceptions.ValidationError`.\n     \"\"\"\n-    pass\n+    merged = errors1.copy()\n+    for key, value in errors2.items():\n+        if key in merged:\n+            if isinstance(merged[key], dict) and isinstance(value, dict):\n+                merged[key] = merge_errors(merged[key], value)\n+            elif isinstance(merged[key], list) and isinstance(value, list):\n+                merged[key].extend(value)\n+            else:\n+                merged[key] = [merged[key], value]\n+        else:\n+            merged[key] = value\n+    return merged\ndiff --git a/src/marshmallow/fields.py b/src/marshmallow/fields.py\nindex 8656a56..c3a5d4a 100644\n--- a/src/marshmallow/fields.py\n+++ b/src/marshmallow/fields.py\n@@ -166,19 +166,37 @@ class Field(FieldABC):\n         :param callable accessor: A callable used to retrieve the value of `attr` from\n             the object `obj`. Defaults to `marshmallow.utils.get_value`.\n         \"\"\"\n-        pass\n+        accessor_func = accessor or utils.get_value\n+        return accessor_func(obj, attr, default)\n\n     def _validate(self, value):\n         \"\"\"Perform validation on ``value``. Raise a :exc:`ValidationError` if validation\n         does not succeed.\n         \"\"\"\n-        pass\n+        errors = []\n+        for validator in self.validators:\n+            try:\n+                if validator(value) is False:\n+                    self.fail('validator_failed')\n+            except ValidationError as error:\n+                errors.extend(error.messages)\n+        if errors:\n+            raise ValidationError(errors)\n\n     def make_error(self, key: str, **kwargs) -&gt;ValidationError:\n         \"\"\"Helper method to make a `ValidationError` with an error message\n         from ``self.error_messages``.\n         \"\"\"\n-        pass\n+        try:\n+            msg = self.error_messages[key]\n+        except KeyError as error:\n+            class_name = self.__class__.__name__\n+            message = (f'Error key \"{key}\" does not exist for field \"{class_name}\".'\n+                       f' Available keys are {\", \".join(self.error_messages.keys())}.')\n+            raise KeyError(message) from error\n+        if isinstance(msg, str):\n+            msg = msg.format(**kwargs)\n+        return ValidationError(msg)\n\n     def fail(self, key: str, **kwargs):\n         \"\"\"Helper method that raises a `ValidationError` with an error message\n@@ -187,13 +205,23 @@ class Field(FieldABC):\n         .. deprecated:: 3.0.0\n             Use `make_error &lt;marshmallow.fields.Field.make_error&gt;` instead.\n         \"\"\"\n-        pass\n+        warnings.warn(\n+            \"Field.fail is deprecated. Use Field.make_error instead.\",\n+            RemovedInMarshmallow4Warning,\n+            stacklevel=2\n+        )\n+        raise self.make_error(key, **kwargs)\n\n     def _validate_missing(self, value):\n         \"\"\"Validate missing values. Raise a :exc:`ValidationError` if\n         `value` should be considered missing.\n         \"\"\"\n-        pass\n+        if value is missing_:\n+            if self.required:\n+                raise self.make_error('required')\n+        elif value is None:\n+            if self.allow_none is False:\n+                raise self.make_error('null')\n\n     def serialize(self, attr: str, obj: typing.Any, accessor: (typing.\n         Callable[[typing.Any, str, typing.Any], typing.Any] | None)=None,\n@@ -206,7 +234,14 @@ class Field(FieldABC):\n         :param accessor: Function used to access values from ``obj``.\n         :param kwargs: Field-specific keyword arguments.\n         \"\"\"\n-        pass\n+        if self.dump_only:\n+            return self.dump_default\n+\n+        value = self.get_value(obj, attr, accessor=accessor)\n+        if value is missing_:\n+            return self.dump_default\n+\n+        return self._serialize(value, attr, obj, **kwargs)\n\n     def deserialize(self, value: typing.Any, attr: (str | None)=None, data:\n         (typing.Mapping[str, typing.Any] | None)=None, **kwargs):\n@@ -219,7 +254,17 @@ class Field(FieldABC):\n         :raise ValidationError: If an invalid value is passed or if a required value\n             is missing.\n         \"\"\"\n-        pass\n+        if self.load_only:\n+            return self.load_default\n+\n+        self._validate_missing(value)\n+        if value is missing_:\n+            return self.load_default\n+\n+        value = self._deserialize(value, attr, data, **kwargs)\n+        self._validate(value)\n+\n+        return value\n\n     def _bind_to_schema(self, field_name, schema):\n         \"\"\"Update field with values from its parent schema. Called by\n@@ -228,7 +273,13 @@ class Field(FieldABC):\n         :param str field_name: Field name set in schema.\n         :param Schema|Field schema: Parent object.\n         \"\"\"\n-        pass\n+        self.parent = self.schema = schema\n+        self.name = field_name\n+        self.root = schema.root\n+        # Allow fields to override their data key\n+        if self.data_key is None:\n+            self.data_key = field_name\n+        self.metadata.setdefault('name', field_name)\n\n     def _serialize(self, value: typing.Any, attr: (str | None), obj: typing\n         .Any, **kwargs):\n@@ -249,7 +300,7 @@ class Field(FieldABC):\n         :param dict kwargs: Field-specific keyword arguments.\n         :return: The serialized value\n         \"\"\"\n-        pass\n+        return value\n\n     def _deserialize(self, value: typing.Any, attr: (str | None), data: (\n         typing.Mapping[str, typing.Any] | None), **kwargs):\n@@ -268,12 +319,12 @@ class Field(FieldABC):\n         .. versionchanged:: 3.0.0\n             Added ``**kwargs`` to signature.\n         \"\"\"\n-        pass\n+        return value\n\n     @property\n     def context(self):\n         \"\"\"The context dictionary for the parent :class:`Schema`.\"\"\"\n-        pass\n+        return self.parent.context if self.parent else {}\n\n\n class Raw(Field):\ndiff --git a/src/marshmallow/schema.py b/src/marshmallow/schema.py\nindex 1e6eabf..38ad968 100644\n--- a/src/marshmallow/schema.py\n+++ b/src/marshmallow/schema.py\n@@ -311,7 +311,10 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):\n\n         .. versionadded:: 3.0.0\n         \"\"\"\n-        pass\n+        attrs = fields.copy()\n+        attrs['Meta'] = type('Meta', (), {'register': False})\n+        schema_cls = type(name, (Schema,), attrs)\n+        return schema_cls\n\n     def handle_error(self, error: ValidationError, data: typing.Any, *,\n         many: bool, **kwargs):\n@@ -327,7 +330,7 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):\n         .. versionchanged:: 3.0.0rc9\n             Receives `many` and `partial` (on deserialization) as keyword arguments.\n         \"\"\"\n-        pass\n+        pass  # Default implementation does nothing\n\n     def get_attribute(self, obj: typing.Any, attr: str, default: typing.Any):\n         \"\"\"Defines how to pull values from an object to serialize.\n@@ -337,7 +340,7 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):\n         .. versionchanged:: 3.0.0a1\n             Changed position of ``obj`` and ``attr``.\n         \"\"\"\n-        pass\n+        return get_value(obj, attr, default)\n\n     @staticmethod\n     def _call_and_store(getter_func, data, *, field_name, error_store,\n@@ -351,7 +354,12 @@ class Schema(base.SchemaABC, metaclass=SchemaMeta):\n         :param int index: Index of the item being validated, if validating a collection,\n             otherwise `None`.\n         \"\"\"\n-        pass\n+        try:\n+            value = getter_func(data)\n+        except ValidationError as error:\n+            error_store.store_error(error.messages, field_name, index=index)\n+            return missing\n+        return value\n\n     def _serialize(self, obj: (_T | typing.Iterable[_T]), *, many: bool=False):\n         \"\"\"Serialize ``obj``.\ndiff --git a/src/marshmallow/utils.py b/src/marshmallow/utils.py\nindex 1c71b57..e9ec424 100644\n--- a/src/marshmallow/utils.py\n+++ b/src/marshmallow/utils.py\n@@ -40,29 +40,35 @@ missing = _Missing()\n\n def is_generator(obj) -&gt;bool:\n     \"\"\"Return True if ``obj`` is a generator\"\"\"\n-    pass\n+    return inspect.isgenerator(obj)\n\n\n def is_iterable_but_not_string(obj) -&gt;bool:\n     \"\"\"Return True if ``obj`` is an iterable object that isn't a string.\"\"\"\n-    pass\n+    return (\n+        isinstance(obj, collections.abc.Iterable) and\n+        not isinstance(obj, (str, bytes))\n+    )\n\n\n def is_collection(obj) -&gt;bool:\n     \"\"\"Return True if ``obj`` is a collection type, e.g list, tuple, queryset.\"\"\"\n-    pass\n+    return is_iterable_but_not_string(obj) and not isinstance(obj, Mapping)\n\n\n def is_instance_or_subclass(val, class_) -&gt;bool:\n     \"\"\"Return True if ``val`` is either a subclass or instance of ``class_``.\"\"\"\n-    pass\n+    try:\n+        return issubclass(val, class_)\n+    except TypeError:\n+        return isinstance(val, class_)\n\n\n def is_keyed_tuple(obj) -&gt;bool:\n     \"\"\"Return True if ``obj`` has keyed tuple behavior, such as\n     namedtuples or SQLAlchemy's KeyedTuples.\n     \"\"\"\n-    pass\n+    return isinstance(obj, tuple) and hasattr(obj, '_fields')\n\n\n def pprint(obj, *args, **kwargs) -&gt;None:\n@@ -73,7 +79,15 @@ def pprint(obj, *args, **kwargs) -&gt;None:\n     .. deprecated:: 3.7.0\n         marshmallow.pprint will be removed in marshmallow 4.\n     \"\"\"\n-    pass\n+    warnings.warn(\n+        \"marshmallow.pprint is deprecated and will be removed in marshmallow 4.\",\n+        RemovedInMarshmallow4Warning,\n+        stacklevel=2,\n+    )\n+    if isinstance(obj, collections.OrderedDict):\n+        py_pprint(dict(obj), *args, **kwargs)\n+    else:\n+        py_pprint(obj, *args, **kwargs)\n\n\n def from_rfc(datestring: str) -&gt;dt.datetime:\n@@ -81,7 +95,7 @@ def from_rfc(datestring: str) -&gt;dt.datetime:\n\n     https://stackoverflow.com/questions/885015/how-to-parse-a-rfc-2822-date-time-into-a-python-datetime  # noqa: B950\n     \"\"\"\n-    pass\n+    return parsedate_to_datetime(datestring)\n\n\n def rfcformat(datetime: dt.datetime) -&gt;str:\n@@ -89,7 +103,7 @@ def rfcformat(datetime: dt.datetime) -&gt;str:\n\n     :param datetime datetime: The datetime.\n     \"\"\"\n-    pass\n+    return format_datetime(datetime)\n\n\n _iso8601_datetime_re = re.compile(\n@@ -104,7 +118,9 @@ _iso8601_time_re = re.compile(\n\n def get_fixed_timezone(offset: (int | float | dt.timedelta)) -&gt;dt.timezone:\n     \"\"\"Return a tzinfo instance with a fixed offset from UTC.\"\"\"\n-    pass\n+    if isinstance(offset, dt.timedelta):\n+        offset = offset.total_seconds()\n+    return dt.timezone(dt.timedelta(seconds=int(offset)))\n\n\n def from_iso_datetime(value):\n@@ -113,7 +129,32 @@ def from_iso_datetime(value):\n     This function supports time zone offsets. When the input contains one,\n     the output uses a timezone with a fixed offset from UTC.\n     \"\"\"\n-    pass\n+    match = _iso8601_datetime_re.match(value)\n+    if not match:\n+        raise ValueError('Not a valid ISO8601-formatted datetime string')\n+\n+    groups = match.groupdict()\n+\n+    groups['year'] = int(groups['year'])\n+    groups['month'] = int(groups['month'])\n+    groups['day'] = int(groups['day'])\n+    groups['hour'] = int(groups['hour'])\n+    groups['minute'] = int(groups['minute'])\n+    groups['second'] = int(groups['second'] or 0)\n+    groups['microsecond'] = int(groups['microsecond'] or 0)\n+\n+    if groups['tzinfo'] == 'Z':\n+        tzinfo = dt.timezone.utc\n+    elif groups['tzinfo']:\n+        offset_mins = int(groups['tzinfo'][-2:]) if len(groups['tzinfo']) &gt; 3 else 0\n+        offset = 60 * int(groups['tzinfo'][1:3]) + offset_mins\n+        if groups['tzinfo'][0] == '-':\n+            offset = -offset\n+        tzinfo = get_fixed_timezone(offset * 60)\n+    else:\n+        tzinfo = None\n+\n+    return dt.datetime(tzinfo=tzinfo, **groups)\n\n\n def from_iso_time(value):\n@@ -121,12 +162,33 @@ def from_iso_time(value):\n\n     This function doesn't support time zone offsets.\n     \"\"\"\n-    pass\n+    match = _iso8601_time_re.match(value)\n+    if not match:\n+        raise ValueError('Not a valid ISO8601-formatted time string')\n+\n+    groups = match.groupdict()\n+\n+    groups['hour'] = int(groups['hour'])\n+    groups['minute'] = int(groups['minute'])\n+    groups['second'] = int(groups['second'] or 0)\n+    groups['microsecond'] = int(groups['microsecond'] or 0)\n+\n+    return dt.time(**groups)\n\n\n def from_iso_date(value):\n     \"\"\"Parse a string and return a datetime.date.\"\"\"\n-    pass\n+    match = _iso8601_date_re.match(value)\n+    if not match:\n+        raise ValueError('Not a valid ISO8601-formatted date string')\n+\n+    groups = match.groupdict()\n+\n+    return dt.date(\n+        int(groups['year']),\n+        int(groups['month']),\n+        int(groups['day'])\n+    )\n\n\n def isoformat(datetime: dt.datetime) -&gt;str:\n@@ -134,7 +196,7 @@ def isoformat(datetime: dt.datetime) -&gt;str:\n\n     :param datetime datetime: The datetime.\n     \"\"\"\n-    pass\n+    return datetime.isoformat()\n\n\n def pluck(dictlist: list[dict[str, typing.Any]], key: str):\n@@ -145,7 +207,7 @@ def pluck(dictlist: list[dict[str, typing.Any]], key: str):\n         &gt;&gt;&gt; pluck(dlist, 'id')\n         [1, 2]\n     \"\"\"\n-    pass\n+    return [d.get(key) for d in dictlist]\n\n\n def get_value(obj, key: (int | str), default=missing):\n@@ -159,7 +221,19 @@ def get_value(obj, key: (int | str), default=missing):\n         `get_value` will never check the value `x.i`. Consider overriding\n         `marshmallow.fields.Field.get_value` in this case.\n     \"\"\"\n-    pass\n+    if isinstance(key, int):\n+        return obj[key] if isinstance(obj, collections.abc.Sequence) else default\n+\n+    try:\n+        return obj[key]\n+    except (KeyError, AttributeError, IndexError, TypeError):\n+        pass\n+\n+    # Fall back to getattr for dotted paths\n+    if '.' in key:\n+        return functools.reduce(lambda o, k: get_value(o, k, default), key.split('.'), obj)\n+\n+    return getattr(obj, key, default)\n\n\n def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):\n@@ -173,12 +247,26 @@ def set_value(dct: dict[str, typing.Any], key: str, value: typing.Any):\n         &gt;&gt;&gt; d\n         {'foo': {'bar': 42}}\n     \"\"\"\n-    pass\n+    if '.' in key:\n+        head, rest = key.split('.', 1)\n+        target = dct.setdefault(head, {})\n+        if not isinstance(target, dict):\n+            raise ValueError(\n+                \"Cannot set '{rest}' in '{head}' ({target}) \"\n+                \"which is not a dict\".format(\n+                    rest=rest, head=head, target=target\n+                )\n+            )\n+        set_value(target, rest, value)\n+    else:\n+        dct[key] = value\n\n\n def callable_or_raise(obj):\n     \"\"\"Check that an object is callable, else raise a :exc:`TypeError`.\"\"\"\n-    pass\n+    if not callable(obj):\n+        raise TypeError('Object {!r} is not callable.'.format(obj))\n+    return obj\n\n\n def get_func_args(func: typing.Callable) -&gt;list[str]:\n@@ -188,7 +276,12 @@ def get_func_args(func: typing.Callable) -&gt;list[str]:\n     .. versionchanged:: 3.0.0a1\n         Do not return bound arguments, eg. ``self``.\n     \"\"\"\n-    pass\n+    if isinstance(func, functools.partial):\n+        return get_func_args(func.func)\n+    if inspect.isfunction(func) or inspect.ismethod(func):\n+        return list(inspect.signature(func).parameters.keys())\n+    # Callable class\n+    return list(inspect.signature(func.__call__).parameters.keys())[1:]\n\n\n def resolve_field_instance(cls_or_instance):\n@@ -196,7 +289,19 @@ def resolve_field_instance(cls_or_instance):\n\n     :param type|Schema cls_or_instance: Marshmallow Schema class or instance.\n     \"\"\"\n-    pass\n+    if isinstance(cls_or_instance, type):\n+        if not issubclass(cls_or_instance, FieldABC):\n+            raise FieldInstanceResolutionError(\n+                'The class \"{}\" is not a subclass of '\n+                'marshmallow.base.FieldABC'.format(cls_or_instance.__name__)\n+            )\n+        return cls_or_instance()\n+    if not isinstance(cls_or_instance, FieldABC):\n+        raise FieldInstanceResolutionError(\n+            'The object \"{}\" is not an instance of '\n+            'marshmallow.base.FieldABC'.format(cls_or_instance)\n+        )\n+    return cls_or_instance\n\n\n def timedelta_to_microseconds(value: dt.timedelta) -&gt;int:\n@@ -204,4 +309,4 @@ def timedelta_to_microseconds(value: dt.timedelta) -&gt;int:\n\n     https://github.com/python/cpython/blob/bb3e0c240bc60fe08d332ff5955d54197f79751c/Lib/datetime.py#L665-L667  # noqa: B950\n     \"\"\"\n-    pass\n+    return (value.days * 86400 + value.seconds) * 1000000 + value.microseconds\ndiff --git a/src/marshmallow/validate.py b/src/marshmallow/validate.py\nindex 3cc3b97..928d96e 100644\n--- a/src/marshmallow/validate.py\n+++ b/src/marshmallow/validate.py\n@@ -105,6 +105,20 @@ class URL(Validator):\n                 self._memoized[key] = self._regex_generator(relative,\n                     absolute, require_tld)\n             return self._memoized[key]\n+\n+        def _regex_generator(self, relative: bool, absolute: bool, require_tld: bool\n+            ) -&gt;typing.Pattern:\n+            return re.compile(\n+                r\"\".join([\n+                    r\"^\",\n+                    r\"(\" if relative else r\"\",\n+                    r\"(?:[a-z0-9\\.\\-\\+]*)://\" if absolute else r\"\",\n+                    r\"(?:[^/:]+)\" if not require_tld else r\"(?:[^/:]+\\.)+[^/:]{2,}\",\n+                    r\"(?::\\d+)?(?:/?|[/?]\\S+)$\",\n+                    r\")?\" if relative else r\"\",\n+                ]),\n+                re.IGNORECASE\n+            )\n     _regex = RegexMemoizer()\n     default_message = 'Not a valid URL.'\n     default_schemes = {'http', 'https', 'ftp', 'ftps'}\n@@ -419,7 +433,15 @@ class OneOf(Validator):\n             of an attribute of the choice objects. Defaults to `str()`\n             or `str()`.\n         \"\"\"\n-        pass\n+        if callable(valuegetter):\n+            getter = valuegetter\n+        elif isinstance(valuegetter, str):\n+            getter = attrgetter(valuegetter)\n+        else:\n+            getter = str\n+\n+        for choice, label in zip_longest(self.choices, self.labels):\n+            yield getter(choice), label or str(choice)\n\n\n class ContainsOnly(OneOf):\n</code></pre>"},{"location":"analysis_baseline_simpy/","title":"Analysis baseline simpy","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_simpy/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_simpy/#repository-simpy","title":"Repository: simpy","text":""},{"location":"analysis_baseline_simpy/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count failed 120 passed 20 total 140 collected 150 deselected 10"},{"location":"analysis_baseline_simpy/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_simpy/#test_conditionpytest_operator_and","title":"test_condition.py::test_operator_and","text":"<pre>test_condition.py::test_operator_and</pre><pre>\nenv = \n\n    def test_operator_and(env):\n        def process(env):\n            timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n            results = yield timeout[0] &amp; timeout[1] &amp; timeout[2]\n\n            assert results == {\n                timeout[0]: 0,\n                timeout[1]: 1,\n                timeout[2]: 2,\n            }\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_operator_and_blocked","title":"test_condition.py::test_operator_and_blocked","text":"<pre>test_condition.py::test_operator_and_blocked</pre><pre>\nenv = \n\n    def test_operator_and_blocked(env):\n        def process(env):\n            timeout = env.timeout(1)\n            event = env.event()\n            yield env.timeout(1)\n\n            condition = timeout &amp; event\n            assert not condition.triggered\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_operator_or","title":"test_condition.py::test_operator_or","text":"<pre>test_condition.py::test_operator_or</pre><pre>\nenv = \n\n    def test_operator_or(env):\n        def process(env):\n            timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n            results = yield timeout[0] | timeout[1] | timeout[2]\n\n            assert results == {\n                timeout[0]: 0,\n            }\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_operator_nested_and","title":"test_condition.py::test_operator_nested_and","text":"<pre>test_condition.py::test_operator_nested_and</pre><pre>\nenv = \n\n    def test_operator_nested_and(env):\n        def process(env):\n            timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n            results = yield (timeout[0] &amp; timeout[2]) | timeout[1]\n\n            assert results == {\n                timeout[0]: 0,\n                timeout[1]: 1,\n            }\n            assert env.now == 1\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_operator_nested_or","title":"test_condition.py::test_operator_nested_or","text":"<pre>test_condition.py::test_operator_nested_or</pre><pre>\nenv = \n\n    def test_operator_nested_or(env):\n        def process(env):\n            timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n            results = yield (timeout[0] | timeout[1]) &amp; timeout[2]\n\n            assert results == {\n                timeout[0]: 0,\n                timeout[1]: 1,\n                timeout[2]: 2,\n            }\n            assert env.now == 2\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:73: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_nested_cond_with_error","title":"test_condition.py::test_nested_cond_with_error","text":"<pre>test_condition.py::test_nested_cond_with_error</pre><pre>\nenv = \n\n    def test_nested_cond_with_error(env):\n        def explode(env):\n            yield env.timeout(1)\n            raise ValueError('Onoes!')\n\n        def process(env):\n            with pytest.raises(ValueError, match='Onoes!'):\n                yield env.process(explode(env)) &amp; env.timeout(1)\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_cond_with_error","title":"test_condition.py::test_cond_with_error","text":"<pre>test_condition.py::test_cond_with_error</pre><pre>\nenv = \n\n    def test_cond_with_error(env):\n        def explode(env, delay):\n            yield env.timeout(delay)\n            raise ValueError(f'Onoes, failed after {delay}!')\n\n        def process(env):\n            with pytest.raises(ValueError, match='Onoes, failed after 0!'):\n                yield env.process(explode(env, 0)) | env.timeout(1)\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_cond_with_nested_error","title":"test_condition.py::test_cond_with_nested_error","text":"<pre>test_condition.py::test_cond_with_nested_error</pre><pre>\nenv = \n\n    def test_cond_with_nested_error(env):\n        def explode(env, delay):\n            yield env.timeout(delay)\n            raise ValueError(f'Onoes, failed after {delay}!')\n\n        def process(env):\n            with pytest.raises(ValueError, match='Onoes, failed after 0!'):\n                yield env.process(explode(env, 0)) &amp; env.timeout(1) | env.timeout(1)\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:112: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_cond_with_uncaught_error","title":"test_condition.py::test_cond_with_uncaught_error","text":"<pre>test_condition.py::test_cond_with_uncaught_error</pre><pre>\nenv = \n\n    def test_cond_with_uncaught_error(env):\n        \"\"\"Errors that happen after the condition has been triggered will not be\n        handled by the condition and cause the simulation to crash.\"\"\"\n\n        def explode(env, delay):\n            yield env.timeout(delay)\n            raise ValueError(f'Onoes, failed after {delay}!')\n\n        def process(env):\n            yield env.timeout(1) | env.process(explode(env, 2))\n\n        env.process(process(env))\n        with pytest.raises(ValueError, match='Onoes, failed after'):\n&gt;           env.run()\n\ntests/test_condition.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_iand_with_and_cond","title":"test_condition.py::test_iand_with_and_cond","text":"<pre>test_condition.py::test_iand_with_and_cond</pre><pre>\nenv = \n\n    def test_iand_with_and_cond(env):\n        def process(env):\n            cond = env.timeout(1, value=1) &amp; env.timeout(2, value=2)\n            orig = cond\n\n            cond &amp;= env.timeout(0, value=0)\n            assert cond is not orig\n\n            results = yield cond\n            assert list(results.values()) == [1, 2, 0]\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:144: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_iand_with_or_cond","title":"test_condition.py::test_iand_with_or_cond","text":"<pre>test_condition.py::test_iand_with_or_cond</pre><pre>\nenv = \n\n    def test_iand_with_or_cond(env):\n        def process(env):\n            cond = env.timeout(1, value=1) | env.timeout(2, value=2)\n            orig = cond\n\n            cond &amp;= env.timeout(0, value=0)\n            assert cond is not orig\n\n            results = yield cond\n            assert list(results.values()) == [1, 0]\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:159: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_ior_with_or_cond","title":"test_condition.py::test_ior_with_or_cond","text":"<pre>test_condition.py::test_ior_with_or_cond</pre><pre>\nenv = \n\n    def test_ior_with_or_cond(env):\n        def process(env):\n            cond = env.timeout(1, value=1) | env.timeout(2, value=2)\n            orig = cond\n\n            cond |= env.timeout(0, value=0)\n            assert cond is not orig\n\n            results = yield cond\n            assert list(results.values()) == [0]\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_ior_with_and_cond","title":"test_condition.py::test_ior_with_and_cond","text":"<pre>test_condition.py::test_ior_with_and_cond</pre><pre>\nenv = \n\n    def test_ior_with_and_cond(env):\n        def process(env):\n            cond = env.timeout(1, value=1) &amp; env.timeout(2, value=2)\n            orig = cond\n\n            cond |= env.timeout(0, value=0)\n            assert cond is not orig\n\n            results = yield cond\n            assert list(results.values()) == [0]\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:189: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_immutable_results","title":"test_condition.py::test_immutable_results","text":"<pre>test_condition.py::test_immutable_results</pre><pre>\nenv = \n\n    def test_immutable_results(env):\n        \"\"\"Results of conditions should not change after they have been\n        triggered.\"\"\"\n\n        def process(env):\n            timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n            # The or condition in this expression will trigger immediately. The and\n            # condition will trigger later on.\n            condition = timeout[0] | (timeout[1] &amp; timeout[2])\n\n            results = yield condition\n            assert results == {timeout[0]: 0}\n\n            # Make sure that the results of condition were frozen. The results of\n            # the nested and condition do not become visible afterwards.\n            yield env.timeout(2)\n            assert results == {timeout[0]: 0}\n\n        env.process(process(env))\n&gt;       env.run()\n\ntests/test_condition.py:211: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_shared_and_condition","title":"test_condition.py::test_shared_and_condition","text":"<pre>test_condition.py::test_shared_and_condition</pre><pre>\nenv = \n\n    def test_shared_and_condition(env):\n        timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n        c1 = timeout[0] &amp; timeout[1]\n        c2 = c1 &amp; timeout[2]\n\n        def p1(_, condition):\n            results = yield condition\n            assert results == {timeout[0]: 0, timeout[1]: 1}\n\n        def p2(_, condition):\n            results = yield condition\n            assert results == {timeout[0]: 0, timeout[1]: 1, timeout[2]: 2}\n\n        env.process(p1(env, c1))\n        env.process(p2(env, c2))\n&gt;       env.run()\n\ntests/test_condition.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_shared_or_condition","title":"test_condition.py::test_shared_or_condition","text":"<pre>test_condition.py::test_shared_or_condition</pre><pre>\nenv = \n\n    def test_shared_or_condition(env):\n        timeout = [env.timeout(delay, value=delay) for delay in range(3)]\n        c1 = timeout[0] | timeout[1]\n        c2 = c1 | timeout[2]\n\n        def p1(_, condition):\n            results = yield condition\n            assert results == {timeout[0]: 0}\n\n        def p2(_, condition):\n            results = yield condition\n            assert results == {timeout[0]: 0}\n\n        env.process(p1(env, c1))\n        env.process(p2(env, c2))\n&gt;       env.run()\n\ntests/test_condition.py:247: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_condition_value","title":"test_condition.py::test_condition_value","text":"<pre>test_condition.py::test_condition_value</pre><pre>\nenv = \n\n    def test_condition_value(env):\n        \"\"\"The value of a condition behaves like a readonly dictionary.\"\"\"\n        timeouts = [env.timeout(delay, value=delay) for delay in range(3)]\n\n        def p(env, timeouts):\n            results = yield env.all_of(timeouts)\n            assert list(results) == timeouts\n            assert list(results.keys()) == timeouts\n            assert list(results.values()) == [0, 1, 2]\n            assert list(results.items()) == list(zip(timeouts, [0, 1, 2]))\n            assert timeouts[0] in results\n            assert results[timeouts[0]] == 0\n            assert results == results  # noqa: PLR0124\n            assert results == results.todict()\n\n        env.process(p(env, timeouts))\n&gt;       env.run()\n\ntests/test_condition.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_result_order","title":"test_condition.py::test_result_order","text":"<pre>test_condition.py::test_result_order</pre><pre>\nenv = \n\n    def test_result_order(env):\n        \"\"\"The order of a conditions result is based on the order in which the\n        events have been specified.\"\"\"\n        timeouts = list(reversed([env.timeout(delay) for delay in range(3)]))\n\n        def p(env, timeouts):\n            results = yield env.all_of(timeouts)\n            assert list(results.keys()) == timeouts\n\n        env.process(p(env, timeouts))\n&gt;       env.run()\n\ntests/test_condition.py:279: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_conditionpytest_nested_result_order","title":"test_condition.py::test_nested_result_order","text":"<pre>test_condition.py::test_nested_result_order</pre><pre>\nenv = \n\n    def test_nested_result_order(env):\n        \"\"\"The order of a conditions result is based on the order in which the\n        events have been specified (even if nested).\"\"\"\n        timeouts = [env.timeout(delay) for delay in range(3)]\n        condition = (timeouts[0] | timeouts[1]) &amp; timeouts[2]\n\n        def p(_, timeouts):\n            results = yield condition\n            assert list(results.keys()) == timeouts\n\n        env.process(p(env, timeouts))\n&gt;       env.run()\n\ntests/test_condition.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_environmentpytest_event_queue_empty","title":"test_environment.py::test_event_queue_empty","text":"<pre>test_environment.py::test_event_queue_empty</pre><pre>\nenv = , log = []\n\n    def test_event_queue_empty(env, log):\n        \"\"\"The simulation should stop if there are no more events, that means, no\n        more active process.\"\"\"\n\n        def pem(env, log):\n            while env.now &lt; 2:\n                log.append(env.now)\n                yield env.timeout(1)\n\n        env.process(pem(env, log))\n&gt;       env.run(10)\n\ntests/test_environment.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_environmentpytest_run_negative_until","title":"test_environment.py::test_run_negative_until","text":"<pre>test_environment.py::test_run_negative_until</pre><pre>\nenv = \n\n    def test_run_negative_until(env):\n        \"\"\"Test passing a negative time to run.\"\"\"\n&gt;       with pytest.raises(\n            ValueError, match='must be greater than the current simulation time'\n        ):\nE       Failed: DID NOT RAISE \n\ntests/test_environment.py:26: Failed"},{"location":"analysis_baseline_simpy/#test_environmentpytest_run_resume","title":"test_environment.py::test_run_resume","text":"<pre>test_environment.py::test_run_resume</pre><pre>\nenv = \n\n    def test_run_resume(env):\n        \"\"\"Stopped simulation can be resumed.\"\"\"\n        events = [env.timeout(t) for t in (5, 10, 15)]\n\n        assert env.now == 0\n        assert not any(event.processed for event in events)\n\n&gt;       env.run(until=10)\n\ntests/test_environment.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_environmentpytest_run_until_value","title":"test_environment.py::test_run_until_value","text":"<pre>test_environment.py::test_run_until_value</pre><pre>\nenv = \n\n    def test_run_until_value(env):\n        \"\"\"Anything that can be converted to a float is a valid until value.\"\"\"\n&gt;       env.run(until='3.141592')\n\ntests/test_environment.py:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = , until = '3.141592'\n\n    def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:\n        \"\"\"Executes :meth:`step()` until the given criterion *until* is met.\n\n        - If it is ``None`` (which is the default), this method will return\n          when there are no further events to be processed.\n\n        - If it is an :class:`~simpy.events.Event`, the method will continue\n          stepping until this event has been triggered and will return its\n          value.  Raises a :exc:`RuntimeError` if there are no further events\n          to be processed and the *until* event was not triggered.\n\n        - If it is a number, the method will continue stepping\n          until the environment's time reaches *until*.\n\n        \"\"\"\n        if until is None:\n            while True:\n                try:\n                    self.step()\n                except EmptySchedule:\n                    return None\n        elif isinstance(until, Event):\n            until.callbacks.append(StopSimulation.callback)\n            try:\n                while not until.triggered:\n                    self.step()\n            except StopSimulation:\n                return until.value\n            except EmptySchedule:\n                if not until.triggered:\n                    raise RuntimeError('No scheduled events left but \"until\" event was not triggered')\n        elif isinstance(until, (int, float)):\n            try:\n                while self._now &lt; until:\n                    self.step()\n            except EmptySchedule:\n                return None\n        else:\n&gt;           raise ValueError('Invalid until parameter type')\nE           ValueError: Invalid until parameter type\n\nsrc/simpy/core.py:196: ValueError"},{"location":"analysis_baseline_simpy/#test_environmentpytest_run_with_processed_event","title":"test_environment.py::test_run_with_processed_event","text":"<pre>test_environment.py::test_run_with_processed_event</pre><pre>\nenv = \n\n    def test_run_with_processed_event(env):\n        \"\"\"An already processed event may also be passed as until value.\"\"\"\n        timeout = env.timeout(1, value='spam')\n&gt;       assert env.run(until=timeout) == 'spam'\nE       AssertionError: assert None == 'spam'\nE        +  where None = run(until=)\nE        +    where run = .run\n\ntests/test_environment.py:63: AssertionError"},{"location":"analysis_baseline_simpy/#test_environmentpytest_run_with_untriggered_event","title":"test_environment.py::test_run_with_untriggered_event","text":"<pre>test_environment.py::test_run_with_untriggered_event</pre><pre>\nenv = \n\n    def test_run_with_untriggered_event(env):\n        excinfo = pytest.raises(RuntimeError, env.run, until=env.event())\n&gt;       assert str(excinfo.value).startswith(\n            'No scheduled events left but \"until\" event was not triggered:'\n        )\nE       assert False\nE        +  where False = ('No scheduled events left but \"until\" event was not triggered:')\nE        +    where  = 'No scheduled events left but \"until\" event was not triggered'.startswith\nE        +      where 'No scheduled events left but \"until\" event was not triggered' = str(RuntimeError('No scheduled events left but \"until\" event was not triggered'))\nE        +        where RuntimeError('No scheduled events left but \"until\" event was not triggered') = .value\n\ntests/test_environment.py:75: AssertionError"},{"location":"analysis_baseline_simpy/#test_eventpytest_succeed","title":"test_event.py::test_succeed","text":"<pre>test_event.py::test_succeed</pre><pre>\nenv = \n\n    def test_succeed(env):\n        \"\"\"Test for the Environment.event() helper function.\"\"\"\n\n        def child(env, event):\n            value = yield event\n            assert value == 'ohai'\n            assert env.now == 5\n\n        def parent(env):\n            event = env.event()\n            env.process(child(env, event))\n            yield env.timeout(5)\n            event.succeed('ohai')\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_event.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_eventpytest_fail","title":"test_event.py::test_fail","text":"<pre>test_event.py::test_fail</pre><pre>\nenv = \n\n    def test_fail(env):\n        \"\"\"Test for the Environment.event() helper function.\"\"\"\n\n        def child(env, event):\n            with pytest.raises(ValueError, match='ohai'):\n                yield event\n            assert env.now == 5\n\n        def parent(env):\n            event = env.event()\n            env.process(child(env, event))\n            yield env.timeout(5)\n            event.fail(ValueError('ohai'))\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_event.py:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_eventpytest_value","title":"test_event.py::test_value","text":"<pre>test_event.py::test_value</pre><pre>\nenv = \n\n    def test_value(env):\n        \"\"\"After an event has been triggered, its value becomes accessible.\"\"\"\n        event = env.timeout(0, 'I am the value')\n\n&gt;       env.run()\n\ntests/test_event.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_eventpytest_unavailable_value","title":"test_event.py::test_unavailable_value","text":"<pre>test_event.py::test_unavailable_value</pre><pre>\nenv = \n\n    def test_unavailable_value(env):\n        \"\"\"If an event has not yet been triggered, its value is not available and\n        trying to access it will result in a AttributeError.\"\"\"\n        event = env.event()\n\n        with pytest.raises(AttributeError, match='.* is not yet available$'):\n&gt;           _ = event.value\n\ntests/test_event.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    @property\n    def value(self) -&gt;Optional[Any]:\n        \"\"\"The value of the event if it is available.\n\n        The value is available when the event has been triggered.\n\n        Raises :exc:`AttributeError` if the value is not yet available.\n\n        \"\"\"\n        if self._value is PENDING:\n&gt;           raise AttributeError('Value not yet available')\nE           AttributeError: Value not yet available. Did you mean: '_value'?\n\nsrc/simpy/events.py:132: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nenv = \n\n    def test_unavailable_value(env):\n        \"\"\"If an event has not yet been triggered, its value is not available and\n        trying to access it will result in a AttributeError.\"\"\"\n        event = env.event()\n\n&gt;       with pytest.raises(AttributeError, match='.* is not yet available$'):\nE       AssertionError: Regex pattern did not match.\nE        Regex: '.* is not yet available$'\nE        Input: 'Value not yet available'\n\ntests/test_event.py:82: AssertionError"},{"location":"analysis_baseline_simpy/#test_eventpytest_triggered","title":"test_event.py::test_triggered","text":"<pre>test_event.py::test_triggered</pre><pre>\nenv = \n\n    def test_triggered(env):\n        def pem(env, event):\n            value = yield event\n            return value\n\n        event = env.event()\n        event.succeed('i was already done')\n\n&gt;       result = env.run(env.process(pem(env, event)))\n\ntests/test_event.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:183: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_eventpytest_condition_callback_removal","title":"test_event.py::test_condition_callback_removal","text":"<pre>test_event.py::test_condition_callback_removal</pre><pre>\nenv = \n\n    def test_condition_callback_removal(env):\n        \"\"\"A condition will remove all outstanding callbacks from its events.\"\"\"\n        a, b = env.event(), env.event()\n        a.succeed()\n&gt;       env.run(until=a | b)\n\ntests/test_event.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:183: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_eventpytest_condition_nested_callback_removal","title":"test_event.py::test_condition_nested_callback_removal","text":"<pre>test_event.py::test_condition_nested_callback_removal</pre><pre>\nenv = \n\n    def test_condition_nested_callback_removal(env):\n        \"\"\"A condition will remove all outstanding callbacks from its events (even\n        if nested).\"\"\"\n        a, b, c = env.event(), env.event(), env.event()\n        b_and_c = b &amp; c\n        a_or_b_and_c = a | b_and_c\n        a.succeed()\n&gt;       env.run(until=a_or_b_and_c)\n\ntests/test_event.py:129: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:183: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_error_forwarding","title":"test_exceptions.py::test_error_forwarding","text":"<pre>test_exceptions.py::test_error_forwarding</pre><pre>\nenv = \n\n    def test_error_forwarding(env):\n        \"\"\"Exceptions are forwarded from child to parent processes if there\n        are any.\n\n        \"\"\"\n\n        def child(env):\n            raise ValueError('Onoes!')\n            yield env.timeout(1)\n\n        def parent(env):\n            with pytest.raises(ValueError, match='Onoes!'):\n                yield env.process(child(env))\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_exceptions.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_no_parent_process","title":"test_exceptions.py::test_no_parent_process","text":"<pre>test_exceptions.py::test_no_parent_process</pre><pre>\nenv = \n\n    def test_no_parent_process(env):\n        \"\"\"Exceptions should be normally raised if there are no processes waiting\n        for the one that raises something.\n\n        \"\"\"\n\n        def child(env):\n            raise ValueError('Onoes!')\n            yield env.timeout(1)\n\n        def parent(env):\n            try:\n                env.process(child(env))\n                yield env.timeout(1)\n            except Exception as err:\n                pytest.fail(f'There should be no error ({err}).')\n\n        env.process(parent(env))\n        with pytest.raises(ValueError, match='Onoes!'):\n&gt;           env.run()\n\ntests/test_exceptions.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_crashing_child_traceback","title":"test_exceptions.py::test_crashing_child_traceback","text":"<pre>test_exceptions.py::test_crashing_child_traceback</pre><pre>\nenv = \n\n    def test_crashing_child_traceback(env):\n        def panic(env):\n            yield env.timeout(1)\n            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')\n\n        def root(env):\n            try:\n                yield env.process(panic(env))\n                pytest.fail(\"Hey, where's the roflcopter?\")\n            except RuntimeError:\n                # The current frame must be visible in the stacktrace.\n                stacktrace = traceback.format_exc()\n                assert 'yield env.process(panic(env))' in stacktrace\n                assert \"raise RuntimeError('Oh noes,\" in stacktrace\n\n        env.process(root(env))\n&gt;       env.run()\n\ntests/test_exceptions.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_exception_chaining","title":"test_exceptions.py::test_exception_chaining","text":"<pre>test_exceptions.py::test_exception_chaining</pre><pre>\nenv = \n\n    def test_exception_chaining(env):\n        \"\"\"Unhandled exceptions pass through the entire event stack. This must be\n        visible in the stacktrace of the exception.\n\n        \"\"\"\n\n        def child(env):\n            yield env.timeout(1)\n            raise RuntimeError('foo')\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            yield child_proc\n\n        def grandparent(env):\n            parent_proc = env.process(parent(env))\n            yield parent_proc\n\n        env.process(grandparent(env))\n        try:\n&gt;           env.run()\n\ntests/test_exceptions.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_invalid_event","title":"test_exceptions.py::test_invalid_event","text":"<pre>test_exceptions.py::test_invalid_event</pre><pre>\nenv = \n\n    def test_invalid_event(env):\n        \"\"\"Invalid yield values will cause the simulation to fail.\"\"\"\n\n        def root(_):\n            yield None\n\n        env.process(root(env))\n        with pytest.raises(RuntimeError, match='Invalid yield value \"None\"'):\n&gt;           env.run()\n\ntests/test_exceptions.py:151: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_exception_handling","title":"test_exceptions.py::test_exception_handling","text":"<pre>test_exceptions.py::test_exception_handling</pre><pre>\nenv = \n\n    def test_exception_handling(env):\n        \"\"\"If failed events are not defused (which is the default) the simulation\n        crashes.\"\"\"\n\n        event = env.event()\n        event.fail(RuntimeError())\n        with pytest.raises(RuntimeError):\n&gt;           env.run(until=1)\n\ntests/test_exceptions.py:161: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_callback_exception_handling","title":"test_exceptions.py::test_callback_exception_handling","text":"<pre>test_exceptions.py::test_callback_exception_handling</pre><pre>\nenv = \n\n    def test_callback_exception_handling(env):\n        \"\"\"Callbacks of events may handle exception by setting the ``defused``\n        attribute of ``event`` to ``True``.\"\"\"\n\n        def callback(event):\n            event.defused = True\n\n        event = env.event()\n        event.callbacks.append(callback)\n        event.fail(RuntimeError())\n        assert not event.defused, 'Event has been defused immediately'\n&gt;       env.run(until=1)\n\ntests/test_exceptions.py:175: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_process_exception_handling","title":"test_exceptions.py::test_process_exception_handling","text":"<pre>test_exceptions.py::test_process_exception_handling</pre><pre>\nenv = \n\n    def test_process_exception_handling(env):\n        \"\"\"Processes can't ignore failed events and auto-handle exceptions.\"\"\"\n\n        def pem(_, event):\n            try:\n                yield event\n                pytest.fail('Hey, the event should fail!')\n            except RuntimeError:\n                pass\n\n        event = env.event()\n        env.process(pem(env, event))\n        event.fail(RuntimeError())\n\n        assert not event.defused, 'Event has been defused immediately'\n&gt;       env.run(until=1)\n\ntests/test_exceptions.py:194: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_process_exception_chaining","title":"test_exceptions.py::test_process_exception_chaining","text":"<pre>test_exceptions.py::test_process_exception_chaining</pre><pre>\nenv = \n\n    def test_process_exception_chaining(env):\n        \"\"\"Because multiple processes can be waiting for an event, exceptions of\n        failed events are copied before being thrown into a process. Otherwise, the\n        traceback of the exception gets modified by a process.\n\n        See https://bitbucket.org/simpy/simpy/issue/60 for more details.\"\"\"\n        import traceback\n\n        def process_a(event):\n            try:\n                yield event\n            except RuntimeError:\n                stacktrace = traceback.format_exc()\n                assert 'process_b' not in stacktrace\n\n        def process_b(event):\n            try:\n                yield event\n            except RuntimeError:\n                stacktrace = traceback.format_exc()\n                assert 'process_a' not in stacktrace\n\n        event = env.event()\n        event.fail(RuntimeError('foo'))\n\n        env.process(process_a(event))\n        env.process(process_b(event))\n\n&gt;       env.run()\n\ntests/test_exceptions.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_exceptionspytest_sys_excepthook","title":"test_exceptions.py::test_sys_excepthook","text":"<pre>test_exceptions.py::test_sys_excepthook</pre><pre>\nenv = \n\n    def test_sys_excepthook(env):\n        \"\"\"Check that the default exception hook reports exception chains.\"\"\"\n\n        def process_a(event):\n            yield event\n\n        def process_b(event):\n            yield event\n\n        event = env.event()\n        event.fail(RuntimeError('foo'))\n\n        env.process(process_b(env.process(process_a(event))))\n\n        try:\n&gt;           env.run()\n\ntests/test_exceptions.py:244: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nenv = \n\n    def test_sys_excepthook(env):\n        \"\"\"Check that the default exception hook reports exception chains.\"\"\"\n\n        def process_a(event):\n            yield event\n\n        def process_b(event):\n            yield event\n\n        event = env.event()\n        event.fail(RuntimeError('foo'))\n\n        env.process(process_b(env.process(process_a(event))))\n\n        try:\n            env.run()\n        except BaseException:\n            # Let the default exception hook print the traceback to the redirected\n            # standard error channel.\n            import sys\n            from io import StringIO\n\n            stderr, sys.stderr = sys.stderr, StringIO()\n\n            typ, e, tb = sys.exc_info()\n            assert typ is not None\n            assert e is not None\n            sys.excepthook(typ, e, tb)\n\n            traceback = sys.stderr.getvalue()\n\n            sys.stderr = stderr\n\n            # Check if frames of process_a and process_b are visible in the\n            # traceback.\n&gt;           assert 'process_a' in traceback\nE           assert 'process_a' in 'Traceback (most recent call last):\\n  File \"/testbed/tests/test_exceptions.py\", line 244, in test_sys_excepthook\\n   ..._callback(event)\\nAttributeError: \\'Initialize\\' object has no attribute \\'_callback\\'. Did you mean: \\'callbacks\\'?\\n'\n\ntests/test_exceptions.py:264: AssertionError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_interruption","title":"test_interrupts.py::test_interruption","text":"<pre>test_interrupts.py::test_interruption</pre><pre>\nenv = \n\n    def test_interruption(env):\n        \"\"\"Processes can be interrupted while waiting for other events.\"\"\"\n\n        def interruptee(env):\n            with pytest.raises(simpy.Interrupt, match='interrupt!'):\n                yield env.timeout(10)\n\n        def interruptor(env):\n            child_process = env.process(interruptee(env))\n            yield env.timeout(5)\n            child_process.interrupt('interrupt!')\n\n        env.process(interruptor(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_concurrent_interrupts","title":"test_interrupts.py::test_concurrent_interrupts","text":"<pre>test_interrupts.py::test_concurrent_interrupts</pre><pre>\nenv = , log = []\n\n    def test_concurrent_interrupts(env, log):\n        \"\"\"Concurrent interrupts are scheduled in the order in which they\n        occurred.\n\n        \"\"\"\n\n        def fox(env, log):\n            while True:\n                try:\n                    yield env.timeout(10)\n                except simpy.Interrupt as interrupt:\n                    log.append((env.now, interrupt.cause))\n\n        def farmer(env, name, fox):\n            fox.interrupt(name)\n            yield env.timeout(1)\n\n        fantastic_mr_fox = env.process(fox(env, log))\n        for name in ('boggis', 'bunce', 'beans'):\n            env.process(farmer(env, name, fantastic_mr_fox))\n\n&gt;       env.run(20)\n\ntests/test_interrupts.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_concurrent_interrupts_and_events","title":"test_interrupts.py::test_concurrent_interrupts_and_events","text":"<pre>test_interrupts.py::test_concurrent_interrupts_and_events</pre><pre>\nenv = , log = []\n\n    def test_concurrent_interrupts_and_events(env, log):\n        \"\"\"Interrupts interrupt a process while waiting for an event. Even if the\n        event has happened concurrently with the interrupt.\"\"\"\n\n        def fox(env, coup, log):\n            while True:\n                try:\n                    yield coup\n                    log.append(f'coup completed at {env.now}')\n                except simpy.Interrupt:\n                    log.append(f'coup interrupted at {env.now}')\n                else:\n                    return\n\n        def master_plan(env, fox, coup):\n            yield env.timeout(1)\n            # Succeed and interrupt concurrently.\n            coup.succeed()\n            fox.interrupt()\n\n        coup = env.event()\n        fantastic_mr_fox = env.process(fox(env, coup, log))\n        env.process(master_plan(env, fantastic_mr_fox, coup))\n\n&gt;       env.run(5)\n\ntests/test_interrupts.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_init_interrupt","title":"test_interrupts.py::test_init_interrupt","text":"<pre>test_interrupts.py::test_init_interrupt</pre><pre>\nenv = \n\n    def test_init_interrupt(env):\n        \"\"\"An interrupt should always be executed after the Initialize event at the\n        same time.\"\"\"\n\n        def child(env):\n            try:\n                yield env.timeout(10)\n                pytest.fail('Should have been interrupted.')\n            except simpy.Interrupt:\n                assert env.now == 0\n\n        def root(env):\n            child_proc = env.process(child(env))\n            child_proc.interrupt()\n\n            yield env.timeout(1)\n\n        env.process(root(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_interrupt_terminated_process","title":"test_interrupts.py::test_interrupt_terminated_process","text":"<pre>test_interrupts.py::test_interrupt_terminated_process</pre><pre>\nenv = \n\n    def test_interrupt_terminated_process(env):\n        \"\"\"Dead processes cannot be interrupted.\"\"\"\n\n        def child(env):\n            yield env.timeout(1)\n\n        def parent(env):\n            child_proc = env.process(child(env))\n\n            # Wait long enough so that child_proc terminates.\n            yield env.timeout(2)\n            ei = pytest.raises(RuntimeError, child_proc.interrupt)\n            assert re.match(\n                r' has terminated '\n                r'and cannot be interrupted.',\n                ei.value.args[0],\n            )\n\n            yield env.timeout(1)\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_multiple_interrupts","title":"test_interrupts.py::test_multiple_interrupts","text":"<pre>test_interrupts.py::test_multiple_interrupts</pre><pre>\nenv = \n\n    def test_multiple_interrupts(env):\n        \"\"\"Interrupts on dead processes are discarded. If there are multiple\n        concurrent interrupts on a process and the latter dies after\n        handling the first interrupt, the remaining ones are silently\n        ignored.\n\n        \"\"\"\n\n        def child(env):\n            try:\n                yield env.timeout(1)\n            except simpy.Interrupt as i:\n                return i.cause\n\n        def parent(env):\n            c = env.process(child(env))\n            yield env.timeout(0)\n            c.interrupt(1)\n            c.interrupt(2)\n            result = yield c\n            assert result == 1\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:149: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_interrupt_self","title":"test_interrupts.py::test_interrupt_self","text":"<pre>test_interrupts.py::test_interrupt_self</pre><pre>\nenv = \n\n    def test_interrupt_self(env):\n        \"\"\"A process should not be able to interrupt itself.\"\"\"\n\n        def pem(env):\n            pytest.raises(RuntimeError, env.active_process.interrupt)\n            yield env.timeout(0)\n\n        env.process(pem(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_immediate_interrupt","title":"test_interrupts.py::test_immediate_interrupt","text":"<pre>test_interrupts.py::test_immediate_interrupt</pre><pre>\nenv = , log = []\n\n    def test_immediate_interrupt(env, log):\n        \"\"\"Processes are immediately interruptable.\"\"\"\n\n        def child(env, log):\n            try:\n                yield env.event()\n            except simpy.Interrupt:\n                log.append(env.now)\n\n        def parent(env, log):\n            child_proc = env.process(child(env, log))\n            child_proc.interrupt()\n            return\n            yield\n\n        env.process(parent(env, log))\n&gt;       env.run()\n\ntests/test_interrupts.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_interrupt_event","title":"test_interrupts.py::test_interrupt_event","text":"<pre>test_interrupts.py::test_interrupt_event</pre><pre>\nenv = \n\n    def test_interrupt_event(env):\n        \"\"\"A process should be interruptable while waiting for an Event.\"\"\"\n\n        def child(env):\n            try:\n                yield env.event()\n            except simpy.Interrupt:\n                assert env.now == 5\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            yield env.timeout(5)\n            child_proc.interrupt()\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_interrupts.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_interruptspytest_concurrent_behaviour","title":"test_interrupts.py::test_concurrent_behaviour","text":"<pre>test_interrupts.py::test_concurrent_behaviour</pre><pre>\nenv = \n\n    def test_concurrent_behaviour(env):\n        def proc_a(env):\n            timeouts = [env.timeout(0) for i in range(2)]\n            while timeouts:\n                with pytest.raises(simpy.Interrupt):\n                    yield timeouts.pop(0)\n\n        def proc_b(_, proc_a):\n            for _ in range(2):\n                proc_a.interrupt()\n            return\n            yield\n\n        proc_a = env.process(proc_a(env))\n        env.process(proc_b(env, proc_a))\n\n&gt;       env.run()\n\ntests/test_interrupts.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_get_state","title":"test_process.py::test_get_state","text":"<pre>test_process.py::test_get_state</pre><pre>\nenv = \n\n    def test_get_state(env):\n        \"\"\"A process is alive until it's generator has not terminated.\"\"\"\n\n        def pem_a(env):\n            yield env.timeout(3)\n\n        def pem_b(env, pem_a):\n            yield env.timeout(1)\n            assert pem_a.is_alive\n\n            yield env.timeout(3)\n            assert not pem_a.is_alive\n\n        proc_a = env.process(pem_a(env))\n        env.process(pem_b(env, proc_a))\n&gt;       env.run()\n\ntests/test_process.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_target","title":"test_process.py::test_target","text":"<pre>test_process.py::test_target</pre><pre>\nenv = \n\n    def test_target(env):\n        def pem(env, event):\n            yield event\n\n        event = env.timeout(5)\n        proc = env.process(pem(env, event))\n\n        # Wait until \"proc\" is initialized and yielded the event\n        while env.peek() &lt; 5:\n&gt;           env.step()\n\ntests/test_process.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_wait_for_proc","title":"test_process.py::test_wait_for_proc","text":"<pre>test_process.py::test_wait_for_proc</pre><pre>\nenv = \n\n    def test_wait_for_proc(env):\n        \"\"\"A process can wait until another process finishes.\"\"\"\n\n        def finisher(env):\n            yield env.timeout(5)\n\n        def waiter(env, finisher):\n            proc = env.process(finisher(env))\n            yield proc  # Waits until \"proc\" finishes\n\n            assert env.now == 5\n\n        env.process(waiter(env, finisher))\n&gt;       env.run()\n\ntests/test_process.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_return_value","title":"test_process.py::test_return_value","text":"<pre>test_process.py::test_return_value</pre><pre>\nenv = \n\n    def test_return_value(env):\n        \"\"\"Processes can set a return value.\"\"\"\n\n        def child(env):\n            yield env.timeout(1)\n            return env.now\n\n        def parent(env):\n            result1 = yield env.process(child(env))\n            result2 = yield env.process(child(env))\n\n            assert [result1, result2] == [1, 2]\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_process.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_child_exception","title":"test_process.py::test_child_exception","text":"<pre>test_process.py::test_child_exception</pre><pre>\nenv = \n\n    def test_child_exception(env):\n        \"\"\"A child catches an exception and sends it to its parent.\"\"\"\n\n        def child(env):\n            yield env.timeout(1)\n            return RuntimeError('Onoes!')\n\n        def parent(env):\n            result = yield env.process(child(env))\n            assert isinstance(result, Exception)\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_process.py:98: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_interrupted_join","title":"test_process.py::test_interrupted_join","text":"<pre>test_process.py::test_interrupted_join</pre><pre>\nenv = \n\n    def test_interrupted_join(env):\n        \"\"\"Interrupts remove a process from the callbacks of its target.\"\"\"\n\n        def interruptor(env, process):\n            yield env.timeout(1)\n            process.interrupt()\n\n        def child(env):\n            yield env.timeout(2)\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            try:\n                yield child_proc\n                pytest.fail('Did not receive an interrupt.')\n            except Interrupt:\n                assert env.now == 1\n                assert child_proc.is_alive\n\n                # We should not get resumed when child terminates.\n                yield env.timeout(5)\n                assert env.now == 6\n\n        parent_proc = env.process(parent(env))\n        env.process(interruptor(env, parent_proc))\n&gt;       env.run()\n\ntests/test_process.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_processpytest_interrupted_join_and_rejoin","title":"test_process.py::test_interrupted_join_and_rejoin","text":"<pre>test_process.py::test_interrupted_join_and_rejoin</pre><pre>\nenv = \n\n    def test_interrupted_join_and_rejoin(env):\n        \"\"\"Tests that interrupts are raised while the victim is waiting for\n        another process. The victim tries to join again.\n\n        \"\"\"\n\n        def interruptor(env, process):\n            yield env.timeout(1)\n            process.interrupt()\n\n        def child(env):\n            yield env.timeout(2)\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            try:\n                yield child_proc\n                pytest.fail('Did not receive an interrupt.')\n            except Interrupt:\n                assert env.now == 1\n                assert child_proc.is_alive\n\n                yield child_proc\n                assert env.now == 2\n\n        parent_proc = env.process(parent(env))\n        env.process(interruptor(env, parent_proc))\n&gt;       env.run()\n\ntests/test_process.py:156: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource","title":"test_resources.py::test_resource","text":"<pre>test_resources.py::test_resource</pre><pre>\nenv = , log = []\n\n    def test_resource(env, log):\n        \"\"\"A *resource* is something with a limited numer of slots that need\n        to be requested before and released after the usage (e.g., gas pumps\n        at a gas station).\n\n        \"\"\"\n\n        def pem(env, name, resource, log):\n            req = resource.request()\n            yield req\n            assert resource.count == 1\n\n            yield env.timeout(1)\n            resource.release(req)\n\n            log.append((name, env.now))\n\n        resource = simpy.Resource(env, capacity=1)\n        assert resource.capacity == 1\n        assert resource.count == 0\n        env.process(pem(env, 'a', resource, log))\n        env.process(pem(env, 'b', resource, log))\n&gt;       env.run()\n\ntests/test_resources.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_context_manager","title":"test_resources.py::test_resource_context_manager","text":"<pre>test_resources.py::test_resource_context_manager</pre><pre>\nenv = , log = []\n\n    def test_resource_context_manager(env, log):\n        \"\"\"The event that ``Resource.request()`` returns can be used as\n        Context Manager.\"\"\"\n\n        def pem(env, name, resource, log):\n            with resource.request() as request:\n                yield request\n                yield env.timeout(1)\n\n            log.append((name, env.now))\n\n        resource = simpy.Resource(env, capacity=1)\n        env.process(pem(env, 'a', resource, log))\n        env.process(pem(env, 'b', resource, log))\n&gt;       env.run()\n\ntests/test_resources.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_slots","title":"test_resources.py::test_resource_slots","text":"<pre>test_resources.py::test_resource_slots</pre><pre>\nenv = , log = []\n\n    def test_resource_slots(env, log):\n        def pem(env, name, resource, log):\n            with resource.request() as req:\n                yield req\n                log.append((name, env.now))\n                yield env.timeout(1)\n\n        resource = simpy.Resource(env, capacity=3)\n        for i in range(9):\n            env.process(pem(env, str(i), resource, log))\n&gt;       env.run()\n\ntests/test_resources.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_continue_after_interrupt","title":"test_resources.py::test_resource_continue_after_interrupt","text":"<pre>test_resources.py::test_resource_continue_after_interrupt</pre><pre>\nenv = \n\n    def test_resource_continue_after_interrupt(env):\n        \"\"\"A process may be interrupted while waiting for a resource but\n        should be able to continue waiting afterwards.\"\"\"\n\n        def pem(env, res):\n            with res.request() as req:\n                yield req\n                yield env.timeout(1)\n\n        def victim(env, res):\n            evt = res.request()\n            try:\n                yield evt\n                pytest.fail('Should not have gotten the resource.')\n            except simpy.Interrupt:\n                yield evt\n                res.release(evt)\n                assert env.now == 1\n\n        def interruptor(proc):\n            proc.interrupt()\n            return 0\n            yield\n\n        res = simpy.Resource(env, 1)\n        env.process(pem(env, res))\n        proc = env.process(victim(env, res))\n        env.process(interruptor(proc))\n&gt;       env.run()\n\ntests/test_resources.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_release_after_interrupt","title":"test_resources.py::test_resource_release_after_interrupt","text":"<pre>test_resources.py::test_resource_release_after_interrupt</pre><pre>\nenv = \n\n    def test_resource_release_after_interrupt(env):\n        \"\"\"A process needs to release a resource, even if it was interrupted\n        and does not continue to wait for it.\"\"\"\n\n        def blocker(env, res):\n            with res.request() as req:\n                yield req\n                yield env.timeout(1)\n\n        def victim(env, res):\n            evt = res.request()\n            try:\n                yield evt\n                pytest.fail('Should not have gotten the resource.')\n            except simpy.Interrupt:\n                # Don't wait for the resource\n                res.release(evt)\n                assert env.now == 0\n\n        def interruptor(proc):\n            proc.interrupt()\n            return 0\n            yield\n\n        res = simpy.Resource(env, 1)\n        env.process(blocker(env, res))\n        victim_proc = env.process(victim(env, res))\n        env.process(interruptor(victim_proc))\n&gt;       env.run()\n\ntests/test_resources.py:151: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_immediate_requests","title":"test_resources.py::test_resource_immediate_requests","text":"<pre>test_resources.py::test_resource_immediate_requests</pre><pre>\nenv = \n\n    def test_resource_immediate_requests(env):\n        \"\"\"A process must not acquire a resource if it releases it and immediately\n        requests it again while there are already other requesting processes.\"\"\"\n\n        def child(env, res):\n            result = []\n            for _ in range(3):\n                with res.request() as req:\n                    yield req\n                    result.append(env.now)\n                    yield env.timeout(1)\n            return result\n\n        def parent(env):\n            res = simpy.Resource(env, 1)\n            child_a = env.process(child(env, res))\n            child_b = env.process(child(env, res))\n\n            a_acquire_times = yield child_a\n            b_acquire_times = yield child_b\n\n            assert a_acquire_times == [0, 2, 4]\n            assert b_acquire_times == [1, 3, 5]\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_resources.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_cm_exception","title":"test_resources.py::test_resource_cm_exception","text":"<pre>test_resources.py::test_resource_cm_exception</pre><pre>\nenv = , log = []\n\n    def test_resource_cm_exception(env, log):\n        \"\"\"Resource with context manager receives an exception.\"\"\"\n\n        def process(env, resource, log, raise_):\n            with resource.request() as req:\n                yield req\n                yield env.timeout(1)\n                log.append(env.now)\n                if raise_:\n                    with pytest.raises(ValueError, match='Foo'):\n                        raise ValueError('Foo')\n\n        resource = simpy.Resource(env, 1)\n        env.process(process(env, resource, log, True))\n        # The second process is used to check if it was able to access the\n        # resource:\n        env.process(process(env, resource, log, False))\n&gt;       env.run()\n\ntests/test_resources.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_with_condition","title":"test_resources.py::test_resource_with_condition","text":"<pre>test_resources.py::test_resource_with_condition</pre><pre>\nenv = \n\n    def test_resource_with_condition(env):\n        def process(env, resource):\n            with resource.request() as res_event:\n                result = yield res_event | env.timeout(1)\n                assert res_event in result\n\n        resource = simpy.Resource(env, 1)\n        env.process(process(env, resource))\n&gt;       env.run()\n\ntests/test_resources.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_resource_with_priority_queue","title":"test_resources.py::test_resource_with_priority_queue","text":"<pre>test_resources.py::test_resource_with_priority_queue</pre><pre>\nenv = \n\n    def test_resource_with_priority_queue(env):\n        def process(env, delay, resource, priority, res_time):\n            yield env.timeout(delay)\n            req = resource.request(priority=priority)\n            yield req\n            assert env.now == res_time\n            yield env.timeout(5)\n            resource.release(req)\n\n        resource = simpy.PriorityResource(env, capacity=1)\n        env.process(process(env, 0, resource, 2, 0))\n        env.process(process(env, 2, resource, 3, 10))\n        env.process(process(env, 2, resource, 3, 15))  # Test equal priority\n        env.process(process(env, 4, resource, 1, 5))\n&gt;       env.run()\n\ntests/test_resources.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_sorted_queue_maxlen","title":"test_resources.py::test_sorted_queue_maxlen","text":"<pre>test_resources.py::test_sorted_queue_maxlen</pre><pre>\nenv = \n\n    def test_sorted_queue_maxlen(env):\n        \"\"\"Requests must fail if more than *maxlen* requests happen\n        concurrently.\"\"\"\n        resource = simpy.PriorityResource(env, capacity=1)\n        resource.put_queue.maxlen = 1  # pyright: ignore\n\n        def process(env, resource):\n            # The first request immediately triggered and does not enter the queue.\n            resource.request(priority=1)\n            # The second request is enqueued.\n            resource.request(priority=1)\n            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):\n                # The third request will now fail.\n                resource.request(priority=1)\n            yield env.timeout(0)\n\n        env.process(process(env, resource))\n&gt;       env.run()\n\ntests/test_resources.py:249: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_get_users","title":"test_resources.py::test_get_users","text":"<pre>test_resources.py::test_get_users</pre><pre>\nenv = \n\n    def test_get_users(env):\n        def process(env, resource):\n            with resource.request() as req:\n                yield req\n                yield env.timeout(1)\n\n        resource = simpy.Resource(env, 1)\n        procs = [env.process(process(env, resource)) for _ in range(3)]\n&gt;       env.run(until=1)\n\ntests/test_resources.py:260: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_preemptive_resource","title":"test_resources.py::test_preemptive_resource","text":"<pre>test_resources.py::test_preemptive_resource</pre><pre>\nenv = \n\n    def test_preemptive_resource(env):\n        \"\"\"Processes with a higher priority may preempt requests of lower priority\n        processes. Note that higher priorities are indicated by a lower number\n        value.\"\"\"\n\n        def proc_a(_, resource, prio):\n            try:\n                with resource.request(priority=prio) as req:\n                    yield req\n                    pytest.fail('Should have received an interrupt/preemption.')\n            except simpy.Interrupt:\n                pass\n\n        def proc_b(_, resource, prio):\n            with resource.request(priority=prio) as req:\n                yield req\n\n        resource = simpy.PreemptiveResource(env, 1)\n        env.process(proc_a(env, resource, 1))\n        env.process(proc_b(env, resource, 0))\n\n&gt;       env.run()\n\ntests/test_resources.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_preemptive_resource_timeout_0","title":"test_resources.py::test_preemptive_resource_timeout_0","text":"<pre>test_resources.py::test_preemptive_resource_timeout_0</pre><pre>\nenv = \n\n    def test_preemptive_resource_timeout_0(env):\n        def proc_a(env, resource, prio):\n            with resource.request(priority=prio) as req:\n                try:\n                    yield req\n                    yield env.timeout(1)\n                    pytest.fail('Should have received an interrupt/preemption.')\n                except simpy.Interrupt:\n                    pass\n            yield env.event()\n\n        def proc_b(_, resource, prio):\n            with resource.request(priority=prio) as req:\n                yield req\n\n        resource = simpy.PreemptiveResource(env, 1)\n        env.process(proc_a(env, resource, 1))\n        env.process(proc_b(env, resource, 0))\n\n&gt;       env.run()\n\ntests/test_resources.py:315: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_mixed_preemption","title":"test_resources.py::test_mixed_preemption","text":"<pre>test_resources.py::test_mixed_preemption</pre><pre>\nenv = , log = []\n\n    def test_mixed_preemption(env, log):\n        def p(id, env, res, delay, prio, preempt, log):\n            yield env.timeout(delay)\n            with res.request(priority=prio, preempt=preempt) as req:\n                try:\n                    yield req\n                    yield env.timeout(2)\n                    log.append((env.now, id))\n                except simpy.Interrupt as ir:\n                    assert ir is not None  # noqa: PT017\n                    assert isinstance(ir.cause, Preempted)  # noqa: PT017\n                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))\n\n        res = simpy.PreemptiveResource(env, 1)\n        # p0: First user:\n        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))\n        # p1: Waits (cannot preempt):\n        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))\n        # p2: Waits later, but has a higher prio:\n        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))\n        # p3: Preempt the above proc:\n        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))\n        # p4: Wait again:\n        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))\n\n&gt;       env.run()\n\ntests/test_resources.py:343: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_nested_preemption","title":"test_resources.py::test_nested_preemption","text":"<pre>test_resources.py::test_nested_preemption</pre><pre>\nenv = , log = []\n\n    def test_nested_preemption(env, log):\n        def process(id, env, res, delay, prio, preempt, log):\n            yield env.timeout(delay)\n            with res.request(priority=prio, preempt=preempt) as req:\n                try:\n                    yield req\n                    yield env.timeout(5)\n                    log.append((env.now, id))\n                except simpy.Interrupt as ir:\n                    assert isinstance(ir.cause, Preempted)  # noqa: PT017\n                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))\n\n        def process2(id, env, res0, res1, delay, prio, preempt, log):\n            yield env.timeout(delay)\n            with res0.request(priority=prio, preempt=preempt) as req0:\n                try:\n                    yield req0\n                    with res1.request(priority=prio, preempt=preempt) as req1:\n                        try:\n                            yield req1\n                            yield env.timeout(5)\n                            log.append((env.now, id))\n                        except simpy.Interrupt as ir:\n                            assert isinstance(ir.cause, Preempted)  # noqa: PT017\n                            log.append(\n                                (\n                                    env.now,\n                                    id,\n                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),\n                                )\n                            )\n                except simpy.Interrupt as ir:\n                    assert isinstance(ir.cause, Preempted)  # noqa: PT017\n                    log.append(\n                        (\n                            env.now,\n                            id,\n                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),\n                        )\n                    )\n\n        res0 = simpy.PreemptiveResource(env, 1)\n        res1 = simpy.PreemptiveResource(env, 1)\n\n        env.process(process2(0, env, res0, res1, 0, -1, True, log))\n        p1 = env.process(process(1, env, res1, 1, -2, True, log))\n\n        env.process(process2(2, env, res0, res1, 20, -1, True, log))\n        p3 = env.process(process(3, env, res0, 21, -2, True, log))\n\n        env.process(process2(4, env, res0, res1, 21, -1, True, log))\n\n&gt;       env.run()\n\ntests/test_resources.py:406: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_container","title":"test_resources.py::test_container","text":"<pre>test_resources.py::test_container</pre><pre>\nenv = , log = []\n\n    def test_container(env, log):\n        \"\"\"A *container* is a resource (of optionally limited capacity) where\n        you can put in our take-out a discrete or continuous amount of\n        things (e.g., a box of lump sugar or a can of milk).  The *put* and\n        *get* operations block if the buffer is to full or to empty. If they\n        return, the process knows that the *put* or *get* operation was\n        successful.\n\n        \"\"\"\n\n        def putter(env, buf, log):\n            yield env.timeout(1)\n            while True:\n                yield buf.put(2)\n                log.append(('p', env.now))\n                yield env.timeout(1)\n\n        def getter(env, buf, log):\n            yield buf.get(1)\n            log.append(('g', env.now))\n\n            yield env.timeout(1)\n            yield buf.get(1)\n            log.append(('g', env.now))\n\n        buf = simpy.Container(env, init=0, capacity=2)\n        env.process(putter(env, buf, log))\n        env.process(getter(env, buf, log))\n&gt;       env.run(until=5)\n\ntests/test_resources.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_container_get_queued","title":"test_resources.py::test_container_get_queued","text":"<pre>test_resources.py::test_container_get_queued</pre><pre>\nenv = \n\n    def test_container_get_queued(env):\n        def proc(env, wait, container, what):\n            yield env.timeout(wait)\n            with getattr(container, what)(1) as req:\n                yield req\n\n        container = simpy.Container(env, 1)\n        p0 = env.process(proc(env, 0, container, 'get'))\n        env.process(proc(env, 1, container, 'put'))\n        env.process(proc(env, 1, container, 'put'))\n        p3 = env.process(proc(env, 1, container, 'put'))\n\n&gt;       env.run(until=1)\n\ntests/test_resources.py:467: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_store","title":"test_resources.py::test_store","text":"<pre>test_resources.py::test_store</pre><pre>\nenv = \n\n    def test_store(env):\n        \"\"\"A store models the production and consumption of concrete python\n        objects (in contrast to containers, where you only now if the *put*\n        or *get* operations were successful but don't get concrete\n        objects).\n\n        \"\"\"\n\n        def putter(_, store, item):\n            yield store.put(item)\n\n        def getter(_, store, orig_item):\n            item = yield store.get()\n            assert item is orig_item\n\n        store = simpy.Store(env, capacity=2)\n        item = object()\n\n        # NOTE: Does the start order matter? Need to test this.\n        env.process(putter(env, store, item))\n        env.process(getter(env, store, item))\n&gt;       env.run()\n\ntests/test_resources.py:535: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_store_capacity","title":"test_resources.py::test_store_capacity","text":"<pre>test_resources.py::test_store_capacity</pre><pre>\nenv = \n\n    def test_store_capacity(env):\n        with pytest.raises(ValueError, match='\"capacity\" must be &gt; 0'):\n            simpy.Store(env, 0)\n        with pytest.raises(ValueError, match='\"capacity\" must be &gt; 0'):\n            simpy.Store(env, -1)\n\n        capacity = 2\n        store = simpy.Store(env, capacity)\n        env.process(store.put(i) for i in range(capacity + 1))\n&gt;       env.run()\n\ntests/test_resources.py:559: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_store_cancel","title":"test_resources.py::test_store_cancel","text":"<pre>test_resources.py::test_store_cancel</pre><pre>\nenv = \n\n    def test_store_cancel(env):\n        store = simpy.Store(env, capacity=1)\n\n        def acquire_implicit_cancel():\n            with store.get():\n                yield env.timeout(1)\n                # implicit cancel() when exiting with-block\n\n        env.process(acquire_implicit_cancel())\n&gt;       env.run()\n\ntests/test_resources.py:574: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_priority_store_item_priority","title":"test_resources.py::test_priority_store_item_priority","text":"<pre>test_resources.py::test_priority_store_item_priority</pre><pre>\nenv = \n\n    def test_priority_store_item_priority(env):\n        pstore = simpy.PriorityStore(env, 3)\n        log = []\n\n        def getter(wait):\n            yield env.timeout(wait)\n            item = yield pstore.get()\n            log.append(item)\n\n        # Do not specify priority; the items themselves will be compared to\n        # determine priority.\n        env.process(pstore.put(s) for s in 'bcadefg')\n        env.process(getter(1))\n        env.process(getter(2))\n        env.process(getter(3))\n&gt;       env.run()\n\ntests/test_resources.py:592: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_priority_store_stable_order","title":"test_resources.py::test_priority_store_stable_order","text":"<pre>test_resources.py::test_priority_store_stable_order</pre><pre>\nenv = \n\n    def test_priority_store_stable_order(env):\n        pstore = simpy.PriorityStore(env, 3)\n        log = []\n\n        def getter(wait):\n            yield env.timeout(wait)\n            _, item = yield pstore.get()\n            log.append(item)\n\n        items = [object() for _ in range(3)]\n\n        # Unorderable items are inserted with same priority.\n        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)\n        env.process(getter(1))\n        env.process(getter(2))\n        env.process(getter(3))\n&gt;       env.run()\n\ntests/test_resources.py:612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_filter_store","title":"test_resources.py::test_filter_store","text":"<pre>test_resources.py::test_filter_store</pre><pre>\nenv = \n\n    def test_filter_store(env):\n        def pem(env):\n            store = simpy.FilterStore(env, capacity=2)\n\n            get_event = store.get(lambda item: item == 'b')\n            yield store.put('a')\n            assert not get_event.triggered\n            yield store.put('b')\n            assert get_event.triggered\n\n        env.process(pem(env))\n&gt;       env.run()\n\ntests/test_resources.py:630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_filter_store_get_after_mismatch","title":"test_resources.py::test_filter_store_get_after_mismatch","text":"<pre>test_resources.py::test_filter_store_get_after_mismatch</pre><pre>\nenv = \n\n    def test_filter_store_get_after_mismatch(env):\n        \"\"\"Regression test for issue #49.\n\n        Triggering get-events after a put in FilterStore wrongly breaks after the\n        first mismatch.\n\n        \"\"\"\n\n        def putter(env, store):\n            # The order of putting 'spam' before 'eggs' is important here.\n            yield store.put('spam')\n            yield env.timeout(1)\n            yield store.put('eggs')\n\n        def getter(store):\n            # The order of requesting 'eggs' before 'spam' is important here.\n            eggs = store.get(lambda i: i == 'eggs')\n            spam = store.get(lambda i: i == 'spam')\n\n            ret = yield spam | eggs\n            assert spam in ret\n            assert eggs not in ret\n            assert env.now == 0\n\n            yield eggs\n            assert env.now == 1\n\n        store = simpy.FilterStore(env, capacity=2)\n        env.process(getter(store))\n        env.process(putter(env, store))\n&gt;       env.run()\n\ntests/test_resources.py:663: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_filter_calls_best_case","title":"test_resources.py::test_filter_calls_best_case","text":"<pre>test_resources.py::test_filter_calls_best_case</pre><pre>\nenv = \n\n    def test_filter_calls_best_case(env):\n        \"\"\"The filter function is called every item in the store until a match is\n        found. In the best case the first item already matches.\"\"\"\n        log = []\n\n        def log_filter(item):\n            log.append(f'check {item}')\n            return True\n\n        store = simpy.FilterStore(env)\n        store.items = [1, 2, 3]\n\n        def getter(store):\n            log.append(f'get {yield store.get(log_filter)}')\n            log.append(f'get {yield store.get(log_filter)}')\n            log.append(f'get {yield store.get(log_filter)}')\n\n        env.process(getter(store))\n&gt;       env.run()\n\ntests/test_resources.py:684: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_filter_calls_worst_case","title":"test_resources.py::test_filter_calls_worst_case","text":"<pre>test_resources.py::test_filter_calls_worst_case</pre><pre>\nenv = \n\n    def test_filter_calls_worst_case(env):\n        \"\"\"In the worst case the filter function is being called for items multiple\n        times.\"\"\"\n\n        log = []\n        store = simpy.FilterStore(env)\n\n        def putter(store):\n            for i in range(4):\n                log.append(f'put {i}')\n                yield store.put(i)\n\n        def log_filter(item):\n            log.append(f'check {item}')\n            return item &gt;= 3\n\n        def getter(store):\n            log.append(f'get {yield store.get(log_filter)}')\n\n        env.process(getter(store))\n        env.process(putter(store))\n&gt;       env.run()\n\ntests/test_resources.py:710: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_immediate_put_request","title":"test_resources.py::test_immediate_put_request","text":"<pre>test_resources.py::test_immediate_put_request</pre><pre>\nenv = \n\n    def test_immediate_put_request(env):\n        \"\"\"Put requests that can be fulfilled immediately do not enter the put\n        queue.\"\"\"\n        resource = simpy.Resource(env, capacity=1)\n        assert len(resource.users) == 0\n        assert len(resource.queue) == 0\n\n        # The resource is empty, the first request will succeed immediately without\n        # entering the queue.\n&gt;       request = resource.request()\n\ntests/test_resources.py:733: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/resources/resource.py:74: in __init__\n    super().__init__(resource)\nsrc/simpy/resources/base.py:39: in __init__\n    resource._trigger_put(None)\nsrc/simpy/resources/base.py:199: in _trigger_put\n    if not self._do_put(put_event):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nevent = \n\n    def _do_put(self, event: PutType) -&gt;Optional[bool]:\n        \"\"\"Perform the *put* operation.\n\n        This method needs to be implemented by subclasses. If the conditions\n        for the put *event* are met, the method must trigger the event (e.g.\n        call :meth:`Event.succeed()` with an appropriate value).\n\n        This method is called by :meth:`_trigger_put` for every event in the\n        :attr:`put_queue`, as long as the return value does not evaluate\n        ``False``.\n        \"\"\"\n&gt;       raise NotImplementedError(\"The _do_put() method has to be implemented by subclasses.\")\nE       NotImplementedError: The _do_put() method has to be implemented by subclasses.\n\nsrc/simpy/resources/base.py:186: NotImplementedError"},{"location":"analysis_baseline_simpy/#test_resourcespytest_immediate_get_request","title":"test_resources.py::test_immediate_get_request","text":"<pre>test_resources.py::test_immediate_get_request</pre><pre>\nenv = \n\n    def test_immediate_get_request(env):\n        \"\"\"Get requests that can be fulfilled immediately do not enter the get\n        queue.\"\"\"\n        container = simpy.Container(env)\n        # Put something in the container, this request is triggered immediately\n        # without entering the queue.\n&gt;       request = container.put(1)\n\ntests/test_resources.py:751: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/resources/container.py:30: in __init__\n    super().__init__(container)\nsrc/simpy/resources/base.py:39: in __init__\n    resource._trigger_put(None)\nsrc/simpy/resources/base.py:199: in _trigger_put\n    if not self._do_put(put_event):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nevent = \n\n    def _do_put(self, event: PutType) -&gt;Optional[bool]:\n        \"\"\"Perform the *put* operation.\n\n        This method needs to be implemented by subclasses. If the conditions\n        for the put *event* are met, the method must trigger the event (e.g.\n        call :meth:`Event.succeed()` with an appropriate value).\n\n        This method is called by :meth:`_trigger_put` for every event in the\n        :attr:`put_queue`, as long as the return value does not evaluate\n        ``False``.\n        \"\"\"\n&gt;       raise NotImplementedError(\"The _do_put() method has to be implemented by subclasses.\")\nE       NotImplementedError: The _do_put() method has to be implemented by subclasses.\n\nsrc/simpy/resources/base.py:186: NotImplementedError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt01","title":"test_rt.py::test_rt[0.1]","text":"<pre>test_rt.py::test_rt[0.1]</pre><pre>\nlog = [], factor = 0.1\n\n    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])\n    def test_rt(log, factor):\n        \"\"\"Basic tests for run().\"\"\"\n        start = monotonic()\n        env = RealtimeEnvironment(factor=factor)\n        env.process(process(env, log, 0.01, 1))\n        env.process(process(env, log, 0.02, 1))\n\n&gt;       env.run(2)\n\ntests/test_rt.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n            sleep(expected_real_time - real_time)\n        elif self._strict and real_time &gt; expected_real_time:\n&gt;           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\nE           RuntimeError: Simulation too slow: 0.000 seconds late\n\nsrc/simpy/rt.py:74: RuntimeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt005","title":"test_rt.py::test_rt[0.05]","text":"<pre>test_rt.py::test_rt[0.05]</pre><pre>\nlog = [], factor = 0.05\n\n    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])\n    def test_rt(log, factor):\n        \"\"\"Basic tests for run().\"\"\"\n        start = monotonic()\n        env = RealtimeEnvironment(factor=factor)\n        env.process(process(env, log, 0.01, 1))\n        env.process(process(env, log, 0.02, 1))\n\n&gt;       env.run(2)\n\ntests/test_rt.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n            sleep(expected_real_time - real_time)\n        elif self._strict and real_time &gt; expected_real_time:\n&gt;           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\nE           RuntimeError: Simulation too slow: 0.000 seconds late\n\nsrc/simpy/rt.py:74: RuntimeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt015","title":"test_rt.py::test_rt[0.15]","text":"<pre>test_rt.py::test_rt[0.15]</pre><pre>\nlog = [], factor = 0.15\n\n    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])\n    def test_rt(log, factor):\n        \"\"\"Basic tests for run().\"\"\"\n        start = monotonic()\n        env = RealtimeEnvironment(factor=factor)\n        env.process(process(env, log, 0.01, 1))\n        env.process(process(env, log, 0.02, 1))\n\n&gt;       env.run(2)\n\ntests/test_rt.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n            sleep(expected_real_time - real_time)\n        elif self._strict and real_time &gt; expected_real_time:\n&gt;           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\nE           RuntimeError: Simulation too slow: 0.000 seconds late\n\nsrc/simpy/rt.py:74: RuntimeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt_multiple_call","title":"test_rt.py::test_rt_multiple_call","text":"<pre>test_rt.py::test_rt_multiple_call</pre><pre>\nlog = []\n\n    def test_rt_multiple_call(log):\n        \"\"\"Test multiple calls to run().\"\"\"\n        start = monotonic()\n        env = RealtimeEnvironment(factor=0.05)\n\n        env.process(process(env, log, 0.01, 2))\n        env.process(process(env, log, 0.01, 3))\n\n&gt;       env.run(5)\n\ntests/test_rt.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n            sleep(expected_real_time - real_time)\n        elif self._strict and real_time &gt; expected_real_time:\n&gt;           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\nE           RuntimeError: Simulation too slow: 0.000 seconds late\n\nsrc/simpy/rt.py:74: RuntimeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt_slow_sim_default_behavior","title":"test_rt.py::test_rt_slow_sim_default_behavior","text":"<pre>test_rt.py::test_rt_slow_sim_default_behavior</pre><pre>\nlog = []\n\n    def test_rt_slow_sim_default_behavior(log):\n        \"\"\"By default, SimPy should raise an error if a simulation is too\n        slow for the selected real-time factor.\"\"\"\n        env = RealtimeEnvironment(factor=0.05)\n        env.process(process(env, log, 0.1, 1))\n\n        err = pytest.raises(RuntimeError, env.run, 3)\n&gt;       assert 'Simulation too slow for real time' in str(err.value)\nE       AssertionError: assert 'Simulation too slow for real time' in 'Simulation too slow: 0.000 seconds late'\nE        +  where 'Simulation too slow: 0.000 seconds late' = str(RuntimeError('Simulation too slow: 0.000 seconds late'))\nE        +    where RuntimeError('Simulation too slow: 0.000 seconds late') = .value\n\ntests/test_rt.py:68: AssertionError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt_slow_sim_no_error","title":"test_rt.py::test_rt_slow_sim_no_error","text":"<pre>test_rt.py::test_rt_slow_sim_no_error</pre><pre>\nlog = []\n\n    def test_rt_slow_sim_no_error(log):\n        \"\"\"Test ignoring slow simulations.\"\"\"\n        start = monotonic()\n        env = RealtimeEnvironment(factor=0.05, strict=False)\n        env.process(process(env, log, 0.1, 1))\n\n&gt;       env.run(2)\n\ntests/test_rt.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\nsrc/simpy/rt.py:76: in step\n    super().step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt_illegal_until","title":"test_rt.py::test_rt_illegal_until","text":"<pre>test_rt.py::test_rt_illegal_until</pre><pre>\ndef test_rt_illegal_until():\n        \"\"\"Test illegal value for *until*.\"\"\"\n        env = RealtimeEnvironment()\n&gt;       with pytest.raises(\n            ValueError,\n            match=r'until \\(-1\\) must be greater than the current simulation time',\n        ):\nE       Failed: DID NOT RAISE \n\ntests/test_rt.py:88: Failed"},{"location":"analysis_baseline_simpy/#test_rtpytest_rt_sync","title":"test_rt.py::test_rt_sync","text":"<pre>test_rt.py::test_rt_sync</pre><pre>\nlog = []\n\n    def test_rt_sync(log):\n        \"\"\"Test resetting the internal wall-clock reference time.\"\"\"\n        env = RealtimeEnvironment(factor=0.05)\n        env.process(process(env, log, 0.01))\n        sleep(0.06)  # Simulate massive workload :-)\n        env.sync()\n&gt;       env.run(3)\n\ntests/test_rt.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n            sleep(expected_real_time - real_time)\n        elif self._strict and real_time &gt; expected_real_time:\n&gt;           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\nE           RuntimeError: Simulation too slow: 0.000 seconds late\n\nsrc/simpy/rt.py:74: RuntimeError"},{"location":"analysis_baseline_simpy/#test_rtpytest_run_with_untriggered_event","title":"test_rt.py::test_run_with_untriggered_event","text":"<pre>test_rt.py::test_run_with_untriggered_event</pre><pre>\nenv = \n\n    def test_run_with_untriggered_event(env):\n        env = RealtimeEnvironment(factor=0.05)\n&gt;       excinfo = pytest.raises(RuntimeError, env.run, until=env.event())\n\ntests/test_rt.py:106: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:183: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event after enough real-time has passed for the\n        event to happen.\n\n        The delay is scaled according to the real-time :attr:`factor`. With\n        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if\n        the event is processed too slowly.\n\n        \"\"\"\n        try:\n            evt_time = self.peek()\n        except EmptySchedule:\n            return\n\n        real_time = monotonic()\n        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n\n        if real_time &lt; expected_real_time:\n&gt;           sleep(expected_real_time - real_time)\nE           OverflowError: timestamp too large to convert to C _PyTime_t\n\nsrc/simpy/rt.py:72: OverflowError"},{"location":"analysis_baseline_simpy/#test_timeoutpytest_discrete_time_steps","title":"test_timeout.py::test_discrete_time_steps","text":"<pre>test_timeout.py::test_discrete_time_steps</pre><pre>\nenv = , log = []\n\n    def test_discrete_time_steps(env, log):\n        \"\"\"envple envulation with discrete time steps.\"\"\"\n\n        def pem(env, log):\n            while True:\n                log.append(env.now)\n                yield env.timeout(delay=1)\n\n        env.process(pem(env, log))\n&gt;       env.run(until=3)\n\ntests/test_timeout.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:192: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_timeoutpytest_negative_timeout","title":"test_timeout.py::test_negative_timeout","text":"<pre>test_timeout.py::test_negative_timeout</pre><pre>\nenv = \n\n    def test_negative_timeout(env):\n        \"\"\"Don't allow negative timeout times.\"\"\"\n\n        def pem(env):\n            yield env.timeout(-1)\n\n        env.process(pem(env))\n        with pytest.raises(ValueError, match='Negative delay'):\n&gt;           env.run()\n\ntests/test_timeout.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_timeoutpytest_timeout_value","title":"test_timeout.py::test_timeout_value","text":"<pre>test_timeout.py::test_timeout_value</pre><pre>\nenv = \n\n    def test_timeout_value(env):\n        \"\"\"You can pass an additional *value* to *timeout* which will be\n        directly yielded back into the PEM. This is useful to implement some\n        kinds of resources or other additions.\n\n        See :class:`envpy.resources.Store` for an example.\n\n        \"\"\"\n\n        def pem(env):\n            val = yield env.timeout(1, 'ohai')\n            assert val == 'ohai'\n\n        env.process(pem(env))\n&gt;       env.run()\n\ntests/test_timeout.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_timeoutpytest_shared_timeout","title":"test_timeout.py::test_shared_timeout","text":"<pre>test_timeout.py::test_shared_timeout</pre><pre>\nenv = , log = []\n\n    def test_shared_timeout(env, log):\n        def child(env, timeout, id, log):\n            yield timeout\n            log.append((id, env.now))\n\n        timeout = env.timeout(1)\n        for i in range(3):\n            env.process(child(env, timeout, i, log))\n\n&gt;       env.run()\n\ntests/test_timeout.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_timeoutpytest_triggered_timeout","title":"test_timeout.py::test_triggered_timeout","text":"<pre>test_timeout.py::test_triggered_timeout</pre><pre>\nenv = \n\n    def test_triggered_timeout(env):\n        def process(env):\n            def child(env, event):\n                value = yield event\n                return value\n\n            event = env.timeout(1, 'i was already done')\n            # Start the child after the timeout has already happened.\n            yield env.timeout(2)\n            value = yield env.process(child(env, event))\n            assert value == 'i was already done'\n\n&gt;       env.run(env.process(process(env)))\n\ntests/test_timeout.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:183: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_start_delayed","title":"test_util.py::test_start_delayed","text":"<pre>test_util.py::test_start_delayed</pre><pre>\nenv = \n\n    def test_start_delayed(env):\n        def pem(env):\n            assert env.now == 5\n            yield env.timeout(1)\n\n        start_delayed(env, pem(env), delay=5)\n&gt;       env.run()\n\ntests/test_util.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_subscribe","title":"test_util.py::test_subscribe","text":"<pre>test_util.py::test_subscribe</pre><pre>\nenv = \n\n    def test_subscribe(env):\n        \"\"\"Check async. interrupt if a process terminates.\"\"\"\n\n        def child(env):\n            yield env.timeout(3)\n            return 'ohai'\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            subscribe_at(child_proc)\n\n            try:\n                yield env.event()\n            except Interrupt as interrupt:\n                assert interrupt.cause is not None  # noqa: PT017\n                assert interrupt.cause[0] is child_proc  # noqa: PT017\n                assert interrupt.cause[1] == 'ohai'  # noqa: PT017\n                assert env.now == 3\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_subscribe_terminated_proc","title":"test_util.py::test_subscribe_terminated_proc","text":"<pre>test_util.py::test_subscribe_terminated_proc</pre><pre>\nenv = \n\n    def test_subscribe_terminated_proc(env):\n        \"\"\"subscribe() proc should send a signal immediately if\n        \"other\" has already terminated.\n\n        \"\"\"\n\n        def child(env):\n            yield env.timeout(1)\n\n        def parent(env):\n            child_proc = env.process(child(env))\n            yield env.timeout(2)\n            pytest.raises(RuntimeError, subscribe_at, child_proc)\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_subscribe_with_join","title":"test_util.py::test_subscribe_with_join","text":"<pre>test_util.py::test_subscribe_with_join</pre><pre>\nenv = \n\n    def test_subscribe_with_join(env):\n        \"\"\"Test that subscribe() works if a process waits for another one.\"\"\"\n\n        def child(env, i):\n            yield env.timeout(i)\n\n        def parent(env):\n            child_proc1 = env.process(child(env, 1))\n            child_proc2 = env.process(child(env, 2))\n            try:\n                subscribe_at(child_proc1)\n                yield child_proc2\n            except Interrupt as interrupt:\n                assert env.now == 1\n                assert interrupt.cause is not None  # noqa: PT017\n                assert interrupt.cause[0] is child_proc1  # noqa: PT017\n                assert child_proc2.is_alive\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:91: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_subscribe_at_timeout","title":"test_util.py::test_subscribe_at_timeout","text":"<pre>test_util.py::test_subscribe_at_timeout</pre><pre>\nenv = \n\n    def test_subscribe_at_timeout(env):\n        \"\"\"You should be able to subscribe at arbitrary events.\"\"\"\n\n        def pem(env):\n            to = env.timeout(2)\n            subscribe_at(to)\n            try:\n                yield env.timeout(10)\n            except Interrupt as interrupt:\n                assert interrupt.cause == (to, None)  # noqa: PT017\n                assert env.now == 2\n\n        env.process(pem(env))\n&gt;       env.run()\n\ntests/test_util.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_subscribe_at_timeout_with_value","title":"test_util.py::test_subscribe_at_timeout_with_value","text":"<pre>test_util.py::test_subscribe_at_timeout_with_value</pre><pre>\nenv = \n\n    def test_subscribe_at_timeout_with_value(env):\n        \"\"\"An event's value should be accessible via the interrupt cause.\"\"\"\n\n        def pem(env):\n            val = 'ohai'\n            to = env.timeout(2, value=val)\n            subscribe_at(to)\n            try:\n                yield env.timeout(10)\n            except Interrupt as interrupt:\n                assert interrupt.cause == (to, val)  # noqa: PT017\n                assert env.now == 2\n\n        env.process(pem(env))\n&gt;       env.run()\n\ntests/test_util.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of","title":"test_util.py::test_all_of","text":"<pre>test_util.py::test_all_of</pre><pre>\nenv = \n\n    def test_all_of(env):\n        \"\"\"Wait for all events to be triggered.\"\"\"\n\n        def parent(env):\n            # Start 10 events.\n            events = [env.timeout(i, value=i) for i in range(10)]\n            results = yield env.all_of(events)\n\n            assert results == {events[i]: i for i in range(10)}\n            assert env.now == 9\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of_generator","title":"test_util.py::test_all_of_generator","text":"<pre>test_util.py::test_all_of_generator</pre><pre>\nenv = \n\n    def test_all_of_generator(env):\n        \"\"\"Conditions also work with generators.\"\"\"\n\n        def parent(env):\n            # Start 10 events.\n            events = (env.timeout(i, value=i) for i in range(10))\n            results = yield env.all_of(events)\n\n            assert list(results.values()) == list(range(10))\n            assert env.now == 9\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:154: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_wait_for_all_with_errors","title":"test_util.py::test_wait_for_all_with_errors","text":"<pre>test_util.py::test_wait_for_all_with_errors</pre><pre>\nenv = \n\n    def test_wait_for_all_with_errors(env):\n        \"\"\"On default AllOf should fail immediately if one of its events\n        fails.\"\"\"\n\n        def child_with_error(env, value):\n            yield env.timeout(value)\n            raise RuntimeError('crashing')\n\n        def parent(env):\n            events = [\n                env.timeout(1, value=1),\n                env.process(child_with_error(env, 2)),\n                env.timeout(3, value=3),\n            ]\n\n            condition = env.all_of(events)\n            with pytest.raises(RuntimeError, match='crashing'):\n                yield condition\n\n            # Although the condition has failed, interim values are available.\n            assert condition._events[0].value == 1\n            assert condition._events[1].value.args[0] == 'crashing'\n            # The last child has not terminated yet.\n            assert not events[2].processed\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of_chaining","title":"test_util.py::test_all_of_chaining","text":"<pre>test_util.py::test_all_of_chaining</pre><pre>\nenv = \n\n    def test_all_of_chaining(env):\n        \"\"\"If a wait_for_all condition A is chained to a wait_for_all condition B,\n        B will be merged into A.\"\"\"\n\n        def parent(env):\n            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])\n            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])\n\n            condition_a &amp;= condition_b\n\n            results = yield condition_a\n            assert list(results.values()) == [0, 1, 0, 1]\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of_chaining_intermediate_results","title":"test_util.py::test_all_of_chaining_intermediate_results","text":"<pre>test_util.py::test_all_of_chaining_intermediate_results</pre><pre>\nenv = \n\n    def test_all_of_chaining_intermediate_results(env):\n        \"\"\"If a wait_for_all condition A with intermediate results is merged into\n        another wait_for_all condition B, the results are copied into condition\n        A.\"\"\"\n\n        def parent(env):\n            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])\n            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])\n\n            yield env.timeout(0)\n\n            condition = condition_a &amp; condition_b\n            result = ConditionValue()\n            condition._populate_value(result)\n            assert list(result.values()) == [0, 0]\n\n            results = yield condition\n            assert list(results.values()) == [0, 1, 0, 1]\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:223: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of_with_triggered_events","title":"test_util.py::test_all_of_with_triggered_events","text":"<pre>test_util.py::test_all_of_with_triggered_events</pre><pre>\nenv = \n\n    def test_all_of_with_triggered_events(env):\n        \"\"\"Processed events can be added to a condition. Confirm this with\n        all_of.\"\"\"\n\n        def parent(env):\n            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]\n            yield env.timeout(2)\n\n            values = list((yield env.all_of(events)).values())\n            assert values == ['spam', 'eggs']\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_any_of","title":"test_util.py::test_any_of","text":"<pre>test_util.py::test_any_of</pre><pre>\nenv = \n\n    def test_any_of(env):\n        \"\"\"Wait for any event to be triggered.\"\"\"\n\n        def parent(env):\n            # Start 10 events.\n            events = [env.timeout(i, value=i) for i in range(10)]\n            results = yield env.any_of(events)\n\n            assert results == {events[0]: 0}\n            assert env.now == 0\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:253: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_any_of_with_errors","title":"test_util.py::test_any_of_with_errors","text":"<pre>test_util.py::test_any_of_with_errors</pre><pre>\nenv = \n\n    def test_any_of_with_errors(env):\n        \"\"\"On default any_of should fail if the event has failed too.\"\"\"\n\n        def child_with_error(env, value):\n            yield env.timeout(value)\n            raise RuntimeError('crashing')\n\n        def parent(env):\n            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]\n            condition = env.any_of(events)\n            with pytest.raises(RuntimeError, match='crashing'):\n                yield condition\n\n            assert condition._events[0].value.args[0] == 'crashing'\n            # The last event has not terminated yet.\n            assert not events[1].processed\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:274: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_any_of_chaining","title":"test_util.py::test_any_of_chaining","text":"<pre>test_util.py::test_any_of_chaining</pre><pre>\nenv = \n\n    def test_any_of_chaining(env):\n        \"\"\"If a any_of condition A is chained to a any_of condition B,\n        B will be merged into A.\"\"\"\n\n        def parent(env):\n            condition_a = env.any_of([env.timeout(2, value='a')])\n            condition_b = env.any_of([env.timeout(1, value='b')])\n\n            condition_a |= condition_b\n\n            results = yield condition_a\n            assert list(results.values()) == ['b']\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:291: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_any_of_with_triggered_events","title":"test_util.py::test_any_of_with_triggered_events","text":"<pre>test_util.py::test_any_of_with_triggered_events</pre><pre>\nenv = \n\n    def test_any_of_with_triggered_events(env):\n        \"\"\"Processed events can be added to a condition. Confirm this with\n        all_of.\"\"\"\n\n        def parent(env):\n            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]\n            yield env.timeout(2)\n\n            values = list((yield env.any_of(events)).values())\n            assert values == ['spam', 'eggs']\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:306: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_empty_any_of","title":"test_util.py::test_empty_any_of","text":"<pre>test_util.py::test_empty_any_of</pre><pre>\nenv = \n\n    def test_empty_any_of(env):\n        \"\"\"AnyOf will trigger immediately if there are no events.\"\"\"\n\n        def parent(env):\n            results = yield env.any_of([])\n            assert results == {}\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:317: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_empty_all_of","title":"test_util.py::test_empty_all_of","text":"<pre>test_util.py::test_empty_all_of</pre><pre>\nenv = \n\n    def test_empty_all_of(env):\n        \"\"\"AllOf will trigger immediately if there are no events.\"\"\"\n\n        def parent(env):\n            results = yield env.all_of([])\n            assert results == {}\n\n        env.process(parent(env))\n&gt;       env.run()\n\ntests/test_util.py:328: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#test_utilpytest_all_of_expansion","title":"test_util.py::test_all_of_expansion","text":"<pre>test_util.py::test_all_of_expansion</pre><pre>\nenv = \n\n    def test_all_of_expansion(env):\n        \"\"\"The result of AllOf is an OrderedDict, which allows to expand its values\n        directly into variables.\"\"\"\n\n        def p(env):\n            timeouts = [env.timeout(d, d) for d in [3, 2, 1]]\n            a, b, c = (yield env.all_of(timeouts)).values()\n            assert a == 3\n            assert b == 2\n            assert c == 1\n\n        env.process(p(env))\n&gt;       env.run()\n\ntests/test_util.py:343: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/simpy/core.py:176: in run\n    self.step()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def step(self) -&gt;None:\n        \"\"\"Process the next event.\n\n        Raise an :exc:`EmptySchedule` if no further events are available.\n\n        \"\"\"\n        try:\n            self._now, _, _, event = heappop(self._queue)\n        except IndexError:\n            raise EmptySchedule()\n\n        # Process the event\n        event._ok = True\n&gt;       event._value = event._callback(event)\nE       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?\n\nsrc/simpy/core.py:150: AttributeError"},{"location":"analysis_baseline_simpy/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/src/simpy/core.py b/src/simpy/core.py\nindex 10c88fb..b39ddef 100644\n--- a/src/simpy/core.py\n+++ b/src/simpy/core.py\n@@ -34,7 +34,10 @@ class BoundClass(Generic[T]):\n     def bind_early(instance: object) -&gt;None:\n         \"\"\"Bind all :class:`BoundClass` attributes of the *instance's* class\n         to the instance itself to increase performance.\"\"\"\n-        pass\n+        cls = type(instance)\n+        for name, obj in cls.__dict__.items():\n+            if isinstance(obj, BoundClass):\n+                setattr(instance, name, obj.__get__(instance, cls))\n\n\n class EmptySchedule(Exception):\n@@ -49,7 +52,7 @@ class StopSimulation(Exception):\n     def callback(cls, event: Event) -&gt;None:\n         \"\"\"Used as callback in :meth:`Environment.run()` to stop the simulation\n         when the *until* event occurred.\"\"\"\n-        pass\n+        raise cls()\n\n\n SimTime = Union[int, float]\n@@ -77,12 +80,12 @@ class Environment:\n     @property\n     def now(self) -&gt;SimTime:\n         \"\"\"The current simulation time.\"\"\"\n-        pass\n+        return self._now\n\n     @property\n     def active_process(self) -&gt;Optional[Process]:\n         \"\"\"The currently active process of the environment.\"\"\"\n-        pass\n+        return self._active_proc\n     if TYPE_CHECKING:\n\n         def process(self, generator: ProcessGenerator) -&gt;Process:\n@@ -121,12 +124,15 @@ class Environment:\n     def schedule(self, event: Event, priority: EventPriority=NORMAL, delay:\n         SimTime=0) -&gt;None:\n         \"\"\"Schedule an *event* with a given *priority* and a *delay*.\"\"\"\n-        pass\n+        heappush(self._queue, (self._now + delay, priority, next(self._eid), event))\n\n     def peek(self) -&gt;SimTime:\n         \"\"\"Get the time of the next scheduled event. Return\n         :data:`~simpy.core.Infinity` if there is no further event.\"\"\"\n-        pass\n+        try:\n+            return self._queue[0][0]\n+        except IndexError:\n+            return Infinity\n\n     def step(self) -&gt;None:\n         \"\"\"Process the next event.\n@@ -134,7 +140,20 @@ class Environment:\n         Raise an :exc:`EmptySchedule` if no further events are available.\n\n         \"\"\"\n-        pass\n+        try:\n+            self._now, _, _, event = heappop(self._queue)\n+        except IndexError:\n+            raise EmptySchedule()\n+\n+        # Process the event\n+        event._ok = True\n+        event._value = event._callback(event)\n+        event._processed = True\n+\n+        if isinstance(event, Process):\n+            self._active_proc = event\n+        else:\n+            self._active_proc = None\n\n     def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:\n         \"\"\"Executes :meth:`step()` until the given criterion *until* is met.\n@@ -151,4 +170,27 @@ class Environment:\n           until the environment's time reaches *until*.\n\n         \"\"\"\n-        pass\n+        if until is None:\n+            while True:\n+                try:\n+                    self.step()\n+                except EmptySchedule:\n+                    return None\n+        elif isinstance(until, Event):\n+            until.callbacks.append(StopSimulation.callback)\n+            try:\n+                while not until.triggered:\n+                    self.step()\n+            except StopSimulation:\n+                return until.value\n+            except EmptySchedule:\n+                if not until.triggered:\n+                    raise RuntimeError('No scheduled events left but \"until\" event was not triggered')\n+        elif isinstance(until, (int, float)):\n+            try:\n+                while self._now &lt; until:\n+                    self.step()\n+            except EmptySchedule:\n+                return None\n+        else:\n+            raise ValueError('Invalid until parameter type')\ndiff --git a/src/simpy/events.py b/src/simpy/events.py\nindex 128ed75..2781b3f 100644\n--- a/src/simpy/events.py\n+++ b/src/simpy/events.py\n@@ -75,19 +75,19 @@ class Event:\n\n     def _desc(self) -&gt;str:\n         \"\"\"Return a string *Event()*.\"\"\"\n-        pass\n+        return 'Event()'\n\n     @property\n     def triggered(self) -&gt;bool:\n         \"\"\"Becomes ``True`` if the event has been triggered and its callbacks\n         are about to be invoked.\"\"\"\n-        pass\n+        return self._value is not PENDING\n\n     @property\n     def processed(self) -&gt;bool:\n         \"\"\"Becomes ``True`` if the event has been processed (e.g., its\n         callbacks have been invoked).\"\"\"\n-        pass\n+        return self.callbacks is None\n\n     @property\n     def ok(self) -&gt;bool:\n@@ -98,7 +98,9 @@ class Event:\n         :raises AttributeError: if accessed before the event is triggered.\n\n         \"\"\"\n-        pass\n+        if self._value is PENDING:\n+            raise AttributeError('Event has not yet been triggered')\n+        return self._ok\n\n     @property\n     def defused(self) -&gt;bool:\n@@ -115,7 +117,7 @@ class Event:\n         processed by the :class:`~simpy.core.Environment`.\n\n         \"\"\"\n-        pass\n+        return self._defused\n\n     @property\n     def value(self) -&gt;Optional[Any]:\n@@ -126,7 +128,9 @@ class Event:\n         Raises :exc:`AttributeError` if the value is not yet available.\n\n         \"\"\"\n-        pass\n+        if self._value is PENDING:\n+            raise AttributeError('Value not yet available')\n+        return self._value\n\n     def trigger(self, event: Event) -&gt;None:\n         \"\"\"Trigger the event with the state and value of the provided *event*.\n@@ -136,7 +140,10 @@ class Event:\n         chain reactions.\n\n         \"\"\"\n-        pass\n+        self._ok = event._ok\n+        self._value = event._value\n+        self._defused = event._defused\n+        self.env.schedule(self)\n\n     def succeed(self, value: Optional[Any]=None) -&gt;Event:\n         \"\"\"Set the event's value, mark it as successful and schedule it for\n@@ -145,7 +152,12 @@ class Event:\n         Raises :exc:`RuntimeError` if this event has already been triggerd.\n\n         \"\"\"\n-        pass\n+        if self._value is not PENDING:\n+            raise RuntimeError('Event has already been triggered')\n+        self._ok = True\n+        self._value = value\n+        self.env.schedule(self)\n+        return self\n\n     def fail(self, exception: Exception) -&gt;Event:\n         \"\"\"Set *exception* as the events value, mark it as failed and schedule\n@@ -156,7 +168,15 @@ class Event:\n         Raises :exc:`RuntimeError` if this event has already been triggered.\n\n         \"\"\"\n-        pass\n+        if not isinstance(exception, Exception):\n+            raise TypeError('exception must be an Exception instance')\n+        if self._value is not PENDING:\n+            raise RuntimeError('Event has already been triggered')\n+        self._ok = False\n+        self._value = exception\n+        self._defused = False\n+        self.env.schedule(self)\n+        return self\n\n     def __and__(self, other: Event) -&gt;Condition:\n         \"\"\"Return a :class:`~simpy.events.Condition` that will be triggered if\n@@ -197,7 +217,8 @@ class Timeout(Event):\n\n     def _desc(self) -&gt;str:\n         \"\"\"Return a string *Timeout(delay[, value=value])*.\"\"\"\n-        pass\n+        value_str = f', value={self._value!r}' if self._value is not None else ''\n+        return f'Timeout({self._delay}{value_str})'\n\n\n class Initialize(Event):\n@@ -267,7 +288,7 @@ class Process(Event):\n\n     def _desc(self) -&gt;str:\n         \"\"\"Return a string *Process(process_func_name)*.\"\"\"\n-        pass\n+        return f'Process({self._generator.__name__})'\n\n     @property\n     def target(self) -&gt;Event:\n@@ -277,17 +298,17 @@ class Process(Event):\n         interrupted.\n\n         \"\"\"\n-        pass\n+        return self._target\n\n     @property\n     def name(self) -&gt;str:\n         \"\"\"Name of the function used to start the process.\"\"\"\n-        pass\n+        return self._generator.__name__\n\n     @property\n     def is_alive(self) -&gt;bool:\n         \"\"\"``True`` until the process generator exits.\"\"\"\n-        pass\n+        return self._value is PENDING\n\n     def interrupt(self, cause: Optional[Any]=None) -&gt;None:\n         \"\"\"Interrupt this process optionally providing a *cause*.\n@@ -297,7 +318,12 @@ class Process(Event):\n         cases.\n\n         \"\"\"\n-        pass\n+        if not self.is_alive:\n+            raise RuntimeError(f'{self} has terminated and cannot be interrupted.')\n+        if self is self.env.active_process:\n+            raise RuntimeError('A process is not allowed to interrupt itself.')\n+        \n+        Interruption(self, cause)\n\n     def _resume(self, event: Event) -&gt;None:\n         \"\"\"Resumes the execution of the process with the value of *event*. If\n@@ -383,16 +409,24 @@ class Condition(Event):\n\n     def _desc(self) -&gt;str:\n         \"\"\"Return a string *Condition(evaluate, [events])*.\"\"\"\n-        pass\n+        return f'Condition({self._evaluate.__name__}, {self._events})'\n\n     def _populate_value(self, value: ConditionValue) -&gt;None:\n         \"\"\"Populate the *value* by recursively visiting all nested\n         conditions.\"\"\"\n-        pass\n+        for event in self._events:\n+            if isinstance(event, Condition):\n+                event._populate_value(value)\n+            elif event.callbacks is None:\n+                value.events.append(event)\n\n     def _build_value(self, event: Event) -&gt;None:\n         \"\"\"Build the value of this condition.\"\"\"\n-        pass\n+        if not self._ok:\n+            return\n+        value = ConditionValue()\n+        self._populate_value(value)\n+        self._value = value\n\n     def _remove_check_callbacks(self) -&gt;None:\n         \"\"\"Remove _check() callbacks from events recursively.\n@@ -403,24 +437,36 @@ class Condition(Event):\n         untriggered events.\n\n         \"\"\"\n-        pass\n+        for event in self._events:\n+            if event.callbacks and self._check in event.callbacks:\n+                event.callbacks.remove(self._check)\n+            if isinstance(event, Condition):\n+                event._remove_check_callbacks()\n\n     def _check(self, event: Event) -&gt;None:\n         \"\"\"Check if the condition was already met and schedule the *event* if\n         so.\"\"\"\n-        pass\n+        if self._value is not PENDING:\n+            return\n+\n+        self._count += 1\n+\n+        if self._evaluate(self._events, self._count):\n+            self._ok = True\n+            self.env.schedule(self)\n+            self._remove_check_callbacks()\n\n     @staticmethod\n     def all_events(events: Tuple[Event, ...], count: int) -&gt;bool:\n         \"\"\"An evaluation function that returns ``True`` if all *events* have\n         been triggered.\"\"\"\n-        pass\n+        return len(events) == count\n\n     @staticmethod\n     def any_events(events: Tuple[Event, ...], count: int) -&gt;bool:\n         \"\"\"An evaluation function that returns ``True`` if at least one of\n         *events* has been triggered.\"\"\"\n-        pass\n+        return count &gt; 0\n\n\n class AllOf(Condition):\n@@ -447,4 +493,7 @@ class AnyOf(Condition):\n\n def _describe_frame(frame: FrameType) -&gt;str:\n     \"\"\"Print filename, line number and function name of a stack frame.\"\"\"\n-    pass\n+    filename = frame.f_code.co_filename\n+    lineno = frame.f_lineno\n+    funcname = frame.f_code.co_name\n+    return f'{filename}:{lineno}, in {funcname}'\ndiff --git a/src/simpy/exceptions.py b/src/simpy/exceptions.py\nindex d45300e..beef1b2 100644\n--- a/src/simpy/exceptions.py\n+++ b/src/simpy/exceptions.py\n@@ -31,4 +31,4 @@ class Interrupt(SimPyException):\n     @property\n     def cause(self) -&gt;Optional[Any]:\n         \"\"\"The cause of the interrupt or ``None`` if no cause was provided.\"\"\"\n-        pass\n+        return self.args[0] if self.args else None\ndiff --git a/src/simpy/resources/base.py b/src/simpy/resources/base.py\nindex a7d0b96..ccedb56 100644\n--- a/src/simpy/resources/base.py\n+++ b/src/simpy/resources/base.py\n@@ -58,7 +58,8 @@ class Put(Event, ContextManager['Put'], Generic[ResourceType]):\n         method is called automatically.\n\n         \"\"\"\n-        pass\n+        if not self.triggered:\n+            self.resource.put_queue.remove(self)\n\n\n class Get(Event, ContextManager['Get'], Generic[ResourceType]):\n@@ -104,7 +105,8 @@ class Get(Event, ContextManager['Get'], Generic[ResourceType]):\n         method is called automatically.\n\n         \"\"\"\n-        pass\n+        if not self.triggered:\n+            self.resource.get_queue.remove(self)\n\n\n PutType = TypeVar('PutType', bound=Put)\n@@ -152,7 +154,7 @@ class BaseResource(Generic[PutType, GetType]):\n     @property\n     def capacity(self) -&gt;Union[float, int]:\n         \"\"\"Maximum capacity of the resource.\"\"\"\n-        pass\n+        return self._capacity\n     if TYPE_CHECKING:\n\n         def put(self) -&gt;Put:\n@@ -181,7 +183,7 @@ class BaseResource(Generic[PutType, GetType]):\n         :attr:`put_queue`, as long as the return value does not evaluate\n         ``False``.\n         \"\"\"\n-        pass\n+        raise NotImplementedError(\"The _do_put() method has to be implemented by subclasses.\")\n\n     def _trigger_put(self, get_event: Optional[GetType]) -&gt;None:\n         \"\"\"This method is called once a new put event has been created or a get\n@@ -191,7 +193,12 @@ class BaseResource(Generic[PutType, GetType]):\n         calls :meth:`_do_put` to check if the conditions for the event are met.\n         If :meth:`_do_put` returns ``False``, the iteration is stopped early.\n         \"\"\"\n-        pass\n+        idx = 0\n+        while idx &lt; len(self.put_queue):\n+            put_event = self.put_queue[idx]\n+            if not self._do_put(put_event):\n+                break\n+            idx += 1\n\n     def _do_get(self, event: GetType) -&gt;Optional[bool]:\n         \"\"\"Perform the *get* operation.\n@@ -204,7 +211,7 @@ class BaseResource(Generic[PutType, GetType]):\n         :attr:`get_queue`, as long as the return value does not evaluate\n         ``False``.\n         \"\"\"\n-        pass\n+        raise NotImplementedError(\"The _do_get() method has to be implemented by subclasses.\")\n\n     def _trigger_get(self, put_event: Optional[PutType]) -&gt;None:\n         \"\"\"Trigger get events.\n@@ -216,4 +223,9 @@ class BaseResource(Generic[PutType, GetType]):\n         calls :meth:`_do_get` to check if the conditions for the event are met.\n         If :meth:`_do_get` returns ``False``, the iteration is stopped early.\n         \"\"\"\n-        pass\n+        idx = 0\n+        while idx &lt; len(self.get_queue):\n+            get_event = self.get_queue[idx]\n+            if not self._do_get(get_event):\n+                break\n+            idx += 1\ndiff --git a/src/simpy/resources/container.py b/src/simpy/resources/container.py\nindex 00aa6de..fe7bce5 100644\n--- a/src/simpy/resources/container.py\n+++ b/src/simpy/resources/container.py\n@@ -77,16 +77,16 @@ class Container(base.BaseResource):\n     @property\n     def level(self) -&gt;ContainerAmount:\n         \"\"\"The current amount of the matter in the container.\"\"\"\n-        pass\n+        return self._level\n     if TYPE_CHECKING:\n\n         def put(self, amount: ContainerAmount) -&gt;ContainerPut:\n             \"\"\"Request to put *amount* of matter into the container.\"\"\"\n-            pass\n+            return ContainerPut(self, amount)\n\n         def get(self, amount: ContainerAmount) -&gt;ContainerGet:\n             \"\"\"Request to get *amount* of matter out of the container.\"\"\"\n-            pass\n+            return ContainerGet(self, amount)\n     else:\n         put = BoundClass(ContainerPut)\n         get = BoundClass(ContainerGet)\ndiff --git a/src/simpy/resources/resource.py b/src/simpy/resources/resource.py\nindex 2c4f6dd..fa35618 100644\n--- a/src/simpy/resources/resource.py\n+++ b/src/simpy/resources/resource.py\n@@ -70,6 +70,15 @@ class Request(base.Put):\n     resource: Resource\n     usage_since: Optional[SimTime] = None\n\n+    def __init__(self, resource: Resource):\n+        super().__init__(resource)\n+        self.resource = resource\n+        self.usage_since = None\n+\n+    def __enter__(self):\n+        self.usage_since = self.env.now\n+        return self\n+\n     def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value:\n         Optional[BaseException], traceback: Optional[TracebackType]\n         ) -&gt;Optional[bool]:\n@@ -90,6 +99,13 @@ class Release(base.Get):\n         \"\"\"The request (:class:`Request`) that is to be released.\"\"\"\n         super().__init__(resource)\n\n+    def __call__(self):\n+        if self.request in self.resource.users:\n+            self.resource.users.remove(self.request)\n+            self.succeed()\n+        else:\n+            self.fail(ValueError(\"This request is not in the resource's users.\"))\n+\n\n class PriorityRequest(Request):\n     \"\"\"Request the usage of *resource* with a given *priority*. If the\n@@ -138,7 +154,10 @@ class SortedQueue(list):\n         Raise a :exc:`RuntimeError` if the queue is full.\n\n         \"\"\"\n-        pass\n+        if self.maxlen is not None and len(self) &gt;= self.maxlen:\n+            raise RuntimeError(\"Queue is full\")\n+        super().append(item)\n+        self.sort(key=lambda x: x.key)\n\n\n class Resource(base.BaseResource):\n@@ -168,7 +187,7 @@ class Resource(base.BaseResource):\n     @property\n     def count(self) -&gt;int:\n         \"\"\"Number of users currently using the resource.\"\"\"\n-        pass\n+        return len(self.users)\n     if TYPE_CHECKING:\n\n         def request(self) -&gt;Request:\ndiff --git a/src/simpy/resources/store.py b/src/simpy/resources/store.py\nindex 5875e6d..379e325 100644\n--- a/src/simpy/resources/store.py\n+++ b/src/simpy/resources/store.py\n@@ -73,11 +73,11 @@ class Store(base.BaseResource):\n\n         def put(self, item: Any) -&gt;StorePut:\n             \"\"\"Request to put *item* into the store.\"\"\"\n-            pass\n+            return StorePut(self, item)\n\n         def get(self) -&gt;StoreGet:\n             \"\"\"Request to get an *item* out of the store.\"\"\"\n-            pass\n+            return StoreGet(self)\n     else:\n         put = BoundClass(StorePut)\n         get = BoundClass(StoreGet)\n@@ -111,6 +111,31 @@ class PriorityStore(Store):\n\n     \"\"\"\n\n+    def __init__(self, env: Environment, capacity: Union[float, int]=float('inf')):\n+        super().__init__(env, capacity)\n+        self.items = []  # Use a list as a heap\n+\n+    if TYPE_CHECKING:\n+        def put(self, item: Any) -&gt; StorePut:\n+            \"\"\"Request to put *item* into the store.\"\"\"\n+            return StorePut(self, item)\n+\n+        def get(self) -&gt; StoreGet:\n+            \"\"\"Request to get the highest priority *item* from the store.\"\"\"\n+            return StoreGet(self)\n+    else:\n+        put = BoundClass(StorePut)\n+        get = BoundClass(StoreGet)\n+\n+    def _do_put(self, event: StorePut) -&gt; None:\n+        if len(self.items) &lt; self.capacity:\n+            heappush(self.items, event.item)\n+            event.succeed()\n+\n+    def _do_get(self, event: StoreGet) -&gt; None:\n+        if self.items:\n+            event.succeed(heappop(self.items))\n+\n\n class FilterStore(Store):\n     \"\"\"Resource with *capacity* slots for storing arbitrary objects supporting\n@@ -139,6 +164,13 @@ class FilterStore(Store):\n             ) -&gt;FilterStoreGet:\n             \"\"\"Request to get an *item*, for which *filter* returns ``True``,\n             out of the store.\"\"\"\n-            pass\n+            return FilterStoreGet(self, filter)\n     else:\n         get = BoundClass(FilterStoreGet)\n+\n+    def _do_get(self, event: FilterStoreGet) -&gt; None:\n+        for item in self.items:\n+            if event.filter(item):\n+                self.items.remove(item)\n+                event.succeed(item)\n+                break\ndiff --git a/src/simpy/rt.py b/src/simpy/rt.py\nindex 9d99392..e3c068c 100644\n--- a/src/simpy/rt.py\n+++ b/src/simpy/rt.py\n@@ -31,14 +31,14 @@ class RealtimeEnvironment(Environment):\n     @property\n     def factor(self) -&gt;float:\n         \"\"\"Scaling factor of the real-time.\"\"\"\n-        pass\n+        return self._factor\n\n     @property\n     def strict(self) -&gt;bool:\n         \"\"\"Running mode of the environment. :meth:`step()` will raise a\n         :exc:`RuntimeError` if this is set to ``True`` and the processing of\n         events takes too long.\"\"\"\n-        pass\n+        return self._strict\n\n     def sync(self) -&gt;None:\n         \"\"\"Synchronize the internal time with the current wall-clock time.\n@@ -48,7 +48,8 @@ class RealtimeEnvironment(Environment):\n         calling :meth:`run()` or :meth:`step()`.\n\n         \"\"\"\n-        pass\n+        self.real_start = monotonic()\n+        self.env_start = self._now\n\n     def step(self) -&gt;None:\n         \"\"\"Process the next event after enough real-time has passed for the\n@@ -59,4 +60,17 @@ class RealtimeEnvironment(Environment):\n         the event is processed too slowly.\n\n         \"\"\"\n-        pass\n+        try:\n+            evt_time = self.peek()\n+        except EmptySchedule:\n+            return\n+\n+        real_time = monotonic()\n+        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor\n+\n+        if real_time &lt; expected_real_time:\n+            sleep(expected_real_time - real_time)\n+        elif self._strict and real_time &gt; expected_real_time:\n+            raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')\n+\n+        super().step()\ndiff --git a/src/simpy/util.py b/src/simpy/util.py\nindex 5e3a81a..bb287ec 100644\n--- a/src/simpy/util.py\n+++ b/src/simpy/util.py\n@@ -33,7 +33,14 @@ def start_delayed(env: Environment, generator: ProcessGenerator, delay: SimTime\n     Raise a :exc:`ValueError` if ``delay &lt;= 0``.\n\n     \"\"\"\n-    pass\n+    if delay &lt;= 0:\n+        raise ValueError(\"delay must be &gt; 0\")\n+    \n+    def delayed_process():\n+        yield env.timeout(delay)\n+        yield from generator\n+\n+    return env.process(delayed_process())\n\n\n def subscribe_at(event: Event) -&gt;None:\n@@ -45,4 +52,11 @@ def subscribe_at(event: Event) -&gt;None:\n     Raise a :exc:`RuntimeError` if ``event`` has already occurred.\n\n     \"\"\"\n-    pass\n+    if event.triggered:\n+        raise RuntimeError(\"Cannot subscribe to an event that has already occurred\")\n+    \n+    def interrupt_callback(event):\n+        import simpy\n+        simpy.exceptions.Interrupt(event.value)\n+\n+    event.callbacks.append(interrupt_callback)\n</code></pre>"},{"location":"analysis_baseline_tinydb/","title":"Analysis baseline tinydb","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_tinydb/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_tinydb/#repository-tinydb","title":"Repository: tinydb","text":""},{"location":"analysis_baseline_tinydb/#failed-to-run-pytests","title":"Failed to run pytests","text":"<pre><code>ImportError while loading conftest '/testbed/tests/conftest.py'.\ntests/conftest.py:7: in &lt;module&gt;\n    from tinydb.middlewares import CachingMiddleware\ntinydb/__init__.py:27: in &lt;module&gt;\n    from .queries import Query, where\ntinydb/queries.py:21: in &lt;module&gt;\n    from .utils import freeze\ntinydb/utils.py:84: in &lt;module&gt;\n    class FrozenDict(dict):\ntinydb/utils.py:95: in FrozenDict\n    __setitem__ = _immutable\nE   NameError: name '_immutable' is not defined\n</code></pre>"},{"location":"analysis_baseline_tinydb/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/tinydb/database.py b/tinydb/database.py\nindex a4ce0e1..f05a307 100644\n--- a/tinydb/database.py\n+++ b/tinydb/database.py\n@@ -99,7 +99,9 @@ class TinyDB(TableBase):\n         :param name: The name of the table.\n         :param kwargs: Keyword arguments to pass to the table class constructor\n         \"\"\"\n-        pass\n+        if name not in self._tables:\n+            self._tables[name] = self.table_class(self._storage, name, **kwargs)\n+        return self._tables[name]\n\n     def tables(self) -&gt;Set[str]:\n         \"\"\"\n@@ -107,13 +109,14 @@ class TinyDB(TableBase):\n\n         :returns: a set of table names\n         \"\"\"\n-        pass\n+        return set(self._storage.read().keys())\n\n     def drop_tables(self) -&gt;None:\n         \"\"\"\n         Drop all tables from the database. **CANNOT BE REVERSED!**\n         \"\"\"\n-        pass\n+        self._storage.write({})\n+        self._tables.clear()\n\n     def drop_table(self, name: str) -&gt;None:\n         \"\"\"\n@@ -121,7 +124,13 @@ class TinyDB(TableBase):\n\n         :param name: The name of the table to drop.\n         \"\"\"\n-        pass\n+        if name in self._tables:\n+            del self._tables[name]\n+        \n+        data = self._storage.read()\n+        if name in data:\n+            del data[name]\n+            self._storage.write(data)\n\n     @property\n     def storage(self) -&gt;Storage:\n@@ -131,7 +140,7 @@ class TinyDB(TableBase):\n         :return: This instance's storage\n         :rtype: Storage\n         \"\"\"\n-        pass\n+        return self._storage\n\n     def close(self) -&gt;None:\n         \"\"\"\n@@ -148,7 +157,8 @@ class TinyDB(TableBase):\n\n         Upon leaving this context, the ``close`` method will be called.\n         \"\"\"\n-        pass\n+        self._storage.close()\n+        self._opened = False\n\n     def __enter__(self):\n         \"\"\"\ndiff --git a/tinydb/middlewares.py b/tinydb/middlewares.py\nindex 50c2af2..c978b1c 100644\n--- a/tinydb/middlewares.py\n+++ b/tinydb/middlewares.py\n@@ -84,8 +84,36 @@ class CachingMiddleware(Middleware):\n         self.cache = None\n         self._cache_modified_count = 0\n\n+    def read(self):\n+        \"\"\"\n+        Read data from cache if available, otherwise read from storage.\n+        \"\"\"\n+        if self.cache is None:\n+            self.cache = self.storage.read()\n+        return self.cache\n+\n+    def write(self, data):\n+        \"\"\"\n+        Write data to cache and increment the modified count.\n+        Flush to storage if the write cache size is reached.\n+        \"\"\"\n+        self.cache = data\n+        self._cache_modified_count += 1\n+        \n+        if self._cache_modified_count &gt;= self.WRITE_CACHE_SIZE:\n+            self.flush()\n+\n     def flush(self):\n         \"\"\"\n         Flush all unwritten data to disk.\n         \"\"\"\n-        pass\n+        if self.cache is not None:\n+            self.storage.write(self.cache)\n+            self._cache_modified_count = 0\n+\n+    def close(self):\n+        \"\"\"\n+        Flush the cache and close the storage.\n+        \"\"\"\n+        self.flush()\n+        self.storage.close()\ndiff --git a/tinydb/mypy_plugin.py b/tinydb/mypy_plugin.py\nindex 5a0191a..08b3f83 100644\n--- a/tinydb/mypy_plugin.py\n+++ b/tinydb/mypy_plugin.py\n@@ -12,3 +12,28 @@ class TinyDBPlugin(Plugin):\n     def __init__(self, options: Options):\n         super().__init__(options)\n         self.named_placeholders: Dict[str, str] = {}\n+\n+    def get_dynamic_class_hook(self, fullname: str) -&gt; CB[DynamicClassDef]:\n+        if fullname == 'tinydb.utils.with_typehint':\n+            return self.with_typehint_callback\n+        return None\n+\n+    def with_typehint_callback(self, ctx: DynamicClassDef) -&gt; None:\n+        if len(ctx.call.args) != 1:\n+            ctx.api.fail(\"with_typehint() requires exactly one argument\", ctx.call)\n+            return\n+\n+        arg = ctx.call.args[0]\n+        if not isinstance(arg, NameExpr):\n+            ctx.api.fail(\"with_typehint() argument must be a type\", ctx.call)\n+            return\n+\n+        base_type = ctx.api.lookup_qualified(arg.fullname)\n+        if base_type is None:\n+            ctx.api.fail(f\"Cannot find type '{arg.fullname}'\", ctx.call)\n+            return\n+\n+        ctx.cls.info.bases = [base_type]\n+\n+def plugin(version: str):\n+    return TinyDBPlugin\ndiff --git a/tinydb/operations.py b/tinydb/operations.py\nindex fdfa678..833860e 100644\n--- a/tinydb/operations.py\n+++ b/tinydb/operations.py\n@@ -13,39 +13,62 @@ def delete(field):\n     \"\"\"\n     Delete a given field from the document.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        if field in doc:\n+            del doc[field]\n+        return doc\n+    return transform\n\n\n def add(field, n):\n     \"\"\"\n     Add ``n`` to a given field in the document.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        if field in doc:\n+            doc[field] += n\n+        return doc\n+    return transform\n\n\n def subtract(field, n):\n     \"\"\"\n     Subtract ``n`` to a given field in the document.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        if field in doc:\n+            doc[field] -= n\n+        return doc\n+    return transform\n\n\n def set(field, val):\n     \"\"\"\n     Set a given field to ``val``.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        doc[field] = val\n+        return doc\n+    return transform\n\n\n def increment(field):\n     \"\"\"\n     Increment a given field in the document by 1.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        if field in doc:\n+            doc[field] += 1\n+        return doc\n+    return transform\n\n\n def decrement(field):\n     \"\"\"\n     Decrement a given field in the document by 1.\n     \"\"\"\n-    pass\n+    def transform(doc):\n+        if field in doc:\n+            doc[field] -= 1\n+        return doc\n+    return transform\ndiff --git a/tinydb/queries.py b/tinydb/queries.py\nindex 0ad5c7e..9ec0435 100644\n--- a/tinydb/queries.py\n+++ b/tinydb/queries.py\n@@ -181,7 +181,21 @@ class Query(QueryInstance):\n         :param hashval: The hash of the query.\n         :return: A :class:`~tinydb.queries.QueryInstance` object\n         \"\"\"\n-        pass\n+        if not self._path and not allow_empty_path:\n+            raise RuntimeError('Query has no path')\n+\n+        def runner(value):\n+            try:\n+                for part in self._path:\n+                    if isinstance(part, Callable):\n+                        value = part(value)\n+                    else:\n+                        value = value[part]\n+                return test(value)\n+            except (KeyError, TypeError, ValueError):\n+                return False\n+\n+        return QueryInstance(runner, hashval)\n\n     def __eq__(self, rhs: Any):\n         \"\"\"\n@@ -255,7 +269,7 @@ class Query(QueryInstance):\n\n         &gt;&gt;&gt; Query().f1.exists()\n         \"\"\"\n-        pass\n+        return self._generate_test(lambda _: True, ('exists', self._path))\n\n     def matches(self, regex: str, flags: int=0) -&gt;QueryInstance:\n         \"\"\"\n@@ -266,7 +280,10 @@ class Query(QueryInstance):\n         :param regex: The regular expression to use for matching\n         :param flags: regex flags to pass to ``re.match``\n         \"\"\"\n-        pass\n+        return self._generate_test(\n+            lambda value: re.match(regex, value, flags) is not None,\n+            ('matches', self._path, regex, flags)\n+        )\n\n     def search(self, regex: str, flags: int=0) -&gt;QueryInstance:\n         \"\"\"\n@@ -278,7 +295,10 @@ class Query(QueryInstance):\n         :param regex: The regular expression to use for matching\n         :param flags: regex flags to pass to ``re.match``\n         \"\"\"\n-        pass\n+        return self._generate_test(\n+            lambda value: re.search(regex, value, flags) is not None,\n+            ('search', self._path, regex, flags)\n+        )\n\n     def test(self, func: Callable[[Mapping], bool], *args) -&gt;QueryInstance:\n         \"\"\"\n@@ -300,7 +320,10 @@ class Query(QueryInstance):\n                      argument\n         :param args: Additional arguments to pass to the test function\n         \"\"\"\n-        pass\n+        return self._generate_test(\n+            lambda value: func(value, *args),\n+            ('test', self._path, func, args)\n+        )\n\n     def any(self, cond: Union[QueryInstance, List[Any]]) -&gt;QueryInstance:\n         \"\"\"\n@@ -324,7 +347,14 @@ class Query(QueryInstance):\n                      a list of which at least one document has to be contained\n                      in the tested document.\n         \"\"\"\n-        pass\n+        if isinstance(cond, QueryInstance):\n+            def test(value):\n+                return any(cond(item) for item in value)\n+        else:\n+            def test(value):\n+                return any(item in cond for item in value)\n+\n+        return self._generate_test(test, ('any', self._path, freeze(cond)))\n\n     def all(self, cond: Union['QueryInstance', List[Any]]) -&gt;QueryInstance:\n         \"\"\"\n@@ -346,7 +376,14 @@ class Query(QueryInstance):\n         :param cond: Either a query that all documents have to match or a list\n                      which has to be contained in the tested document.\n         \"\"\"\n-        pass\n+        if isinstance(cond, QueryInstance):\n+            def test(value):\n+                return all(cond(item) for item in value)\n+        else:\n+            def test(value):\n+                return all(item in value for item in cond)\n+\n+        return self._generate_test(test, ('all', self._path, freeze(cond)))\n\n     def one_of(self, items: List[Any]) -&gt;QueryInstance:\n         \"\"\"\n@@ -356,7 +393,8 @@ class Query(QueryInstance):\n\n         :param items: The list of items to check with\n         \"\"\"\n-        pass\n+        return self._generate_test(lambda value: value in items,\n+                                   ('one_of', self._path, freeze(items)))\n\n     def noop(self) -&gt;QueryInstance:\n         \"\"\"\n@@ -364,18 +402,21 @@ class Query(QueryInstance):\n\n         Useful for having a base value when composing queries dynamically.\n         \"\"\"\n-        pass\n+        return self._generate_test(lambda _: True, ('noop',), allow_empty_path=True)\n\n     def map(self, fn: Callable[[Any], Any]) -&gt;'Query':\n         \"\"\"\n         Add a function to the query path. Similar to __getattr__ but for\n         arbitrary functions.\n         \"\"\"\n-        pass\n+        query = type(self)()\n+        query._path = self._path + (fn,)\n+        query._hash = ('path', query._path) if self.is_cacheable() else None\n+        return query\n\n\n def where(key: str) -&gt;Query:\n     \"\"\"\n     A shorthand for ``Query()[key]``\n     \"\"\"\n-    pass\n+    return Query()[key]\ndiff --git a/tinydb/storages.py b/tinydb/storages.py\nindex 0ddc223..16bfa7a 100644\n--- a/tinydb/storages.py\n+++ b/tinydb/storages.py\n@@ -18,7 +18,12 @@ def touch(path: str, create_dirs: bool):\n     :param path: The file to create.\n     :param create_dirs: Whether to create all missing parent directories.\n     \"\"\"\n-    pass\n+    if create_dirs:\n+        os.makedirs(os.path.dirname(path), exist_ok=True)\n+    \n+    if not os.path.exists(path):\n+        with open(path, 'a'):\n+            os.utime(path, None)\n\n\n class Storage(ABC):\n@@ -38,7 +43,7 @@ class Storage(ABC):\n\n         Return ``None`` here to indicate that the storage is empty.\n         \"\"\"\n-        pass\n+        raise NotImplementedError\n\n     @abstractmethod\n     def write(self, data: Dict[str, Dict[str, Any]]) -&gt;None:\n@@ -49,7 +54,7 @@ class Storage(ABC):\n\n         :param data: The current state of the database.\n         \"\"\"\n-        pass\n+        raise NotImplementedError\n\n     def close(self) -&gt;None:\n         \"\"\"\n@@ -88,6 +93,40 @@ class JSONStorage(Storage):\n         if any([(character in self._mode) for character in ('+', 'w', 'a')]):\n             touch(path, create_dirs=create_dirs)\n         self._handle = open(path, mode=self._mode, encoding=encoding)\n+        self.path = path\n+        self.encoding = encoding\n+\n+    def read(self) -&gt;Optional[Dict[str, Dict[str, Any]]]:\n+        \"\"\"\n+        Read the current state.\n+\n+        Any kind of deserialization should go here.\n+\n+        Return ``None`` here to indicate that the storage is empty.\n+        \"\"\"\n+        self._handle.seek(0)\n+        try:\n+            return json.load(self._handle)\n+        except json.JSONDecodeError:\n+            return None\n+\n+    def write(self, data: Dict[str, Dict[str, Any]]) -&gt;None:\n+        \"\"\"\n+        Write the current state of the database to the storage.\n+\n+        Any kind of serialization should go here.\n+\n+        :param data: The current state of the database.\n+        \"\"\"\n+        self._handle.seek(0)\n+        json.dump(data, self._handle, **self.kwargs)\n+        self._handle.truncate()\n+\n+    def close(self) -&gt;None:\n+        \"\"\"\n+        Close open file handles.\n+        \"\"\"\n+        self._handle.close()\n\n\n class MemoryStorage(Storage):\n@@ -101,3 +140,25 @@ class MemoryStorage(Storage):\n         \"\"\"\n         super().__init__()\n         self.memory = None\n+\n+    def read(self) -&gt;Optional[Dict[str, Dict[str, Any]]]:\n+        \"\"\"\n+        Read the current state from memory.\n+\n+        Return ``None`` here to indicate that the storage is empty.\n+        \"\"\"\n+        return self.memory\n+\n+    def write(self, data: Dict[str, Dict[str, Any]]) -&gt;None:\n+        \"\"\"\n+        Write the current state of the database to memory.\n+\n+        :param data: The current state of the database.\n+        \"\"\"\n+        self.memory = data\n+\n+    def close(self) -&gt;None:\n+        \"\"\"\n+        Clear the memory.\n+        \"\"\"\n+        self.memory = None\ndiff --git a/tinydb/table.py b/tinydb/table.py\nindex 48eea63..1e85fff 100644\n--- a/tinydb/table.py\n+++ b/tinydb/table.py\n@@ -85,14 +85,14 @@ class Table:\n         \"\"\"\n         Get the table name.\n         \"\"\"\n-        pass\n+        return self._name\n\n     @property\n     def storage(self) -&gt;Storage:\n         \"\"\"\n         Get the table storage instance.\n         \"\"\"\n-        pass\n+        return self._storage\n\n     def insert(self, document: Mapping) -&gt;int:\n         \"\"\"\n@@ -101,7 +101,10 @@ class Table:\n         :param document: the document to insert\n         :returns: the inserted document's ID\n         \"\"\"\n-        pass\n+        doc_id = self._get_next_id()\n+        self._update_table(lambda table: table.update({doc_id: document}))\n+        self.clear_cache()\n+        return doc_id\n\n     def insert_multiple(self, documents: Iterable[Mapping]) -&gt;List[int]:\n         \"\"\"\n@@ -110,7 +113,15 @@ class Table:\n         :param documents: an Iterable of documents to insert\n         :returns: a list containing the inserted documents' IDs\n         \"\"\"\n-        pass\n+        doc_ids = []\n+        def updater(table):\n+            for document in documents:\n+                doc_id = self._get_next_id()\n+                table[doc_id] = document\n+                doc_ids.append(doc_id)\n+        self._update_table(updater)\n+        self.clear_cache()\n+        return doc_ids\n\n     def all(self) -&gt;List[Document]:\n         \"\"\"\n@@ -118,7 +129,8 @@ class Table:\n\n         :returns: a list with all documents.\n         \"\"\"\n-        pass\n+        return [self.document_class(doc, self.document_id_class(doc_id))\n+                for doc_id, doc in self._read_table().items()]\n\n     def search(self, cond: QueryLike) -&gt;List[Document]:\n         \"\"\"\n@@ -127,7 +139,12 @@ class Table:\n         :param cond: the condition to check against\n         :returns: list of matching documents\n         \"\"\"\n-        pass\n+        if cond in self._query_cache:\n+            return self._query_cache[cond]\n+\n+        docs = [doc for doc in self.all() if cond(doc)]\n+        self._query_cache[cond] = docs\n+        return docs\n\n     def get(self, cond: Optional[QueryLike]=None, doc_id: Optional[int]=\n         None, doc_ids: Optional[List]=None) -&gt;Optional[Union[Document, List\n@@ -145,7 +162,25 @@ class Table:\n\n         :returns: the document(s) or ``None``\n         \"\"\"\n-        pass\n+        if doc_id is not None:\n+            table = self._read_table()\n+            if doc_id in table:\n+                return self.document_class(table[doc_id], self.document_id_class(doc_id))\n+            return None\n+        \n+        if doc_ids is not None:\n+            docs = []\n+            table = self._read_table()\n+            for id in doc_ids:\n+                if id in table:\n+                    docs.append(self.document_class(table[id], self.document_id_class(id)))\n+            return docs if docs else None\n+        \n+        if cond is not None:\n+            docs = self.search(cond)\n+            return docs[0] if docs else None\n+        \n+        return None\n\n     def contains(self, cond: Optional[QueryLike]=None, doc_id: Optional[int\n         ]=None) -&gt;bool:\n@@ -158,7 +193,10 @@ class Table:\n         :param cond: the condition use\n         :param doc_id: the document ID to look for\n         \"\"\"\n-        pass\n+        if doc_id is not None:\n+            return doc_id in self._read_table()\n+        \n+        return bool(self.search(cond)) if cond is not None else False\n\n     def update(self, fields: Union[Mapping, Callable[[Mapping], None]],\n         cond: Optional[QueryLike]=None, doc_ids: Optional[Iterable[int]]=None\n@@ -172,7 +210,21 @@ class Table:\n         :param doc_ids: a list of document IDs\n         :returns: a list containing the updated document's ID\n         \"\"\"\n-        pass\n+        updated_ids = []\n+\n+        def updater(table):\n+            nonlocal updated_ids\n+            for doc_id, doc in table.items():\n+                if (doc_ids is None or doc_id in doc_ids) and (cond is None or cond(doc)):\n+                    if callable(fields):\n+                        fields(doc)\n+                    else:\n+                        doc.update(fields)\n+                    updated_ids.append(doc_id)\n+\n+        self._update_table(updater)\n+        self.clear_cache()\n+        return updated_ids\n\n     def update_multiple(self, updates: Iterable[Tuple[Union[Mapping,\n         Callable[[Mapping], None]], QueryLike]]) -&gt;List[int]:\n@@ -181,7 +233,10 @@ class Table:\n\n         :returns: a list containing the updated document's ID\n         \"\"\"\n-        pass\n+        updated_ids = []\n+        for fields, cond in updates:\n+            updated_ids.extend(self.update(fields, cond))\n+        return updated_ids\n\n     def upsert(self, document: Mapping, cond: Optional[QueryLike]=None) -&gt;List[\n         int]:\n@@ -197,7 +252,19 @@ class Table:\n         Document with a doc_id\n         :returns: a list containing the updated documents' IDs\n         \"\"\"\n-        pass\n+        if isinstance(document, Document):\n+            doc_id = document.doc_id\n+            document = dict(document)\n+            del document['doc_id']\n+            cond = Query().doc_id == doc_id\n+\n+        if cond is None:\n+            return [self.insert(document)]\n+        \n+        updated = self.update(document, cond)\n+        if not updated:\n+            return [self.insert(document)]\n+        return updated\n\n     def remove(self, cond: Optional[QueryLike]=None, doc_ids: Optional[\n         Iterable[int]]=None) -&gt;List[int]:\n@@ -208,13 +275,31 @@ class Table:\n         :param doc_ids: a list of document IDs\n         :returns: a list containing the removed documents' ID\n         \"\"\"\n-        pass\n+        removed = []\n+\n+        def remover(table):\n+            nonlocal removed\n+            if doc_ids is not None:\n+                for doc_id in doc_ids:\n+                    if doc_id in table:\n+                        del table[doc_id]\n+                        removed.append(doc_id)\n+            else:\n+                for doc_id, doc in list(table.items()):\n+                    if cond is None or cond(doc):\n+                        del table[doc_id]\n+                        removed.append(doc_id)\n+\n+        self._update_table(remover)\n+        self.clear_cache()\n+        return removed\n\n     def truncate(self) -&gt;None:\n         \"\"\"\n         Truncate the table by removing all documents.\n         \"\"\"\n-        pass\n+        self._update_table(lambda table: table.clear())\n+        self.clear_cache()\n\n     def count(self, cond: QueryLike) -&gt;int:\n         \"\"\"\n@@ -222,13 +307,13 @@ class Table:\n\n         :param cond: the condition use\n         \"\"\"\n-        pass\n+        return len(self.search(cond))\n\n     def clear_cache(self) -&gt;None:\n         \"\"\"\n         Clear the query cache.\n         \"\"\"\n-        pass\n+        self._query_cache.clear()\n\n     def __len__(self):\n         \"\"\"\n@@ -249,7 +334,11 @@ class Table:\n         \"\"\"\n         Return the ID for a newly inserted document.\n         \"\"\"\n-        pass\n+        if self._next_id is None:\n+            self._next_id = max(self._read_table().keys() or [0]) + 1\n+        else:\n+            self._next_id += 1\n+        return self._next_id\n\n     def _read_table(self) -&gt;Dict[str, Mapping]:\n         \"\"\"\n@@ -259,7 +348,7 @@ class Table:\n         we may not want to convert *all* documents when returning\n         only one document for example.\n         \"\"\"\n-        pass\n+        return self._storage.read() or {}\n\n     def _update_table(self, updater: Callable[[Dict[int, Mapping]], None]):\n         \"\"\"\n@@ -274,4 +363,6 @@ class Table:\n         As a further optimization, we don't convert the documents into the\n         document class, as the table data will *not* be returned to the user.\n         \"\"\"\n-        pass\n+        data = self._read_table()\n+        updater(data)\n+        self._storage.write(data)\ndiff --git a/tinydb/utils.py b/tinydb/utils.py\nindex 0721622..9957b9e 100644\n--- a/tinydb/utils.py\n+++ b/tinydb/utils.py\n@@ -23,7 +23,8 @@ def with_typehint(baseclass: Type[T]):\n     MyPy does not. For that reason TinyDB has a MyPy plugin in\n     ``mypy_plugin.py`` that adds support for this pattern.\n     \"\"\"\n-    pass\n+    # The actual implementation is handled by the MyPy plugin in mypy_plugin.py\n+    return baseclass\n\n\n class LRUCache(abc.MutableMapping, Generic[K, V]):\n@@ -45,26 +46,40 @@ class LRUCache(abc.MutableMapping, Generic[K, V]):\n         self.cache: OrderedDict[K, V] = OrderedDict()\n\n     def __len__(self) -&gt;int:\n-        return self.length\n+        return len(self.cache)\n\n     def __contains__(self, key: object) -&gt;bool:\n         return key in self.cache\n\n     def __setitem__(self, key: K, value: V) -&gt;None:\n-        self.set(key, value)\n+        if key in self.cache:\n+            del self.cache[key]\n+        elif len(self.cache) &gt;= self.capacity:\n+            self.cache.popitem(last=False)\n+        self.cache[key] = value\n\n     def __delitem__(self, key: K) -&gt;None:\n         del self.cache[key]\n\n-    def __getitem__(self, key) -&gt;V:\n-        value = self.get(key)\n-        if value is None:\n+    def __getitem__(self, key: K) -&gt;V:\n+        if key not in self.cache:\n             raise KeyError(key)\n+        value = self.cache.pop(key)\n+        self.cache[key] = value\n         return value\n\n     def __iter__(self) -&gt;Iterator[K]:\n         return iter(self.cache)\n\n+    def get(self, key: K, default: Optional[D] = None) -&gt; Union[V, D, None]:\n+        try:\n+            return self[key]\n+        except KeyError:\n+            return default\n+\n+    def set(self, key: K, value: V) -&gt; None:\n+        self[key] = value\n+\n\n class FrozenDict(dict):\n     \"\"\"\n@@ -88,4 +103,10 @@ def freeze(obj):\n     \"\"\"\n     Freeze an object by making it immutable and thus hashable.\n     \"\"\"\n-    pass\n+    if isinstance(obj, dict):\n+        return FrozenDict((k, freeze(v)) for k, v in obj.items())\n+    elif isinstance(obj, list):\n+        return tuple(freeze(i) for i in obj)\n+    elif isinstance(obj, set):\n+        return frozenset(freeze(i) for i in obj)\n+    return obj\n</code></pre>"},{"location":"analysis_baseline_voluptuous/","title":"Analysis baseline voluptuous","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_voluptuous/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_voluptuous/#repository-voluptuous","title":"Repository: voluptuous","text":""},{"location":"analysis_baseline_voluptuous/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count error 1 total 1 collected 1 passed 0"},{"location":"analysis_baseline_voluptuous/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_voluptuous/#testsmdtestsmd","title":"tests.md::tests.md","text":"<pre>tests.md::tests.md</pre><pre>\npath = PosixPath('/testbed/voluptuous/__init__.py')\nconfig = &lt;_pytest.config.Config object at 0x7f651ae5c820&gt;\n\n    def importtestmodule(\n        path: Path,\n        config: Config,\n    ):\n        # We assume we are only called once per module.\n        importmode = config.getoption(\"--import-mode\")\n        try:\n&gt;           mod = import_path(\n                path,\n                mode=importmode,\n                root=config.rootpath,\n                consider_namespace_packages=config.getini(\"consider_namespace_packages\"),\n            )\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath = PosixPath('/testbed/voluptuous/__init__.py')\n\n    def import_path(\n        path: str | os.PathLike[str],\n        *,\n        mode: str | ImportMode = ImportMode.prepend,\n        root: Path,\n        consider_namespace_packages: bool,\n    ) -&gt; ModuleType:\n        \"\"\"\n        Import and return a module from the given path, which can be a file (a module) or\n        a directory (a package).\n\n        :param path:\n            Path to the file to import.\n\n        :param mode:\n            Controls the underlying import mechanism that will be used:\n\n            * ImportMode.prepend: the directory containing the module (or package, taking\n              `__init__.py` files into account) will be put at the *start* of `sys.path` before\n              being imported with `importlib.import_module`.\n\n            * ImportMode.append: same as `prepend`, but the directory will be appended\n              to the end of `sys.path`, if not already in `sys.path`.\n\n            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`\n              to import the module, which avoids having to muck with `sys.path` at all. It effectively\n              allows having same-named test modules in different places.\n\n        :param root:\n            Used as an anchor when mode == ImportMode.importlib to obtain\n            a unique name for the module being imported so it can safely be stored\n            into ``sys.modules``.\n\n        :param consider_namespace_packages:\n            If True, consider namespace packages when resolving module names.\n\n        :raises ImportPathMismatchError:\n            If after importing the given `path` and the module `__file__`\n            are different. Only raised in `prepend` and `append` modes.\n        \"\"\"\n        path = Path(path)\n        mode = ImportMode(mode)\n\n        if not path.exists():\n            raise ImportError(path)\n\n        if mode is ImportMode.importlib:\n            # Try to import this module using the standard import mechanisms, but\n            # without touching sys.path.\n            try:\n                pkg_root, module_name = resolve_pkg_root_and_module_name(\n                    path, consider_namespace_packages=consider_namespace_packages\n                )\n            except CouldNotResolvePathError:\n                pass\n            else:\n                # If the given module name is already in sys.modules, do not import it again.\n                with contextlib.suppress(KeyError):\n                    return sys.modules[module_name]\n\n                mod = _import_module_using_spec(\n                    module_name, path, pkg_root, insert_modules=False\n                )\n                if mod is not None:\n                    return mod\n\n            # Could not import the module with the current sys.path, so we fall back\n            # to importing the file as a single module, not being a part of a package.\n            module_name = module_name_from_path(path, root)\n            with contextlib.suppress(KeyError):\n                return sys.modules[module_name]\n\n            mod = _import_module_using_spec(\n                module_name, path, path.parent, insert_modules=True\n            )\n            if mod is None:\n                raise ImportError(f\"Can't find module {module_name} at location {path}\")\n            return mod\n\n        try:\n            pkg_root, module_name = resolve_pkg_root_and_module_name(\n                path, consider_namespace_packages=consider_namespace_packages\n            )\n        except CouldNotResolvePathError:\n            pkg_root, module_name = path.parent, path.stem\n\n        # Change sys.path permanently: restoring it at the end of this function would cause surprising\n        # problems because of delayed imports: for example, a conftest.py file imported by this function\n        # might have local imports, which would fail at runtime if we restored sys.path.\n        if mode is ImportMode.append:\n            if str(pkg_root) not in sys.path:\n                sys.path.append(str(pkg_root))\n        elif mode is ImportMode.prepend:\n            if str(pkg_root) != sys.path[0]:\n                sys.path.insert(0, str(pkg_root))\n        else:\n            assert_never(mode)\n\n&gt;       importlib.import_module(module_name)\n\n.venv/lib/python3.10/site-packages/_pytest/pathlib.py:582: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', package = None\n\n    def import_module(name, package=None):\n        \"\"\"Import a module.\n\n        The 'package' argument is required when performing a relative import. It\n        specifies the package to use as the anchor point from which to resolve the\n        relative import to an absolute import.\n\n        \"\"\"\n        level = 0\n        if name.startswith('.'):\n            if not package:\n                msg = (\"the 'package' argument is required to perform a relative \"\n                       \"import for {!r}\")\n                raise TypeError(msg.format(name))\n            for character in name:\n                if character != '.':\n                    break\n                level += 1\n&gt;       return _bootstrap._gcd_import(name[level:], package, level)\n\n/usr/lib/python3.10/importlib/__init__.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', package = None, level = 0\n\n&gt;   ???\n\n:1050: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', import_ = \n\n&gt;   ???\n\n:1027: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nname = 'voluptuous', import_ = \n\n&gt;   ???\n\n:1006: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nspec = ModuleSpec(name='voluptuous', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x7f651ad2bf70&gt;, origin='/testbed/voluptuous/__init__.py', submodule_search_locations=['/testbed/voluptuous'])\n\n&gt;   ???\n\n:688: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_frozen_importlib_external.SourceFileLoader object at 0x7f651ad2bf70&gt;\nmodule = \n\n&gt;   ???\n\n:883: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nf = \nargs = (<code> at 0x7f651a226340, file \"/testbed/voluptuous/__init__.py\", line 1&gt;, {'ALLOW_EXTRA': 1, 'Default...ing.Any]], 'Error': , 'Exclusive': , ...})\nkwds = {}\n\n&gt;   ???\n\n:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \"\"\"Schema validation for Python data structures.\n\n    Given eg. a nested data structure like this:\n\n        {\n            'exclude': ['Users', 'Uptime'],\n            'include': [],\n            'set': {\n                'snmp_community': 'public',\n                'snmp_timeout': 15,\n                'snmp_version': '2c',\n            },\n            'targets': {\n                'localhost': {\n                    'exclude': ['Uptime'],\n                    'features': {\n                        'Uptime': {\n                            'retries': 3,\n                        },\n                        'Users': {\n                            'snmp_community': 'monkey',\n                            'snmp_port': 15,\n                        },\n                    },\n                    'include': ['Users'],\n                    'set': {\n                        'snmp_community': 'monkeys',\n                    },\n                },\n            },\n        }\n\n    A schema like this:\n\n        &gt;&gt;&gt; settings = {\n        ...   'snmp_community': str,\n        ...   'retries': int,\n        ...   'snmp_version': All(Coerce(str), Any('3', '2c', '1')),\n        ... }\n        &gt;&gt;&gt; features = ['Ping', 'Uptime', 'Http']\n        &gt;&gt;&gt; schema = Schema({\n        ...    'exclude': features,\n        ...    'include': features,\n        ...    'set': settings,\n        ...    'targets': {\n        ...      'exclude': features,\n        ...      'include': features,\n        ...      'features': {\n        ...        str: settings,\n        ...      },\n        ...    },\n        ... })\n\n    Validate like so:\n\n        &gt;&gt;&gt; schema({\n        ...   'set': {\n        ...     'snmp_community': 'public',\n        ...     'snmp_version': '2c',\n        ...   },\n        ...   'targets': {\n        ...     'exclude': ['Ping'],\n        ...     'features': {\n        ...       'Uptime': {'retries': 3},\n        ...       'Users': {'snmp_community': 'monkey'},\n        ...     },\n        ...   },\n        ... }) == {\n        ...   'set': {'snmp_version': '2c', 'snmp_community': 'public'},\n        ...   'targets': {\n        ...     'exclude': ['Ping'],\n        ...     'features': {'Uptime': {'retries': 3},\n        ...                  'Users': {'snmp_community': 'monkey'}}}}\n        True\n    \"\"\"\n\n    # flake8: noqa\n    # fmt: off\n    from voluptuous.schema_builder import *\n&gt;   from voluptuous.util import *\n\nvoluptuous/__init__.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    import typing\n&gt;   from voluptuous import validators\n\nvoluptuous/util.py:2: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    from __future__ import annotations\n    import datetime\n    import os\n    import re\n    import sys\n    import typing\n    from decimal import Decimal, InvalidOperation\n    from functools import wraps\n    from voluptuous.error import AllInvalid, AnyInvalid, BooleanInvalid, CoerceInvalid, ContainsInvalid, DateInvalid, DatetimeInvalid, DirInvalid, EmailInvalid, ExactSequenceInvalid, FalseInvalid, FileInvalid, InInvalid, Invalid, LengthInvalid, MatchInvalid, MultipleInvalid, NotEnoughValid, NotInInvalid, PathInvalid, RangeInvalid, TooManyValid, TrueInvalid, TypeInvalid, UrlInvalid\n&gt;   from voluptuous.schema_builder import Schema, Schemable, message, raises\nE   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)\n\nvoluptuous/validators.py:10: ImportError\n\nThe above exception was the direct cause of the following exception:\n\ncls = \nfunc = . at 0x7f651a2052d0&gt;\nwhen = 'setup'\nreraise = (, )\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -&gt; CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n\n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n&gt;           result: TResult | None = func()\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n&gt;       lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise\n    )\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:242: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \nkwargs = {'item': }, firstresult = False\n\n    def __call__(self, **kwargs: object) -&gt; Any:\n        \"\"\"Call the hook.\n\n        Only accepts keyword arguments, which should match the hook\n        specification.\n\n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n&gt;       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\n.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.config.PytestPluginManager object at 0x7f651b43ff40&gt;\nhook_name = 'pytest_runtest_setup'\nmethods = [&gt;, &gt;, ...]\nkwargs = {'item': }, firstresult = False\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n\n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n                                teardown.throw(outcome._exception)\n                            else:\n                                teardown.send(outcome._result)\n                            # Following is unreachable for a well behaved hook wrapper.\n                            # Try to force finalizers otherwise postponed till GC action.\n                            # Note: close() may raise if generator handles GeneratorExit.\n                            teardown.close()\n                        except StopIteration as si:\n                            outcome.force_result(si.value)\n                            continue\n                        except BaseException as e:\n                            outcome.force_exception(e)\n                            continue\n                        _raise_wrapfail(teardown, \"has second yield\")\n\n&gt;               return outcome.get_result()\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def get_result(self) -&gt; ResultType:\n        \"\"\"Get the result(s) for this hook call.\n\n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n&gt;           raise exc.with_traceback(exc.__traceback__)\n\n.venv/lib/python3.10/site-packages/pluggy/_result.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n\n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n&gt;                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @pytest.hookimpl(wrapper=True, tryfirst=True)\n    def pytest_runtest_setup() -&gt; Generator[None]:\n&gt;       yield from unraisable_exception_runtest_hook()\n\n.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def unraisable_exception_runtest_hook() -&gt; Generator[None]:\n        with catch_unraisable_exception() as cm:\n            try:\n&gt;               yield\n\n.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n\n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n&gt;                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.logging.LoggingPlugin object at 0x7f651aaee8f0&gt;\nitem = \n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_setup(self, item: nodes.Item) -&gt; Generator[None]:\n        self.log_cli_handler.set_when(\"setup\")\n\n        empty: dict[str, list[logging.LogRecord]] = {}\n        item.stash[caplog_records_key] = empty\n&gt;       yield from self._runtest_for(item, \"setup\")\n\n.venv/lib/python3.10/site-packages/_pytest/logging.py:840: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.logging.LoggingPlugin object at 0x7f651aaee8f0&gt;\nitem = , when = 'setup'\n\n    def _runtest_for(self, item: nodes.Item, when: str) -&gt; Generator[None]:\n        \"\"\"Implement the internals of the pytest_runtest_xxx() hooks.\"\"\"\n        with catching_logs(\n            self.caplog_handler,\n            level=self.log_level,\n        ) as caplog_handler, catching_logs(\n            self.report_handler,\n            level=self.log_level,\n        ) as report_handler:\n            caplog_handler.reset()\n            report_handler.reset()\n            item.stash[caplog_records_key][when] = caplog_handler.records\n            item.stash[caplog_handler_key] = caplog_handler\n\n            try:\n&gt;               yield\n\n.venv/lib/python3.10/site-packages/_pytest/logging.py:829: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n\n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n&gt;                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &gt; _state='suspended' _in_suspended=False&gt; _capture_fixture=None&gt;\nitem = \n\n    @hookimpl(wrapper=True)\n    def pytest_runtest_setup(self, item: Item) -&gt; Generator[None]:\n        with self.item_capture(\"setup\", item):\n&gt;           return (yield)\n\n.venv/lib/python3.10/site-packages/_pytest/capture.py:875: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException as exc:\n                exception = exc\n        finally:\n            # Fast path - only new-style wrappers, no Result.\n            if only_new_style_wrappers:\n                if firstresult:  # first result hooks return a single value\n                    result = results[0] if results else None\n                else:\n                    result = results\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    try:\n                        if exception is not None:\n                            teardown.throw(exception)  # type: ignore[union-attr]\n                        else:\n                            teardown.send(result)  # type: ignore[union-attr]\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()  # type: ignore[union-attr]\n                    except StopIteration as si:\n                        result = si.value\n                        exception = None\n                        continue\n                    except BaseException as e:\n                        exception = e\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n                if exception is not None:\n                    raise exception.with_traceback(exception.__traceback__)\n                else:\n                    return result\n\n            # Slow path - need to support old-style wrappers.\n            else:\n                if firstresult:  # first result hooks return a single value\n                    outcome: Result[object | list[object]] = Result(\n                        results[0] if results else None, exception\n                    )\n                else:\n                    outcome = Result(results, exception)\n\n                # run all wrapper post-yield blocks\n                for teardown in reversed(teardowns):\n                    if isinstance(teardown, tuple):\n                        try:\n                            teardown[0].send(outcome)\n                        except StopIteration:\n                            pass\n                        except BaseException as e:\n                            _warn_teardown_exception(hook_name, teardown[1], e)\n                            raise\n                        else:\n                            _raise_wrapfail(teardown[0], \"has second yield\")\n                    else:\n                        try:\n                            if outcome._exception is not None:\n&gt;                               teardown.throw(outcome._exception)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @pytest.hookimpl(wrapper=True, trylast=True)\n    def pytest_runtest_setup() -&gt; Generator[None]:\n&gt;       yield from thread_exception_runtest_hook()\n\n.venv/lib/python3.10/site-packages/_pytest/threadexception.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def thread_exception_runtest_hook() -&gt; Generator[None]:\n        with catch_threading_exception() as cm:\n            try:\n&gt;               yield\n\n.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhook_name = 'pytest_runtest_setup'\nhook_impls = [&gt;, &gt;, ...]\ncaller_kwargs = {'item': }, firstresult = False\n\n    def _multicall(\n        hook_name: str,\n        hook_impls: Sequence[HookImpl],\n        caller_kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -&gt; object | list[object]:\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n\n        ``caller_kwargs`` comes from HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results: list[object] = []\n        exception = None\n        only_new_style_wrappers = True\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns: list[Teardown] = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n\n                    if hook_impl.hookwrapper:\n                        only_new_style_wrappers = False\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            wrapper_gen = cast(Generator[None, Result[object], None], res)\n                            next(wrapper_gen)  # first yield\n                            teardowns.append((wrapper_gen, hook_impl))\n                        except StopIteration:\n                            _raise_wrapfail(wrapper_gen, \"did not yield\")\n                    elif hook_impl.wrapper:\n                        try:\n                            # If this cast is not valid, a type error is raised below,\n                            # which is the desired response.\n                            res = hook_impl.function(*args)\n                            function_gen = cast(Generator[None, object, object], res)\n                            next(function_gen)  # first yield\n                            teardowns.append(function_gen)\n                        except StopIteration:\n                            _raise_wrapfail(function_gen, \"did not yield\")\n                    else:\n&gt;                       res = hook_impl.function(*args)\n\n.venv/lib/python3.10/site-packages/pluggy/_callers.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nitem = \n\n    def pytest_runtest_setup(item: Item) -&gt; None:\n        _update_current_test_var(item, \"setup\")\n&gt;       item.session._setupstate.setup(item)\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &lt;_pytest.runner.SetupState object at 0x7f651aaec100&gt;\nitem = \n\n    def setup(self, item: Item) -&gt; None:\n        \"\"\"Setup objects along the collector chain to the item.\"\"\"\n        needed_collectors = item.listchain()\n\n        # If a collector fails its setup, fail its entire subtree of items.\n        # The setup is not retried for each item - the same exception is used.\n        for col, (finalizers, exc) in self.stack.items():\n            assert col in needed_collectors, \"previous item was not torn down properly\"\n            if exc:\n                raise exc[0].with_traceback(exc[1])\n\n        for col in needed_collectors[len(self.stack) :]:\n            assert col not in self.stack\n            # Push onto the stack.\n            self.stack[col] = ([col.teardown], None)\n            try:\n&gt;               col.setup()\n\n.venv/lib/python3.10/site-packages/_pytest/runner.py:514: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = \n\n    def setup(self) -&gt; None:\n&gt;       init_mod = importtestmodule(self.path / \"__init__.py\", self.config)\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:663: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath = PosixPath('/testbed/voluptuous/__init__.py')\nconfig = &lt;_pytest.config.Config object at 0x7f651ae5c820&gt;\n\n    def importtestmodule(\n        path: Path,\n        config: Config,\n    ):\n        # We assume we are only called once per module.\n        importmode = config.getoption(\"--import-mode\")\n        try:\n            mod = import_path(\n                path,\n                mode=importmode,\n                root=config.rootpath,\n                consider_namespace_packages=config.getini(\"consider_namespace_packages\"),\n            )\n        except SyntaxError as e:\n            raise nodes.Collector.CollectError(\n                ExceptionInfo.from_current().getrepr(style=\"short\")\n            ) from e\n        except ImportPathMismatchError as e:\n            raise nodes.Collector.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module {!r} has this __file__ attribute:\\n\"\n                \"  {}\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  {}\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\".format(*e.args)\n            ) from e\n        except ImportError as e:\n            exc_info = ExceptionInfo.from_current()\n            if config.get_verbosity() &lt; 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n&gt;           raise nodes.Collector.CollectError(\n                f\"ImportError while importing test module '{path}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                f\"{formatted_tb}\"\n            ) from e\nE           _pytest.nodes.Collector.CollectError: ImportError while importing test module '/testbed/voluptuous/__init__.py'.\nE           Hint: make sure your test modules/packages have valid Python names.\nE           Traceback:\nE           /usr/lib/python3.10/importlib/__init__.py:126: in import_module\nE               return _bootstrap._gcd_import(name[level:], package, level)\nE           voluptuous/__init__.py:80: in \nE               from voluptuous.util import *\nE           voluptuous/util.py:2: in \nE               from voluptuous import validators\nE           voluptuous/validators.py:10: in \nE               from voluptuous.schema_builder import Schema, Schemable, message, raises\nE           E   ImportError: cannot import name 'raises' from 'voluptuous.schema_builder' (/testbed/voluptuous/schema_builder.py)\n\n.venv/lib/python3.10/site-packages/_pytest/python.py:523: CollectError"},{"location":"analysis_baseline_voluptuous/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/voluptuous/error.py b/voluptuous/error.py\nindex f72fbe7..7999b26 100644\n--- a/voluptuous/error.py\n+++ b/voluptuous/error.py\n@@ -146,7 +146,7 @@ class LiteralInvalid(Invalid):\n\n\n class LengthInvalid(Invalid):\n-    pass\n+    \"\"\"The value has an invalid length.\"\"\"\n\n\n class DatetimeInvalid(Invalid):\n@@ -158,22 +158,28 @@ class DateInvalid(Invalid):\n\n\n class InInvalid(Invalid):\n-    pass\n+    \"\"\"The value is not in the required collection.\"\"\"\n\n\n class NotInInvalid(Invalid):\n-    pass\n+    \"\"\"The value is in a collection it should not be in.\"\"\"\n\n\n class ExactSequenceInvalid(Invalid):\n-    pass\n+    \"\"\"The sequence does not match exactly.\"\"\"\n\n\n class NotEnoughValid(Invalid):\n     \"\"\"The value did not pass enough validations.\"\"\"\n-    pass\n+    def __init__(self, msg: str, min_valid: int, actual_valid: int, path: typing.Optional[typing.List[typing.Hashable]] = None):\n+        super().__init__(msg, path)\n+        self.min_valid = min_valid\n+        self.actual_valid = actual_valid\n\n\n class TooManyValid(Invalid):\n     \"\"\"The value passed more than expected validations.\"\"\"\n-    pass\n+    def __init__(self, msg: str, max_valid: int, actual_valid: int, path: typing.Optional[typing.List[typing.Hashable]] = None):\n+        super().__init__(msg, path)\n+        self.max_valid = max_valid\n+        self.actual_valid = actual_valid\ndiff --git a/voluptuous/humanize.py b/voluptuous/humanize.py\nindex 2902871..7776e89 100644\n--- a/voluptuous/humanize.py\n+++ b/voluptuous/humanize.py\n@@ -11,4 +11,32 @@ def humanize_error(data, validation_error: Invalid, max_sub_error_length:\n     Invalid and MultipleInvalid do not include the offending value in error messages,\n     and MultipleInvalid.__str__ only provides the first error.\n     \"\"\"\n-    pass\n+    if isinstance(validation_error, MultipleInvalid):\n+        errors = validation_error.errors\n+    else:\n+        errors = [validation_error]\n+\n+    error_messages = []\n+    for error in errors:\n+        path = _format_path(error.path)\n+        value = _get_value_from_path(data, error.path)\n+        error_message = f\"Error at {path}: {error}\"\n+        if value is not None:\n+            truncated_value = str(value)[:max_sub_error_length]\n+            if len(str(value)) &gt; max_sub_error_length:\n+                truncated_value += \"...\"\n+            error_message += f\" (got {truncated_value})\"\n+        error_messages.append(error_message)\n+\n+    return \"\\n\".join(error_messages)\n+\n+def _format_path(path):\n+    return \".\".join(str(p) for p in path) if path else \"root\"\n+\n+def _get_value_from_path(data, path):\n+    for key in path:\n+        if isinstance(data, (dict, list)) and key in data:\n+            data = data[key]\n+        else:\n+            return None\n+    return data\ndiff --git a/voluptuous/schema_builder.py b/voluptuous/schema_builder.py\nindex de2b53c..57ef356 100644\n--- a/voluptuous/schema_builder.py\n+++ b/voluptuous/schema_builder.py\n@@ -113,7 +113,27 @@ class Schema(object):\n\n         Note: only very basic inference is supported.\n         \"\"\"\n-        pass\n+        def infer_type(value):\n+            if isinstance(value, dict):\n+                return {k: infer_type(v) for k, v in value.items()}\n+            elif isinstance(value, list):\n+                if value:\n+                    return [infer_type(value[0])]\n+                else:\n+                    return list\n+            elif isinstance(value, str):\n+                return str\n+            elif isinstance(value, int):\n+                return int\n+            elif isinstance(value, float):\n+                return float\n+            elif isinstance(value, bool):\n+                return bool\n+            else:\n+                return type(value)\n+\n+        inferred_schema = infer_type(data)\n+        return cls(inferred_schema, **kwargs)\n\n     def __eq__(self, other):\n         if not isinstance(other, Schema):\n@@ -142,7 +162,58 @@ class Schema(object):\n\n     def _compile_mapping(self, schema, invalid_msg=None):\n         \"\"\"Create validator for given mapping.\"\"\"\n-        pass\n+        def validate_mapping(path, iterable, value):\n+            if not isinstance(value, dict):\n+                raise er.Invalid(invalid_msg or 'expected a dictionary', path)\n+\n+            out = {}\n+            required_keys = set()\n+            optional_keys = set()\n+            _compile = self._compile\n+            error = er.MultipleInvalid()\n+\n+            for key, subschema in _iterate_mapping_candidates(schema):\n+                if isinstance(key, Required):\n+                    required_keys.add(key.schema)\n+                elif isinstance(key, Optional):\n+                    optional_keys.add(key.schema)\n+                else:\n+                    optional_keys.add(key)\n+\n+            for key, val in value.items():\n+                key_path = path + [key]\n+                for skey, svalue in _iterate_mapping_candidates(schema):\n+                    if isinstance(skey, Optional):\n+                        skey = skey.schema\n+                    if isinstance(skey, Required):\n+                        skey = skey.schema\n+                    if skey == key:\n+                        try:\n+                            out[key] = _compile(svalue)(key_path, value, val)\n+                            break\n+                        except er.Invalid as e:\n+                            error.add(e)\n+                else:\n+                    if self.extra == PREVENT_EXTRA:\n+                        error.add(er.Invalid('extra keys not allowed', key_path))\n+                    elif self.extra == ALLOW_EXTRA:\n+                        out[key] = val\n+                    elif self.extra == REMOVE_EXTRA:\n+                        pass\n+                    else:\n+                        raise ValueError('Invalid value for extra')\n+\n+            missing_required_keys = required_keys - set(out.keys())\n+            if missing_required_keys:\n+                error.add(er.Invalid(f'required key(s) {\", \".join(repr(k) for k in missing_required_keys)} not provided',\n+                                     path))\n+\n+            if error.errors:\n+                raise error\n+\n+            return out\n+\n+        return validate_mapping\n\n     def _compile_object(self, schema):\n         \"\"\"Validate an object.\n@@ -162,7 +233,26 @@ class Schema(object):\n             ...   validate(Structure(one='three'))\n\n         \"\"\"\n-        pass\n+        base = self._compile_mapping(schema, invalid_msg='object value')\n+\n+        def validate_object(path, iterable, value):\n+            if schema.cls is not UNDEFINED and not isinstance(value, schema.cls):\n+                raise er.Invalid('expected {} but got {}'.format(schema.cls, type(value)), path)\n+            \n+            # Convert object attributes to a dictionary\n+            value_dict = {k: getattr(value, k) for k in dir(value) if not k.startswith('_')}\n+            \n+            # Validate the dictionary\n+            result_dict = base(path, iterable, value_dict)\n+            \n+            # Create a new object with validated attributes\n+            validated_obj = schema.cls() if schema.cls is not UNDEFINED else type(value)()\n+            for k, v in result_dict.items():\n+                setattr(validated_obj, k, v)\n+            \n+            return validated_obj\n+\n+        return validate_object\n\n     def _compile_dict(self, schema):\n         \"\"\"Validate a dictionary.\n@@ -240,7 +330,7 @@ class Schema(object):\n          \"expected str for dictionary value @ data['adict']['strfield']\"]\n\n         \"\"\"\n-        pass\n+        return self._compile_mapping(schema, invalid_msg='expected a dictionary')\n\n     def _compile_sequence(self, schema, seq_type):\n         \"\"\"Validate a sequence type.\n@@ -255,7 +345,27 @@ class Schema(object):\n         &gt;&gt;&gt; validator([1])\n         [1]\n         \"\"\"\n-        pass\n+        _compile = self._compile\n+        seq_schema = [_compile(s) for s in schema]\n+\n+        def validate_sequence(path, iterable, value):\n+            if not isinstance(value, seq_type):\n+                raise er.Invalid('expected a {}'.format(seq_type.__name__), path)\n+\n+            result = []\n+            for i, item in enumerate(value):\n+                item_path = path + [i]\n+                for validator in seq_schema:\n+                    try:\n+                        result.append(validator(item_path, iterable, item))\n+                        break\n+                    except er.Invalid:\n+                        pass\n+                else:\n+                    raise er.Invalid('invalid value', item_path)\n+            return seq_type(result)\n+\n+        return validate_sequence\n\n     def _compile_tuple(self, schema):\n         \"\"\"Validate a tuple.\n@@ -270,7 +380,7 @@ class Schema(object):\n         &gt;&gt;&gt; validator((1,))\n         (1,)\n         \"\"\"\n-        pass\n+        return self._compile_sequence(schema, tuple)\n\n     def _compile_list(self, schema):\n         \"\"\"Validate a list.\n@@ -285,7 +395,7 @@ class Schema(object):\n         &gt;&gt;&gt; validator([1])\n         [1]\n         \"\"\"\n-        pass\n+        return self._compile_sequence(schema, list)\n\n     def _compile_set(self, schema):\n         \"\"\"Validate a set.\n@@ -300,7 +410,26 @@ class Schema(object):\n         &gt;&gt;&gt; with raises(er.MultipleInvalid, 'invalid value in set'):\n         ...   validator(set(['a']))\n         \"\"\"\n-        pass\n+        _compile = self._compile\n+        set_schema = [_compile(s) for s in schema]\n+\n+        def validate_set(path, iterable, value):\n+            if not isinstance(value, set):\n+                raise er.Invalid('expected a set', path)\n+\n+            result = set()\n+            for item in value:\n+                for validator in set_schema:\n+                    try:\n+                        result.add(validator(path, iterable, item))\n+                        break\n+                    except er.Invalid:\n+                        pass\n+                else:\n+                    raise er.Invalid('invalid value in set', path)\n+            return result\n+\n+        return validate_set\n\n     def extend(self, schema: Schemable, required: typing.Optional[bool]=\n         None, extra: typing.Optional[int]=None) -&gt;Schema:\n@@ -316,7 +445,17 @@ class Schema(object):\n         :param required: if set, overrides `required` of this `Schema`\n         :param extra: if set, overrides `extra` of this `Schema`\n         \"\"\"\n-        pass\n+        if not isinstance(self.schema, dict) or not isinstance(schema, dict):\n+            raise ValueError(\"Both schemas must be dictionary-based\")\n+\n+        new_schema = self.schema.copy()\n+        new_schema.update(schema)\n+\n+        return Schema(\n+            new_schema,\n+            required=self.required if required is None else required,\n+            extra=self.extra if extra is None else extra\n+        )\n\n\n def _compile_scalar(schema):\n@@ -678,17 +817,31 @@ def message(default: typing.Optional[str]=None, cls: typing.Optional[typing\n         ... except er.MultipleInvalid as e:\n         ...   assert isinstance(e.errors[0], IntegerInvalid)\n     \"\"\"\n-    pass\n+    def decorator(func):\n+        @wraps(func)\n+        def wrapper(*args, **kwargs):\n+            msg = kwargs.pop('msg', None) or default\n+            clsoverride = kwargs.pop('clsoverride', None) or cls\n+            try:\n+                return func(*args, **kwargs)\n+            except ValueError as e:\n+                raise (clsoverride or er.Invalid)(msg or str(e))\n+        return wrapper\n+    return decorator\n\n\n def _args_to_dict(func, args):\n     \"\"\"Returns argument names as values as key-value pairs.\"\"\"\n-    pass\n+    arg_count = func.__code__.co_argcount\n+    arg_names = func.__code__.co_varnames[:arg_count]\n+    return dict(zip(arg_names, args))\n\n\n def _merge_args_with_kwargs(args_dict, kwargs_dict):\n     \"\"\"Merge args with kwargs.\"\"\"\n-    pass\n+    ret = args_dict.copy()\n+    ret.update(kwargs_dict)\n+    return ret\n\n\n def validate(*a, **kw) -&gt;typing.Callable:\n@@ -707,4 +860,20 @@ def validate(*a, **kw) -&gt;typing.Callable:\n         ...   return arg1 * 2\n\n     \"\"\"\n-    pass\n+    def validate_schema_decorator(func):\n+        schema = Schema(kw) if kw else Schema(a[0])\n+\n+        @wraps(func)\n+        def wrapper(*args, **kwargs):\n+            schema_dict = _merge_args_with_kwargs(_args_to_dict(func, args), kwargs)\n+            validated = schema(schema_dict)\n+            result = func(**validated)\n+            if '__return__' in schema.schema:\n+                return_validator = schema.schema['__return__']\n+                if isinstance(return_validator, Schema):\n+                    return return_validator(result)\n+                else:\n+                    return Schema(return_validator)(result)\n+            return result\n+        return wrapper\n+    return validate_schema_decorator\ndiff --git a/voluptuous/util.py b/voluptuous/util.py\nindex fe15b1a..a2c57d8 100644\n--- a/voluptuous/util.py\n+++ b/voluptuous/util.py\n@@ -13,7 +13,7 @@ def Lower(v: str) -&gt;str:\n     &gt;&gt;&gt; s('HI')\n     'hi'\n     \"\"\"\n-    pass\n+    return v.lower()\n\n\n def Upper(v: str) -&gt;str:\n@@ -23,7 +23,7 @@ def Upper(v: str) -&gt;str:\n     &gt;&gt;&gt; s('hi')\n     'HI'\n     \"\"\"\n-    pass\n+    return v.upper()\n\n\n def Capitalize(v: str) -&gt;str:\n@@ -33,7 +33,7 @@ def Capitalize(v: str) -&gt;str:\n     &gt;&gt;&gt; s('hello world')\n     'Hello world'\n     \"\"\"\n-    pass\n+    return v.capitalize()\n\n\n def Title(v: str) -&gt;str:\n@@ -43,7 +43,7 @@ def Title(v: str) -&gt;str:\n     &gt;&gt;&gt; s('hello world')\n     'Hello World'\n     \"\"\"\n-    pass\n+    return v.title()\n\n\n def Strip(v: str) -&gt;str:\n@@ -53,7 +53,7 @@ def Strip(v: str) -&gt;str:\n     &gt;&gt;&gt; s('  hello world  ')\n     'hello world'\n     \"\"\"\n-    pass\n+    return v.strip()\n\n\n class DefaultTo(object):\ndiff --git a/voluptuous/validators.py b/voluptuous/validators.py\nindex 88b50f6..10230e1 100644\n--- a/voluptuous/validators.py\n+++ b/voluptuous/validators.py\n@@ -41,7 +41,13 @@ def truth(f: typing.Callable) -&gt;typing.Callable:\n     &gt;&gt;&gt; with raises(MultipleInvalid, 'not a valid value'):\n     ...   validate('/notavaliddir')\n     \"\"\"\n-    pass\n+    @wraps(f)\n+    def wrapper(v):\n+        t = f(v)\n+        if not t:\n+            raise ValueError\n+        return v\n+    return wrapper\n\n\n class Coerce(object):\n@@ -109,7 +115,7 @@ def IsTrue(v):\n     ... except MultipleInvalid as e:\n     ...   assert isinstance(e.errors[0], TrueInvalid)\n     \"\"\"\n-    pass\n+    return bool(v)\n\n\n @message('value was not false', cls=FalseInvalid)\n@@ -129,7 +135,7 @@ def IsFalse(v):\n     ... except MultipleInvalid as e:\n     ...   assert isinstance(e.errors[0], FalseInvalid)\n     \"\"\"\n-    pass\n+    return not bool(v)\n\n\n @message('expected boolean', cls=BooleanInvalid)\n@@ -153,7 +159,18 @@ def Boolean(v):\n     ... except MultipleInvalid as e:\n     ...   assert isinstance(e.errors[0], BooleanInvalid)\n     \"\"\"\n-    pass\n+    if isinstance(v, bool):\n+        return v\n+    if isinstance(v, str):\n+        v = v.lower()\n+        if v in ('1', 'true', 'yes', 'on', 'enable'):\n+            return True\n+        if v in ('0', 'false', 'no', 'off', 'disable'):\n+            return False\n+    try:\n+        return bool(v)\n+    except ValueError:\n+        raise BooleanInvalid('expected boolean')\n\n\n class _WithSubValidators(object):\n@@ -894,7 +911,16 @@ class Number(object):\n         :param number:\n         :return: tuple(precision, scale, decimal_number)\n         \"\"\"\n-        pass\n+        try:\n+            decimal_num = Decimal(number)\n+        except InvalidOperation:\n+            raise Invalid(self.msg or f'{number} is not a valid Decimal')\n+\n+        sign, digits, exponent = decimal_num.as_tuple()\n+        scale = -exponent if exponent &lt; 0 else 0\n+        precision = len(digits)\n+\n+        return precision, scale, decimal_num\n\n\n class SomeOf(_WithSubValidators):\n</code></pre>"},{"location":"analysis_baseline_wcwidth/","title":"Analysis baseline wcwidth","text":"<p>back to baseline summary</p>"},{"location":"analysis_baseline_wcwidth/#submission-name-baseline","title":"Submission Name: baseline","text":""},{"location":"analysis_baseline_wcwidth/#repository-wcwidth","title":"Repository: wcwidth","text":""},{"location":"analysis_baseline_wcwidth/#pytest-summary-tests","title":"Pytest Summary: tests","text":"status count passed 6 failed 32 skipped 1 total 39 collected 39"},{"location":"analysis_baseline_wcwidth/#failed-pytest-outputs-tests","title":"Failed pytest outputs: tests","text":""},{"location":"analysis_baseline_wcwidth/#test_corepytest_empty_string","title":"test_core.py::test_empty_string","text":"<pre>test_core.py::test_empty_string</pre><pre>\ndef test_empty_string():\n        \"\"\"\n        Test empty string is OK.\n\n        https://github.com/jquast/wcwidth/issues/24\n        \"\"\"\n        phrase = \"\"\n        expect_length_each = 0\n        expect_length_phrase = 0\n\n        # exercise,\n&gt;       length_each = wcwidth.wcwidth(phrase)\n\ntests/test_core.py:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nwc = '', unicode_version = 'auto'\n\n    @lru_cache(maxsize=1000)\n    def wcwidth(wc, unicode_version='auto'):\n        \"\"\"\n        Given one Unicode character, return its printable length on a terminal.\n\n        :param str wc: A single Unicode character.\n        :param str unicode_version: A Unicode version number, such as\n            ``'6.0.0'``. A list of version levels suported by wcwidth\n            is returned by :func:`list_versions`.\n\n            Any version string may be specified without error -- the nearest\n            matching version is selected.  When ``latest`` (default), the\n            highest Unicode version level is used.\n        :return: The width, in cells, necessary to display the character of\n            Unicode string character, ``wc``.  Returns 0 if the ``wc`` argument has\n            no printable effect on a terminal (such as NUL '\\\\0'), -1 if ``wc`` is\n            not printable, or has an indeterminate effect on the terminal, such as\n            a control character.  Otherwise, the number of column positions the\n            character occupies on a graphic terminal (1 or 2) is returned.\n        :rtype: int\n\n        See :ref:`Specification` for details of cell measurement.\n        \"\"\"\n&gt;       ucs = ord(wc)\nE       TypeError: ord() expected a character, but string of length 0 found\n\nwcwidth/wcwidth.py:129: TypeError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_hello_jp","title":"test_core.py::test_hello_jp","text":"<pre>test_core.py::test_hello_jp</pre><pre>\ndef test_hello_jp():\n        u\"\"\"\n        Width of Japanese phrase: \u30b3\u30f3\u30cb\u30c1\u30cf, \u30bb\u30ab\u30a4!\n\n        Given a phrase of 5 and 3 Katakana ideographs, joined with\n        3 English-ASCII punctuation characters, totaling 11, this\n        phrase consumes 19 cells of a terminal emulator.\n        \"\"\"\n        # given,\n        phrase = u'\u30b3\u30f3\u30cb\u30c1\u30cf, \u30bb\u30ab\u30a4!'\n        expect_length_each = (2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1)\n        expect_length_phrase = sum(expect_length_each)\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 12467\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_wcswidth_substr","title":"test_core.py::test_wcswidth_substr","text":"<pre>test_core.py::test_wcswidth_substr</pre><pre>\ndef test_wcswidth_substr():\n        \"\"\"\n        Test wcswidth() optional 2nd parameter, ``n``.\n\n        ``n`` determines at which position of the string\n        to stop counting length.\n        \"\"\"\n        # given,\n        phrase = u'\u30b3\u30f3\u30cb\u30c1\u30cf, \u30bb\u30ab\u30a4!'\n        end = 7\n        expect_length_each = (2, 2, 2, 2, 2, 1, 1,)\n        expect_length_phrase = sum(expect_length_each)\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))[:end]\n\ntests/test_core.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 12467\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_null_width_0","title":"test_core.py::test_null_width_0","text":"<pre>test_core.py::test_null_width_0</pre><pre>\ndef test_null_width_0():\n        \"\"\"NULL (0) reports width 0.\"\"\"\n        # given,\n        phrase = u'abc\\x00def'\n        expect_length_each = (1, 1, 1, 0, 1, 1, 1)\n        expect_length_phrase = sum(expect_length_each)\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 97\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_control_c0_width_negative_1","title":"test_core.py::test_control_c0_width_negative_1","text":"<pre>test_core.py::test_control_c0_width_negative_1</pre><pre>\ndef test_control_c0_width_negative_1():\n        \"\"\"How the API reacts to CSI (Control sequence initiate).\n\n        An example of bad fortune, this terminal sequence is a width of 0\n        on all terminals, but wcwidth doesn't parse Control-Sequence-Inducer\n        (CSI) sequences.\n\n        Also the \"legacy\" posix functions wcwidth and wcswidth return -1 for\n        any string containing the C1 control character \\x1b (ESC).\n        \"\"\"\n        # given,\n        phrase = u'\\x1b[0m'\n        expect_length_each = (-1, 1, 1, 1)\n        expect_length_phrase = -1\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 91\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_combining_width","title":"test_core.py::test_combining_width","text":"<pre>test_core.py::test_combining_width</pre><pre>\ndef test_combining_width():\n        \"\"\"Simple test combining reports total width of 4.\"\"\"\n        # given,\n        phrase = u'--\\u05bf--'\n        expect_length_each = (1, 1, 0, 1, 1)\n        expect_length_phrase = 4\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:164: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 45\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_combining_cafe","title":"test_core.py::test_combining_cafe","text":"<pre>test_core.py::test_combining_cafe</pre><pre>\ndef test_combining_cafe():\n        u\"\"\"Phrase cafe + COMBINING ACUTE ACCENT is caf\u00e9 of length 4.\"\"\"\n        phrase = u\"cafe\\u0301\"\n        expect_length_each = (1, 1, 1, 1, 0)\n        expect_length_phrase = 4\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 99\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_combining_enclosing","title":"test_core.py::test_combining_enclosing","text":"<pre>test_core.py::test_combining_enclosing</pre><pre>\ndef test_combining_enclosing():\n        u\"\"\"CYRILLIC CAPITAL LETTER A + COMBINING CYRILLIC HUNDRED THOUSANDS SIGN is of length 1.\"\"\"\n        phrase = u\"\\u0410\\u0488\"\n        expect_length_each = (1, 0)\n        expect_length_phrase = 1\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:194: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 1040\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_balinese_script","title":"test_core.py::test_balinese_script","text":"<pre>test_core.py::test_balinese_script</pre><pre>\ndef test_balinese_script():\n        u\"\"\"\n        Balinese kapal (ship) is length 3.\n\n        This may be an example that is not yet correctly rendered by any terminal so\n        far, like devanagari.\n        \"\"\"\n        phrase = (u\"\\u1B13\"    # Category 'Lo', EAW 'N' -- BALINESE LETTER KA\n                  u\"\\u1B28\"    # Category 'Lo', EAW 'N' -- BALINESE LETTER PA KAPAL\n                  u\"\\u1B2E\"    # Category 'Lo', EAW 'N' -- BALINESE LETTER LA\n                  u\"\\u1B44\")   # Category 'Mc', EAW 'N' -- BALINESE ADEG ADEG\n        expect_length_each = (1, 1, 1, 0)\n        expect_length_phrase = 3\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:217: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 6931\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_kr_jamo","title":"test_core.py::test_kr_jamo","text":"<pre>test_core.py::test_kr_jamo</pre><pre>\ndef test_kr_jamo():\n        \"\"\"\n        Test basic combining of HANGUL CHOSEONG and JUNGSEONG\n\n        Example and from Raymond Chen's blog post,\n        https://devblogs.microsoft.com/oldnewthing/20201009-00/?p=104351\n        \"\"\"\n        # This is an example where both characters are \"wide\" when displayed alone.\n        #\n        # But JUNGSEONG (vowel) is designed for combination with a CHOSEONG (consonant).\n        #\n        # This wcwidth library understands their width only when combination,\n        # and not by independent display, like other zero-width characters that may\n        # only combine with an appropriate preceding character.\n        phrase = (\n            u\"\\u1100\"  # \u1100 HANGUL CHOSEONG KIYEOK (consonant)\n            u\"\\u1161\"  # \u1161 HANGUL JUNGSEONG A (vowel)\n        )\n        expect_length_each = (2, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:247: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 4352\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_kr_jamo_filler","title":"test_core.py::test_kr_jamo_filler","text":"<pre>test_core.py::test_kr_jamo_filler</pre><pre>\ndef test_kr_jamo_filler():\n        u\"\"\"\n        Jamo filler is 0 width.\n\n        Example from https://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf\n        \"\"\"\n        phrase = (\n            u\"\\u1100\"  # HANGUL CHOSEONG KIYEOK (consonant)\n            u\"\\u1160\"  # HANGUL JUNGSEONG FILLER (vowel)\n        )\n        expect_length_each = (2, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:269: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 4352\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_devanagari_script","title":"test_core.py::test_devanagari_script","text":"<pre>test_core.py::test_devanagari_script</pre><pre>\ndef test_devanagari_script():\n        \"\"\"\n        Attempt to test the measurement width of Devanagari script.\n\n        I believe this 'phrase' should be length 3.\n\n        This is a difficult problem, and this library does not yet get it right,\n        because we interpret the unicode data files programmatically, but they do\n        not correctly describe how their terminal width is measured.\n\n        There are very few Terminals that do!\n\n        As of 2023,\n\n        - iTerm2: correct length but individual characters are out of order and\n                  horizaontally misplaced as to be unreadable in its language when\n                  using 'Noto Sans' font.\n        - mlterm: mixed results, it offers several options in the configuration\n                  dialog, \"Xft\", \"Cario\", and \"Variable Column Width\" have some\n                  effect, but with neither 'Noto Sans' or 'unifont', it is not\n                  recognizable as the Devanagari script it is meant to display.\n\n        Previous testing with Devanagari documented at address https://benizi.com/vim/devanagari/\n\n        See also, https://askubuntu.com/questions/8437/is-there-a-good-mono-spaced-font-for-devanagari-script-in-the-terminal\n        \"\"\"\n        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf\n        # please note that document correctly points out that the final width cannot be determined\n        # as a sum of each individual width, as this library currently performs with exception of\n        # ZWJ, but I think it incorrectly gestures what a stateless call to wcwidth.wcwidth of\n        # each codepoint *should* return.\n        phrase = (u\"\\u0915\"    # Akhand, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER KA\n                  u\"\\u094D\"    # Joiner, Category 'Mn', East Asian Width property 'N' -- DEVANAGARI SIGN VIRAMA\n                  u\"\\u0937\"    # Fused, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER SSA\n                  u\"\\u093F\")   # MatraL, Category 'Mc', East Asian Width property 'N' -- DEVANAGARI VOWEL SIGN I\n        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)\n        expect_length_each = (1, 0, 1, 0)\n        # I believe the final width *should* be 3.\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 2325\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_tamil_script","title":"test_core.py::test_tamil_script","text":"<pre>test_core.py::test_tamil_script</pre><pre>\ndef test_tamil_script():\n        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf\n        phrase = (u\"\\u0b95\"    # Akhand, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER KA\n                  u\"\\u0bcd\"    # Joiner, Category 'Mn', East Asian Width property 'N' -- TAMIL SIGN VIRAMA\n                  u\"\\u0bb7\"    # Fused, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER SSA\n                  u\"\\u0bcc\")   # MatraLR, Category 'Mc', East Asian Width property 'N' -- TAMIL VOWEL SIGN AU\n        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (3, 0, 0, 4)\n        expect_length_each = (1, 0, 1, 0)\n\n        # I believe the final width should be about 5 or 6.\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 2965\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_kannada_script","title":"test_core.py::test_kannada_script","text":"<pre>test_core.py::test_kannada_script</pre><pre>\ndef test_kannada_script():\n        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf\n        # |\u0cb0\u0ccd\u0c9d\u0cc8|\n        # |123|\n        phrase = (u\"\\u0cb0\"    # Repha, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA\n                  u\"\\u0ccd\"    # Joiner, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN VIRAMA\n                  u\"\\u0c9d\"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER JHA\n                  u\"\\u0cc8\")   # MatraUR, Category 'Mc', East Asian Width property 'N' -- KANNADA VOWEL SIGN AI\n        # 23107-terminal-suppt.pdf suggests should be (2, 0, 3, 1)\n        expect_length_each = (1, 0, 1, 0)\n        # I believe the correct final width *should* be 3 or 4.\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 3248\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_kannada_script_2","title":"test_core.py::test_kannada_script_2","text":"<pre>test_core.py::test_kannada_script_2</pre><pre>\ndef test_kannada_script_2():\n        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf\n        # |\u0cb0\u0cbc\u0ccd\u0c9a|\n        # |12|\n        phrase = (u\"\\u0cb0\"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA\n                  u\"\\u0cbc\"    # Nukta, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN NUKTA\n                  u\"\\u0ccd\"    # Joiner, Category 'Lo', East Asian Width property 'N' -- KANNADA SIGN VIRAMA\n                  u\"\\u0c9a\")   # Subjoin, Category 'Mc', East Asian Width property 'N' -- KANNADA LETTER CA\n        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)\n        expect_length_each = (1, 0, 0, 1)\n        # I believe the final width is correct, but maybe for the wrong reasons!\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_core.py:383: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 3248\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_corepytest_zero_wide_conflict","title":"test_core.py::test_zero_wide_conflict","text":"<pre>test_core.py::test_zero_wide_conflict</pre><pre>\ndef test_zero_wide_conflict():\n        # Test characters considered both \"wide\" and \"zero\" width\n        # -  (0x03000, 0x0303e,),  # Ideographic Space       ..Ideographic Variation In\n        # +  (0x03000, 0x03029,),  # Ideographic Space       ..Hangzhou Numeral Nine\n&gt;       assert wcwidth.wcwidth(unichr(0x03029), unicode_version='4.1.0') == 2\n\ntests/test_core.py:395: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 12329\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_unfinished_zwj_sequence","title":"test_emojis.py::test_unfinished_zwj_sequence","text":"<pre>test_emojis.py::test_unfinished_zwj_sequence</pre><pre>\n@pytest.mark.skipif(NARROW_ONLY, reason=\"Test cannot verify on python 'narrow' builds\")\n    def test_unfinished_zwj_sequence():\n        u\"\"\"\n        Ensure index-out-of-bounds does not occur for zero-width joiner without any following character\n        \"\"\"\n        phrase = (u\"\\U0001f469\"   # Base, Category So, East Asian Width property 'W' -- WOMAN\n                  u\"\\U0001f3fb\"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2\n                  u\"\\u200d\")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER\n        expect_length_each = (2, 0, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_emojis.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 128105\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_non_recommended_zwj_sequence","title":"test_emojis.py::test_non_recommended_zwj_sequence","text":"<pre>test_emojis.py::test_non_recommended_zwj_sequence</pre><pre>\n@pytest.mark.skipif(NARROW_ONLY, reason=\"Test cannot verify on python 'narrow' builds\")\n    def test_non_recommended_zwj_sequence():\n        \"\"\"\n        Verify ZWJ is measured as though successful with characters that cannot be joined, wcwidth does not verify\n        \"\"\"\n        phrase = (u\"\\U0001f469\"   # Base, Category So, East Asian Width property 'W' -- WOMAN\n                  u\"\\U0001f3fb\"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2\n                  u\"\\u200d\")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER\n        expect_length_each = (2, 0, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_emojis.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 128105\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_another_emoji_zwj_sequence","title":"test_emojis.py::test_another_emoji_zwj_sequence","text":"<pre>test_emojis.py::test_another_emoji_zwj_sequence</pre><pre>\n@pytest.mark.skipif(NARROW_ONLY, reason=\"Test cannot verify on python 'narrow' builds\")\n    def test_another_emoji_zwj_sequence():\n        phrase = (\n            u\"\\u26F9\"        # PERSON WITH BALL\n            u\"\\U0001F3FB\"    # EMOJI MODIFIER FITZPATRICK TYPE-1-2\n            u\"\\u200D\"        # ZERO WIDTH JOINER\n            u\"\\u2640\"        # FEMALE SIGN\n            u\"\\uFE0F\")       # VARIATION SELECTOR-16\n        expect_length_each = (1, 0, 0, 1, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_emojis.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 9977\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_longer_emoji_zwj_sequence","title":"test_emojis.py::test_longer_emoji_zwj_sequence","text":"<pre>test_emojis.py::test_longer_emoji_zwj_sequence</pre><pre>\n@pytest.mark.skipif(NARROW_ONLY, reason=\"Test cannot verify on python 'narrow' builds\")\n    def test_longer_emoji_zwj_sequence():\n        \"\"\"\n        A much longer emoji ZWJ sequence of 10 total codepoints is just 2 cells!\n\n        Also test the same sequence in duplicate, verifying multiple VS-16 sequences\n        in a single function call.\n        \"\"\"\n        # 'Category Code', 'East Asian Width property' -- 'description'\n        phrase = (u\"\\U0001F9D1\"   # 'So', 'W' -- ADULT\n                  u\"\\U0001F3FB\"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2\n                  u\"\\u200d\"       # 'Cf', 'N' -- ZERO WIDTH JOINER\n                  u\"\\u2764\"       # 'So', 'N' -- HEAVY BLACK HEART\n                  u\"\\uFE0F\"       # 'Mn', 'A' -- VARIATION SELECTOR-16\n                  u\"\\u200d\"       # 'Cf', 'N' -- ZERO WIDTH JOINER\n                  u\"\\U0001F48B\"   # 'So', 'W' -- KISS MARK\n                  u\"\\u200d\"       # 'Cf', 'N' -- ZERO WIDTH JOINER\n                  u\"\\U0001F9D1\"   # 'So', 'W' -- ADULT\n                  u\"\\U0001F3FD\"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-4\n        ) * 2\n        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf\n        expect_length_each = (2, 0, 0, 1, 0, 0, 2, 0, 2, 0) * 2\n        expect_length_phrase = 4\n\n        # exercise,\n&gt;       length_each = tuple(map(wcwidth.wcwidth, phrase))\n\ntests/test_emojis.py:140: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 129489\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_recommended_emoji_zwj_sequences","title":"test_emojis.py::test_recommended_emoji_zwj_sequences","text":"<pre>test_emojis.py::test_recommended_emoji_zwj_sequences</pre><pre>\n@pytest.mark.skipif(NARROW_ONLY, reason=\"Some sequences in text file are not compatible with 'narrow' builds\")\n    def test_recommended_emoji_zwj_sequences():\n        \"\"\"\n        Test wcswidth of all of the unicode.org-published emoji-zwj-sequences.txt\n        \"\"\"\n        # given,\n        lines, sequences = read_sequences_from_file('emoji-zwj-sequences.txt')\n\n        errors = []\n        # Exercise, track by zipping with original text file line, a debugging aide\n        num = 0\n        for sequence, line in zip(sequences, lines):\n            num += 1\n&gt;           measured_width = wcwidth.wcswidth(sequence)\n\ntests/test_emojis.py:171: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:177: in wcswidth\n    char_width = wcwidth(char, unicode_version)\nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 128104\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_recommended_variation_16_sequences","title":"test_emojis.py::test_recommended_variation_16_sequences","text":"<pre>test_emojis.py::test_recommended_variation_16_sequences</pre><pre>\ndef test_recommended_variation_16_sequences():\n        \"\"\"\n        Test wcswidth of all of the unicode.org-published emoji-variation-sequences.txt\n        \"\"\"\n        # given,\n        lines, sequences = read_sequences_from_file('emoji-variation-sequences.txt')\n\n        errors = []\n        num = 0\n        for sequence, line in zip(sequences, lines):\n            num += 1\n            if '\\ufe0f' not in sequence:\n                # filter for only \\uFE0F (VS-16)\n                continue\n&gt;           measured_width = wcwidth.wcswidth(sequence)\n\ntests/test_emojis.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:177: in wcswidth\n    char_width = wcwidth(char, unicode_version)\nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 35\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_unicode_9_vs16","title":"test_emojis.py::test_unicode_9_vs16","text":"<pre>test_emojis.py::test_unicode_9_vs16</pre><pre>\ndef test_unicode_9_vs16():\n        \"\"\"Verify effect of VS-16 on unicode_version 9.0 and later\"\"\"\n        phrase = (u\"\\u2640\"        # FEMALE SIGN\n                  u\"\\uFE0F\")       # VARIATION SELECTOR-16\n\n        expect_length_each = (1, 0)\n        expect_length_phrase = 2\n\n        # exercise,\n&gt;       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)\n\ntests/test_emojis.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_emojis.py:222: in \n    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)\nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 9792\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError"},{"location":"analysis_baseline_wcwidth/#test_emojispytest_unicode_8_vs16","title":"test_emojis.py::test_unicode_8_vs16","text":"<pre>test_emojis.py::test_unicode_8_vs16</pre><pre>\ndef test_unicode_8_vs16():\n        \"\"\"Verify that VS-16 has no effect on unicode_version 8.0 and earler\"\"\"\n        phrase = (u\"\\u2640\"        # FEMALE SIGN\n                  u\"\\uFE0F\")       # VARIATION SELECTOR-16\n\n        expect_length_each = (1, 0)\n        expect_length_phrase = 1\n\n        # exercise,\n&gt;       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)\n\ntests/test_emojis.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_emojis.py:238: in \n    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)\nwcwidth/wcwidth.py:136: in wcwidth\n    if _bisearch(ucs, ZERO_WIDTH):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nucs = 9792\ntable = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}\n\n    def _bisearch(ucs, table):\n        \"\"\"\n        Auxiliary function for binary search in interval table.\n\n        :arg int ucs: Ordinal value of unicode character.\n        :arg list table: List of starting and ending ranges of ordinal values,\n            in form of ``[(start, end), ...]``.\n        :rtype: int\n        :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n        \"\"\"\n        lbound = 0\n        ubound = len(table) - 1\n\n&gt;       if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\nE       KeyError: 0\n\nwcwidth/wcwidth.py:91: KeyError"},{"location":"analysis_baseline_wcwidth/#test_table_integritypytest_verify_table_integrity","title":"test_table_integrity.py::test_verify_table_integrity","text":"<pre>test_table_integrity.py::test_verify_table_integrity</pre><pre>\n('/testbed/tests/test_table_integrity.py', 10, 'Skipped: Test only with a single version of python')\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_505_str","title":"test_ucslevel.py::test_nearest_505_str","text":"<pre>test_ucslevel.py::test_nearest_505_str</pre><pre>\ndef test_nearest_505_str():\n        \"\"\"wcwidth._wcmatch_version('5.0.5') returns nearest '5.0.0'. (str)\"\"\"\n        # given\n        given, expected = '5.0.5', '5.0.0'\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '5.0.5'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_505_unicode","title":"test_ucslevel.py::test_nearest_505_unicode","text":"<pre>test_ucslevel.py::test_nearest_505_unicode</pre><pre>\ndef test_nearest_505_unicode():\n        \"\"\"wcwidth._wcmatch_version(u'5.0.5') returns nearest u'5.0.0'. (unicode)\"\"\"\n        # given\n        given, expected = u'5.0.5', u'5.0.0'\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '5.0.5'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_800_str","title":"test_ucslevel.py::test_nearest_800_str","text":"<pre>test_ucslevel.py::test_nearest_800_str</pre><pre>\ndef test_nearest_800_str():\n        \"\"\"wcwidth._wcmatch_version('8') returns nearest '8.0.0'.\"\"\"\n        # given\n        given, expected = '8', '8.0.0'\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '8'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '8' not found, using '7.0.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_800_unicode","title":"test_ucslevel.py::test_nearest_800_unicode","text":"<pre>test_ucslevel.py::test_nearest_800_unicode</pre><pre>\ndef test_nearest_800_unicode():\n        \"\"\"wcwidth._wcmatch_version(u'8') returns nearest u'8.0.0'.\"\"\"\n        # given\n        given, expected = u'8', u'8.0.0'\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '8'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '8' not found, using '7.0.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_999_str","title":"test_ucslevel.py::test_nearest_999_str","text":"<pre>test_ucslevel.py::test_nearest_999_str</pre><pre>\ndef test_nearest_999_str():\n        \"\"\"wcwidth._wcmatch_version('999.0') returns nearest (latest).\"\"\"\n        # given\n        given, expected = '999.0', wcwidth.list_versions()[-1]\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '999.0'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '999.0' not found, using '15.1.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nearest_999_unicode","title":"test_ucslevel.py::test_nearest_999_unicode","text":"<pre>test_ucslevel.py::test_nearest_999_unicode</pre><pre>\ndef test_nearest_999_unicode():\n        \"\"\"wcwidth._wcmatch_version(u'999.0') returns nearest (latest).\"\"\"\n        # given\n        given, expected = u'999.0', wcwidth.list_versions()[-1]\n\n        # exercise\n&gt;       result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngiven_version = '999.0'\n\n    @lru_cache(maxsize=8)\n    def _wcmatch_version(given_version):\n        \"\"\"\n        Return nearest matching supported Unicode version level.\n\n        If an exact match is not determined, the nearest lowest version level is\n        returned after a warning is emitted.  For example, given supported levels\n        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``\n        is selected and returned:\n\n        &gt;&gt;&gt; _wcmatch_version('4.9.9')\n        '4.1.0'\n        &gt;&gt;&gt; _wcmatch_version('8.0')\n        '8.0.0'\n        &gt;&gt;&gt; _wcmatch_version('1')\n        '4.1.0'\n\n        :param str given_version: given version for compare, may be ``auto``\n            (default), to select Unicode Version from Environment Variable,\n            ``UNICODE_VERSION``. If the environment variable is not set, then the\n            latest is used.\n        :rtype: str\n        :returns: unicode string, or non-unicode ``str`` type for python 2\n            when given ``version`` is also type ``str``.\n        \"\"\"\n        if given_version == 'auto':\n            given_version = os.environ.get('UNICODE_VERSION', 'latest')\n\n        if given_version == 'latest':\n            return list_versions()[-1]\n\n        supported_versions = list_versions()\n        given_value = _wcversion_value(given_version)\n\n        for version in reversed(supported_versions):\n            if _wcversion_value(version) &lt;= given_value:\n                if version != given_version:\n&gt;                   warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\nE                   UserWarning: Unicode version '999.0' not found, using '15.1.0'\n\nwcwidth/wcwidth.py:234: UserWarning\n</pre>"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nonint_unicode","title":"test_ucslevel.py::test_nonint_unicode","text":"<pre>test_ucslevel.py::test_nonint_unicode</pre><pre>\ndef test_nonint_unicode():\n        \"\"\"wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode).\"\"\"\n        # given\n        given, expected = u'x.y.z', wcwidth.list_versions()[-1]\n        warnings.resetwarnings()\n        wcwidth._wcmatch_version.cache_clear()\n\n        # exercise\n        with pytest.warns(UserWarning):\n            # warns that given version is not valid\n&gt;           result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:229: in _wcmatch_version\n    given_value = _wcversion_value(given_version)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nver_string = 'x.y.z'\n\n    @lru_cache(maxsize=128)\n    def _wcversion_value(ver_string):\n        \"\"\"\n        Integer-mapped value of given dotted version string.\n\n        :param str ver_string: Unicode version string, of form ``n.n.n``.\n        :rtype: tuple(int)\n        :returns: tuple of digit tuples, ``tuple(int, [...])``.\n        \"\"\"\n&gt;       return tuple(map(int, ver_string.split('.')))\nE       ValueError: invalid literal for int() with base 10: 'x'\n\nwcwidth/wcwidth.py:194: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_nonint_unicode():\n        \"\"\"wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode).\"\"\"\n        # given\n        given, expected = u'x.y.z', wcwidth.list_versions()[-1]\n        warnings.resetwarnings()\n        wcwidth._wcmatch_version.cache_clear()\n\n        # exercise\n&gt;       with pytest.warns(UserWarning):\nE       Failed: DID NOT WARN. No warnings of type (,) were emitted.\nE        Emitted warnings: [].\n\ntests/test_ucslevel.py:161: Failed"},{"location":"analysis_baseline_wcwidth/#test_ucslevelpytest_nonint_str","title":"test_ucslevel.py::test_nonint_str","text":"<pre>test_ucslevel.py::test_nonint_str</pre><pre>\ndef test_nonint_str():\n        \"\"\"wcwidth._wcmatch_version(u'x.y.z') returns latest (str).\"\"\"\n        # given\n        given, expected = 'x.y.z', wcwidth.list_versions()[-1]\n        warnings.resetwarnings()\n        wcwidth._wcmatch_version.cache_clear()\n\n        # exercise\n        with pytest.warns(UserWarning):\n            # warns that given version is not valid\n&gt;           result = wcwidth._wcmatch_version(given)\n\ntests/test_ucslevel.py:179: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nwcwidth/wcwidth.py:229: in _wcmatch_version\n    given_value = _wcversion_value(given_version)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nver_string = 'x.y.z'\n\n    @lru_cache(maxsize=128)\n    def _wcversion_value(ver_string):\n        \"\"\"\n        Integer-mapped value of given dotted version string.\n\n        :param str ver_string: Unicode version string, of form ``n.n.n``.\n        :rtype: tuple(int)\n        :returns: tuple of digit tuples, ``tuple(int, [...])``.\n        \"\"\"\n&gt;       return tuple(map(int, ver_string.split('.')))\nE       ValueError: invalid literal for int() with base 10: 'x'\n\nwcwidth/wcwidth.py:194: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_nonint_str():\n        \"\"\"wcwidth._wcmatch_version(u'x.y.z') returns latest (str).\"\"\"\n        # given\n        given, expected = 'x.y.z', wcwidth.list_versions()[-1]\n        warnings.resetwarnings()\n        wcwidth._wcmatch_version.cache_clear()\n\n        # exercise\n&gt;       with pytest.warns(UserWarning):\nE       Failed: DID NOT WARN. No warnings of type (,) were emitted.\nE        Emitted warnings: [].\n\ntests/test_ucslevel.py:177: Failed"},{"location":"analysis_baseline_wcwidth/#patch-diff","title":"Patch diff","text":"<pre><code>diff --git a/wcwidth/unicode_versions.py b/wcwidth/unicode_versions.py\nindex cc437d7..5c07028 100644\n--- a/wcwidth/unicode_versions.py\n+++ b/wcwidth/unicode_versions.py\n@@ -15,4 +15,8 @@ def list_versions():\n     :returns: Supported Unicode version numbers in ascending sorted order.\n     :rtype: list[str]\n     \"\"\"\n-    pass\n+    return [\n+        '4.1.0', '5.0.0', '5.1.0', '5.2.0', '6.0.0', '6.1.0', '6.2.0', '6.3.0',\n+        '7.0.0', '8.0.0', '9.0.0', '10.0.0', '11.0.0', '12.0.0', '12.1.0',\n+        '13.0.0', '14.0.0', '15.0.0', '15.1.0'\n+    ]\ndiff --git a/wcwidth/wcwidth.py b/wcwidth/wcwidth.py\nindex 6d93a59..8daf7de 100644\n--- a/wcwidth/wcwidth.py\n+++ b/wcwidth/wcwidth.py\n@@ -85,7 +85,22 @@ def _bisearch(ucs, table):\n     :rtype: int\n     :returns: 1 if ordinal value ucs is found within lookup table, else 0.\n     \"\"\"\n-    pass\n+    lbound = 0\n+    ubound = len(table) - 1\n+\n+    if ucs &lt; table[0][0] or ucs &gt; table[-1][1]:\n+        return 0\n+\n+    while ubound &gt;= lbound:\n+        mid = (lbound + ubound) // 2\n+        if ucs &gt; table[mid][1]:\n+            lbound = mid + 1\n+        elif ucs &lt; table[mid][0]:\n+            ubound = mid - 1\n+        else:\n+            return 1\n+\n+    return 0\n\n\n @lru_cache(maxsize=1000)\n@@ -111,7 +126,26 @@ def wcwidth(wc, unicode_version='auto'):\n\n     See :ref:`Specification` for details of cell measurement.\n     \"\"\"\n-    pass\n+    ucs = ord(wc)\n+    \n+    # C0/C1 control characters\n+    if ucs &lt; 32 or 0x07F &lt;= ucs &lt; 0x0A0:\n+        return -1\n+\n+    # Check if the character is in the zero width table\n+    if _bisearch(ucs, ZERO_WIDTH):\n+        return 0\n+\n+    # Check if the character is in the wide East Asian table\n+    if _bisearch(ucs, WIDE_EASTASIAN):\n+        return 2\n+\n+    # Check if it's a combining character\n+    if ucs in VS16_NARROW_TO_WIDE:\n+        return 2\n+\n+    # All other characters are considered to have a width of 1\n+    return 1\n\n\n def wcswidth(pwcs, n=None, unicode_version='auto'):\n@@ -135,7 +169,17 @@ def wcswidth(pwcs, n=None, unicode_version='auto'):\n\n     See :ref:`Specification` for details of cell measurement.\n     \"\"\"\n-    pass\n+    if n is None:\n+        n = len(pwcs)\n+    \n+    width = 0\n+    for char in pwcs[:n]:\n+        char_width = wcwidth(char, unicode_version)\n+        if char_width == -1:\n+            return -1\n+        width += char_width\n+    \n+    return width\n\n\n @lru_cache(maxsize=128)\n@@ -147,7 +191,7 @@ def _wcversion_value(ver_string):\n     :rtype: tuple(int)\n     :returns: tuple of digit tuples, ``tuple(int, [...])``.\n     \"\"\"\n-    pass\n+    return tuple(map(int, ver_string.split('.')))\n\n\n @lru_cache(maxsize=8)\n@@ -175,4 +219,21 @@ def _wcmatch_version(given_version):\n     :returns: unicode string, or non-unicode ``str`` type for python 2\n         when given ``version`` is also type ``str``.\n     \"\"\"\n-    pass\n+    if given_version == 'auto':\n+        given_version = os.environ.get('UNICODE_VERSION', 'latest')\n+    \n+    if given_version == 'latest':\n+        return list_versions()[-1]\n+    \n+    supported_versions = list_versions()\n+    given_value = _wcversion_value(given_version)\n+    \n+    for version in reversed(supported_versions):\n+        if _wcversion_value(version) &lt;= given_value:\n+            if version != given_version:\n+                warnings.warn(f\"Unicode version '{given_version}' not found, using '{version}'\")\n+            return version\n+    \n+    # If no suitable version found, return the earliest supported version\n+    warnings.warn(f\"Unicode version '{given_version}' not found, using '{supported_versions[0]}'\")\n+    return supported_versions[0]\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#commit0","title":"Commit0","text":"<p>Commit0 provides several commands to facilitate the process of cloning, building, testing, and evaluating repositories. Here's an overview of the available commands:</p>"},{"location":"api/#setup","title":"Setup","text":"<p>Use <code>commit0 setup [OPTIONS] REPO_SPLIT</code> to clone a repository split. Available options include:</p> Argument Type Description Default <code>repo_split</code> str Split of repositories to clone <code>--dataset-name</code> str Name of the Huggingface dataset <code>wentingzhao/commit0_combined</code> <code>--dataset-split</code> str Split of the Huggingface dataset <code>test</code> <code>--base-dir</code> str Base directory to clone repos to <code>repos/</code> <code>--commit0-dot-file-path</code> str Storing path for stateful commit0 configs <code>.commit0.yaml</code>"},{"location":"api/#build","title":"Build","text":"<p>Use <code>commit0 build [OPTIONS]</code> to build the Commit0 split chosen in the Setup stage. Available options include:</p> Argument Type Description Default <code>--num-workers</code> int Number of workers <code>8</code> <code>--commit0-dot-file-path</code> str Path to the commit0 dot file <code>.commit0.yaml</code> <code>--verbose</code> int Verbosity level (1 or 2) <code>1</code>"},{"location":"api/#get-tests","title":"Get Tests","text":"<p>Use <code>commit0 get-tests REPO_NAME</code> to get tests for a Commit0 repository.</p> Argument Type Description Default <code>repo_name</code> str Name of the repository to get tests for"},{"location":"api/#test","title":"Test","text":"<p>Use <code>commit0 test [OPTIONS] REPO_OR_REPO_PATH [TEST_IDS]</code> to run tests on a Commit0 repository. Available options include:</p> Argument Type Description Default <code>repo_or_repo_path</code> str Directory of the repository to test <code>test_ids</code> str Test IDs to run <code>--branch</code> str Branch to test <code>--backend</code> str Backend to use for testing <code>modal</code> <code>--timeout</code> int Timeout for tests in seconds <code>1800</code> <code>--num-cpus</code> int Number of CPUs to use <code>1</code> <code>--reference</code> bool Test the reference commit <code>False</code> <code>--coverage</code> bool Get coverage information <code>False</code> <code>--rebuild</code> bool Rebuild an image <code>False</code> <code>--commit0-dot-file-path</code> str Path to the commit0 dot file <code>.commit0.yaml</code> <code>--verbose</code> int Verbosity level (1 or 2) <code>1</code> <code>--stdin</code> bool Read test names from stdin <code>False</code>"},{"location":"api/#evaluate","title":"Evaluate","text":"<p>Use <code>commit0 evaluate [OPTIONS]</code> to evaluate the Commit0 split chosen in the Setup stage. Available options include:</p> Argument Type Description Default <code>--branch</code> str Branch to evaluate <code>--backend</code> str Backend to use for evaluation <code>modal</code> <code>--timeout</code> int Timeout for evaluation in seconds <code>1800</code> <code>--num-cpus</code> int Number of CPUs to use <code>1</code> <code>--num-workers</code> int Number of workers to use <code>8</code> <code>--reference</code> bool Evaluate the reference commit <code>False</code> <code>--coverage</code> bool Get coverage information <code>False</code> <code>--commit0-dot-file-path</code> str Path to the commit0 dot file <code>.commit0.yaml</code> <code>--rebuild</code> bool Rebuild images <code>False</code>"},{"location":"api/#lint","title":"Lint","text":"<p>Use <code>commit0 lint [OPTIONS] REPO_OR_REPO_DIR</code> to lint files in a repository. Available options include:</p> Argument Type Description Default <code>repo_or_repo_dir</code> str Directory of the repository to test <code>--files</code> List[Path] Files to lint (optional) <code>--commit0-dot-file-path</code> str Path to the commit0 dot file <code>.commit0.yaml</code> <code>--verbose</code> int Verbosity level (1 or 2) <code>1</code>"},{"location":"api/#save","title":"Save","text":"<p>Use <code>commit0 save [OPTIONS] OWNER BRANCH</code> to save the Commit0 split to GitHub. Available options include:</p> Argument Type Description Default <code>owner</code> str Owner of the repository <code>branch</code> str Branch to save <code>--github-token</code> str GitHub token for authentication <code>--commit0-dot-file-path</code> str Path to the commit0 dot file <code>.commit0.yaml</code>"},{"location":"api/#agent","title":"Agent","text":""},{"location":"api/#config","title":"Config","text":"<p>Use <code>agent config [OPTIONS] AGENT_NAME</code> to set up the configuration for an agent. Available options include:</p> Argument Type Description Default <code>agent_name</code> str Agent to use, we only support aider for now. <code>aider</code> <code>--model-name</code> str LLM model to use, check here for all supported models. <code>claude-3-5-sonnet-20240620</code> <code>--use-user-prompt</code> bool Use a custom prompt instead of the default prompt. <code>False</code> <code>--user-prompt</code> str The prompt sent to agent. See code for details. <code>--run-tests</code> bool Run tests after code modifications for feedback. You need to set up <code>docker</code> or <code>modal</code> before running tests, refer to commit0 docs. <code>False</code> <code>--max-iteration</code> int Maximum number of agent iterations. <code>3</code> <code>--use-repo-info</code> bool Include the repository information. <code>False</code> <code>--max-repo-info-length</code> int Maximum length of the repository information to use. <code>10000</code> <code>--use-unit-tests-info</code> bool Include the unit tests information. <code>False</code> <code>--max-unit-tests-info-length</code> int Maximum length of the unit tests information to use. <code>10000</code> <code>--use-spec-info</code> bool Include the spec information. <code>False</code> <code>--max-spec-info-length</code> int Maximum length of the spec information to use. <code>10000</code> <code>--use-lint-info</code> bool Include the lint information. <code>False</code> <code>--max-lint-info-length</code> int Maximum length of the lint information to use. <code>10000</code> <code>--pre-commit-config-path</code> str Path to the pre-commit config file. This is needed for running <code>lint</code>. <code>.pre-commit-config.yaml</code> <code>--agent-config-file</code> str Path to write the agent config. <code>.agent.yaml</code>"},{"location":"api/#running","title":"Running","text":"<p>Use <code>agent run [OPTIONS] BRANCH</code> to execute an agent on a specific branch. Available options include:</p> Argument Type Description Default <code>branch</code> str Branch to run the agent on, you can specific the name of the branch <code>--backend</code> str Test backend to run the agent on, ignore this option if you are not adding <code>run_tests</code> option to agent. <code>modal</code> <code>--log-dir</code> str Log directory to store the logs. <code>logs/aider</code> <code>--max-parallel-repos</code> int Maximum number of repositories for agent to run in parallel. Running in sequential if set to 1. <code>1</code> <code>--display-repo-progress-num</code> int Number of repo progress displayed when running. <code>5</code>"},{"location":"baseline/","title":"Baseline","text":"<p>Commit0 contains a baseline system based on the Aider code generation system.</p> <p>...</p>"},{"location":"distributed/","title":"Distributed","text":"<p>One of the main advantages of <code>commit0</code> is that it can run a range of unit tests in distributed environments.</p> <p>By default, the library is configured to work with modal.</p> <pre><code>pip install modal\nmodal token new\n</code></pre>"},{"location":"distributed/#modal-setup","title":"Modal Setup","text":"<p>To enable distributed run, first create a file called <code>distributed.yaml</code></p> <pre><code>backend: modal\nbase_dir: repos.dist/\n</code></pre> <p>You can pass this configuration file as an argumnet to clone.</p> <pre><code>commit0 clone lite --cfg=distributed\n</code></pre> <p>Next to run tests you can run the standard test command.</p> <pre><code>commit0 test simpy master tests/test_event.py::test_succeed --cfg=distributed\n</code></pre>"},{"location":"repos/","title":"Repos","text":"<p>Directions for how to add new repositories.</p>"},{"location":"setupdist/","title":"Commit0","text":""},{"location":"setupdist/#distributed-mode","title":"Distributed Mode","text":"<p>Commit0 is a command-line tool that allows you to run unit-tests on a variety of libraries in isolated environments.</p> <p>The defaul tool uses modal as a distributed test runner.</p> <pre><code>pip install modal\nmodal token new\n</code></pre> <p>To get started, run the <code>setup</code> command with the dataset split that youare interested in working with. We'll start with the <code>lite</code> split.</p> <pre><code>commit0 setup lite\n</code></pre> <p>This will clone a set of skeleton libraries in your <code>repos/</code> directory. Commiting changes to branches in this directory is how you send changes to the test runner.</p> <p>Next to run tests you can run the standard test command. This command will run a reference unit test for the <code>simpy</code> repo.</p> <pre><code>commit0 test simpy tests/test_event.py::test_succeed --reference\n</code></pre> <p>To run a test in your codebase you can run with no args. This one will fail.</p> <pre><code>commit0 test simpy tests/test_event.py::test_succeed\n</code></pre> <p>To run a test in your codebase with a specific branch you can commit to the branch and call with the --branch command.</p> <pre><code>commit0 test simpy tests/test_event.py::test_succeed --branch my_branch\n</code></pre>"},{"location":"setupdist/#local-mode","title":"Local Mode","text":"<p>To run in local mode you first be sure that you have docker tools installed. On Debian systems:</p> <pre><code>apt install docker\n</code></pre> <p>To get started, run the <code>setup</code> command with the dataset split that you are interested in working with. We'll start with the <code>lite</code> split.</p> <pre><code>commit0 setup lite\n</code></pre> <p>This will install a clone the code for subset of libraries to your <code>repos/</code> directory.</p> <p>Next run the <code>build</code> command which will configure Docker containers for each of the libraries with isolated virtual environments. The command uses the uv library for efficient builds.</p> <pre><code>commit0 build\n</code></pre> <p>The main operation you can do with these enviroments is to run tests. Here we run a test in the <code>simpy</code> library.</p> <pre><code>commit0 test simpy tests/test_event.py::test_succeed\n</code></pre> <p>See distributed setup for more commands.</p>"},{"location":"setuplocal/","title":"Setuplocal","text":""},{"location":"setuplocal/#local-mode","title":"Local Mode","text":"<p>To run in local mode you first be sure that you have docker tools installed. On Debian systems:</p> <pre><code>apt install docker\n</code></pre> <p>To get started, run the <code>setup</code> command with the dataset split that you are interested in working with. We'll start with the <code>lite</code> split.</p> <pre><code>commit0 setup lite\n</code></pre> <p>This will install a clone the code for subset of libraries to your <code>repos/</code> directory.</p> <p>Next run the <code>build</code> command which will configure Docker containers for each of the libraries with isolated virtual environments. The command uses the uv library for efficient builds.</p> <pre><code>commit0 build\n</code></pre> <p>The main operation you can do with these enviroments is to run tests. Here we run a test in the <code>simpy</code> library.</p> <pre><code>commit0 test simpy tests/test_event.py::test_succeed\n</code></pre> <p>See distributed setup for more commands.</p>"},{"location":"table/","title":"Table","text":"Name Repo Commit0 Tests minitorch [orig] [commit0] 230 simpy [orig] [commit0] 140 bitstring [orig] [commit0] 834 tinydb [orig] [commit0] 201 marshmallow [orig] [commit0] 1229 python-prompt-toolkit [orig] [commit0] 151 parsel [orig] [commit0] 343 pyjwt pyjwt [orig] [commit0] 259 networkx [orig] [commit0] 5440 graphene [orig] [commit0] 447 tlslite-ng tlslite-ng [orig] [commit0] 1653 wcwidth wcwidth [orig] [commit0] 38 chardet chardet [orig] [commit0] 376 dnspython dnspython [orig] [commit0] 1304 imapclient imapclient [orig] [commit0] 267 virtualenv [orig] [commit0] 284 pexpect pexpect [orig] [commit0] 255 web3.py [orig] [commit0] 40433 babel [orig] [commit0] 5663 geopandas [orig] [commit0] 2196 dulwich dulwich [orig] [commit0] 1522 flask [orig] [commit0] 477 voluptuous voluptuous [orig] [commit0] 149 jinja [orig] [commit0] 851 seaborn [orig] [commit0] 2362 requests requests [orig] [commit0] 590 scrapy [orig] [commit0] 2904 fastapi [orig] [commit0] 2013 click [orig] [commit0] 589 python-rsa [orig] [commit0] 86 statsmodels [orig] [commit0] 17669 more-itertools more-itertools [orig] [commit0] 662 moviepy [orig] [commit0] 109 deprecated deprecated [orig] [commit0] 171 pydantic [orig] [commit0] 5091 loguru [orig] [commit0] 1461 pypdf [orig] [commit0] 911 attrs [orig] [commit0] 1414 mimesis [orig] [commit0] 6159 cookiecutter [orig] [commit0] 367 tornado [orig] [commit0] 1150 imbalanced-learn [orig] [commit0] 2310 python-progressbar [orig] [commit0] 385 PyBoy [orig] [commit0] 201 pytest [orig] [commit0] 3612 pylint [orig] [commit0] 1878 sphinx [orig] [commit0] 2187 joblib [orig] [commit0] 1450 xarray [orig] [commit0] 15643 cachetools cachetools [orig] [commit0] 215 paramiko paramiko [orig] [commit0] 557 fabric [orig] [commit0] 353 filesystem_spec [orig] [commit0] 698 jedi jedi [orig] [commit0] 3854 sqlparse sqlparse [orig] [commit0] 461 portalocker [orig] [commit0] 38"}]}