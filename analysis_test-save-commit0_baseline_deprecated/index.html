
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis test save commit0 baseline deprecated - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-base-baseline" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis test save commit0 baseline deprecated
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_and_blocked" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_and_blocked
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_and" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_and
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_operator_nested_or" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_operator_nested_or
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_nested_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_nested_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_cond_with_uncaught_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_cond_with_uncaught_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_iand_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_iand_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_or_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_or_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_ior_with_and_cond" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_ior_with_and_cond
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_immutable_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_immutable_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_and_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_and_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_shared_or_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_shared_or_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_condition_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_condition_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_conditionpytest_nested_result_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_condition.py::test_nested_result_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_event_queue_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_event_queue_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_negative_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_negative_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_resume" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_resume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_until_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_until_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_processed_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_processed_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_environmentpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_environment.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_succeed" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_succeed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_fail" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_fail
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_unavailable_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_unavailable_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_triggered" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_triggered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_eventpytest_condition_nested_callback_removal" class="md-nav__link">
    <span class="md-ellipsis">
      test_event.py::test_condition_nested_callback_removal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_error_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_error_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_no_parent_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_no_parent_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_crashing_child_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_crashing_child_traceback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_invalid_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_invalid_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_callback_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_callback_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_handling" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_process_exception_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_process_exception_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspytest_sys_excepthook" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::test_sys_excepthook
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interruption" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interruption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_interrupts_and_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_interrupts_and_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_init_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_init_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_terminated_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_terminated_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_multiple_interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_multiple_interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_self" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_self
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_immediate_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_immediate_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_interrupt_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_interrupt_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interruptspytest_concurrent_behaviour" class="md-nav__link">
    <span class="md-ellipsis">
      test_interrupts.py::test_concurrent_behaviour
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_get_state" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_get_state
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_target" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_target
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_wait_for_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_wait_for_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_return_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_return_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_child_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_child_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_processpytest_interrupted_join_and_rejoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_process.py::test_interrupted_join_and_rejoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_continue_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_continue_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_release_after_interrupt" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_release_after_interrupt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_immediate_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_immediate_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_cm_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_cm_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_condition" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_condition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_resource_with_priority_queue" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_resource_with_priority_queue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_sorted_queue_maxlen" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_sorted_queue_maxlen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_get_users" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_get_users
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_preemptive_resource_timeout_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_preemptive_resource_timeout_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_mixed_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_mixed_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_nested_preemption" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_nested_preemption
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_container_get_queued" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_container_get_queued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_capacity" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_capacity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_store_cancel" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_store_cancel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_item_priority" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_item_priority
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_priority_store_stable_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_priority_store_stable_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_store_get_after_mismatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_store_get_after_mismatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_best_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_best_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_filter_calls_worst_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_filter_calls_worst_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_put_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_put_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_resourcespytest_immediate_get_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_resources.py::test_immediate_get_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt01" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt005" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.05]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt015" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt[0.15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_multiple_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_multiple_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_default_behavior" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_default_behavior
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_slow_sim_no_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_slow_sim_no_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_illegal_until" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_illegal_until
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_rt_sync" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_rt_sync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rtpytest_run_with_untriggered_event" class="md-nav__link">
    <span class="md-ellipsis">
      test_rt.py::test_run_with_untriggered_event
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_discrete_time_steps" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_discrete_time_steps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_negative_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_negative_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_timeout_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_timeout_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_shared_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_shared_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_timeoutpytest_triggered_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_timeout.py::test_triggered_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_start_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_start_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_terminated_proc" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_terminated_proc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_with_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_with_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_subscribe_at_timeout_with_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_subscribe_at_timeout_with_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_wait_for_all_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_wait_for_all_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_chaining_intermediate_results" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_chaining_intermediate_results
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_chaining" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_chaining
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_any_of_with_triggered_events" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_any_of_with_triggered_events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_any_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_any_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_empty_all_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_empty_all_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpytest_all_of_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::test_all_of_expansion
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_1" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_corepytest_empty_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_empty_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_hello_jp" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_hello_jp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_wcswidth_substr" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_wcswidth_substr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_null_width_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_null_width_0
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_control_c0_width_negative_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_control_c0_width_negative_1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_width" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_width
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_cafe" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_cafe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_combining_enclosing" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_combining_enclosing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_balinese_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_balinese_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kr_jamo" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kr_jamo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kr_jamo_filler" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kr_jamo_filler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_devanagari_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_devanagari_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_tamil_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_tamil_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kannada_script" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kannada_script
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_kannada_script_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_kannada_script_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_corepytest_zero_wide_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_core.py::test_zero_wide_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unfinished_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unfinished_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_non_recommended_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_non_recommended_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_another_emoji_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_another_emoji_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_longer_emoji_zwj_sequence" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_longer_emoji_zwj_sequence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_recommended_emoji_zwj_sequences" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_recommended_emoji_zwj_sequences
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_recommended_variation_16_sequences" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_recommended_variation_16_sequences
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unicode_9_vs16" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unicode_9_vs16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_emojispytest_unicode_8_vs16" class="md-nav__link">
    <span class="md-ellipsis">
      test_emojis.py::test_unicode_8_vs16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_table_integritypytest_verify_table_integrity" class="md-nav__link">
    <span class="md-ellipsis">
      test_table_integrity.py::test_verify_table_integrity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_505_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_505_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_505_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_505_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_800_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_800_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_800_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_800_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_999_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_999_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nearest_999_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nearest_999_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nonint_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nonint_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ucslevelpytest_nonint_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_ucslevel.py::test_nonint_str
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_2" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_3" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests_4" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_2" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_2" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function1" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function2" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function3" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function4" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function5" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function6" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class__warnsnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class__warns[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class__warnsclassic_deprecated_class2" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method4" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method5" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method6" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method4" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method5" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method6" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method4" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method5" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method6" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_should_raise_type_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_should_raise_type_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_warning_msg_has_reason" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_warning_msg_has_reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_warning_msg_has_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_warning_msg_has_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_specific_warning_cls_is_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_specific_warning_cls_is_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_respect_global_filter" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_respect_global_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_classpytest_class_deprecation_using_deprecated_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_classpytest_class_respect_global_filter" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_class.py::test_class_respect_global_filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_classpytest_subclass_deprecation_using_deprecated_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_classpytest_simple_class_deprecation_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_class.py::test_simple_class_deprecation_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_metaclasspytest_with_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_metaclass.py::test_with_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_metaclasspytest_with_new" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_metaclass.py::test_with_new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_metaclasspytest_with_metaclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_metaclass.py::test_with_metaclass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecated_metaclasspytest_with_singleton_metaclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated_metaclass.py::test_with_singleton_metaclass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method0" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method1" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method2" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method3" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_warning_msg_has_reason" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_warning_msg_has_reason
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_warning_msg_has_version" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_warning_msg_has_version
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_specific_warning_cls_is_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_specific_warning_cls_is_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_syntax_trimminguse-functionbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_syntax_trimming[Use :function:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_sphinx_syntax_trimminguse-pyfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-funcbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-functionbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :function:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-classbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :class:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-excbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :exc:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-exceptionbaz-instead-use-baz-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :exception:Baz instead-Use Baz instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-methbazbar-instead-use-bazbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :meth:Baz.bar instead-Use Baz.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-methodbazbar-instead-use-bazbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :method:Baz.bar instead-Use Baz.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-pyfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :py:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-cppfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-jsfuncbar-instead-use-bar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :js:func:bar instead-Use bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-funcpkgmodbar-instead-use-pkgmodbar-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :func:~pkg.mod.bar instead-Use ~pkg.mod.bar instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-rinstead-use-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :r:instead-Use instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-drinstead-use-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :d:r:instead-Use instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-rfoo-instead-use-foo-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :r:foo instead-Use foo instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinxpytest_get_deprecated_msguse-drfoo-instead-use-foo-instead" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx.py::test_get_deprecated_msg[Use :d:r:foo instead-Use foo instead]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_metaclasspytest_with_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_metaclass.py::test_with_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_metaclasspytest_with_new" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_metaclass.py::test_with_new
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_metaclasspytest_with_metaclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_metaclass.py::test_with_metaclass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sphinx_metaclasspytest_with_singleton_metaclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_sphinx_metaclass.py::test_with_singleton_metaclass
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_test-save-commit0_baseline">back to Claude Sonnet 3.5 - Base summary</a></p>
<h1 id="claude-sonnet-35-base-baseline"><strong>Claude Sonnet 3.5 - Base</strong>: baseline</h1>
<h2 id="pytest-summary">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">120</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest">Failed pytest:</h2>
<h3 id="test_conditionpytest_operator_and">test_condition.py::test_operator_and</h3>
<details><summary> <pre>test_condition.py::test_operator_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d900>

    def test_operator_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] & timeout[1] & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d900>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_and_blocked">test_condition.py::test_operator_and_blocked</h3>
<details><summary> <pre>test_condition.py::test_operator_and_blocked</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa432a40>

    def test_operator_and_blocked(env):
        def process(env):
            timeout = env.timeout(1)
            event = env.event()
            yield env.timeout(1)

            condition = timeout & event
            assert not condition.triggered

        env.process(process(env))
>       env.run()

tests/test_condition.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa432a40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_or">test_condition.py::test_operator_or</h3>
<details><summary> <pre>test_condition.py::test_operator_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb340>

    def test_operator_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield timeout[0] | timeout[1] | timeout[2]

            assert results == {
                timeout[0]: 0,
            }

        env.process(process(env))
>       env.run()

tests/test_condition.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb340>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_and">test_condition.py::test_operator_nested_and</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_and</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6697e0>

    def test_operator_nested_and(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] & timeout[2]) | timeout[1]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
            }
            assert env.now == 1

        env.process(process(env))
>       env.run()

tests/test_condition.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6697e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_operator_nested_or">test_condition.py::test_operator_nested_or</h3>
<details><summary> <pre>test_condition.py::test_operator_nested_or</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9913cd0>

    def test_operator_nested_or(env):
        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            results = yield (timeout[0] | timeout[1]) & timeout[2]

            assert results == {
                timeout[0]: 0,
                timeout[1]: 1,
                timeout[2]: 2,
            }
            assert env.now == 2

        env.process(process(env))
>       env.run()

tests/test_condition.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9913cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_cond_with_error">test_condition.py::test_nested_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_nested_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345960>

    def test_nested_cond_with_error(env):
        def explode(env):
            yield env.timeout(1)
            raise ValueError('Onoes!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(explode(env)) & env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345960>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_error">test_condition.py::test_cond_with_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9966800>

    def test_cond_with_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9966800>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_nested_error">test_condition.py::test_cond_with_nested_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_nested_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98ec20>

    def test_cond_with_nested_error(env):
        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            with pytest.raises(ValueError, match='Onoes, failed after 0!'):
                yield env.process(explode(env, 0)) & env.timeout(1) | env.timeout(1)

        env.process(process(env))
>       env.run()

tests/test_condition.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98ec20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_cond_with_uncaught_error">test_condition.py::test_cond_with_uncaught_error</h3>
<details><summary> <pre>test_condition.py::test_cond_with_uncaught_error</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa420a60>

    def test_cond_with_uncaught_error(env):
        """Errors that happen after the condition has been triggered will not be
        handled by the condition and cause the simulation to crash."""

        def explode(env, delay):
            yield env.timeout(delay)
            raise ValueError(f'Onoes, failed after {delay}!')

        def process(env):
            yield env.timeout(1) | env.process(explode(env, 2))

        env.process(process(env))
        with pytest.raises(ValueError, match='Onoes, failed after'):
>           env.run()

tests/test_condition.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa420a60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_and_cond">test_condition.py::test_iand_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912dd0>

    def test_iand_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 2, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912dd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_iand_with_or_cond">test_condition.py::test_iand_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_iand_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def test_iand_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond &= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [1, 0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d1c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_or_cond">test_condition.py::test_ior_with_or_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_or_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4307f0>

    def test_ior_with_or_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) | env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4307f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_ior_with_and_cond">test_condition.py::test_ior_with_and_cond</h3>
<details><summary> <pre>test_condition.py::test_ior_with_and_cond</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def test_ior_with_and_cond(env):
        def process(env):
            cond = env.timeout(1, value=1) & env.timeout(2, value=2)
            orig = cond

            cond |= env.timeout(0, value=0)
            assert cond is not orig

            results = yield cond
            assert list(results.values()) == [0]

        env.process(process(env))
>       env.run()

tests/test_condition.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30f1f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_immutable_results">test_condition.py::test_immutable_results</h3>
<details><summary> <pre>test_condition.py::test_immutable_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4214b0>

    def test_immutable_results(env):
        """Results of conditions should not change after they have been
        triggered."""

        def process(env):
            timeout = [env.timeout(delay, value=delay) for delay in range(3)]
            # The or condition in this expression will trigger immediately. The and
            # condition will trigger later on.
            condition = timeout[0] | (timeout[1] & timeout[2])

            results = yield condition
            assert results == {timeout[0]: 0}

            # Make sure that the results of condition were frozen. The results of
            # the nested and condition do not become visible afterwards.
            yield env.timeout(2)
            assert results == {timeout[0]: 0}

        env.process(process(env))
>       env.run()

tests/test_condition.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4214b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_and_condition">test_condition.py::test_shared_and_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_and_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66b640>

    def test_shared_and_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] & timeout[1]
        c2 = c1 & timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0, timeout[1]: 1, timeout[2]: 2}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66b640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_shared_or_condition">test_condition.py::test_shared_or_condition</h3>
<details><summary> <pre>test_condition.py::test_shared_or_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30cc70>

    def test_shared_or_condition(env):
        timeout = [env.timeout(delay, value=delay) for delay in range(3)]
        c1 = timeout[0] | timeout[1]
        c2 = c1 | timeout[2]

        def p1(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        def p2(_, condition):
            results = yield condition
            assert results == {timeout[0]: 0}

        env.process(p1(env, c1))
        env.process(p2(env, c2))
>       env.run()

tests/test_condition.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30cc70>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_condition_value">test_condition.py::test_condition_value</h3>
<details><summary> <pre>test_condition.py::test_condition_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa431510>

    def test_condition_value(env):
        """The value of a condition behaves like a readonly dictionary."""
        timeouts = [env.timeout(delay, value=delay) for delay in range(3)]

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results) == timeouts
            assert list(results.keys()) == timeouts
            assert list(results.values()) == [0, 1, 2]
            assert list(results.items()) == list(zip(timeouts, [0, 1, 2]))
            assert timeouts[0] in results
            assert results[timeouts[0]] == 0
            assert results == results  # noqa: PLR0124
            assert results == results.todict()

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa431510>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_result_order">test_condition.py::test_result_order</h3>
<details><summary> <pre>test_condition.py::test_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d750>

    def test_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified."""
        timeouts = list(reversed([env.timeout(delay) for delay in range(3)]))

        def p(env, timeouts):
            results = yield env.all_of(timeouts)
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30d750>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_conditionpytest_nested_result_order">test_condition.py::test_nested_result_order</h3>
<details><summary> <pre>test_condition.py::test_nested_result_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d030>

    def test_nested_result_order(env):
        """The order of a conditions result is based on the order in which the
        events have been specified (even if nested)."""
        timeouts = [env.timeout(delay) for delay in range(3)]
        condition = (timeouts[0] | timeouts[1]) & timeouts[2]

        def p(_, timeouts):
            results = yield condition
            assert list(results.keys()) == timeouts

        env.process(p(env, timeouts))
>       env.run()

tests/test_condition.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d030>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_event_queue_empty">test_environment.py::test_event_queue_empty</h3>
<details><summary> <pre>test_environment.py::test_event_queue_empty</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbaf0>, log = []

    def test_event_queue_empty(env, log):
        """The simulation should stop if there are no more events, that means, no
        more active process."""

        def pem(env, log):
            while env.now < 2:
                log.append(env.now)
                yield env.timeout(1)

        env.process(pem(env, log))
>       env.run(10)

tests/test_environment.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbaf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_negative_until">test_environment.py::test_run_negative_until</h3>
<details><summary> <pre>test_environment.py::test_run_negative_until</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e650>

    def test_run_negative_until(env):
        """Test passing a negative time to run."""
>       with pytest.raises(
            ValueError, match='must be greater than the current simulation time'
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_environment.py:26: Failed
</pre>
</details>
<h3 id="test_environmentpytest_run_resume">test_environment.py::test_run_resume</h3>
<details><summary> <pre>test_environment.py::test_run_resume</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98e080>

    def test_run_resume(env):
        """Stopped simulation can be resumed."""
        events = [env.timeout(t) for t in (5, 10, 15)]

        assert env.now == 0
        assert not any(event.processed for event in events)

>       env.run(until=10)

tests/test_environment.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98e080>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_environmentpytest_run_until_value">test_environment.py::test_run_until_value</h3>
<details><summary> <pre>test_environment.py::test_run_until_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f0460>

    def test_run_until_value(env):
        """Anything that can be converted to a float is a valid until value."""
>       env.run(until='3.141592')

tests/test_environment.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f0460>, until = '3.141592'

    def run(self, until: Optional[Union[SimTime, Event]]=None) ->Optional[Any]:
        """Executes :meth:`step()` until the given criterion *until* is met.

        - If it is ``None`` (which is the default), this method will return
          when there are no further events to be processed.

        - If it is an :class:`~simpy.events.Event`, the method will continue
          stepping until this event has been triggered and will return its
          value.  Raises a :exc:`RuntimeError` if there are no further events
          to be processed and the *until* event was not triggered.

        - If it is a number, the method will continue stepping
          until the environment's time reaches *until*.

        """
        if until is None:
            while True:
                try:
                    self.step()
                except EmptySchedule:
                    return None
        elif isinstance(until, Event):
            until.callbacks.append(StopSimulation.callback)
            try:
                while not until.triggered:
                    self.step()
            except StopSimulation:
                return until.value
            except EmptySchedule:
                if not until.triggered:
                    raise RuntimeError('No scheduled events left but "until" event was not triggered')
        elif isinstance(until, (int, float)):
            try:
                while self._now < until:
                    self.step()
            except EmptySchedule:
                return None
        else:
>           raise ValueError('Invalid until parameter type')
E           ValueError: Invalid until parameter type

src/simpy/core.py:196: ValueError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_processed_event">test_environment.py::test_run_with_processed_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_processed_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987430>

    def test_run_with_processed_event(env):
        """An already processed event may also be passed as until value."""
        timeout = env.timeout(1, value='spam')
>       assert env.run(until=timeout) == 'spam'
E       AssertionError: assert None == 'spam'
E        +  where None = run(until=<Timeout(1, value='spam') object at 0x7f67a9984d90>)
E        +    where run = <simpy.core.Environment object at 0x7f67a9987430>.run

tests/test_environment.py:63: AssertionError
</pre>
</details>
<h3 id="test_environmentpytest_run_with_untriggered_event">test_environment.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_environment.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30d420>

    def test_run_with_untriggered_event(env):
        excinfo = pytest.raises(RuntimeError, env.run, until=env.event())
>       assert str(excinfo.value).startswith(
            'No scheduled events left but "until" event was not triggered:'
        )
E       assert False
E        +  where False = <built-in method startswith of str object at 0x7f67a99d3d70>('No scheduled events left but "until" event was not triggered:')
E        +    where <built-in method startswith of str object at 0x7f67a99d3d70> = 'No scheduled events left but "until" event was not triggered'.startswith
E        +      where 'No scheduled events left but "until" event was not triggered' = str(RuntimeError('No scheduled events left but "until" event was not triggered'))
E        +        where RuntimeError('No scheduled events left but "until" event was not triggered') = <ExceptionInfo RuntimeError('No scheduled events left but "until" event was not triggered') tblen=2>.value

tests/test_environment.py:75: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_succeed">test_event.py::test_succeed</h3>
<details><summary> <pre>test_event.py::test_succeed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985720>

    def test_succeed(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            value = yield event
            assert value == 'ohai'
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.succeed('ohai')

        env.process(parent(env))
>       env.run()

tests/test_event.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985720>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_fail">test_event.py::test_fail</h3>
<details><summary> <pre>test_event.py::test_fail</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def test_fail(env):
        """Test for the Environment.event() helper function."""

        def child(env, event):
            with pytest.raises(ValueError, match='ohai'):
                yield event
            assert env.now == 5

        def parent(env):
            event = env.event()
            env.process(child(env, event))
            yield env.timeout(5)
            event.fail(ValueError('ohai'))

        env.process(parent(env))
>       env.run()

tests/test_event.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99b8cd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_value">test_event.py::test_value</h3>
<details><summary> <pre>test_event.py::test_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f2830>

    def test_value(env):
        """After an event has been triggered, its value becomes accessible."""
        event = env.timeout(0, 'I am the value')

>       env.run()

tests/test_event.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f2830>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Timeout' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_unavailable_value">test_event.py::test_unavailable_value</h3>
<details><summary> <pre>test_event.py::test_unavailable_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

        with pytest.raises(AttributeError, match='.* is not yet available$'):
>           _ = event.value

tests/test_event.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Event() object at 0x7f67a9984d90>

    @property
    def value(self) ->Optional[Any]:
        """The value of the event if it is available.

        The value is available when the event has been triggered.

        Raises :exc:`AttributeError` if the value is not yet available.

        """
        if self._value is PENDING:
>           raise AttributeError('Value not yet available')
E           AttributeError: Value not yet available. Did you mean: '_value'?

src/simpy/events.py:132: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a9987f40>

    def test_unavailable_value(env):
        """If an event has not yet been triggered, its value is not available and
        trying to access it will result in a AttributeError."""
        event = env.event()

>       with pytest.raises(AttributeError, match='.* is not yet available$'):
E       AssertionError: Regex pattern did not match.
E        Regex: '.* is not yet available$'
E        Input: 'Value not yet available'

tests/test_event.py:82: AssertionError
</pre>
</details>
<h3 id="test_eventpytest_triggered">test_event.py::test_triggered</h3>
<details><summary> <pre>test_event.py::test_triggered</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04ec50>

    def test_triggered(env):
        def pem(env, event):
            value = yield event
            return value

        event = env.event()
        event.succeed('i was already done')

>       result = env.run(env.process(pem(env, event)))

tests/test_event.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04ec50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_callback_removal">test_event.py::test_condition_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667430>

    def test_condition_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events."""
        a, b = env.event(), env.event()
        a.succeed()
>       env.run(until=a | b)

tests/test_event.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_eventpytest_condition_nested_callback_removal">test_event.py::test_condition_nested_callback_removal</h3>
<details><summary> <pre>test_event.py::test_condition_nested_callback_removal</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99874c0>

    def test_condition_nested_callback_removal(env):
        """A condition will remove all outstanding callbacks from its events (even
        if nested)."""
        a, b, c = env.event(), env.event(), env.event()
        b_and_c = b & c
        a_or_b_and_c = a | b_and_c
        a.succeed()
>       env.run(until=a_or_b_and_c)

tests/test_event.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99874c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_error_forwarding">test_exceptions.py::test_error_forwarding</h3>
<details><summary> <pre>test_exceptions.py::test_error_forwarding</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def test_error_forwarding(env):
        """Exceptions are forwarded from child to parent processes if there
        are any.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            with pytest.raises(ValueError, match='Onoes!'):
                yield env.process(child(env))

        env.process(parent(env))
>       env.run()

tests/test_exceptions.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c9d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_no_parent_process">test_exceptions.py::test_no_parent_process</h3>
<details><summary> <pre>test_exceptions.py::test_no_parent_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98cca0>

    def test_no_parent_process(env):
        """Exceptions should be normally raised if there are no processes waiting
        for the one that raises something.

        """

        def child(env):
            raise ValueError('Onoes!')
            yield env.timeout(1)

        def parent(env):
            try:
                env.process(child(env))
                yield env.timeout(1)
            except Exception as err:
                pytest.fail(f'There should be no error ({err}).')

        env.process(parent(env))
        with pytest.raises(ValueError, match='Onoes!'):
>           env.run()

tests/test_exceptions.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98cca0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_crashing_child_traceback">test_exceptions.py::test_crashing_child_traceback</h3>
<details><summary> <pre>test_exceptions.py::test_crashing_child_traceback</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_crashing_child_traceback(env):
        def panic(env):
            yield env.timeout(1)
            raise RuntimeError('Oh noes, roflcopter incoming... BOOM!')

        def root(env):
            try:
                yield env.process(panic(env))
                pytest.fail("Hey, where's the roflcopter?")
            except RuntimeError:
                # The current frame must be visible in the stacktrace.
                stacktrace = traceback.format_exc()
                assert 'yield env.process(panic(env))' in stacktrace
                assert "raise RuntimeError('Oh noes," in stacktrace

        env.process(root(env))
>       env.run()

tests/test_exceptions.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_chaining">test_exceptions.py::test_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04c640>

    def test_exception_chaining(env):
        """Unhandled exceptions pass through the entire event stack. This must be
        visible in the stacktrace of the exception.

        """

        def child(env):
            yield env.timeout(1)
            raise RuntimeError('foo')

        def parent(env):
            child_proc = env.process(child(env))
            yield child_proc

        def grandparent(env):
            parent_proc = env.process(parent(env))
            yield parent_proc

        env.process(grandparent(env))
        try:
>           env.run()

tests/test_exceptions.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04c640>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_invalid_event">test_exceptions.py::test_invalid_event</h3>
<details><summary> <pre>test_exceptions.py::test_invalid_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940d8a0>

    def test_invalid_event(env):
        """Invalid yield values will cause the simulation to fail."""

        def root(_):
            yield None

        env.process(root(env))
        with pytest.raises(RuntimeError, match='Invalid yield value "None"'):
>           env.run()

tests/test_exceptions.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940d8a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_exception_handling">test_exceptions.py::test_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5240>

    def test_exception_handling(env):
        """If failed events are not defused (which is the default) the simulation
        crashes."""

        event = env.event()
        event.fail(RuntimeError())
        with pytest.raises(RuntimeError):
>           env.run(until=1)

tests/test_exceptions.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_callback_exception_handling">test_exceptions.py::test_callback_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_callback_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa98d540>

    def test_callback_exception_handling(env):
        """Callbacks of events may handle exception by setting the ``defused``
        attribute of ``event`` to ``True``."""

        def callback(event):
            event.defused = True

        event = env.event()
        event.callbacks.append(callback)
        event.fail(RuntimeError())
        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa98d540>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Event' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_handling">test_exceptions.py::test_process_exception_handling</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_handling</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9912ef0>

    def test_process_exception_handling(env):
        """Processes can't ignore failed events and auto-handle exceptions."""

        def pem(_, event):
            try:
                yield event
                pytest.fail('Hey, the event should fail!')
            except RuntimeError:
                pass

        event = env.event()
        env.process(pem(env, event))
        event.fail(RuntimeError())

        assert not event.defused, 'Event has been defused immediately'
>       env.run(until=1)

tests/test_exceptions.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9912ef0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_process_exception_chaining">test_exceptions.py::test_process_exception_chaining</h3>
<details><summary> <pre>test_exceptions.py::test_process_exception_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5c60>

    def test_process_exception_chaining(env):
        """Because multiple processes can be waiting for an event, exceptions of
        failed events are copied before being thrown into a process. Otherwise, the
        traceback of the exception gets modified by a process.

        See https://bitbucket.org/simpy/simpy/issue/60 for more details."""
        import traceback

        def process_a(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_b' not in stacktrace

        def process_b(event):
            try:
                yield event
            except RuntimeError:
                stacktrace = traceback.format_exc()
                assert 'process_a' not in stacktrace

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_a(event))
        env.process(process_b(event))

>       env.run()

tests/test_exceptions.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5c60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_exceptionspytest_sys_excepthook">test_exceptions.py::test_sys_excepthook</h3>
<details><summary> <pre>test_exceptions.py::test_sys_excepthook</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
>           env.run()

tests/test_exceptions.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bab90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError

During handling of the above exception, another exception occurred:

env = <simpy.core.Environment object at 0x7f67a99bab90>

    def test_sys_excepthook(env):
        """Check that the default exception hook reports exception chains."""

        def process_a(event):
            yield event

        def process_b(event):
            yield event

        event = env.event()
        event.fail(RuntimeError('foo'))

        env.process(process_b(env.process(process_a(event))))

        try:
            env.run()
        except BaseException:
            # Let the default exception hook print the traceback to the redirected
            # standard error channel.
            import sys
            from io import StringIO

            stderr, sys.stderr = sys.stderr, StringIO()

            typ, e, tb = sys.exc_info()
            assert typ is not None
            assert e is not None
            sys.excepthook(typ, e, tb)

            traceback = sys.stderr.getvalue()

            sys.stderr = stderr

            # Check if frames of process_a and process_b are visible in the
            # traceback.
>           assert 'process_a' in traceback
E           assert 'process_a' in 'Traceback (most recent call last):\n  File "/testbed/tests/test_exceptions.py", line 244, in test_sys_excepthook\n   ..._callback(event)\nAttributeError: \'Initialize\' object has no attribute \'_callback\'. Did you mean: \'callbacks\'?\n'

tests/test_exceptions.py:264: AssertionError
</pre>
</details>
<h3 id="test_interruptspytest_interruption">test_interrupts.py::test_interruption</h3>
<details><summary> <pre>test_interrupts.py::test_interruption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def test_interruption(env):
        """Processes can be interrupted while waiting for other events."""

        def interruptee(env):
            with pytest.raises(simpy.Interrupt, match='interrupt!'):
                yield env.timeout(10)

        def interruptor(env):
            child_process = env.process(interruptee(env))
            yield env.timeout(5)
            child_process.interrupt('interrupt!')

        env.process(interruptor(env))
>       env.run()

tests/test_interrupts.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9ff13f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts">test_interrupts.py::test_concurrent_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d13c0>, log = []

    def test_concurrent_interrupts(env, log):
        """Concurrent interrupts are scheduled in the order in which they
        occurred.

        """

        def fox(env, log):
            while True:
                try:
                    yield env.timeout(10)
                except simpy.Interrupt as interrupt:
                    log.append((env.now, interrupt.cause))

        def farmer(env, name, fox):
            fox.interrupt(name)
            yield env.timeout(1)

        fantastic_mr_fox = env.process(fox(env, log))
        for name in ('boggis', 'bunce', 'beans'):
            env.process(farmer(env, name, fantastic_mr_fox))

>       env.run(20)

tests/test_interrupts.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d13c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_interrupts_and_events">test_interrupts.py::test_concurrent_interrupts_and_events</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_interrupts_and_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb400>, log = []

    def test_concurrent_interrupts_and_events(env, log):
        """Interrupts interrupt a process while waiting for an event. Even if the
        event has happened concurrently with the interrupt."""

        def fox(env, coup, log):
            while True:
                try:
                    yield coup
                    log.append(f'coup completed at {env.now}')
                except simpy.Interrupt:
                    log.append(f'coup interrupted at {env.now}')
                else:
                    return

        def master_plan(env, fox, coup):
            yield env.timeout(1)
            # Succeed and interrupt concurrently.
            coup.succeed()
            fox.interrupt()

        coup = env.event()
        fantastic_mr_fox = env.process(fox(env, coup, log))
        env.process(master_plan(env, fantastic_mr_fox, coup))

>       env.run(5)

tests/test_interrupts.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_init_interrupt">test_interrupts.py::test_init_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_init_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def test_init_interrupt(env):
        """An interrupt should always be executed after the Initialize event at the
        same time."""

        def child(env):
            try:
                yield env.timeout(10)
                pytest.fail('Should have been interrupted.')
            except simpy.Interrupt:
                assert env.now == 0

        def root(env):
            child_proc = env.process(child(env))
            child_proc.interrupt()

            yield env.timeout(1)

        env.process(root(env))
>       env.run()

tests/test_interrupts.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1e40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_terminated_process">test_interrupts.py::test_interrupt_terminated_process</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_terminated_process</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def test_interrupt_terminated_process(env):
        """Dead processes cannot be interrupted."""

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))

            # Wait long enough so that child_proc terminates.
            yield env.timeout(2)
            ei = pytest.raises(RuntimeError, child_proc.interrupt)
            assert re.match(
                r'<Process\(child\) object at 0x.*> has terminated '
                r'and cannot be interrupted.',
                ei.value.args[0],
            )

            yield env.timeout(1)

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5ae0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_multiple_interrupts">test_interrupts.py::test_multiple_interrupts</h3>
<details><summary> <pre>test_interrupts.py::test_multiple_interrupts</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa109bd0>

    def test_multiple_interrupts(env):
        """Interrupts on dead processes are discarded. If there are multiple
        concurrent interrupts on a process and the latter dies after
        handling the first interrupt, the remaining ones are silently
        ignored.

        """

        def child(env):
            try:
                yield env.timeout(1)
            except simpy.Interrupt as i:
                return i.cause

        def parent(env):
            c = env.process(child(env))
            yield env.timeout(0)
            c.interrupt(1)
            c.interrupt(2)
            result = yield c
            assert result == 1

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa109bd0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_self">test_interrupts.py::test_interrupt_self</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_self</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa66bee0>

    def test_interrupt_self(env):
        """A process should not be able to interrupt itself."""

        def pem(env):
            pytest.raises(RuntimeError, env.active_process.interrupt)
            yield env.timeout(0)

        env.process(pem(env))
>       env.run()

tests/test_interrupts.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa66bee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_immediate_interrupt">test_interrupts.py::test_immediate_interrupt</h3>
<details><summary> <pre>test_interrupts.py::test_immediate_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa4223b0>, log = []

    def test_immediate_interrupt(env, log):
        """Processes are immediately interruptable."""

        def child(env, log):
            try:
                yield env.event()
            except simpy.Interrupt:
                log.append(env.now)

        def parent(env, log):
            child_proc = env.process(child(env, log))
            child_proc.interrupt()
            return
            yield

        env.process(parent(env, log))
>       env.run()

tests/test_interrupts.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa4223b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_interrupt_event">test_interrupts.py::test_interrupt_event</h3>
<details><summary> <pre>test_interrupts.py::test_interrupt_event</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940cac0>

    def test_interrupt_event(env):
        """A process should be interruptable while waiting for an Event."""

        def child(env):
            try:
                yield env.event()
            except simpy.Interrupt:
                assert env.now == 5

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(5)
            child_proc.interrupt()

        env.process(parent(env))
>       env.run()

tests/test_interrupts.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940cac0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_interruptspytest_concurrent_behaviour">test_interrupts.py::test_concurrent_behaviour</h3>
<details><summary> <pre>test_interrupts.py::test_concurrent_behaviour</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108280>

    def test_concurrent_behaviour(env):
        def proc_a(env):
            timeouts = [env.timeout(0) for i in range(2)]
            while timeouts:
                with pytest.raises(simpy.Interrupt):
                    yield timeouts.pop(0)

        def proc_b(_, proc_a):
            for _ in range(2):
                proc_a.interrupt()
            return
            yield

        proc_a = env.process(proc_a(env))
        env.process(proc_b(env, proc_a))

>       env.run()

tests/test_interrupts.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_get_state">test_process.py::test_get_state</h3>
<details><summary> <pre>test_process.py::test_get_state</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa423430>

    def test_get_state(env):
        """A process is alive until it's generator has not terminated."""

        def pem_a(env):
            yield env.timeout(3)

        def pem_b(env, pem_a):
            yield env.timeout(1)
            assert pem_a.is_alive

            yield env.timeout(3)
            assert not pem_a.is_alive

        proc_a = env.process(pem_a(env))
        env.process(pem_b(env, proc_a))
>       env.run()

tests/test_process.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa423430>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_target">test_process.py::test_target</h3>
<details><summary> <pre>test_process.py::test_target</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3459c0>

    def test_target(env):
        def pem(env, event):
            yield event

        event = env.timeout(5)
        proc = env.process(pem(env, event))

        # Wait until "proc" is initialized and yielded the event
        while env.peek() < 5:
>           env.step()

tests/test_process.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3459c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_wait_for_proc">test_process.py::test_wait_for_proc</h3>
<details><summary> <pre>test_process.py::test_wait_for_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa9803a0>

    def test_wait_for_proc(env):
        """A process can wait until another process finishes."""

        def finisher(env):
            yield env.timeout(5)

        def waiter(env, finisher):
            proc = env.process(finisher(env))
            yield proc  # Waits until "proc" finishes

            assert env.now == 5

        env.process(waiter(env, finisher))
>       env.run()

tests/test_process.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa9803a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_return_value">test_process.py::test_return_value</h3>
<details><summary> <pre>test_process.py::test_return_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def test_return_value(env):
        """Processes can set a return value."""

        def child(env):
            yield env.timeout(1)
            return env.now

        def parent(env):
            result1 = yield env.process(child(env))
            result2 = yield env.process(child(env))

            assert [result1, result2] == [1, 2]

        env.process(parent(env))
>       env.run()

tests/test_process.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ed0f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_child_exception">test_process.py::test_child_exception</h3>
<details><summary> <pre>test_process.py::test_child_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d5690>

    def test_child_exception(env):
        """A child catches an exception and sends it to its parent."""

        def child(env):
            yield env.timeout(1)
            return RuntimeError('Onoes!')

        def parent(env):
            result = yield env.process(child(env))
            assert isinstance(result, Exception)

        env.process(parent(env))
>       env.run()

tests/test_process.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d5690>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join">test_process.py::test_interrupted_join</h3>
<details><summary> <pre>test_process.py::test_interrupted_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94e95a0>

    def test_interrupted_join(env):
        """Interrupts remove a process from the callbacks of its target."""

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                # We should not get resumed when child terminates.
                yield env.timeout(5)
                assert env.now == 6

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94e95a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_processpytest_interrupted_join_and_rejoin">test_process.py::test_interrupted_join_and_rejoin</h3>
<details><summary> <pre>test_process.py::test_interrupted_join_and_rejoin</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def test_interrupted_join_and_rejoin(env):
        """Tests that interrupts are raised while the victim is waiting for
        another process. The victim tries to join again.

        """

        def interruptor(env, process):
            yield env.timeout(1)
            process.interrupt()

        def child(env):
            yield env.timeout(2)

        def parent(env):
            child_proc = env.process(child(env))
            try:
                yield child_proc
                pytest.fail('Did not receive an interrupt.')
            except Interrupt:
                assert env.now == 1
                assert child_proc.is_alive

                yield child_proc
                assert env.now == 2

        parent_proc = env.process(parent(env))
        env.process(interruptor(env, parent_proc))
>       env.run()

tests/test_process.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f06a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource">test_resources.py::test_resource</h3>
<details><summary> <pre>test_resources.py::test_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa664df0>, log = []

    def test_resource(env, log):
        """A *resource* is something with a limited numer of slots that need
        to be requested before and released after the usage (e.g., gas pumps
        at a gas station).

        """

        def pem(env, name, resource, log):
            req = resource.request()
            yield req
            assert resource.count == 1

            yield env.timeout(1)
            resource.release(req)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        assert resource.capacity == 1
        assert resource.count == 0
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa664df0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_context_manager">test_resources.py::test_resource_context_manager</h3>
<details><summary> <pre>test_resources.py::test_resource_context_manager</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940e500>, log = []

    def test_resource_context_manager(env, log):
        """The event that ``Resource.request()`` returns can be used as
        Context Manager."""

        def pem(env, name, resource, log):
            with resource.request() as request:
                yield request
                yield env.timeout(1)

            log.append((name, env.now))

        resource = simpy.Resource(env, capacity=1)
        env.process(pem(env, 'a', resource, log))
        env.process(pem(env, 'b', resource, log))
>       env.run()

tests/test_resources.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940e500>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_slots">test_resources.py::test_resource_slots</h3>
<details><summary> <pre>test_resources.py::test_resource_slots</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa665f30>, log = []

    def test_resource_slots(env, log):
        def pem(env, name, resource, log):
            with resource.request() as req:
                yield req
                log.append((name, env.now))
                yield env.timeout(1)

        resource = simpy.Resource(env, capacity=3)
        for i in range(9):
            env.process(pem(env, str(i), resource, log))
>       env.run()

tests/test_resources.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa665f30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_continue_after_interrupt">test_resources.py::test_resource_continue_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_continue_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def test_resource_continue_after_interrupt(env):
        """A process may be interrupted while waiting for a resource but
        should be able to continue waiting afterwards."""

        def pem(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                yield evt
                res.release(evt)
                assert env.now == 1

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(pem(env, res))
        proc = env.process(victim(env, res))
        env.process(interruptor(proc))
>       env.run()

tests/test_resources.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94eb8b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_release_after_interrupt">test_resources.py::test_resource_release_after_interrupt</h3>
<details><summary> <pre>test_resources.py::test_resource_release_after_interrupt</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa667850>

    def test_resource_release_after_interrupt(env):
        """A process needs to release a resource, even if it was interrupted
        and does not continue to wait for it."""

        def blocker(env, res):
            with res.request() as req:
                yield req
                yield env.timeout(1)

        def victim(env, res):
            evt = res.request()
            try:
                yield evt
                pytest.fail('Should not have gotten the resource.')
            except simpy.Interrupt:
                # Don't wait for the resource
                res.release(evt)
                assert env.now == 0

        def interruptor(proc):
            proc.interrupt()
            return 0
            yield

        res = simpy.Resource(env, 1)
        env.process(blocker(env, res))
        victim_proc = env.process(victim(env, res))
        env.process(interruptor(victim_proc))
>       env.run()

tests/test_resources.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa667850>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_immediate_requests">test_resources.py::test_resource_immediate_requests</h3>
<details><summary> <pre>test_resources.py::test_resource_immediate_requests</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945e3b0>

    def test_resource_immediate_requests(env):
        """A process must not acquire a resource if it releases it and immediately
        requests it again while there are already other requesting processes."""

        def child(env, res):
            result = []
            for _ in range(3):
                with res.request() as req:
                    yield req
                    result.append(env.now)
                    yield env.timeout(1)
            return result

        def parent(env):
            res = simpy.Resource(env, 1)
            child_a = env.process(child(env, res))
            child_b = env.process(child(env, res))

            a_acquire_times = yield child_a
            b_acquire_times = yield child_b

            assert a_acquire_times == [0, 2, 4]
            assert b_acquire_times == [1, 3, 5]

        env.process(parent(env))
>       env.run()

tests/test_resources.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945e3b0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_cm_exception">test_resources.py::test_resource_cm_exception</h3>
<details><summary> <pre>test_resources.py::test_resource_cm_exception</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa345a20>, log = []

    def test_resource_cm_exception(env, log):
        """Resource with context manager receives an exception."""

        def process(env, resource, log, raise_):
            with resource.request() as req:
                yield req
                yield env.timeout(1)
                log.append(env.now)
                if raise_:
                    with pytest.raises(ValueError, match='Foo'):
                        raise ValueError('Foo')

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource, log, True))
        # The second process is used to check if it was able to access the
        # resource:
        env.process(process(env, resource, log, False))
>       env.run()

tests/test_resources.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa345a20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_condition">test_resources.py::test_resource_with_condition</h3>
<details><summary> <pre>test_resources.py::test_resource_with_condition</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945dc60>

    def test_resource_with_condition(env):
        def process(env, resource):
            with resource.request() as res_event:
                result = yield res_event | env.timeout(1)
                assert res_event in result

        resource = simpy.Resource(env, 1)
        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945dc60>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_resource_with_priority_queue">test_resources.py::test_resource_with_priority_queue</h3>
<details><summary> <pre>test_resources.py::test_resource_with_priority_queue</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa6d0460>

    def test_resource_with_priority_queue(env):
        def process(env, delay, resource, priority, res_time):
            yield env.timeout(delay)
            req = resource.request(priority=priority)
            yield req
            assert env.now == res_time
            yield env.timeout(5)
            resource.release(req)

        resource = simpy.PriorityResource(env, capacity=1)
        env.process(process(env, 0, resource, 2, 0))
        env.process(process(env, 2, resource, 3, 10))
        env.process(process(env, 2, resource, 3, 15))  # Test equal priority
        env.process(process(env, 4, resource, 1, 5))
>       env.run()

tests/test_resources.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa6d0460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_sorted_queue_maxlen">test_resources.py::test_sorted_queue_maxlen</h3>
<details><summary> <pre>test_resources.py::test_sorted_queue_maxlen</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945c100>

    def test_sorted_queue_maxlen(env):
        """Requests must fail if more than *maxlen* requests happen
        concurrently."""
        resource = simpy.PriorityResource(env, capacity=1)
        resource.put_queue.maxlen = 1  # pyright: ignore

        def process(env, resource):
            # The first request immediately triggered and does not enter the queue.
            resource.request(priority=1)
            # The second request is enqueued.
            resource.request(priority=1)
            with pytest.raises(RuntimeError, match='Cannot append event. Queue is full.'):
                # The third request will now fail.
                resource.request(priority=1)
            yield env.timeout(0)

        env.process(process(env, resource))
>       env.run()

tests/test_resources.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945c100>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_get_users">test_resources.py::test_get_users</h3>
<details><summary> <pre>test_resources.py::test_get_users</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa666d10>

    def test_get_users(env):
        def process(env, resource):
            with resource.request() as req:
                yield req
                yield env.timeout(1)

        resource = simpy.Resource(env, 1)
        procs = [env.process(process(env, resource)) for _ in range(3)]
>       env.run(until=1)

tests/test_resources.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa666d10>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource">test_resources.py::test_preemptive_resource</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_preemptive_resource(env):
        """Processes with a higher priority may preempt requests of lower priority
        processes. Note that higher priorities are indicated by a lower number
        value."""

        def proc_a(_, resource, prio):
            try:
                with resource.request(priority=prio) as req:
                    yield req
                    pytest.fail('Should have received an interrupt/preemption.')
            except simpy.Interrupt:
                pass

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_preemptive_resource_timeout_0">test_resources.py::test_preemptive_resource_timeout_0</h3>
<details><summary> <pre>test_resources.py::test_preemptive_resource_timeout_0</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def test_preemptive_resource_timeout_0(env):
        def proc_a(env, resource, prio):
            with resource.request(priority=prio) as req:
                try:
                    yield req
                    yield env.timeout(1)
                    pytest.fail('Should have received an interrupt/preemption.')
                except simpy.Interrupt:
                    pass
            yield env.event()

        def proc_b(_, resource, prio):
            with resource.request(priority=prio) as req:
                yield req

        resource = simpy.PreemptiveResource(env, 1)
        env.process(proc_a(env, resource, 1))
        env.process(proc_b(env, resource, 0))

>       env.run()

tests/test_resources.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa30ddb0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_mixed_preemption">test_resources.py::test_mixed_preemption</h3>
<details><summary> <pre>test_resources.py::test_mixed_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a945f460>, log = []

    def test_mixed_preemption(env, log):
        def p(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(2)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert ir is not None  # noqa: PT017
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        res = simpy.PreemptiveResource(env, 1)
        # p0: First user:
        env.process(p(0, env, res, delay=0, prio=2, preempt=True, log=log))
        # p1: Waits (cannot preempt):
        env.process(p(1, env, res, delay=0, prio=2, preempt=True, log=log))
        # p2: Waits later, but has a higher prio:
        env.process(p(2, env, res, delay=1, prio=1, preempt=False, log=log))
        # p3: Preempt the above proc:
        p3 = env.process(p(3, env, res, delay=3, prio=0, preempt=True, log=log))
        # p4: Wait again:
        env.process(p(4, env, res, delay=4, prio=3, preempt=True, log=log))

>       env.run()

tests/test_resources.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a945f460>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_nested_preemption">test_resources.py::test_nested_preemption</h3>
<details><summary> <pre>test_resources.py::test_nested_preemption</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa10aec0>, log = []

    def test_nested_preemption(env, log):
        def process(id, env, res, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res.request(priority=prio, preempt=preempt) as req:
                try:
                    yield req
                    yield env.timeout(5)
                    log.append((env.now, id))
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append((env.now, id, (ir.cause.by, ir.cause.usage_since)))

        def process2(id, env, res0, res1, delay, prio, preempt, log):
            yield env.timeout(delay)
            with res0.request(priority=prio, preempt=preempt) as req0:
                try:
                    yield req0
                    with res1.request(priority=prio, preempt=preempt) as req1:
                        try:
                            yield req1
                            yield env.timeout(5)
                            log.append((env.now, id))
                        except simpy.Interrupt as ir:
                            assert isinstance(ir.cause, Preempted)  # noqa: PT017
                            log.append(
                                (
                                    env.now,
                                    id,
                                    (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                                )
                            )
                except simpy.Interrupt as ir:
                    assert isinstance(ir.cause, Preempted)  # noqa: PT017
                    log.append(
                        (
                            env.now,
                            id,
                            (ir.cause.by, ir.cause.usage_since, ir.cause.resource),
                        )
                    )

        res0 = simpy.PreemptiveResource(env, 1)
        res1 = simpy.PreemptiveResource(env, 1)

        env.process(process2(0, env, res0, res1, 0, -1, True, log))
        p1 = env.process(process(1, env, res1, 1, -2, True, log))

        env.process(process2(2, env, res0, res1, 20, -1, True, log))
        p3 = env.process(process(3, env, res0, 21, -2, True, log))

        env.process(process2(4, env, res0, res1, 21, -1, True, log))

>       env.run()

tests/test_resources.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa10aec0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container">test_resources.py::test_container</h3>
<details><summary> <pre>test_resources.py::test_container</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9178d30>, log = []

    def test_container(env, log):
        """A *container* is a resource (of optionally limited capacity) where
        you can put in our take-out a discrete or continuous amount of
        things (e.g., a box of lump sugar or a can of milk).  The *put* and
        *get* operations block if the buffer is to full or to empty. If they
        return, the process knows that the *put* or *get* operation was
        successful.

        """

        def putter(env, buf, log):
            yield env.timeout(1)
            while True:
                yield buf.put(2)
                log.append(('p', env.now))
                yield env.timeout(1)

        def getter(env, buf, log):
            yield buf.get(1)
            log.append(('g', env.now))

            yield env.timeout(1)
            yield buf.get(1)
            log.append(('g', env.now))

        buf = simpy.Container(env, init=0, capacity=2)
        env.process(putter(env, buf, log))
        env.process(getter(env, buf, log))
>       env.run(until=5)

tests/test_resources.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9178d30>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_container_get_queued">test_resources.py::test_container_get_queued</h3>
<details><summary> <pre>test_resources.py::test_container_get_queued</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04cf40>

    def test_container_get_queued(env):
        def proc(env, wait, container, what):
            yield env.timeout(wait)
            with getattr(container, what)(1) as req:
                yield req

        container = simpy.Container(env, 1)
        p0 = env.process(proc(env, 0, container, 'get'))
        env.process(proc(env, 1, container, 'put'))
        env.process(proc(env, 1, container, 'put'))
        p3 = env.process(proc(env, 1, container, 'put'))

>       env.run(until=1)

tests/test_resources.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04cf40>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store">test_resources.py::test_store</h3>
<details><summary> <pre>test_resources.py::test_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa430400>

    def test_store(env):
        """A store models the production and consumption of concrete python
        objects (in contrast to containers, where you only now if the *put*
        or *get* operations were successful but don't get concrete
        objects).

        """

        def putter(_, store, item):
            yield store.put(item)

        def getter(_, store, orig_item):
            item = yield store.get()
            assert item is orig_item

        store = simpy.Store(env, capacity=2)
        item = object()

        # NOTE: Does the start order matter? Need to test this.
        env.process(putter(env, store, item))
        env.process(getter(env, store, item))
>       env.run()

tests/test_resources.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa430400>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_capacity">test_resources.py::test_store_capacity</h3>
<details><summary> <pre>test_resources.py::test_store_capacity</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def test_store_capacity(env):
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, 0)
        with pytest.raises(ValueError, match='"capacity" must be > 0'):
            simpy.Store(env, -1)

        capacity = 2
        store = simpy.Store(env, capacity)
        env.process(store.put(i) for i in range(capacity + 1))
>       env.run()

tests/test_resources.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa04d8d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_store_cancel">test_resources.py::test_store_cancel</h3>
<details><summary> <pre>test_resources.py::test_store_cancel</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a940c520>

    def test_store_cancel(env):
        store = simpy.Store(env, capacity=1)

        def acquire_implicit_cancel():
            with store.get():
                yield env.timeout(1)
                # implicit cancel() when exiting with-block

        env.process(acquire_implicit_cancel())
>       env.run()

tests/test_resources.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a940c520>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_item_priority">test_resources.py::test_priority_store_item_priority</h3>
<details><summary> <pre>test_resources.py::test_priority_store_item_priority</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980070>

    def test_priority_store_item_priority(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            item = yield pstore.get()
            log.append(item)

        # Do not specify priority; the items themselves will be compared to
        # determine priority.
        env.process(pstore.put(s) for s in 'bcadefg')
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980070>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_priority_store_stable_order">test_resources.py::test_priority_store_stable_order</h3>
<details><summary> <pre>test_resources.py::test_priority_store_stable_order</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbee0>

    def test_priority_store_stable_order(env):
        pstore = simpy.PriorityStore(env, 3)
        log = []

        def getter(wait):
            yield env.timeout(wait)
            _, item = yield pstore.get()
            log.append(item)

        items = [object() for _ in range(3)]

        # Unorderable items are inserted with same priority.
        env.process(pstore.put(simpy.PriorityItem(0, item)) for item in items)
        env.process(getter(1))
        env.process(getter(2))
        env.process(getter(3))
>       env.run()

tests/test_resources.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbee0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store">test_resources.py::test_filter_store</h3>
<details><summary> <pre>test_resources.py::test_filter_store</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91950c0>

    def test_filter_store(env):
        def pem(env):
            store = simpy.FilterStore(env, capacity=2)

            get_event = store.get(lambda item: item == 'b')
            yield store.put('a')
            assert not get_event.triggered
            yield store.put('b')
            assert get_event.triggered

        env.process(pem(env))
>       env.run()

tests/test_resources.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91950c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_store_get_after_mismatch">test_resources.py::test_filter_store_get_after_mismatch</h3>
<details><summary> <pre>test_resources.py::test_filter_store_get_after_mismatch</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a94d4910>

    def test_filter_store_get_after_mismatch(env):
        """Regression test for issue #49.

        Triggering get-events after a put in FilterStore wrongly breaks after the
        first mismatch.

        """

        def putter(env, store):
            # The order of putting 'spam' before 'eggs' is important here.
            yield store.put('spam')
            yield env.timeout(1)
            yield store.put('eggs')

        def getter(store):
            # The order of requesting 'eggs' before 'spam' is important here.
            eggs = store.get(lambda i: i == 'eggs')
            spam = store.get(lambda i: i == 'spam')

            ret = yield spam | eggs
            assert spam in ret
            assert eggs not in ret
            assert env.now == 0

            yield eggs
            assert env.now == 1

        store = simpy.FilterStore(env, capacity=2)
        env.process(getter(store))
        env.process(putter(env, store))
>       env.run()

tests/test_resources.py:663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a94d4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_best_case">test_resources.py::test_filter_calls_best_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_best_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa980790>

    def test_filter_calls_best_case(env):
        """The filter function is called every item in the store until a match is
        found. In the best case the first item already matches."""
        log = []

        def log_filter(item):
            log.append(f'check {item}')
            return True

        store = simpy.FilterStore(env)
        store.items = [1, 2, 3]

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
>       env.run()

tests/test_resources.py:684: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa980790>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_filter_calls_worst_case">test_resources.py::test_filter_calls_worst_case</h3>
<details><summary> <pre>test_resources.py::test_filter_calls_worst_case</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa3f1600>

    def test_filter_calls_worst_case(env):
        """In the worst case the filter function is being called for items multiple
        times."""

        log = []
        store = simpy.FilterStore(env)

        def putter(store):
            for i in range(4):
                log.append(f'put {i}')
                yield store.put(i)

        def log_filter(item):
            log.append(f'check {item}')
            return item >= 3

        def getter(store):
            log.append(f'get {yield store.get(log_filter)}')

        env.process(getter(store))
        env.process(putter(store))
>       env.run()

tests/test_resources.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa3f1600>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_put_request">test_resources.py::test_immediate_put_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_put_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d4b80>

    def test_immediate_put_request(env):
        """Put requests that can be fulfilled immediately do not enter the put
        queue."""
        resource = simpy.Resource(env, capacity=1)
        assert len(resource.users) == 0
        assert len(resource.queue) == 0

        # The resource is empty, the first request will succeed immediately without
        # entering the queue.
>       request = resource.request()

tests/test_resources.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/resource.py:74: in __init__
    super().__init__(resource)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.resource.Resource object at 0x7f67aa2d5420>
event = <Event() object at 0x7f67aa2d55d0>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_resourcespytest_immediate_get_request">test_resources.py::test_immediate_get_request</h3>
<details><summary> <pre>test_resources.py::test_immediate_get_request</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9910af0>

    def test_immediate_get_request(env):
        """Get requests that can be fulfilled immediately do not enter the get
        queue."""
        container = simpy.Container(env)
        # Put something in the container, this request is triggered immediately
        # without entering the queue.
>       request = container.put(1)

tests/test_resources.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/resources/container.py:30: in __init__
    super().__init__(container)
src/simpy/resources/base.py:39: in __init__
    resource._trigger_put(None)
src/simpy/resources/base.py:199: in _trigger_put
    if not self._do_put(put_event):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.resources.container.Container object at 0x7f67a9912bc0>
event = <Event() object at 0x7f67a9913700>

    def _do_put(self, event: PutType) ->Optional[bool]:
        """Perform the *put* operation.

        This method needs to be implemented by subclasses. If the conditions
        for the put *event* are met, the method must trigger the event (e.g.
        call :meth:`Event.succeed()` with an appropriate value).

        This method is called by :meth:`_trigger_put` for every event in the
        :attr:`put_queue`, as long as the return value does not evaluate
        ``False``.
        """
>       raise NotImplementedError("The _do_put() method has to be implemented by subclasses.")
E       NotImplementedError: The _do_put() method has to be implemented by subclasses.

src/simpy/resources/base.py:186: NotImplementedError
</pre>
</details>
<h3 id="test_rtpytest_rt01">test_rt.py::test_rt[0.1]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.1]</pre></summary><pre>
log = [], factor = 0.1

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444250>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt005">test_rt.py::test_rt[0.05]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.05]</pre></summary><pre>
log = [], factor = 0.05

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9197580>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt015">test_rt.py::test_rt[0.15]</h3>
<details><summary> <pre>test_rt.py::test_rt[0.15]</pre></summary><pre>
log = [], factor = 0.15

    @pytest.mark.parametrize('factor', [0.1, 0.05, 0.15])
    def test_rt(log, factor):
        """Basic tests for run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=factor)
        env.process(process(env, log, 0.01, 1))
        env.process(process(env, log, 0.02, 1))

>       env.run(2)

tests/test_rt.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a99b8190>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_multiple_call">test_rt.py::test_rt_multiple_call</h3>
<details><summary> <pre>test_rt.py::test_rt_multiple_call</pre></summary><pre>
log = []

    def test_rt_multiple_call(log):
        """Test multiple calls to run()."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05)

        env.process(process(env, log, 0.01, 2))
        env.process(process(env, log, 0.01, 3))

>       env.run(5)

tests/test_rt.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67aa2d7d00>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_default_behavior">test_rt.py::test_rt_slow_sim_default_behavior</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_default_behavior</pre></summary><pre>
log = []

    def test_rt_slow_sim_default_behavior(log):
        """By default, SimPy should raise an error if a simulation is too
        slow for the selected real-time factor."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.1, 1))

        err = pytest.raises(RuntimeError, env.run, 3)
>       assert 'Simulation too slow for real time' in str(err.value)
E       AssertionError: assert 'Simulation too slow for real time' in 'Simulation too slow: 0.000 seconds late'
E        +  where 'Simulation too slow: 0.000 seconds late' = str(RuntimeError('Simulation too slow: 0.000 seconds late'))
E        +    where RuntimeError('Simulation too slow: 0.000 seconds late') = <ExceptionInfo RuntimeError('Simulation too slow: 0.000 seconds late') tblen=3>.value

tests/test_rt.py:68: AssertionError
</pre>
</details>
<h3 id="test_rtpytest_rt_slow_sim_no_error">test_rt.py::test_rt_slow_sim_no_error</h3>
<details><summary> <pre>test_rt.py::test_rt_slow_sim_no_error</pre></summary><pre>
log = []

    def test_rt_slow_sim_no_error(log):
        """Test ignoring slow simulations."""
        start = monotonic()
        env = RealtimeEnvironment(factor=0.05, strict=False)
        env.process(process(env, log, 0.1, 1))

>       env.run(2)

tests/test_rt.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
src/simpy/rt.py:76: in step
    super().step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a94796c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_rtpytest_rt_illegal_until">test_rt.py::test_rt_illegal_until</h3>
<details><summary> <pre>test_rt.py::test_rt_illegal_until</pre></summary><pre>
def test_rt_illegal_until():
        """Test illegal value for *until*."""
        env = RealtimeEnvironment()
>       with pytest.raises(
            ValueError,
            match=r'until \(-1\) must be greater than the current simulation time',
        ):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_rt.py:88: Failed
</pre>
</details>
<h3 id="test_rtpytest_rt_sync">test_rt.py::test_rt_sync</h3>
<details><summary> <pre>test_rt.py::test_rt_sync</pre></summary><pre>
log = []

    def test_rt_sync(log):
        """Test resetting the internal wall-clock reference time."""
        env = RealtimeEnvironment(factor=0.05)
        env.process(process(env, log, 0.01))
        sleep(0.06)  # Simulate massive workload :-)
        env.sync()
>       env.run(3)

tests/test_rt.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9444b80>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
            sleep(expected_real_time - real_time)
        elif self._strict and real_time > expected_real_time:
>           raise RuntimeError(f'Simulation too slow: {real_time - expected_real_time:.3f} seconds late')
E           RuntimeError: Simulation too slow: 0.000 seconds late

src/simpy/rt.py:74: RuntimeError
</pre>
</details>
<h3 id="test_rtpytest_run_with_untriggered_event">test_rt.py::test_run_with_untriggered_event</h3>
<details><summary> <pre>test_rt.py::test_run_with_untriggered_event</pre></summary><pre>
env = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def test_run_with_untriggered_event(env):
        env = RealtimeEnvironment(factor=0.05)
>       excinfo = pytest.raises(RuntimeError, env.run, until=env.event())

tests/test_rt.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.rt.RealtimeEnvironment object at 0x7f67a9483640>

    def step(self) ->None:
        """Process the next event after enough real-time has passed for the
        event to happen.

        The delay is scaled according to the real-time :attr:`factor`. With
        :attr:`strict` mode enabled, a :exc:`RuntimeError` will be raised, if
        the event is processed too slowly.

        """
        try:
            evt_time = self.peek()
        except EmptySchedule:
            return

        real_time = monotonic()
        expected_real_time = self.real_start + (evt_time - self.env_start) / self._factor

        if real_time < expected_real_time:
>           sleep(expected_real_time - real_time)
E           OverflowError: timestamp too large to convert to C _PyTime_t

src/simpy/rt.py:72: OverflowError
</pre>
</details>
<h3 id="test_timeoutpytest_discrete_time_steps">test_timeout.py::test_discrete_time_steps</h3>
<details><summary> <pre>test_timeout.py::test_discrete_time_steps</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bbfa0>, log = []

    def test_discrete_time_steps(env, log):
        """envple envulation with discrete time steps."""

        def pem(env, log):
            while True:
                log.append(env.now)
                yield env.timeout(delay=1)

        env.process(pem(env, log))
>       env.run(until=3)

tests/test_timeout.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:192: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bbfa0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_negative_timeout">test_timeout.py::test_negative_timeout</h3>
<details><summary> <pre>test_timeout.py::test_negative_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91767a0>

    def test_negative_timeout(env):
        """Don't allow negative timeout times."""

        def pem(env):
            yield env.timeout(-1)

        env.process(pem(env))
        with pytest.raises(ValueError, match='Negative delay'):
>           env.run()

tests/test_timeout.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91767a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_timeout_value">test_timeout.py::test_timeout_value</h3>
<details><summary> <pre>test_timeout.py::test_timeout_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ae140>

    def test_timeout_value(env):
        """You can pass an additional *value* to *timeout* which will be
        directly yielded back into the PEM. This is useful to implement some
        kinds of resources or other additions.

        See :class:`envpy.resources.Store` for an example.

        """

        def pem(env):
            val = yield env.timeout(1, 'ohai')
            assert val == 'ohai'

        env.process(pem(env))
>       env.run()

tests/test_timeout.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ae140>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_shared_timeout">test_timeout.py::test_shared_timeout</h3>
<details><summary> <pre>test_timeout.py::test_shared_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9174130>, log = []

    def test_shared_timeout(env, log):
        def child(env, timeout, id, log):
            yield timeout
            log.append((id, env.now))

        timeout = env.timeout(1)
        for i in range(3):
            env.process(child(env, timeout, i, log))

>       env.run()

tests/test_timeout.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9174130>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_timeoutpytest_triggered_timeout">test_timeout.py::test_triggered_timeout</h3>
<details><summary> <pre>test_timeout.py::test_triggered_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91ac880>

    def test_triggered_timeout(env):
        def process(env):
            def child(env, event):
                value = yield event
                return value

            event = env.timeout(1, 'i was already done')
            # Start the child after the timeout has already happened.
            yield env.timeout(2)
            value = yield env.process(child(env, event))
            assert value == 'i was already done'

>       env.run(env.process(process(env)))

tests/test_timeout.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:183: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91ac880>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_start_delayed">test_util.py::test_start_delayed</h3>
<details><summary> <pre>test_util.py::test_start_delayed</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a99bb550>

    def test_start_delayed(env):
        def pem(env):
            assert env.now == 5
            yield env.timeout(1)

        start_delayed(env, pem(env), delay=5)
>       env.run()

tests/test_util.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a99bb550>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe">test_util.py::test_subscribe</h3>
<details><summary> <pre>test_util.py::test_subscribe</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def test_subscribe(env):
        """Check async. interrupt if a process terminates."""

        def child(env):
            yield env.timeout(3)
            return 'ohai'

        def parent(env):
            child_proc = env.process(child(env))
            subscribe_at(child_proc)

            try:
                yield env.event()
            except Interrupt as interrupt:
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc  # noqa: PT017
                assert interrupt.cause[1] == 'ohai'  # noqa: PT017
                assert env.now == 3

        env.process(parent(env))
>       env.run()

tests/test_util.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa2d54e0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_terminated_proc">test_util.py::test_subscribe_terminated_proc</h3>
<details><summary> <pre>test_util.py::test_subscribe_terminated_proc</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985cf0>

    def test_subscribe_terminated_proc(env):
        """subscribe() proc should send a signal immediately if
        "other" has already terminated.

        """

        def child(env):
            yield env.timeout(1)

        def parent(env):
            child_proc = env.process(child(env))
            yield env.timeout(2)
            pytest.raises(RuntimeError, subscribe_at, child_proc)

        env.process(parent(env))
>       env.run()

tests/test_util.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985cf0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_with_join">test_util.py::test_subscribe_with_join</h3>
<details><summary> <pre>test_util.py::test_subscribe_with_join</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447a90>

    def test_subscribe_with_join(env):
        """Test that subscribe() works if a process waits for another one."""

        def child(env, i):
            yield env.timeout(i)

        def parent(env):
            child_proc1 = env.process(child(env, 1))
            child_proc2 = env.process(child(env, 2))
            try:
                subscribe_at(child_proc1)
                yield child_proc2
            except Interrupt as interrupt:
                assert env.now == 1
                assert interrupt.cause is not None  # noqa: PT017
                assert interrupt.cause[0] is child_proc1  # noqa: PT017
                assert child_proc2.is_alive

        env.process(parent(env))
>       env.run()

tests/test_util.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447a90>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout">test_util.py::test_subscribe_at_timeout</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9482440>

    def test_subscribe_at_timeout(env):
        """You should be able to subscribe at arbitrary events."""

        def pem(env):
            to = env.timeout(2)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, None)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9482440>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_subscribe_at_timeout_with_value">test_util.py::test_subscribe_at_timeout_with_value</h3>
<details><summary> <pre>test_util.py::test_subscribe_at_timeout_with_value</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91749d0>

    def test_subscribe_at_timeout_with_value(env):
        """An event's value should be accessible via the interrupt cause."""

        def pem(env):
            val = 'ohai'
            to = env.timeout(2, value=val)
            subscribe_at(to)
            try:
                yield env.timeout(10)
            except Interrupt as interrupt:
                assert interrupt.cause == (to, val)  # noqa: PT017
                assert env.now == 2

        env.process(pem(env))
>       env.run()

tests/test_util.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91749d0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of">test_util.py::test_all_of</h3>
<details><summary> <pre>test_util.py::test_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a948b6a0>

    def test_all_of(env):
        """Wait for all events to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.all_of(events)

            assert results == {events[i]: i for i in range(10)}
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a948b6a0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_generator">test_util.py::test_all_of_generator</h3>
<details><summary> <pre>test_util.py::test_all_of_generator</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa108670>

    def test_all_of_generator(env):
        """Conditions also work with generators."""

        def parent(env):
            # Start 10 events.
            events = (env.timeout(i, value=i) for i in range(10))
            results = yield env.all_of(events)

            assert list(results.values()) == list(range(10))
            assert env.now == 9

        env.process(parent(env))
>       env.run()

tests/test_util.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa108670>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_wait_for_all_with_errors">test_util.py::test_wait_for_all_with_errors</h3>
<details><summary> <pre>test_util.py::test_wait_for_all_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f2740>

    def test_wait_for_all_with_errors(env):
        """On default AllOf should fail immediately if one of its events
        fails."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [
                env.timeout(1, value=1),
                env.process(child_with_error(env, 2)),
                env.timeout(3, value=3),
            ]

            condition = env.all_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            # Although the condition has failed, interim values are available.
            assert condition._events[0].value == 1
            assert condition._events[1].value.args[0] == 'crashing'
            # The last child has not terminated yet.
            assert not events[2].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f2740>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining">test_util.py::test_all_of_chaining</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def test_all_of_chaining(env):
        """If a wait_for_all condition A is chained to a wait_for_all condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            condition_a &= condition_b

            results = yield condition_a
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67aa0ee8c0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_chaining_intermediate_results">test_util.py::test_all_of_chaining_intermediate_results</h3>
<details><summary> <pre>test_util.py::test_all_of_chaining_intermediate_results</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b4910>

    def test_all_of_chaining_intermediate_results(env):
        """If a wait_for_all condition A with intermediate results is merged into
        another wait_for_all condition B, the results are copied into condition
        A."""

        def parent(env):
            condition_a = env.all_of([env.timeout(i, value=i) for i in range(2)])
            condition_b = env.all_of([env.timeout(i, value=i) for i in range(2)])

            yield env.timeout(0)

            condition = condition_a & condition_b
            result = ConditionValue()
            condition._populate_value(result)
            assert list(result.values()) == [0, 0]

            results = yield condition
            assert list(results.values()) == [0, 1, 0, 1]

        env.process(parent(env))
>       env.run()

tests/test_util.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b4910>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_with_triggered_events">test_util.py::test_all_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_all_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9197490>

    def test_all_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.all_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9197490>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of">test_util.py::test_any_of</h3>
<details><summary> <pre>test_util.py::test_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9447730>

    def test_any_of(env):
        """Wait for any event to be triggered."""

        def parent(env):
            # Start 10 events.
            events = [env.timeout(i, value=i) for i in range(10)]
            results = yield env.any_of(events)

            assert results == {events[0]: 0}
            assert env.now == 0

        env.process(parent(env))
>       env.run()

tests/test_util.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9447730>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_errors">test_util.py::test_any_of_with_errors</h3>
<details><summary> <pre>test_util.py::test_any_of_with_errors</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91f19f0>

    def test_any_of_with_errors(env):
        """On default any_of should fail if the event has failed too."""

        def child_with_error(env, value):
            yield env.timeout(value)
            raise RuntimeError('crashing')

        def parent(env):
            events = [env.process(child_with_error(env, 1)), env.timeout(2, value=2)]
            condition = env.any_of(events)
            with pytest.raises(RuntimeError, match='crashing'):
                yield condition

            assert condition._events[0].value.args[0] == 'crashing'
            # The last event has not terminated yet.
            assert not events[1].processed

        env.process(parent(env))
>       env.run()

tests/test_util.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91f19f0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_chaining">test_util.py::test_any_of_chaining</h3>
<details><summary> <pre>test_util.py::test_any_of_chaining</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9489d50>

    def test_any_of_chaining(env):
        """If a any_of condition A is chained to a any_of condition B,
        B will be merged into A."""

        def parent(env):
            condition_a = env.any_of([env.timeout(2, value='a')])
            condition_b = env.any_of([env.timeout(1, value='b')])

            condition_a |= condition_b

            results = yield condition_a
            assert list(results.values()) == ['b']

        env.process(parent(env))
>       env.run()

tests/test_util.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9489d50>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_any_of_with_triggered_events">test_util.py::test_any_of_with_triggered_events</h3>
<details><summary> <pre>test_util.py::test_any_of_with_triggered_events</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9181d20>

    def test_any_of_with_triggered_events(env):
        """Processed events can be added to a condition. Confirm this with
        all_of."""

        def parent(env):
            events = [env.timeout(0, value='spam'), env.timeout(1, value='eggs')]
            yield env.timeout(2)

            values = list((yield env.any_of(events)).values())
            assert values == ['spam', 'eggs']

        env.process(parent(env))
>       env.run()

tests/test_util.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9181d20>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_any_of">test_util.py::test_empty_any_of</h3>
<details><summary> <pre>test_util.py::test_empty_any_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9175de0>

    def test_empty_any_of(env):
        """AnyOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.any_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9175de0>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_empty_all_of">test_util.py::test_empty_all_of</h3>
<details><summary> <pre>test_util.py::test_empty_all_of</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a91b7280>

    def test_empty_all_of(env):
        """AllOf will trigger immediately if there are no events."""

        def parent(env):
            results = yield env.all_of([])
            assert results == {}

        env.process(parent(env))
>       env.run()

tests/test_util.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a91b7280>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>
<h3 id="test_utilpytest_all_of_expansion">test_util.py::test_all_of_expansion</h3>
<details><summary> <pre>test_util.py::test_all_of_expansion</pre></summary><pre>
env = <simpy.core.Environment object at 0x7f67a9985240>

    def test_all_of_expansion(env):
        """The result of AllOf is an OrderedDict, which allows to expand its values
        directly into variables."""

        def p(env):
            timeouts = [env.timeout(d, d) for d in [3, 2, 1]]
            a, b, c = (yield env.all_of(timeouts)).values()
            assert a == 3
            assert b == 2
            assert c == 1

        env.process(p(env))
>       env.run()

tests/test_util.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/simpy/core.py:176: in run
    self.step()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simpy.core.Environment object at 0x7f67a9985240>

    def step(self) ->None:
        """Process the next event.

        Raise an :exc:`EmptySchedule` if no further events are available.

        """
        try:
            self._now, _, _, event = heappop(self._queue)
        except IndexError:
            raise EmptySchedule()

        # Process the event
        event._ok = True
>       event._value = event._callback(event)
E       AttributeError: 'Initialize' object has no attribute '_callback'. Did you mean: 'callbacks'?

src/simpy/core.py:150: AttributeError
</pre>
</details>

<h2 id="failed-to-run-pytests">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:7: in &lt;module&gt;
    from tinydb.middlewares import CachingMiddleware
tinydb/__init__.py:27: in &lt;module&gt;
    from .queries import Query, where
tinydb/queries.py:21: in &lt;module&gt;
    from .utils import freeze
tinydb/utils.py:84: in &lt;module&gt;
    class FrozenDict(dict):
tinydb/utils.py:95: in FrozenDict
    __setitem__ = _immutable
E   NameError: name &#39;_immutable&#39; is not defined
</code></pre></div>
<h2 id="failed-to-run-pytests_1">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from tests.base import Blog, User, UserSchema
tests/base.py:11: in &lt;module&gt;
    from marshmallow import Schema, fields, missing, post_load, validate
src/marshmallow/__init__.py:17: in &lt;module&gt;
    from marshmallow.schema import Schema, SchemaOpts
src/marshmallow/schema.py:15: in &lt;module&gt;
    from marshmallow import fields as ma_fields
src/marshmallow/fields.py:18: in &lt;module&gt;
    from marshmallow.utils import is_aware, is_collection, resolve_field_instance
E   ImportError: cannot import name &#39;is_aware&#39; from &#39;marshmallow.utils&#39; (/testbed/src/marshmallow/utils.py)
</code></pre></div>
<h2 id="pytest-summary_1">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">32</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">39</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">39</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_1">Failed pytest:</h2>
<h3 id="test_corepytest_empty_string">test_core.py::test_empty_string</h3>
<details><summary> <pre>test_core.py::test_empty_string</pre></summary><pre>
def test_empty_string():
        """
        Test empty string is OK.

        https://github.com/jquast/wcwidth/issues/24
        """
        phrase = ""
        expect_length_each = 0
        expect_length_phrase = 0

        # exercise,
>       length_each = wcwidth.wcwidth(phrase)

tests/test_core.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

wc = '', unicode_version = 'auto'

    @lru_cache(maxsize=1000)
    def wcwidth(wc, unicode_version='auto'):
        """
        Given one Unicode character, return its printable length on a terminal.

        :param str wc: A single Unicode character.
        :param str unicode_version: A Unicode version number, such as
            ``'6.0.0'``. A list of version levels suported by wcwidth
            is returned by :func:`list_versions`.

            Any version string may be specified without error -- the nearest
            matching version is selected.  When ``latest`` (default), the
            highest Unicode version level is used.
        :return: The width, in cells, necessary to display the character of
            Unicode string character, ``wc``.  Returns 0 if the ``wc`` argument has
            no printable effect on a terminal (such as NUL '\\0'), -1 if ``wc`` is
            not printable, or has an indeterminate effect on the terminal, such as
            a control character.  Otherwise, the number of column positions the
            character occupies on a graphic terminal (1 or 2) is returned.
        :rtype: int

        See :ref:`Specification` for details of cell measurement.
        """
>       ucs = ord(wc)
E       TypeError: ord() expected a character, but string of length 0 found

wcwidth/wcwidth.py:129: TypeError
</pre>
</details>
<h3 id="test_corepytest_hello_jp">test_core.py::test_hello_jp</h3>
<details><summary> <pre>test_core.py::test_hello_jp</pre></summary><pre>
def test_hello_jp():
        u"""
        Width of Japanese phrase: , !

        Given a phrase of 5 and 3 Katakana ideographs, joined with
        3 English-ASCII punctuation characters, totaling 11, this
        phrase consumes 19 cells of a terminal emulator.
        """
        # given,
        phrase = u', !'
        expect_length_each = (2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12467
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_wcswidth_substr">test_core.py::test_wcswidth_substr</h3>
<details><summary> <pre>test_core.py::test_wcswidth_substr</pre></summary><pre>
def test_wcswidth_substr():
        """
        Test wcswidth() optional 2nd parameter, ``n``.

        ``n`` determines at which position of the string
        to stop counting length.
        """
        # given,
        phrase = u', !'
        end = 7
        expect_length_each = (2, 2, 2, 2, 2, 1, 1,)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))[:end]

tests/test_core.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12467
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_null_width_0">test_core.py::test_null_width_0</h3>
<details><summary> <pre>test_core.py::test_null_width_0</pre></summary><pre>
def test_null_width_0():
        """NULL (0) reports width 0."""
        # given,
        phrase = u'abc\x00def'
        expect_length_each = (1, 1, 1, 0, 1, 1, 1)
        expect_length_phrase = sum(expect_length_each)

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 97
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_control_c0_width_negative_1">test_core.py::test_control_c0_width_negative_1</h3>
<details><summary> <pre>test_core.py::test_control_c0_width_negative_1</pre></summary><pre>
def test_control_c0_width_negative_1():
        """How the API reacts to CSI (Control sequence initiate).

        An example of bad fortune, this terminal sequence is a width of 0
        on all terminals, but wcwidth doesn't parse Control-Sequence-Inducer
        (CSI) sequences.

        Also the "legacy" posix functions wcwidth and wcswidth return -1 for
        any string containing the C1 control character \x1b (ESC).
        """
        # given,
        phrase = u'\x1b[0m'
        expect_length_each = (-1, 1, 1, 1)
        expect_length_phrase = -1

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 91
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_width">test_core.py::test_combining_width</h3>
<details><summary> <pre>test_core.py::test_combining_width</pre></summary><pre>
def test_combining_width():
        """Simple test combining reports total width of 4."""
        # given,
        phrase = u'--\u05bf--'
        expect_length_each = (1, 1, 0, 1, 1)
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 45
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_cafe">test_core.py::test_combining_cafe</h3>
<details><summary> <pre>test_core.py::test_combining_cafe</pre></summary><pre>
def test_combining_cafe():
        u"""Phrase cafe + COMBINING ACUTE ACCENT is caf of length 4."""
        phrase = u"cafe\u0301"
        expect_length_each = (1, 1, 1, 1, 0)
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 99
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_combining_enclosing">test_core.py::test_combining_enclosing</h3>
<details><summary> <pre>test_core.py::test_combining_enclosing</pre></summary><pre>
def test_combining_enclosing():
        u"""CYRILLIC CAPITAL LETTER A + COMBINING CYRILLIC HUNDRED THOUSANDS SIGN is of length 1."""
        phrase = u"\u0410\u0488"
        expect_length_each = (1, 0)
        expect_length_phrase = 1

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 1040
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_balinese_script">test_core.py::test_balinese_script</h3>
<details><summary> <pre>test_core.py::test_balinese_script</pre></summary><pre>
def test_balinese_script():
        u"""
        Balinese kapal (ship) is length 3.

        This may be an example that is not yet correctly rendered by any terminal so
        far, like devanagari.
        """
        phrase = (u"\u1B13"    # Category 'Lo', EAW 'N' -- BALINESE LETTER KA
                  u"\u1B28"    # Category 'Lo', EAW 'N' -- BALINESE LETTER PA KAPAL
                  u"\u1B2E"    # Category 'Lo', EAW 'N' -- BALINESE LETTER LA
                  u"\u1B44")   # Category 'Mc', EAW 'N' -- BALINESE ADEG ADEG
        expect_length_each = (1, 1, 1, 0)
        expect_length_phrase = 3

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 6931
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kr_jamo">test_core.py::test_kr_jamo</h3>
<details><summary> <pre>test_core.py::test_kr_jamo</pre></summary><pre>
def test_kr_jamo():
        """
        Test basic combining of HANGUL CHOSEONG and JUNGSEONG

        Example and from Raymond Chen's blog post,
        https://devblogs.microsoft.com/oldnewthing/20201009-00/?p=104351
        """
        # This is an example where both characters are "wide" when displayed alone.
        #
        # But JUNGSEONG (vowel) is designed for combination with a CHOSEONG (consonant).
        #
        # This wcwidth library understands their width only when combination,
        # and not by independent display, like other zero-width characters that may
        # only combine with an appropriate preceding character.
        phrase = (
            u"\u1100"  #  HANGUL CHOSEONG KIYEOK (consonant)
            u"\u1161"  #  HANGUL JUNGSEONG A (vowel)
        )
        expect_length_each = (2, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 4352
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kr_jamo_filler">test_core.py::test_kr_jamo_filler</h3>
<details><summary> <pre>test_core.py::test_kr_jamo_filler</pre></summary><pre>
def test_kr_jamo_filler():
        u"""
        Jamo filler is 0 width.

        Example from https://www.unicode.org/L2/L2006/06310-hangul-decompose9.pdf
        """
        phrase = (
            u"\u1100"  # HANGUL CHOSEONG KIYEOK (consonant)
            u"\u1160"  # HANGUL JUNGSEONG FILLER (vowel)
        )
        expect_length_each = (2, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 4352
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_devanagari_script">test_core.py::test_devanagari_script</h3>
<details><summary> <pre>test_core.py::test_devanagari_script</pre></summary><pre>
def test_devanagari_script():
        """
        Attempt to test the measurement width of Devanagari script.

        I believe this 'phrase' should be length 3.

        This is a difficult problem, and this library does not yet get it right,
        because we interpret the unicode data files programmatically, but they do
        not correctly describe how their terminal width is measured.

        There are very few Terminals that do!

        As of 2023,

        - iTerm2: correct length but individual characters are out of order and
                  horizaontally misplaced as to be unreadable in its language when
                  using 'Noto Sans' font.
        - mlterm: mixed results, it offers several options in the configuration
                  dialog, "Xft", "Cario", and "Variable Column Width" have some
                  effect, but with neither 'Noto Sans' or 'unifont', it is not
                  recognizable as the Devanagari script it is meant to display.

        Previous testing with Devanagari documented at address https://benizi.com/vim/devanagari/

        See also, https://askubuntu.com/questions/8437/is-there-a-good-mono-spaced-font-for-devanagari-script-in-the-terminal
        """
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # please note that document correctly points out that the final width cannot be determined
        # as a sum of each individual width, as this library currently performs with exception of
        # ZWJ, but I think it incorrectly gestures what a stateless call to wcwidth.wcwidth of
        # each codepoint *should* return.
        phrase = (u"\u0915"    # Akhand, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER KA
                  u"\u094D"    # Joiner, Category 'Mn', East Asian Width property 'N' -- DEVANAGARI SIGN VIRAMA
                  u"\u0937"    # Fused, Category 'Lo', East Asian Width property 'N' -- DEVANAGARI LETTER SSA
                  u"\u093F")   # MatraL, Category 'Mc', East Asian Width property 'N' -- DEVANAGARI VOWEL SIGN I
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)
        expect_length_each = (1, 0, 1, 0)
        # I believe the final width *should* be 3.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 2325
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_tamil_script">test_core.py::test_tamil_script</h3>
<details><summary> <pre>test_core.py::test_tamil_script</pre></summary><pre>
def test_tamil_script():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        phrase = (u"\u0b95"    # Akhand, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER KA
                  u"\u0bcd"    # Joiner, Category 'Mn', East Asian Width property 'N' -- TAMIL SIGN VIRAMA
                  u"\u0bb7"    # Fused, Category 'Lo', East Asian Width property 'N' -- TAMIL LETTER SSA
                  u"\u0bcc")   # MatraLR, Category 'Mc', East Asian Width property 'N' -- TAMIL VOWEL SIGN AU
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (3, 0, 0, 4)
        expect_length_each = (1, 0, 1, 0)

        # I believe the final width should be about 5 or 6.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 2965
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kannada_script">test_core.py::test_kannada_script</h3>
<details><summary> <pre>test_core.py::test_kannada_script</pre></summary><pre>
def test_kannada_script():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # ||
        # |123|
        phrase = (u"\u0cb0"    # Repha, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA
                  u"\u0ccd"    # Joiner, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN VIRAMA
                  u"\u0c9d"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER JHA
                  u"\u0cc8")   # MatraUR, Category 'Mc', East Asian Width property 'N' -- KANNADA VOWEL SIGN AI
        # 23107-terminal-suppt.pdf suggests should be (2, 0, 3, 1)
        expect_length_each = (1, 0, 1, 0)
        # I believe the correct final width *should* be 3 or 4.
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 3248
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_kannada_script_2">test_core.py::test_kannada_script_2</h3>
<details><summary> <pre>test_core.py::test_kannada_script_2</pre></summary><pre>
def test_kannada_script_2():
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        # ||
        # |12|
        phrase = (u"\u0cb0"    # Base, Category 'Lo', East Asian Width property 'N' -- KANNADA LETTER RA
                  u"\u0cbc"    # Nukta, Category 'Mn', East Asian Width property 'N' -- KANNADA SIGN NUKTA
                  u"\u0ccd"    # Joiner, Category 'Lo', East Asian Width property 'N' -- KANNADA SIGN VIRAMA
                  u"\u0c9a")   # Subjoin, Category 'Mc', East Asian Width property 'N' -- KANNADA LETTER CA
        # 23107-terminal-suppt.pdf suggests wcwidth.wcwidth should return (2, 0, 0, 1)
        expect_length_each = (1, 0, 0, 1)
        # I believe the final width is correct, but maybe for the wrong reasons!
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_core.py:383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 3248
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_corepytest_zero_wide_conflict">test_core.py::test_zero_wide_conflict</h3>
<details><summary> <pre>test_core.py::test_zero_wide_conflict</pre></summary><pre>
def test_zero_wide_conflict():
        # Test characters considered both "wide" and "zero" width
        # -  (0x03000, 0x0303e,),  # Ideographic Space       ..Ideographic Variation In
        # +  (0x03000, 0x03029,),  # Ideographic Space       ..Hangzhou Numeral Nine
>       assert wcwidth.wcwidth(unichr(0x03029), unicode_version='4.1.0') == 2

tests/test_core.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 12329
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unfinished_zwj_sequence">test_emojis.py::test_unfinished_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_unfinished_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_unfinished_zwj_sequence():
        u"""
        Ensure index-out-of-bounds does not occur for zero-width joiner without any following character
        """
        phrase = (u"\U0001f469"   # Base, Category So, East Asian Width property 'W' -- WOMAN
                  u"\U0001f3fb"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER
        expect_length_each = (2, 0, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128105
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_non_recommended_zwj_sequence">test_emojis.py::test_non_recommended_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_non_recommended_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_non_recommended_zwj_sequence():
        """
        Verify ZWJ is measured as though successful with characters that cannot be joined, wcwidth does not verify
        """
        phrase = (u"\U0001f469"   # Base, Category So, East Asian Width property 'W' -- WOMAN
                  u"\U0001f3fb"   # Modifier, Category Sk, East Asian Width property 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d")      # Joiner, Category Cf, East Asian Width property 'N'  -- ZERO WIDTH JOINER
        expect_length_each = (2, 0, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128105
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_another_emoji_zwj_sequence">test_emojis.py::test_another_emoji_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_another_emoji_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_another_emoji_zwj_sequence():
        phrase = (
            u"\u26F9"        # PERSON WITH BALL
            u"\U0001F3FB"    # EMOJI MODIFIER FITZPATRICK TYPE-1-2
            u"\u200D"        # ZERO WIDTH JOINER
            u"\u2640"        # FEMALE SIGN
            u"\uFE0F")       # VARIATION SELECTOR-16
        expect_length_each = (1, 0, 0, 1, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9977
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_longer_emoji_zwj_sequence">test_emojis.py::test_longer_emoji_zwj_sequence</h3>
<details><summary> <pre>test_emojis.py::test_longer_emoji_zwj_sequence</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Test cannot verify on python 'narrow' builds")
    def test_longer_emoji_zwj_sequence():
        """
        A much longer emoji ZWJ sequence of 10 total codepoints is just 2 cells!

        Also test the same sequence in duplicate, verifying multiple VS-16 sequences
        in a single function call.
        """
        # 'Category Code', 'East Asian Width property' -- 'description'
        phrase = (u"\U0001F9D1"   # 'So', 'W' -- ADULT
                  u"\U0001F3FB"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-1-2
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\u2764"       # 'So', 'N' -- HEAVY BLACK HEART
                  u"\uFE0F"       # 'Mn', 'A' -- VARIATION SELECTOR-16
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\U0001F48B"   # 'So', 'W' -- KISS MARK
                  u"\u200d"       # 'Cf', 'N' -- ZERO WIDTH JOINER
                  u"\U0001F9D1"   # 'So', 'W' -- ADULT
                  u"\U0001F3FD"   # 'Sk', 'W' -- EMOJI MODIFIER FITZPATRICK TYPE-4
        ) * 2
        # This test adapted from https://www.unicode.org/L2/L2023/23107-terminal-suppt.pdf
        expect_length_each = (2, 0, 0, 1, 0, 0, 2, 0, 2, 0) * 2
        expect_length_phrase = 4

        # exercise,
>       length_each = tuple(map(wcwidth.wcwidth, phrase))

tests/test_emojis.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 129489
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_recommended_emoji_zwj_sequences">test_emojis.py::test_recommended_emoji_zwj_sequences</h3>
<details><summary> <pre>test_emojis.py::test_recommended_emoji_zwj_sequences</pre></summary><pre>
@pytest.mark.skipif(NARROW_ONLY, reason="Some sequences in text file are not compatible with 'narrow' builds")
    def test_recommended_emoji_zwj_sequences():
        """
        Test wcswidth of all of the unicode.org-published emoji-zwj-sequences.txt
        """
        # given,
        lines, sequences = read_sequences_from_file('emoji-zwj-sequences.txt')

        errors = []
        # Exercise, track by zipping with original text file line, a debugging aide
        num = 0
        for sequence, line in zip(sequences, lines):
            num += 1
>           measured_width = wcwidth.wcswidth(sequence)

tests/test_emojis.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:177: in wcswidth
    char_width = wcwidth(char, unicode_version)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 128104
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_recommended_variation_16_sequences">test_emojis.py::test_recommended_variation_16_sequences</h3>
<details><summary> <pre>test_emojis.py::test_recommended_variation_16_sequences</pre></summary><pre>
def test_recommended_variation_16_sequences():
        """
        Test wcswidth of all of the unicode.org-published emoji-variation-sequences.txt
        """
        # given,
        lines, sequences = read_sequences_from_file('emoji-variation-sequences.txt')

        errors = []
        num = 0
        for sequence, line in zip(sequences, lines):
            num += 1
            if '\ufe0f' not in sequence:
                # filter for only \uFE0F (VS-16)
                continue
>           measured_width = wcwidth.wcswidth(sequence)

tests/test_emojis.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:177: in wcswidth
    char_width = wcwidth(char, unicode_version)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 35
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unicode_9_vs16">test_emojis.py::test_unicode_9_vs16</h3>
<details><summary> <pre>test_emojis.py::test_unicode_9_vs16</pre></summary><pre>
def test_unicode_9_vs16():
        """Verify effect of VS-16 on unicode_version 9.0 and later"""
        phrase = (u"\u2640"        # FEMALE SIGN
                  u"\uFE0F")       # VARIATION SELECTOR-16

        expect_length_each = (1, 0)
        expect_length_phrase = 2

        # exercise,
>       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)

tests/test_emojis.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_emojis.py:222: in <genexpr>
    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='9.0') for w_char in phrase)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9792
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_emojispytest_unicode_8_vs16">test_emojis.py::test_unicode_8_vs16</h3>
<details><summary> <pre>test_emojis.py::test_unicode_8_vs16</pre></summary><pre>
def test_unicode_8_vs16():
        """Verify that VS-16 has no effect on unicode_version 8.0 and earler"""
        phrase = (u"\u2640"        # FEMALE SIGN
                  u"\uFE0F")       # VARIATION SELECTOR-16

        expect_length_each = (1, 0)
        expect_length_phrase = 1

        # exercise,
>       length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)

tests/test_emojis.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_emojis.py:238: in <genexpr>
    length_each = tuple(wcwidth.wcwidth(w_char, unicode_version='8.0') for w_char in phrase)
wcwidth/wcwidth.py:136: in wcwidth
    if _bisearch(ucs, ZERO_WIDTH):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ucs = 9792
table = {'10.0.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), '11.0.0': ((0, 0), (173, 1...9), (1471, 1471), ...), '12.1.0': ((0, 0), (173, 173), (768, 879), (1155, 1161), (1425, 1469), (1471, 1471), ...), ...}

    def _bisearch(ucs, table):
        """
        Auxiliary function for binary search in interval table.

        :arg int ucs: Ordinal value of unicode character.
        :arg list table: List of starting and ending ranges of ordinal values,
            in form of ``[(start, end), ...]``.
        :rtype: int
        :returns: 1 if ordinal value ucs is found within lookup table, else 0.
        """
        lbound = 0
        ubound = len(table) - 1

>       if ucs < table[0][0] or ucs > table[-1][1]:
E       KeyError: 0

wcwidth/wcwidth.py:91: KeyError
</pre>
</details>
<h3 id="test_table_integritypytest_verify_table_integrity">test_table_integrity.py::test_verify_table_integrity</h3>
<details><summary> <pre>test_table_integrity.py::test_verify_table_integrity</pre></summary><pre>
('/testbed/tests/test_table_integrity.py', 10, 'Skipped: Test only with a single version of python')
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_505_str">test_ucslevel.py::test_nearest_505_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_505_str</pre></summary><pre>
def test_nearest_505_str():
        """wcwidth._wcmatch_version('5.0.5') returns nearest '5.0.0'. (str)"""
        # given
        given, expected = '5.0.5', '5.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '5.0.5'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_505_unicode">test_ucslevel.py::test_nearest_505_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_505_unicode</pre></summary><pre>
def test_nearest_505_unicode():
        """wcwidth._wcmatch_version(u'5.0.5') returns nearest u'5.0.0'. (unicode)"""
        # given
        given, expected = u'5.0.5', u'5.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '5.0.5'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '5.0.5' not found, using '5.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_800_str">test_ucslevel.py::test_nearest_800_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_800_str</pre></summary><pre>
def test_nearest_800_str():
        """wcwidth._wcmatch_version('8') returns nearest '8.0.0'."""
        # given
        given, expected = '8', '8.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '8'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '8' not found, using '7.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_800_unicode">test_ucslevel.py::test_nearest_800_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_800_unicode</pre></summary><pre>
def test_nearest_800_unicode():
        """wcwidth._wcmatch_version(u'8') returns nearest u'8.0.0'."""
        # given
        given, expected = u'8', u'8.0.0'

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '8'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '8' not found, using '7.0.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_999_str">test_ucslevel.py::test_nearest_999_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_999_str</pre></summary><pre>
def test_nearest_999_str():
        """wcwidth._wcmatch_version('999.0') returns nearest (latest)."""
        # given
        given, expected = '999.0', wcwidth.list_versions()[-1]

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '999.0'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '999.0' not found, using '15.1.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nearest_999_unicode">test_ucslevel.py::test_nearest_999_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nearest_999_unicode</pre></summary><pre>
def test_nearest_999_unicode():
        """wcwidth._wcmatch_version(u'999.0') returns nearest (latest)."""
        # given
        given, expected = u'999.0', wcwidth.list_versions()[-1]

        # exercise
>       result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

given_version = '999.0'

    @lru_cache(maxsize=8)
    def _wcmatch_version(given_version):
        """
        Return nearest matching supported Unicode version level.

        If an exact match is not determined, the nearest lowest version level is
        returned after a warning is emitted.  For example, given supported levels
        ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``
        is selected and returned:

        >>> _wcmatch_version('4.9.9')
        '4.1.0'
        >>> _wcmatch_version('8.0')
        '8.0.0'
        >>> _wcmatch_version('1')
        '4.1.0'

        :param str given_version: given version for compare, may be ``auto``
            (default), to select Unicode Version from Environment Variable,
            ``UNICODE_VERSION``. If the environment variable is not set, then the
            latest is used.
        :rtype: str
        :returns: unicode string, or non-unicode ``str`` type for python 2
            when given ``version`` is also type ``str``.
        """
        if given_version == 'auto':
            given_version = os.environ.get('UNICODE_VERSION', 'latest')

        if given_version == 'latest':
            return list_versions()[-1]

        supported_versions = list_versions()
        given_value = _wcversion_value(given_version)

        for version in reversed(supported_versions):
            if _wcversion_value(version) <= given_value:
                if version != given_version:
>                   warnings.warn(f"Unicode version '{given_version}' not found, using '{version}'")
E                   UserWarning: Unicode version '999.0' not found, using '15.1.0'

wcwidth/wcwidth.py:234: UserWarning
</pre>
</details>
<h3 id="test_ucslevelpytest_nonint_unicode">test_ucslevel.py::test_nonint_unicode</h3>
<details><summary> <pre>test_ucslevel.py::test_nonint_unicode</pre></summary><pre>
def test_nonint_unicode():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode)."""
        # given
        given, expected = u'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
        with pytest.warns(UserWarning):
            # warns that given version is not valid
>           result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:229: in _wcmatch_version
    given_value = _wcversion_value(given_version)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ver_string = 'x.y.z'

    @lru_cache(maxsize=128)
    def _wcversion_value(ver_string):
        """
        Integer-mapped value of given dotted version string.

        :param str ver_string: Unicode version string, of form ``n.n.n``.
        :rtype: tuple(int)
        :returns: tuple of digit tuples, ``tuple(int, [...])``.
        """
>       return tuple(map(int, ver_string.split('.')))
E       ValueError: invalid literal for int() with base 10: 'x'

wcwidth/wcwidth.py:194: ValueError

During handling of the above exception, another exception occurred:

    def test_nonint_unicode():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (unicode)."""
        # given
        given, expected = u'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
>       with pytest.warns(UserWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
E        Emitted warnings: [].

tests/test_ucslevel.py:161: Failed
</pre>
</details>
<h3 id="test_ucslevelpytest_nonint_str">test_ucslevel.py::test_nonint_str</h3>
<details><summary> <pre>test_ucslevel.py::test_nonint_str</pre></summary><pre>
def test_nonint_str():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (str)."""
        # given
        given, expected = 'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
        with pytest.warns(UserWarning):
            # warns that given version is not valid
>           result = wcwidth._wcmatch_version(given)

tests/test_ucslevel.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
wcwidth/wcwidth.py:229: in _wcmatch_version
    given_value = _wcversion_value(given_version)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ver_string = 'x.y.z'

    @lru_cache(maxsize=128)
    def _wcversion_value(ver_string):
        """
        Integer-mapped value of given dotted version string.

        :param str ver_string: Unicode version string, of form ``n.n.n``.
        :rtype: tuple(int)
        :returns: tuple of digit tuples, ``tuple(int, [...])``.
        """
>       return tuple(map(int, ver_string.split('.')))
E       ValueError: invalid literal for int() with base 10: 'x'

wcwidth/wcwidth.py:194: ValueError

During handling of the above exception, another exception occurred:

    def test_nonint_str():
        """wcwidth._wcmatch_version(u'x.y.z') returns latest (str)."""
        # given
        given, expected = 'x.y.z', wcwidth.list_versions()[-1]
        warnings.resetwarnings()
        wcwidth._wcmatch_version.cache_clear()

        # exercise
>       with pytest.warns(UserWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
E        Emitted warnings: [].

tests/test_ucslevel.py:177: Failed
</pre>
</details>

<h2 id="failed-to-run-pytests_2">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="failed-to-run-pytests_3">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="failed-to-run-pytests_4">Failed to run pytests</h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:5: in &lt;module&gt;
    from jinja2 import loaders
src/jinja2/__init__.py:9: in &lt;module&gt;
    from .environment import Environment as Environment
src/jinja2/environment.py:14: in &lt;module&gt;
    from . import nodes
src/jinja2/nodes.py:808: in &lt;module&gt;
    NodeType.__new__ = staticmethod(_failing_new)
E   NameError: name &#39;_failing_new&#39; is not defined
</code></pre></div>
<h2 id="pytest-summary_2">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">80</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">81</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">171</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">171</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_2">Failed pytest:</h2>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsnone">test_deprecated.py::test_classic_deprecated_function__warns[None]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[None]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[None]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_function(request):
        if request.param is None:

            @deprecated.classic.deprecated
>           def foo1():

tests/test_deprecated.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<function classic_deprecated_function.<locals>.foo1 at 0x7ee0671a3400>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function1">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function1]</pre></summary><pre>
classic_deprecated_function = <function classic_deprecated_function.<locals>.foo1 at 0x7ee066f2d6c0>

    def test_classic_deprecated_function__warns(classic_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:135: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function2">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function2]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_function' for <Function test_classic_deprecated_function__warns[classic_deprecated_function2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_function(request):
        if request.param is None:

            @deprecated.classic.deprecated
            def foo1():
                pass

            return foo1
        else:
            args, kwargs = request.param

>           @deprecated.classic.deprecated(*args, **kwargs)

tests/test_deprecated.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Good reason',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function3">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function3]</pre></summary><pre>
classic_deprecated_function = <function classic_deprecated_function.<locals>.foo1 at 0x7ee066f2dcf0>

    def test_classic_deprecated_function__warns(classic_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:135: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function4">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function4]</pre></summary><pre>
classic_deprecated_function = <function classic_deprecated_function.<locals>.foo1 at 0x7ee066f2dea0>

    def test_classic_deprecated_function__warns(classic_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:135: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function5">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function5]</pre></summary><pre>
classic_deprecated_function = <function classic_deprecated_function.<locals>.foo1 at 0x7ee066f2ca60>

    def test_classic_deprecated_function__warns(classic_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:135: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_function__warnsclassic_deprecated_function6">test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_function__warns[classic_deprecated_function6]</pre></summary><pre>
classic_deprecated_function = <function classic_deprecated_function.<locals>.foo1 at 0x7ee066f2e050>

    def test_classic_deprecated_function__warns(classic_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:135: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class__warnsnone">test_deprecated.py::test_classic_deprecated_class__warns[None]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class__warns[None]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[None]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_class(request):
        if request.param is None:

            @deprecated.classic.deprecated
>           class Foo2(object):

tests/test_deprecated.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated.classic_deprecated_class.<locals>.Foo2'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class__warnsclassic_deprecated_class2">test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class__warns[classic_deprecated_class2]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_class' for <Function test_classic_deprecated_class__warns[classic_deprecated_class2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_class(request):
        if request.param is None:

            @deprecated.classic.deprecated
            class Foo2(object):
                pass

            return Foo2
        else:
            args, kwargs = request.param

>           @deprecated.classic.deprecated(*args, **kwargs)

tests/test_deprecated.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Good reason',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsnone">test_deprecated.py::test_classic_deprecated_method__warns[None]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[None]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[None]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_method(request):
        if request.param is None:

>           class Foo3(object):

tests/test_deprecated.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:69: in Foo3
    def foo3(self):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<function classic_deprecated_method.<locals>.Foo3.foo3 at 0x7ee066f2d750>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method1">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method1]</pre></summary><pre>
classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>

    def test_classic_deprecated_method__warns(classic_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = classic_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:160: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method2">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method2]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_method' for <Function test_classic_deprecated_method__warns[classic_deprecated_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_method(request):
        if request.param is None:

            class Foo3(object):
                @deprecated.classic.deprecated
                def foo3(self):
                    pass

            return Foo3
        else:
            args, kwargs = request.param

>           class Foo3(object):

tests/test_deprecated.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:77: in Foo3
    @deprecated.classic.deprecated(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Good reason',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method3">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method3]</pre></summary><pre>
classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>

    def test_classic_deprecated_method__warns(classic_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = classic_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:160: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method4">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method4]</pre></summary><pre>
classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>

    def test_classic_deprecated_method__warns(classic_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = classic_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:160: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method5">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method5]</pre></summary><pre>
classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>

    def test_classic_deprecated_method__warns(classic_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = classic_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:160: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_method__warnsclassic_deprecated_method6">test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_method__warns[classic_deprecated_method6]</pre></summary><pre>
classic_deprecated_method = <class 'tests.test_deprecated.classic_deprecated_method.<locals>.Foo3'>

    def test_classic_deprecated_method__warns(classic_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = classic_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:160: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsnone">test_deprecated.py::test_classic_deprecated_static_method__warns[None]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[None]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[None]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_static_method(request):
        if request.param is None:

>           class Foo4(object):

tests/test_deprecated.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:91: in Foo4
    def foo4():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2dd80>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method1">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method1]</pre></summary><pre>
classic_deprecated_static_method = <function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2f640>

    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:172: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method2">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_static_method' for <Function test_classic_deprecated_static_method__warns[classic_deprecated_static_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_static_method(request):
        if request.param is None:

            class Foo4(object):
                @staticmethod
                @deprecated.classic.deprecated
                def foo4():
                    pass

            return Foo4.foo4
        else:
            args, kwargs = request.param

>           class Foo4(object):

tests/test_deprecated.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:100: in Foo4
    @deprecated.classic.deprecated(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Good reason',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method3">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method3]</pre></summary><pre>
classic_deprecated_static_method = <function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2ff40>

    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:172: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method4">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method4]</pre></summary><pre>
classic_deprecated_static_method = <function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2f910>

    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:172: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method5">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method5]</pre></summary><pre>
classic_deprecated_static_method = <function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2ee60>

    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:172: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_static_method__warnsclassic_deprecated_static_method6">test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_static_method__warns[classic_deprecated_static_method6]</pre></summary><pre>
classic_deprecated_static_method = <function classic_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066f2f0a0>

    def test_classic_deprecated_static_method__warns(classic_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            classic_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:172: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsnone">test_deprecated.py::test_classic_deprecated_class_method__warns[None]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[None]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[None]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_class_method(request):
        if request.param is None:

>           class Foo5(object):

tests/test_deprecated.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:114: in Foo5
    def foo5(cls):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<function classic_deprecated_class_method.<locals>.Foo5.foo5 at 0x7ee066f2f010>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method1">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method1]</pre></summary><pre>
classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>

    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = classic_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:185: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method2">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]</pre></summary><pre>
request = <SubRequest 'classic_deprecated_class_method' for <Function test_classic_deprecated_class_method__warns[classic_deprecated_class_method2]>>

    @pytest.fixture(scope="module", params=_PARAMS)
    def classic_deprecated_class_method(request):
        if request.param is None:

            class Foo5(object):
                @classmethod
                @deprecated.classic.deprecated
                def foo5(cls):
                    pass

            return Foo5
        else:
            args, kwargs = request.param

>           class Foo5(object):

tests/test_deprecated.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_deprecated.py:123: in Foo5
    @deprecated.classic.deprecated(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('Good reason',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method3">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method3]</pre></summary><pre>
classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>

    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = classic_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:185: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method4">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method4]</pre></summary><pre>
classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>

    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = classic_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:185: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method5">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method5]</pre></summary><pre>
classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>

    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = classic_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:185: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_classic_deprecated_class_method__warnsclassic_deprecated_class_method6">test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]</h3>
<details><summary> <pre>test_deprecated.py::test_classic_deprecated_class_method__warns[classic_deprecated_class_method6]</pre></summary><pre>
classic_deprecated_class_method = <class 'tests.test_deprecated.classic_deprecated_class_method.<locals>.Foo5'>

    def test_classic_deprecated_class_method__warns(classic_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = classic_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:185: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_should_raise_type_error">test_deprecated.py::test_should_raise_type_error</h3>
<details><summary> <pre>test_deprecated.py::test_should_raise_type_error</pre></summary><pre>
def test_should_raise_type_error():
        try:
>           deprecated.classic.deprecated(5)

tests/test_deprecated.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (5,), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_warning_msg_has_reason">test_deprecated.py::test_warning_msg_has_reason</h3>
<details><summary> <pre>test_deprecated.py::test_warning_msg_has_reason</pre></summary><pre>
def test_warning_msg_has_reason():
        reason = "Good reason"

        @deprecated.classic.deprecated(reason=reason)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_deprecated.py:212: IndexError
</pre>
</details>
<h3 id="test_deprecatedpytest_warning_msg_has_version">test_deprecated.py::test_warning_msg_has_version</h3>
<details><summary> <pre>test_deprecated.py::test_warning_msg_has_version</pre></summary><pre>
def test_warning_msg_has_version():
        version = "1.2.3"

        @deprecated.classic.deprecated(version=version)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_deprecated.py:225: IndexError
</pre>
</details>
<h3 id="test_deprecatedpytest_specific_warning_cls_is_used">test_deprecated.py::test_specific_warning_cls_is_used</h3>
<details><summary> <pre>test_deprecated.py::test_specific_warning_cls_is_used</pre></summary><pre>
def test_specific_warning_cls_is_used():
        @deprecated.classic.deprecated(category=MyDeprecationWarning)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_deprecated.py:246: IndexError
</pre>
</details>
<h3 id="test_deprecatedpytest_respect_global_filter">test_deprecated.py::test_respect_global_filter</h3>
<details><summary> <pre>test_deprecated.py::test_respect_global_filter</pre></summary><pre>
def test_respect_global_filter():
        @deprecated.classic.deprecated(version='1.2.1', reason="deprecated function")
        def fun():
            print("fun")

        warnings.simplefilter("once", category=DeprecationWarning)

        with warnings.catch_warnings(record=True) as warns:
            fun()
            fun()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_deprecated.py:260: AssertionError
</pre>
</details>
<h3 id="test_deprecated_classpytest_class_deprecation_using_deprecated_decorator">test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator</h3>
<details><summary> <pre>test_deprecated_class.py::test_class_deprecation_using_deprecated_decorator</pre></summary><pre>
def test_class_deprecation_using_deprecated_decorator():
        @deprecated.classic.deprecated
>       class MyBaseClass(object):

tests/test_deprecated_class.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_class.test_class_deprecation_using_deprecated_decorator.<locals>.MyBaseClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_classpytest_class_respect_global_filter">test_deprecated_class.py::test_class_respect_global_filter</h3>
<details><summary> <pre>test_deprecated_class.py::test_class_respect_global_filter</pre></summary><pre>
def test_class_respect_global_filter():
        @deprecated.classic.deprecated
>       class MyBaseClass(object):

tests/test_deprecated_class.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_class.test_class_respect_global_filter.<locals>.MyBaseClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_classpytest_subclass_deprecation_using_deprecated_decorator">test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator</h3>
<details><summary> <pre>test_deprecated_class.py::test_subclass_deprecation_using_deprecated_decorator</pre></summary><pre>
def test_subclass_deprecation_using_deprecated_decorator():
        @deprecated.classic.deprecated
>       class MyBaseClass(object):

tests/test_deprecated_class.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_class.test_subclass_deprecation_using_deprecated_decorator.<locals>.MyBaseClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_classpytest_simple_class_deprecation_with_args">test_deprecated_class.py::test_simple_class_deprecation_with_args</h3>
<details><summary> <pre>test_deprecated_class.py::test_simple_class_deprecation_with_args</pre></summary><pre>
def test_simple_class_deprecation_with_args():
>       @deprecated.classic.deprecated('kwargs class')

tests/test_deprecated_class.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ('kwargs class',), kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_metaclasspytest_with_init">test_deprecated_metaclass.py::test_with_init</h3>
<details><summary> <pre>test_deprecated_metaclass.py::test_with_init</pre></summary><pre>
def test_with_init():
        @deprecated.classic.deprecated
>       class MyClass(object):

tests/test_deprecated_metaclass.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_metaclass.test_with_init.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_metaclasspytest_with_new">test_deprecated_metaclass.py::test_with_new</h3>
<details><summary> <pre>test_deprecated_metaclass.py::test_with_new</pre></summary><pre>
def test_with_new():
        @deprecated.classic.deprecated
>       class MyClass(object):

tests/test_deprecated_metaclass.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_metaclass.test_with_new.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_metaclasspytest_with_metaclass">test_deprecated_metaclass.py::test_with_metaclass</h3>
<details><summary> <pre>test_deprecated_metaclass.py::test_with_metaclass</pre></summary><pre>
def test_with_metaclass():
        class Meta(type):
            def __call__(cls, *args, **kwargs):
                obj = super(Meta, cls).__call__(*args, **kwargs)
                obj.c = 3.14
                return obj

        @deprecated.classic.deprecated
>       class MyClass(with_metaclass(Meta)):

tests/test_deprecated_metaclass.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_metaclass.test_with_metaclass.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_deprecated_metaclasspytest_with_singleton_metaclass">test_deprecated_metaclass.py::test_with_singleton_metaclass</h3>
<details><summary> <pre>test_deprecated_metaclass.py::test_with_singleton_metaclass</pre></summary><pre>
def test_with_singleton_metaclass():
        class Singleton(type):
            _instances = {}

            def __call__(cls, *args, **kwargs):
                if cls not in cls._instances:
                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
                return cls._instances[cls]

        @deprecated.classic.deprecated
>       class MyClass(with_metaclass(Singleton)):

tests/test_deprecated_metaclass.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_deprecated_metaclass.test_with_singleton_metaclass.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = 'A good reason', version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n   A good reason\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringshort_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[short_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.', directive = 'deprecated'
reason = None, version = '1.2.0', expected = '.. deprecated:: 1.2.0\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = 'A good reason'
version = '1.2.0', expected = '.. deprecated:: 1.2.0\n   A good reason\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringno_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[no_docstring-deprecated-version]</pre></summary><pre>
docstring = None, directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n   A good reason\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd213_long_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D213_long_docstring-deprecated-version]</pre></summary><pre>
docstring = '\n        This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-reasonversion">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&amp;version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-reason&version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = 'A good reason', version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n   A good reason\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_has_sphinx_docstringd212_long_docstring-deprecated-version">test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]</h3>
<details><summary> <pre>test_sphinx.py::test_has_sphinx_docstring[D212_long_docstring-deprecated-version]</pre></summary><pre>
docstring = 'This function adds *x* and *y*.\n\n        :param x: number *x*\n        :param y: number *y*\n        :return: sum = *x* + *y*\n        '
directive = 'deprecated', reason = None, version = '1.2.0'
expected = '.. deprecated:: 1.2.0\n'

    @pytest.mark.parametrize(
        "reason, version, expected",
        [
            (
                'A good reason',
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                       {reason}
                    """
                ),
            ),
            (
                None,
                '1.2.0',
                textwrap.dedent(
                    """\
                    .. {directive}:: {version}
                    """
                ),
            ),
        ],
        ids=["reason&version", "version"],
    )
    def test_has_sphinx_docstring(docstring, directive, reason, version, expected):
        # The function:
        def foo(x, y):
            return x + y

        # with docstring:
        foo.__doc__ = docstring

        # is decorated with:
        decorator_factory = getattr(deprecated.sphinx, directive)
        decorator = decorator_factory(reason=reason, version=version)
        foo = decorator(foo)

        # The function must contains this Sphinx docstring:
        expected = expected.format(directive=directive, version=version, reason=reason)

        current = textwrap.dedent(foo.__doc__)
        assert current.endswith(expected)

        current = current.replace(expected, '')
        if docstring:
            # An empty line must separate the original docstring and the directive.
            assert re.search("\n[ ]*\n$", current, flags=re.DOTALL)
        else:
            # Avoid "Explicit markup ends without a blank line" when the decorated function has no docstring
            assert current == "\n"

        with warnings.catch_warnings(record=True) as warns:
            foo(1, 2)

        if directive in {'versionadded', 'versionchanged'}:
            # don't emit DeprecationWarning
            assert len(warns) == 0
        else:
            # emit DeprecationWarning
>           assert len(warns) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_sphinx.py:105: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function0">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function0]</pre></summary><pre>
sphinx_deprecated_function = <function sphinx_deprecated_function.<locals>.foo1 at 0x7ee066fc89d0>

    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:252: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function1">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function1]</pre></summary><pre>
sphinx_deprecated_function = <function sphinx_deprecated_function.<locals>.foo1 at 0x7ee066fc8310>

    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:252: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function2">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function2]</pre></summary><pre>
sphinx_deprecated_function = <function sphinx_deprecated_function.<locals>.foo1 at 0x7ee066fc84c0>

    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:252: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_function__warnssphinx_deprecated_function3">test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_function__warns[sphinx_deprecated_function3]</pre></summary><pre>
sphinx_deprecated_function = <function sphinx_deprecated_function.<locals>.foo1 at 0x7ee066fc8940>

    def test_sphinx_deprecated_function__warns(sphinx_deprecated_function):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_function()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:252: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method0">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method0]</pre></summary><pre>
sphinx_deprecated_method = <class 'tests.test_sphinx.sphinx_deprecated_method.<locals>.Foo3'>

    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = sphinx_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:278: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method1">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method1]</pre></summary><pre>
sphinx_deprecated_method = <class 'tests.test_sphinx.sphinx_deprecated_method.<locals>.Foo3'>

    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = sphinx_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:278: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method2">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method2]</pre></summary><pre>
sphinx_deprecated_method = <class 'tests.test_sphinx.sphinx_deprecated_method.<locals>.Foo3'>

    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = sphinx_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:278: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_method__warnssphinx_deprecated_method3">test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_method__warns[sphinx_deprecated_method3]</pre></summary><pre>
sphinx_deprecated_method = <class 'tests.test_sphinx.sphinx_deprecated_method.<locals>.Foo3'>

    def test_sphinx_deprecated_method__warns(sphinx_deprecated_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            obj = sphinx_deprecated_method()
            obj.foo3()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:278: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method0">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method0]</pre></summary><pre>
sphinx_deprecated_static_method = <function sphinx_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066fc8d30>

    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:289: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method1">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method1]</pre></summary><pre>
sphinx_deprecated_static_method = <function sphinx_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066fc9090>

    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:289: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method2">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method2]</pre></summary><pre>
sphinx_deprecated_static_method = <function sphinx_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066fc9240>

    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:289: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_static_method__warnssphinx_deprecated_static_method3">test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_static_method__warns[sphinx_deprecated_static_method3]</pre></summary><pre>
sphinx_deprecated_static_method = <function sphinx_deprecated_static_method.<locals>.Foo4.foo4 at 0x7ee066fc93f0>

    def test_sphinx_deprecated_static_method__warns(sphinx_deprecated_static_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            sphinx_deprecated_static_method()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:289: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method0">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method0]</pre></summary><pre>
sphinx_deprecated_class_method = <class 'tests.test_sphinx.sphinx_deprecated_class_method.<locals>.Foo5'>

    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = sphinx_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:301: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method1">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method1]</pre></summary><pre>
sphinx_deprecated_class_method = <class 'tests.test_sphinx.sphinx_deprecated_class_method.<locals>.Foo5'>

    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = sphinx_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:301: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method2">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method2]</pre></summary><pre>
sphinx_deprecated_class_method = <class 'tests.test_sphinx.sphinx_deprecated_class_method.<locals>.Foo5'>

    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = sphinx_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:301: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_deprecated_class_method__warnssphinx_deprecated_class_method3">test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_deprecated_class_method__warns[sphinx_deprecated_class_method3]</pre></summary><pre>
sphinx_deprecated_class_method = <class 'tests.test_sphinx.sphinx_deprecated_class_method.<locals>.Foo5'>

    def test_sphinx_deprecated_class_method__warns(sphinx_deprecated_class_method):
        with warnings.catch_warnings(record=True) as warns:
            warnings.simplefilter("always")
            cls = sphinx_deprecated_class_method()
            cls.foo5()
>       assert len(warns) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sphinx.py:301: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_warning_msg_has_reason">test_sphinx.py::test_warning_msg_has_reason</h3>
<details><summary> <pre>test_sphinx.py::test_warning_msg_has_reason</pre></summary><pre>
def test_warning_msg_has_reason():
        reason = "Good reason"

        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_sphinx.py:330: IndexError
</pre>
</details>
<h3 id="test_sphinxpytest_warning_msg_has_version">test_sphinx.py::test_warning_msg_has_version</h3>
<details><summary> <pre>test_sphinx.py::test_warning_msg_has_version</pre></summary><pre>
def test_warning_msg_has_version():
        version = "1.2.3"

        @deprecated.sphinx.deprecated(version=version)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_sphinx.py:343: IndexError
</pre>
</details>
<h3 id="test_sphinxpytest_specific_warning_cls_is_used">test_sphinx.py::test_specific_warning_cls_is_used</h3>
<details><summary> <pre>test_sphinx.py::test_specific_warning_cls_is_used</pre></summary><pre>
def test_specific_warning_cls_is_used():
        @deprecated.sphinx.deprecated(version="4.5.6", category=MyDeprecationWarning)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_sphinx.py:364: IndexError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_syntax_trimminguse-functionbar-instead-use-bar-instead">test_sphinx.py::test_sphinx_syntax_trimming[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :function:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        ["reason", "expected"],
        [
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
        ],
    )
    def test_sphinx_syntax_trimming(reason, expected):
        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_sphinx.py:389: IndexError
</pre>
</details>
<h3 id="test_sphinxpytest_sphinx_syntax_trimminguse-pyfuncbar-instead-use-bar-instead">test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_sphinx_syntax_trimming[Use :py:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        ["reason", "expected"],
        [
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
        ],
    )
    def test_sphinx_syntax_trimming(reason, expected):
        @deprecated.sphinx.deprecated(version="4.5.6", reason=reason)
        def foo():
            pass

        with warnings.catch_warnings(record=True) as warns:
            foo()
>       warn = warns[0]
E       IndexError: list index out of range

tests/test_sphinx.py:389: IndexError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-funcbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function <lambda>. (Use bar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-functionbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :function:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :function:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :function:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function <lambda>. (Use :function:`bar` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-classbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :class:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :class:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :class:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function <lambda>. (Use Baz instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-excbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :exc:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :exc:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :exc:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function <lambda>. (Use Baz instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-exceptionbaz-instead-use-baz-instead">test_sphinx.py::test_get_deprecated_msg[Use :exception:<code>Baz</code> instead-Use <code>Baz</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :exception:`Baz` instead-Use `Baz` instead]</pre></summary><pre>
reason = 'Use :exception:`Baz` instead', expected = 'Use `Baz` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `Baz` instead' in 'Call to deprecated function <lambda>. (Use :exception:`Baz` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-methbazbar-instead-use-bazbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :meth:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :meth:`Baz.bar` instead-Use `Baz.bar` instead]</pre></summary><pre>
reason = 'Use :meth:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `Baz.bar` instead' in 'Call to deprecated function <lambda>. (Use Baz.bar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-methodbazbar-instead-use-bazbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :method:<code>Baz.bar</code> instead-Use <code>Baz.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :method:`Baz.bar` instead-Use `Baz.bar` instead]</pre></summary><pre>
reason = 'Use :method:`Baz.bar` instead', expected = 'Use `Baz.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `Baz.bar` instead' in 'Call to deprecated function <lambda>. (Use :method:`Baz.bar` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-pyfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :py:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :py:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :py:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function <lambda>. (Use :pybar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-cppfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :cpp:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :cpp:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function <lambda>. (Use :cppbar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-jsfuncbar-instead-use-bar-instead">test_sphinx.py::test_get_deprecated_msg[Use :js:func:<code>bar</code> instead-Use <code>bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :js:func:`bar` instead-Use `bar` instead]</pre></summary><pre>
reason = 'Use :js:func:`bar` instead', expected = 'Use `bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `bar` instead' in 'Call to deprecated function <lambda>. (Use :jsbar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-funcpkgmodbar-instead-use-pkgmodbar-instead">test_sphinx.py::test_get_deprecated_msg[Use :func:<code>~pkg.mod.bar</code> instead-Use <code>~pkg.mod.bar</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :func:`~pkg.mod.bar` instead-Use `~pkg.mod.bar` instead]</pre></summary><pre>
reason = 'Use :func:`~pkg.mod.bar` instead'
expected = 'Use `~pkg.mod.bar` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `~pkg.mod.bar` instead' in 'Call to deprecated function <lambda>. (Use pkg.mod.bar instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-rinstead-use-instead">test_sphinx.py::test_get_deprecated_msg[Use :r:<code>instead-Use</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`` instead-Use `` instead]</pre></summary><pre>
reason = 'Use :r:`` instead', expected = 'Use `` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `` instead' in 'Call to deprecated function <lambda>. (Use :r:`` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-drinstead-use-instead">test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>instead-Use</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`` instead-Use `` instead]</pre></summary><pre>
reason = 'Use :d:r:`` instead', expected = 'Use `` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `` instead' in 'Call to deprecated function <lambda>. (Use :d:r:`` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-rfoo-instead-use-foo-instead">test_sphinx.py::test_get_deprecated_msg[Use :r:<code>foo</code> instead-Use <code>foo</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :r:`foo` instead-Use `foo` instead]</pre></summary><pre>
reason = 'Use :r:`foo` instead', expected = 'Use `foo` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `foo` instead' in 'Call to deprecated function <lambda>. (Use :r:`foo` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinxpytest_get_deprecated_msguse-drfoo-instead-use-foo-instead">test_sphinx.py::test_get_deprecated_msg[Use :d:r:<code>foo</code> instead-Use <code>foo</code> instead]</h3>
<details><summary> <pre>test_sphinx.py::test_get_deprecated_msg[Use :d:r:`foo` instead-Use `foo` instead]</pre></summary><pre>
reason = 'Use :d:r:`foo` instead', expected = 'Use `foo` instead'

    @pytest.mark.parametrize(
        "reason, expected",
        [
            # classic examples using the default domain (Python)
            ("Use :func:`bar` instead", "Use `bar` instead"),
            ("Use :function:`bar` instead", "Use `bar` instead"),
            ("Use :class:`Baz` instead", "Use `Baz` instead"),
            ("Use :exc:`Baz` instead", "Use `Baz` instead"),
            ("Use :exception:`Baz` instead", "Use `Baz` instead"),
            ("Use :meth:`Baz.bar` instead", "Use `Baz.bar` instead"),
            ("Use :method:`Baz.bar` instead", "Use `Baz.bar` instead"),
            # other examples using a domain :
            ("Use :py:func:`bar` instead", "Use `bar` instead"),
            ("Use :cpp:func:`bar` instead", "Use `bar` instead"),
            ("Use :js:func:`bar` instead", "Use `bar` instead"),
            # the reference can have special characters:
            ("Use :func:`~pkg.mod.bar` instead", "Use `~pkg.mod.bar` instead"),
            # edge cases:
            ("Use :r:`` instead", "Use `` instead"),
            ("Use :d:r:`` instead", "Use `` instead"),
            ("Use :r:`foo` instead", "Use `foo` instead"),
            ("Use :d:r:`foo` instead", "Use `foo` instead"),
            ("Use r:`bad` instead", "Use r:`bad` instead"),
            ("Use ::`bad` instead", "Use ::`bad` instead"),
            ("Use :::`bad` instead", "Use :::`bad` instead"),
        ],
    )
    def test_get_deprecated_msg(reason, expected):
        adapter = deprecated.sphinx.SphinxAdapter("deprecated", reason=reason, version="1")
        actual = adapter.get_deprecated_msg(lambda: None, None)
>       assert expected in actual
E       AssertionError: assert 'Use `foo` instead' in 'Call to deprecated function <lambda>. (Use :d:r:`foo` instead) -- Deprecated since version 1.'

tests/test_sphinx.py:424: AssertionError
</pre>
</details>
<h3 id="test_sphinx_metaclasspytest_with_init">test_sphinx_metaclass.py::test_with_init</h3>
<details><summary> <pre>test_sphinx_metaclass.py::test_with_init</pre></summary><pre>
def test_with_init():
        @deprecated.classic.deprecated
>       class MyClass(object):

tests/test_sphinx_metaclass.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_sphinx_metaclass.test_with_init.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_sphinx_metaclasspytest_with_new">test_sphinx_metaclass.py::test_with_new</h3>
<details><summary> <pre>test_sphinx_metaclass.py::test_with_new</pre></summary><pre>
def test_with_new():
        @deprecated.classic.deprecated
>       class MyClass(object):

tests/test_sphinx_metaclass.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_sphinx_metaclass.test_with_new.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_sphinx_metaclasspytest_with_metaclass">test_sphinx_metaclass.py::test_with_metaclass</h3>
<details><summary> <pre>test_sphinx_metaclass.py::test_with_metaclass</pre></summary><pre>
def test_with_metaclass():
        class Meta(type):
            def __call__(cls, *args, **kwargs):
                obj = super(Meta, cls).__call__(*args, **kwargs)
                obj.c = 3.14
                return obj

        @deprecated.classic.deprecated
>       class MyClass(with_metaclass(Meta)):

tests/test_sphinx_metaclass.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_sphinx_metaclass.test_with_metaclass.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>
<h3 id="test_sphinx_metaclasspytest_with_singleton_metaclass">test_sphinx_metaclass.py::test_with_singleton_metaclass</h3>
<details><summary> <pre>test_sphinx_metaclass.py::test_with_singleton_metaclass</pre></summary><pre>
def test_with_singleton_metaclass():
        class Singleton(type):
            _instances = {}

            def __call__(cls, *args, **kwargs):
                if cls not in cls._instances:
                    cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
                return cls._instances[cls]

        @deprecated.classic.deprecated
>       class MyClass(with_metaclass(Singleton)):

tests/test_sphinx_metaclass.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<class 'tests.test_sphinx_metaclass.test_with_singleton_metaclass.<locals>.MyClass'>,)
kwargs = {}

    def deprecated(*args, **kwargs):
        """
        This is a decorator which can be used to mark functions
        as deprecated. It will result in a warning being emitted
        when the function is used.

        **Classic usage:**

        To use this, decorate your deprecated function with **@deprecated** decorator:

        .. code-block:: python

           from deprecated import deprecated


           @deprecated
           def some_old_function(x, y):
               return x + y

        You can also decorate a class or a method:

        .. code-block:: python

           from deprecated import deprecated


           class SomeClass(object):
               @deprecated
               def some_old_method(self, x, y):
                   return x + y


           @deprecated
           class SomeOldClass(object):
               pass

        You can give a *reason* message to help the developer to choose another function/class,
        and a *version* number to specify the starting version number of the deprecation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(reason="use another function", version='1.2.0')
           def some_old_function(x, y):
               return x + y

        The *category* keyword argument allow you to specify the deprecation warning class of your choice.
        By default, :exc:`DeprecationWarning` is used but you can choose :exc:`FutureWarning`,
        :exc:`PendingDeprecationWarning` or a custom subclass.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(category=PendingDeprecationWarning)
           def some_old_function(x, y):
               return x + y

        The *action* keyword argument allow you to locally change the warning filtering.
        *action* can be one of "error", "ignore", "always", "default", "module", or "once".
        If ``None``, empty or missing, the the global filtering mechanism is used.
        See: `The Warnings Filter`_ in the Python documentation.

        .. code-block:: python

           from deprecated import deprecated


           @deprecated(action="error")
           def some_old_function(x, y):
               return x + y

        """
>       if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):
E       NameError: name 'types' is not defined

deprecated/classic.py:248: NameError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/deprecated/classic.py b/deprecated/classic.py</span>
<span class="gh">index fc9af25..273dcec 100644</span>
<span class="gd">--- a/deprecated/classic.py</span>
<span class="gi">+++ b/deprecated/classic.py</span>
<span class="gu">@@ -119,7 +119,21 @@ class ClassicAdapter(wrapt.AdapterFactory):</span>

<span class="w"> </span>        :return: The warning message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if instance is None:</span>
<span class="gi">+            if inspect.isclass(wrapped):</span>
<span class="gi">+                fmt = &quot;Call to deprecated class {name}.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt = &quot;Call to deprecated function {name}.&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if inspect.isclass(instance):</span>
<span class="gi">+                fmt = &quot;Call to deprecated class method {name}.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt = &quot;Call to deprecated method {name}.&quot;</span>
<span class="gi">+        if self.reason:</span>
<span class="gi">+            fmt += &quot; ({reason})&quot;</span>
<span class="gi">+        if self.version:</span>
<span class="gi">+            fmt += &quot; -- Deprecated since version {version}.&quot;</span>
<span class="gi">+        return fmt.format(name=wrapped.__name__, reason=self.reason, version=self.version)</span>

<span class="w"> </span>    def __call__(self, wrapped):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -231,4 +245,9 @@ def deprecated(*args, **kwargs):</span>
<span class="w"> </span>           return x + y

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if args and isinstance(args[0], (type, types.FunctionType, types.MethodType)):</span>
<span class="gi">+        return ClassicAdapter()(args[0])</span>
<span class="gi">+    else:</span>
<span class="gi">+        def wrapper(wrapped):</span>
<span class="gi">+            return ClassicAdapter(**kwargs)(wrapped)</span>
<span class="gi">+        return wrapper</span>
<span class="gh">diff --git a/deprecated/sphinx.py b/deprecated/sphinx.py</span>
<span class="gh">index 6daf81f..d91c375 100644</span>
<span class="gd">--- a/deprecated/sphinx.py</span>
<span class="gi">+++ b/deprecated/sphinx.py</span>
<span class="gu">@@ -133,7 +133,13 @@ class SphinxAdapter(ClassicAdapter):</span>
<span class="w"> </span>           Strip Sphinx cross-referencing syntax from warning message.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get the original deprecation message</span>
<span class="gi">+        message = super(SphinxAdapter, self).get_deprecated_msg(wrapped, instance)</span>
<span class="gi">+        </span>
<span class="gi">+        # Strip Sphinx cross-referencing syntax</span>
<span class="gi">+        message = re.sub(r&#39;:(?:class|func|meth|attr|obj|exc|data|const|mod):`~?([^`]+)`&#39;, r&#39;\1&#39;, message)</span>
<span class="gi">+        </span>
<span class="gi">+        return message</span>


<span class="w"> </span>def versionadded(reason=&#39;&#39;, version=&#39;&#39;, line_length=70):
<span class="gu">@@ -157,7 +163,7 @@ def versionadded(reason=&#39;&#39;, version=&#39;&#39;, line_length=70):</span>

<span class="w"> </span>    :return: the decorated function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return SphinxAdapter(&#39;versionadded&#39;, reason=reason, version=version, line_length=line_length)</span>


<span class="w"> </span>def versionchanged(reason=&#39;&#39;, version=&#39;&#39;, line_length=70):
<span class="gu">@@ -180,7 +186,7 @@ def versionchanged(reason=&#39;&#39;, version=&#39;&#39;, line_length=70):</span>

<span class="w"> </span>    :return: the decorated function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return SphinxAdapter(&#39;versionchanged&#39;, reason=reason, version=version, line_length=line_length)</span>


<span class="w"> </span>def deprecated(reason=&#39;&#39;, version=&#39;&#39;, line_length=70, **kwargs):
<span class="gu">@@ -218,4 +224,4 @@ def deprecated(reason=&#39;&#39;, version=&#39;&#39;, line_length=70, **kwargs):</span>
<span class="w"> </span>    .. versionchanged:: 1.2.13
<span class="w"> </span>       Change the signature of the decorator to reflect the valid use cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return SphinxAdapter(&#39;deprecated&#39;, reason=reason, version=version, line_length=line_length, **kwargs)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>